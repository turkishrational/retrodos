     1                                  ; ****************************************************************************
     2                                  ; RETRODOS.SYS (MSDOS 3.3 Kernel) - RETRO DOS v3.3 (for Windows 3.1)
     3                                  ; -Modified Retro DOS v3 for Windows 3.1 compatibility-		by ERDOGAN TAN
     4                                  ; ----------------------------------------------------------------------------
     5                                  ; Last Update: 15/09/2022 (Previous: 03/08/2019)
     6                                  ; ----------------------------------------------------------------------------
     7                                  ; Beginning: 24/02/2018 (Retro DOS 2.0), 25/05/2018 (Retro DOS 3.0)
     8                                  ; ----------------------------------------------------------------------------
     9                                  ; Assembler: NASM version 2.11 (2.15)
    10                                  ; ----------------------------------------------------------------------------
    11                                  ;	    ((nasm retrodos33.s -l retrodos33.lst -o MSDOS.SYS -Z error.txt)) 	
    12                                  ; ----------------------------------------------------------------------------
    13                                  ; This assembly file has three parts: (BIOS+SYSINIT+KERNEL in one kernel file)
    14                                  ; 1a) IBMBIO.COM (IO.SYS) part from beginning to '%incbin MSDOS.BIN'
    15                                  ; 1b) SYSINIT part (at the end of IBMBIO.COM/IO.SYS) as '%incbin SYSINIT.BIN'
    16                                  ; 2) MSDOS.SYS (MSDOS 3.3 Kernel) as included binary file (MSDOS.BIN).
    17                                  ; source : 'retrodos.s' (main), 'sysinit.s' (included), 'msdos.s' (included)	
    18                                  ;
    19                                  ; (Note: RETRO DOS 3.0 boot sector code will load 'MSDOS.SYS' at 1000h:0000h)
    20                                  ; (Original MSDOS 3.3 IBMBIO.COM loads/runs its own init code at 0070h:0000h)
    21                                  
    22                                  ;=============================================================================
    23                                  ; Modified from 'retrodos.s', Retro DOS v1.0 Kernel ("IBMBIO.COM") Source code
    24                                  ; by Erdogan Tan, 20/02/2018
    25                                  ;=============================================================================
    26                                  
    27                                  ; MSBIO (IO.SYS 3.3) source files:
    28                                  ; 	MSBIO1.ASM,MSCON.ASM,MSAUX.ASM,MSLPT.ASM,MSCLOCK.ASM,MSDISK.ASM
    29                                  ;	MSBIO2.ASM,MSHARD.ASM,MSINIT.ASM 
    30                                  ;	SYINIT1.ASM,SYSCONF.ASM,SYSINIT2.ASM,SYSIMES.ASM
    31                                  
    32                                  ;=============================================================================
    33                                  ; 25/08/2022 - 2022 modifications (by comparing with PC-DOS 3.30 IBMBIO.COM)
    34                                  ;=============================================================================
    35                                  ; (Modifications are done for running Windows 3.1 on Retro DOS v3.0 to v3.3)
    36                                  ;-----------------------------------------------------------------------------  
    37                                  
    38                                  ;=============================================================================
    39                                  ; MSBIO
    40                                  ;=============================================================================
    41                                  ;msbio1+mscon+msaux+mslpt+msclock+msdisk+
    42                                  ;msbio2+mshard+msinit+sysinit1+sysconf+sysinit2+sysimes,
    43                                  ;msbio
    44                                  
    45                                  SECTOR_SIZE     equ     0200h		; size of a sector
    46                                  PAUSE_KEY       equ     7200h		; scancode + charcode of PAUSE key
    47                                  KEYBUF_NEXT     equ     041Ah		; next character in keyboard buffer
    48                                  KEYBUF_FREE     equ     041Ch		; next free slot in keyboard buffer
    49                                  KEYBUF          equ     041Eh		; keyboard buffer data
    50                                  LOGICAL_DRIVE   equ     0504h		; linear address of logical drive byte
    51                                  ;DOS_SEGMENT	equ     00BFh ; v1.1	; segment in which DOS will run
    52                                  DOS_SEGMENT	equ     00C4h		; Retro DOS v1.0 - 13/02/2018
    53                                  BIO_SEGMENT     equ     0060h		; segment in which BIO is running
    54                                  
    55                                  ; 24/02/2018 (Retro DOS 2.0 - MSDOS 3.3 "DISKPRM.INC" - 24/07/1987)
    56                                  ; The following structure defines the disk parameter table
    57                                  ; pointed to by Interrupt vector 1EH (location 0:78H)
    58                                  
    59                                  struc	DISK_PARMS
    60 00000000 ??                      .DISK_SPECIFY_1:  resb	1
    61 00000001 ??                      .DISK_SPECIFY_2:  resb	1
    62 00000002 ??                      .DISK_MOTOR_WAIT: resb  1	; Wait till motor off
    63 00000003 ??                      .DISK_SECTOR_SIZ: resb 	1	; Bytes/Sector (2 = 512)
    64 00000004 ??                      .DISK_EOT:	  resb  1	; Sectors per track (MAX)
    65 00000005 ??                      .DISK_RW_GAP:	  resb  1	; Read Write Gap
    66 00000006 ??                      .DISK_DTL:	  resb	1
    67 00000007 ??                      .DISK_FORMT_GAP:  resb  1	; Format Gap Length
    68 00000008 ??                      .DISK_FILL:	  resb  1	; Format Fill Byte
    69 00000009 ??                      .DISK_HEAD_STTL:  resb  1	; Head Settle Time (MSec)
    70 0000000A ??                      .DISK_MOTOR_STRT: resb  1	; Motor start delay
    71                                  .size:
    72                                  endstruc
    73                                  
    74                                  ROMStatus	equ	1
    75                                  ROMRead 	equ	2
    76                                  ROMWrite	equ	3
    77                                  ROMVerify	equ	4
    78                                  ROMFormat	equ	5  
    79                                  
    80                                  ; 24/02/2018 (Retro DOS 2.0 - MSDOS 3.3 "MSBDS.INC" - 24/07/1987)
    81                                  ; -------------------------------------------------------------------------
    82                                  ;  BDS is the Bios Data Structure.
    83                                  ;
    84                                  ;  There is one BDS for each logical drive in the system.  All the BDS's
    85                                  ;  are linked together in a list with the pointer to the first BDS being
    86                                  ;  found in START_BDS.	The BDS hold various values important to the disk
    87                                  ;  drive.  For example there is a field for last time accesses.  As actions
    88                                  ;  take place in the system the BDS are update to reflect the actions.
    89                                  ;  For example is there is a read to a disk the last access field for the
    90                                  ;  BDS for that drive is update to the current time.
    91                                  ;
    92                                  ; Values for various flags in BDS.Flags.
    93                                  ;
    94                                  
    95                                  fNon_Removable	    equ     01H 	;For non-removable media
    96                                  fChangeline	    equ     02H 	;If changeline supported on drive
    97                                  RETURN_FAKE_BPB     equ     04H 	; When set, don't do a build BPB
    98                                  					; just return the fake one
    99                                  GOOD_TRACKLAYOUT    equ     08H 	; The track layout has no funny sectors
   100                                  fI_Am_Mult	    equ     10H 	;If more than one logical for this physical
   101                                  fI_Own_Physical     equ     20H 	;Signify logical owner of this physical
   102                                  fChanged	    equ     40H 	;Indicates media changed
   103                                  SET_DASD_true	    equ     80H 	; Set DASD before next format
   104                                  fChanged_By_Format  equ    100h
   105                                  
   106                                  ;
   107                                  ; Various form factors to describe media
   108                                  ;
   109                                  
   110                                  ff48tpi 	    equ     0
   111                                  ff96tpi 	    equ     1
   112                                  ffSmall 	    equ     2
   113                                  ffHardFile	    equ     5
   114                                  ffOther 	    equ     7
   115                                  ; MSDOS 6.0 ("MSBDS.INC", 1991)
   116                                  ff288		    equ     9	; 2.88 MB drive
   117                                  ; Retro DOS v2.0 feature only !
   118                                  ff144		    equ	   10	; 1.44 MB drive			
   119                                  
   120                                  struc	BDS	; BDS_Type
   121 00000000 ????????                .Link:		resd 1		; Link to next BDS
   122 00000004 ??                      .DriveNum:	resb 1		; Physical drive number
   123 00000005 ??                      .DriveLet:	resb 1		; DOS drive number
   124 00000006 ????                    .BytePerSec:	resw 1		; number of bytes/sec
   125 00000008 ??                      .SecPerClus:	resb 1		; sec per allocation unit
   126 00000009 ????                    .RESSEC:	resw 1		; number of reserved sectors
   127 0000000B ??                      .cFAT:		resb 1		; number of fats
   128 0000000C ????                    .cDir:		resw 1		; number of directory entries
   129 0000000E ????                    .DRVLIM:	resw 1		; number of sectors on medium
   130 00000010 ??                      .Mediad:	resb 1		; media descriptor byte
   131 00000011 ????                    .cSecFat: 	resw 1		; number of sectors/fat
   132 00000013 ????                    .SECLIM:	resw 1		; sectors per track
   133 00000015 ????                    .HDLIM:		resw 1		; max number of heads
   134 00000017 ????                    .HIDSEC:	resw 1		; number of hidden sectors
   135 00000019 ??                      .FatSiz:	resb 1		; flags...
   136 0000001A ????                    .Opcnt:		resw 1		; Open ref. count
   137 0000001C <res Ch>                .Volid:		resb 12		; volume ID of medium
   138 00000028 ??                      .FormFactor:	resb 1		; form factor index
   139 00000029 ????                    .Flags:		resw 1		; various flags
   140 0000002B ????                    .cCyln:		resw 1		; max number of cylinders
   141 0000002D ????                    .RBytePerSec:	resw 1		; Recommended BPB
   142 0000002F ??                      .RSecPerClus:	resb 1
   143 00000030 ????                    .RRESSEC: 	resw 1
   144 00000032 ??                      .RcFAT:		resb 1
   145 00000033 ????                    .RcDir:		resw 1
   146 00000035 ????                    .RDRVLIM: 	resw 1
   147 00000037 ??                      .Rmediad: 	resb 1
   148 00000038 ????                    .RcSecFat:	resw 1
   149 0000003A ????                    .RSECLIM: 	resw 1
   150 0000003C ????                    .RHDLIM:	resw 1
   151 0000003E ????                    .RHIDSEC: 	resw 1
   152 00000040 ????                    .RHHIDSEC:	resw 1
   153 00000042 ????????                .RLOGSEC: 	resd 1
   154 00000046 ????????????            .Reserve: 	resb 6		; Reserved for future
   155 0000004C ??                      .Track:		resb 1		; last track accessed on drive
   156 0000004D ????                    .TIM_LO:	resw 1		; Time of last access. Keep
   157 0000004F ????                    .TIM_HI:	resw 1		; these contiguous.
   158                                  endstruc
   159                                  
   160                                  BPBSize	equ	BDS.Track - BDS.RBytePerSec 
   161                                  				; size in bytes of RecBPB area in the BDS
   162                                  
   163                                  ; 23/03/2018
   164                                  
   165                                  ;STATIC REQUEST HEADER (DEVSYM.INC, MSDOS 6.0, 1991)
   166                                  STRUC SRHEAD
   167 00000000 ??                      .REQLEN:	resb 1		;LENGTH IN BYTES OF REQUEST BLOCK
   168 00000001 ??                      .REQUNIT:	resb 1		;DEVICE UNIT NUMBER
   169 00000002 ??                      .REQFUNC:	resb 1		;TYPE OF REQUEST
   170 00000003 ????                    .REQSTAT:	resw 1		;STATUS WORD
   171 00000005 ????????????????        	       	resb 8		;RESERVED FOR QUEUE LINKS
   172                                  .size:
   173                                  endstruc
   174                                  
   175                                  ; GENERIC IOCTL REQUEST STRUCTURE (DEVSYM.INC, MSDOS 6.0, 1991)
   176                                  ;	SEE THE DOS 4.0 DEVICE DRIVER SPEC FOR FURTHER ELABORATION.
   177                                  ;
   178                                  struc IOCTL_REQ
   179                                  	       ;DB    (SIZE SRHEAD) DUP(?)
   180 00000000 <res Dh>                		resb SRHEAD.size	
   181                                  			    	; GENERIC IOCTL ADDITION.
   182 0000000D ??                      .MAJORFUNCTION:	resb 1		;FUNCTION CODE
   183 0000000E ??                      .MINORFUNCTION:	resb 1		;FUNCTION CATEGORY
   184 0000000F ????                    .REG_SI:	resw 1
   185 00000011 ????                    .REG_DI:	resw 1
   186 00000013 ????????                .GENERICIOCTL_PACKET: resd 1	; POINTER TO DATA BUFFER
   187                                  endstruc
   188                                  
   189                                  ; GENERIC IOCTL CATEGORY CODES  (IOCTL.INC, MSDOS 6.0, 1991)
   190                                  IOC_OTHER	EQU	0	; Other device control J.K. 4/29/86
   191                                  IOC_SE		EQU	1	; SERIAL DEVICE CONTROL
   192                                  IOC_TC		EQU	2	; TERMINAL CONTROL
   193                                  IOC_SC		EQU	3	; SCREEN CONTROL
   194                                  IOC_KC		EQU	4	; KEYBOARD CONTROL
   195                                  IOC_PC		EQU	5	; PRINTER CONTROL
   196                                  IOC_DC		EQU	8	; DISK CONTROL (SAME AS RAWIO)
   197                                  
   198                                  ; DEFINITIONS FOR IOCTL_REQ.MINORFUNCTION
   199                                  GEN_IOCTL_WRT_TRK   EQU   40H
   200                                  GEN_IOCTL_RD_TRK    EQU   60H
   201                                  GEN_IOCTL_FN_TST    EQU   20H	; USED TO DIFF. BET READS AND WRTS
   202                                  
   203                                  ;struc A_RETRYCOUNT  ; (IOCTL.INC, MSDOS 6.0, 1991)
   204                                  ;.RC_COUNT:	resw 	1
   205                                  ;endstruc
   206                                  
   207                                  ; 27/03/2018 - DEVSYM.INC - MSDOS 3.3 - 24/07/1987
   208                                  
   209                                  ;
   210                                  ; ATTRIBUTE BIT MASKS
   211                                  ;
   212                                  ; CHARACTER DEVICES:
   213                                  ;
   214                                  ; BIT 15 -> MUST BE 1
   215                                  ;     14 -> 1 IF THE DEVICE UNDERSTANDS IOCTL CONTROL STRINGS
   216                                  ;     13 -> 1 IF THE DEVICE SUPPORTS OUTPUT-UNTIL-BUSY
   217                                  ;     12 -> UNUSED
   218                                  ;     11 -> 1 IF THE DEVICE UNDERSTANDS OPEN/CLOSE
   219                                  ;     10 -> MUST BE 0
   220                                  ;      9 -> MUST BE 0
   221                                  ;      8 -> UNUSED
   222                                  ;      7 -> UNUSED
   223                                  ;      6 -> UNUSED
   224                                  ;      5 -> UNUSED
   225                                  ;      4 -> 1 IF DEVICE IS RECIPIENT OF INT 29H
   226                                  ;      3 -> 1 IF DEVICE IS CLOCK DEVICE
   227                                  ;      2 -> 1 IF DEVICE IS NULL DEVICE
   228                                  ;      1 -> 1 IF DEVICE IS CONSOLE OUTPUT
   229                                  ;      0 -> 1 IF DEVICE IS CONSOLE INPUT
   230                                  ;
   231                                  ; BLOCK DEVICES:
   232                                  ;
   233                                  ; BIT 15 -> MUST BE 0
   234                                  ;     14 -> 1 IF THE DEVICE UNDERSTANDS IOCTL CONTROL STRINGS
   235                                  ;     13 -> 1 IF THE DEVICE DETERMINES MEDIA BY EXAMINING THE FAT ID BYTE.
   236                                  ;	    THIS REQUIRES THE FIRST SECTOR OF THE FAT TO *ALWAYS* RESIDE IN
   237                                  ;	    THE SAME PLACE.
   238                                  ;     12 -> UNUSED
   239                                  ;     11 -> 1 IF THE DEVICE UNDERSTANDS OPEN/CLOSE/REMOVABLE MEDIA
   240                                  ;     10 -> MUST BE 0
   241                                  ;      9 -> MUST BE 0
   242                                  ;      8 -> UNUSED
   243                                  ;      7 -> UNUSED
   244                                  ;      6 -> IF DEVICE HAS SUPPORT FOR GETMAP/SETMAP OF LOGICAL DRIVES.
   245                                  ;	    IF THE DEVICE UNDERSTANDS GENERIC IOCTL FUNCTION CALLS.
   246                                  ;      5 -> UNUSED
   247                                  ;      4 -> UNUSED
   248                                  ;      3 -> UNUSED
   249                                  ;      2 -> UNUSED
   250                                  ;      1 -> UNUSED
   251                                  ;      0 -> UNUSED
   252                                  ;
   253                                  
   254                                  DEVTYP	       EQU   8000H	    ; BIT 15 - 1  IF CHAR, 0 IF BLOCK
   255                                  CHARDEV        EQU   8000H
   256                                  DEVIOCTL       EQU   4000H	    ; BIT 14 - CONTROL MODE BIT
   257                                  ISFATBYDEV     EQU   2000H	    ; BIT 13 - DEVICE USES FAT ID BYTES,
   258                                  				    ;  COMP MEDIA.
   259                                  OUTTILBUSY     EQU   2000H	    ; OUTPUT UNTIL BUSY IS ENABLED
   260                                  ISNET	       EQU   1000H	    ; BIT 12 - 1 IF A NET DEVICE, 0 IF
   261                                  				    ;  NOT.  CURRENTLY BLOCK ONLY.
   262                                  DEVOPCL        EQU   0800H	    ; BIT 11 - 1 IF THIS DEVICE HAS
   263                                  				    ;  OPEN,CLOSE AND REMOVABLE MEDIA
   264                                  				    ;  ENTRY POINTS, 0 IF NOT
   265                                  
   266                                  EXTENTBIT      EQU   0400H	    ; BIT 10 - CURRENTLY 0 ON ALL DEVS
   267                                  				    ;  THIS BIT IS RESERVED FOR FUTURE USE
   268                                  				    ;  TO EXTEND THE DEVICE HEADER BEYOND
   269                                  				    ;  ITS CURRENT FORM.
   270                                  
   271                                  ; NOTE BIT 9 IS CURRENTLY USED ON IBM SYSTEMS TO INDICATE "DRIVE IS SHARED".
   272                                  ;    SEE IOCTL FUNCTION 9. THIS USE IS NOT DOCUMENTED, IT IS USED BY SOME
   273                                  ;    OF THE UTILITIES WHICH ARE SUPPOSED TO FAIL ON SHARED DRIVES ON SERVER
   274                                  ;    MACHINES (FORMAT,CHKDSK,RECOVER,..).
   275                                  
   276                                  DEV320	       EQU   0040H	    ;BIT 6 - FOR BLOCK DEVICES, THIS
   277                                  				    ;DEVICE SUPPORTS SET/GET MAP OF
   278                                  				    ;LOGICAL DRIVES, AND SUPPORTS
   279                                  				    ;GENERIC IOCTL CALLS.
   280                                  				    ;FOR CHARACTER DEVICES, THIS
   281                                  				    ;DEVICE SUPPORTS GENERIC IOCTL.
   282                                  				    ;THIS IS A DOS 3.2 DEVICE DRIVER.
   283                                  ISSPEC	       EQU   0010H	    ;BIT 4 - THIS DEVICE IS SPECIAL
   284                                  ISCLOCK        EQU   0008H	    ;BIT 3 - THIS DEVICE IS THE CLOCK DEVICE.
   285                                  ISNULL	       EQU   0004H	    ;BIT 2 - THIS DEVICE IS THE NULL DEVICE.
   286                                  ISCOUT	       EQU   0002H	    ;BIT 1 - THIS DEVICE IS THE CONSOLE OUTPUT.
   287                                  ISCIN	       EQU   0001H	    ;BIT 0 - THIS DEVICE IS THE CONSOLE INPUT.
   288                                  
   289                                  
   290                                  ; 19/03/2018
   291                                  
   292                                  ;*********************************************************************
   293                                  ;	BDS structure for mini disk
   294                                  ;*********************************************************************	  
   295                                  									  
   296                                  struc	BDSM	; BDSM_type
   297 00000000 ????                    .mLink:		resw	1 ; DW -1		;Link to next structure   
   298 00000002 ????                    		resw	1 ; DW ?
   299 00000004 ??                      .mDriveNum:	resb	1 ; DB 80h		;Int 13 Drive Number	  
   300 00000005 ??                      .mDriveLet:	resb	1 ; DB 3		;Logical Drive Number	  
   301 00000006 ????                    .mBytePerSec:	resw 	1 ; DW 512
   302 00000008 ??                      .mSecPerClus:	resb	1 ; DB 1		;Sectors/allocation unit  
   303 00000009 ????                    .mRESSEC:	resw	1 ; DW 1		;Reserved sectors for DOS 
   304 0000000B ??                      .mcFAT:		resb	1 ; DB 2		;No. of allocation tables 
   305 0000000C ????                    .mcDIR:		resw	1 ; DW 16		;Number of directory entries
   306 0000000E ????                    .mDRVLIM:	resw 	1 ; DW 0		;Num of sectors (at 512 bytes each)
   307 00000010 ??                      .mMediad:	resb	1 ; DB 11111000b	;Media descriptor	  
   308 00000011 ????                    .mcSecFat:	resw 	1 ; DW 1		;Number of FAT sectors	  
   309 00000013 ????                    .mSECLIM:	resw 	1 ; DW 0		;Sector limit		  
   310 00000015 ????                    .mHDLIM:	resw	1 ; DW 0		;Head limit		  
   311 00000017 ????                    .mHIDSEC:	resw 	1 ; DW 0		;Hidden sector count	  
   312 00000019 ??                      .mFatSiz:	resb 	1 ; DB 0		;TRUE => bigfat 	  
   313 0000001A ????                    .mOPCNT:	resw	1 ; DW 0		;Open Ref. Count	  
   314 0000001C <res Bh>                .mVOLID:	resb   11 ; DB "NO NAME    "    ;Volume ID for this disk  
   315 00000027 ??                      		resb 	1 ; DB 0		;ASCIZII for "NO NAME    "
   316 00000028 ??                      .mFormFactor:	resb 	1 ; DB 3		;Form Factor		  
   317 00000029 ????                    .mFLAGS:	resw	1 ; DW 0020H		;Various Flags		  
   318 0000002B ????                    .mcCyln:	resw	1 ; DW 40		;max number of cylinders  
   319 0000002D <res 1Fh>               .mRecBPB:	resb   31 ; DB 31 DUP (0) 	;Recommended BPB for drive
   320 0000004C ??                      .mTrack:	resb	1 ; DB -1						  
   321 0000004D ????                    .isMini:	resw	1 ; DW 1		;Overlapping TIM_LOH	  
   322 0000004F ????                    .Hidden_Trks:	resw 	1 ; DW 0		;Overlapping TIM_HIH	  
   323                                  									  
   324                                  ;.TIM_LOH:	resw	1 ; DW -1		;Keep these two contiguous (?)   
   325                                  ;.TIM_HIH:	resw	1 ; DW -1
   326                                  .size:							  
   327                                  
   328                                  endstruc
   329                                  
   330                                  ; 27/05/2018 - Retro DOS v3.0 
   331                                  ; [MSDOS 3.3, MSDISK.ASM]
   332                                  
   333                                  struc INT13FRAME
   334 00000000 ????                    .oldbp:	resw 1
   335 00000002 ????                    .oldax:	resw 1
   336 00000004 ????                    .oldbx:	resw 1
   337 00000006 ????                    .oldcx:	resw 1
   338 00000008 ????                    .olddx:	resw 1
   339 0000000A ????????                .olddd:	resd 1
   340 0000000E ????                    .oldf:	resw 1
   341                                  .size:
   342                                  endstruc
   343                                  
   344                                  ; 02/06/2018 - Retro DOS v3.0
   345                                  ; [MSDOS 3.3, BIOSTRUC.INC]
   346                                  
   347                                  struc ROMBIOS_DESC		; BIOS_SYSTEM_DESCRIPTOR						  
   348 00000000 ????                    .bios_SD_leng:		resw 1				  
   349 00000002 ??                      .bios_SD_modelbyte:	resb 1					  
   350                                  .bios_SD_scnd_modelbyte: 
   351 00000003 ??                      			resb 1					  
   352 00000004 ??                      			resb 1					  
   353 00000005 ??                      .bios_SD_featurebyte1:	resb 1					  
   354 00000006 ????????                			resb 4					  
   355                                  endstruc
   356                                  							  
   357                                  ;******************************************************************************
   358                                  Max_mini_dsk_num equ	23		; Max # of mini disk bios can support
   359                                  
   360                                  
   361                                  KERNEL_SEGMENT	equ 0070h  ; Retro DOS v2.0 - 17/03/2018
   362                                  
   363                                  ;-----------------------------------------------------------------------------
   364                                  ; Start of code
   365                                  ;-----------------------------------------------------------------------------
   366                                  
   367                                          	[ORG 0]			; segment 0x0060
   368                                  
   369                                  ;-----------------------------------------------------------------------------
   370                                  ; MSDATA.INC - MSDOS 3.3 BIOS - 24/07/1987
   371                                  ;-----------------------------------------------------------------------------
   372                                  ; 21/03/2018 - Retro DOS v2.0
   373                                  
   374                                  START$:
   375 00000000 E90D2A                  		JMP	INIT		; START$ patch by init to point to
   376                                  					; hdrive BPB
   377                                  
   378                                  SYS_INIT_START EQU SYSINIT_START - START$
   379                                  KERNEL_BYTES EQU END_OF_KERNEL - START$
   380                                  MSDOS_BIN_ADDRESS EQU MSDOS_BIN_OFFSET - START$
   381                                  
   382                                  %define SYSINITSEG SYS_INIT_START >> 4  ; 26/03/2018
   383                                  %define MSDOS_BIN_SEGMENT MSDOS_BIN_ADDRESS >> 4 ; 26/03/2018 
   384                                  %define KERNEL_SIZE KERNEL_BYTES >> 1 ; Retro DOS v2.0 - 26/03/2018
   385                                  
   386                                  
   387                                  ;----------------------------------------------------------------------------
   388                                  ;
   389                                  ;		Command Jump Tables
   390                                  ;
   391                                  ;     These tables hold the entry points for the various service routines
   392                                  ; for the different drivers.  The index in the table is the command code for
   393                                  ; that funcion plus two.  For example the command code for Read (input) is 4,
   394                                  ; The 6th (4 plus 2) entry in the table DSKTBL is DSK$READ - the command to
   395                                  ; read a disk.	Commands which do not exist for a device are filled with
   396                                  ; exit (e.g. MediaCheck for CONTBL).  The first entry in the table is the
   397                                  ; largest command code implemented for that device.  This value is used
   398                                  ; for error checking.  If new command codes are added then the first entry
   399                                  ; in the table must be incremented.
   400                                  ;
   401                                  ;	BEWARE - These tables overlap somewhat! -c.p.
   402                                  ;
   403                                  
   404                                  ;align 2
   405                                  
   406                                  		; 08/04/2018
   407                                  		; Retro DOS v2.0 (IBMBIO.COM, IBMDOS 2.1)
   408                                  		; ((Disassembler: IDA Pro Free))
   409                                  
   410                                  ;
   411                                  ; Disk:
   412                                  ;
   413                                  
   414                                  		;nop
   415                                  DSKTBL:
   416 00000003 18                      		DB	24		; This is the size of the table YUK!!!!
   417 00000004 [D319]                  		DW	DSK$INIT	; code	0: INIT
   418 00000006 [7509]                  		DW	MEDIA$CHK	; code	1: Media Check
   419 00000008 [250A]                  		DW	GET$BPB 	; code	2: BUILD BPB
   420 0000000A [3506]                  		DW	CMDERR		; code	3: IOCTL input
   421 0000000C [3A0C]                  		DW	DSK$READ	; code	4: INPUT
   422 0000000E [3106]                  		DW	BUS$EXIT	; code	5: NONDESTRUCITVE INPUT, NO WAIT
   423 00000010 [4C06]                  		DW	EXIT		; code	6: INPUT STATUS
   424 00000012 [4C06]                  		DW	EXIT		; code	7: INPUT FLUSH
   425 00000014 [280C]                  		DW	DSK$WRIT	; code	8: OUTPUT
   426 00000016 [1F0C]                  		DW	DSK$WRITV	; code	9: OUTPUT with verify
   427 00000018 [4C06]                  		DW	EXIT		; code 10: OUTPUT STATUS
   428 0000001A [4C06]                  		DW	EXIT		; code 11: OUTPUT FLUSH
   429 0000001C [3506]                  		DW	CMDERR		; code 12: IOCTL output
   430                                  TABLE_PATCH:
   431 0000001E [B31B]                  		DW	DSK$OPEN	; code 13: DEVICE OPEN
   432 00000020 [BC1B]                  		DW	DSK$CLOSE	; code 14: DEVICE CLOSE
   433 00000022 [E50B]                  		DW	DSK$REM 	; code 15: REMOVABLE MEDIA
   434 00000024 [4C06]                  		DW	EXIT
   435 00000026 [4C06]                  		DW	EXIT
   436 00000028 [4C06]                  		DW	EXIT
   437 0000002A [9412]                  		DW	GENERIC$IOCTL
   438 0000002C [4C06]                  		DW	EXIT
   439 0000002E [4C06]                  		DW	EXIT
   440 00000030 [4C06]                  		DW	EXIT
   441 00000032 [D416]                  		DW	IOCTL$GETOWN
   442 00000034 [F616]                  		DW	IOCTL$SETOWN
   443                                  
   444                                  
   445                                  ;
   446                                  ; Console:
   447                                  ;
   448                                  		;nop
   449 00000036 00                      		db	0
   450                                  CONTBL:
   451 00000037 0A                      		DB	10
   452 00000038 [4C06]                  		DW	EXIT
   453 0000003A [4C06]                  		DW	EXIT
   454 0000003C [4C06]                  		DW	EXIT
   455 0000003E [3506]                  		DW	CMDERR
   456 00000040 [7606]                  		DW	CON$READ
   457 00000042 [A206]                  		DW	CON$RDND
   458 00000044 [4C06]                  		DW	EXIT
   459 00000046 [E406]                  		DW	CON$FLSH
   460 00000048 [FC06]                  		DW	CON$WRIT
   461 0000004A [FC06]                  		DW	CON$WRIT
   462 0000004C [4C06]                  		DW	EXIT
   463                                  
   464                                  ;
   465                                  ; Auxilary:
   466                                  ;
   467                                  		;nop
   468 0000004E 00                      		db	0
   469                                  AUXTBL:
   470 0000004F 0A                      		DB	10
   471 00000050 [4C06]                  		DW	EXIT
   472 00000052 [4C06]                  		DW	EXIT
   473 00000054 [4C06]                  		DW	EXIT
   474 00000056 [3506]                  		DW	CMDERR
   475 00000058 [1007]                  		DW	AUX$READ
   476 0000005A [3707]                  		DW	AUX$RDND
   477 0000005C [4C06]                  		DW	EXIT
   478 0000005E [7007]                  		DW	AUX$FLSH
   479 00000060 [7907]                  		DW	AUX$WRIT
   480 00000062 [7907]                  		DW	AUX$WRIT
   481 00000064 [5907]                  		DW	AUX$WRST
   482                                  
   483                                  ;
   484                                  ; Clock:
   485                                  ;
   486                                  		;nop
   487 00000066 00                      		db	0
   488                                  TIMTBL:
   489 00000067 09                      		DB	9
   490 00000068 [4C06]                  		DW	EXIT
   491 0000006A [4C06]                  		DW	EXIT
   492 0000006C [4C06]                  		DW	EXIT
   493 0000006E [3506]                  		DW	CMDERR
   494 00000070 [1A09]                  		DW	TIM$READ
   495 00000072 [3106]                  		DW	BUS$EXIT
   496 00000074 [4C06]                  		DW	EXIT
   497 00000076 [4C06]                  		DW	EXIT
   498 00000078 [7B08]                  		DW	TIM$WRIT
   499 0000007A [7B08]                  		DW	TIM$WRIT
   500                                  
   501                                  ;
   502                                  ; Printer:
   503                                  ;
   504                                  		;nop
   505 0000007C 00                      		db	0
   506                                  PRNTBL:
   507 0000007D 18                      		DB	24
   508 0000007E [4C06]                  		DW	EXIT			;INIT
   509 00000080 [4C06]                  		DW	EXIT
   510 00000082 [4C06]                  		DW	EXIT
   511 00000084 [3506]                  		DW	CMDERR
   512 00000086 [4306]                  		DW	EXIT$ZER		;INDICATE ZERO CHARS READ
   513 00000088 [3106]                  		DW	BUS$EXIT
   514 0000008A [4C06]                  		DW	EXIT
   515 0000008C [4C06]                  		DW	EXIT
   516 0000008E [9D07]                  		DW	PRN$WRIT
   517 00000090 [9D07]                  		DW	PRN$WRIT
   518 00000092 [B907]                  		DW	PRN$STAT
   519 00000094 [4C06]                  		DW	EXIT
   520 00000096 [4C06]                  		DW	EXIT
   521 00000098 [4C06]                  		DW	EXIT
   522 0000009A [4C06]                  		DW	EXIT
   523 0000009C [4C06]                  		DW	EXIT
   524 0000009E [E907]                  		DW	PRN$TILBUSY
   525 000000A0 [4C06]                  		DW	EXIT
   526 000000A2 [4C06]                  		DW	EXIT
   527 000000A4 [2F08]                  		DW	PRN$GENIOCTL
   528 000000A6 [4C06]                  		DW	EXIT
   529 000000A8 [4C06]                  		DW	EXIT
   530 000000AA [4C06]                  		DW	EXIT
   531 000000AC [3506]                  		DW	CMDERR
   532 000000AE [3506]                  		DW	CMDERR
   533                                  
   534                                  ; 11/06/2018 - Retro DOS v3.0 (MSDOS 3.3, MSDATA.INC, 24/07/1987) 
   535                                  
   536                                  	;EVENB
   537                                  align 2
   538                                  OLD13:
   539 000000B0 35393836                		db	'5986'		;Code for 3.30
   540                                  ORIG13:
   541 000000B4 32310000                		db	'21',0,0	;Code for 3.30
   542                                  
   543                                  ;
   544                                  ; PTRSAV - pointer save
   545                                  ;
   546                                  ;   This variable holds the pointer to the Request Header passed by a
   547                                  ; program wishing to use a device driver.  When the strategy routine is
   548                                  ; called it puts the address of the Request header in this variable and
   549                                  ; returns.
   550                                  ;
   551                                  
   552                                  	;EVENB
   553                                  PTRSAV:
   554 000000B8 00000000                		DD	0
   555                                  
   556                                  AUXBUF:
   557 000000BC 00000000                		DB	0,0,0,0	; SET OF 1 BYTE BUFFERS FOR COM 1,2,3, AND 4
   558                                  
   559                                  
   560                                  ; 12/06/2018 - Retro DOS v3.0 (MSDOS 3.3, MSDATA.INC, 24/07/1987)
   561                                  
   562                                  	; EVENB
   563                                  align 2
   564                                  
   565                                  PrevOper:
   566 000000C0 0000                    		DW	0	; Holds ROM DISK INT request (i.e. Register AX).
   567                                  Number_Of_Sec:
   568 000000C2 00                      		DB	0	; Holds number of sectors to read on an ECC error
   569                                  
   570                                  ;;Rev 3.30 Modification
   571                                  ;	IF	($-CODE) GT 100H
   572                                  ;	    %OUT VDISK BUFFER NOT CORRECTLY LOCATED
   573                                  ;	ELSE
   574                                  ;	    ORG 100H
   575                                  ;	ENDIF
   576                                  ;	PUBLIC	VDISK_AREA
   577                                  ;VDISK_AREA DB	108 DUP(0)	;FOR USE BY VDISK
   578                                  ;;End of Modification
   579                                  
   580                                  ;align 256 ; 13/06/2018
   581                                  	; 25/08/2022 - IBMBIO.COM (IBMBIO33.IDB) compatibility (db 169 dup(0)) 
   582                                  	;times	61 db 0
   583                                  
   584                                  VDISK_AREA:
   585 000000C3 00<rep 6Ch>             	times	108 db 	0	;FOR USE BY VDISK	
   586                                  
   587                                  ;align 2
   588                                  
   589                                  ;
   590                                  ; AUXNUM holds the number of the printer or AUX device requested.  For
   591                                  ; example if printer 2 was called (PRN2$IN) AUXNUM is set to be one; with
   592                                  ; line printer 3 AUXNUM is set to 2.  With this set the printer device driver
   593                                  ; can tell which printer to command applies to.
   594                                  ;
   595                                  ; WARNING!!!  These are addressed together in GETDX
   596                                  ;
   597                                  
   598                                  	;EVENB
   599                                  
   600                                  AUXNUM:
   601 0000012F 00                      		DB	0
   602 00000130 00                      		DB	0
   603                                  
   604                                  ;
   605                                  ; Device Header for the CON Device Driver
   606                                  ;
   607                                  
   608                                  	;EVENB
   609                                  
   610                                  ;align 2
   611                                  
   612                                  CONHeader:
   613                                  		;DD	AUXDEV2
   614 00000131 [4301]                  		DW	AUXDEV2
   615 00000133 7000                    		DW	KERNEL_SEGMENT ; 27/03/2018
   616 00000135 1380                    		DW	1000000000010011B	; Con in and con out + special
   617 00000137 [A005]                  		DW	STRATEGY		; Strategy entry point
   618 00000139 [AB05]                  		DW	CON$IN			; interrupt entry point
   619 0000013B 434F4E2020202020        		DB	'CON     '              ; device name
   620                                  
   621                                  
   622                                  ;
   623                                  ; Device Header for device "AUX"
   624                                  ;
   625                                  
   626                                  	;EVENB
   627                                  ;align 2
   628                                  
   629                                  AUXDEV2:					;HEADER FOR DEVICE "AUX"
   630                                  		;DD	PRNDEV2
   631 00000143 [5501]                  		DW	PRNDEV2
   632 00000145 7000                    		DW	KERNEL_SEGMENT ; 27/03/2018
   633 00000147 0080                    		DW	1000000000000000B	; attribute word, character device
   634 00000149 [A005]                  		DW	STRATEGY		; device strategy routine
   635 0000014B [B105]                  		DW	AUX0$IN 		; device interrupt routine
   636 0000014D 4155582020202020        		DB	'AUX     '              ; device name
   637                                  
   638                                  
   639                                  ;
   640                                  ; Device Header for device PRN
   641                                  ;
   642                                  
   643                                  	;EVENB
   644                                  ;align 2
   645                                  
   646                                  PRNDEV2:					 ;HEADER FOR DEVICE "PRN"
   647                                  		;DD	TIMDEV
   648 00000155 [6701]                  		DW	TIMDEV
   649 00000157 7000                    		DW	KERNEL_SEGMENT ; 27/03/2018
   650 00000159 40A0                    		DW	CHARDEV + OUTTILBUSY + DEV320
   651 0000015B [A005]                  		DW	STRATEGY
   652 0000015D [CC05]                  		DW	PRN0$IN
   653 0000015F 50524E2020202020        		DB	'PRN     '
   654                                  
   655                                  
   656                                  ;
   657                                  ; Device Header for device CLOCK$
   658                                  ;
   659                                  
   660                                  	;EVENB
   661                                  ;align 2
   662                                  
   663                                  TIMDEV:
   664                                  		;DD	DSKDEV
   665 00000167 [7901]                  		DW	DSKDEV
   666 00000169 7000                    		DW	KERNEL_SEGMENT ; 27/03/2018
   667 0000016B 0880                    		DW	1000000000001000B
   668 0000016D [A005]                  		DW	STRATEGY
   669 0000016F [F205]                  		DW	TIM$IN
   670 00000171 434C4F434B242020        		DB	'CLOCK$  '
   671                                  
   672                                  ;
   673                                  ; Device Header for disk devices
   674                                  ;
   675                                  ;	Device attribute bits:
   676                                  ;		Bit 6 - DOS 3.2 Bit
   677                                  ;
   678                                  
   679                                  	;EVENB
   680                                  ;align 2
   681                                  
   682                                  DSKDEV:
   683                                  		;DD	COM1DEV
   684 00000179 [8E01]                  		DW	COM1DEV
   685 0000017B 7000                    		DW	KERNEL_SEGMENT ; 27/03/2018
   686 0000017D 4008                    		DW	0000100001000000B	; DOS 3.2
   687 0000017F [A005]                  		DW	STRATEGY		; strategy routine
   688 00000181 [F805]                  		DW	DSK$IN			; Interrupt entry point
   689                                  
   690                                  ;
   691                                  ; maximum number of drives
   692                                  ;
   693                                  
   694                                  DRVMAX:
   695 00000183 04                      		DB	4
   696                                  
   697                                  ; 25/05/2018 - Retro DOS 3.0
   698 00000184 FE                      STEP_DRV:	DB	-2
   699 00000185 00                      PHYS_DRV:	DB	0
   700                                  
   701                                  ; 11/06/2018 - Retro DOS 3.0
   702 00000186 00                      fHave96:	db	0
   703 00000187 00                      fHaveK09:	db	0
   704 00000188 00                      Single:		db	0 ; 13/06/2018
   705 00000189 00                      fSetOwner:	db	0
   706 0000018A 00                      NEW_ROM:	db	0
   707 0000018B 6B6A                    Secrete_Code:	dw	'kj'		;Code for 3.30.
   708                                  
   709                                  ;
   710                                  ; Last drive accessed
   711                                  ;
   712                                  
   713                                  		; 09/04/2018
   714                                  ;MEDIACHK_DRV:  ;; 13/04/2018
   715                                  ;		DB	0  ; 25/05/2018 
   716                                  		
   717                                  ;TIM_LO:
   718                                  ;		Dw	0FFFFh
   719                                  ;TIM_HI:
   720                                  ;		Dw	0FFFFh
   721                                  ;WRTVERIFY:
   722                                  ;RFLAG:
   723                                  ;		DB	ROMRead		;2 for read, 3 for write
   724                                  ;VERIFY:
   725                                  ;		DB	0		;1 if verify after write
   726                                  ;Single:
   727                                  ;		DB	0
   728                                  ;CURSECBUF:
   729                                  ;		DB	0
   730                                  ;SECCNT:
   731                                  ;		DW	0
   732                                  ;HARDNUM:
   733                                  ;		DB	99		;logical drive number of first hardfile	
   734                                  ;DRVNUM:
   735                                  ;		DB	0
   736                                  ;CURHD:
   737                                  ;		DB	0
   738                                  ;CURSEC:
   739                                  ;		DB	0
   740                                  ;CURTRK:
   741                                  ;		DW	0
   742                                  ;SPSAV:
   743                                  ;		DW	0
   744                                  
   745                                  ;
   746                                  ; Device Header for device "COM1"
   747                                  ;
   748                                  
   749                                  	;EVENB
   750                                  
   751 0000018D 90                      align 2
   752                                  
   753                                  COM1DEV:
   754                                  		;DD	LPT1DEV
   755 0000018E [A001]                  		DW	LPT1DEV
   756 00000190 7000                    		DW	KERNEL_SEGMENT ; 27/03/2018
   757 00000192 0080                    		DW	1000000000000000B ; attribute word, character device
   758 00000194 [A005]                  		DW	STRATEGY	; device strategy routine
   759 00000196 [B105]                  		DW	AUX0$IN 	; device interrupt routine
   760 00000198 434F4D3120202020        		DB	'COM1    '	; device name
   761                                  
   762                                  
   763                                  ;
   764                                  ; Device Header for device LPT1
   765                                  ;
   766                                  
   767                                  	;EVENB
   768                                  ;align 2
   769                                  
   770                                  LPT1DEV:
   771                                  		;DD	LPT2DEV
   772 000001A0 [B201]                  		DW	LPT2DEV
   773 000001A2 7000                    		DW	KERNEL_SEGMENT ; 27/03/2018
   774 000001A4 40A0                    		DW	CHARDEV + OUTTILBUSY + DEV320
   775 000001A6 [A005]                  		DW	STRATEGY
   776 000001A8 [D205]                  		DW	PRN1$IN ; 03/08/2019
   777 000001AA 4C50543120202020        		DB	'LPT1    '
   778                                  
   779                                  
   780                                  ;
   781                                  ; Device Header for device LPT2
   782                                  ;
   783                                  
   784                                  	;EVENB
   785                                  ;align 2
   786                                  LPT2DEV:
   787                                  		;DD	LPT3DEV
   788 000001B2 [C401]                  		DW	LPT3DEV
   789 000001B4 7000                    		DW	KERNEL_SEGMENT ; 27/03/2018
   790 000001B6 40A0                    		DW	CHARDEV + OUTTILBUSY + DEV320
   791 000001B8 [A005]                  		DW	STRATEGY
   792 000001BA [DA05]                  		DW	PRN2$IN ; 03/08/2019
   793 000001BC 4C50543220202020        		DB	'LPT2    '
   794                                  
   795                                  ;
   796                                  ; Device Header for device LPT3
   797                                  ;
   798                                  
   799                                  	;EVENB
   800                                  ;align 2
   801                                  
   802                                  LPT3DEV:
   803                                  		;DD	COM2DEV
   804 000001C4 [D601]                  		DW	COM2DEV
   805 000001C6 7000                    		DW	KERNEL_SEGMENT ; 27/03/2018
   806 000001C8 40A0                    		DW	CHARDEV + OUTTILBUSY + DEV320
   807 000001CA [A005]                  		DW	STRATEGY
   808 000001CC [E205]                  		DW	PRN3$IN ; 03/08/2019
   809 000001CE 4C50543320202020        		DB	'LPT3    '
   810                                  
   811                                  		; 25/05/2018
   812                                  
   813                                  ;
   814                                  ; Device Header for device "COM2"
   815                                  ;
   816                                  
   817                                  	;EVENB
   818                                  
   819                                  ;align 2
   820                                  
   821                                  COM2DEV:
   822                                  		;DD	COM3DEV
   823 000001D6 [E801]                  		DW	COM3DEV
   824 000001D8 7000                    		DW	KERNEL_SEGMENT
   825 000001DA 0080                    		DW	1000000000000000B	; attribute word, character device
   826 000001DC [A005]                  		DW	STRATEGY		; device strategy routine
   827 000001DE [B705]                  		DW	AUX1$IN 		; device interrupt routine
   828 000001E0 434F4D3220202020        		DB	'COM2    '              ; device name
   829                                  
   830                                  ;;Rev 3.30 Modification
   831                                  ;
   832                                  ; Device header for device "COM3"
   833                                  ;
   834                                  
   835                                  	;EVENB
   836                                  
   837                                  ;align 2 
   838                                  
   839                                  COM3DEV:
   840                                  		;DD	COM4DEV
   841 000001E8 [FA01]                  		DW	COM4DEV
   842 000001EA 7000                    		DW	KERNEL_SEGMENT
   843 000001EC 0080                    		DW	1000000000000000b	; character device attribute
   844 000001EE [A005]                  		DW	STRATEGY
   845 000001F0 [BD05]                  		DW	AUX2$IN			; com3 == aux2
   846 000001F2 434F4D3320202020        		DB	'COM3    '
   847                                  
   848                                  ;
   849                                  ; Device header for device "COM4"
   850                                  ;
   851                                  
   852                                  	;EVENB
   853                                  
   854                                  ;align 2 
   855                                  
   856                                  COM4DEV:
   857 000001FA FFFF                    		DW	-1
   858 000001FC 7000                    		DW	KERNEL_SEGMENT
   859 000001FE 0080                    		DW	1000000000000000b	; character device attribute
   860 00000200 [A005]                  		DW	STRATEGY
   861 00000202 [C305]                  		DW	AUX3$IN			; com4 == aux3
   862 00000204 434F4D3420202020        		DB	'COM4    '
   863                                  
   864                                  
   865                                  ; Hard-wire the link to the next Int2f handler.
   866                                  ;;Rev 3.30 Modification
   867                                  		
   868                                  		;EVENB
   869                                  ;align 2
   870                                  
   871                                  NEXT2F_13:
   872                                  		; 13/06/2018
   873 0000020C [DF19]                  		DW	INT2F_DISK		; MSBIO2.ASM
   874 0000020E 7000                    		DW	KERNEL_SEGMENT
   875                                  
   876                                  ;
   877                                  ; Start of linked list of BDS's
   878                                  ;
   879                                  
   880                                  		;EVENB
   881                                  ;align 2
   882                                  
   883                                  START_BDS:
   884                                  		; 13/06/2018
   885 00000210 [4604]                         		Dw      BDS1			;START OF BDS LINKED LIST.
   886 00000212 7000                    		DW	KERNEL_SEGMENT
   887                                  
   888                                  ;;End of Modification
   889                                  
   890                                  
   891                                  ;
   892                                  ; Some floppy drives do not have changeline support.  The result is a
   893                                  ; large amount of inefficiency in the code.  A media-check always returns
   894                                  ; "I don`t know".  This cause DOS to reread the FAT on every access and
   895                                  ; always discard any cached data.
   896                                  ;    We get around this inefficiency by implementing a "Logical Door Latch".
   897                                  ; The following three items are used to do this.  The logical door latch is
   898                                  ; based on the premise that it is not physically possible to change floppy
   899                                  ; disks in a drive in under two seconds (most people take about 10).  The
   900                                  ; logical door latch is implemented by saving the time of the last successful
   901                                  ; disk operation (in the value TIM_DRV).  When a new request is made the
   902                                  ; current time is compared to the saved time.  If less than two seconds have
   903                                  ; passed then the value "No Change" is returned.  If more than two seconds
   904                                  ; have passed the value "Don't Know" is returned.
   905                                  ;    There is one complecation to this algorithm.  Some programs change the
   906                                  ; value of the timer.  In this unfortunate case we have an invalid timer.
   907                                  ; This possibility is detected by counting the number of disk operations
   908                                  ; which occur without any time passing.  If this count exceeds the value of
   909                                  ; "AccessMax" we assume the counter is invalid and always return "Don't
   910                                  ; Know".  The variable "AccessCount" is used to keep track of the number
   911                                  ; of disk operation which occur without the time changing.
   912                                  ;
   913                                  
   914                                  AccessCount:
   915 00000214 00                      		DB	0		; number of times media check called
   916                                  TIM_DRV:
   917 00000215 FF                      		DB	-1		; time when last disk I/O was performed
   918                                  FlagBits:
   919 00000216 0000                    		DW	0		; Bits to set in flag field when doing
   920                                  					; a Set_Changed_DL
   921                                  MedByt:
   922 00000218 00                      		DB	0		; hold media byte from floppy
   923                                  
   924                                  ;		;EVENB
   925 00000219 90                      align 2
   926                                  		; 13/06/2018
   927                                  WRTVERIFY:
   928                                  RFLAG:
   929 0000021A 02                      		DB	ROMRead		;2 for read, 3 for write
   930                                  VERIFY:
   931 0000021B 00                      		DB	0		;1 if verify after write
   932                                  SECCNT:
   933 0000021C 0000                    		DW	0
   934                                  HARDNUM:
   935 0000021E 63                      		DB	99		;logical drive number of first hardfile	
   936                                  
   937                                  ;
   938                                  ; Some of the older versions of the IBM rom-bios always assumed a seek would
   939                                  ; have to be made to read the diskette.  Consequently a large head settle
   940                                  ; time was always used in the I/O operations.  To get around this problem
   941                                  ; we need to continually adjust the head settle time.  The following
   942                                  ; algorithm is used:
   943                                  ;
   944                                  ;   Get the current head settle value.
   945                                  ;   If it is 1, then
   946                                  ;	set slow = 15
   947                                  ;   else
   948                                  ;	set slow = value
   949                                  ;   ...
   950                                  ;   if we are seeking and writing then
   951                                  ;	use slow
   952                                  ;   else
   953                                  ;	use fast
   954                                  ;   ...
   955                                  ;   restore current head settle value
   956                                  ;
   957                                  
   958                                  MotorStartup:
   959 0000021F 00                      		DB	0			; value from table
   960                                  SettleCurrent:
   961 00000220 00                      		DB	0			; value from table
   962                                  SettleSlow:
   963 00000221 00                      		DB	0			; slow settle value
   964                                  NextSpeed:
   965 00000222 00                       		DB	0			; value of speed to be used
   966                                  Save_head_sttl:
   967 00000223 00                      		DB	0			;used by READ_SECTOR routine
   968                                  EOT:
   969 00000224 09                      		DB	9
   970                                  
   971                                  ; 11/06/2018
   972                                  
   973                                  ;
   974                                  ; pointer to Disk Parameter Table
   975                                  ;
   976                                  ;
   977                                  ;		;EVENB
   978 00000225 90                      align 2
   979                                  DPT:
   980 00000226 00000000                		dd	0
   981                                  
   982                                  ; 13/06/2018
   983                                  ; 23/03/2018
   984                                  ;
   985                                  ; The following two sets of variables are used to hold values for
   986                                  ; disk I/O operations
   987                                  ; Keep the next two items contiguous - see IOCTL_Block for reason
   988                                  
   989                                  CURSEC:	
   990 0000022A 00                      		DB	0			; current sector
   991                                  CURHD:
   992 0000022B 00                      		DB	0			; current head
   993                                  CURTRK:
   994 0000022C 0000                    		DW	0			; current track
   995                                  SPSAV:
   996 0000022E 0000                    		DW	0			; save the stack pointer
   997                                  
   998                                  ;
   999                                  ; The following are used for IOCTL function calls
  1000                                  ;
  1001                                  
  1002                                  ; 11/06/2018 - Retro DOS v3.0
  1003                                  FORMT_EOT:
  1004 00000230 08                      		DB	8			; EOT used for format
  1005                                  HDNUM:
  1006 00000231 00                      		DB	0			; Head number
  1007                                  TRKNUM:
  1008 00000232 0000                    		DW	0			; Track being manipulated
  1009                                  GAP_PATCH:
  1010 00000234 50                      		DB	50h			; Format gap patched into DPT
  1011                                  
  1012                                  ;
  1013                                  ; Disk errors returned from the IBM rom
  1014                                  ;
  1015                                  
  1016                                  ERRIN:
  1017 00000235 80                      		DB	80H			; no response
  1018 00000236 40                      		DB	40H			; seek failure
  1019 00000237 10                      		DB	10H			; bad CRC
  1020 00000238 08                      		DB	8			; DMA overrun
  1021 00000239 06                      		DB	6			; media change
  1022 0000023A 04                      		DB	4			; sector not found
  1023 0000023B 03                      		DB	3			; write attempt to write-protect disk
  1024                                  LSTERR:
  1025 0000023C 00                      		DB	0			; all other errors
  1026                                  
  1027                                  ;
  1028                                  ; returned error code corresponding to above errors
  1029                                  ;
  1030                                  
  1031                                  ERROUT:
  1032 0000023D 02                      		DB	2			; no response
  1033 0000023E 06                      		DB	6			; seek failure
  1034 0000023F 04                      		DB	4			; bad CRC
  1035 00000240 04                      		DB	4			; DMA overrun
  1036 00000241 0F                      		DB	15			; invalid media change
  1037 00000242 08                      		DB	8			; sector not found
  1038 00000243 00                      		DB	0			; write attempt on write-protect disk
  1039 00000244 0C                      		DB	12			; general error
  1040                                  
  1041                                  NUMERR	EQU	ERROUT-ERRIN
  1042                                  
  1043                                  
  1044 00000245 90                      align 2
  1045                                  
  1046                                  ;-------------------------------------------------------------
  1047                                  ;
  1048                                  ; DiskSector is a 512 byte sector into which the boot sector
  1049                                  ; is read.  It is also used as read sector for DMA check for
  1050                                  ; hard disk.
  1051                                  
  1052                                  DiskSector:
  1053                                  		;db	11 dup(?)	   ; take care of 3 jump bytes plus OEM name.
  1054 00000246 00<rep Bh>              		times	11 db 0
  1055                                  BPB_In_Sector:
  1056 00000251 0000                    		dw	0
  1057                                  SECPERCLUSINSECTOR:
  1058 00000253 00                      		db	0
  1059 00000254 0000                    		dw	0
  1060 00000256 00                      		db	0
  1061 00000257 0000                    		dw	0
  1062 00000259 0000                    		dw	0
  1063                                  MediaByte:
  1064 0000025B 00                      		db	0
  1065 0000025C 0000                    		dw	0
  1066 0000025E 0000                    		dw	0
  1067 00000260 0000                    		dw	0
  1068 00000262 0000                    		dw	0
  1069 00000264 00                      		db	0
  1070                                  		;db	512-($-DiskSector) dup (?)
  1071 00000265 00<rep 1E1h>            		times	512-($-DiskSector) db 0
  1072                                  
  1073                                  
  1074                                  ; 25/05/2018 (04/04/2018)
  1075                                  
  1076                                  ;---------------------------------------------------------------------
  1077                                  ;
  1078                                  ;	The "BDS"'s contain information for each drive in the system.
  1079                                  ;  There is one BDS for each logical drvie in the system.  The BDS's
  1080                                  ;  are all linked together in a chain.	The BDS contain various values
  1081                                  ;  important to the disk drive. Various values are updated whenever actions
  1082                                  ;  are performed.  For example if a drive is read from the last time
  1083                                  ;  accessed fields are updated to the current time.
  1084                                  ;	Initial values:
  1085                                  ;    *	Sectors/Alloc. unit in BPB initially set to -1 to signify that
  1086                                  ;	the BPB has not been filled.
  1087                                  ;    *	Link is set to -1 to signify end of list.
  1088                                  ;    *	number of cylinders in MaxParms initialized to -1 to indicate
  1089                                  ;	that the parameters have not been set.
  1090                                  ;
  1091                                  ;  START_BDS contains a pointer to the first BDS.  It is through this
  1092                                  ;  pointer that routines find particular BDS (see SetDrive to see how
  1093                                  ;  this is done).
  1094                                  ;
  1095                                  
  1096                                  	;EVENB
  1097                                  ;align 2
  1098                                  
  1099                                  BDS1:
  1100                                  		;DD	BDS2			;LINK TO NEXT STRUCTURE
  1101 00000446 [9804]                  		DW	BDS2
  1102 00000448 7000                    		DW	KERNEL_SEGMENT  ; 28/03/2018
  1103 0000044A 00                      		DB	0			;ROM DISK INT Drive Number
  1104 0000044B 00                      		DB	0			;Logical Drive Letter
  1105                                  FDRIVE1:
  1106 0000044C 0002                    		DW	512			;Physical sector size in bytes
  1107 0000044E FF                      		DB	-1			;Sectors/allocation unit
  1108 0000044F 0100                    		DW	1			;Reserved sectors for DOS
  1109 00000451 02                      		DB	2			;No. allocation tables
  1110 00000452 4000                    		DW	64			;Number directory entries
  1111 00000454 6801                    		DW	9*40			;Number sectors (at 512 bytes ea.)
  1112 00000456 00                      		DB	00000000b		;Media descriptor, initially 00H.
  1113 00000457 0200                    		DW	2			;Number of FAT sectors
  1114 00000459 0900                    		DW	9			;Sector limit
  1115 0000045B 0100                    		DW	1			;Head limit
  1116 0000045D 0000                    		DW	0			;Hidden sector count
  1117 0000045F 00                      		DB	0			; TRUE => Large fats
  1118                                  OPCNT1:
  1119 00000460 0000                    		DW	0			;Open Ref. Count
  1120                                  VOLID1:
  1121 00000462 4E4F204E414D452020-     		DB	"NO NAME    ",0         ;Volume ID for this disk
  1121 0000046B 202000             
  1122 0000046E 03                      		DB	3			;Form Factor
  1123                                  FLAGS1:
  1124 0000046F 2000                    		DW	0020H			;Various Flags
  1125                                  	;	DB	9 dup (0)		;Reserved for future use
  1126 00000471 2800                    		dw	40			; number of cylinders
  1127                                  RecBPB1:
  1128 00000473 0002                    		DW	512			;Physical sector size in bytes
  1129 00000475 01                      		DB	1			;Sectors/allocation unit
  1130 00000476 0100                    		DW	1			;Reserved sectors for DOS
  1131 00000478 02                      		DB	2			;No. allocation tables
  1132 00000479 E000                    		DW	0E0H			;NUMBER DIRECTORY ENTRIES
  1133 0000047B 6801                    		DW	9*40			;Number sectors (at 512 bytes ea.)
  1134 0000047D F0                      		DB	0F0h			;Media descriptor, initially 00H.
  1135 0000047E 0200                    		DW	2			;Number of FAT sectors
  1136 00000480 0900                    		DW	9			;Sector limit
  1137 00000482 0200                    		DW	2			;HEAD LIMIT
  1138 00000484 0000                    		DW	0			;Hidden sector count
  1139                                  		;DB	12 DUP (?)
  1140 00000486 00<rep Ch>              		times	12 db 0
  1141                                  TRACK1:
  1142 00000492 FF                      		DB	-1			;Last track accessed on this drive
  1143                                  TIM_LO1:
  1144 00000493 FFFF                    		DW	-1			;Keep these two contiguous (?)
  1145                                  TIM_HI1:
  1146 00000495 FFFF                    		DW	-1
  1147                                  
  1148                                  	;EVENB
  1149 00000497 90                      align 2
  1150                                  BDS2:
  1151                                  		;DD	BDS3			;LINK TO NEXT STRUCTURE
  1152 00000498 [EA04]                  		DW	BDS3
  1153 0000049A 7000                    		DW	KERNEL_SEGMENT ; 28/03/2018
  1154 0000049C 00                      		DB	0			;INT 13 DRIVE NUMBER
  1155 0000049D 00                      		DB	0			;Logical Drive Letter
  1156                                  FDRIVE2:
  1157 0000049E 0002                    		DW	512			;Physical sector size in bytes
  1158 000004A0 FF                      		DB	-1			;Sectors/allocation unit
  1159 000004A1 0100                    		DW	1			;Reserved sectors for DOS
  1160 000004A3 02                      		DB	2			;No. allocation tables
  1161 000004A4 4000                    		DW	64			;Number directory entries
  1162 000004A6 6801                    		DW	9*40			;Number sectors (at 512 bytes ea.)
  1163 000004A8 00                      		DB	00000000b		;Media descriptor, initially 00H.
  1164 000004A9 0200                    		DW	2			;Number of FAT sectors
  1165 000004AB 0900                    		DW	9			;Sector limit
  1166 000004AD 0100                    		DW	1			;Head limit
  1167 000004AF 0000                    		DW	0			;Hidden sector count
  1168 000004B1 00                      		DB	0			; TRUE => Large fats
  1169                                  OPCNT2:
  1170 000004B2 0000                    		DW	0			;Open Ref. Count
  1171                                  VOLID2:
  1172 000004B4 4E4F204E414D452020-     		DB	"NO NAME    ",0         ;Volume ID for this disk
  1172 000004BD 202000             
  1173 000004C0 03                      		DB	3			;Form Factor
  1174                                  FLAGS2:
  1175 000004C1 2000                    		DW	0020H			;Various Flags
  1176                                  	;	DB	9 dup (0)		;Reserved for future use
  1177 000004C3 2800                    		dw	40			; number of cylinders
  1178                                  RecBPB2:
  1179 000004C5 0002                    		DW	512			;Physical sector size in bytes
  1180 000004C7 01                      		DB	1			;Sectors/allocation unit
  1181 000004C8 0100                    		DW	1			;Reserved sectors for DOS
  1182 000004CA 02                      		DB	2			;No. allocation tables
  1183 000004CB E000                    		DW	0E0H			;NUMBER DIRECTORY ENTRIES
  1184 000004CD 6801                    		DW	9*40			;Number sectors (at 512 bytes ea.)
  1185 000004CF F0                      		DB	0F0h			;Media descriptor, initially 00H.
  1186 000004D0 0200                    		DW	2			;Number of FAT sectors
  1187 000004D2 0900                    		DW	9			;Sector limit
  1188 000004D4 0200                    		DW	2			;HEAD LIMIT
  1189 000004D6 0000                    		DW	0			;Hidden sector count
  1190                                  		;DB	12 DUP (?)
  1191 000004D8 00<rep Ch>              		times	12 db 0
  1192                                  TRACK2:
  1193 000004E4 FF                      		DB	-1			;Last track accessed on this drive
  1194                                  TIM_LO2:
  1195 000004E5 FFFF                    		DW	-1			;Keep these two contiguous (?)
  1196                                  TIM_HI2:
  1197 000004E7 FFFF                    		DW	-1
  1198                                  
  1199                                  	;EVENB
  1200 000004E9 90                      align 2
  1201                                  BDS3:
  1202                                  		;DD	BDS4			;LINK TO NEXT STRUCTURE
  1203 000004EA [3C05]                  		DW	BDS4
  1204 000004EC 7000                    		DW	KERNEL_SEGMENT ; 28/03/2018
  1205 000004EE 00                      		DB	0			;INT 13 DRIVE NUMBER
  1206 000004EF 00                      		DB	0			;Logical Drive Letter
  1207                                  FDRIVE3:
  1208 000004F0 0002                    		DW	512			;Physical sector size in bytes
  1209 000004F2 FF                      		DB	-1			;Sectors/allocation unit
  1210 000004F3 0100                    		DW	1			;Reserved sectors for DOS
  1211 000004F5 02                      		DB	2			;No. allocation tables
  1212 000004F6 4000                    		DW	64			;Number directory entries
  1213 000004F8 6801                    		DW	9*40			;Number sectors (at 512 bytes ea.)
  1214 000004FA 00                      		DB	00000000b		;Media descriptor, initially 00H.
  1215 000004FB 0200                    		DW	2			;Number of FAT sectors
  1216 000004FD 0900                    		DW	9			;Sector limit
  1217 000004FF 0100                    		DW	1			;Head limit
  1218 00000501 0000                    		DW	0			;Hidden sector count
  1219 00000503 00                      		DB	0			; TRUE => Large fats
  1220                                  OPCNT3:
  1221 00000504 0000                    		DW	0			;Open Ref. Count
  1222                                  VOLID3:
  1223 00000506 4E4F204E414D452020-     		DB	"NO NAME    ",0         ;Volume ID for this disk
  1223 0000050F 202000             
  1224 00000512 03                      		DB	3			;Form Factor
  1225                                  FLAGS3:
  1226 00000513 2000                    		DW	0020H			;Various Flags
  1227                                  	;	DB	9 dup (0)		;Reserved for future use
  1228 00000515 2800                    		dw	40			; number of cylinders
  1229                                  RecBPB3:
  1230 00000517 0002                    		DW	512			;Physical sector size in bytes
  1231 00000519 01                      		DB	1			;Sectors/allocation unit
  1232 0000051A 0100                    		DW	1			;Reserved sectors for DOS
  1233 0000051C 02                      		DB	2			;No. allocation tables
  1234 0000051D E000                    		DW	0E0H			;NUMBER DIRECTORY ENTRIES
  1235 0000051F 6801                    		DW	9*40			;Number sectors (at 512 bytes ea.)
  1236 00000521 F0                      		DB	0F0h			;Media descriptor, initially 00H.
  1237 00000522 0200                    		DW	2			;Number of FAT sectors
  1238 00000524 0900                    		DW	9			;Sector limit
  1239 00000526 0200                    		DW	2			;HEAD LIMIT
  1240 00000528 0000                    		DW	0			;Hidden sector count
  1241                                  		;DB	12 DUP (?)
  1242 0000052A 00<rep Ch>              		times	12 db 0	
  1243                                  TRACK3:
  1244 00000536 FF                      		DB	-1			;Last track accessed on this drive
  1245                                  TIM_LO3:
  1246 00000537 FFFF                    		DW	-1			;Keep these two contiguous (?)
  1247                                  TIM_HI3:
  1248 00000539 FFFF                    		DW	-1
  1249                                  
  1250                                  	;EVENB
  1251 0000053B 90                      align 2
  1252                                  BDS4:
  1253 0000053C FFFF                    		DW	-1			;Link to next structure
  1254                                  		;DW	Code
  1255 0000053E 7000                    		DW	KERNEL_SEGMENT
  1256 00000540 00                      		DB	0			;INT 13 DRIVE NUMBER
  1257 00000541 00                      		DB	0			;Logical Drive Letter
  1258                                  FDRIVE4:
  1259 00000542 0002                    		DW	512			;Physical sector size in bytes
  1260 00000544 FF                      		DB	-1			;Sectors/allocation unit
  1261 00000545 0100                    		DW	1			;Reserved sectors for DOS
  1262 00000547 02                      		DB	2			;No. allocation tables
  1263 00000548 4000                    		DW	64			;Number directory entries
  1264 0000054A 6801                    		DW	9*40			;Number sectors (at 512 bytes ea.)
  1265 0000054C 00                      		DB	00000000b		;Media descriptor, initially 00H.
  1266 0000054D 0200                    		DW	2			;Number of FAT sectors
  1267 0000054F 0900                    		DW	9			;Sector limit
  1268 00000551 0100                    		DW	1			;Head limit
  1269 00000553 0000                    		DW	0			;Hidden sector count
  1270 00000555 00                      		DB	0			; TRUE => Large fats
  1271                                  OPCNT4:
  1272 00000556 0000                    		DW	0			;Open Ref. Count
  1273                                  VOLID4:
  1274 00000558 4E4F204E414D452020-     		DB	"NO NAME    ",0         ;Volume ID for this disk
  1274 00000561 202000             
  1275 00000564 03                      		DB	3			;Form Factor
  1276                                  FLAGS4:
  1277 00000565 2000                    		DW	0020H			;Various Flags
  1278                                  	;	DB	9 dup (0)		;Reserved for future use
  1279 00000567 2800                    		dw	40			; number of cylinders
  1280                                  ;;Rev 3.30 Modification
  1281                                  RECBPB4:
  1282 00000569 0002                    		DW	512			;BYTES PER SECTOR
  1283 0000056B 01                      		DB	1			;SECTORS/ALLOCATION UNIT
  1284 0000056C 0100                    		DW	1			;RESERVED SECTORS FOR DOS
  1285 0000056E 02                      		DB	2			;NO. ALLOCATION TABLES
  1286 0000056F E000                    		DW	0E0H			;NUMBER DIRECTORY ENTRIES
  1287 00000571 6801                    		DW	9*40			;NUMBER SECTORS (AT 512 BYTES EA.)
  1288 00000573 F0                      		DB	0F0H			;MEDIA DESCRIPTOR, INITIALLY F0H.
  1289 00000574 0200                    		DW	2			;NUMBER OF FAT SECTORS
  1290 00000576 0900                    		DW	9			;SECTOR LIMIT
  1291 00000578 0200                    		DW	2			;HEAD LIMIT
  1292 0000057A 0000                    		DW	0			;HIDDEN SECTOR COUNT
  1293                                  		;DB	12 DUP (?)
  1294 0000057C 00<rep Ch>              		times	12 db 0
  1295                                  ;;End of Modification
  1296                                  TRACK4:
  1297 00000588 FF                      		DB	-1			;Last track accessed on this drive
  1298                                  TIM_LO4:
  1299 00000589 FFFF                    		DW	-1			;Keep these two contiguous (?)
  1300                                  TIM_HI4:
  1301 0000058B FFFF                    		DW	-1
  1302                                  
  1303                                  struc bpbType
  1304 00000000 ??                      .spf:	resb 	1
  1305 00000001 ??                      .spt:	resb 	1
  1306 00000002 ??                      .cdire:	resb 	1
  1307 00000003 ????                    .csec:	resw 	1
  1308 00000005 ??                      .spa:	resb	1
  1309 00000006 ??                      .chead:	resb	1
  1310                                  .size:
  1311                                  endstruc
  1312                                  
  1313                                  SM92:   ; bpbType
  1314 0000058D 03                      		db	3	; .spf
  1315 0000058E 09                      		db	9	; .spt
  1316 0000058F 70                      		db	70h	; .cdire
  1317 00000590 A005                    		dw	2*9*80	; .csec
  1318 00000592 02                      		db	2	; .spa	
  1319 00000593 02                      		db	2	; .chead
  1320                                  
  1321                                  	
  1322                                  ;
  1323                                  ; ALTAH is a single character buffer used to handle special keys.
  1324                                  ;
  1325                                  
  1326                                  ALTAH:
  1327 00000594 00                      		DB	0			;Special key handling
  1328                                  
  1329                                  ;
  1330                                  ; The following variable can be modified via IOCTL sub-function 16. In this
  1331                                  ; way, the wait can be set to suit the speed of the particular printer being
  1332                                  ; used. One for each printer device.
  1333                                  ;
  1334                                  
  1335                                  PRINTDEV:
  1336 00000595 00                      		DB	0		; Index into following array
  1337                                  
  1338                                  ;EVENB
  1339                                  align 2
  1340                                  
  1341                                  WAIT_COUNT:
  1342                                  		;DW	4 dup (50h)	; Array of Retry counts for printer
  1343 00000596 5000<rep 4h>            		times	4 dw 50h	 	
  1344                                  
  1345                                  ;
  1346                                  ; DAYCNT is the number of days since 1-1-80.
  1347                                  ; Each time the clock is read it is necessary to check if another day has
  1348                                  ; passed.  The ROM only returns the day rollover once so if it is missed
  1349                                  ; the time will be off by a day.
  1350                                  ;
  1351                                  
  1352                                  ;EVENB
  1353                                  ;align 2
  1354                                  
  1355                                  DAYCNT:
  1356 0000059E 0000                    		DW	0
  1357                                  
  1358                                  ;-----------------------------------------------------------------------------
  1359                                  ; MSBIO1.ASM  - MSDOS 3.3 - 24/07/1987
  1360                                  ;-----------------------------------------------------------------------------
  1361                                  ; 23/03/2018 - Retro DOS v2.0
  1362                                  
  1363                                  ;
  1364                                  ; The next nine equ's describe the offset into the request header for
  1365                                  ; different information.  For example STATUS is in byte 3 of the request
  1366                                  ; header (starting count at zero).
  1367                                  ;
  1368                                  
  1369                                  CMDLEN	equ	0			; length of this command
  1370                                  UNIT	equ	1			; sub unit specifier
  1371                                  CMD	equ	2			; command code
  1372                                  STATUS	equ	3			; status
  1373                                  MEDIA	equ	13			; media descriptor
  1374                                  TRANS	equ	14			; transfer address
  1375                                  COUNT	equ	18			; count of blocks or characters
  1376                                  START	equ	20			; first block to transfer
  1377                                  EXTRA	equ	22			; Usually pointer to Vol Id for error 15
  1378                                  
  1379                                  ;
  1380                                  ; Strategy is the strategy entry point for all default bio device drivers.
  1381                                  ; All that is done is to save the pointer to the request header in the
  1382                                  ; variable PtrSav.
  1383                                  ;
  1384                                  
  1385                                  STRATEGY:
  1386 000005A0 2E891E[B800]            		mov	[CS:PTRSAV],BX
  1387 000005A5 2E8C06[BA00]            		mov	[CS:PTRSAV+2],ES
  1388 000005AA CB                      		retf
  1389                                  
  1390                                  ;------------------------------------------------------------------------------
  1391                                  ;
  1392                                  ;			Device entry point
  1393                                  ;
  1394                                  ; The following ten pieces of code are the interrupt entry points for the
  1395                                  ; default device drivers.  These small pieces of code have two jobs.
  1396                                  ;
  1397                                  ;	1) Make SI point to the beginning of the proper command jump  table.
  1398                                  ;	   SI must first be pushed to preserve original contents.
  1399                                  ;	2) If the call is an AUX or a printer save the number of the
  1400                                  ;	   request in AL.  AL is moved to AUXNUM below.
  1401                                  ;
  1402                                  
  1403                                  ;
  1404                                  ; Con device:
  1405                                  ;
  1406                                  CON$IN:
  1407 000005AB 56                      		PUSH	SI
  1408 000005AC BE[3700]                		MOV	SI,CONTBL
  1409 000005AF EB4B                    		JMP	SHORT ENTRY
  1410                                  AUX0$IN:
  1411 000005B1 56                      		PUSH	SI
  1412 000005B2 50                      		PUSH	AX
  1413 000005B3 30C0                    		XOR	AL,AL
  1414 000005B5 EB10                    		JMP	SHORT AUXENT
  1415                                  AUX1$IN:
  1416 000005B7 56                      		PUSH	SI
  1417 000005B8 50                      		PUSH	AX
  1418 000005B9 B001                    		MOV	AL,1
  1419 000005BB EB0A                    		JMP	short AUXENT
  1420                                  
  1421                                  		; 25/05/2018
  1422                                  AUX2$IN:
  1423 000005BD 56                      		PUSH	SI
  1424 000005BE 50                      		PUSH	AX
  1425 000005BF B002                    		MOV	AL,2
  1426 000005C1 EB04                    		JMP	short AUXENT
  1427                                  AUX3$IN:
  1428 000005C3 56                      		PUSH	SI
  1429 000005C4 50                      		PUSH	AX
  1430 000005C5 B003                    		MOV	AL,3
  1431                                  		;JMP	short AUXENT
  1432                                  AUXENT:
  1433 000005C7 BE[4F00]                		MOV	SI,AUXTBL
  1434 000005CA EB31                    		JMP	SHORT ENTRY1
  1435                                  
  1436                                  PRN0$IN:
  1437 000005CC 56                      		PUSH	SI
  1438 000005CD 50                      		PUSH	AX
  1439 000005CE 31C0                    		XOR	AX,AX
  1440 000005D0 EB16                    		JMP	SHORT PRNENT
  1441                                  PRN1$IN:
  1442 000005D2 56                      		PUSH	SI
  1443 000005D3 50                      		PUSH	AX
  1444 000005D4 30C0                    		XOR	AL,AL
  1445 000005D6 B401                    		MOV	AH,1
  1446 000005D8 EB0E                    		JMP	SHORT PRNENT
  1447                                  PRN2$IN:
  1448 000005DA 56                      		PUSH	SI
  1449 000005DB 50                      		PUSH	AX
  1450 000005DC B001                    		MOV	AL,1
  1451 000005DE B402                    		MOV	AH,2
  1452 000005E0 EB06                    		JMP	SHORT PRNENT
  1453                                  PRN3$IN:
  1454 000005E2 56                      		PUSH	SI
  1455 000005E3 50                      		PUSH	AX
  1456 000005E4 B002                    		MOV	AL,2
  1457 000005E6 B403                    		MOV	AH,3
  1458                                  PRNENT:
  1459 000005E8 BE[7D00]                		MOV	SI,PRNTBL
  1460 000005EB 2E8826[9505]            		MOV	[CS:PRINTDEV],AH
  1461 000005F0 EB0B                    		JMP	SHORT ENTRY1
  1462                                  
  1463                                  TIM$IN:
  1464 000005F2 56                      		PUSH	SI
  1465 000005F3 BE[6700]                		MOV	SI,TIMTBL
  1466 000005F6 EB04                    		JMP	SHORT ENTRY
  1467                                  
  1468                                  DSK$IN:
  1469 000005F8 56                      		PUSH	SI
  1470 000005F9 BE[0300]                		mov	SI,DSKTBL
  1471                                  
  1472                                  ;
  1473                                  ;  This section is the prolog to all default device drivers.  All registers
  1474                                  ; are saved, the registers are filled with information from the request header,
  1475                                  ; and the routine from the jump table is called. Error checking is done
  1476                                  ; to assure command code is valid. Before calling the routine in the
  1477                                  ; jump table the register are:
  1478                                  ;
  1479                                  ;	AH = Media Descriptor
  1480                                  ;	AL = Unit Code
  1481                                  ;	BX = offset to PTRSAV (request header is therefore at DS:BX)
  1482                                  ;	CX = count from request header
  1483                                  ;	DX = start sector
  1484                                  ;	ES:DI = transfer address
  1485                                  ;	SI = points to jump table
  1486                                  ;	DS = points to this segment
  1487                                  ;
  1488                                  ; Once the routine finishes its job it jumps back to one of the eight
  1489                                  ; pieces of code below labeled Exit Points.
  1490                                  ;
  1491                                  
  1492                                  ENTRY:
  1493 000005FC 50                      		push	AX
  1494                                  ENTRY1:
  1495 000005FD 51                      		push	CX			; save all registers
  1496 000005FE 52                      		push	DX
  1497 000005FF 57                      		push	DI
  1498 00000600 55                      		push	BP
  1499 00000601 1E                      		push	DS
  1500 00000602 06                      		push	ES
  1501 00000603 53                      		push	BX
  1502                                  
  1503 00000604 2EA2[2F01]              		mov	[CS:AUXNUM],AL		; save choice of AUX/PRN device
  1504                                  
  1505 00000608 2EC51E[B800]            		lds	BX,[CS:PTRSAV]		; get pointer to I/O packet
  1506                                  	
  1507 0000060D 8A4701                  		mov	AL,[BX+UNIT]		;AL = UNIT CODE
  1508 00000610 8A670D                  		mov	AH,[BX+MEDIA]		;AH = MEDIA DESCRIP
  1509 00000613 8B4F12                  		mov	CX,[BX+COUNT]		;CX = COUNT
  1510 00000616 8B5714                  		mov	DX,[BX+START]		;DX = START SECTOR
  1511                                  
  1512 00000619 97                      		xchg	DI,AX
  1513 0000061A 8A4702                  		mov	AL,[BX+CMD]
  1514                                  		; 11/04/2018 (25/05/2018)
  1515 0000061D 2E3A04                  		cmp	AL,[CS:SI]		; is command code a valid number?
  1516 00000620 7713                    		ja	SHORT CMDERR		; no, jump to handle error
  1517                                  
  1518                                  		;XOR	AH,AH
  1519 00000622 98                      		CBW				; note that AL <= 15 means OK
  1520 00000623 D1E0                    		shl	AX,1
  1521 00000625 01C6                    		add	SI,AX			; get SI to point to address of routine
  1522                                  		
  1523 00000627 97                      		xchg	AX,DI			; put proper value back into AX
  1524 00000628 C47F0E                  		les	DI,[BX+TRANS]		; get ES:DI to point to transfer address
  1525 0000062B 0E                      		push	CS			; get DS equal to CS
  1526 0000062C 1F                      		pop	DS
  1527                                  
  1528 0000062D FC                      		cld				; clear the direction flag
  1529                                  		; 25/05/2018
  1530 0000062E FF6401                  		jmp	WORD [SI+1]		; go to the command
  1531                                  
  1532                                  
  1533                                  ;=====================================================
  1534                                  ;=
  1535                                  ;=	SUBROUTINES SHARED BY MULTIPLE DEVICES
  1536                                  ;=
  1537                                  ;=====================================================
  1538                                  
  1539                                  ;----------------------------------------------------------
  1540                                  ;
  1541                                  ;		Exit  Points
  1542                                  ;
  1543                                  ; All device driver call return through one of these eight
  1544                                  ; pieces of code.  The code set error and status conditions
  1545                                  ; and then restores the registers.
  1546                                  ;
  1547                                  		
  1548                                  BUS$EXIT:				; device busy exit
  1549                                  
  1550 00000631 B403                    		mov	AH,00000011b		; set error code
  1551 00000633 EB19                    		jmp	SHORT ERR1
  1552                                  CMDERR:
  1553 00000635 B003                    		mov	AL,3			; unknown command error
  1554                                  ERR$CNT:
  1555 00000637 2EC51E[B800]            		lds	BX,[CS:PTRSAV]
  1556                                  		;lds	BX,[PTRSAV]	; 11/04/2018
  1557 0000063C 294F12                  		sub	[BX+COUNT],CX		;# of successful I/O's
  1558                                  ERR$EXIT:
  1559 0000063F B481                    		mov	AH,10000001b		; mark error and return
  1560 00000641 EB0B                    		jmp	SHORT ERR1
  1561                                  
  1562                                  EXIT$ZER:
  1563                                  		;lds	BX,[CS:PTRSAV]
  1564 00000643 C51E[B800]              		lds	BX,[PTRSAV]		; IBMDOS 3.3 (IBMBIO.COM)
  1565 00000647 31C0                    		xor	AX,AX
  1566 00000649 894712                  		mov	[BX+COUNT],AX		; indicate no character read
  1567                                  
  1568                                  EXIT:
  1569 0000064C B401                    		mov	AH,00000001b
  1570                                  ERR1:
  1571 0000064E 2EC51E[B800]            		lds	BX,[CS:PTRSAV]
  1572                                  		;lds	BX,[PTRSAV]	; 11/04/2018
  1573 00000653 894703                  		mov	[BX+STATUS],AX		; mark operation complete
  1574                                  
  1575 00000656 5B                      		pop	BX			; restore register and return
  1576 00000657 07                      		pop	ES
  1577 00000658 1F                      		pop	DS
  1578 00000659 5D                      		pop	BP
  1579 0000065A 5F                      		pop	DI
  1580 0000065B 5A                      		pop	DX
  1581 0000065C 59                      		pop	CX
  1582 0000065D 58                      		pop	AX
  1583 0000065E 5E                      		pop	SI
  1584 0000065F CB                      		retf
  1585                                  
  1586                                  
  1587                                  ;-------------------------------------------------------------
  1588                                  ;
  1589                                  ; Chrout - write out character in AL using current attribute
  1590                                  ;
  1591                                  ;   called via int 29h
  1592                                  ;
  1593                                  
  1594                                  CHROUT	equ 29H
  1595                                  
  1596                                  OUTCHR:
  1597                                  		; 13/06/2018 (IBMDOS 3.3, IBMBIO.COM) ; **
  1598                                  		; 08/04/2018 (IBMDOS 2.1, IBMBIO.COM) ; *
  1599                                  		;sti ; *
  1600 00000660 50                      		push	AX			; preserve affect registers
  1601 00000661 56                      		push	SI ; **
  1602 00000662 57                      		push	DI ; **
  1603 00000663 55                      		push	BP ; **
  1604                                  		;push	BX			;
  1605 00000664 B40E                    		mov	AH,0Eh 			; set command to write a character
  1606                                  		;mov	BH,0			;
  1607                                  		;mov	BL,7			; set foreground color
  1608 00000666 BB0700                  		mov	BX,7
  1609 00000669 CD10                    		int	10h			; call rom-bios
  1610                                  		;pop	BX			;
  1611 0000066B 5D                      		pop	BP ; **			; restore registers
  1612 0000066C 5F                      		pop	DI ; **
  1613 0000066D 5E                      		pop	SI ; **
  1614 0000066E 58                      		pop	AX
  1615 0000066F CF                      		iret
  1616                                  
  1617                                  ;----------------------------------------------
  1618                                  ;
  1619                                  ; Fill DX register with value in AUXNUM
  1620                                  ;
  1621                                  
  1622                                  GETDX:
  1623                                  		; IBMDOS 2.1
  1624                                  		;mov	dl, [AUXNUM]
  1625                                  		;xor	dh,dh
  1626                                  
  1627                                  		; MSDOS 3.3
  1628 00000670 2E8B16[2F01]            		mov	DX,[CS:AUXNUM]
  1629 00000675 C3                      		retn
  1630                                  
  1631                                  ;-----------------------------------------------------------------------------
  1632                                  ; MSCON.ASM - MSDOS 3.3 - 24/07/1987
  1633                                  ;-----------------------------------------------------------------------------
  1634                                  ; 23/03/2018 - Retro DOS v2.0
  1635                                  
  1636                                  ;----------------------------------------------------------------
  1637                                  ;								:
  1638                                  ;	      C O N - CONSOLE DEVICE DRIVER			:
  1639                                  ;								:
  1640                                  ;								:
  1641                                  ;   This file contains the Console Device Driver.  The		:
  1642                                  ; console device driver sends characters to the moniter and	:
  1643                                  ; gets characters from the keyboard.				:
  1644                                  ;								:
  1645                                  ;----------------------------------------------------------------
  1646                                  
  1647                                  
  1648                                  ;----------------------------------------------------------------
  1649                                  ;								:
  1650                                  ;		    Console read routine			:
  1651                                  ;								:
  1652                                  ;----------------------------------------------------------------
  1653                                  ;
  1654                                  
  1655                                  CON$READ:					; if CX is zero, no characters
  1656 00000676 E306                    		jcxz	CON$EXIT		;   to be read -- just exit
  1657                                  CON$LOOP:
  1658 00000678 E80500                  		call	CHRIN			; get char in AL
  1659 0000067B AA                      		stosb				; store char at ES:DI, specified buffer
  1660 0000067C E2FA                    		loop	CON$LOOP		; if CX is non-zero more char to read
  1661                                  CON$EXIT:
  1662 0000067E EBCC                    		jmp	short EXIT		; all done, successful return
  1663                                  
  1664                                  		; Temporary !
  1665                                  		; 25/08/2022 - IBMBIO.COM (IBMBIO33.IDB) address compatibility!
  1666                                  		;db	0
  1667                                  
  1668                                  ;----------------------------------------------------------------
  1669                                  ;								:
  1670                                  ;	    Input single character into AL			:
  1671                                  ;								:
  1672                                  ;----------------------------------------------------------------
  1673                                  CHRIN:
  1674                                  						; set command to read character
  1675 00000680 31C0                    		xor	AX,AX			;  and clear AL
  1676 00000682 8606[9405]              		xchg	AL,[ALTAH]		; get character & zero ALTAH
  1677 00000686 08C0                    		or	AL,AL			; see if buffer has a character
  1678 00000688 7515                    		jnz	short KEYRET		; if so - return this character
  1679                                  						; if not - read single character
  1680 0000068A CD16                    		int	16h			; call ROM-Bios keyboard routine
  1681                                  ALT10:
  1682 0000068C 09C0                    		or	AX,AX			; Check for non-key after BREAK
  1683 0000068E 74F0                    		jz	short CHRIN
  1684 00000690 3D0072                  		cmp	AX,7200h		; Check for CTRL-PRTSC
  1685 00000693 7502                    		jnz	short ALT15
  1686 00000695 B010                    		mov	AL,16			; indicate prtsc
  1687                                  ALT15:
  1688 00000697 08C0                    		or	AL,AL			; special case?
  1689 00000699 7504                    		jnz	short KEYRET		; no, return with character
  1690 0000069B 8826[9405]              		mov	[ALTAH],AH		; yes, store special key
  1691                                  KEYRET:
  1692 0000069F C3                      		RETN
  1693                                  
  1694                                  ;----------------------------------------------------------------
  1695                                  ;								:
  1696                                  ;	   Keyboard non destructive read, no wait		:
  1697                                  ;								:
  1698                                  ; If bit 10 is set by the DOS in the status word of the request :
  1699                                  ; packet, and there is no character in the input buffer, the	:
  1700                                  ; driver issues a system WAIT request to the ROM. On return	:
  1701                                  ; from the ROM, it returns a 'char-not-found' to the DOS.       :
  1702                                  ;								:
  1703                                  ;----------------------------------------------------------------
  1704                                  
  1705                                  		; 13/06/2018 (Retro DOS v3.0, IBMDOS 3.0, IBMBIO.COM) 
  1706                                  ;CONBUSJ:
  1707                                  ;		jmp	short CONBUS
  1708                                  		; Temporary !
  1709                                  		; 25/08/2022 - IBMBIO.COM (IBMBIO33.IDB) address compatibility!
  1710                                  CONBUSJ:
  1711 000006A0 EB3F                    		jmp	short CONBUS
  1712                                  		;nop
  1713                                  
  1714                                  CON$RDND:
  1715 000006A2 A0[9405]                		mov	AL,[ALTAH]		; first see if there is a
  1716 000006A5 08C0                    		or	AL,AL			; character in the buffer?
  1717                                  		;;jz	short RD1		; with debugging code it is
  1718                                  		;;jmp	short RDEXIT		; too far for conditional jump
  1719 000006A7 752E                    		jnz	short RDEXIT
  1720                                  		; Temporary !
  1721                                  		; 25/08/2022 - IBMBIO.COM (IBMBIO33.IDB) address compatibility!
  1722                                  		;jz	short RD1
  1723                                  		;jmp	short RDEXIT
  1724                                  		;nop
  1725                                  RD1:				     		; set command to 'see if
  1726 000006A9 B401                    		mov	AH, 1	     		; character available'
  1727 000006AB CD16                    		int	16h	     		; call ROM-BIOS keyboard routine
  1728                                  		;jz	short nochr		; with debugging code it is
  1729                                  		;jmp	short gotchr		; to far for conditional jump
  1730                                  		; 25/08/2022
  1731 000006AD 7519                    		jnz	short gotchr
  1732                                  		;nop	; IBMBIO.COM (IBMBIO33.IDB) address compatibility!
  1733                                  nochr:
  1734 000006AF 803E[8701]00            		cmp	byte [fHaveK09], 0
  1735                                  		;jz	short CONBUSJ
  1736 000006B4 742B                    		jz	short CONBUS
  1737 000006B6 C51E[B800]              		lds	bx,[PTRSAV]		; get pointer to request header
  1738 000006BA F747030004              		test	word [bx+STATUS],0400h	; System WAIT enabled?
  1739                                  		;jz	short CONBUSJ 		; no, get out
  1740 000006BF 7420                    		jz	short CONBUS
  1741                                  
  1742 000006C1 B80041                  		mov	AX, 4100h     		; set command for Wait on External
  1743                                  				      		; event and condition type to
  1744                                  				      		; any external event
  1745                                  		; Temporary !
  1746                                  		; 25/08/2022 - IBMBIO.COM (IBMBIO33.IDB) address compatibility !	
  1747                                  		;xor	BL,BL			; no timeout value
  1748                                  		
  1749 000006C4 CD15                    		int	15h	      		; call rom-bios sleep function
  1750 000006C6 EB19                    		jmp	short CONBUS		; after wait exit to con busy
  1751                                  
  1752                                  		; Temporary !
  1753                                  		; 25/08/2022 - IBMBIO.COM (IBMBIO33.IDB) address compatibility !
  1754                                  		;nop
  1755                                  
  1756                                  gotchr:
  1757 000006C8 09C0                    		or	AX, AX			; check for null after break
  1758 000006CA 7504                    		JNZ	short NOTBRK		; no, skip down
  1759                                  
  1760                                  ;		;mov	ah, 0
  1761                                  ;; note: AH is already zero, no need to set command
  1762                                  		; Temporary !
  1763                                  		; 25/08/2022 - IBMBIO.COM (IBMBIO33.IDB) address compatibility !
  1764                                  		;mov	ah, 0			
  1765                                  
  1766 000006CC CD16                    		int	16h			; yes, read the null
  1767 000006CE EBD2                    		Jmp	short CON$RDND		; and get a real status
  1768                                  
  1769                                  NOTBRK:
  1770 000006D0 3D0072                  		cmp	AX, 7200H		; check for ctrl-prtsc
  1771 000006D3 7502                    		jnz	short RDEXIT		; no
  1772 000006D5 B010                    		mov	AL, 16			; yes, indicate ctrl-prtsc
  1773                                  
  1774                                  RDEXIT:
  1775 000006D7 C51E[B800]              		lds	BX, [PTRSAV]		; get pointer to request header
  1776 000006DB 88470D                  		mov	[BX+MEDIA], AL		; move character into req. header
  1777                                  EXVEC:
  1778 000006DE E96BFF                  		jmp	EXIT			; all done -- successful return
  1779                                  CONBUS:
  1780 000006E1 E94DFF                  		Jmp	BUS$EXIT		; done -- con device is busy
  1781                                  
  1782                                  ;----------------------------------------------------------------
  1783                                  ;								:
  1784                                  ;		Keyboard flush routine				:
  1785                                  ;								:
  1786                                  ;----------------------------------------------------------------
  1787                                  
  1788                                  CON$FLSH:
  1789 000006E4 E80300                  		call	FLUSH
  1790 000006E7 E962FF                  		jmp	EXIT
  1791                                  
  1792                                  FLUSH:
  1793 000006EA C606[9405]00            		mov	byte [ALTAH], 0	; clear out holding buffer
  1794                                  
  1795                                  FlLoop:
  1796                                  				 	; Is there a char there?
  1797 000006EF B401                    		mov	AH, 1	 	; command code for check status
  1798 000006F1 CD16                    		int	16h	 	; call rom-bios keyboard routine
  1799                                  					; if z flag is set then no character
  1800 000006F3 7406                    		jz	short FlDone	; is ready, buffer is empty -- get out
  1801 000006F5 30E4                    		xor	AH, AH	 	; if zf is nof set, get character
  1802                                  		; 25/08/2022
  1803                                  		;mov	ah, 0 ; IBMBIO.COM (IBMBIO33.IDB)
  1804 000006F7 CD16                    		int	16h	 	; call rom-bios to get character
  1805 000006F9 EBF4                    		jmp	short FlLoop	; repeat until buffer is empty
  1806                                  FlDone:
  1807 000006FB C3                      		retn
  1808                                  
  1809                                  ;----------------------------------------------------------------
  1810                                  ;								:
  1811                                  ;	       Console Write Routine				:
  1812                                  ;								:
  1813                                  ;----------------------------------------------------------------
  1814                                  	
  1815                                  CON$WRIT:
  1816 000006FC E3E0                    		jcxz	EXVEC			; if CX is zero, get out
  1817                                  CON$LP:
  1818                                  		; 13/06/2018 - Retro DOS v3.0 (IBMDOS 3.3, IBMBIO.COM)
  1819 000006FE 268A05                  		mov	AL,[ES:DI]		; get character
  1820 00000701 47                      		inc	DI			; point to next character
  1821 00000702 CD29                    		int	CHROUT			; Output character
  1822 00000704 E2F8                    		loop	CON$LP			; repeat until all through
  1823 00000706 E943FF                  		jmp	EXIT
  1824                                  
  1825                                  ;-----------------------------------------------
  1826                                  ;
  1827                                  ;	BREAK KEY HANDLING
  1828                                  ;
  1829                                  
  1830                                  CBREAK:
  1831 00000709 2EC606[9405]03          		mov	byte [CS:ALTAH], 3	; indicate break key set
  1832                                  
  1833                                  INTRET:
  1834 0000070F CF                      		IRET
  1835                                  
  1836                                  		; Temporary !
  1837                                  		; 25/08/2022 - IBMBIO.COM (IBMBIO33.IDB) address compatibility !
  1838                                  		;db	0
  1839                                  
  1840                                  ;-----------------------------------------------------------------------------
  1841                                  ; MSAUX.ASM - MSDOS 3.3 - 24/07/1987
  1842                                  ;-----------------------------------------------------------------------------
  1843                                  ; 23/03/2018 - Retro DOS v2.0
  1844                                  
  1845                                  ;----------------------------------------------------------------
  1846                                  ;								:
  1847                                  ;	     A U X - AUXILARY DEVICE DRIVER			:
  1848                                  ;								:
  1849                                  ;								:
  1850                                  ;   This file contains the Auxilary Device Driver.  The 	:
  1851                                  ; auxilary driver handles calls to and from the RS-232 port.	:
  1852                                  ; Three devices uses this code: AUX, COM1, and COM2.  AUX and	:
  1853                                  ; COM1 talk to the zero RS-232 card and COM2 talks to the	:
  1854                                  ; 'one' RS-232 card.  The beginning of the interrupt entry      :
  1855                                  ; point for these devices sets the variable AUXNUM in the	:
  1856                                  ; msbio.asm module.  If the value is 0 the routines in this	:
  1857                                  ; file will talk to the the 'zero' card.  If the value in       :
  1858                                  ; AUXNUM is 1 the routines will talk to the 'one' card.         :
  1859                                  ; The procedure GETDX is called to put the value 0 or 1 in	:
  1860                                  ; the DX register depending on the value in AUXBUF.		:
  1861                                  ;								:
  1862                                  ;   The routines in this files are:				:
  1863                                  ;								:
  1864                                  ;	routine 		function			:
  1865                                  ;	------- 		--------			:
  1866                                  ;	AUX$READ		Read characters from the	:
  1867                                  ;				  specified device.		:
  1868                                  ;	AUX$RDND		Non-desrucrtive read with	:
  1869                                  ;				  no waiting.			:
  1870                                  ;	AUX$FLSH		Flush specified device input	:
  1871                                  ;				  buffer.			:
  1872                                  ;	AUX$WRIT		Write characters to the 	:
  1873                                  ;				  specified device.		:
  1874                                  ;	AUX$WRST		Get status of specified 	:
  1875                                  ;				  device			:
  1876                                  ;								:
  1877                                  ;  These routines are not called directly.  Call are made via	:
  1878                                  ; the strategy and interrupt entry point (see Device Header).	:
  1879                                  ;								:
  1880                                  ;  Data structure:						:
  1881                                  ;    The Aux Device has a two byte buffer called AUXBUF.  The	:
  1882                                  ;  first byte is for the zero card, the second byte is for the	:
  1883                                  ;  one card.  A zero value in the byte indicates the buffer is	:
  1884                                  ;  empty.  The routines use GETBX to get the address of the	:
  1885                                  ;  buffer.							:
  1886                                  ;								:
  1887                                  ;----------------------------------------------------------------
  1888                                  
  1889                                  ;		VALUES IN AH, REQUESTING FUNCTION OF INT 14H IN ROM BIOS
  1890                                  AUXFUNC_SEND	 EQU	1	;TRANSMIT
  1891                                  AUXFUNC_RECEIVE  EQU	2	;READ
  1892                                  AUXFUNC_STATUS	 EQU	3	;REQUEST STATUS
  1893                                  
  1894                                  ;		ERROR FLAGS, REPORTED BY INT 14H
  1895                                  
  1896                                  ;	 THESE FLAGS REPORTED IN AH:
  1897                                  FLAG_DATA_READY  EQU	01H	;DATA READY
  1898                                  FLAG_OVERRUN	 EQU	02H	;OVERRUN ERROR
  1899                                  FLAG_PARITY	 EQU	04H	;PARITY ERROR
  1900                                  FLAG_FRAME	 EQU	08H	;FRAMING ERROR
  1901                                  FLAG_BREAK	 EQU	10H	;BREAK DETECT
  1902                                  FLAG_TRANHOL_EMP EQU	20H	;TRANSMIT HOLDING REGISTER EMPTY
  1903                                  FLAG_TRANSHF_EMP EQU	40H	;TRANSMIT SHIFT REGISTER EMPTY
  1904                                  FLAG_TIMEOUT	 EQU	80H	;TIMEOUT
  1905                                  
  1906                                  ;	THESE FLAGS REPORTED IN AL:
  1907                                  FLAG_DELTA_CTS	 EQU	01H	;DELTA CLEAR TO SEND
  1908                                  FLAG_DELTA_DSR	 EQU	02H	;DELTA DATA SET READY
  1909                                  FLAG_TRAIL_RING  EQU	04H	;TRAILING EDGE RING INDICATOR
  1910                                  FLAG_DELTA_SIG	 EQU	08H	;DELTA RECEIVE LINE SIGNAL DETECT
  1911                                  FLAG_CTS	 EQU	10H	;CLEAR TO SEND
  1912                                  FLAG_DSR	 EQU	20H	;DATA SET READY
  1913                                  FLAG_RING	 EQU	40H	;RING INDICATOR
  1914                                  FLAG_REC_SIG	 EQU	80H	;RECEIVE LINE SIGNAL DETECT
  1915                                  
  1916                                  ;------------------------------------------------------------------
  1917                                  ;								  :
  1918                                  ;	Read zero or more characters from Auxilary Device	  :
  1919                                  ;								  :
  1920                                  ;	input:es:[di] points to area to receive aux data	  :
  1921                                  ;	      cx has number of bytes to be read 		  :
  1922                                  ;	      "auxnum" first byte has number of aux device (rel 0):
  1923                                  ;								  :
  1924                                  ;------------------------------------------------------------------
  1925                                  
  1926                                  AUX$READ:
  1927 00000710 E311                    		jcxz	EXVEC2		; if no characters, get out
  1928 00000712 E87E00                  		call	GETBX		; put address of AUXBUF in BX
  1929 00000715 31C0                    		xor	AX,AX		; clear AX register
  1930 00000717 8607                    		xchg	AL,[BX] 	; Get character , if any, from
  1931                                  					;   buffer and clear buffer
  1932 00000719 08C0                    		or	AL,AL		; if AL is nonzero there was a
  1933                                  					;   character in the buffer
  1934 0000071B 7503                    		jnz	short AUX2	; if so skip AUXIN call
  1935                                  AUX1:					;
  1936 0000071D E80600                  		call	AUXIN		; get character from port
  1937                                  AUX2:					;
  1938 00000720 AA                      		stosb			; store character
  1939 00000721 E2FA                    		loop	AUX1		; if more character, go around again
  1940                                  EXVEC2: 				;
  1941 00000723 E926FF                  		jmp	EXIT		; all done, successful exit
  1942                                  
  1943                                  ;
  1944                                  ; AUXIN: make a call on ROM BIOS to read character from
  1945                                  ;	 the auxilary device, then do some error checking.
  1946                                  ;	 If an error occurs then AUXIN jumps to ERR$CNT and
  1947                                  ;	 does NOT return to where it was called from.
  1948                                  ;
  1949                                  
  1950                                  AUXIN:
  1951 00000726 B402                    		mov	ah,AUXFUNC_RECEIVE
  1952 00000728 E83F00                  		call	AUXOP
  1953                                  		 			;check for Frame, Parity, or Overrun errors
  1954                                  		 			;WARNING: these error bits are unpredictable 
  1955                                  		 			;         if timeout (bit 7) is set
  1956 0000072B F6C40E                  		test	ah,FLAG_FRAME|FLAG_PARITY|FLAG_OVERRUN
  1957 0000072E 7406                    		jz	short AROK	;No error if all bits are clear
  1958                                  
  1959                                  		; 26/05/2018
  1960                                  		;Error getting character
  1961                                  		;add	sp,2		;Remove rtn address (near call)
  1962                                  		;xor	al,al
  1963                                  		;or	al,FLAG_REC_SIG | FLAG_DSR | FLAG_CTS
  1964                                  
  1965                                  		; 13/06/2018 (IBMDOS 3.3, IBMBIO.COM)
  1966 00000730 58                      		pop	ax
  1967 00000731 B0B0                    		mov	al,FLAG_REC_SIG+FLAG_DSR+FLAG_CTS 
  1968                                  
  1969 00000733 E901FF                  		jmp	ERR$CNT
  1970                                  AROK:
  1971 00000736 C3                      		RETN			;CHAR JUST READ IS IN AL, STATUS IS IN AH
  1972                                  
  1973                                  ;----------------------------------------------------------------
  1974                                  ;								:
  1975                                  ;	Aux non-destructive read with no waiting		:
  1976                                  ;								:
  1977                                  ;	input: es:[di] points to area to receive aux data	:
  1978                                  ;								:
  1979                                  ;----------------------------------------------------------------
  1980                                  ;
  1981                                  
  1982                                  AUX$RDND:
  1983 00000737 E85900                  		call	GETBX		; have BX point to AUXBUF
  1984 0000073A 8A07                    		mov	AL,[BX] 	; copy contents of buffer to AL
  1985 0000073C 08C0                    		or	AL,AL		; if AL is non-zero (char in buffer)
  1986 0000073E 7514                    		jnz	short AUXRDX	;   then return character
  1987 00000740 E82500                  		call	AUXSTAT 	;   if not, get status of AUX device
  1988 00000743 F6C401                  		TEST	AH,FLAG_DATA_READY ;TEST DATA READY
  1989 00000746 740E                    		jz	short AUXBUS	;   then device is busy (not ready)
  1990                                  
  1991 00000748 A820                    		TEST	AL,FLAG_DSR	;TEST DATA SET READY
  1992 0000074A 740A                    		jz	short AUXBUS	;   then device is busy (not ready)
  1993 0000074C E8D7FF                  		call	AUXIN		;   else aux is ready, get character
  1994 0000074F E84100                  		call	GETBX		; have bx point to AUXBUF
  1995 00000752 8807                    		mov	[BX],AL 	; save character in buffer
  1996                                  AUXRDX: 				;
  1997 00000754 EB81                    		jmp	RDEXIT		; return character
  1998                                  
  1999                                  		; Temporary !
  2000                                  		; 25/08/2022 - IBMBIO.COM (IBMBIO33.IDB) address compatibility !
  2001                                  		;db	0
  2002                                  
  2003                                  AUXBUS: 				;
  2004 00000756 E9D8FE                  		jmp	BUS$EXIT	; jump to device busy exit
  2005                                  
  2006                                  ;----------------------------------------------------------------
  2007                                  ;								:
  2008                                  ;		Aux Output Status				:
  2009                                  ;								:
  2010                                  ;----------------------------------------------------------------
  2011                                  
  2012                                  AUX$WRST:
  2013 00000759 E80C00                  		call	AUXSTAT 	; get status of AUX in AX
  2014                                  					; now test to see if device is busy
  2015                                  					; if this bit is not set,
  2016 0000075C A820                    		TEST	AL,FLAG_DSR	;TEST DATA SET READY
  2017 0000075E 74F6                    		jz	short AUXBUS	;   then device is busy (not ready)
  2018 00000760 F6C420                  		TEST	AH,FLAG_TRANHOL_EMP ;TEST TRANSMIT HOLD REG EMPTY
  2019 00000763 74F1                    		jz	short AUXBUS	;   then device is busy (not ready)
  2020 00000765 E9E4FE                  		jmp	EXIT
  2021                                  
  2022                                  ;
  2023                                  ; AUXSTAT makes a call on the ROM-BIOS to determine the status
  2024                                  ;	  of the auxilary device
  2025                                  ;	  Outputs:
  2026                                  ;		AX is filled with status of port.
  2027                                  ;		DX is changes to specify which card - either 0, 1 (, 2, 3) ;ba
  2028                                  ;		NO other registers are modified
  2029                                  ;
  2030                                  
  2031                                  AUXSTAT:
  2032 00000768 B403                    		mov	ah,AUXFUNC_STATUS
  2033                                  		;call	AUXOP
  2034                                  		;retn
  2035                                  AUXOP:					;AH=FUNCTION CODE
  2036                                  					;0=INIT, 1=SEND, 2=RECEIVE, 3=STATUS
  2037 0000076A E803FF                  		call	GETDX		; have DX point to proper card
  2038 0000076D CD14                    		int	14h		; call rom-bios for status
  2039 0000076F C3                      		retn
  2040                                  
  2041                                  ;----------------------------------------------------------------
  2042                                  ;								:
  2043                                  ;  Flush AUX Input buffer - set contents of AUXBUF to zero	:
  2044                                  ;								:
  2045                                  ;----------------------------------------------------------------
  2046                                  
  2047                                  AUX$FLSH:
  2048 00000770 E82000                  		call	GETBX		; get BX to point to AUXBUF
  2049 00000773 C60700                  		mov	byte [BX],0	; zero out buffer
  2050 00000776 E9D3FE                  		jmp	EXIT		; all done, successful return
  2051                                  	
  2052                                  ;----------------------------------------------------------------
  2053                                  ;								:
  2054                                  ;		Write to Auxilary Device			:
  2055                                  ;								:
  2056                                  ;----------------------------------------------------------------
  2057                                  
  2058                                  AUX$WRIT:
  2059 00000779 E3A8                    		jcxz	EXVEC2		; if CX is zero, no characters
  2060                                  				;   to be written, jump to exit
  2061                                  AUX$LOOP:
  2062 0000077B 268A05                  		mov	AL,[ES:DI]	; get character to be written
  2063 0000077E 47                      		inc	DI		; move DI pointer to next character
  2064 0000077F B401                    		MOV	AH,AUXFUNC_SEND ;VALUE=1, INDICATES A WRITE
  2065 00000781 E8E6FF                  		CALL	AUXOP		;SEND CHARACTER OVER AUX PORT
  2066                                  
  2067 00000784 F6C480                  		TEST	AH,FLAG_TIMEOUT ;CHECK FOR ERROR
  2068 00000787 7405                    		jz	short AWOK	;   then no error
  2069 00000789 B00A                    		mov	AL,10		;   else indicate write fault
  2070 0000078B E9A9FE                  		jmp	ERR$CNT 	; call error routines
  2071                                  
  2072                                  					; if CX is non-zero, still more
  2073                                  AWOK:
  2074 0000078E E2EB                    		loop	AUX$LOOP	; more characrter to print
  2075 00000790 E9B9FE                  		jmp	EXIT		; all done, successful return
  2076                                  
  2077                                  ;
  2078                                  ;  GETBX puts the address of AUXBUF (the Auxilary Device buffer)
  2079                                  ;	 in BX.  After calling GETBX, a routine can get to AUXBUF
  2080                                  ;	 with [BX].
  2081                                  ;
  2082                                  ;  NOTE: The getdx routine is in msbio1 and looks like:
  2083                                  ;	mov	dx,word ptr cs:[auxnum]
  2084                                  ;
  2085                                  
  2086                                  GETBX:
  2087 00000793 E8DAFE                  		call	GETDX
  2088 00000796 89D3                    		mov	BX,DX
  2089 00000798 81C3[BC00]              		add	BX,AUXBUF
  2090 0000079C C3                      		retn
  2091                                  
  2092                                  ;-----------------------------------------------------------------------------
  2093                                  ; MSLPT.ASM - MSDOS 3.3 - 24/07/1987
  2094                                  ;-----------------------------------------------------------------------------
  2095                                  ; 23/03/2018 - Retro DOS v2.0
  2096                                  
  2097                                  ;----------------------------------------------------------------
  2098                                  ;								:
  2099                                  ;	P R N - PRINTER DEVICE					:
  2100                                  ;								:
  2101                                  ;								:
  2102                                  ;   This file contains the Printer Device Driver.  The		:
  2103                                  ; printer driver handles calls to the printers.  Four devices	:
  2104                                  ; use this code: PRN, LPT1, LPT2, and LPT3.  The beginning	:
  2105                                  ; of the interrupt entry point for these device sets the	:
  2106                                  ; variable AUXNUM in the msbio.asm module.  The number is	:
  2107                                  ; in AUXNUM dictates which device will to written to: 0 for	:
  2108                                  ; PRN and LPT1, 1 for LPT2, and 2 for LPT3.			:
  2109                                  ;								:
  2110                                  ;   The routines in this files are:				:
  2111                                  ;								:
  2112                                  ;	routine 		function			:
  2113                                  ;	------- 		--------			:
  2114                                  ;	PRN$WRIT		Write to printer device 	:
  2115                                  ;	PRN$STAT		Printer status routine		:
  2116                                  ;	PRN$TilBusy		Print spooler routine		:
  2117                                  ;	Prn$GenIOCTL		Generic IOCTL routine		:
  2118                                  ;								:
  2119                                  ;  These routines are not called directly.  Call are made via	:
  2120                                  ; the strategy and interrupt entry point (see Device Header).	:
  2121                                  ;								:
  2122                                  ;----------------------------------------------------------------
  2123                                  
  2124                                  ; IBM ROM STATUS BITS (I DON'T TRUST THEM, NEITHER SHOULD YOU)             
  2125                                  									   
  2126                                  NOTBUSYSTATUS	equ 10000000b		; NOT BUSY			   
  2127                                  ACKSTATUS	equ 01000000b		; ACKNOWLEDGE (FOR WHAT?)	   
  2128                                  NOPAPERSTATUS	equ 00100000b		; NO MORE PAPER 		   
  2129                                  SELECTEDSTATUS	equ 00010000b		; THE PRINTER SAID IT WAS SELECTED 
  2130                                  IOERRSTATUS	equ 00001000b		; SOME KINDA ERROR		   
  2131                                  RESERVED	equ 00000110b		; NOPS				   
  2132                                  TIMEOUTSTATUS	equ 00000001b		; TIME OUT.			   
  2133                                  									   
  2134                                  									   
  2135                                  ; WARNING!!! THE IBM ROM DOES NOT RETURN JUST ONE BIT. IT RETURNS A	   
  2136                                  ; WHOLE SLEW OF BITS, ONLY ONE OF WHICH IS CORRECT.			   
  2137                                  									   
  2138                                  ;----------------------------------------------------------------
  2139                                  ;								:
  2140                                  ;		WRITE TO PRINTER DEVICE 			:
  2141                                  ;								:
  2142                                  ;   CX has count of bytes to be printed 			:
  2143                                  ;   ES:DI point to source buffer contains characters		:
  2144                                  ;   AuxNum (in msbio.asm) has printer number			:
  2145                                  ;								:
  2146                                  ;----------------------------------------------------------------
  2147                                  						   
  2148                                  PRN$WRIT:
  2149 0000079D E310                    		jcxz	EXVEC3			; no chars to output, Get out
  2150                                  PRN$LOOP:
  2151 0000079F BB0200                  		mov	BX,2			; Initialize retry flag
  2152                                  PRN$out:
  2153 000007A2 268A05                  		mov	AL,[ES:DI]		; Get a character into AL
  2154 000007A5 47                      		inc	DI			; Point to next character
  2155 000007A6 30E4                    		XOR	AH,AH			; AH=0 => OUTPUT CHAR IN DL	   
  2156 000007A8 E82400                  		call	PRNOP			; print character
  2157 000007AB 7505                    		jnz	short PrRetry 		; if error, try to print again
  2158 000007AD E2F0                    		loop	PRN$LOOP		; if more character, keep printing
  2159                                  EXVEC3:
  2160 000007AF E99AFE                  		jmp	EXIT
  2161                                  
  2162                                  PrRetry:
  2163 000007B2 4F                      		dec	DI			; undo the inc above...
  2164 000007B3 4B                      		dec	BX			; Decrement retry count
  2165 000007B4 75EC                    		jnz	short PRN$out 		; See if done with retrys
  2166                                  PMESSG:
  2167 000007B6 E97EFE                  		JMP	ERR$CNT 		; if so return with the error
  2168                                  
  2169                                  ;----------------------------------------------------------------
  2170                                  ;								:
  2171                                  ;		PRINTER STATUS ROUTINE				:
  2172                                  ;								:
  2173                                  ;----------------------------------------------------------------
  2174                                  ;
  2175                                  						   
  2176                                  PRN$STAT:
  2177 000007B9 E81100                  		call	PRNSTAT 		; get the status
  2178 000007BC 75F8                    		jnz	short PMESSG		; if error jump to error routine
  2179 000007BE B009                    		MOV	AL,9			; AGAIN, ASSUME OUT OF PAPER...    
  2180 000007C0 F6C420                  		TEST	AH,NOPAPERSTATUS					   
  2181 000007C3 75F1                    		JNZ	short PMESSG
  2182 000007C5 F6C480                  		TEST	AH,NOTBUSYSTATUS					   
  2183 000007C8 75E5                    		jnz	short EXVEC3		; if not busy return via EXVEC3
  2184 000007CA E964FE                  		JMP	BUS$EXIT		; else busy, return to busy exit   
  2185                                  
  2186                                  ;
  2187                                  ;   PRNSTAT	get printer status
  2188                                  ;   PRNOP	print a character
  2189                                  ;
  2190                                  ; PRNSTAT and PRNOP are two routines which call on the ROM-BIOS
  2191                                  ; printer routines.  The routines share code which calls on the bios and
  2192                                  ; then determines which, if any, error occured. PRNSTAT and PRNOP differ
  2193                                  ; only by the value put into AH before the ROM-BIOS call.
  2194                                  ;
  2195                                  ;   INPUT	if PRNOP then character in AL
  2196                                  ;
  2197                                  ;   OUTPUT	- AL holds error code
  2198                                  ;		- AH status byte from printer
  2199                                  ;		- flag NZ if error
  2200                                  
  2201                                  PRNSTAT:						   
  2202 000007CD B402                    		mov	AH,2			; set command for get status   *
  2203                                  PRNOP:
  2204 000007CF E89EFE                  		call	GETDX			; determine which printer      *
  2205 000007D2 CD17                    		int	17h			; call ROM-BIOS printer routine  *
  2206                                  
  2207 000007D4 F6C408                  		TEST	AH,IOERRSTATUS		; I/O ERROR?			   
  2208 000007D7 740A                    		JZ	short CHECKNOTREADY	; NO, TRY NOT READY		   
  2209                                  									   
  2210                                  ; AT THIS POINT, WE KNOW WE HAVE AN ERROR. THE CONVERSE IS NOT TRUE.	   
  2211                                  									   
  2212 000007D9 B009                    		MOV	AL,9			; FIRST, ASSUME OUT OF PAPER	   
  2213 000007DB F6C420                  		TEST	AH,NOPAPERSTATUS	; OUT OF PAPER SET?		   
  2214 000007DE 7502                    		JNZ	short RET1			; YES, ERROR IS SET
  2215 000007E0 FEC0                    		INC	AL			; INDICATE I/O ERROR		   
  2216                                  RET1:									   
  2217                                  									   
  2218                                  ; WE HAVE TRIAGED NOW FOR OUT OF PAPER AND IO ERR (IGNORING TIME-OUT)	   
  2219                                  									   
  2220 000007E2 C3                      		RETN				; RETURN WITH ERROR		   
  2221                                  									   
  2222                                  ; THE BITS SAID NO ERROR.  UNFORTUNATELY, THERE MAY BE OTHER THINGS AT WOR  K
  2223                                  ; HERE. 								   
  2224                                  									   
  2225                                  CHECKNOTREADY:								   
  2226 000007E3 B002                    		MOV	AL,2			; ASSUME NOT-READY		   
  2227 000007E5 F6C401                  		TEST	AH,TIMEOUTSTATUS	; IS TIME-OUT SET?		   
  2228                                  						; IF NZ THEN ERROR, ELSE OK???	   
  2229                                  PRNOP2: 								   
  2230 000007E8 C3                      		RETN
  2231                                  
  2232                                  ;26/05/2018
  2233                                  
  2234                                  ;----------------------------------------------------------------
  2235                                  ;								:
  2236                                  ;		Output until Busy				:
  2237                                  ;								:
  2238                                  ; Output until busy.  This entry point is used EXCLUSIVELY by	:
  2239                                  ; the print spoolers.  Under no curcumstances should the device :
  2240                                  ; driver block waiting for the device to become ready.		:
  2241                                  ;								:
  2242                                  ;   Inputs:	CX has count of bytes to output.		:
  2243                                  ;		ES:DI points to source buffer			:
  2244                                  ;   Outputs:	Set the number of bytes transferred		:
  2245                                  ;		  appropriately.				:
  2246                                  ;								:
  2247                                  ;----------------------------------------------------------------
  2248                                  
  2249                                  PRN$TILBUSY:
  2250 000007E9 1E                      	push	DS			; save DS
  2251 000007EA 06                      	push	ES			; copy ES to DS
  2252 000007EB 1F                      	pop	DS
  2253 000007EC 89FE                    	mov	SI,DI			; everything is set for LODSB
  2254                                  PRN$TilBLoop:
  2255 000007EE 51                      	push	CX
  2256 000007EF 53                      	push	BX
  2257 000007F0 31DB                    	xor	BX,BX
  2258 000007F2 2E8A1E[9505]            	mov	BL,[CS:PRINTDEV]
  2259 000007F7 D1E3                    	shl	BX,1
  2260 000007F9 2E8B8F[9605]            	mov	CX,[CS:BX+WAIT_COUNT]	; wait COUNT times to come ready
  2261 000007FE 5B                      	pop	BX
  2262                                  PRN$GetStat:
  2263 000007FF E8CBFF                  	call	PRNSTAT 		; get status
  2264 00000802 751E                    	jnz	short PRN$BPERR		; if error jump to error routine
  2265 00000804 F6C480                  	TEST	AH,10000000B		; READY YET?
  2266 00000807 E1F6                    	loopz	PRN$GetStat		; if busy keep trying
  2267 00000809 59                      	pop	CX			; get original count
  2268 0000080A 7417                    	jz	short PRN$BErr		; still not ready => done
  2269 0000080C AC                      	lodsb
  2270 0000080D 30E4                    	XOR	AH,AH
  2271 0000080F E8BDFF                  	call	PRNOP			; print the character
  2272 00000812 750F                    	jnz	short PRN$BErr		; error
  2273 00000814 E2D8                    	loop	PRN$TilBLoop		; go for more
  2274                                  PRN$B:
  2275 00000816 1F                      	pop	DS			; recover DS
  2276 00000817 2EC51E[B800]            	lds	BX,[CS:PTRSAV]		; get pointer to header
  2277                                  
  2278 0000081C 294F12                  	sub	[BX+COUNT],CX		; Determine number of succ. I/O's
  2279 0000081F E92AFE                  	jmp	EXIT			; all done, successful return
  2280                                  
  2281                                  PRN$BPERR:
  2282 00000822 59                      	pop	CX			; recover number of char left
  2283                                  PRN$BErr:
  2284 00000823 1F                      	pop	DS			; get pointer to header
  2285 00000824 2EC51E[B800]            	lds	BX,[CS:PTRSAV]
  2286 00000829 294F12                  	sub	[BX+COUNT],CX		; Determine number of succ. I/O's
  2287 0000082C E910FE                  	jmp	ERR$EXIT		; jump to error exit
  2288                                  
  2289                                  ;
  2290                                  ; Prn$GenIOCTL:
  2291                                  ;
  2292                                  ; Manipulates the value in WAIT_COUNT depending on the value passed in the
  2293                                  ; Generic IOCTL packet.
  2294                                  ; It either sets or returns the current value for the retry count for the
  2295                                  ; device.
  2296                                  ;
  2297                                  
  2298                                  PRN$GENIOCTL:
  2299                                  
  2300 0000082F C43E[B800]              	les	di,[PTRSAV]
  2301 00000833 26807D0D05              	cmp	byte [es:di+IOCTL_REQ.MAJORFUNCTION],IOC_PC
  2302 00000838 7403                    	je	short PrnFunc_OK
  2303                                  PrnFuncErr:
  2304 0000083A E9F8FD                  	jmp	CMDERR
  2305                                  
  2306                                  PrnFunc_OK:
  2307 0000083D 268A450E                	mov	al,[es:di+IOCTL_REQ.MINORFUNCTION]
  2308 00000841 26C47D13                	les	di,[es:di+IOCTL_REQ.GENERICIOCTL_PACKET]
  2309 00000845 31DB                    	xor	bx,bx
  2310 00000847 8A1E[9505]              	mov	bl,[PRINTDEV]		; get index into retry counts
  2311 0000084B D1E3                    	shl	bx,1
  2312 0000084D 8B8F[9605]              	mov	CX,[BX+WAIT_COUNT]	; pull out retry count for device
  2313 00000851 3C65                    	cmp	al,GET_RETRY_COUNT
  2314 00000853 7407                    	jz	short PrnGetCount
  2315 00000855 3C45                    	cmp	al,SET_RETRY_COUNT
  2316 00000857 75E1                    	jnz	short PrnFuncErr
  2317 00000859 268B0D                  	mov	cx,[es:di+A_RETRYCOUNT.RC_COUNT]  ; A_RETRYCOUNT.RC_COUNT = 0 
  2318                                  PrnGetCount:
  2319 0000085C 898F[9605]              	mov	[BX+WAIT_COUNT],CX	; place "new" retry count
  2320 00000860 26890D                  	mov	[es:di+A_RETRYCOUNT.RC_COUNT],cx ; return current retry count
  2321 00000863 E9E6FD                  	jmp	EXIT
  2322                                  
  2323                                  	; Temporary !
  2324                                  	; 25/08/2022 - IBMBIO.COM (IBMBIO33.IDB) address compatibility!
  2325                                  	;db	0
  2326                                  
  2327                                  ;-----------------------------------------------------------------------------
  2328                                  ; MSCLOCK.ASM - MSDOS 3.3 - 24/07/1987
  2329                                  ;-----------------------------------------------------------------------------
  2330                                  ; 23/03/2018 - Retro DOS v2.0
  2331                                  
  2332                                  ;----------------------------------------				  
  2333                                  ;	CMOS EQUATES FOR THIS SYSTEM	:  ; 26/03/2018 - CMOSEQU.INC, 1987
  2334                                  ;-----------------------------------------------------------------------------
  2335                                  CMOS_PORT	EQU	070H		; I/O ADDRESS OF CMOS ADDRESS PORT	 
  2336                                  CMOS_DATA	EQU	071H		; I/O ADDRESS OF CMOS DATA PORT 	 
  2337                                  NMI		EQU	10000000B	; DISABLE NMI INTERRUPTS MASK - 	 
  2338                                  					;  HIGH BIT OF CMOS LOCATION ADDRESS
  2339                                  ;---------- CMOS TABLE LOCATION ADDRESS'S ## --------------------------------- 
  2340                                  CMOS_SECONDS	EQU	000H		; SECONDS				 
  2341                                  CMOS_SEC_ALARM	EQU	001H		; SECONDS ALARM  ## NOTE:  ALL LOCATIONS 
  2342                                  CMOS_MINUTES	EQU	002H		; MINUTES	      | IN THE CMOS AREA 
  2343                                  CMOS_MIN_ALARM	EQU	003H		; MINUTES ALARM       | ARE IBM USE ONLY 
  2344                                  CMOS_HOURS	EQU	004H		; HOURS 	      | AND  SUBJECT  TO 
  2345                                  CMOS_HR_ALARM	EQU	005H		; HOURS ALARM	      | CHANGE. ONLY THE 
  2346                                  CMOS_DAY_WEEK	EQU	006H		; DAY OF THE WEEK     | POST & BIOS CODE 
  2347                                  CMOS_DAY_MONTH	EQU	007H		; DAY OF THE MONTH    | SHOULD	DIRECTLY 
  2348                                  CMOS_MONTH	EQU	008H		; MONTH 	      | ACCESS LOCATIONS 
  2349                                  CMOS_YEAR	EQU	009H		; YEAR (TWO DIGITS)   | IN CMOS STORAGE. 
  2350                                  CMOS_REG_A	EQU	00AH		; STATUS REGISTER A   '----------------- 
  2351                                  CMOS_REG_B	EQU	00BH		; STATUS REGISTER B  ALARM		 
  2352                                  CMOS_REG_C	EQU	00CH		; STATUS REGISTER C  FLAGS		 
  2353                                  CMOS_REG_D	EQU	00DH		; STATUS REGISTER D  BATTERY		 
  2354                                  CMOS_DIAG	EQU	00EH		; POST DIAGNOSTIC STATUS RESULTS BYTE	 
  2355                                  CMOS_SHUT_DOWN	EQU	00FH		; SHUTDOWN STATUS COMMAND BYTE		 
  2356                                  CMOS_DISKETTE	EQU	010H		; DISKETTE DRIVE TYPE BYTE	      ;  
  2357                                  ;		EQU	011H		; - RESERVED			      ;C 
  2358                                  CMOS_DISK	EQU	012H		; FIXED DISK TYPE BYTE		      ;H 
  2359                                  ;		EQU	013H		; - RESERVED			      ;E 
  2360                                  CMOS_EQUIP	EQU	014H		; EQUIPMENT WORD LOW BYTE	      ;C 
  2361                                  CMOS_B_M_S_LO	EQU	015H		; BASE MEMORY SIZE - LOW BYTE (X1024) ;K 
  2362                                  CMOS_B_M_S_HI	EQU	016H		; BASE MEMORY SIZE - HIGH BYTE	      ;S 
  2363                                  CMOS_E_M_S_LO	EQU	017H		; EXPANSION MEMORY SIZE - LOW BYTE    ;U 
  2364                                  CMOS_E_M_S_HI	EQU	018H		; EXPANSION MEMORY SIZE - HIGH BYTE   ;M 
  2365                                  CMOS_DISK_1	EQU	019H		; FIXED DISK TYPE - DRIVE C EXTENSION ;E 
  2366                                  CMOS_DISK_2	EQU	01AH		; FIXED DISK TYPE - DRIVE D EXTENSION ;D 
  2367                                  ;		EQU	01BH		; - 1BH THROUGH 2DH - RESERVED	      ;  
  2368                                  CMOS_CKSUM_HI	EQU	02EH		; CMOS CHECKSUM - HIGH BYTE	      ;* 
  2369                                  CMOS_CKSUM_LO	EQU	02FH		; CMOS CHECKSUM - LOW BYTE	      ;* 
  2370                                  CMOS_U_M_S_LO	EQU	030H		; USABLE MEMORY ABOVE 1 MEG - LOW BYTE	 
  2371                                  CMOS_U_M_S_HI	EQU	031H		; USABLE MEMORY ABOVE 1 MEG - HIGH BYTE  
  2372                                  CMOS_CENTURY	EQU	032H		; DATE CENTURY BYTE (BCD)		 
  2373                                  CMOS_INFO128	EQU	033H		; 128KB INFORMATION STATUS FLAG BYTE	 
  2374                                  ;		EQU	034H		; - 34H THROUGH 3FH - RESERVED
  2375                                  
  2376                                  ;----------------------------------------------------------------
  2377                                  ;								:
  2378                                  ;		    CLOCK DEVICE DRIVER 			:
  2379                                  ;								:
  2380                                  ;								:
  2381                                  ;   This file contains the Clock Device Driver. 		:
  2382                                  ;								:
  2383                                  ;   The routines in this files are:				:
  2384                                  ;								:
  2385                                  ;	routine 		function			:
  2386                                  ;	------- 		--------			:
  2387                                  ;	TIM$WRIT		Set the current time		:
  2388                                  ;	TIM$READ		Read the current time		:
  2389                                  ;	Time_To_Ticks		Convert time to corresponding	:
  2390                                  ;				  number of clock ticks 	:
  2391                                  ;								:
  2392                                  ; The clock ticks at the rate of:				:
  2393                                  ;								:
  2394                                  ;	1193180/65536 ticks/second (about 18.2 ticks per second):
  2395                                  ; See each routine for information on the use.			:
  2396                                  ;								:
  2397                                  ;----------------------------------------------------------------
  2398                                  
  2399                                  ;
  2400                                  ; DAYCNT is the number of days since 1-1-80.
  2401                                  ; Each time the clock is read it is necessary to check if another day has
  2402                                  ; passed.  The ROM only returns the day rollover once so if it is missed
  2403                                  ; the time will be off by a day.
  2404                                  ;
  2405                                  
  2406                                  ;26/05/2018
  2407                                  
  2408                                  ; variables for real time clock setting
  2409                                  HaveCMOSClock:
  2410 00000866 00                      		db	0	;set by MSINIT.
  2411                                  base_century:
  2412 00000867 13                      		db	19
  2413                                  base_year:
  2414 00000868 50                      		db	80
  2415                                  month_tab:
  2416 00000869 1F1C1F1E1F1E1F1F1E-     		db	31,28,31,30,31,30,31,31,30,31,30,31
  2416 00000872 1F1E1F             
  2417                                  
  2418                                  ; The following are indirect intra-segment call addresses. The
  2419                                  ;procedures are defined in MSINIT for relocation.  MSINIT will set these
  2420                                  ;address when the relocation is done.
  2421                                  	
  2422                                  BinToBCD:
  2423 00000875 0000                    		dw	0	;should point to Bin_To_BCD proc in MSINIT
  2424                                  
  2425                                  DaycntToDay:
  2426 00000877 0000                    		dw	0	;should point to Daycnt_to_day in MSINIT
  2427                                  
  2428                                  ;********************************************************************
  2429                                  ; Indirect call address of TIME_TO_TICKS procedure.
  2430                                  ;This will be used by the relocatable portable suspend/resume code.
  2431                                  
  2432                                  TimeToTicks:
  2433 00000879 [D508]                  		dw	TIME_TO_TICKS
  2434                                  
  2435                                  ;--------------------------------------------------------------------
  2436                                  ;
  2437                                  ; Settime sets the current time
  2438                                  ;
  2439                                  ; On entry ES:[DI] has the current time:
  2440                                  ;
  2441                                  ;	number of days since 1-1-80	(WORD)
  2442                                  ;	minutes (0-59)			(BYTE)
  2443                                  ;	hours (0-23)			(BYTE)
  2444                                  ;	hundredths of seconds (0-99)	(BYTE)
  2445                                  ;	seconds (0-59)			(BYTE)
  2446                                  ;
  2447                                  ; Each number has been checked for the correct range.
  2448                                  ;
  2449                                  
  2450                                  TIM$WRIT:
  2451 0000087B 268B05                  		mov	AX,[ES:DI]
  2452 0000087E 50                      		push	AX		;DAYCNT. We need to set this at the very
  2453                                  					;  end to avoid tick windows.
  2454                                  		
  2455                                  		;11/06/2018
  2456                                  		;26/05/2018
  2457                                  
  2458                                  		;;Rev 3.30 Modification
  2459 0000087F 803E[6608]00            		cmp	byte [HaveCMOSClock], 0
  2460 00000884 7426                    		je	short No_CMOS_1
  2461 00000886 268A4503                		mov	al,[es:di+3]		;get binary hours
  2462 0000088A FF16[7508]              		call	word [BinToBCD]		;convert to BCD
  2463                                  		; Temporary !
  2464                                  		; 25/08/2022 - IBMBIO.COM (IBMBIO33.IDB) address compatibility!
  2465                                  		;call	word [cs:BinToBCD]
  2466 0000088E 88C5                    		mov	ch,al			;CH = BCD hours
  2467 00000890 268A4502                		mov	al,[es:di+2]		;get binary minutes
  2468 00000894 FF16[7508]              		call	word [BinToBCD]		;convert to BCD
  2469                                  		; Temporary !
  2470                                  		; 25/08/2022 - IBMBIO.COM (IBMBIO33.IDB) address compatibility!
  2471                                  		;call	word [cs:BinToBCD]
  2472 00000898 88C1                    		mov	cl,al			;CL = BCD minutes
  2473 0000089A 268A4505                		mov	al,[es:di+5]		;get binary seconds
  2474 0000089E FF16[7508]              		call	word [BinToBCD]		;convert to BCD
  2475                                  		; Temporary !
  2476                                  		; 25/08/2022 - IBMBIO.COM (IBMBIO33.IDB) address compatibility!
  2477                                  		;call	word [cs:BinToBCD]
  2478 000008A2 88C6                    		mov	dh,al			;DH = BCD seconds
  2479 000008A4 B200                    		mov	dl,0			;DL = 0 (ST) or 1 (DST)
  2480 000008A6 FA                      		cli				;turn off timer
  2481 000008A7 B403                    		mov	ah,03h			;set RTC time
  2482                                  		; Temporary !
  2483                                  		; 25/08/2022 - IBMBIO.COM (IBMBIO33.IDB) address compatibility!
  2484                                  		;mov	ax, 0300h
  2485 000008A9 CD1A                    		int	1Ah			;call rom bios clock routine
  2486 000008AB FB                      		sti
  2487                                  		;;End of Modification
  2488                                  No_CMOS_1:
  2489 000008AC 268B4D02                		mov	CX,[ES:DI+2]
  2490 000008B0 268B5504                		mov	DX,[ES:DI+4]
  2491                                  		;;Rev 3.30 Modification
  2492 000008B4 E81E00                  		call	TIME_TO_TICKS		; convert time to ticks
  2493                                  						;CX:DX now has time in ticks
  2494 000008B7 FA                      		cli				; Turn off timer
  2495 000008B8 B401                    		mov	AH, 1			; command is set time in clock
  2496 000008BA CD1A                    		int	1Ah			; call rom-bios clock routines
  2497 000008BC 8F06[9E05]              		pop	word [DAYCNT]
  2498 000008C0 FB                      		sti
  2499                                  		;CMOS clock -------------------------------------
  2500 000008C1 803E[6608]00            		cmp	byte [HaveCMOSClock], 0
  2501 000008C6 740A                    		je	short No_CMOS_2
  2502                                  		; 13/06/2018
  2503 000008C8 FF16[7708]              		call	word [DaycntToDay]	; convert to BCD format
  2504                                  		; Temporary !
  2505                                  		; 25/08/2022 - IBMBIO.COM (IBMBIO33.IDB) address compatibility!
  2506                                  		;call	word [cs:DaycntToDay]
  2507 000008CC FA                      		cli				; Turn off timer
  2508 000008CD B405                    		mov	AH,05h			; set RTC date
  2509 000008CF CD1A                    		int	1Ah			; call rom-bios clock routines
  2510 000008D1 FB                      		sti
  2511                                  		;------------------------------------------------
  2512                                  No_CMOS_2:
  2513 000008D2 E977FD                  		jmp	EXIT
  2514                                  		;;End of Modification
  2515                                  
  2516                                  ;
  2517                                  ; convert time to ticks
  2518                                  ; input : time in CX and DX
  2519                                  ; ticks returned in CX:DX
  2520                                  ;
  2521                                  
  2522                                  TIME_TO_TICKS:
  2523                                  		; first convert from Hour,min,sec,hund. to
  2524                                  		; total number of 100th of seconds
  2525 000008D5 B03C                    		mov	AL,60
  2526 000008D7 F6E5                    		mul	CH		;Hours to minutes
  2527 000008D9 B500                    		mov	CH,0
  2528 000008DB 01C8                    		add	AX,CX		;Total minutes
  2529 000008DD B97017                  		mov	CX,6000 	;60*100
  2530 000008E0 89D3                    		mov	BX,DX		;Get out of the way of the multiply
  2531 000008E2 F7E1                    		mul	CX		;Convert to 1/100 sec
  2532 000008E4 89C1                    		mov	CX,AX
  2533 000008E6 B064                    		mov	AL,100
  2534 000008E8 F6E7                    		mul	BH		;Convert seconds to 1/100 sec
  2535 000008EA 01C1                    		add	CX,AX		;Combine seconds with hours and min.
  2536 000008EC 83D200                  		adc	DX,0		;Ripple carry
  2537 000008EF B700                    		mov	BH,0
  2538 000008F1 01D9                    		add	CX,BX		;Combine 1/100 sec
  2539 000008F3 83D200                  		adc	DX,0
  2540                                  
  2541                                  		;;Rev 3.30 Modification
  2542                                  		;DX:CX IS TIME IN 1/100 SEC
  2543 000008F6 92                      		XCHG	AX,DX
  2544 000008F7 91                      		XCHG	AX,CX		;NOW TIME IS IN CX:AX
  2545 000008F8 BB0BE9                  		MOV	BX,59659
  2546 000008FB F7E3                    		MUL	BX		;MULTIPLY LOW HALF
  2547 000008FD 87D1                    		XCHG	DX,CX
  2548 000008FF 92                      		XCHG	AX,DX		;CX->AX, AX->DX, DX->CX
  2549 00000900 F7E3                    		MUL	BX		;MULTIPLY HIGH HALF
  2550 00000902 01C8                    		ADD	AX,CX		;COMBINE OVERLAPPING PRODUCTS
  2551 00000904 83D200                  		ADC	DX,0
  2552 00000907 92                      		XCHG	AX,DX		;AX:DX=TIME*59659
  2553 00000908 BB0500                  		MOV	BX,5
  2554 0000090B F6F3                    		DIV	BL		;DIVIDE HIGH HALF BY 5
  2555 0000090D 88C1                    		MOV	CL,AL
  2556 0000090F B500                    		MOV	CH,0
  2557 00000911 88E0                    		MOV	AL,AH		;REMAINDER OF DIVIDE-BY-5
  2558 00000913 98                      		CBW
  2559 00000914 92                      		XCHG	AX,DX		;USE IT TO EXTEND LOW HALF
  2560 00000915 F7F3                    		DIV	BX		;DIVIDE LOW HALF BY 5
  2561 00000917 89C2                    		MOV	DX,AX
  2562                                  			; CX:DX is now number of ticks in time
  2563 00000919 C3                      		retn
  2564                                  
  2565                                  ;
  2566                                  ; Gettime reads date and time
  2567                                  ; and returns the following information:
  2568                                  ;
  2569                                  ;	ES:[DI]  =count of days since 1-1-80
  2570                                  ;	ES:[DI+2]=hours
  2571                                  ;	ES:[DI+3]=minutes
  2572                                  ;	ES:[DI+4]=seconds
  2573                                  ;	ES:[DI+5]=hundredths of seconds
  2574                                  ;
  2575                                  
  2576                                  TIM$READ:				; read the clock
  2577 0000091A 30E4                    		xor	AH, AH		; set command to read clock
  2578 0000091C CD1A                    		int	1Ah		; call rom-bios to get time
  2579                                  
  2580 0000091E 08C0                    		or	al,al		; check for a new day
  2581 00000920 7404                    		jz	short noroll1 	; if al=0 then don't reset day count
  2582 00000922 FF06[9E05]              		INC	word [DAYCNT]	; CATCH ROLLOVE
  2583                                  noroll1:
  2584 00000926 8B36[9E05]              		MOV	SI,[DAYCNT]
  2585                                  
  2586                                  ;
  2587                                  ; we now need to convert the time in tick to the time in 100th of
  2588                                  ; seconds.  The relation between tick and seconds is:
  2589                                  ;
  2590                                  ;		 65536 seconds
  2591                                  ;	       ----------------
  2592                                  ;		1,193,180 tick
  2593                                  ;
  2594                                  ; To get to 100th of second we need to multiply by 100. The equation is:
  2595                                  ;
  2596                                  ;	Ticks from clock  * 65536 * 100
  2597                                  ;      ---------------------------------  = time in 100th of seconds
  2598                                  ;		1,193,180
  2599                                  ;
  2600                                  ; Fortunately this formula simplifies to:
  2601                                  ;
  2602                                  ;	Ticks from clock * 5 * 65,536
  2603                                  ;      --------------------------------- = time in 100th of seconds
  2604                                  ;		59,659
  2605                                  ;
  2606                                  ; The calculation is done by first multipling tick by 5. Next we divide by
  2607                                  ; 59,659.  In this division we multiply by 65,536 by shifting the dividend
  2608                                  ; my 16 bits to the left.
  2609                                  ;
  2610                                  ; start with ticks in CX:DX
  2611                                  ; multiply by 5
  2612 0000092A 89C8                    		MOV	AX,CX
  2613 0000092C 89D3                    		MOV	BX,DX
  2614 0000092E D1E2                    		SHL	DX,1
  2615 00000930 D1D1                    		RCL	CX,1		;TIMES 2
  2616 00000932 D1E2                    		SHL	DX,1
  2617 00000934 D1D1                    		RCL	CX,1		;TIMES 4
  2618 00000936 01DA                    		ADD	DX,BX
  2619 00000938 11C8                    		ADC	AX,CX		;TIMES 5
  2620 0000093A 92                      		XCHG	AX,DX		
  2621                                  	
  2622                                  
  2623                                  ; now have ticks * 5 in DX:AX
  2624                                  ; we now need to multiply by 65,536 and divide by 59659 d.
  2625                                  
  2626 0000093B B90BE9                  		mov	CX,59659	; get divisor
  2627 0000093E F7F1                    		div	CX
  2628                                  					; DX now has remainder
  2629                                  					; AX has high word of final quotient
  2630 00000940 89C3                    		mov	BX,AX		; put high work if safe place
  2631 00000942 31C0                    		xor	AX,AX		; this is the multiply by 65536
  2632 00000944 F7F1                    		div	CX		; BX:AX now has time in 100th of seconds
  2633                                  
  2634                                  ;
  2635                                  ;Rounding based on the remainder may be added here
  2636                                  ;The result in BX:AX is time in 1/100 second.
  2637 00000946 89DA                    		mov	DX,BX
  2638 00000948 B9C800                  		mov	CX,200		;Extract 1/100's
  2639                                  ;Division by 200 is necessary to ensure no overflow--max result
  2640                                  ;is number of seconds in a day/2 = 43200.
  2641 0000094B F7F1                    		div	CX
  2642 0000094D 80FA64                  		cmp	DL,100		;Remainder over 100?
  2643 00000950 7203                    		jb	short NOADJ
  2644 00000952 80EA64                  		sub	DL,100		;Keep 1/100's less than 100
  2645                                  NOADJ:
  2646 00000955 F5                      		cmc			;If we subtracted 100, carry is now set
  2647 00000956 88D3                    		mov	BL,DL		;Save 1/100's
  2648                                  ;To compensate for dividing by 200 instead of 100, we now multiply
  2649                                  ;by two, shifting a one in if the remainder had exceeded 100.
  2650 00000958 D1D0                    		rcl	AX,1
  2651 0000095A B200                    		mov	DL,0
  2652 0000095C D1D2                    		rcl	DX,1
  2653 0000095E B93C00                  		mov	CX,60		;Divide out seconds
  2654 00000961 F7F1                    		div	CX
  2655 00000963 88D7                    		mov	BH,DL		;Save the seconds
  2656 00000965 F6F1                    		div	CL		;Break into hours and minutes
  2657 00000967 86C4                    		xchg	AL,AH
  2658                                  
  2659                                  ;Time is now in AX:BX (hours, minutes, seconds, 1/100 sec)
  2660                                  
  2661 00000969 50                      		push	AX
  2662 0000096A 89F0                    		MOV	AX,SI		; DAYCNT
  2663 0000096C AB                      		stosw
  2664 0000096D 58                      		pop	AX
  2665 0000096E AB                      		stosw
  2666 0000096F 89D8                    		mov	AX,BX
  2667 00000971 AB                      		stosw
  2668 00000972 E9D7FC                  		jmp	EXIT
  2669                                  
  2670                                  ;-----------------------------------------------------------------------------
  2671                                  ; MSDISK.ASM (1) - MSDOS 3.3 - 02/02/1988
  2672                                  ;-----------------------------------------------------------------------------
  2673                                  ; 26/05/2018 - Retro DOS v3.0
  2674                                  ; 23/03/2018 - Retro DOS v2.0
  2675                                  
  2676                                  ;------------------------------------------------------------------------
  2677                                  ;									:
  2678                                  ;	       DISK INTERFACE ROUTINES					:
  2679                                  ;									:
  2680                                  ;									:
  2681                                  ;   This file contains the Disk Device Driver.				:
  2682                                  ;									:
  2683                                  ;   The routines in this files are:					:
  2684                                  ;									:
  2685                                  ;	routine 		function				:
  2686                                  ;	------- 		--------				:
  2687                                  ;									:
  2688                                  ;	MEDIA$CHK		Determine if media in drive has changed :
  2689                                  ;									:
  2690                                  ;	GET$BPB 		Build a valid BPB for drive		:
  2691                                  ;									:
  2692                                  ;	DSK$REM 		Determine if disk has removable media	:
  2693                                  ;									:
  2694                                  ;	DSK$WRTV		Disk write with verify			:
  2695                                  ;									:
  2696                                  ;	DSK$WRT 		Disk write				:
  2697                                  ;									:
  2698                                  ;	DSK$READ		Read disk				:
  2699                                  ;									:
  2700                                  ;									:
  2701                                  ;  These routines are not called directly.  Call are made via		:
  2702                                  ; the strategy and interrupt entry point (see Device Header).		:
  2703                                  ;									:
  2704                                  ;  Data structures:							:
  2705                                  ;	There are two main types of data structures associated with	:
  2706                                  ;  the disk drives.  The first is the BDS.  BDS is the Bios Data	:
  2707                                  ;  structure.  There is one BDS for each logical drive in the system.	:
  2708                                  ;  All the BDS's are linked together in a list with the pointer to the  :
  2709                                  ;  first BDS being found in START_BDS.	The BDS hold various values	:
  2710                                  ;  important to the disk drive.  For example there is a field for last	:
  2711                                  ;  time accesses.  As actions take place in the system the BDS are	:
  2712                                  ;  update to reflect the actions.  For example if there is a read to	:
  2713                                  ;  a disk the last access field for the BDS for that drive is updated	:
  2714                                  ;  to the current time. 						:
  2715                                  ;	 The second data structure associated with disk drives is the	:
  2716                                  ;  BPB.  A BPB is a Bios Parameter Block.  The BPB contains information :
  2717                                  ;  about the media inside a disk drive.  Some on the fields in the BPB	:
  2718                                  ;  are Sectors per track, number of FATs, and number of tracks.  This	:
  2719                                  ;  information is used to tell where sectors are on the disk.  For	:
  2720                                  ;  example,  if we need to read logical sector 52:			:
  2721                                  ;									:
  2722                                  ;	Diskette			Track	Sector	Side		:
  2723                                  ;    single density							:
  2724                                  ;    eight sectors per track		  6	   5	  0		:
  2725                                  ;									:
  2726                                  ;    double density							:
  2727                                  ;    nine sectors per track		  2	   7	  1		:
  2728                                  ;									:
  2729                                  ;  The BPB for the media in the drive is stored in the BDS for the	:
  2730                                  ;  drive.  If the user changes the floppy in the drive a call is	:
  2731                                  ;  made to GET$BPB to build a new BPB in the BDS.  See this routine	:
  2732                                  ;  for the algorithm.							:
  2733                                  ;									:
  2734                                  ;									:
  2735                                  ;------------------------------------------------------------------------
  2736                                  
  2737                                  ;
  2738                                  ; Maximum number of retries in case of error
  2739                                  ;
  2740                                  
  2741                                  MAXERR	EQU 5
  2742                                  LSTDRV	EQU 0504h
  2743                                  
  2744                                  ;
  2745                                  ; Some floppy drives do not have changeline support.  The result is a
  2746                                  ; large amount of inefficiency in the code.  A media-check always returns
  2747                                  ; "I don`t know".  This cause DOS to reread the FAT on every access and
  2748                                  ; always discard any cached data.
  2749                                  ;    We get around this inefficiency by implementing a "Logical Door Latch".
  2750                                  ; The following three items are used to do this.  The logical door latch is
  2751                                  ; based on the premise that it is not physically possible to change floppy
  2752                                  ; disks in a drive in under two seconds (most people take about 10).  The
  2753                                  ; logical door latch is implemented by saving the time of the last successful
  2754                                  ; disk operation (in the value TIM_DRV).  When a new request is made the
  2755                                  ; current time is compared to the saved time.  If less than two seconds have
  2756                                  ; passed then the value "No Change" is returned.  If more than two seconds
  2757                                  ; have passed the value "Don't Know" is returned.
  2758                                  ;    There is one complecation to this algorithm.  Some programs change the
  2759                                  ; value of the timer.  In this unfortunate case we have an invalid timer.
  2760                                  ; This possiblity is detected by counting the number of disk operations
  2761                                  ; which occur without any time passing.  If this count exceeds the value of
  2762                                  ; "AccessMax" we assume the counter is invalid and always return "Don't
  2763                                  ; Know".  The variable "AccessCount" is used to keep track of the number
  2764                                  ; of disk operation which occur without the time changing.
  2765                                  ;
  2766                                  
  2767                                  AccessMax EQU 5
  2768                                  
  2769                                  ;
  2770                                  ; Some of the older versions of the IBM rom-bios always assumed a seek would
  2771                                  ; have to be made to read the diskette.  Consequently a large head settle
  2772                                  ; time was always used in the I/O operations.  To get around this problem
  2773                                  ; we need to continually adjust the head settle time.  The following
  2774                                  ; algorithm is used:
  2775                                  ;
  2776                                  ;   Get the current head settle value.
  2777                                  ;   If it is 1, then
  2778                                  ;	set slow = 15
  2779                                  ;   else
  2780                                  ;	set slow = value
  2781                                  ;   ...
  2782                                  ;   if we are seeking and writing then
  2783                                  ;	use slow
  2784                                  ;   else
  2785                                  ;	use fast
  2786                                  ;   ...
  2787                                  ;   restore current head settle value
  2788                                  ;
  2789                                  
  2790                                  ;
  2791                                  ; flags for size of FAT
  2792                                  ;
  2793                                  
  2794                                  fTOOBIG	EQU 80h
  2795                                  fBIG	EQU 40h
  2796                                  
  2797                                  error_unknown_media equ	7	; for use in BUILD BPB call
  2798                                  
  2799                                  struc BPB_TYPE
  2800 00000000 ????                    .SECSIZE:	resw 1
  2801 00000002 ??                      .SECALL:	resb 1
  2802 00000003 ????                    .RESNUM:	resw 1
  2803 00000005 ??                      .FATNUM:	resb 1
  2804 00000006 ????                    .DIRNUM:	resw 1
  2805 00000008 ????                    .SECNUM:	resw 1
  2806 0000000A ??                      .FATID:		resb 1
  2807 0000000B ????                    .FATSIZE:	resw 1
  2808 0000000D ????                    .SLIM:		resw 1
  2809 0000000F ????                    .HLIM:		resw 1
  2810 00000011 ????                    .HIDDEN:	resw 1
  2811                                  .size:
  2812                                  endstruc
  2813                                  
  2814                                  ;------------------------------------------------------------------------
  2815                                  ;									:
  2816                                  ; The next 100 or so lines of code do the Media Check.	Media Check	:
  2817                                  ; determines if the diskette (media) in the drive has been changed.	:
  2818                                  ;									:
  2819                                  ;	SI is used to hold media check code:				:
  2820                                  ;			-1	media changed				:
  2821                                  ;			 0	Don't know                              :
  2822                                  ;			 1	media has not been changed		:
  2823                                  ;									:
  2824                                  ; The algorithm used is a follows:					:
  2825                                  ;	if (hard disk)							:
  2826                                  ;	    if (changed by format)					:
  2827                                  ;		   return (not changed) 				:
  2828                                  ;	    if	not (changed by format) 				:
  2829                                  ;		   return (changed)					:
  2830                                  ;	else we have a floppy						:
  2831                                  ;	    if floppy has change line support go ask the floppy 	:
  2832                                  ;	    if floppy does not have change line do the following	:
  2833                                  ;		read the time						:
  2834                                  ;		if more than two second have passed return don't know   :
  2835                                  ;		if no time has passed then might be unreliable		:
  2836                                  ;		  counter (some program fool with the counter when	:
  2837                                  ;		  they should not).  See note below for procedure with	:
  2838                                  ;		  unreliable counter					:
  2839                                  ;		if sometime has passed but not two second return	:
  2840                                  ;		  media has not changed.  This is based on the		:
  2841                                  ;		  assumption that it is not physically possible to	:
  2842                                  ;		  change a disk in less the two seconds (most people	:
  2843                                  ;		  take about 10 seconds).				:
  2844                                  ;									:
  2845                                  ;------------------------------------------------------------------------
  2846                                  
  2847                                  MEDIA$CHK:
  2848                                  		; 13/06/2018
  2849                                  		; 26/05/2018 - Retro DOS v3.0
  2850                                  		; (Volume Serial Number Check)
  2851                                  
  2852                                  		; 08/04/2018
  2853                                  		; Retro DOS v2.0
  2854                                  		; (Media check code here is mix of MSDOS 2.0, MSDOS 3.3
  2855                                  		; and Retro DOS v2.0 special media -disk change- check code..)
  2856                                  		; (..it is not compatible with MSDOS 3.3 mediacheck)
  2857                                  		; (Excluded methods: Volume Serial Number Check,
  2858                                  		; "fChanged_By_Format" check -via int 13h hook-)
  2859                                  
  2860                                  		; 26/05/2018
  2861                                  
  2862 00000975 E87D02                  		call	SETDRIVE ; point DS:DI to BDS for specified drive	
  2863                                  
  2864 00000978 2E813E[8B01]6B6A        		cmp	word [CS:Secrete_Code], 'kj' ; Secrete code for
  2865 0000097F 7546                    		jne	short Media$Done	; DOS 3.3 MSBIO.
  2866                                  		
  2867                                  		;cmp	AL, 1	; Retro DOS v2.0 method
  2868                                  				; We will not check disk change status
  2869                                  				; if disk/unit number > 1.
  2870                                  				; (hard disk or diskette 3 ! or diskette 4 !)
  2871                                  		;ja	short Media$Done
  2872                                  
  2873                                  ;
  2874                                  ; For non-removable disks only return changed if changed by format,
  2875                                  ; otherwise return 'not changed'.
  2876                                  ;
  2877 00000981 BE0100                  		mov	si,1		; assume no change
  2878 00000984 F745290001              		test	word [DI+BDS.Flags],fChanged_By_Format
  2879 00000989 7417                    		jz	short WeAreNotFakingIt
  2880                                  					; reset flag
  2881 0000098B 816529FFFE              		and	word [DI+BDS.Flags],~fChanged_By_Format
  2882                                  
  2883                                  ;
  2884                                  ; If media has been changed by format, must use the ROM.
  2885                                  ; Cannot rely on the 2 second time check.
  2886                                  ;
  2887 00000990 2EC606[1502]FF          		mov	byte [CS:TIM_DRV],-1  ; Ensure that we ask the ROM if
  2888                                  					      ; media has changed
  2889 00000996 F745290100              		test	word [DI+BDS.Flags],fNon_Removable
  2890 0000099B 740C                    		jz	short WeHaveAFloppy
  2891 0000099D BEFFFF                  		mov	SI,-1			; Indicate media changed
  2892 000009A0 EB25                    		jmp	short Media$Done
  2893                                  ;
  2894                                  ; return 'not changed' if disk is a hard file.
  2895                                  ;
  2896                                  
  2897                                  WeAreNotFakingIt:
  2898 000009A2 F745290100              		test	word [DI+BDS.Flags],fNon_Removable
  2899 000009A7 751E                    		jnz	short Media$Done
  2900                                  
  2901                                  		;
  2902                                  		; return 'not changed' if disk is a hard file.
  2903                                  		;
  2904                                  
  2905                                  		;mov	si,1    ; not changed
  2906                                  
  2907                                  		;cmp	al, [CS:HARDNUM]
  2908                                  		;jnb	short Media$Done ; fixed/hard disk !
  2909                                  
  2910                                  ;
  2911                                  ; If this code is reached disk is a diskette drive
  2912                                  ;
  2913                                  
  2914                                  WeHaveAFloppy:
  2915 000009A9 31F6                    		xor	si,si	; Presume "I don't know"
  2916                                  
  2917                                  		; 11/04/2018
  2918                                  		;mov	[CS:MEDIACHK_DRV], al ; Retro DOS v2.0 method 
  2919                                  		; 13/04/2018
  2920                                  		;mov	[MEDIACHK_DRV], al
  2921                                  
  2922                                  ;
  2923                                  ; If drive is a floppy with changeline support the rom is called to
  2924                                  ; determine if the media has changed. It is not necessary to do the 2
  2925                                  ; second check on these drives.
  2926                                  ;
  2927                                  		;CALL	MediaCheck
  2928                                  
  2929                                  		; DL = drive number (0..3) ; 13/04/2018
  2930                                  
  2931                                  		;and	si, si
  2932                                  		;jnz	short Media$Done
  2933                                  
  2934                                  		; SI = 0, "I don't know" (if media has been changed or not!?)
  2935                                  
  2936                                  		;inc	si	; 1 = no change
  2937                                  		 
  2938                                  		; 26/05/2018 - Retro DOS v3.0
  2939                                  		;----------------------------------------|
  2940                                  		; Warning: Do not change the following. ;|
  2941                                  		;	   It gets patched in MSINIT	;|
  2942                                  							;|
  2943                                  Media_Patch:						;|
  2944 000009AB E82212                  		CALL	MediaCheck			;|
  2945 000009AE 7233                    		jc	short ERR$EXITJ			;|
  2946 000009B0 E89413                  		call	HasChange			;|
  2947 000009B3 7512                    		jnz	short Media$Done		;|
  2948                                  		;----------------------------------------|
  2949                                  
  2950                                  ;
  2951                                  ; If this code is reached the drive is a floppy with no changeline support
  2952                                  ;
  2953                                  
  2954 000009B5 BE0100                  		MOV	SI,1			; PRESUME NO CHANGE
  2955 000009B8 2EA0[1502]              		mov	al,[CS:TIM_DRV] 	; last drive accessed
  2956                                  						;is drive of last access the same?
  2957                                  		;mov	al,[TIM_DRV]
  2958                                  		;;CMP	AL,[CS:MEDIACHK_DRV]
  2959                                  		;;cmp	al,[MEDIACHK_DRV]  ; 11/04/2018
  2960                                  		;CMP	AL,DL ; 13/04/2018
  2961                                  
  2962 000009BC 3A4504                  		cmp	al,[DI+BDS.DriveNum] ; 26/05/2018
  2963 000009BF 7505                    		JNE	short Media$Unk		; no, then return don't know
  2964                                  ;
  2965                                  ; CHECK TO SEE IF THIS DRIVE HAS BEEN ACCESSED IN THE LAST 2 SECONDS.
  2966                                  ;
  2967 000009C1 E82500                  		call	CHECK_TIME_OF_ACCESS
  2968 000009C4 EB01                    		jmp	short Media$Done
  2969                                  
  2970                                  Media$Unk:
  2971 000009C6 4E                      		DEC	SI			; RETURN "I DON'T KNOW"
  2972                                  
  2973                                  ;
  2974                                  ; SI now contains the correct value for media change. Clean up the left overs
  2975                                  ;
  2976                                  Media$Done:
  2977 000009C7 2EC41E[B800]            		les	bx,[CS:PTRSAV]		; get original packet
  2978                                  		;les	bx,[PTRSAV] ; 11/04/2018
  2979 000009CC 2689770E                		mov	[ES:BX+TRANS],SI
  2980 000009D0 09F6                    		or	SI,SI
  2981                                  		;jns	EXIT
  2982 000009D2 7803                    		js	short INIT_PATCH
  2983 000009D4 E975FC                  		jmp	EXIT
  2984                                  
  2985                                  		;; make sure we ask ROM for media check
  2986                                  		;mov	byte [CS:TIM_DRV],-1
  2987                                  		;;mov	byte [TIM_DRV],-1 ; 11/04/2018
  2988                                  		;jmp	EXIT
  2989                                  
  2990                                  		; 26/05/2018 - Retro DOS v3.0
  2991                                  		;----------------------------------------|
  2992                                  		; Warning: Do not change the following. ;|
  2993                                  		;	   It gets patched in msinit	;|
  2994                                  							;|
  2995                                  INIT_PATCH:						;|
  2996 000009D7 E8BE12                  		CALL	MEDIA_SET_VID			;|
  2997                                  		;----------------------------------------|
  2998 000009DA 2EC606[1502]FF          		mov	byte [cs:TIM_DRV],-1 ; make sure we ask ROM for media check
  2999                                  VOLIDOK:
  3000 000009E0 E969FC                  		jmp	EXIT
  3001                                  
  3002                                  ERR$EXITJ:
  3003 000009E3 E8F904                  		CALL	MAPERROR
  3004 000009E6 E956FC                  		JMP	ERR$EXIT
  3005                                  
  3006                                  ;
  3007                                  ; PERFORM A CHECK ON THE TIME PASSED SINCE THE LAST ACCESS FOR THIS
  3008                                  ; PHYSICAL DRIVE.
  3009                                  ; WE ARE ACCESSING THE SAME DRIVE.  IF THE TIME OF LAST SUCCESSFUL ACCESS
  3010                                  ; WAS LESS THAN 2 SECONDS AGO, THEN WE MAY PRESUME THAT THE DISK WAS NOT
  3011                                  ; CHANGED
  3012                                  ; RETURNS IN SI:
  3013                                  ;	0 - IF TIME OF LAST ACCESS WAS >= 2 SECONDS
  3014                                  ;	1 - IF TIME WAS < 2 SECONDS (I.E NO MEDIA CHANGE ASSUMED)
  3015                                  ; REGISTERS AFFECTED AX,CX,DX, FLAGS.
  3016                                  ;
  3017                                  
  3018                                  CHECK_TIME_OF_ACCESS:
  3019                                  		; 27/05/2018 - Retro DOS v3.0
  3020 000009E9 BE0100                  		mov	si,1			; Presume no change
  3021                                  		;;Rev 3.30 Modification
  3022 000009EC 30E4                    		xor	AH, AH			; set command to read time
  3023 000009EE CD1A                    		int	1Ah			; call rom-bios clock routine
  3024                                  
  3025                                  ;
  3026                                  ; Once time is read, must make sure the date wrap is not lost.	The ROM will
  3027                                  ; return the value only once, it must check for day wrap on each call.
  3028                                  ;
  3029 000009F0 D0E8                    		SHR	AL,1
  3030 000009F2 2E8316[9E05]00          		ADC	word [CS:DAYCNT],0	; ADD IT TO OUR SAVED DAY COUNT
  3031                                  		;ADC	word [DAYCNT], 0 ; 11/04/2018
  3032                                  ;
  3033                                  ; Compute elapsed time1
  3034                                  ;
  3035                                  		; 27/05/2018
  3036                                  		; Retro DOS v3.0
  3037 000009F8 8B454D                  		MOV	AX,[DI+BDS.TIM_LO]	; GET STORED TIME
  3038 000009FB 29C2                    		SUB	DX,AX
  3039 000009FD 8B454F                  		MOV	AX,[DI+BDS.TIM_HI]
  3040 00000A00 19C1                    		SBB	CX,AX
  3041                                  ;
  3042                                  ; CX:DX is the elapsed time
  3043                                  ;
  3044 00000A02 751D                    		JNZ	short TimeCheck_Unk	; CX <> 0 => > 1 hour
  3045 00000A04 09D2                    		OR	DX,DX			; did some time pass?
  3046 00000A06 7514                    		JNZ	short TimePassed	; yes, examine max value
  3047                                  ;
  3048                                  ; No noticeable time has passed. There are two possibilities. First there
  3049                                  ; could be two driver calls with in one clock tick (55 milliseconds).  The
  3050                                  ; second possibility is the program has reprogramed the counter -- this is
  3051                                  ; the unreliable counter case. To distinguish between the case a count is
  3052                                  ; kept of the number of calls that happen without a clock tick (the variable
  3053                                  ; is AccessCount).  If this count exceeds a set limit (MaxAccess) it is
  3054                                  ; assumed the counter is unreliable and the value don't know is returned.
  3055                                  ; If AccessCount is less than MaxAccess we assume the time is valid and
  3056                                  ; therefore the media has not changed.
  3057                                  ;
  3058 00000A08 2EFE06[1402]            		inc	byte [cs:AccessCount]
  3059                                  						; Exceeded threshold for count?
  3060 00000A0D 2E803E[1402]05          		cmp	byte [cs:AccessCount],AccessMax
  3061 00000A13 720D                    		jb	short TimeCheck_Ret	; no, return media unchanged
  3062 00000A15 2EFE0E[1402]            		dec	byte [cs:AccessCount]	; don't let the count wrap
  3063 00000A1A EB05                    		jmp	short TimeCheck_Unk	; "I don't know" if media changed
  3064                                  
  3065                                  ;
  3066                                  ; If this code is reached some time has passed.  Need to determine if
  3067                                  ; 2 seconds have passed.  Note: 18.2 ticks per second.
  3068                                  ;
  3069                                  TimePassed:
  3070 00000A1C 83FA24                  		CMP	DX,18*2			; IF ( Time_passed <= 2secs )
  3071 00000A1F 7601                    		JBE	short TimeCheck_Ret	;      presume no change
  3072                                  
  3073                                  
  3074                                  ; Everything indicates that we do not know what has happened.
  3075                                  ;
  3076                                  TimeCheck_Unk:
  3077 00000A21 4E                      		DEC	SI			; Presume I don't know
  3078                                  TimeCheck_Ret:
  3079 00000A22 C3                      		RETN
  3080                                  
  3081                                  ERR$EXITJ2:
  3082                                  		;JMP 	ERR$EXIT
  3083                                  		; 25/08/2022
  3084 00000A23 EBBE                    		jmp	short ERR$EXITJ
  3085                                  
  3086                                  ;------------------------------------------------------------------------
  3087                                  ;									:
  3088                                  ;		Get Bios Parameter Block				:
  3089                                  ;									:
  3090                                  ; GET$BPB is called to build a valid BPB for the media in the disk	:
  3091                                  ; drive.  A BPB (Bios Parameter Block) contains information about	:
  3092                                  ; the media which is currently in the drive.  The values stored is	:
  3093                                  ; information like number of fat sectors, size of drive, 8 or 9 sectors,:
  3094                                  ; etc.									:
  3095                                  ;									:
  3096                                  ;	This routine is called by the device drive code.		:
  3097                                  ;									:
  3098                                  ;	On entry AL contains the logical drive number which needs	:
  3099                                  ;	  the BPB built.						:
  3100                                  ;	ES:[DI] points to a buffer; the first byte of the buffer is a	:
  3101                                  ;	   media decriptor byte.					:
  3102                                  ;									:
  3103                                  ;------------------------------------------------------------------------
  3104                                  ;
  3105                                  ; Build a valid BPB for the disk in the drive.
  3106                                  ;
  3107                                  
  3108                                  GET$BPB:
  3109 00000A25 268A25                  		mov	AH,[ES:DI]		; get FAT ID byte read by DOS
  3110 00000A28 E8CA01                  		call	SETDRIVE		; get the correct BDS for the drv
  3111                                  		; 27/05/2018
  3112                                  		;;Rev 3.30 Modification
  3113 00000A2B F745290100              		TEST	word [DI+BDS.Flags],fNon_Removable
  3114 00000A30 7508                    		JNZ	short ALREADY_GOTBPB	; NO NEED TO BUILD FOR FIXED DISKS
  3115                                  		;End of Modification
  3116 00000A32 E81C00                  		call	GETBP			; build a BPB if necessary.
  3117 00000A35 72EC                    		jc	short ERR$EXITJ2	; if error exit
  3118                                  SET_PATCH:
  3119 00000A37 E82B13                  		CALL	Set_Volume_ID
  3120                                  ALREADY_GOTBPB:
  3121 00000A3A 83C706                  		add	di,BDS.BytePerSec	; return the BPB that is in the current BDS
  3122                                  
  3123                                  SetPTRSAV:					; return point for DSK$INIT
  3124 00000A3D 2EC41E[B800]            		les	BX,[CS:PTRSAV]
  3125 00000A42 2688670D                		mov	[ES:BX+MEDIA],AH
  3126 00000A46 26897F12                		mov	[ES:BX+COUNT],DI
  3127 00000A4A 268C5F14                		mov	[ES:BX+COUNT+2],DS
  3128 00000A4E E9FBFB                  		jmp	EXIT
  3129                                  
  3130                                  ; 13/06/2018
  3131                                  ; 27/05/2018 - Retro DOS v3.0
  3132                                  
  3133                                  ;
  3134                                  ;      GETBP fills the BDS with the BPB for the media currently in the drive.
  3135                                  ; The following steps are followed:
  3136                                  ;	If the Return_Fake_BPB flag is set then the GETBP just returns.
  3137                                  ;	If the BDS is for a hard disk (non-removable) then GETBP returns since
  3138                                  ;   the BPB cannot change on a hard disk drive.
  3139                                  ;	For all other cases GETBP reads the boot sector and looks for a BPB
  3140                                  ;   in the boot sector. (All DOS 2.X and about disks should have a valid
  3141                                  ;   BPB in the boot sector.)
  3142                                  ;	If no valid BPB is found (DOS 1.X disk) then GETBP reads the FAT
  3143                                  ;   sector and gets the FAT ID byte.  With this byte a valid BPB is build.
  3144                                  ;
  3145                                  ;	Inputs:
  3146                                  ;		DS:DI points to correct BDS
  3147                                  ;
  3148                                  ;	Outputs:
  3149                                  ;		Fills in BPB in current BDS if valid BPB or FAT ID on disk.
  3150                                  ;		Carry set, and AL=7 if invalid disk.
  3151                                  ;		Carry set and error code in AL if other error.
  3152                                  ;
  3153                                  
  3154                                  GETBP:
  3155                                  					; if non-removable or returning
  3156                                  					; fake BPB then return BPB as is.
  3157 00000A51 F745290500              		TEST	WORD [DI+BDS.Flags],RETURN_FAKE_BPB|fNon_Removable
  3158 00000A56 7403                    		jz	short GETBP1
  3159 00000A58 E98C00                  		JMP	GETRET_Exit
  3160                                  
  3161                                  GETBP1:
  3162 00000A5B 51                      		push	cx
  3163 00000A5C 52                      		push	dx
  3164 00000A5D 06                      		push	es
  3165 00000A5E 53                      		push	bx
  3166                                  ;
  3167                                  ; Attempt to read in boot sector and determine BPB.
  3168                                  ; We assume that the 2.x and greater DOS disks all have a valid boot sector.
  3169                                  ;
  3170                                  Rdboot:
  3171 00000A5F E89000                  		call	READBOOTSEC
  3172                                  		;jc	short GetBP_Err_Ret
  3173                                  		; 03/09/2022
  3174 00000A62 7303                    		jnc	short NoRdErr
  3175 00000A64 E98100                  		jmp	GetBP_Err_Ret	; Carry set if there was error.
  3176                                  NoRdErr:
  3177 00000A67 83FB00                  		cmp	bx,0		; BX is 0 if boot sector is valid.
  3178                                  		;or	bx, bx
  3179 00000A6A 7505                    		jnz	short DoFatBPB	; if not go read FAT
  3180                                  
  3181 00000A6C E8DD00                  		call	MOVBPB		; Move BPB into registers.
  3182 00000A6F EB5A                    		jmp	short HAS1
  3183                                  	
  3184                                  		; Temporary !
  3185                                  		; 25/08/2022 - IBMBIO.COM (IBMBIO33.IDB) address compatibility!
  3186                                  		;nop
  3187                                  
  3188                                  ;
  3189                                  ; At this point the drive contains a 1.X diskette.  We read the FAT byte
  3190                                  ; and fill in the BPB from there.
  3191                                  ;
  3192                                  
  3193                                  DoFatBPB:
  3194 00000A71 E8FA00                          	call    READFAT		; puts media descriptor byte in AH
  3195 00000A74 7272                            	jc	short GetBP_Err_Ret ; if carry set, there was error, get out
  3196                                  
  3197                                  		;----------------------------------------|
  3198                                  		; Warning: Do not change the following. ;|
  3199                                  		;          It gets patched in msinit    ;|
  3200                                  							;|
  3201                                  GETBP1_PATCH:   		                        ;|
  3202 00000A76 E82E12                  		call    hidensity               	;|
  3203                                  		;----------------------------------------|
  3204                                  		
  3205                                  		; Test for a valid 3.5" medium
  3206 00000A79 807D2802                        	cmp     byte [DI+BDS.FormFactor],ffSmall
  3207 00000A7D 751B                            	jnz	short Is_Floppy
  3208                                          
  3209 00000A7F 80FCF9                  		cmp     ah,0F9H		; is it a valid fat ID byte for 3.5" ?
  3210 00000A82 7569                    		jnz     short Got_Unknown_Medium
  3211 00000A84 BB[8D05]                        	mov     bx,SM92		; pointer to correct BPB
  3212 00000A87 0E                              	push    cs
  3213 00000A88 07                              	pop     es
  3214                                  ;--------------------------------------------------------------bug330a08
  3215                                  		;;mov	al,[es:bx+bpbType.spf]
  3216 00000A89 268A07                  		mov	al,[es:bx]  ; 05/07/2019
  3217                                          	; Temporary !
  3218                                  		; 25/08/2022 - IBMBIO.COM (IBMBIO33.IDB) address compatibility!
  3219                                  		;mov	al,[es:bx+bpbType.spf]
  3220                                  
  3221 00000A8C 268B4F03                		mov     cx,[es:bx+bpbType.csec]
  3222 00000A90 268B5705                        	mov     dx,[es:bx+bpbType.spa]
  3223 00000A94 268B5F01                        	mov     bx,[es:bx+bpbType.spt]
  3224                                  ;--------------------------------------------------------------bug330a08
  3225 00000A98 EB2E                    		jmp	short HAS1_res	; Need to load reserved sectors
  3226                                  		; Temporary !
  3227                                  		; 25/08/2022 - IBMBIO.COM (IBMBIO33.IDB) address compatibility!
  3228                                  		;jmp	short HAS1
  3229                                  		;db	0
  3230                                  
  3231                                  		; 25/08/2022 - IBMBIO.COM (IBMBIO33.IDB) address compatibility!
  3232                                  		; 13/06/2018
  3233                                  ;GetBP_Err_Ret:
  3234                                  ;		CALL	MAPERROR
  3235                                  ;		JMP	SHORT GETRET
  3236                                  
  3237                                  ;
  3238                                  ; must be a 5.25" floppy if we come here
  3239                                  ;
  3240                                  Is_Floppy:
  3241 00000A9A 88E1                    		mov     CL,AH		; save media
  3242 00000A9C 80E1F8                  		and     CL,0F8H		; normalize
  3243 00000A9F 80F9F8                  		cmp     CL,0F8H		; compare with good media byte
  3244 00000AA2 7549                            	jnz     short Got_Unknown_Medium
  3245                                  
  3246 00000AA4 B001                    GOODID: 	mov     AL,1		; set number of FAT sectors
  3247 00000AA6 BB0840                          	mov     BX,64*256+8	; set dir entries and sector max
  3248 00000AA9 B94001                          	mov     CX,40*8		; set size of drive
  3249 00000AAC BA0101                          	mov     DX,01*256+1	; set head limit and sec/all unit
  3250 00000AAF F6C402                         		test    AH,00000010B	; test for 8 or 9 sectors
  3251 00000AB2 7507                            	jnz	short HAS8	; NZ = has 8 sectors
  3252 00000AB4 FEC0                            	inc     AL		; inc number of FAT sectors
  3253 00000AB6 FEC3                            	inc     BL		; inc sector max
  3254 00000AB8 83C128                          	add     CX,40		; increase size
  3255 00000ABB F6C401                  HAS8:   	test    AH,00000001B	; test for 1 or 2 heads
  3256 00000ABE 7408                    		jz	short HAS1_res	; Z = 1 head
  3257                                  		; Temporary !
  3258                                  		; 25/08/2022 - IBMBIO.COM (IBMBIO33.IDB) address compatibility!
  3259                                  		;jz	short HAS1
  3260 00000AC0 01C9                    		add     CX,CX		; double size of disk
  3261 00000AC2 B770                    		mov     BH,112		; increase number of directory entries
  3262 00000AC4 FEC6                    		inc     DH		; inc sec/all unit
  3263 00000AC6 FEC2                    		inc     DL		; inc head limit
  3264                                  
  3265                                  		; Temporary !
  3266                                  		; 25/08/2022 - IBMBIO.COM (IBMBIO33.IDB) address compatibility!
  3267                                  HAS1_res:
  3268 00000AC8 8B7509                  		mov	si,[DI+BDS.RESSEC]
  3269                                  					; save values in BDS
  3270 00000ACB 887508                  HAS1:		mov     [DI+BDS.SecPerClus],DH
  3271 00000ACE 887D0C                          	mov     [DI+BDS.cDir],BH
  3272 00000AD1 894D0E                          	mov     [DI+BDS.DRVLIM],CX
  3273 00000AD4 886510                          	mov     [DI+BDS.Mediad],AH
  3274 00000AD7 884511                          	mov     [DI+BDS.cSecFat],AL
  3275 00000ADA 885D13                          	mov     [DI+BDS.SECLIM],BL
  3276 00000ADD 885515                          	mov     [DI+BDS.HDLIM],DL
  3277                                  		; Temporary !
  3278                                  		; 25/08/2022 - IBMBIO.COM (IBMBIO33.IDB) address compatibility!
  3279 00000AE0 897509                          	mov     [DI+BDS.RESSEC],SI
  3280                                  GETRET: 
  3281 00000AE3 5B                      		pop     bx
  3282 00000AE4 07                      		pop	es
  3283 00000AE5 5A                      		pop	dx
  3284 00000AE6 59                      		pop	cx	
  3285                                  GETRET_Exit:
  3286 00000AE7 C3                      		retn
  3287                                  
  3288                                  		; 25/08/2022 - IBMBIO.COM (IBMBIO33.IDB) address compatibility!
  3289                                  GetBP_Err_Ret:
  3290 00000AE8 E8F403                  		CALL	MAPERROR
  3291 00000AEB EBF6                    		JMP	SHORT GETRET
  3292                                  
  3293                                  ;
  3294                                  ; We have a 3.5" diskette for which we cannot build a BPB. We do not assume any
  3295                                  ; type of BPB for this medium.
  3296                                  ;
  3297                                  Got_Unknown_Medium:
  3298 00000AED B007                    		mov	al,error_unknown_media
  3299 00000AEF F9                      		stc
  3300 00000AF0 EBF1                    		jmp	short GETRET
  3301                                  
  3302                                  ;
  3303                                  ; Read in the boot sector. Set carry if error in reading sector.
  3304                                  ; BX is set to 1 if the boot sector is invalid, otherwise it is 0.
  3305                                  ;
  3306                                  READBOOTSEC:
  3307 00000AF2 B90100                  		mov	CX,0001h	; set track and sector number
  3308 00000AF5 30F6                    		xor     DH,DH		; set head number for read_sector
  3309 00000AF7 E88600                  		call	READ_SECTOR
  3310 00000AFA 724F                    		jc	short Err_ret	; error - get out
  3311 00000AFC 31DB                    		xor	bx,bx		; assume valid boot sector.
  3312                                  
  3313                                  				; at this point the boot sector has been
  3314                                  				; read in from the disk.  We now need to
  3315                                  				; determine if the boot sector contains
  3316                                  				; a valid BPB.	Currently there are only
  3317                                  				; a few simple checks.	Expanding the
  3318                                  				; number or types of checks would not be
  3319                                  				; a bad idea.
  3320                                  
  3321                                  ;*******************************************************************************
  3322                                  ; Put a sanity check for the boot sector in here to detect boot sectors that
  3323                                  ; do not have valid BPBs.
  3324                                  ; We examine the first two bytes - they must contain a long jump or a short
  3325                                  ; jump followed by a NOP.
  3326                                  ; If this test is passed, we further check by examining the signature at
  3327                                  ; the end of the boot sector for the word AA55H.
  3328                                  ; If the signature is not present, we examine the media descriptor byte to
  3329                                  ; see if it is valid.
  3330                                  ;******************************************************************************
  3331 00000AFE 2E803E[4602]69          		cmp	byte [cs:DiskSector],069H    ; Is it a direct jump?
  3332 00000B04 7418                    		JE	short Check_bpb_MediaByte    ; DON'T NEED TO FIND A NOP
  3333 00000B06 2E803E[4602]E9          		cmp	byte [cs:DiskSector],0E9H    ; DOS 2.0 jump?
  3334 00000B0C 7410                    		JE	short Check_bpb_MediaByte    ; NO NEED FOR NOP
  3335 00000B0E 2E803E[4602]EB          		cmp	byte [cs:DiskSector],0EBH    ; How about a short jump.
  3336 00000B14 7533                    		JNE	short INVALIDBOOTSEC
  3337 00000B16 2E803E[4802]90          		cmp	byte [cs:DiskSector+2],090H  ; Is next one a NOP?
  3338 00000B1C 752B                    		JNE	short INVALIDBOOTSEC
  3339                                  
  3340                                  ; Don't have to perform the following signature check since
  3341                                  ; we need to check the media byte even with the good signatured diskette.
  3342                                  ;CHECK_SIGNATURE:
  3343                                  ;		CMP	word [cs:DiskSector+1FEh],0AA55h ; SEE IF NON-IBM
  3344                                  ;							 ; DISK OR 1.X MEDIA.
  3345                                  ;		JZ	short CHECKSINGLESIDED ; GO SEE IF SINGLE SIDED MEDIUM.
  3346                                  ;					       ; MAY NEED SOME SPECIAL HANDLING
  3347                                  ;
  3348                                  ; CHECK FOR NON-IBM DISKS WHICH DO NOT HAVE THE SIGNATURE AA55 AT THE
  3349                                  ; END OF THE BOOT SECTOR, BUT STILL HAVE A VALID BOOT SECTOR. THIS IS DONE
  3350                                  ; BY EXAMINING THE MEDIA DESCRIPTOR IN THE BOOT SECTOR.
  3351                                  ;
  3352                                  
  3353                                  ;;Rev 3.30 Modification
  3354                                  Check_bpb_MediaByte:
  3355                                  
  3356 00000B1E 2EA0[5B02]              		MOV	AL,[CS:MediaByte]
  3357 00000B22 24F0                    		AND	AL,0F0H
  3358 00000B24 3CF0                    		CMP	AL,0F0H		; ALLOW FOR STRANGE MEDIA
  3359 00000B26 7521                    		JNZ	short INVALIDBOOTSEC 
  3360                                  ;
  3361                                  ; THERE WERE SOME (APPARENTLY A BUNCH) DISKETTES THAT HAD BEEN FORMATTED
  3362                                  ; UNDER DOS 3.1 AND EARLIER VERSIONS WHICH HAVE INVALID BPBS IN THEIR BOOT
  3363                                  ; SECTORS. THESE ARE SPECIFICALLY DISKETTES THAT WERE FORMATTED IN DRIVES
  3364                                  ; WITH ONE HEAD, OR WHOSE SIDE 0 WAS BAD. THESE CONTAIN BPBS IN THE BOOT
  3365                                  ; SECT THAT HAVE THE SEC/CLUS FIELD SET TO 2 INSTEAD OF 1, AS IS STANDARD
  3366                                  ; IN DOS. TO SUPPORT THEM, WE HAVE TO INTRODUCE A "HACK" THAT WILL
  3367                                  ; HELP OUR BUILD BPB ROUTINE TO RECOGNISE THESE SPECIFIC CASES, AND TO
  3368                                  ; SET UP OUT COPY OF THE BPB ACCORDINGLY.
  3369                                  ; WE DO THIS BY CHECKING TO SEE IF THE BOOT SECTOR IS OFF A DISKETTE THAT
  3370                                  ; IS SINGLE-SIDED AND IS A PRE-DOS 3.20 DISKETTE. IF IT IS, WE SET THE
  3371                                  ; SEC/CLUS FIELD TO 1. IF NOT, WE CARRY ON AS NORMAL.
  3372                                  CHECKSINGLESIDED:
  3373 00000B28 2EA0[5B02]              		MOV	AL,[CS:MediaByte]
  3374 00000B2C A801                    		TEST	AL,0001H ; IS LOW BIT SET? - INDICATES DOUBLE SIDED
  3375 00000B2E 751A                    		JNZ	short GoodDsk
  3376 00000B30 2E813E[4E02]332E        		CMP	word [CS:DiskSector+8],"3."
  3377 00000B37 7508                    		JNZ	short MUSTBEEARLIER
  3378 00000B39 2E803E[5002]32          		CMP	byte [CS:DiskSector+10],"2"
  3379 00000B3F 7309                    		JAE	short GoodDsk
  3380                                  
  3381                                  ; WE MUST HAVE A PRE-3.20 DISKETTE. SET THE SEC/CLUS FIELD TO 1
  3382                                  MUSTBEEARLIER:
  3383 00000B41 2EC606[5302]01          		MOV	BYTE [CS:SECPERCLUSINSECTOR],1
  3384 00000B47 EB01                    		JMP	short GoodDsk
  3385                                  
  3386                                  INVALIDBOOTSEC:
  3387 00000B49 43                      		INC	BX		; SET THAT BOOT SECTOR INVALID
  3388                                  ;;End of Modification
  3389                                  
  3390                                  GoodDsk:				; carry already reset
  3391 00000B4A F8                      		clc
  3392                                  Err_ret:
  3393 00000B4B C3                      		retn
  3394                                  
  3395                                  ;Err_Ret:				; carry is already set on entry here
  3396                                  ;		retn
  3397                                  
  3398                                  
  3399                                  		; Temporary !
  3400                                  		; 25/08/2022 - IBMBIO.COM (IBMBIO33.IDB) address compatibility!
  3401                                  		;retn
  3402                                  
  3403                                  ;
  3404                                  ; MovBPB moves the BPB read from the Boot sector into registers for use by
  3405                                  ; GETBP routine at Has1
  3406                                  ;
  3407                                  MOVBPB:
  3408 00000B4C 1E                      		push	ds
  3409 00000B4D 57                      		push	di
  3410 00000B4E 0E                      		push	cs
  3411 00000B4F 1F                      		pop	ds
  3412 00000B50 BF[5102]                		mov	di,BPB_In_Sector
  3413 00000B53 8A7502                  		mov	dh,[DI+BPB_TYPE.SECALL]	;sectors per unit
  3414 00000B56 8A7D06                  		mov	bh,[DI+BPB_TYPE.DIRNUM]	;number of directory entries
  3415 00000B59 8B4D08                  		mov	cx,[DI+BPB_TYPE.SECNUM]	;size of drive
  3416 00000B5C 8A650A                  		mov	ah,[DI+BPB_TYPE.FATID]	;media descriptor
  3417 00000B5F 8A450B                  		mov	al,[DI+BPB_TYPE.FATSIZE] ;number of FAT sectors
  3418 00000B62 8A5D0D                  		mov	bl,[DI+BPB_TYPE.SLIM]	;sectors per track
  3419 00000B65 8A550F                  		mov	dl,[DI+BPB_TYPE.HLIM]	;number of heads
  3420                                  		; Temporary !
  3421                                  		; 25/08/2022 - IBMBIO.COM (IBMBIO33.IDB) address compatibility!
  3422 00000B68 8B7503                  		mov	si,[DI+BPB_TYPE.RESNUM]	;reserved sectors
  3423 00000B6B 5F                      		pop	di
  3424 00000B6C 1F                      		pop	ds
  3425 00000B6D C3                      		retn
  3426                                  
  3427                                  ;
  3428                                  ; Read in the FAT sector and get the Media Byte from it.
  3429                                  ; Input : AL contains logical drive.
  3430                                  ; Output:
  3431                                  ;	  Carry set if an error occurs, AX contains error code.
  3432                                  ;	  Otherwise, AH contains media byte on exit. AL is preserved.
  3433                                  
  3434                                  READFAT:
  3435 00000B6E 50                      		push	ax		   ; preserve logical drive in AL
  3436 00000B6F B600                    		MOV	DH,0		   ; HEAD 0
  3437 00000B71 B90200                  		mov	CX,2		   ; set track and sector number
  3438 00000B74 E80900                  		call	READ_SECTOR	   ; CS:BX points to fat sector
  3439 00000B77 7205                    		jc	short Bad_FAT_Ret  ; error, get out
  3440 00000B79 58                      		pop	ax		   ; reset logical drive
  3441 00000B7A 2E8A27                  		mov	ah,[CS:BX]	   ; media byte
  3442 00000B7D C3                      		retn
  3443                                  
  3444                                  Bad_FAT_Ret:				   ; carry set on entry
  3445 00000B7E 59                      		pop	cx	           ; clear stack
  3446 00000B7F C3                      		retn
  3447                                  
  3448                                  ;
  3449                                  ; Read_sector reads a single sector into the tempory buffer 'DiskSector'.
  3450                                  ; Up to three retries are done in case of error.
  3451                                  ;
  3452                                  ;    Inputs:
  3453                                  ;	DS:DI	points to BDS for drive
  3454                                  ;	CH - track number
  3455                                  ;	CL - sector number
  3456                                  ;	DH - head number
  3457                                  ;
  3458                                  ;    Outputs:
  3459                                  ;	If carry is clear -- successful read
  3460                                  ;	   CS:BX points to buffer holding sector
  3461                                  ;	   AX, BX are not preserved, CX, DX, BP, and ES are preserved
  3462                                  ;
  3463                                  ;	If carry is set -- error on read
  3464                                  ;	   AX, BX, and DX are not preserved; CX, BP, and ES are preserved
  3465                                  ;
  3466                                  ;
  3467                                  
  3468                                  READ_SECTOR:
  3469 00000B80 55                      		push	BP		; preserve BP register
  3470 00000B81 BD0300                  		mov	BP,3		; BP is retry count, set to 3
  3471 00000B84 06                      		push	ES		; preserve ES also
  3472 00000B85 8A5504                  		mov	DL,[DI+BDS.DriveNum]
  3473 00000B88 BB[4602]                		mov	BX,DiskSector	; Get ES:BX to point to buffer
  3474 00000B8B 0E                      		push	CS		;    get the segment right
  3475 00000B8C 07                      		pop	ES		; now ES:BX is correct
  3476                                  
  3477                                  RD_RET:
  3478                                  					; set command to read (AH=2) and
  3479 00000B8D B80102                  		mov	AX,0201h	; number of sectors to 1 (AL=1)
  3480 00000B90 CD13                    		int	13h		; call rom-bios disk routines
  3481 00000B92 733C                    		jnc	short OKRET2	; if no carry then no error - done
  3482                                  Rd_rty:
  3483 00000B94 E8C60A                  		call	AGAIN		; reset disk and decrement BP
  3484 00000B97 7434                    		jz	short ERR_RD_RET
  3485 00000B99 F745290100              		test	word [DI+BDS.Flags],fNon_Removable
  3486 00000B9E 75ED                    		JNZ	short RD_RET
  3487                                  
  3488                                  ;;Rev 3.30 Modification -----------------------------------------
  3489 00000BA0 1E                      		push	ds		; For retry, set head settle
  3490 00000BA1 50                      		push	ax		; time to 0Fh.
  3491 00000BA2 2EC536[2602]            		lds	si,[CS:DPT]
  3492 00000BA7 8A4409                  		mov	al,[SI+DISK_PARMS.DISK_HEAD_STTL]
  3493 00000BAA 2EA2[2302]              		mov	[CS:Save_head_sttl],al
  3494 00000BAE C644090F                		mov	byte [SI+DISK_PARMS.DISK_HEAD_STTL],NORMSETTLE
  3495 00000BB2 58                      		pop	ax
  3496 00000BB3 1F                      		pop	ds
  3497                                  					; SET CMD TO READ (AH=2) AND
  3498 00000BB4 B80102                  		MOV	AX,0201h	; NUM OF SECTORS TO 1 (AL=1)
  3499 00000BB7 CD13                    		INT	13h		; CALL ROM-BIOS DISK ROUTINES
  3500 00000BB9 1E                      		push	ds
  3501 00000BBA 50                      		push	ax
  3502 00000BBB 2EC536[2602]            		lds	si,[CS:DPT]
  3503 00000BC0 2EA0[2302]              		mov	al,[CS:Save_head_sttl]
  3504 00000BC4 884409                  		mov	[SI+DISK_PARMS.DISK_HEAD_STTL],al
  3505 00000BC7 58                      		pop	ax
  3506 00000BC8 1F                      		pop	ds
  3507 00000BC9 7305                    		jnc	short OKRET2
  3508 00000BCB EBC7                    		jmp	short Rd_rty
  3509                                  ERR_RD_RET:
  3510 00000BCD B2FF                    		MOV	DL,-1	; MAKE SURE WE ASK ROM IF MEDIA  CHANGED
  3511 00000BCF F9                      		STC		; RETURN ERROR
  3512                                  ;;End of Modification -----------------------------------------
  3513                                  
  3514                                  			; Update information pertaining to last drive
  3515                                  			; accessed, time of access, last track accessed
  3516                                  			; in that drive.
  3517                                  OKRET2:
  3518                                  				; set up for head settle logic in DISK
  3519 00000BD0 2E8816[8401]            		mov	[CS:STEP_DRV],DL ; save last drive accessed
  3520 00000BD5 2E8816[1502]            		mov	[CS:TIM_DRV],DL	; save the values
  3521 00000BDA 886D4C                  		mov	[DI+BDS.Track],CH ;
  3522 00000BDD 9C                      		pushf			; save the flags
  3523 00000BDE E81603                  		call	SET_TIM
  3524 00000BE1 9D                      		popf			; restore flags
  3525 00000BE2 07                      		pop	ES		; restore registers
  3526 00000BE3 5D                      		pop	BP
  3527 00000BE4 C3                      		retn
  3528                                  
  3529                                  ;27/05/2018 - Retro DOS v3.0
  3530                                  
  3531                                  ;------------------------------------------------------------------------
  3532                                  ;									:
  3533                                  ;		Disk Removable Routine					:
  3534                                  ;									:
  3535                                  ;  This routine determines if a particular logical drive has		:
  3536                                  ;  removable media.							:
  3537                                  ;									:
  3538                                  ;  Input								:
  3539                                  ;     AL contains the logical drive number which the check is being	:
  3540                                  ;  done.								:
  3541                                  ;------------------------------------------------------------------------
  3542                                  
  3543                                  DSK$REM:				;ARR 2.41
  3544 00000BE5 E80D00                  		call	SETDRIVE	; get BDS for this drive
  3545 00000BE8 F745290100              		test	word [DI+BDS.Flags],fNon_Removable
  3546 00000BED 7503                    		jnz	short NON_REM
  3547 00000BEF E95AFA                  		jmp	EXIT
  3548                                  
  3549                                  NON_REM:				; if non removable set busy bit
  3550 00000BF2 E93CFA                  		jmp	BUS$EXIT
  3551                                  
  3552                                  ;
  3553                                  ; SetDrive scans through the data structure of BDSs and returns a
  3554                                  ; pointer to the BDS that belongs to the drive specified in AL.
  3555                                  ; Carry is set if no BDS has a logical drive number which matches the
  3556                                  ; value in AL.
  3557                                  ;	Input:
  3558                                  ;	  AL contains the logical drive number
  3559                                  ;	Output:
  3560                                  ;	  DS:DI points to correct BDS if Carry is clear.
  3561                                  ;
  3562                                  ;	 All register execpt DS and DI are preserved
  3563                                  ;
  3564                                  
  3565                                  SETDRIVE:
  3566                                  		; 27/05/2018 - Retro DOS v3.0
  3567                                  		; (MSDOS v3.3, 'MSDISK.ASM')
  3568                                  		
  3569 00000BF5 53                      		push	bx
  3570 00000BF6 0E                      		push	cs
  3571 00000BF7 1F                      		pop	ds
  3572                                  
  3573 00000BF8 8B3E[1002]              		mov	di,[START_BDS] 
  3574                                  Scan_Loop:
  3575                                  ;;Rev 3.30 Modification -----------------------------------------
  3576 00000BFC 2E803E[8501]01          		CMP	BYTE [CS:PHYS_DRV],1 ; DOES AL HAVE PHYS DRV?
  3577 00000C02 7207                    		JB	short USE_LOGICAL_DRV
  3578 00000C04 384504                  		CMP	BYTE [DI+BDS.DriveNum],AL
  3579 00000C07 7414                    		JE	short SetDrv
  3580 00000C09 EB05                    		JMP	SHORT GET_NXT_BDS
  3581                                  USE_LOGICAL_DRV:
  3582 00000C0B 384505                  		CMP	[DI+BDS.DriveLet],AL
  3583 00000C0E 740D                    		JE	short SetDrv
  3584                                  GET_NXT_BDS:
  3585 00000C10 8B5D02                  		MOV	BX,[DI+BDS.Link+2] ; GO TO NEXT BDS
  3586                                  		;MOV	DI,[DI+BDS.Link]
  3587 00000C13 8B3D                    		mov	di,[di] ; 05/07/2019
  3588 00000C15 8EDB                    		mov	ds,bx
  3589                                  ;;End of Modification -----------------------------------------
  3590                                  
  3591 00000C17 83FFFF                  		cmp	di,-1		; at end of list?
  3592 00000C1A 75E0                    		jnz	short Scan_Loop	; no, keep looking
  3593 00000C1C F9                      		stc			; yes, indicate error set carry
  3594                                  SetDrv:
  3595 00000C1D 5B                      		pop	bx		; restore bx
  3596 00000C1E C3                      		retn
  3597                                  
  3598                                  ;------------------------------------------------------------------------
  3599                                  ;									:
  3600                                  ;		DISK I/O ROUTINES					:
  3601                                  ;									:
  3602                                  ;  On entry the register contain the following values:			:
  3603                                  ;									:
  3604                                  ;	AH - Media Descriptor byte					:
  3605                                  ;	AL - logical drive number					:
  3606                                  ;	CX - count of sectors to be read or written			:
  3607                                  ;	DX - start sector						:
  3608                                  ;	DI - offset of destination buffer				:
  3609                                  ;									:
  3610                                  ;------------------------------------------------------------------------
  3611                                  
  3612                                  
  3613                                  ;------------------------------------------------------------------------
  3614                                  ;									:
  3615                                  ;		Disk Write with Verify					:
  3616                                  ;									:
  3617                                  ;  Input								:
  3618                                  ;	See about header for register contents on entry.		:
  3619                                  ;									:
  3620                                  ;------------------------------------------------------------------------
  3621                                  
  3622                                  
  3623                                  DSK$WRITV:
  3624 00000C1F 2EC706[1A02]0301        		MOV	WORD [CS:WRTVERIFY],103H
  3625 00000C26 EB07                    		JMP	SHORT DSK$CL
  3626                                  
  3627                                  ;------------------------------------------------------------------------
  3628                                  ;									:
  3629                                  ;		       Disk Write					:
  3630                                  ;									:
  3631                                  ;  Input								:
  3632                                  ;	See about header for register contents on entry.		:
  3633                                  ;									:
  3634                                  ;------------------------------------------------------------------------
  3635                                  
  3636                                  DSK$WRIT:
  3637 00000C28 2EC706[1A02]0300        		MOV	WORD [CS:WRTVERIFY],ROMWrite
  3638                                  
  3639                                  DSK$CL:
  3640 00000C2F E89000                  		CALL	DISKIO
  3641                                  DSK$IO:
  3642 00000C32 7203                    		JC	short DSKBad
  3643 00000C34 E915FA                  		JMP	EXIT
  3644                                  DSKBad:
  3645 00000C37 E9FDF9                  		JMP	ERR$CNT
  3646                                  
  3647                                  ;------------------------------------------------------------------------
  3648                                  ;									:
  3649                                  ;			Disk Read					:
  3650                                  ;									:
  3651                                  ;  Input								:
  3652                                  ;	See about header for register contents on entry.		:
  3653                                  ;									:
  3654                                  ;------------------------------------------------------------------------
  3655                                  
  3656                                  DSK$READ:
  3657 00000C3A E87F00                  		CALL	DISKRD
  3658 00000C3D EBF3                    		JMP	short DSK$IO
  3659                                  
  3660                                  ;
  3661                                  ; Miscellaneous odd jump routines.  Moved out of mainline for speed.
  3662                                  ;
  3663                                  
  3664                                  ;
  3665                                  ; CheckSingle determines if the drive specified is a virtual drive (more
  3666                                  ; than one logical drive associated with one physical drive). If this
  3667                                  ; is the case we need to prompt the user to place the correct disk in
  3668                                  ; the drive.
  3669                                  ;
  3670                                  ;	Input:
  3671                                  ;	   DS:DI pints to the BDS for the drive being checked.
  3672                                  ;
  3673                                  ;	If there is a error the carry flag is set on return
  3674                                  ;
  3675                                  ;  All registers are preserved.
  3676                                  ;
  3677                                  
  3678                                  CHECKSINGLE:
  3679                                  		; 27/05/2018 - Retro DOS v3.0
  3680 00000C3F 50                      		push	AX		; save affected registers
  3681 00000C40 53                      		push	BX
  3682                                  
  3683 00000C41 8B5D29                  		mov	BX,[DI+BDS.Flags]
  3684                                  					;Can't change disk
  3685 00000C44 F6C321                  		TEST	BL,fNon_Removable | fI_Own_Physical
  3686 00000C47 7562                    		jnz	short SingleRet	; on hard drive so return
  3687                                  					; is there a drive sharing this
  3688 00000C49 F6C310                  		TEST	BL,fI_Am_Mult	;   physical drive?
  3689 00000C4C 745D                    		jz	short SingleRet	; if not, then return
  3690                                  
  3691                                  			; At this point there is more than one
  3692                                  			; logical drive mapped to this physical drive.
  3693                                  			; But the drive being accessed is not the
  3694                                  			; owner of the physical drive.	What needs to
  3695                                  			; be done is find the current owner BDS and
  3696                                  			; turn off the owner flag and then make current
  3697                                  			; BDS the owner of the drive.  Then prompt the
  3698                                  			; user to change disks.
  3699                                  	
  3700 00000C4E 8A4504                  		mov	al,[DI+BDS.DriveNum] ; get physical drive number
  3701 00000C51 1E                      		push	ds		; preserve pointer to current BDS
  3702 00000C52 57                      		push	di
  3703 00000C53 0E                      		push	cs
  3704 00000C54 1F                      		pop	ds		; Point to start of BDS linked list
  3705                                  
  3706 00000C55 BF[1002]                		mov	di,START_BDS
  3707                                  Scan_List:
  3708 00000C58 8B5D02                  		mov	bx,[DI+BDS.Link+2] ; go to next BDS
  3709                                  		;mov	di,[DI+BDS.Link]
  3710 00000C5B 8B3D                    		mov	di,[di] ; 05/07/2019
  3711 00000C5D 8EDB                    		mov	ds,bx
  3712                                  		
  3713 00000C5F 83FFFF                  		cmp	di,-1		; end of list?
  3714 00000C62 744A                    		jz	short Single_Err_Ret ; if so there must be an error
  3715                                  					; same physical drive?
  3716 00000C64 384504                  		cmp	[DI+BDS.DriveNum],al
  3717 00000C67 75EF                    		jnz	short Scan_List	; no, keep looking
  3718                                  
  3719                                  Check_Own:				; yes, check to see if owner
  3720 00000C69 8B5D29                  		mov	bx,[DI+BDS.Flags]
  3721 00000C6C F6C320                  		test	bl,fI_Own_Physical
  3722 00000C6F 74E7                    		jz	short Scan_List	; not owner, keep looking
  3723 00000C71 80F320                  		xor	bl,fI_Own_Physical ; yes owner, reset ownership flag
  3724 00000C74 895D29                  		mov	[DI+BDS.Flags],bx
  3725 00000C77 5F                      		pop	di		; Restore pointer to current BDS
  3726 00000C78 1F                      		pop	ds
  3727 00000C79 31DB                    		xor	bx,bx
  3728 00000C7B 80CB20                  		or	bl,fI_Own_Physical ; establish current BDS as owner
  3729 00000C7E 095D29                  		or	[DI+BDS.Flags],bx
  3730                                  
  3731                                  			;
  3732                                  			; We examine the fSetOwner flag. If it is
  3733                                  			; set, then we are using the code in
  3734                                  			; CheckSingle to just set the owner of
  3735                                  			; a drive. We must not issue the prompt
  3736                                  			; in this case.
  3737                                  			;
  3738                                  
  3739 00000C81 2E803E[8901]01          		cmp	byte [cs:fSetOwner],1
  3740 00000C87 7422                    		jz	short SingleRet
  3741                                  	
  3742                                  			;
  3743                                  			; To support "backward" compatibility with
  3744                                  			; IBM's "single drive status byte" we now
  3745                                  			; check to see if we are in a single drive
  3746                                  			; system and the Application has "cleverly"
  3747                                  			; diddled the SDSB (Single Drive Status Byte)
  3748                                  			;
  3749                                  
  3750 00000C89 2E803E[8801]02          		cmp	byte [cs:Single],2	   ; single drive system?
  3751 00000C8F 7517                    		jne	short Ignore_SDSB  ; no, jump down
  3752                                  
  3753 00000C91 1E                      		push	ds		   ; yes...		
  3754 00000C92 57                      		push	di
  3755 00000C93 50                      		push	ax
  3756                                  
  3757 00000C94 8A4505                  		mov	al,[DI+BDS.DriveLet] ; IF (Curr_drv == Req_drv)
  3758 00000C97 88C4                    		mov	ah,al
  3759 00000C99 31FF                    		xor	di,di
  3760 00000C9B 8EDF                    		mov	ds,di
  3761 00000C9D 86060405                		xchg	al,[LSTDRV]	    ; THEN swap(Curr_drv,Req_drv)
  3762 00000CA1 38C4                    		cmp	ah,al		    ; ELSE
  3763 00000CA3 58                      		pop	ax		    ;     swap(Curr_drv,Req_drv)	
  3764 00000CA4 5F                      		pop	di		    ;	  Issue Swap_dsk_msg	
  3765 00000CA5 1F                      		pop	ds
  3766 00000CA6 7403                    		je	short SingleRet	
  3767                                  
  3768                                  Ignore_SDSB:
  3769 00000CA8 E8D60D                  		call	SWPDSK		; ask user for correct disk
  3770                                  
  3771                                  SingleRet:
  3772 00000CAB 5B                      		pop	BX		; restore registers
  3773 00000CAC 58                      		pop	AX
  3774 00000CAD C3                      		retn			; return
  3775                                  
  3776                                  Single_Err_Ret:
  3777 00000CAE F9                      		stc			; set carry flage to indicate error
  3778 00000CAF 5F                      		pop	di		; restore current BDS
  3779 00000CB0 1F                      		pop	ds
  3780 00000CB1 EBF8                    		jmp	short SingleRet
  3781                                  
  3782                                  ;
  3783                                  ; BadDrive is called when sector specified is greater than last
  3784                                  ; sector on disk.
  3785                                  ; or when BDS is not found for drive
  3786                                  ;
  3787                                  
  3788                                  BadDrive:
  3789 00000CB3 B008                    		mov	AL,8		; error code 'sector not found'
  3790 00000CB5 F9                      		stc			; indicate error
  3791                                  IORET:	
  3792 00000CB6 C3                      		retn			; return
  3793                                  
  3794                                  BogusSettle:
  3795 00000CB7 B00F                    		MOV	AL,NORMSETTLE	; someone has diddled the settle
  3796 00000CB9 E9B200                  		JMP	GotSlowSettle
  3797                                  
  3798                                  ;------------------------------------------------------------
  3799                                  ;
  3800                                  ;	DISK I/O HANDLER
  3801                                  ;
  3802                                  ;   On entry:
  3803                                  ;	AL = Drive Number (0-6)
  3804                                  ;	AH = Media Descriptor
  3805                                  ;	CX = sector count
  3806                                  ;	DX = first sector
  3807                                  ;	DS = CS
  3808                                  ;	ES:DI = transfer address
  3809                                  ;	[RFLAG] = operation (2 for read, 3 for write)
  3810                                  ;	[VERIFY] = 1 for verity after write
  3811                                  ;
  3812                                  ;   On exit:
  3813                                  ;	if successful carry flag = 0
  3814                                  ;	  else CF=1 and AL contains error code
  3815                                  ;
  3816                                  
  3817                                  DISKRD:		; 27/05/2018 - Retro DOS v3.0
  3818 00000CBC 2EC606[1A02]02          		mov	byte [CS:RFLAG],ROMRead	; set command to read
  3819                                  		; 25/08/2022 - IBMBIO.COM (IBMBIO33.IDB) address compatibility!
  3820                                  		;mov	byte [RFLAG],ROMRead	; 11/04/2018
  3821                                  DISKIO:
  3822                                  		; 13/04/2018
  3823                                  		; 08/04/2018
  3824                                  		; Retro DOS v2.0 (IBMDOS 2.1, IBMBIO.COM)
  3825                                  
  3826                                  		;clc
  3827                                  		;jcxz	IORET
  3828                                  		
  3829                                  		;;mov	[CS:SPSAV],SP		; save the sp value
  3830                                  		;mov	[SPSAV],sp
  3831                                  
  3832 00000CC2 89FB                    		mov	BX,DI			; ES:BX is transfer address
  3833 00000CC4 E82EFF                  		call	SETDRIVE		; map logical and physical
  3834                                  		; Temporary !
  3835                                  		; 25/08/2022 - IBMBIO.COM (IBMBIO33.IDB) address compatibility!
  3836 00000CC7 72EA                    		jc	short BadDrive		; carry means BDS not found
  3837                                  
  3838 00000CC9 8A4510                  		mov	al,[DI+BDS.Mediad]
  3839 00000CCC 2EA2[1802]              		mov	[CS:MedByt],al		; Preserve media byte for drive for use
  3840                                  						; in determining media change.
  3841 00000CD0 E3E4                    		jcxz	IORET
  3842 00000CD2 2E8926[2E02]            		mov	[CS:SPSAV],SP		; save the sp value
  3843                                  
  3844                                  		; DX = Sector address (offset)
  3845                                  		; BX = Buffer address (offset)
  3846                                  		
  3847                                  ; Ensure that we are trying to access valid sectors on the drive
  3848                                  ;
  3849 00000CD7 89D6                    		mov	SI,DX			; start with first sector
  3850 00000CD9 01CE                    		add	SI,CX			; add in sector count
  3851 00000CDB 035517                  		add	DX,[DI+BDS.HIDSEC]	; add in the hidden sectors
  3852 00000CDE 3B750E                  		cmp	SI,[DI+BDS.DRVLIM]	; compare against max (volume size)
  3853 00000CE1 77D0                    		ja	short BadDrive		; if greater than max, error
  3854 00000CE3 2E890E[1C02]            		mov	[CS:SECCNT],CX		; save sector count
  3855                                  
  3856                                  ;;Rev 3.30 Modification -----------------------------------------
  3857                                  ; SET UP POINTER TO DISK BASE TABLE IN [DPT]. WE CANNOT ASSUME THAT IOSETUP
  3858                                  ; WILL DO IT BECAUSE WE WILL SKIP THE SET UP STUFF WITH HARD DISKS.
  3859 00000CE8 1E                      		PUSH	DS
  3860 00000CE9 31C0                    		XOR	AX,AX
  3861 00000CEB 8ED8                    		MOV	DS,AX
  3862 00000CED C5367800                		LDS	SI,[DSKADR]		; CURRENT DISK PARM TABLE
  3863 00000CF1 2E8936[2602]            		MOV	[CS:DPT],SI
  3864 00000CF6 2E8C1E[2802]            		MOV	[CS:DPT+2],DS
  3865 00000CFB 1F                      		POP	DS
  3866                                  ;;End of Modification -----------------------------------------
  3867                                  
  3868                                  
  3869                                  ; For hard drives do not do media check or set DPT.
  3870                                  ;
  3871                                  
  3872 00000CFC F745290100              		test	word [DI+BDS.Flags],fNon_Removable
  3873 00000D01 7509                    		jnz	short Skip_Setup
  3874                                  	
  3875 00000D03 E839FF                  		CALL	CHECKSINGLE
  3876                                  
  3877                                  ;
  3878                                  ; Check to see if we have previously noted a change line.  The routine
  3879                                  ; returns if everything is OK.	Otherwise, it pops off the stack and returns
  3880                                  ; the proper error code.
  3881                                  ;
  3882                                  		;----------------------------------------|
  3883                                  		; Warning: Do not change the following. ;|
  3884                                  		;	   It gets patched in msinit	;|
  3885                                  							;|
  3886                                  DiskIO_PATCH:						;|
  3887 00000D06 E80E0F                  		CALL	CheckLatchIO			;|
  3888                                  		;----------------------------------------|
  3889                                  ;
  3890                                  ; Set up tables and variables for I/O
  3891 00000D09 E82900                  		call	IOSETUP
  3892                                  ;
  3893                                  ; Now the settle values are correct for the following code
  3894                                  ;
  3895                                  Skip_Setup:
  3896 00000D0C 89D0                    		mov	AX,DX		; setup locical sector for divide
  3897 00000D0E 31D2                    		xor	DX,DX
  3898 00000D10 F77513                  		div	word [DI+BDS.SECLIM] ; divide by sectors per track
  3899 00000D13 FEC2                    		inc	DL
  3900 00000D15 2E8816[2A02]            		mov	[CS:CURSEC],DL	; save current sector
  3901 00000D1A 8B4D15                  		mov	CX,[DI+BDS.HDLIM]  ; get number of heads
  3902 00000D1D 31D2                    		xor	DX,DX		; divide tracks by heads per cylinder
  3903 00000D1F F7F1                    		div	CX
  3904 00000D21 2E8816[2B02]            		mov	[CS:CURHD],DL	; save current head
  3905 00000D26 2EA3[2C02]              		mov	[CS:CURTRK],AX	; save current track
  3906                                  ;
  3907                                  ; We are now set up for the I/O.  Normally, we consider the DMA boundary
  3908                                  ; violations here.  Not true.  We perform the operation as if everything is
  3909                                  ; symmetric; let the DISK INT handler worry about the DMA violations.
  3910                                  ;
  3911 00000D2A 2EA1[1C02]              		mov	AX,[CS:SECCNT]
  3912 00000D2E E87100                  		call	BLOCK
  3913 00000D31 E84100                  		call	DONE
  3914 00000D34 C3                      		retn
  3915                                  
  3916                                  ; 27/05/2018 - Retro DOS v3.0
  3917                                  
  3918                                  ; IOSetUp:
  3919                                  ;
  3920                                  ; IOSetUp does the following functions:
  3921                                  ;   *	Set the drive-last-accessed flag (for diskette only).  No need to
  3922                                  ;	update these flags for hard disks becuase we know a hard disk will
  3923                                  ;	not be removed.
  3924                                  ;   *	Set the proper last sector number in the Disk Parameter Table (DPT)
  3925                                  ;   *	Set the proper motor start up time in DPT
  3926                                  ;   *	Set the proper head settle time in the DPT
  3927                                  ;
  3928                                  ; Input:
  3929                                  ;	DS:DI -> current BDS.
  3930                                  ; Output:
  3931                                  ;	AX,CX,SI are destroyed.
  3932                                  ;
  3933                                  
  3934                                  IOSETUP:
  3935 00000D35 8A4504                  		MOV	AL,[DI+BDS.DriveNum]
  3936 00000D38 2EA2[1502]              		MOV	[CS:TIM_DRV],AL	; SAVE DRIVE LETTER
  3937                                  ;
  3938                                  ; determine proper head settle values
  3939                                  ;
  3940 00000D3C 8CD9                    		mov	CX,DS
  3941 00000D3E 2EC536[2602]            		LDS	SI,[CS:DPT]	; GET POINTER TO DISK BASE TABLE
  3942 00000D43 2EA0[2402]              		MOV	AL,[CS:EOT]
  3943 00000D47 884404                  		mov	[SI+DISK_PARMS.DISK_EOT],AL	; bump for us
  3944 00000D4A 8A440A                  		mov	AL,[SI+DISK_PARMS.DISK_MOTOR_STRT] 
  3945                                  					; preserve old motor start time
  3946 00000D4D 2EA2[1F02]              		mov	[CS:MotorStartup],AL
  3947                                  ;
  3948                                  ; For 3.5" drives, both external as well as on the K09, we need to set the
  3949                                  ; Motor Start Time to 4. This checking for every I/O is going to affect
  3950                                  ; performance across the board, but is necessary!!
  3951                                  ;
  3952 00000D51 06                      		push	es
  3953 00000D52 8EC1                    		mov	es,cx		; ES:DI -> to current BDS
  3954 00000D54 26807D2802              		cmp	byte [es:di+BDS.FormFactor],ffSmall
  3955 00000D59 7505                    		jnz	short Motor_Start_OK
  3956 00000D5B B004                    		mov	AL,4
  3957 00000D5D 86440A                  		xchg	AL,[SI+DISK_PARMS.DISK_MOTOR_STRT]
  3958                                  Motor_Start_OK:
  3959 00000D60 07                      		pop	ES
  3960                                  ;
  3961                                  ; DS:SI now points to disk parameter table.  Get current settle and set fast
  3962                                  ; settle
  3963                                  ;
  3964 00000D61 30C0                    		XOR	AL,AL
  3965 00000D63 FEC0                    		INC	AL		; IBM WANTS FAST SETTLE = 1 - RS
  3966 00000D65 864409                  		xchg	AL,[SI+DISK_PARMS.DISK_HEAD_STTL]
  3967                                  					; get settle and set up for fast
  3968 00000D68 2EA2[2002]              		mov	[CS:SettleCurrent],AL
  3969 00000D6C B00F                    		MOV	AL,NORMSETTLE	; SOMEONE HAS DIDDLED THE SETTLE
  3970                                  GotSlowSettle:
  3971 00000D6E 8ED9                    		mov	DS,CX
  3972 00000D70 2EA2[2102]              		mov	[CS:SettleSlow],AL
  3973 00000D74 C3                      		retn
  3974                                  
  3975                                  ;
  3976                                  ; Set time of last access, and reset default values in the DPT.
  3977                                  ;
  3978                                  DONE:
  3979 00000D75 F745290100              		test	word [DI+BDS.Flags],fNon_Removable
  3980 00000D7A 7525                    		jnz	short RETZ	; Do not set for non-removable Media
  3981 00000D7C E87801                  		call	SET_TIM		; set time of last access for drive
  3982                                  ;
  3983                                  ; Restore head settle and EOT values
  3984                                  ;
  3985                                  DiddleBack:
  3986 00000D7F 50                      		push	ax			; preserve AX
  3987 00000D80 8CDA                    		mov	DX,DS			; save DS in DX
  3988 00000D82 2EA0[2002]              		mov	AL,[cs:SettleCurrent]	; get value in registers
  3989 00000D86 2E8A26[1F02]            		mov	AH,[cs:MotorStartup]
  3990 00000D8B 2EC536[2602]            		lds	SI,[CS:DPT]		; get pointer to DPT
  3991 00000D90 C6440409                		mov	byte [SI+DISK_PARMS.DISK_EOT],9 ; save values in DPT
  3992 00000D94 884409                  		mov	[SI+DISK_PARMS.DISK_HEAD_STTL],AL
  3993 00000D97 C6440302                		mov	byte [SI+DISK_PARMS.DISK_SECTOR_SIZ],2
  3994 00000D9B 88640A                  		mov	[SI+DISK_PARMS.DISK_MOTOR_STRT],AH
  3995 00000D9E 8EDA                    		mov	DS,DX			; restore DS
  3996 00000DA0 58                      		pop	ax			; restore AX
  3997                                  RETZ:
  3998 00000DA1 C3                      		retn
  3999                                  
  4000                                  ;
  4001                                  ; Block reads or writes the number of sectors specified in AX
  4002                                  ; handling track boundaries.  For example, on an 8 sector per track
  4003                                  ; disk there might be a request to read 6 sectors starting at the 5th
  4004                                  ; sector.  Block breaks this request into a read of sectors 5-8 on
  4005                                  ; the first track and a read of sectors 1-2 on the next track.	Disk is
  4006                                  ; called to do the actual read.
  4007                                  ;
  4008                                  ;   Inputs:
  4009                                  ;	AX - number of sectors to be read
  4010                                  ;	DS:DI points to BDS for disk drive
  4011                                  ;	cs:CurSec - sector on track where read should start
  4012                                  ;	cs:CurTrk - track where read should start
  4013                                  ;	cs:CurHd - head for read
  4014                                  ;	ES:BX - transfer address
  4015                                  ; AX, CX, and BL are not preserved
  4016                                  ;
  4017                                  
  4018                                  BLOCK:
  4019 00000DA2 09C0                    		or	AX,AX		; see if any sectors to read
  4020 00000DA4 74FB                    		jz	short RETZ	; if not, return
  4021                                  ;;Rev 3.30 Modification -----------------------------------------
  4022                                  ; Fixed disk will not be restricted to the trk-by-trk basis.
  4023 00000DA6 F745290100              		test	word [DI+BDS.Flags], fNon_Removable
  4024 00000DAB 7406                    		jz	short BLOCK_FLOPPY
  4025 00000DAD E82600                  		call	DISK
  4026 00000DB0 31C0                    		xor	ax,ax
  4027 00000DB2 C3                      		RETN
  4028                                  BLOCK_FLOPPY:
  4029                                  ;;End of Modification -----------------------------------------
  4030                                  ;
  4031                                  ; READ AT MOST 1 TRACK WORTH.  PERFORM MINIMIZATION AT SECTOR / TRACK
  4032                                  ;
  4033 00000DB3 8A4D13                  		mov	CL,[DI+BDS.SECLIM] ; get sectors per track
  4034 00000DB6 FEC1                    		inc	CL
  4035 00000DB8 2E2A0E[2A02]            		sub	CL,[CS:CURSEC]	; set CX to number of sector after current
  4036 00000DBD 30ED                    		xor	CH,CH		;    sector on the current track
  4037 00000DBF 39C8                    		cmp	AX,CX		; is all of request on current track?
  4038 00000DC1 7302                    		jae	short GotMin	; no, jump down
  4039 00000DC3 89C1                    		mov	CX,AX	; yes, set number of sector on this track to AX
  4040                                  GotMin:
  4041                                  				; now
  4042                                  				; AX is the requested number of sectors to read
  4043                                  				; CX is the number that we can do on this track
  4044 00000DC5 50                      		push	AX
  4045 00000DC6 51                      		push	CX
  4046 00000DC7 89C8                    		mov	AX,CX	; AL is number of sectors to read
  4047 00000DC9 E80A00                  		call	DISK
  4048 00000DCC 59                      		pop	CX
  4049 00000DCD 58                      		pop	AX
  4050                                  
  4051                                  				; CX is the number of sectors just transferred
  4052 00000DCE 29C8                    		sub	AX,CX	; reduce sectors-remaining by last I/O
  4053 00000DD0 D0E1                    		shl	CL,1
  4054 00000DD2 00CF                    		add	BH,CL	; adjust transfer address
  4055 00000DD4 EBCC                    		jmp	short BLOCK ; jump to do any remaining sectors
  4056                                  
  4057                                  
  4058                                  ; 27/05/2018 - Retro DOS v3.0
  4059                                  ;
  4060                                  ;  DISK:
  4061                                  ; Disk is called to read or write one or more sectors on a track.
  4062                                  ; Retries are make if an error occurs.
  4063                                  ;
  4064                                  ;    Input:
  4065                                  ;	AL - number of sector to be read/written (they must all be on one track)
  4066                                  ;	DS:DI points to BDS for the drive
  4067                                  ;	ES:BX is transfer address (must not cross 64k physical boundry)
  4068                                  ;	[RFLAG] is 2 for read and 3 for write
  4069                                  ;	[VERIFY] is 0 for normal, 1 for verify after write
  4070                                  ;	[CurTrk] is track (cylinder) to be read/written.
  4071                                  ;	[CurHd] is head to be used in operation.
  4072                                  ;	[CurSec] is sector to start read on.
  4073                                  ;
  4074                                  ; The following are overwritten: BP,
  4075                                  ;   Output:
  4076                                  ;	[SECCNT] is decrement by the number of sectors read or written
  4077                                  
  4078                                  DISK:
  4079 00000DD6 BD0500                  		mov	BP,MAXERR	; set up retry count
  4080 00000DD9 2E8A26[1A02]            		MOV	AH,[CS:RFLAG]	;GET READ/WRITE INDICATOR
  4081                                  
  4082                                  RETRY:
  4083                                  				; AX is overwritten in int 13 call, so
  4084                                  				; to do a retry we need to save the
  4085                                  				; value by pushing on the stack
  4086 00000DDE 50                      		push	AX
  4087                                  				; the next five lines of code put the
  4088                                  				; sector number in bit 5-0 of CL and the
  4089                                  				; cylinder number in CH and bits 7-6 of
  4090                                  				; CL.  The register must be set up in this
  4091                                  				; way for the bios.
  4092 00000DDF 2E8B16[2C02]            		mov	DX,[CS:CURTRK]	;Load current cylinder
  4093                                  ;;Rev 3.30 Modification -----------------------------------------
  4094 00000DE4 F745290100              		test	word [DI+BDS.Flags],fNon_Removable ;Fixed disk
  4095 00000DE9 7409                    		jz	short DISK_NOT_MINI 	;no, skip this.
  4096                                  		;cmp	byte [DI+BDSM.isMini], 1
  4097 00000DEB 837D4D01                		cmp	word [DI+BDSM.isMini], 1 ;Is this a mini disk?
  4098 00000DEF 7503                    		jnz	short DISK_NOT_MINI	;No. continue to next.
  4099 00000DF1 03554F                  		add	dx, [DI+BDSM.Hidden_Trks] ;else add hidden trks.
  4100                                  DISK_NOT_MINI:
  4101                                  ;;End of Modification -----------------------------------------
  4102 00000DF4 D0CE                    		ror	DH,1 ; get high two bits of cylinder in correct place
  4103 00000DF6 D0CE                    		ror	DH,1
  4104                                  
  4105 00000DF8 2E0A36[2A02]            		or	DH,[cs:CURSEC]	; get sector value
  4106 00000DFD 89D1                    		mov	CX,DX ; put cylinder/sector values in correct register
  4107                                  				; get head value
  4108 00000DFF 86E9                    		xchg	CH,CL	; put bytes in correct place
  4109 00000E01 2E8A36[2B02]            		mov	DH,[CS:CURHD]
  4110                                  				; get drive number
  4111 00000E06 8A5504                  		mov	DL,[DI+BDS.DriveNum]
  4112                                  
  4113 00000E09 807D2805                		CMP	BYTE [DI+BDS.FormFactor],ffHardFile
  4114 00000E0D 7414                    		JZ	short DO_Fast ; HARD FILES USE FAST SPEED
  4115                                  ;
  4116                                  ; The registers are now all set up for call on rom-bios.
  4117                                  ; The next dozen or so line determines whether we call Do_Fast or Do_Norm
  4118                                  ; for the actual I/O read.  Do_Fast calls FastSpeed for the actual I/O.
  4119                                  ; Do_Norm calls NormSpeed.  NormSpeed changes the value for the head settle
  4120                                  ; time in the disk parameter table to a larger value and then calls FastSpeed
  4121                                  ; to do the I/O.  So Do_Fast just has a shorter head settle time.
  4122                                  ;
  4123 00000E0F 2E803E[8401]FF          		CMP	byte [CS:STEP_DRV],-1
  4124                                  		;jz	short Do_Writej
  4125 00000E15 7459                    		jz	short DO_WRITE ; 14/06/2018
  4126                                  
  4127 00000E17 80FC02                  		cmp	AH,ROMRead	; For read...
  4128 00000E1A 7407                    		je	short DO_Fast	;   ... alway use fast
  4129                                  
  4130 00000E1C 80FC04                  		cmp	AH, ROMVerify	; For verify...
  4131 00000E1F 7402                    		je	short DO_Fast	;   ... alway use fast
  4132                                  
  4133                                  Do_Writej:
  4134 00000E21 EB4D                    		jmp	short DO_WRITE	; Jump down for write...
  4135                                  
  4136                                  		; Temporary
  4137                                  		; 25/08/2022 - IBMBIO.COM (IBMBIO33.IDB) address compatibility!
  4138                                  		;nop
  4139                                  
  4140                                  DO_Fast:
  4141 00000E23 E8AB00                  		CALL	FASTSPEED	; do I/O carry set if error
  4142                                  TestErr:
  4143 00000E26 7262                    		jc	short DSKERR	; error -- get out
  4144                                  ; SET DRIVE AND TRACK OF LAST ACCESS
  4145 00000E28 2E8816[8401]            		mov	[CS:STEP_DRV],DL ; save the last drive accessed
  4146 00000E2D 886D4C                  		mov	[DI+BDS.Track],CH ; save in BDS
  4147                                  
  4148                                  NO_SET:
  4149 00000E30 2E813E[1A02]0301        		cmp	word [CS:WRTVERIFY],103H ; Check for write and verify
  4150 00000E37 7448                    		jz	short DOVERIFY	; yes -- go do verify
  4151                                  NOVERIFY:
  4152 00000E39 58                      		pop	AX		; pop command and num sec. from stack
  4153 00000E3A 80E13F                  		and	CL,03FH		; Eliminate cylinder bits from sector
  4154 00000E3D 30E4                    		xor	AH,AH
  4155 00000E3F 2E2906[1C02]            		sub	[CS:SECCNT],AX	; Reduce count of sectors to go
  4156 00000E44 00C1                    		add	CL,AL		; Next sector
  4157 00000E46 2E880E[2A02]            		mov	[CS:CURSEC],CL
  4158                                  					 ; See if sector/track limit reached
  4159 00000E4B 3A4D13                  		cmp	CL,[DI+BDS.SECLIM]
  4160 00000E4E 761E                    		jbe	short Disk_Ret	; yes, return
  4161                                  NextTrack:
  4162 00000E50 2EC606[2A02]01          		mov	byte [CS:CURSEC],1 ; Start with first sector of next track
  4163 00000E56 2E8A36[2B02]            		mov	DH,[CS:CURHD]
  4164 00000E5B FEC6                    		inc	DH		; go to next head
  4165 00000E5D 3A7515                  		cmp	DH,[DI+BDS.HDLIM] ; at head limit?
  4166 00000E60 7207                    		jb	short NOXOR	; no, jump down
  4167 00000E62 30F6                    		xor	DH,DH		; at head limit, reset to head zero ...
  4168 00000E64 2EFF06[2C02]            		inc	word [CS:CURTRK] ; 	and go to next head
  4169                                  NOXOR:
  4170 00000E69 2E8836[2B02]            		mov	[CS:CURHD],DH	; save new head number
  4171                                  Disk_Ret:
  4172 00000E6E F8                      		clc			; successful return so clear error flag
  4173 00000E6F C3                      		retn			; all done
  4174                                  
  4175                                  ;
  4176                                  ; The request is for write.  Determine if we are talking about the same
  4177                                  ; track and drive.  If so, use the fast speed.
  4178                                  ;
  4179                                  DO_WRITE:
  4180 00000E70 2E3A16[8401]            		cmp	DL,[CS:STEP_DRV] ; same drive?
  4181 00000E75 7505                    		jnz	short DO_Norm 	 ; no, do normal speed
  4182 00000E77 3A6D4C                  		cmp	CH,[DI+BDS.Track] ; same track on drive
  4183 00000E7A 74A7                    		jz	short DO_Fast	; yes, do fast speed
  4184                                  DO_Norm:
  4185 00000E7C E83300                  		call	NORMSPEED	; use larger head settle time
  4186 00000E7F EBA5                    		jmp	SHORT TestErr	; test for error
  4187                                  
  4188                                  ;
  4189                                  ; we have a verify request also.  Get state info and go verify
  4190                                  ;
  4191                                  
  4192                                  DOVERIFY:
  4193 00000E81 58                      		pop	AX		; get number of sectors from stack
  4194 00000E82 50                      		push	AX		;    in non-detructive fashion
  4195 00000E83 B404                    		MOV	AH,ROMVerify	; REQUEST VERIFY
  4196 00000E85 E84900                  		CALL	FASTSPEED	; MZ  2.21 change settle mode
  4197 00000E88 73AF                    		JNC	short NOVERIFY
  4198                                  
  4199                                  ;
  4200                                  ; Need to special case the change-line error AH=06h.  If we get this, we
  4201                                  ; need to return it.
  4202                                  ;
  4203                                  	;----------------------------------------|
  4204                                  	; Warning: Do not change the following. ;|
  4205                                  	;	   It gets patched in msinit	;|
  4206                                  						;|
  4207                                  DSKERR:						;|
  4208 00000E8A E8CF0D                  		CALL	CheckIO 		;|
  4209                                  	;---------------------------------------;|
  4210                                  
  4211 00000E8D E8CD07                  		Call	AGAIN	; reset the disk and decrement retry cnt
  4212 00000E90 7409                    		jz	short HARDERR ; if z flag set, did all retries-give up
  4213 00000E92 80FC80                  		cmp	AH,80H		; timeout?
  4214 00000E95 7404                    		jz	short HARDERR ; yes, jump to hard error
  4215                                  DSKERR1:
  4216 00000E97 58                      		pop	AX		; Restore sector count
  4217 00000E98 E943FF                  		jmp	RETRY		;     and try again
  4218                                  
  4219                                  HARDERR:
  4220 00000E9B E84100                  		CALL	MAPERROR
  4221                                  
  4222                                  HARDERR2:			; for routines that call MapError themselves
  4223 00000E9E 2EC606[1502]FF          		mov	byte [CS:TIM_DRV],-1 ;Force a media check through ROM
  4224 00000EA4 2E8B0E[1C02]            		mov	CX,[CS:SECCNT]	;Get count of sectors to go
  4225 00000EA9 2E8B26[2E02]            		mov	SP,[CS:SPSAV]	;Recover entry stack pointer
  4226                                  ;
  4227                                  ; Since we are performing a non-local goto, restore the disk parameters
  4228                                  ;
  4229                                  MedByt_OK:
  4230 00000EAE E8CEFE                  		call	DiddleBack
  4231 00000EB1 C3                      		retn			;and return
  4232                                  
  4233                                  ;
  4234                                  ; change settle value from SettleCurrent to whatever is appropriate
  4235                                  ;
  4236                                  NORMSPEED:
  4237 00000EB2 1E                      		push	DS		; save two registers
  4238 00000EB3 50                      		push	AX
  4239                                  				; change value in current disk parm tbl
  4240 00000EB4 2EA0[2102]              		mov	AL,[CS:SettleSlow] 
  4241 00000EB8 2EC536[2602]            		lds	SI,[CS:DPT]	; current disk parm table
  4242 00000EBD 884409                  		mov	[SI+DISK_PARMS.DISK_HEAD_STTL],AL
  4243 00000EC0 58                      		pop	AX		; restore command and sector count
  4244 00000EC1 1F                      		pop	DS
  4245 00000EC2 E80C00                  		call	FASTSPEED	; do I/0
  4246 00000EC5 1E                      		push	DS	; restore the value in disk parm table
  4247 00000EC6 2EC536[2602]            		lds	SI,[CS:DPT]
  4248 00000ECB C6440901                		mov	byte [SI+DISK_PARMS.DISK_HEAD_STTL],1 ; 1 is fast settle
  4249 00000ECF 1F                      		pop	DS
  4250 00000ED0 C3                      		retn
  4251                                  
  4252                                  FASTSPEED:
  4253                                  ;
  4254                                  ; If the drive has been marked as too big (i.e. starting sector of the
  4255                                  ; partition is > 16 bits, then ALWAYS return drive not ready.
  4256                                  ;
  4257 00000ED1 F6451980                		TEST	BYTE [DI+BDS.FatSiz],fTOOBIG
  4258 00000ED5 7503                    		JNZ	short NotReady
  4259                                  
  4260 00000ED7 CD13                    		int	13h		; call rom-bios disk routines
  4261                                  Death:
  4262 00000ED9 C3                      		retn
  4263                                  NotReady:
  4264 00000EDA F9                      		stc			; set carry to indicate error
  4265 00000EDB B480                    		mov	AH,80h		; put error code in AH
  4266 00000EDD EBFA                    		jmp	short Death	; jump to ret
  4267                                  
  4268                                  ;
  4269                                  ; Map error returned by ROM into corresponding code to be returned to
  4270                                  ; DOS in AL.
  4271                                  ;
  4272                                  MAPERROR:
  4273 00000EDF 51                      		push	CX		; save cx
  4274 00000EE0 0E                      		push	CS
  4275 00000EE1 07                      		pop	ES		; make ES the local segment
  4276 00000EE2 88E0                    		mov	AL,AH		; move error code into AL
  4277 00000EE4 2EA2[3C02]              		mov	[CS:LSTERR],AL	; terminate list with error code
  4278 00000EE8 B90800                  		mov	CX,NUMERR	; number of possible error conditions
  4279 00000EEB BF[3502]                		mov	DI,ERRIN	; point to error conditions
  4280 00000EEE F2AE                    		repne	SCASB
  4281 00000EF0 2E8A4507                		mov	AL,[CS:DI+NUMERR-1] ; get translation
  4282 00000EF4 59                      		pop	cx		; restore cx
  4283 00000EF5 F9                      		stc			; flag error condition
  4284 00000EF6 C3                      		retn
  4285                                  
  4286                                  		; Temporary
  4287                                  		; 25/08/2022 - IBMBIO.COM (IBMBIO33.IDB) address compatibility!
  4288                                  		;db	0
  4289                                  
  4290                                  ;
  4291                                  ; Set the time of last access for this drive. This is done only for removable
  4292                                  ; media.
  4293                                  ;
  4294                                  SET_TIM:
  4295 00000EF7 50                      		push	ax
  4296 00000EF8 30E4                    		xor	AH, AH		; set command to get time
  4297 00000EFA CD1A                    		int	1Ah		; call rom-bios timer function
  4298 00000EFC 08C0                    		or	AL,AL		; is there 24 hour rollover?
  4299 00000EFE 7405                    		jz	short NOROLL3 	; no, skip down
  4300 00000F00 2EFF06[9E05]            		inc	word [CS:DAYCNT] ; yes, then increment DayCnt
  4301                                  NOROLL3:
  4302                                  ; We have the new time. If we see that the time has passed, then we reset
  4303                                  ; the threshold counter...
  4304 00000F05 3B554D                  		cmp	DX,[DI+BDS.TIM_LO] ; Did any time pass?
  4305 00000F08 7505                    		jnz	short SetAccess	; yes, update access time
  4306 00000F0A 3B4D4F                  		cmp	CX,[DI+BDS.TIM_HI] ; now look at the high bits
  4307 00000F0D 740C                    		jz	short Done_Set	; if equal then no time passed
  4308                                  SetAccess:				; we get here if some time has passed
  4309                                  					; zero AccessCount to show time passage
  4310 00000F0F 2EC606[1402]00          		mov	byte [CS:AccessCount],0
  4311 00000F15 89554D                  		MOV	[DI+BDS.TIM_LO],DX ; save low time bits
  4312 00000F18 894D4F                  		MOV	[DI+BDS.TIM_HI],CX ; save high time bit
  4313                                  Done_Set:
  4314 00000F1B F8                      		clc			; indicate no error
  4315 00000F1C 58                      		pop	ax		; restore AX register
  4316 00000F1D C3                      		retn
  4317                                  
  4318                                  ; 28/05/2018 - Retro DOS v3.0
  4319                                  
  4320                                  ;
  4321                                  ; This is the true DISK INT handler.  We parse the request to see if there is
  4322                                  ; a DMA violation.  If so, depending on the function, we:
  4323                                  ;   READ/WRITE	Break the request into three pieces and move the middle one
  4324                                  ;	into our internal buffer.
  4325                                  ;   FORMAT	Copy the format table into the buffer
  4326                                  ;   VERIFY	Point the transfer address into the buffer
  4327                                  ;
  4328                                  ; This is the biggest bogosity of all.	The IBM controller does NOT handle
  4329                                  ; operations that cross physical 64K boundaries.  In these cases, we copy
  4330                                  ; the offending sector into the buffer below and do the I/O from there.
  4331                                  ;
  4332                                  
  4333                                  ;;Rev 3.30 Modification -----------------------------------------
  4334                                  ;To handle the INT 13h, AH = 8 Problem.
  4335                                  ;Save Registers here.
  4336 00000F1E 0000                    Save_AX:   DW  0
  4337 00000F20 0000                    Save_BX:   DW  0
  4338 00000F22 0000                    Save_CX:   DW  0
  4339 00000F24 0000                    Save_DX:   DW  0
  4340 00000F26 0000                    Save_DI:   DW  0
  4341 00000F28 0000                    Save_SI:   DW  0
  4342 00000F2A 0000                    Save_BP:   DW  0
  4343 00000F2C 0000                    Save_DS:   DW  0
  4344 00000F2E 0000                    Save_ES:   DW  0
  4345 00000F30 0000                    Prev_DX:   DW  0
  4346 00000F32 0000                    Save_Flag: DW  0
  4347                                  ;;End of Modification -----------------------------------------
  4348                                  
  4349                                  ;
  4350                                  ; Block13:
  4351                                  ;
  4352                                  ;   Entry conditions:
  4353                                  ;	AH = function
  4354                                  ;	AL = number of sectors
  4355                                  ;	ES:BX = DMA address
  4356                                  ;	CX = packed track and sector
  4357                                  ;	DX = head and drive
  4358                                  ;   Output conditions:
  4359                                  ;	NO DMA violation.
  4360                                  ;
  4361                                  
  4362                                  Block13:
  4363                                  ;
  4364                                  ; Let the operation proceed.  If there is a DMA violation, then we do things.
  4365                                  ;
  4366 00000F34 2EA3[C000]              		mov	 [cs:PrevOper],AX	; save request
  4367 00000F38 9C                      		pushf				; preserve the flags
  4368 00000F39 80FC05                  		cmp	AH,ROMFormat		; format request?
  4369 00000F3C 750A                    		jnz	short Not_Format	;    no, skip down
  4370                                  
  4371                                  	; Set changed by format bit for all logical drives using this physical drive
  4372                                  		;---------------------------------------------------------|
  4373                                  		; Warning: Do Not Change the following. 		  |
  4374                                  		; It gets patched in at INIT time			  |
  4375                                  Changed_Patch:
  4376 00000F3E 2EC706[1602]4001        		mov	word [cs:FlagBits],fChanged_By_Format+fChanged
  4377 00000F45 E8C50D                  		call	Set_Changed_DL	; Indicate that media changed by format
  4378                                  		;							  |
  4379                                  		;---------------------------------------------------------|
  4380                                  
  4381                                  Not_Format:
  4382                                  ;;Rev 3.30 Modification -----------------------------------------
  4383 00000F48 80FC08                  		cmp	ah, 8			; Read Driver Parm ?
  4384 00000F4B 7412                    		je	short Bus_Problem
  4385 00000F4D 80FC15                  		cmp	ah, 15h
  4386 00000F50 740D                    		je	short Bus_Problem
  4387 00000F52 2EFF1E[B400]            		CALL	far [CS:ORIG13]		; SIMULATE INT 13
  4388 00000F57 7203                    		JC	short GOTERR13_br	; ERROR?
  4389                                  		;14/06/2018
  4390 00000F59 CA0200                  		RETF	2			; NO, RETURN AND CLEAR FLAGS
  4391                                  
  4392                                  GOTERR13_br: 
  4393 00000F5C E98000                  		jmp	GotErr13
  4394                                  
  4395                                  ;Some machines have a problem with Int 13h function=8
  4396                                  ;This function does not reset the common buses after the execution.
  4397                                  ;To solve this problem, when we detect AH=8h, then we will save the result
  4398                                  ;and will issue AH=1 (Read Status) call to reset the buses.
  4399                                  
  4400                                  Bus_Problem:
  4401 00000F5F 2E8916[300F]            		mov	[cs:Prev_DX], DX	;save orignal drive number
  4402 00000F64 2EFF1E[B400]            		call	far [CS:ORIG13]		;Do "Read drive parm"
  4403                                  
  4404 00000F69 2EA3[1E0F]              		mov	[cs:Save_AX], AX	;Save registers,flag
  4405 00000F6D 2E891E[200F]            		mov	[cs:Save_BX], BX
  4406 00000F72 2E890E[220F]            		mov	[cs:Save_CX], CX
  4407 00000F77 2E8916[240F]            		mov	[cs:Save_DX], DX
  4408 00000F7C 2E893E[260F]            		mov	[cs:Save_DI], DI
  4409 00000F81 2E8936[280F]            		mov	[cs:Save_SI], SI
  4410 00000F86 2E892E[2A0F]            		mov	[cs:Save_BP], BP
  4411 00000F8B 2E8C1E[2C0F]            		mov	[cs:Save_DS], DS
  4412 00000F90 2E8C06[2E0F]            		mov	[cs:Save_ES], ES
  4413 00000F95 9C                      		pushf
  4414 00000F96 2E8F06[320F]            		pop	word [cs:Save_Flag]
  4415                                  
  4416 00000F9B 2E8B16[300F]            		mov	dx, [cs:Prev_DX]	;restore orignal drive
  4417 00000FA0 9C                      		pushf
  4418 00000FA1 B401                    		mov	ah, 1			;Read Status.
  4419 00000FA3 2EFF1E[B400]            		call	far [CS:ORIG13]		;Reset the bus as a side effect
  4420                                  
  4421 00000FA8 2EA1[1E0F]              		mov	AX, [cs:Save_AX]	;restore registers,flag
  4422 00000FAC 2E8B1E[200F]            		mov	BX, [cs:Save_BX]
  4423 00000FB1 2E8B0E[220F]            		mov	CX, [cs:Save_CX]
  4424 00000FB6 2E8B16[240F]            		mov	DX, [cs:Save_DX]
  4425 00000FBB 2E8B3E[260F]            		mov	DI, [cs:Save_DI]
  4426 00000FC0 2E8B36[280F]            		mov	SI, [cs:Save_SI]
  4427 00000FC5 2E8B2E[2A0F]            		mov	BP, [cs:Save_BP]
  4428 00000FCA 2E8E1E[2C0F]            		mov	DS, [cs:Save_DS]
  4429 00000FCF 2E8E06[2E0F]            		mov	ES, [cs:Save_ES]
  4430 00000FD4 2EFF36[320F]            		push	word [cs:Save_Flag]
  4431 00000FD9 9D                      		popf
  4432 00000FDA 7203                    		jc	short GotErr13		;AH=8 had been an error?
  4433                                  		;14/06/2018
  4434 00000FDC CA0200                  		retf	2
  4435                                  ;
  4436                                  ; Some kind of error occurred.	See if it is DMA violation
  4437                                  ;
  4438                                  GotErr13:
  4439 00000FDF 9C                      		pushf
  4440 00000FE0 80FC09                  		cmp	AH, 09h			; is error DMA error code?
  4441                                  		;JNZ	short CHECK_ECC
  4442                                  		;JMP	short GotDMAErr
  4443                                  		; 03/09/2022
  4444 00000FE3 7458                    		jz	short GotDMAErr
  4445                                  
  4446                                  		; Temporary
  4447                                  		; 25/08/2022 - IBMBIO.COM (IBMBIO33.IDB) address compatibility!
  4448                                  		;nop
  4449                                  
  4450                                  CHECK_ECC:
  4451 00000FE5 80FC11                  		CMP	AH,11H
  4452 00000FE8 7404                    		JZ	short OK11
  4453 00000FEA 9D                      		POPF
  4454                                  		; 14/06/2018
  4455 00000FEB CA0200                  		RETF	2
  4456                                  ;
  4457                                  ; We have an error status 11h.	This indicates an ECC-corrected error.	Note
  4458                                  ; that this indicates that the data is PROBABLY correct but not CERTAINLY
  4459                                  ; correct. The ROMs on PC-1s and PC_XTs have a 'bug' in that if an ECC error
  4460                                  ; occurs for a multi-sector read, only the sectors up to the one where the
  4461                                  ; error occurred are read in. We have no way of knowing how many were read in
  4462                                  ; this case, so we redo the operation, reading one sector at a time. If we
  4463                                  ; get an ECC error on reading one sector, we ignore the error because the
  4464                                  ; sector has been read in.
  4465                                  ;
  4466                                  
  4467                                  OK11:
  4468                                  ;		popf			; restore flags
  4469                                  ;;Rev 3.30 Modification -----------------------------------------
  4470                                  ; Here, it is better reset the system. So, we are going to
  4471                                  ; call Orig13 again
  4472 00000FEE B400                    		mov	ah,0
  4473 00000FF0 2EFF1E[B400]            		call	far [CS:ORIG13]	;reset. Don't care about result
  4474                                  ;;End of Modification -----------------------------------------
  4475                                  
  4476 00000FF5 2EA1[C000]              		mov	ax,[cs:PrevOper] ; Retrieve request
  4477                                  ;
  4478                                  ; This will provide a termination point.
  4479                                  ;
  4480 00000FF9 3C01                    		cmp	AL,1		; If request for one sector, assume OK
  4481 00000FFB 7505                    		jnz	short ECC_Err_Handle ; more than one sector -- jump down
  4482 00000FFD 30E4                    		xor	AH,AH		; clear carry too!
  4483                                  		;14/06/2018
  4484 00000FFF CA0200                  		retf	2
  4485                                  
  4486                                  ECC_Err_Handle:
  4487 00001002 53                      		push	bx
  4488 00001003 51                      		push	cx
  4489 00001004 52                      		push	dx
  4490 00001005 2EA2[C200]              		mov	[cs:Number_Of_Sec],AL
  4491                                  Loop_ECC:
  4492 00001009 2EA1[C000]              		mov	AX,[CS:PrevOper] ; set command to previos command
  4493 0000100D B001                    		mov	AL,1		 ;     but request only one sector
  4494                                  ;
  4495                                  ; we do reads one sector at a time. this ensures that we will eventually
  4496                                  ; finish the request since ecc errors on 1 sector do read in that sector.
  4497                                  ;
  4498                                  ; we need  some "intelligence" in the ecc handler to handle reads
  4499                                  ; that attempt to read more sectors than are available on a particular
  4500                                  ; track.
  4501                                  ; we call check_wrap to set up the sector #, head # and cylinder # for
  4502                                  ; this request.
  4503                                  ; at this point, all registers are set up for the call to orig13, except
  4504                                  ; that there maybe a starting sector number that is bigger than the number
  4505                                  ; of sectors on a track.
  4506                                  ;
  4507 0000100F E84607                  		CALL	Check_Wrap	; see if wrapping around cylinder
  4508                                  
  4509 00001012 9C                      		pushf			; save flags
  4510 00001013 2EFF1E[B400]            		call	far [CS:ORIG13]	; call original rom-bios code
  4511                                  ;;Rev 3.30 Modification ------------------------------------------------------
  4512 00001018 730D                    		JNC	short OK11_Op
  4513 0000101A 80FC11                  		CMP	AH,11H		; ONLY ALLOW ECC ERRORS
  4514 0000101D 7517                    		JNZ	short OK11_EXIT_err ; Other error?
  4515 0000101F B400                    		mov	ah,0		; ECC error. Reset it again.
  4516 00001021 9C                      		pushf
  4517 00001022 2EFF1E[B400]            		call	far [CS:ORIG13]
  4518                                  OK11_Op:
  4519                                  					; adjust number of sectors for one read
  4520 00001027 2EFE0E[C200]            		dec	byte [CS:Number_Of_Sec]	
  4521 0000102C 7409                    		jz	short OK11_Exit	; all done?
  4522 0000102E FEC1                    		inc	CL		; advance sector number
  4523 00001030 FEC7                    		inc	BH		; add 200H to address
  4524 00001032 FEC7                    		inc	BH
  4525 00001034 EBD3                    		jmp	short Loop_ECC	; and around for reading another sector
  4526                                  
  4527                                  OK11_EXIT_err:
  4528 00001036 F9                      		stc			; Set carry bit again.
  4529                                  ;;End of Modification ------------------------------------------------------
  4530                                  
  4531                                  OK11_Exit:
  4532 00001037 5A                      		pop	dx
  4533 00001038 59                      		pop	cx
  4534 00001039 5B                      		pop	bx
  4535                                  		;14/06/2018
  4536 0000103A CA0200                  		retf	2
  4537                                  
  4538                                  ;
  4539                                  ; we truly have a DMA violation.  Restore register AX and retry the
  4540                                  ; operation as best we can.
  4541                                  ;
  4542                                  GotDMAErr:
  4543 0000103D 58                      		pop	AX		; clean up stack
  4544 0000103E 2EA1[C000]              		mov	AX,[cs:PrevOper] ; restore command
  4545 00001042 FB                      		sti			; restore interrupts
  4546 00001043 80FC02                  		cmp	AH,ROMRead	; determine the command
  4547 00001046 7266                    		jb	short IntDone
  4548 00001048 80FC04                  		cmp	AH,ROMVerify
  4549 0000104B 7439                    		jz	short IntVerify
  4550 0000104D 80FC05                  		cmp	AH,ROMFormat
  4551 00001050 7446                    		jz	short IntFormat
  4552 00001052 775A                    		ja	short IntDone
  4553                                  ;
  4554                                  ; We are doing a read/write call.  Check for DMA problems
  4555                                  ;
  4556 00001054 52                      		push	dx		; save registers we overwrite
  4557 00001055 51                      		push	cx
  4558 00001056 53                      		push	bx
  4559 00001057 50                      		push	ax
  4560                                  
  4561 00001058 55                      		push	BP
  4562 00001059 89E5                    		mov	BP,SP
  4563 0000105B 8CC2                    		mov	DX,ES		; Check for 64k boundary error
  4564                                  
  4565 0000105D D1E2                    		shl	DX,1
  4566 0000105F D1E2                    		shl	DX,1
  4567 00001061 D1E2                    		shl	DX,1
  4568 00001063 D1E2                    		shl	DX,1		; Segment converted to absolute address
  4569                                  
  4570 00001065 01DA                    		add	DX,BX		; Combine with offset
  4571 00001067 81C2FF01                		add	DX,511		; simulate a transfer
  4572                                  ;
  4573                                  ; If carry is set, then we are within 512 bytes of the end of the segment.
  4574                                  ; We skip the first transfer and perform the remaining buffering and transfer
  4575                                  ;
  4576 0000106B 7306                    		JNC	short NO_SKIP_FIRST
  4577 0000106D 8A7609                  		mov	DH,[bp+INT13FRAME.olddx+1] ; set correct head number
  4578 00001070 E99A00                  		jmp	Buffer
  4579                                  
  4580                                  NO_SKIP_FIRST:
  4581                                  ;
  4582                                  ; DX is the physical 16 bits of start of transfer.  Compute remaining
  4583                                  ; sectors in segment.
  4584                                  ;
  4585 00001073 D0EE                    		shr	DH,1		; DH = number of sectors before address
  4586 00001075 B480                    		mov	AH,128		; AH = max number of sectors in segment
  4587 00001077 28F4                    		sub	AH,DH
  4588                                  ;
  4589                                  ; AH is now the number of sectors that we can successfully write in this
  4590                                  ; segment.  If this number is above or equal to the requested number, then we
  4591                                  ; continue the operation as normal.  Otherwise, we break it into pieces.
  4592                                  ;
  4593 00001079 38C4                    		cmp	AH,AL		; can we fit it in?
  4594 0000107B 7236                    		jb	short DoBlock	; no, perform blocking.
  4595                                  ;
  4596                                  ; Yes, the request fits.  Let it happen
  4597                                  ;
  4598 0000107D 8A7609                  		MOV	DH,[BP+INT13FRAME.olddx+1] ; SET UP HEAD NUMBER
  4599 00001080 E89607                  		call	DoINT
  4600 00001083 E9F100                  		jmp	Bad13
  4601                                  ;
  4602                                  ; Verify the given sectors.  Place the buffer pointer into our space.
  4603                                  ;
  4604                                  IntVerify:
  4605 00001086 06                      		push	es
  4606 00001087 53                      		push	bx
  4607 00001088 0E                      		push	CS
  4608 00001089 07                      		pop	ES
  4609                                  DoSimple:
  4610 0000108A BB[4602]                		mov	BX,DiskSector
  4611 0000108D 9C                      		pushf
  4612 0000108E 2EFF1E[B400]            		call	far [CS:ORIG13]
  4613 00001093 5B                      		pop	bx
  4614 00001094 07                      		pop	es
  4615                                  		;14/06/2018
  4616 00001095 CA0200                  		retf	2
  4617                                  
  4618                                  ;
  4619                                  ; Format operation.  Copy the parameter table into memory
  4620                                  ;
  4621                                  IntFormat:
  4622 00001098 06                      		push	es
  4623 00001099 53                      		push	bx
  4624 0000109A 56                      		push	si
  4625 0000109B 57                      		push	di
  4626 0000109C 1E                      		push	ds
  4627 0000109D 06                      		push	ES
  4628 0000109E 0E                      		push	CS
  4629 0000109F 07                      		pop	ES
  4630 000010A0 1F                      		pop	DS
  4631 000010A1 89DE                    		mov	SI,BX
  4632 000010A3 BF[4602]                		mov	DI,DiskSector
  4633 000010A6 E86707                  		call	Move
  4634 000010A9 1F                      		pop	ds
  4635 000010AA 5F                      		pop	di
  4636 000010AB 5E                      		pop	si
  4637 000010AC EBDC                    		jmp	short DoSimple
  4638                                  ;
  4639                                  ; Inline continuation of operation
  4640                                  ;
  4641                                  IntDone:
  4642 000010AE 2EFF2E[B400]            		jmp	far [CS:ORIG13]
  4643                                  ;
  4644                                  ; We can't fit the request into the entire block.  Perform the operation on
  4645                                  ; the first block.
  4646                                  ;
  4647                                  ;
  4648                                  ; DoBlock is modified to correctly handle multi-sector disk I/O. 
  4649                                  ; Old DoBlock had added the number of sectors I/Oed (AH in Old DoBlock) after
  4650                                  ; the DoInt call to CL.  Observing only the lower 6 bits of CL(=max. 64) can
  4651                                  ; represent a starting sector, if AH was big, then CL would be clobbered.
  4652                                  ; By the way, we still are going to use CL for this purpose since Checkwrap
  4653                                  ; routine will use it as an input.  To prevent CL from being clobbered, a 
  4654                                  ; safe number of sectors should be calculated like "63 - # of sectors/track".
  4655                                  ; DoBlock will handle the first block of requested sectors within the
  4656                                  ; boundary of this safe value.
  4657                                  
  4658                                  ;Try to get the # of sectors/track from BDS via Rom drive number.
  4659                                  ;For any mini disks installed, here we have to pray that they have the
  4660                                  ;same # of sector/track as the main DOS partition disk drive.
  4661                                  
  4662                                  DoBlock:
  4663                                  ;;Rev 3.30 Modification ------------------------------------------------------
  4664                                  		;mov	dx,[bp+INT13FRAME] 	;set head #
  4665 000010B3 8B5608                  		mov	dx,[bp+INT13FRAME.olddx] ;set head # ; 17/07/2019
  4666 000010B6 57                      		push	di					
  4667 000010B7 1E                      		push	ds					
  4668 000010B8 50                      		push	ax		;AH=# of sectors before DMA err
  4669                                  					;AL - User requested # of sectors
  4670 000010B9 2EC606[8501]01          		mov	byte [CS:PHYS_DRV],1				
  4671 000010BF 88D0                    		mov	al, dl							
  4672 000010C1 E831FB                  		call	SETDRIVE	;get BDS pointer for this DISK. 
  4673 000010C4 58                      		pop	ax							
  4674 000010C5 2EC606[8501]00          		mov	byte [CS:PHYS_DRV],0				
  4675 000010CB F745290100              		test	word [DI+BDS.Flags],fNon_Removable ;don't have to worry
  4676 000010D0 7504                    		jnz	short DoBlockHard ;about floppies. They are track by
  4677                                  					;track operations	
  4678 000010D2 88E0                    		mov	al, ah		;set al = ah for floppies
  4679 000010D4 EB0F                    		jmp	short DoBlockCont			
  4680                                  DoBlockHard:					
  4681 000010D6 51                      		push	cx				
  4682 000010D7 31C9                    		xor	cx, cx				
  4683 000010D9 8B4D13                  		mov	cx, [DI+BDS.SECLIM] ;# of sectors/track
  4684 000010DC B53F                    		mov	ch, 63						
  4685 000010DE 28CD                    		sub	ch, cl						
  4686 000010E0 88E8                    		mov	al, ch						
  4687 000010E2 86E0                    		xchg	ah, al		;now ah - safe # of sectors
  4688                                  					;al - # of sectors before DMA err
  4689 000010E4 59                      		pop	cx							
  4690                                  DoBlockCont:								
  4691 000010E5 1F                      		pop	ds							
  4692 000010E6 5F                      		pop	di							
  4693                                  DoBlockContinue:							
  4694 000010E7 38C4                    		cmp	ah, al		;if safe_# >= #_of_sectors_to_go_before DMA,
  4695 000010E9 7305                    		jae	short DoBlocklast ;then #_of_sectors_to_go as it is for DoInt.
  4696 000010EB 50                      		push	ax		;save AH, AL				
  4697 000010EC 88E0                    		mov	al, ah		;Otherwise, set al to ah to operate.
  4698                                  			;DoInt will set AH to a proper function in [BP.Oldax]	
  4699 000010EE EB03                    		jmp	short DoBlockDoInt 
  4700                                  DoBlocklast:						
  4701 000010F0 88C4                    		mov	ah, al					
  4702 000010F2 50                      		push	ax		;save AH	
  4703                                  DoBlockDoInt:				;let AH=AL=# of sectors this shot
  4704 000010F3 E82307                  		CALL	DoINT							 
  4705 000010F6 727F                    		JC	short Bad13	;something happened, bye!	 
  4706 000010F8 58                      		pop	ax
  4707                                  					;decrement by the successful operation							 
  4708 000010F9 286602                  		SUB	BYTE [BP+INT13FRAME.oldax], AH 	
  4709 000010FC 00E1                    		ADD	CL,AH		;advance sector number. Safety guaranteed.	
  4710 000010FE 00E7                    		ADD	BH,AH		;advance DMA address			
  4711 00001100 00E7                    		ADD	BH,AH		;twice for 512 byte sectors.	
  4712 00001102 38C4                    		cmp	ah, al		;check the previous value	
  4713 00001104 7407                    		je	short Buffer	;if #_of_sectors_to_go < safe_#, 
  4714                                  					; then we are done already. 
  4715 00001106 28E0                    		sub	al, ah		;otherwise, 
  4716                                  					; #_sector_to_go = #_of_sector_to_go - safe_#  
  4717 00001108 E84D06                  		call	Check_Wrap	;get new CX, DH for the next operation. 		  
  4718 0000110B EBDA                    		jmp	short DoBlockContinue ;handles next sectors left.			
  4719                                  ;;End of Modification ------------------------------------------------------
  4720                                  ;
  4721                                  Buffer:
  4722 0000110D 53                      		push	BX
  4723 0000110E 8A6603                  		mov	AH,[BP+INT13FRAME.oldax+1]
  4724 00001111 80FC03                  		cmp	AH,ROMWrite
  4725 00001114 7525                    		jnz	short DoRead
  4726                                  ;
  4727                                  ; Copy the offending sector into local buffer
  4728                                  ;
  4729 00001116 1E                      		push	ds
  4730 00001117 06                      		push	es
  4731 00001118 56                      		push	si
  4732 00001119 57                      		push	di
  4733 0000111A 0E                      		push	CS		; exchange segment registers
  4734 0000111B 06                      		push	ES
  4735 0000111C 1F                      		pop	DS
  4736 0000111D 07                      		pop	ES
  4737 0000111E BF[4602]                		mov	DI,DiskSector	; where to move
  4738 00001121 57                      		push	DI		; save it
  4739 00001122 89DE                    		mov	SI,BX		; source
  4740 00001124 E8E906                  		call	Move
  4741 00001127 5B                      		pop	BX		; new transfer address
  4742 00001128 5F                      		pop	di
  4743 00001129 5E                      		pop	si
  4744 0000112A B001                    		mov	AL,1
  4745 0000112C 8A5608                  		mov	DL,[BP+INT13FRAME.olddx] ; set drive number
  4746 0000112F E82606                  		call	Check_Wrap	; check for head or cylinder wrap
  4747                                  ;
  4748                                  ;   AH is function
  4749                                  ;   AL is 1 for single sector transfer
  4750                                  ;   ES:BX is local transfer addres
  4751                                  ;   CX is track/sector number
  4752                                  ;   DX is head/drive number
  4753                                  ;   SI,DI unchanged
  4754                                  ;
  4755 00001132 E8E406                  		CALL	DoINT
  4756 00001135 07                      		pop	es
  4757 00001136 1F                      		pop	ds
  4758 00001137 723E                    		jc	short Bad13	; go clean up
  4759 00001139 EB26                    		jmp	SHORT DoTail
  4760                                  ;
  4761                                  ; Reading a sector.  Do INT first, then move things around
  4762                                  ;
  4763                                  DoRead:
  4764 0000113B 06                      		push	es
  4765 0000113C 53                      		push	bx
  4766 0000113D 0E                      		push	CS
  4767 0000113E 07                      		pop	ES
  4768 0000113F BB[4602]                		mov	BX,DiskSector
  4769 00001142 B001                    		mov	AL,1
  4770 00001144 8A5608                  		mov	DL,[BP+INT13FRAME.olddx] ; set drive number
  4771 00001147 E80E06                  		call	Check_Wrap	; check for head or cylinder wrap
  4772                                  ;
  4773                                  ;   AH = function
  4774                                  ;   AL = 1 for single sector
  4775                                  ;   ES:BX points to local buffer
  4776                                  ;   CX, DX are track/sector, head/drive
  4777                                  ;
  4778 0000114A E8CC06                  		CALL	DoINT
  4779 0000114D 5B                      		pop	bx
  4780 0000114E 07                      		pop	es
  4781 0000114F 7226                    		jc	short Bad13	; error => clean up
  4782 00001151 1E                      		push	ds
  4783 00001152 56                      		push	si
  4784 00001153 57                      		push	di
  4785 00001154 0E                      		push	CS
  4786 00001155 1F                      		pop	DS
  4787 00001156 89DF                    		mov	DI,BX
  4788 00001158 BE[4602]                		mov	SI,DiskSector
  4789 0000115B E8B206                  		call	Move
  4790 0000115E 5F                      		pop	di
  4791 0000115F 5E                      		pop	si
  4792 00001160 1F                      		pop	ds
  4793                                  ;
  4794                                  ; Note the fact that we've done 1 more sector
  4795                                  ;
  4796                                  DoTail:
  4797 00001161 5B                      		pop	BX		; retrieve new DMA area
  4798 00001162 80C702                  		add	BH,2		; advance over sector
  4799 00001165 41                      		inc	CX
  4800 00001166 8A4602                  		mov	AL,[BP+INT13FRAME.oldax]
  4801 00001169 F8                      		clc
  4802 0000116A FEC8                    		dec	AL
  4803 0000116C 7409                    		jz	short Bad13	; no more I/O
  4804 0000116E 8A5608                  		mov	DL,[BP+INT13FRAME.olddx] ; set drive number
  4805 00001171 E8E405                  		call	Check_Wrap	; check for head or cylinder wrap
  4806 00001174 E8A206                  		call	DoINT
  4807                                  ;
  4808                                  ; We are done.	AX has the final code; we throw away what we got before
  4809                                  ;
  4810                                  Bad13:
  4811 00001177 89EC                    		mov	SP,BP
  4812 00001179 5D                      		pop	bp
  4813 0000117A 5B                      		pop	bx
  4814 0000117B 5B                      		pop	bx
  4815 0000117C 59                      		pop	cx
  4816 0000117D 5A                      		pop	dx
  4817                                  		; 06/07/2018
  4818 0000117E CA0200                  		retf	2
  4819                                  
  4820                                  ; include msioctl.inc
  4821                                  
  4822                                  ;-----------------------------------------------------------------------------
  4823                                  ; include msioctl.inc - MSDOS 3.3 - MSDISK.ASM - 02/02/1988
  4824                                  ;-----------------------------------------------------------------------------
  4825                                  ; 24/03/2018 - Retro DOS v2.0
  4826                                  
  4827                                  		; include ioctl.inc
  4828                                  
  4829                                  ; IOCTL.INC - MSDOS 6.0 - 1991
  4830                                  ; ............................................................................
  4831                                  
  4832                                  ;*** J.K.
  4833                                  ;General Guide -
  4834                                  ;Category Code:
  4835                                  ; 0... .... DOS Defined
  4836                                  ; 1... .... User defined
  4837                                  ; .xxx xxxx Code
  4838                                  
  4839                                  ;Function Code:
  4840                                  ; 0... .... Return error if unsupported
  4841                                  ; 1... .... Ignore if unsupported
  4842                                  ; .0.. .... Intercepted by DOS
  4843                                  ; .1.. .... Passed to driver
  4844                                  ; ..0. .... Sends data/commands to device
  4845                                  ; ..1. .... Quries data/info from device
  4846                                  ; ...x .... Subfunction
  4847                                  ;
  4848                                  ; Note that "Sends/queries" data bit is intended only to regularize the
  4849                                  ; function set.  It plays no critical role; some functions may contain both
  4850                                  ; command and query elements. The convention is that such commands are
  4851                                  ; defined as "sends data".
  4852                                  
  4853                                  ;*****************************;*
  4854                                  ; BLOCK DRIVERS 	      ;*
  4855                                  ;*****************************;*
  4856                                  
  4857                                  ; IOCTL SUB-FUNCTIONS
  4858                                  IOCTL_GET_DEVICE_INFO	EQU	0
  4859                                  IOCTL_SET_DEVICE_INFO	EQU	1
  4860                                  IOCTL_READ_HANDLE	EQU	2
  4861                                  IOCTL_WRITE_HANDLE	EQU	3
  4862                                  IOCTL_READ_DRIVE	EQU	4
  4863                                  IOCTL_WRITE_DRIVE	EQU	5
  4864                                  IOCTL_GET_INPUT_STATUS	EQU	6
  4865                                  IOCTL_GET_OUTPUT_STATUS EQU	7
  4866                                  IOCTL_CHANGEABLE?	EQU	8
  4867                                  IOCTL_DeviceLocOrRem?	EQU	9
  4868                                  IOCTL_HandleLocOrRem?	EQU	0Ah   ;10
  4869                                  IOCTL_SHARING_RETRY	EQU	0Bh   ;11
  4870                                  GENERIC_IOCTL_HANDLE	EQU	0Ch   ;12
  4871                                  GENERIC_IOCTL		EQU	0Dh   ;13
  4872                                  IOCTL_GET_DRIVE_MAP 	EQU	0Eh   ;14
  4873                                  IOCTL_SET_DRIVE_MAP	EQU	0Fh   ;15
  4874                                  IOCTL_QUERY_HANDLE	EQU	10h   ;16
  4875                                  IOCTL_QUERY_BLOCK	EQU	11h   ;17
  4876                                  
  4877                                  ; GENERIC IOCTL SUB-FUNCTIONS
  4878                                  RAWIO			EQU	8
  4879                                  
  4880                                  ; RAWIO SUB-FUNCTIONS
  4881                                  GET_DEVICE_PARAMETERS	EQU	60H
  4882                                  SET_DEVICE_PARAMETERS	EQU	40H
  4883                                  READ_TRACK		EQU	61H
  4884                                  WRITE_TRACK		EQU	41H
  4885                                  VERIFY_TRACK		EQU	62H
  4886                                  FORMAT_TRACK		EQU	42H
  4887                                  GET_MEDIA_ID		EQU	66h	;AN000;AN003;changed from 63h
  4888                                  SET_MEDIA_ID		EQU	46h	;AN000;AN003;changed from 43h
  4889                                  GET_ACCESS_FLAG 	EQU	67h	;AN002;AN003;Unpublished function.Changed from 64h
  4890                                  SET_ACCESS_FLAG 	EQU	47h	;AN002;AN003;Unpublished function.Changed from 44h
  4891                                  SENSE_MEDIA_TYPE	EQU	68H	;Added for 5.00
  4892                                  
  4893                                  
  4894                                  ; SPECIAL FUNCTION FOR GET DEVICE PARAMETERS
  4895                                  BUILD_DEVICE_BPB	EQU	000000001B
  4896                                  
  4897                                  ; SPECIAL FUNCTIONS FOR SET DEVICE PARAMETERS
  4898                                  INSTALL_FAKE_BPB	EQU	000000001B
  4899                                  ONLY_SET_TRACKLAYOUT	EQU	000000010B
  4900                                  TRACKLAYOUT_IS_GOOD	EQU	000000100B
  4901                                  
  4902                                  ; SPECIAL FUNCTION FOR FORMAT TRACK
  4903                                  STATUS_FOR_FORMAT	EQU	000000001B
  4904                                  DO_FAST_FORMAT		EQU	000000010B ;AN001;
  4905                                  ; CODES RETURNED FROM FORMAT STATUS CALL
  4906                                  FORMAT_NO_ROM_SUPPORT	EQU	000000001B
  4907                                  FORMAT_COMB_NOT_SUPPORTED EQU	000000010B
  4908                                  
  4909                                  ; DEVICETYPE VALUES
  4910                                  MAX_SECTORS_IN_TRACK	EQU	63	; MAXIMUM SECTORS ON A DISK.(Was 40 in DOS 3.2)
  4911                                  DEV_5INCH		EQU	0
  4912                                  DEV_5INCH96TPI		EQU	1
  4913                                  DEV_3INCH720KB		EQU	2
  4914                                  DEV_8INCHSS		EQU	3
  4915                                  DEV_8INCHDS		EQU	4
  4916                                  DEV_HARDDISK		EQU	5
  4917                                  DEV_OTHER		EQU	7
  4918                                  ;DEV_3INCH1440KB	EQU	7
  4919                                  DEV_3INCH2880KB		EQU	9
  4920                                  ; Retro DOS v2.0 - 26/03/2018
  4921                                  ;;DEV_TAPE		EQU	6
  4922                                  ;;DEV_ERIMO		EQU	8
  4923                                  ;DEV_3INCH2880KB	EQU	9
  4924                                  DEV_3INCH1440KB		EQU	10
  4925                                  
  4926                                  ;MAX_DEV_TYPE		EQU	9	; MAXIMUM DEVICE TYPE THAT WE
  4927                                  					; CURRENTLY SUPPORT.
  4928                                  MAX_DEV_TYPE		EQU	10
  4929                                  
  4930                                  struc A_SECTORTABLE
  4931 00000000 ????                    .ST_SECTORNUMBER:	resw	1
  4932 00000002 ????                    .ST_SECTORSIZE:		resw	1
  4933                                  .size:
  4934                                  endstruc
  4935                                  
  4936                                  ; MSDOS 6.0 - BPB.INC - 1991
  4937                                  ; ####
  4938                                  ;**	BIOS PARAMETER BLOCK DEFINITION
  4939                                  ;
  4940                                  ;	The BPB contains information about the disk structure. It dates
  4941                                  ;	back to the earliest FAT systems and so FAT information is
  4942                                  ;	intermingled with physical driver information.
  4943                                  ;
  4944                                  ;	A boot sector contains a BPB for its device; for other disks
  4945                                  ;	the driver creates a BPB. DOS keeps copies of some of this
  4946                                  ;	information in the DPB.
  4947                                  ;
  4948                                  ;	The BDS structure contains a BPB within it.
  4949                                  ;
  4950                                  
  4951                                  struc A_BPB
  4952 00000000 ????                    .BPB_BYTESPERSECTOR:	resw	1
  4953 00000002 ??                      .BPB_SECTORSPERCLUSTER:	resb	1
  4954 00000003 ????                    .BPB_RESERVEDSECTORS:	resw	1
  4955 00000005 ??                      .BPB_NUMBEROFFATS:	resb	1
  4956 00000006 ????                    .BPB_ROOTENTRIES: 	resw	1
  4957 00000008 ????                    .BPB_TOTALSECTORS:	resw	1
  4958 0000000A ??                      .BPB_MEDIADESCRIPTOR:	resb	1
  4959 0000000B ????                    .BPB_SECTORSPERFAT:	resw	1
  4960 0000000D ????                    .BPB_SECTORSPERTRACK:	resw	1
  4961 0000000F ????                    .BPB_HEADS:		resw	1
  4962 00000011 ????                    .BPB_HIDDENSECTORS:	resw	1
  4963 00000013 ????                    			resw	1
  4964 00000015 ????                    .BPB_BIGTOTALSECTORS:	resw	1
  4965 00000017 ????                    			resw	1
  4966 00000019 ????????????            			resb	6	; NOTE:  many times these
  4967                                  ;					; 	 6 bytes are omitted
  4968                                  ;					;	 when BPB manipulations
  4969                                  ;					;	 are performed!
  4970                                  .size:
  4971                                  endstruc
  4972                                  ; ####
  4973                                  
  4974                                  struc A_DEVICEPARAMETERS
  4975 00000000 ??                      .DP_SPECIALFUNCTIONS:	resb	1
  4976 00000001 ??                      .DP_DEVICETYPE:		resb	1
  4977 00000002 ????                    .DP_DEVICEATTRIBUTES:	resw	1
  4978 00000004 ????                    .DP_CYLINDERS:		resw	1
  4979 00000006 ??                      .DP_MEDIATYPE:		resb	1
  4980 00000007 <res 1Fh>               .DP_BPB:		resb	A_BPB.size
  4981 00000026 ????                    .DP_TRACKTABLEENTRIES:	resw	1
  4982 00000028 <res FCh>               .DP_SECTORTABLE:	resb	MAX_SECTORS_IN_TRACK * A_SECTORTABLE.size
  4983                                  endstruc
  4984                                  
  4985                                  struc A_TRACKREADWRITEPACKET
  4986 00000000 ??                      .TRWP_SPECIALFUNCTIONS:	resb	1
  4987 00000001 ????                    .TRWP_HEAD:		resw	1
  4988 00000003 ????                    .TRWP_CYLINDER:		resw	1
  4989 00000005 ????                    .TRWP_FIRSTSECTOR:	resw	1
  4990 00000007 ????                    .TRWP_SECTORSTOREADWRITE: resw	1
  4991 00000009 ????????                .TRWP_TRANSFERADDRESS:	resd	1
  4992                                  endstruc
  4993                                  
  4994                                  ;AN001; - FP_TRACKCOUNT is only meaningful when FP_SPECIALFUNCTIONS bit 1 = 1.
  4995                                  struc A_FORMATPACKET
  4996 00000000 ??                      .FP_SPECIALFUNCTIONS:	resb	1  ; db ?
  4997 00000001 ????                    .FP_HEAD: 		resw	1  ; dw ? 
  4998 00000003 ????                    .FP_CYLINDER:		resw	1  ; dw ?
  4999 00000005 ????                    .FP_TRACKCOUNT:		resw	1  ; dw 1 ; !
  5000                                  endstruc
  5001                                  
  5002                                  struc A_VERIFYPACKET
  5003 00000000 ??                      .VP_SPECIALFUNCTIONS:	resb	1
  5004 00000001 ????                    .VP_HEAD: 		resw	1
  5005 00000003 ????                    .VP_CYLINDER:		resw	1
  5006                                  endstruc
  5007                                  
  5008                                  struc A_MEDIA_ID_INFO
  5009 00000000 ????                    .MI_LEVEL:		resw	1  ; dw 0 ; !		;J.K. 87 Info. level
  5010 00000002 ????????                .MI_SERIAL:		resd	1  ; dd ?		;J.K. 87 Serial #
  5011 00000006 <res Bh>                .MI_LABEL:		resb	11 ; db 11 DUP (' ') ;!	;J.K. 87 volume label
  5012 00000011 ????????????????        .MI_SYSTEM:		resb 	8  ; db 8 DUP (' ')  ;!	;J.K. 87 File system type
  5013                                  endstruc
  5014                                  
  5015                                  struc A_DISKACCESS_CONTROL	   ;AN002; Unpublished function. Only for Hard file.
  5016 00000000 ??                      .DAC_SPECIALFUNCTIONS:	resb 	1  ; db 0 ; ! ;AN002; Always 0
  5017 00000001 ??                      .DAC_ACCESS_FLAG: 	resb 	1  ; db 0 ; ! 
  5018                                  				   ; Non Zero - allow disk I/O to unformatted hard file
  5019                                  endstruc			   ; 0 - Disallow disk I/O to unformatted hard file
  5020                                  
  5021                                  
  5022                                  struc A_MEDIA_SENSE			; Media sense structure added 5.00
  5023 00000000 ??                      .MS_ISDEFAULT:		resb	1	; If 1 type returned is drv default
  5024 00000001 ??                      .MS_DEVICETYPE:		resb	1	; Drive type 
  5025 00000002 ??                      .MS_RESERVED1:		resb	1	; RESERVED
  5026 00000003 ??                      .MS_RESERVED2:		resb 	1	; RESERVED 
  5027                                  endstruc
  5028                                  
  5029                                  ;********************************;*
  5030                                  ; CHARACTER DEVICES (PRINTERS)	 ;*
  5031                                  ;********************************;*
  5032                                  
  5033                                  ;RAWIO SUB-FUNCTIONS
  5034                                  GET_RETRY_COUNT 	EQU	65H
  5035                                  SET_RETRY_COUNT 	EQU	45H
  5036                                  
  5037                                  struc A_RETRYCOUNT
  5038 00000000 ????                    .RC_COUNT:		resw 1
  5039                                  endstruc
  5040                                  
  5041                                  ;********************************;*		;J.K. 4/29/86
  5042                                  ; CHARACTER DEVICES (SCREEN)	 ;*
  5043                                  ;********************************;*		;J.K. 4/29/86
  5044                                  ;
  5045                                  ;SC_MODE_INFO	 struc
  5046                                  ;SC_INFO_LENGTH 	 DW	 9
  5047                                  ;SC_MODE		 DB	 0
  5048                                  ;SC_COLORS		 DW	 0
  5049                                  ;SC_WIDTH		 DW	 0
  5050                                  ;SC_LENGTH		 DW	 0
  5051                                  ;SC_MODE_INFO	 ends
  5052                                  ;
  5053                                  ;SC_INFO_PACKET_LENGTH	 EQU	 9		 ;LENGTH OF THE INFO PACKET.
  5054                                  
  5055                                  ;SUBFUNCTIONS FOR CON$GENIOCTL
  5056                                  ;GET_SC_MODE		 EQU	 60h
  5057                                  ;SET_SC_MODE		 EQU	 40h
  5058                                  ;The following subfunctions are reserved for installable CODE PAGE switch
  5059                                  ;console devices. - J.K. 4/29/86
  5060                                  ;Get_active_codepage	 equ	 6Ah
  5061                                  ;Invoke_active_codepage  equ	 4Ah
  5062                                  ;Start_designate_codepage equ	 4Ch
  5063                                  ;End_designate_codepage  equ	 4Dh
  5064                                  ;Get_list_of_designated_codepage equ 6Bh
  5065                                  ;J.K. 4/29/86 *** End of Con$genioctl equates & structures
  5066                                  
  5067                                  ; 28/05/2018 - Retro DOS v3.0
  5068                                  
  5069                                  ;
  5070                                  ; Generic IOCTL dispatch tables
  5071                                  ;
  5072                                  IOReadJumpTable: 
  5073 00001181 02                      		db	2
  5074 00001182 [D012]                  		dw	GetDeviceParameters
  5075 00001184 [3E15]                  		dw	ReadTrack
  5076 00001186 [1915]                  		dw	VerifyTrack
  5077                                  
  5078                                  IOWriteJumpTable:
  5079 00001188 02                      		db	2
  5080 00001189 [0C13]                  		dw	SetDeviceParameters
  5081 0000118B [4615]                  		dw	WriteTrack
  5082 0000118D [7714]                  		dw	FormatTrack
  5083                                  
  5084                                  		; 25/08/2022 - IBMBIO.COM (IBMBIO33.IDB) address compatibility!
  5085                                  SectorsPerTrack:
  5086 0000118F 0F00                    		dw      15
  5087                                  
  5088                                  MAX_SECTORS_CURR_SUP	EQU	63	; CURRENT MAXIMUM SEC/TRK THAT	  ;3.30
  5089                                  					; WE SUPPORT (Was 40 in DOS 3.2)  ;3.30
  5090                                  ;
  5091                                  ; TrackTable is an area for saving information passwd by the set device
  5092                                  ; parameter function for laster use my Read/Write/Format/Verify.
  5093                                  ;
  5094                                  ; Entries are 4-Tuples (C,H,R,N) where:
  5095                                  ;   C = Cylinder, H = Head, R = Sector, N = Bytes/Sector
  5096                                  ;
  5097                                  ; fixed for bug0016 - initialised table with values - sp
  5098                                  TrackTable:
  5099 00001191 00000102                		db	0,0,1,2
  5100 00001195 00000202                		db	0,0,2,2
  5101 00001199 00000302                		db	0,0,3,2
  5102 0000119D 00000402                		db	0,0,4,2
  5103 000011A1 00000502                		db	0,0,5,2
  5104 000011A5 00000602                		db	0,0,6,2
  5105 000011A9 00000702                		db	0,0,7,2
  5106 000011AD 00000802                		db	0,0,8,2
  5107 000011B1 00000902                		db	0,0,9,2
  5108 000011B5 00000A02                		db	0,0,10,2
  5109 000011B9 00000B02                		db	0,0,11,2
  5110 000011BD 00000C02                		db	0,0,12,2
  5111 000011C1 00000D02                		db	0,0,13,2
  5112 000011C5 00000E02                		db	0,0,14,2
  5113 000011C9 00000F02                		db	0,0,15,2
  5114 000011CD 00001002                		db	0,0,16,2
  5115 000011D1 00001102                		db	0,0,17,2
  5116 000011D5 00001202                		db	0,0,18,2
  5117 000011D9 00<rep B4h>                             times (MAX_SECTORS_CURR_SUP*A_SECTORTABLE.size)-($-TrackTable) db 0
  5118                                  
  5119                                  		; 25/08/2022 - IBMBIO.COM (IBMBIO33.IDB) address compatibility!
  5120                                  ;SectorsPerTrack:
  5121                                  ;		dw      15
  5122                                  
  5123                                  ; This is a real ugly place to put this
  5124                                  ; it should really go in the BDS
  5125 0000128D 00                      mediaType:	db	0
  5126                                  
  5127                                  Media_Set_For_Format:
  5128 0000128E 00                      		db	0		; 1 if we have done an Int 13 Set Media
  5129                                  					; Type for Format call
  5130                                  ; Rev 3.30 *****************************************************************
  5131                                  Had_Format_Error:
  5132 0000128F 00                      		db	0		; 1 if the previous format operation
  5133                                  					; failed.
  5134                                  Dsk_time_out_Err	equ	80h	; Time out error (No media present).
  5135                                  Dsk_change_line_Err	equ	6h	; Change line error
  5136                                  Dsk_illegal_combination equ	0Ch	; Return code of ah=18h function.
  5137                                  ; Rev 3.30 *****************************************************************
  5138                                  
  5139                                  ;
  5140                                  ; TempDPT is a temporary place to hold a pointer to the original
  5141                                  ; Disk Parameter Table while DPT is made to point to a table returned
  5142                                  ; by a BIOS call.  A value of -1 indicateds no value has been saved.
  5143                                  ;
  5144                                  
  5145                                  TempDPT:
  5146 00001290 FFFFFFFF                		DD	-1
  5147                                  
  5148                                  ;
  5149                                  ; Generic$IOCTL:
  5150                                  ;    Perform Generic IOCTL request
  5151                                  ;    Input:
  5152                                  ;	al	- unit number
  5153                                  ;    Output:
  5154                                  ;	if carry set then al contains error code
  5155                                  ;
  5156                                  
  5157                                  GENERIC$IOCTL:
  5158 00001294 2EC41E[B800]            		les	bx,[cs:PTRSAV]		; es:bx points to request header.
  5159 00001299 E859F9                  		call	SETDRIVE		; ds:di points to BDS for drive.
  5160                                  ;
  5161                                  ; At this point:
  5162                                  ;    es:bx - points to the Request Header
  5163                                  ;    ds:di points to the BDS for the drive
  5164                                  ;
  5165 0000129C 26807F0D08              		cmp	byte [es:bx+IOCTL_REQ.MAJORFUNCTION],RAWIO
  5166 000012A1 752A                    		jne	IOCTL_Func_Err
  5167 000012A3 268A470E                		mov	al,[es:bx+IOCTL_REQ.MINORFUNCTION]
  5168 000012A7 BE[8111]                		mov	si,IOReadJumpTable
  5169 000012AA A820                    		test	al,GEN_IOCTL_FN_TST	; Test of req. function
  5170 000012AC 7503                    		jnz	short NotGenericIoctlWrite	;   function is a Read.
  5171 000012AE BE[8811]                		mov	si,IOWriteJumpTable
  5172                                  NotGenericIoctlWrite:
  5173 000012B1 240F                    		and	al,0FH
  5174 000012B3 2E3A04                  		cmp	al,[cs:si]
  5175 000012B6 7715                    		ja	short IOCTL_Func_Err
  5176 000012B8 98                      		cbw
  5177 000012B9 D1E0                    		shl	ax, 1
  5178 000012BB 46                      		inc	si
  5179 000012BC 01C6                    		add	si,ax
  5180 000012BE 26C45F13                		les	bx,[es:bx+IOCTL_REQ.GENERICIOCTL_PACKET]
  5181 000012C2 2EFF14                  		call	[cs:si]
  5182 000012C5 7203                    		jc	short FailGeneric$IOCTL
  5183 000012C7 E982F3                  		jmp	EXIT
  5184                                  
  5185                                  FailGeneric$IOCTL:
  5186 000012CA E972F3                  		jmp	ERR$EXIT
  5187                                  
  5188                                  IOCTL_Func_Err:
  5189 000012CD E965F3                  		jmp	CMDERR
  5190                                  
  5191                                  ;
  5192                                  ; GetDeviceParameters:
  5193                                  ;
  5194                                  ; Input: DS:DI points to BDS for drive
  5195                                  ;	 ES:BX points to device parameter packet
  5196                                  ;
  5197                                  
  5198                                  GetDeviceParameters:
  5199                                  ; Copy info from BDS to the device parameters packet
  5200 000012D0 8A4528                  		mov	al,[DI+BDS.FormFactor]
  5201 000012D3 26884701                		mov	[es:bx+A_DEVICEPARAMETERS.DP_DEVICETYPE], al
  5202 000012D7 8B4529                  		mov	ax,[DI+BDS.Flags]
  5203 000012DA 83E003                  		and	ax,fNon_Removable+fChangeline	; mask off other bits
  5204 000012DD 26894702                		mov	[es:bx+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES], ax
  5205 000012E1 8B452B                  		mov	ax,[DI+BDS.cCyln]
  5206 000012E4 26894704                		mov	[es:bx+A_DEVICEPARAMETERS.DP_CYLINDERS], ax
  5207                                  
  5208                                  ; Set media type to default
  5209 000012E8 30C0                    		xor	al, al
  5210 000012EA 26884706                		mov	[es:bx+A_DEVICEPARAMETERS.DP_MEDIATYPE],al
  5211                                  
  5212                                  ; Copy recommended BPB
  5213 000012EE 8D752D                  		lea	si, [DI+BDS.RBytePerSec]
  5214                                  		;test	byte [es:bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],BUILD_DEVICE_BPB
  5215 000012F1 26F60701                		test	byte [es:bx],BUILD_DEVICE_BPB ; 05/07/2019
  5216 000012F5 740B                    		jz	short use_BPB_present
  5217                                  ; Get the correct disk in the drive
  5218 000012F7 E845F9                  		call	CHECKSINGLE
  5219                                  ; Build the BPB from scratch
  5220 000012FA E854F7                  		call	GETBP
  5221 000012FD 720C                    		jc	short Get_Parm_Ret
  5222 000012FF 8D7506                  		lea	si,[DI+BDS.BytePerSec]
  5223                                  use_BPB_present:
  5224 00001302 8D7F07                  		lea	di,[bx+A_DEVICEPARAMETERS.DP_BPB]
  5225 00001305 B91300                  		mov	cx,BPB_TYPE.size	; for now use 'small' BPB
  5226 00001308 F3A4                    		rep	movsb
  5227 0000130A F8                      		clc
  5228                                  Get_Parm_Ret:
  5229 0000130B C3                      		retn
  5230                                  
  5231                                  ;
  5232                                  ; SetDeviceParameters:
  5233                                  ;
  5234                                  ; Input: DS:DI points to BDS for drive
  5235                                  ;	 ES:BX points to device parameter packet
  5236                                  ;
  5237                                  
  5238                                  SetDeviceParameters:
  5239                                  
  5240                                  ; Make sure the fChanged_By_Format flag gets set to kick DOS into looking at
  5241                                  ; the BPB
  5242 0000130C 814D294001              		or	word [DI+BDS.Flags],fChanged_By_Format | fChanged
  5243                                  		;test	byte [es:bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],ONLY_SET_TRACKLAYOUT
  5244 00001311 26F60702                		test	byte [es:bx],ONLY_SET_TRACKLAYOUT ; 05/07/2019
  5245                                  		;;jz	short SetDevParm_1
  5246                                  		;;jmp	short SetTrackTable		; Originally TrackLayout
  5247 00001315 756D                    		jnz	short SetTrackTable ; 05/07/2019
  5248                                  		; Temporary !
  5249                                  		; 25/08/2022 - IBMBIO.COM (IBMBIO33.IDB) address compatibility!
  5250                                  		;jz	short SetDevParm_1
  5251                                  		;jmp	short SetTrackTable		; Originally TrackLayout	
  5252                                  		;nop 
  5253                                  
  5254                                  SetDevParm_1:
  5255                                  ; Copy info from the device parameters packet to BDS
  5256 00001317 268A4701                		mov	al,[es:bx+A_DEVICEPARAMETERS.DP_DEVICETYPE]
  5257 0000131B 884528                  		mov	[DI+BDS.FormFactor], al
  5258                                  
  5259 0000131E 268B4704                		mov	ax,[es:bx+A_DEVICEPARAMETERS.DP_CYLINDERS]
  5260 00001322 89452B                  		mov	[DI+BDS.cCyln],ax
  5261                                  
  5262                                  ; If change line is not loaded then ignore changeling flag
  5263 00001325 268B4702                		mov	ax,[es:bx+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES]
  5264 00001329 2E803E[8601]00          		cmp	byte [cs:fHave96],0
  5265 0000132F 7503                    		jnz	short Have_Change
  5266 00001331 83E0FD                  		and	ax,~fChangeline
  5267                                  Have_Change:
  5268                                  ; ignore all bits except Non_removable and Changeline
  5269 00001334 83E003                  		and	ax,fNon_Removable | fChangeline
  5270 00001337 8B4D29                  		mov	cx,[DI+BDS.Flags]
  5271 0000133A 83E1F4                  		and	cx,~(fNon_Removable | fChangeline | GOOD_TRACKLAYOUT)
  5272 0000133D 09C8                    		or	ax,cx
  5273 0000133F 894529                  		mov	[DI+BDS.Flags],ax
  5274                                  
  5275                                  ; Set media type
  5276 00001342 268A4706                		mov	al,[es:bx+A_DEVICEPARAMETERS.DP_MEDIATYPE]
  5277 00001346 2EA2[8D12]              		mov	[cs:mediaType],al
  5278                                  ; the media changed (maybe) so we will have to do a SetDASD the next time
  5279                                  ; we format a track
  5280 0000134A 814D298000              		or	word [DI+BDS.Flags],SET_DASD_true
  5281                                  
  5282 0000134F 1E                      		push	ds
  5283 00001350 57                      		push	di
  5284 00001351 06                      		push	es
  5285 00001352 53                      		push	bx
  5286                                  ; Figure out what we are supposed to do with the BPB
  5287                                  
  5288                                  ; Were we asked to install a fake BPB?
  5289                                  		;test	byte [es:bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],INSTALL_FAKE_BPB
  5290 00001353 26F60701                		test	byte [es:bx],INSTALL_FAKE_BPB ; 05/07/2019
  5291 00001357 7515                    		jnz	short InstallFakeBPB
  5292                                  
  5293                                  ; Were we returning a fake BPB when asked to build a BPB?
  5294 00001359 F745290400              		test	word [DI+BDS.Flags],RETURN_FAKE_BPB
  5295 0000135E 7406                    		jz	short InstallRecommendedBPB
  5296                                  
  5297                                  ; We were returning a fake BPB but we can stop now
  5298 00001360 836529FB                		and	word[DI+BDS.Flags],~RETURN_FAKE_BPB
  5299 00001364 EB17                    		jmp	short DoneWithBPBstuff
  5300                                  
  5301                                  		; Temporary !
  5302                                  		; 25/08/2022 - IBMBIO.COM (IBMBIO33.IDB) address compatibility!
  5303                                  		;nop
  5304                                  		;nop
  5305                                  		;nop
  5306                                  
  5307                                  InstallRecommendedBPB:
  5308 00001366 B91F00                  		mov	cx,A_BPB.size
  5309 00001369 8D7D2D                  		lea	di,[DI+BDS.RBytePerSec]
  5310 0000136C EB06                    		jmp	short CopyTheBPB
  5311                                  
  5312                                  InstallFakeBPB:
  5313 0000136E B91300                  		mov	cx,BPB_TYPE.size    ; move 'smaller' BPB
  5314 00001371 8D7D06                  		lea	di,[DI+BDS.BytePerSec]
  5315                                  CopyTheBPB:
  5316 00001374 8D7707                  		lea	si,[bx+A_DEVICEPARAMETERS.DP_BPB]
  5317                                  ; exchange es and ds
  5318 00001377 06                      		push	es
  5319 00001378 1E                      		push	ds
  5320 00001379 07                      		pop	es
  5321 0000137A 1F                      		pop	ds
  5322                                  
  5323 0000137B F3A4                    		rep	movsb
  5324                                  
  5325                                  DoneWithBPBstuff:
  5326 0000137D E8AC03                  		call	RestoreOldDPT
  5327 00001380 5B                      		pop	bx
  5328 00001381 07                      		pop	es
  5329 00001382 5F                      		pop	di
  5330 00001383 1F                      		pop	ds
  5331                                  
  5332                                  ; Set up track table (if neccessary)
  5333                                  SetTrackTable:
  5334 00001384 268B4F26                		mov	cx,[es:bx+A_DEVICEPARAMETERS.DP_TRACKTABLEENTRIES]
  5335 00001388 2E890E[8F11]            		mov	[cs:SectorsPerTrack],cx
  5336 0000138D 836529F7                		and	word [DI+BDS.Flags],~GOOD_TRACKLAYOUT
  5337                                  		;test	byte [es:bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],TRACKLAYOUT_IS_GOOD
  5338 00001391 26F60704                		test	byte [es:bx],TRACKLAYOUT_IS_GOOD ; 05/07/2019
  5339 00001395 7404                    		jz	short UglyTrackLayout
  5340 00001397 834D2908                		or	word [DI+BDS.Flags],GOOD_TRACKLAYOUT
  5341                                  
  5342                                  UglyTrackLayout:
  5343 0000139B 83F93F                  		cmp	cx,MAX_SECTORS_IN_TRACK
  5344 0000139E 7728                    		ja	short TooManySectorsPerTrack
  5345 000013A0 E324                    		jcxz	SectorInfoSaved		; if no value don't copy table
  5346                                  						; save information in the track table
  5347                                  	
  5348                                  		; 25/08/2022
  5349                                  
  5350 000013A2 53                      		push	BX			; get ES:BX to point to sector
  5351 000013A3 83C328                  		add	BX,A_DEVICEPARAMETERS.DP_SECTORTABLE ;  table in Device param. struct
  5352                                  		
  5353 000013A6 57                      		push	DI
  5354 000013A7 BF[9311]                		mov	DI,TrackTable + 2	; CS:DI now points to sector id
  5355                                                  				; of the first track table entry
  5356 000013AA 50                      		push	AX			; preserve AX value
  5357                                  		
  5358                                  						; For MAX_SECTORS_IN_TRACK
  5359                                  TrackLoop:					;   DO:
  5360                                  		;mov	AX,[ES:BX]		;   get sector number
  5361                                  		;mov	[CS:DI],AL		;   save in track table
  5362                                  		
  5363 000013AB 268B4702                	        mov	AX,[ES:BX+2]		;   get sector size
  5364 000013AF E83B02                  	        call	SectorSizeToSectorIndex ;   convert size to index number
  5365                                  		;mov	[CS:DI+1],AL		;   save size in track table
  5366                                  		; 25/08/2022
  5367 000013B2 88C4                    		mov	ah,al
  5368 000013B4 268A07                  		mov	al,[es:bx]	
  5369 000013B7 2E8905                  		mov	[cs:di],ax		
  5370                                  
  5371                                  		;add	BX,A_SECTORTABLE.size	;   advance pointers to next
  5372                                  		;add	DI,A_SECTORTABLE.size	;   entries
  5373                                  		; 25/08/2022
  5374 000013BA B80400                  		mov	ax,A_SECTORTABLE.size
  5375 000013BD 01C3                    		add	bx,ax
  5376 000013BF 01C7                    		add	di,ax
  5377 000013C1 E0E8                    		loopnz	TrackLoop		; End FOR
  5378                                  		
  5379 000013C3 58                      		pop	AX 			; restore the saved values
  5380 000013C4 5F                      		pop	DI
  5381 000013C5 5B                      		pop	BX
  5382                                  
  5383                                  SectorInfoSaved:
  5384 000013C6 F8                      		clc
  5385 000013C7 C3                      		retn
  5386                                  
  5387                                  TooManySectorsPerTrack:
  5388 000013C8 B00C                    		mov	al, 0Ch
  5389 000013CA F9                      		stc
  5390 000013CB C3                      		retn
  5391                                  
  5392                                  ;
  5393                                  ; FormatStatus:
  5394                                  ; If SpecialFunction byte is 1, then this routine is called to see if there is
  5395                                  ; ROM support for the combination of sec/trk and # of cyln, and if the
  5396                                  ; combination is legal.
  5397                                  ;
  5398                                  ; Input: DS:DI points to BDS for drive
  5399                                  ;	 ES:BX points to format packet
  5400                                  ;
  5401                                  ; Output:
  5402                                  ;	SpecialFunction byte set to:
  5403                                  ;		0 - ROM support + legal combination
  5404                                  ;		1 - No ROM support
  5405                                  ;		2 - Illegal Combination
  5406                                  ;		3 - No media present, ROM support exists but can't determine
  5407                                  ;		    media
  5408                                  ;	Carry cleared.
  5409                                  ;
  5410                                  ;	For format track:
  5411                                  ;		Carry set if error
  5412                                  ;
  5413                                  ;
  5414                                  ;  Flags also may be altered. All other registers preserved.
  5415                                  ;  If the call to ROM returns no error, then the current DPT is "replaced" by
  5416                                  ;  the one returned by the ROM. This is done by changing the pointer in [DPT]
  5417                                  ;  to the one returned. The original pointer to the disk base table is stored
  5418                                  ;  in TempDPT, until it is restored.
  5419                                  ;
  5420                                  ;
  5421                                  FormatStatus:
  5422 000013CC 51                      		push	cx
  5423 000013CD 52                      		push	dx
  5424                                  			; Are we here because of a format err
  5425 000013CE 2E803E[8F12]01          		cmp	byte [cs:Had_Format_Error],1
  5426 000013D4 7411                    		je	short Fstat01
  5427 000013D6 2E803E[8E12]01          		cmp	byte [cs:Media_Set_For_Format],1
  5428 000013DC 7503                    		jnz	short FStat03
  5429 000013DE E99200                  		jmp	Stat_Ret
  5430                                  FStat03:
  5431 000013E1 2EC606[8E12]00          		mov	byte [cs:Media_Set_For_Format],0
  5432                                  ;
  5433                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  5434                                  ;			modification - sp001
  5435                                  ;	
  5436                                  ;	remove check for new rom from here. we shall just assume the
  5437                                  ;	prescence of the new rom and go ahead and issue the int13 call
  5438                                  ;	anyway. later on if there is an error we shall check this to
  5439                                  ;	see if it is there because of lack of rom support, in which
  5440                                  ;	case the appropriate error will be indicated by setting al to 1
  5441                                  ;
  5442                                  ;	I would ideally like to see the new rom testing code shifted to
  5443                                  ;	msinit and this code reintroduced. however for this version we
  5444                                  ;	are aiming to stick close to the IBM variety. 
  5445                                  ;
  5446                                  ;	More changes to support this commenting out will follow. All
  5447                                  ;	will be marked as modification sp001
  5448                                  ;
  5449                                  ;	mov	al,1			; No ROM support available error code
  5450                                  ;	test	byte ptr cs:[NEW_ROM],1
  5451                                  ;	jnz	short FStat01
  5452                                  ;	jmp	Stat_Ret
  5453                                  Fstat01:
  5454 000013E7 1E                      		push	ds
  5455 000013E8 56                      		push	si
  5456                                  
  5457 000013E9 31C0                    		xor	ax,ax
  5458 000013EB 8ED8                    		mov	ds,ax
  5459 000013ED C5367800                		lds	si,[DSKADR]		; DS:SI := pDPT
  5460                                  
  5461 000013F1 2E8936[2602]            		mov	word [cs:DPT],si	; cs:[DPT] := pDPT
  5462 000013F6 2E8C1E[2802]            		mov	word [cs:DPT+2],ds
  5463                                  
  5464 000013FB 5E                      		pop	si
  5465 000013FC 1F                      		pop	ds
  5466                                  
  5467                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  5468                                  ;			modification sp001
  5469                                  ;	
  5470                                  ;	the following instruction introduced for the new rom modification
  5471                                  ;
  5472 000013FD 2EC606[8A01]01          		mov	byte [cs:NEW_ROM],1		; assume new rom
  5473                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  5474 00001403 8B452B                  		mov	ax,[DI+BDS.cCyln]
  5475 00001406 8B4D13                  		mov	cx,[DI+BDS.SECLIM]
  5476                                  					; set up registers for format status call
  5477 00001409 80E403                  		and	AH,03h		; 'and' out unneeded track bits
  5478 0000140C D0CC                    		ror	AH,1		; get track and sector values correct
  5479 0000140E D0CC                    		ror	AH,1
  5480 00001410 08CC                    		or	AH,CL		; set sector number
  5481 00001412 86E0                    		xchg	AH,AL
  5482 00001414 89C1                    		mov	CX,AX
  5483 00001416 FECD                    		dec	CH
  5484 00001418 8A5504                  		mov	DL,[DI+BDS.DriveNum] ; get drive number
  5485 0000141B B418                    		mov	AH,18h	; set command to "sec/trk supported?"
  5486                                  
  5487 0000141D 06                      		push	es
  5488 0000141E 57                      		push	di
  5489 0000141F 1E                      		push	ds
  5490 00001420 56                      		push	si
  5491                                  
  5492 00001421 CD13                    		int	13h		; call rom bios to see if supported
  5493 00001423 7234                    		jc	short Format_Stat_Err ; if carry, combination is not supported
  5494                                  
  5495                                  				; ES:DI points to new Disk Base Table
  5496                                  				; combination for this drive replace
  5497                                  				; current (DskAdr) pointer with new one,
  5498                                  				; saving the old one in TempDPT.
  5499                                  
  5500                                  		; Are we here because of a format err
  5501 00001425 2E803E[8F12]01          		cmp	byte [cs:Had_Format_Error],1
  5502 0000142B 7508                    		jnz	short Fstat02	; Then skip the disk base setup
  5503                                  	
  5504 0000142D 30C0                    		xor	al,al			; Supported and OK
  5505 0000142F 2EA2[8F12]              		mov	[cs:Had_Format_Error],al ; Clear format error
  5506 00001433 EB3A                    		jmp	short Pop_Stat_Ret	; Back to work
  5507                                  Fstat02:
  5508 00001435 31C0                    		xor	ax,ax
  5509 00001437 8ED8                    		mov	ds,ax
  5510 00001439 C5367800                		lds	si,[DSKADR]	; DS:SI := pDPT
  5511                                  
  5512 0000143D 2E8936[9012]            		mov	[cs:TempDPT],si
  5513 00001442 2E8C1E[9212]            		mov	[cs:TempDPT+2],ds ; Save pDPT
  5514                                  
  5515 00001447 893E7800                		mov	[DSKADR],DI 	; Setup New DPT returned by
  5516 0000144B 8C067A00                		mov	[DSKADR+2],ES	; ROM
  5517                                  
  5518 0000144F 2EC606[8E12]01          		mov	byte [cs:Media_Set_For_Format],1 ; set flag
  5519 00001455 30C0                    		xor	al,al		; Legal combination + ROM support code
  5520 00001457 EB16                    		jmp	short Pop_Stat_Ret
  5521                                  
  5522                                  Format_Stat_Err:
  5523 00001459 B003                    		mov	al,3			; Assume a time out
  5524 0000145B 80FC80                  		cmp	ah,Dsk_time_out_Err	; Was it a time out???
  5525 0000145E 740F                    		jz	short Pop_Stat_Ret	;  Yes - then done
  5526 00001460 FEC8                    		dec	al			; Assume an illegal comb.
  5527 00001462 80FC0C                  		cmp	ah,Dsk_illegal_combination ; Was it an illegal comb???
  5528 00001465 7408                    		jz	short Pop_Stat_Ret	; Yes - then done
  5529 00001467 FEC8                    		dec	al			; Assume No ROM Support	
  5530                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  5531                                  ;			modification sp001
  5532                                  ;
  5533                                  ;	the following instruction was introduced for the new_rom modification
  5534                                  ;
  5535 00001469 2EC606[8A01]00          		mov	byte [cs:NEW_ROM],0	; the old rom
  5536                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  5537                                  
  5538                                  ; Return result of status call
  5539                                  Pop_Stat_Ret:
  5540 0000146F 5E                      		pop	si
  5541 00001470 1F                      		pop	ds
  5542 00001471 5F                      		pop	di
  5543 00001472 07                      		pop	es
  5544                                  Stat_Ret:
  5545 00001473 F8                      		clc
  5546 00001474 5A                      		pop	dx
  5547 00001475 59                      		pop	cx
  5548 00001476 C3                      		retn
  5549                                  
  5550                                  
  5551                                  	; 25/08/2022
  5552                                  ;
  5553                                  ; FormatTrack:
  5554                                  ; If SpecialFunction byte is 1, then this is a status call to see if there is
  5555                                  ; ROM support for the combination of sec/trk and # of cyln, and if the
  5556                                  ; combination is legal. If SpecialFunction byte is 0, then format the track.
  5557                                  ;
  5558                                  ; Input: DS:DI points to BDS for drive
  5559                                  ;        ES:BX points to format packet
  5560                                  ;
  5561                                  ; Output:
  5562                                  ;       For status call:
  5563                                  ;       SpecialFunction byte set to:
  5564                                  ;               0 - ROM support + legal combination
  5565                                  ;               1 - No ROM support
  5566                                  ;               2 - Illegal Combination
  5567                                  ;		3 - no media present			;Rev 3.30
  5568                                  ;       Carry cleared.
  5569                                  ;
  5570                                  ;       For format track:
  5571                                  ;               Carry set if error
  5572                                  ;
  5573                                  ;
  5574                                  ;  Flags also may be altered. All other registers preserved.
  5575                                  ;  If the call to ROM returns no error, then the current DPT is "replaced" by
  5576                                  ;  the one returned by the ROM. This is done by changing the pointer in [DPT]
  5577                                  ;  to the one returned. The original pointer to the disk base table is stored
  5578                                  ;  in TempDPT, until it is restored.
  5579                                  ;
  5580                                  ;  This proc was changed to force a status for format call if we are on the
  5581                                  ;  new ROM.
  5582                                  ;
  5583                                  ;
  5584                                  FormatTrack:
  5585                                  		;test	byte [es:bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],STATUS_FOR_FORMAT
  5586 00001477 26F60701                		test	byte [es:bx],STATUS_FOR_FORMAT ; 05/07/2019
  5587 0000147B 7408                    		jz	short SkipStatusOnly
  5588                                  
  5589                                  Do_Status_Only:
  5590 0000147D E84CFF                  		call	FormatStatus
  5591                                  		;mov	[es:bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],al
  5592 00001480 268807                  		mov	[es:bx],al ; 05/07/2019
  5593                                  		;clc
  5594 00001483 F8                      		clc	; 05/07/2019 (CF=1 is possible from 'FormatStatus')
  5595 00001484 C3                      		retn
  5596                                  	
  5597                                  SkipStatusOnly:                       ; for a hard disk only do the verify
  5598 00001485 807D2805                        	cmp     byte [DI+BDS.FormFactor],DEV_HARDDISK
  5599 00001489 7503                    		jnz	short SkipVerify
  5600 0000148B E98700                  		jmp	DoVerifyTrack
  5601                                  SkipVerify:
  5602 0000148E 1E                      		push	ds			; Format a Track
  5603 0000148F 57                      		push	di
  5604 00001490 06                      		push	es
  5605 00001491 53                      		push	bx
  5606 00001492 E837FF                  		call	FormatStatus		; SetDASD checks media_set_for_format
  5607                                  		;;14/06/2018 (IBMDOS 3.3,IBMBIO.COM)
  5608                                  		;cmp	al,1
  5609                                  		;je	short NeedToSetDasd
  5610 00001495 3C03                    		cmp	al,3			; Check for time out
  5611                                  		;jne	short NoSetDasd
  5612 00001497 745D                    		je	short Format_Failed	; Fail if time out
  5613                                  		;jmp	short Format_Failed
  5614                                  NeedToSetDasd:
  5615 00001499 E86701                          	call    SetDASD
  5616                                  ;
  5617                                  ; Store Cylinder,Head in track table
  5618                                  ;                       ***** ASSUMPTION *******
  5619                                  ;       Since format requests on Fixed Media are converted to Verifies, we
  5620                                  ;       assume that we are formatting a floppy and hence have 255 or less
  5621                                  ;       tracks and heads. We therefore must change the Cylinder, Head data
  5622                                  ;       from the Request Packet Size to that of the TrackTable (see Int 13
  5623                                  ;       interface in IBM's Tech Ref.).
  5624                                  
  5625                                  ; Check to ensure correct disk is in drive
  5626                                  NoSetDasd:
  5627 0000149C E8A0F7                  		call    CHECKSINGLE
  5628                                  
  5629 0000149F 268B4703                		mov     ax,[es:bx+A_FORMATPACKET.FP_CYLINDER]
  5630 000014A3 2EA3[3202]              		mov     [cs:TRKNUM],ax
  5631 000014A7 268B4F01                		mov     cx,[es:bx+A_FORMATPACKET.FP_HEAD]
  5632 000014AB 2E880E[3102]            		mov     [cs:HDNUM],cl
  5633 000014B0 88CC                    		mov     ah,cl
  5634                                                          ; this next piece of code copies the correct head
  5635                                                          ; and cylinder numbers to the tracktable
  5636 000014B2 57                      		push    di			; preserve DI
  5637 000014B3 BF[9111]                		mov     di,TrackTable
  5638 000014B6 2E8B0E[8F11]            		mov     CX,[cs:SectorsPerTrack] ; get number of sectors
  5639 000014BB E308                            	jcxz    EndSetUpTrackTable	; if nothing to do skip down
  5640                                  SetUpLoop:
  5641 000014BD 2E8905                  		mov     [cs:di],AX		; set head and track value
  5642 000014C0 83C704                  		add     di,4			; move to next entry
  5643 000014C3 E0F8                    		loopnz  SetUpLoop		; loop if not done yet
  5644                                  EndSetUpTrackTable:
  5645 000014C5 5F                              	pop     di			; restore DI (BDS pointer)
  5646 000014C6 B90500                          	mov     cx,MAXERR		; Set up retry count
  5647                                  FormatRetry:
  5648 000014C9 51                      		push    cx
  5649                                                                  		; set up registers for format call to TO_ROM
  5650 000014CA 2EA1[8F11]              		mov     AX,[CS:SectorsPerTrack]	; set number of sectors
  5651 000014CE B405                    		mov     AH,ROMFormat
  5652 000014D0 0E                      		push    cs			; set ES:BX to point to
  5653 000014D1 07                      		pop     es			;    the track table
  5654 000014D2 BB[9111]                		mov     BX,TrackTable
  5655                                                                                  ; don't need to set CL on format
  5656 000014D5 E89701                  		call    To_ROM
  5657 000014D8 59                      		pop	cx
  5658 000014D9 7330                    		jnc	short FormatOk
  5659                                  		;pop     cx
  5660 000014DB 2EC606[8F12]01          		mov	byte [cs:Had_Format_Error],1	; Mark the error
  5661 000014E1 50                      		push	ax		
  5662 000014E2 51                      		push	cx			
  5663 000014E3 52                      		push	dx
  5664 000014E4 E87B01                  		call    ResetDisk
  5665 000014E7 E8E2FE                  		call	FormatStatus
  5666 000014EA 3C01                    		cmp	al,1
  5667 000014EC 7503                    		jnz	short While_Err
  5668 000014EE E81201                  		call	SetDASD 
  5669                                  While_Err:
  5670 000014F1 5A                      		pop	dx
  5671 000014F2 59                      		pop	cx
  5672 000014F3 58                      		pop	ax
  5673 000014F4 E2D3                    		loop    FormatRetry
  5674                                  
  5675                                  ; Format failed
  5676                                  Format_Failed:
  5677 000014F6 2EC606[8F12]01          		mov	byte [cs:Had_Format_Error],1	; Indicate a format error
  5678 000014FC 80FC06                  		cmp	ah,Dsk_change_line_Err		; Convert change line to
  5679 000014FF 7502                    		jne	short Map_Err			;   to time out.
  5680 00001501 B480                    		mov	ah,Dsk_time_out_Err
  5681                                  Map_Err:
  5682 00001503 E8D9F9                          	call    MAPERROR
  5683 00001506 5B                      		pop	bx
  5684 00001507 07                      		pop	es
  5685 00001508 5F                      		pop	di
  5686 00001509 1F                      		pop	ds
  5687 0000150A C3                      		retn
  5688                                  
  5689                                  FormatOk:
  5690 0000150B 2EC606[8F12]00          		mov	byte [cs:Had_Format_Error],0 ; Reset format error flag
  5691                                  		;pop     cx			; clean up stack after bailing out
  5692                                  						; of FormatRetry loop early
  5693 00001511 5B                      		pop	bx
  5694 00001512 07                      		pop	es
  5695 00001513 5F                      		pop	di
  5696 00001514 1F                      		pop	ds
  5697                                  DoVerifyTrack:
  5698 00001515 E80100                  	        call    VerifyTrack             ; Will reset DPT entries.
  5699 00001518 C3                      		retn
  5700                                  
  5701                                  ;
  5702                                  ; VerifyTrack:
  5703                                  ;
  5704                                  ; Input: DS:DI points to BDS for drive
  5705                                  ;	 ES:BX points to verify packet
  5706                                  ;
  5707                                  
  5708                                  VerifyTrack:
  5709 00001519 2EC606[1A02]04          		mov	byte [cs:RFLAG],ROMVerify
  5710 0000151F 268B4703                		mov	ax,[es:bx+A_VERIFYPACKET.VP_CYLINDER]
  5711 00001523 2EA3[2C02]              		mov	[cs:CURTRK], ax
  5712 00001527 268B4701                		mov	ax,[es:bx+A_VERIFYPACKET.VP_HEAD]
  5713                                  
  5714                                  ;	****** ASSUMPTION ******
  5715                                  ;	we assume that we have less than 256 heads, and that the Request
  5716                                  ;	Header Data Structure is unneccessarily big
  5717 0000152B 2EA2[2B02]              		mov	[cs:CURHD],al
  5718 0000152F 31C0                    		xor	ax,ax
  5719 00001531 2E8B0E[8F11]            		mov	cx,[cs:SectorsPerTrack]
  5720                                  ; Use 0:0 as the transfer address for verify
  5721 00001536 31DB                    		xor	bx, bx
  5722 00001538 8EC3                    		mov	es, bx
  5723 0000153A E83100                  		call	TrackIO
  5724 0000153D C3                      		retn
  5725                                  
  5726                                  ;
  5727                                  ; ReadTrack:
  5728                                  ;
  5729                                  ; Input: DS:DI points to BDS for drive
  5730                                  ;	 ES:BX points to read packet
  5731                                  ;
  5732                                  
  5733                                  ReadTrack:
  5734 0000153E 2EC606[1A02]02          		mov	byte [cs:RFLAG],ROMRead
  5735 00001544 EB08                    		jmp	short ReadWriteTrack
  5736                                  
  5737                                  ;
  5738                                  ; WriteTrack:
  5739                                  ;
  5740                                  ; Input: DS:DI points to BDS for drive
  5741                                  ;	 ES:BX points to write packet
  5742                                  ;
  5743                                  
  5744                                  WriteTrack:
  5745 00001546 2EC606[1A02]03          		mov	byte [cs:RFLAG],ROMWrite
  5746 0000154C EB00                    		jmp	short ReadWriteTrack
  5747                                  ;
  5748                                  ; ReadWriteTrack:
  5749                                  ;
  5750                                  ; Input:
  5751                                  ;    DS:DI points to BDS for drive
  5752                                  ;    ES:BX points to write packet
  5753                                  ;    RFLAG - 2 for read, 3 for write
  5754                                  ;
  5755                                  
  5756                                  ReadWriteTrack:
  5757 0000154E 268B4703                		mov	ax,[es:bx+A_TRACKREADWRITEPACKET.TRWP_CYLINDER]
  5758 00001552 2EA3[2C02]              		mov	[cs:CURTRK],ax
  5759 00001556 268B4701                		mov	ax,[es:bx+A_TRACKREADWRITEPACKET.TRWP_HEAD]
  5760                                  
  5761                                  ;	****** ASSUMPTION ******
  5762                                  ;	we assume that we have less than 256 heads, and that the Request
  5763                                  ;	Header Data Structure is unneccessarily big
  5764 0000155A 2EA2[2B02]              		mov	[cs:CURHD],al
  5765 0000155E 268B4705                		mov	ax,[es:bx+A_TRACKREADWRITEPACKET.TRWP_FIRSTSECTOR]
  5766 00001562 268B4F07                		mov	cx,[es:bx+A_TRACKREADWRITEPACKET.TRWP_SECTORSTOREADWRITE]
  5767 00001566 26C45F09                		les	bx,[es:bx+A_TRACKREADWRITEPACKET.TRWP_TRANSFERADDRESS]
  5768 0000156A E80100                  		call	TrackIO
  5769 0000156D C3                      		retn
  5770                                  ;
  5771                                  ; TrackIO:
  5772                                  ;    Performs Track Read/Write/Verify
  5773                                  ;
  5774                                  ;   Input:
  5775                                  ;      RFLAG	- 2 = Read
  5776                                  ;		  3 = Write
  5777                                  ;		  4 = Verify
  5778                                  ;      ax	- Index into track table of first sector to IO
  5779                                  ;      cx	- number of sectors to IO
  5780                                  ;      es:bx	- Transfer address
  5781                                  ;      ds:di	- pointer to BDS
  5782                                  ;      curtrk	- current cylinder
  5783                                  ;      curhd	- current head
  5784                                  ;
  5785                                  
  5786                                  TrackIO:
  5787                                  ; procedure `disk' will pop stack to SPsav and return if error
  5788 0000156E 2E8926[2E02]            		mov	[cs:SPSAV], sp
  5789                                  ; Ensure correct disk is in drive
  5790 00001573 E8C9F6                  		call	CHECKSINGLE
  5791                                  ;
  5792                                  ; Set up tables and variables for I/O
  5793                                  ;
  5794 00001576 2E803E[8E12]01          		cmp	byte [cs:Media_Set_For_Format],1
  5795 0000157C 7407                    		jz	short DPTAlreadySet
  5796                                  ;
  5797                                  ; SET UP TABLES AND VARIABLES FOR I/O
  5798                                  ;
  5799 0000157E 50                      		push	ax
  5800 0000157F 51                      		push	cx
  5801 00001580 E8B2F7                  		call	IOSETUP
  5802 00001583 59                      		pop	cx
  5803 00001584 58                      		pop	ax
  5804                                  ;
  5805                                  ; point si at the table entry of the first sector to be IO'd
  5806                                  ;
  5807                                  DPTAlreadySet:
  5808 00001585 BE[9111]                		mov	si,TrackTable
  5809 00001588 D1E0                    		shl	ax,1
  5810 0000158A D1E0                    		shl	ax,1
  5811 0000158C 01C6                    		add	si,ax
  5812                                  ;
  5813                                  ; we want:
  5814                                  ;    cx to be the number of times we have to loop
  5815                                  ;    dx to be the number of sectors we read on each iteration
  5816 0000158E BA0100                  		mov	dx,1
  5817 00001591 F745290800              		test	word [DI+BDS.Flags],GOOD_TRACKLAYOUT
  5818 00001596 7402                    		jz	short IOnextSector
  5819                                  
  5820                                  ; Hey! we can read all the sectors in one blow
  5821 00001598 87D1                    		xchg	dx, cx
  5822                                  
  5823                                  IOnextSector:
  5824 0000159A 51                      		push	cx
  5825 0000159B 52                      		push	dx
  5826                                  ; skip over the cylinder and head in the track table
  5827 0000159C 46                      		inc	si
  5828 0000159D 46                      		inc	si
  5829                                  
  5830                                  ; Get sector id from track table
  5831 0000159E 2E8A04                  		mov     AL,[cs:si]	; get current sector value
  5832 000015A1 2EA2[2A02]              		mov     [cs:CURSEC], AL	; save cursec value
  5833                                          
  5834                                  ;*** For a Fixed disk multi-track disk I/O -  4/14/86
  5835                                  ;Assumptions: 1). In the input CX (# of sectors to go) to TRACKIO, only CL is
  5836                                  ;valid.  2). Sector size should be set to 512 bytes. 3). GOODTRACKLAYOUT.
  5837                                  ;
  5838 000015A5 F745290100              		test	word [DI+BDS.Flags],fNon_Removable ;Fixed disk? - J.K
  5839 000015AA 740E                    		jz	short IOREMOVABLE		;no -
  5840 000015AC 2E8916[1C02]            		mov	[cs:SECCNT], dx 		;# of sectors to I/O -
  5841 000015B1 89D0                    		mov	ax, dx				;		 
  5842 000015B3 E820F8                  		call	DISK				;		
  5843 000015B6 5A                      		pop	dx				;		 
  5844 000015B7 59                      		pop	cx				;		
  5845 000015B8 F8                      		clc					;		
  5846 000015B9 C3                      		retn					;		
  5847                                  
  5848                                  IOREMOVABLE:		 
  5849 000015BA 2E8A4401                        	mov     AL,[cs:si+1]	; get sector size index
  5850                                  
  5851                                  		; The next eight lines put sector size index in DPT
  5852 000015BE 06                      		push    ES                      ; save value while getting pointer
  5853 000015BF 56                      		push    SI                      ;    to DPT
  5854 000015C0 50                      		push	AX
  5855                                  
  5856 000015C1 2EC436[2602]            		les     SI,[cs:DPT]		; ES:SI points to DPT
  5857                                                                                  ; put size in DPT
  5858 000015C6 26884403                		mov     [ES:SI+DISK_PARMS.DISK_SECTOR_SIZ], AL
  5859 000015CA 8B4513                  		mov     AX,[DI+BDS.SECLIM]        ; get number of sector/track
  5860 000015CD 26884404                		mov     [ES:SI+DISK_PARMS.DISK_EOT],AL ; patch in DPT
  5861                                  
  5862 000015D1 58                      		pop	AX			; restore register values
  5863 000015D2 5E                      		pop     SI     
  5864 000015D3 07                      		pop     ES
  5865                                                                          ; convert index to byte value
  5866 000015D4 E82200                  		call    SectorSizeIndexToSectorSize
  5867 000015D7 50                      		push    AX                      ; save number of bytes in sector
  5868 000015D8 89D0                    		mov     AX, DX                  ; get number of sector for I/0
  5869                                  
  5870                                  DoTheIO:
  5871 000015DA 2EA3[1C02]              		mov	[cs:SECCNT],ax	; set up the count of sectors to I/O
  5872 000015DE E8F5F7                  		call	DISK		
  5873                                  					; advance buffer pointer by adding
  5874                                  					;   sector size
  5875 000015E1 58                      		pop	ax
  5876 000015E2 01C3                    		add	bx, ax
  5877 000015E4 5A                      		pop	dx
  5878 000015E5 59                      		pop	cx
  5879 000015E6 E2B2                    		loop	IOnextSector
  5880 000015E8 E88AF7                  		call	DONE		; Set time of last access, and reset
  5881 000015EB F8                      		clc			; entries in DPT.
  5882 000015EC C3                      		retn
  5883                                  
  5884                                  ;
  5885                                  ; The sector size in bytes needs to be converted to an index value for the IBM
  5886                                  ; ROM. (0=>128, 1=>256,2=>512,3=>1024). It is assumed that only these values
  5887                                  ; are permissible.
  5888                                  ; On Input   AX contains sector size in bytes
  5889                                  ; On Output  AL contains index
  5890                                  ;
  5891                                  
  5892                                  SectorSizeToSectorIndex:
  5893 000015ED 80E407                  		and     AH, 07h 	; very simple error correction
  5894 000015F0 88E0                    		mov     AL, AH          ; shift left 8 bits
  5895 000015F2 3C04                    		cmp     AL, 4           ; size 1024?
  5896 000015F4 7502                    		jnz	short SecToIndexRet ; no, then we are done
  5897 000015F6 2C01                    		sub     AL, 1           ; if 1024, adjust index to 3
  5898                                  SecToIndexRet:
  5899 000015F8 C3                      		retn
  5900                                  
  5901                                  SectorSizeIndexToSectorSize:
  5902                                  ; value in AH on entry is not important
  5903 000015F9 51                      		push    CX              ; save CX value
  5904 000015FA 88C1                    		mov     CL, AL          ; use index number as shift size
  5905 000015FC B88000                  		mov     AX, 0080h       ; set AX to 128
  5906 000015FF D3E0                    		shl     AX, CL          ; shift by index to get proper value
  5907 00001601 59                      		pop     CX              ; restore CX value
  5908 00001602 C3                      		retn
  5909                                  
  5910                                  ;
  5911                                  ; Set up the ROM for formatting.
  5912                                  ; we have to tell the ROM BIOS what type of disk is in the drive.
  5913                                  ; On Input   - DS:DI - points to BDS
  5914                                  ;
  5915                                  SetDASD:
  5916                                  ; See if we have new ROM and have issues Set Media Type For Format call
  5917 00001603 2EF606[8E12]01                  	test    byte [cs:Media_Set_For_Format],1
  5918 00001609 7549                    		jnz	short DasdHasBeenSet
  5919                                  ; See if we have previously set DASD type
  5920 0000160B 2E803E[8F12]01          		cmp	byte [cs:Had_Format_Error],1
  5921 00001611 740C                    		je	short DoSetDasd
  5922 00001613 F745298000              		test    word [DI+BDS.Flags],SET_DASD_true
  5923 00001618 743A                    		jz	short DasdHasBeenSet
  5924 0000161A 8165297FFF              		and     word [DI+BDS.Flags],~SET_DASD_true
  5925                                                  ; the next nine lines determine and put the DASD type in AL
  5926                                  DoSetDasd:
  5927 0000161F 2EC606[8F12]00          		mov	byte [cs:Had_Format_Error],0
  5928 00001625 2EC606[3402]50                  	mov	byte [cs:GAP_PATCH],50h	; assume 48tpi or 3.5" drive
  5929 0000162B 807D2802                        	cmp     byte [DI+BDS.FormFactor],ffSmall ; is 3.5" drive?
  5930 0000162F 7504                            	jnz	short Not35Drive	; no, skip down
  5931 00001631 B004                            	mov     AL,04h			; yes set proper DASD value
  5932 00001633 EB18                    		jmp     short Do_Set            ; jump down
  5933                                  
  5934                                  Not35Drive:
  5935 00001635 B001                    		mov     AL,01h			;
  5936 00001637 807D2801                		cmp     byte [DI+BDS.FormFactor],ff96tpi; 96tpi disk drive?
  5937 0000163B 7510                    		jnz	short Do_Set		; no skip down to rom call
  5938 0000163D FEC0                    		inc     AL                      ; reflect 96tpi drive in DASD type
  5939 0000163F 807D130F                		cmp     byte [DI+BDS.SECLIM],15 ; 96tpi media in drive?
  5940 00001643 7508                    		jnz	short Do_Set		; no, skip down to rom call
  5941 00001645 FEC0                    		inc     AL                      ; reflect 96tpi media in DASD type
  5942 00001647 2EC606[3402]54          		mov	byte [cs:GAP_PATCH],54h ;  and in the GAP_PATCH
  5943                                  Do_Set:
  5944 0000164D B417                    		mov     AH,17h			; set command to Set DASD type
  5945 0000164F 8A5504                  		mov     DL,[DI+BDS.DriveNum]	; set drive number
  5946 00001652 CD13                    		int     13h                     ; call rom-bios
  5947                                  DasdHasBeenSet:
  5948 00001654 8A6513                  		mov     ah,[DI+BDS.SECLIM]
  5949 00001657 2E8826[3002]            		mov	[cs:FORMT_EOT],ah
  5950 0000165C C3                      		retn
  5951                                  
  5952                                  ;
  5953                                  ; This routine is called if an error occurs while formatting or verifying.
  5954                                  ; It resets the drive, and decrements the retry count.
  5955                                  ; On Entry - DS:DI - points to BDS for the drive
  5956                                  ;	     BP    - contains retry count
  5957                                  ; On Exit    Flags indicate result of decrementing retry count
  5958                                  ;
  5959                                  ;
  5960                                  ;  There are some drives that "lose" the changeline indication if another
  5961                                  ;  floppy drive is accessed before the changeline is recorded by the device
  5962                                  ;  driver. In this situation, it is possible for the ROM to also not detect
  5963                                  ;  that the medium has changed. So, the end result is that we could have a
  5964                                  ;  diskette in the drive for which we can not even read the boot sector.
  5965                                  ;  We "fix" this by setting the byte at location DISK_STATE_MACHINE_DRV_0 (hex)
  5966                                  ;  for physical drive 0 (or DISK_STATE_MACHINE_DRV_1  for drive 1) to 0 (See
  5967                                  ;  IBM PC/AT "blessed" addresses Document for explanation) . This tells the ROM
  5968                                  ;  that the medium is 'unknown'.  The ROM actually uses these locations for
  5969                                  ;  itself.  Note that we do this only for internal drives; we do not do this for
  5970                                  ;  fixed disks or for physical drives > 1. We may end up corrupting some
  5971                                  ;  other bytes in memory that may be used for something else.
  5972                                  ;  NOTE: We do not stuff this byte if the last operation was a FORMAT because
  5973                                  ;  the ROM loses track of what it is trying to format!!
  5974                                  ;
  5975                                  ;  This routine was changed to only stuff 61H when the drive indicated it
  5976                                  ;  supported changeline. The Phoenix ROM was taking a very long time
  5977                                  ;  to figure out what the media was which caused disk time outs to take
  5978                                  ;  forever
  5979                                  ;
  5980                                  ;  We assume that DS:DI points to the current BDS for this drive.
  5981                                  ;	no registers should be touched
  5982                                  ;
  5983                                  
  5984                                  AGAIN:
  5985 0000165D E80200                  		call	ResetDisk
  5986 00001660 4D                      		dec	bp		; decrement retry count
  5987 00001661 C3                      		RETN
  5988                                  
  5989                                  ResetDisk:
  5990 00001662 50                      		push	ax
  5991 00001663 30E4                    		xor	AH, AH			; set command to reset disk
  5992 00001665 CD13                    		int	13h			; call the rom-bios
  5993 00001667 58                      		pop	ax
  5994 00001668 2EC606[8401]FF          		mov	byte [cs:STEP_DRV],-1	; zap up the speed
  5995 0000166E C3                      		retn
  5996                                  
  5997                                  ;
  5998                                  ; This routine sets up the Drive Parameter Table with the values needed for
  5999                                  ; Format, does an Int 13. Values in DPT are restored after a VERIFY is done.
  6000                                  ;
  6001                                  ; On Entry  -	DS:DI - points to BDS for the drive
  6002                                  ;		ES:BX - points to TRKBUF
  6003                                  ;		AL    - number of sectors
  6004                                  ;		AH    - Int 13 function code
  6005                                  ;		CL    - Sector number for verify
  6006                                  ; On Exit   -	DS,DI,ES,BX remain unchanged.
  6007                                  ;		ax and flags are the results of the int 13
  6008                                  ;
  6009                                  
  6010                                  To_ROM:
  6011 0000166F 1E                      		push	ds
  6012 00001670 57                      		push	di
  6013 00001671 06                      		push	es
  6014 00001672 53                      		push	bx
  6015 00001673 56                      		push	si
  6016                                  
  6017                                  ; The below line was replaced because saving the DPT is predicated upon
  6018                                  ; whether the functionality of the new ROM was used, not if it exists.
  6019                                  ;		test	byte ptr cs:[NEW_ROM],1
  6020                                  
  6021 00001674 2EF606[8E12]01          		test	byte [cs:Media_Set_For_Format],1
  6022 0000167A 753D                    		jnz	short Got_Valid_DPT
  6023                                  
  6024                                  ; Set up values in the DPT
  6025                                  ; Set up motor start correctly for 3.5" drives.
  6026 0000167C 50                      		push	ax
  6027 0000167D 1E                      		push	ds
  6028                                  
  6029 0000167E 31C0                    		xor	ax,ax
  6030 00001680 8ED8                    		mov	ds,ax
  6031 00001682 C5367800                		lds	si,[DSKADR]	; DS:SI := pDPT
  6032                                  
  6033 00001686 2E8936[2602]            		mov	[cs:DPT],si
  6034 0000168B 2E8C1E[2802]            		mov	[cs:DPT+2],ds	; Save pDPT
  6035                                  
  6036 00001690 1F                      		pop     ds
  6037 00001691 06                      		push    ES		; save value in ES
  6038 00001692 2EC436[2602]            		LES     SI,[CS:DPT]
  6039                                  
  6040 00001697 8B5513                  		mov     DX,[DI+BDS.SECLIM] ; set the sector per track in
  6041 0000169A 26885404                		mov     [es:si+DISK_PARMS.DISK_EOT],DL	; the Disk Parameter Table
  6042 0000169E 83FA0F                  		cmp     DX, 15                  ; 96tip media?
  6043 000016A1 7409                    		jz	short To_ROM1		; yes, skip down
  6044                                                                  ; no - set Format Gap to 320/360 media value
  6045 000016A3 2E8A0E[3402]            		mov     CL,[cs:GAP_PATCH]
  6046 000016A8 26884C07                		mov     [ES:SI+DISK_PARMS.DISK_FORMT_GAP],CL
  6047                                  To_ROM1:                                ; 3.5" floppy drive?
  6048 000016AC 807D2802                		cmp     byte [DI+BDS.FormFactor],ffSmall
  6049 000016B0 7505                    		jnz	short To_ROM2	; no, skip down
  6050                                                                  ; yes - reset disk motor start value
  6051 000016B2 26C6440A04              		mov     byte [ES:SI+DISK_PARMS.DISK_MOTOR_STRT],4
  6052                                  To_ROM2:
  6053 000016B7 07                      		pop     ES		; restore ES value
  6054 000016B8 58                      		pop     ax
  6055                                  
  6056                                  Got_Valid_DPT:
  6057                                   					; now set up the registers
  6058 000016B9 8A5504                          	mov     DL,[DI+BDS.DriveNum] ; set drive number
  6059 000016BC 2E8A36[3102]                    	mov     DH,[CS:HDNUM]	; set head number
  6060 000016C1 2E8B0E[3202]            		mov     CX,[CS:TRKNUM]	; set track number
  6061 000016C6 D0CD                    		ror     CH,1
  6062 000016C8 D0CD                    		ror     CH,1
  6063 000016CA 86E9                    		xchg    CH, CL
  6064 000016CC CD13                    		int     13h		; call the rom-bios disk routines
  6065 000016CE 5E                      		pop	si
  6066 000016CF 5B                      		pop	bx
  6067 000016D0 07                      		pop	es
  6068 000016D1 5F                      		pop	di
  6069 000016D2 1F                      		pop	ds
  6070 000016D3 C3                      		retn
  6071                                  
  6072                                  ;
  6073                                  ; Get the owner of the physical drive represented by the logical drive in BL.
  6074                                  ; The assumption is that we **ALWAYS** keep track of the owner of a drive!!
  6075                                  ; If this is not the case, the system may hang, just following the linked list.
  6076                                  ;
  6077                                  
  6078                                  IOCTL$GETOWN:
  6079 000016D4 E81EF5                  		call	SETDRIVE
  6080 000016D7 8A4504                  		mov	al,[DI+BDS.DriveNum]	; Get physical drive number
  6081 000016DA 0E                      		push	cs
  6082 000016DB 1F                      		pop	ds
  6083 000016DC BF[1002]                		mov	di,START_BDS
  6084                                  Own_Loop:
  6085 000016DF 384504                  		cmp	[DI+BDS.DriveNum],al
  6086 000016E2 7507                    		jne	short GetNextBDS
  6087 000016E4 F745292000              		test	word [DI+BDS.Flags],fI_Own_Physical
  6088 000016E9 7509                    		jnz	short Done_GetOwn
  6089                                  GetNextBDS:
  6090 000016EB 8B5D02                  		mov	bx,[DI+BDS.Link+2]
  6091                                  		;mov	di,[DI+BDS.Link]
  6092 000016EE 8B3D                    		mov	di,[di] ; 05/07/2019
  6093 000016F0 8EDB                    		mov	ds,bx
  6094 000016F2 EBEB                    		jmp	short Own_Loop
  6095                                  Done_GetOwn:
  6096 000016F4 EB1D                    		JMP	SHORT EXIT_OWN
  6097                                  
  6098                                  ;
  6099                                  ; Set the ownership of the physical drive represented by the logical drive in
  6100                                  ; BL.
  6101                                  ;
  6102                                  
  6103                                  IOCTL$SETOWN:
  6104 000016F6 E8FCF4                  		call	SETDRIVE
  6105 000016F9 2EC606[8901]01          		mov	byte [cs:fSetOwner],1	; set flag for CheckSingle to
  6106                                  						; look at.
  6107 000016FF E83DF5                  		call	CHECKSINGLE		; Set ownership of drive
  6108 00001702 2EC606[8901]00          		mov	byte [cs:fSetOwner],0	; reset flag
  6109 00001708 31DB                    		xor	bx,bx
  6110 0000170A 8EC3                    		mov	es,bx
  6111 0000170C B1FF                    		mov	cl,-1
  6112 0000170E 26880E0405              		mov	byte [es:LSTDRV],cl 	; Set up SDSB as well
  6113                                  
  6114                                  EXIT_OWN:
  6115                                  ; If there is only one logical drive assigned to this physical drive, return
  6116                                  ; 0 to user to indicate this.
  6117 00001713 30C9                    		xor	cl,cl
  6118 00001715 F745291000              		test	word [DI+BDS.Flags],fI_Am_Mult
  6119 0000171A 7405                    		jz	short EXIT_NO_MULT
  6120 0000171C 8A4D05                  		mov	cl,[DI+BDS.DriveLet]	; Get logical drive number
  6121 0000171F FEC1                    		inc	cl			; get it 1-based
  6122                                  EXIT_NO_MULT:
  6123 00001721 2EC51E[B800]            		LDS	BX,[CS:PTRSAV]
  6124 00001726 884F01                  		mov	[BX+UNIT],CL
  6125 00001729 E920EF                  		jmp	EXIT
  6126                                  
  6127                                  ;
  6128                                  ; Moves the old DPT that had been saved in TempDPT back to DPT. This is done
  6129                                  ; only if the first byte of TempDPT is not -1.
  6130                                  ; All registers (including flags) are preserved.
  6131                                  ;
  6132                                  
  6133                                  RestoreOldDPT:
  6134                                  ; If we have already restored the disk base table earlier, do not do it
  6135                                  ; again.
  6136 0000172C 50                      		push	ax
  6137 0000172D 30C0                    		xor	al,al
  6138                                  ; Reset flag and get current flag setting
  6139 0000172F 2EA2[8F12]              		mov	[cs:Had_Format_Error],al
  6140 00001733 2E8606[8E12]            		xchg	[cs:Media_Set_For_Format],al
  6141 00001738 08C0                    		or	al,al
  6142 0000173A 7419                    		jz	short DontRestore
  6143 0000173C 56                      		push	si
  6144 0000173D 1E                      		push	ds
  6145 0000173E 06                      		push	es
  6146 0000173F 2EC536[9012]            		LDS	SI,[CS:TempDPT]
  6147 00001744 31C0                    		xor	ax,ax
  6148 00001746 8EC0                    		mov	es,ax			; have ES -> segment 0
  6149 00001748 2689367800              		MOV	[ES:DSKADR],SI
  6150 0000174D 268C1E7A00              		MOV	[ES:DSKADR+2],DS
  6151                                  GotCurrentDPT:
  6152 00001752 07                      		pop	es
  6153 00001753 1F                      		pop	ds
  6154 00001754 5E                      		pop	si
  6155                                  DontRestore:
  6156 00001755 58                      		pop	ax
  6157 00001756 F8                      		clc				; clear carry
  6158 00001757 C3                      		retn				; (7/31/86)
  6159                                  
  6160                                  ;end of file msioctl.asm
  6161                                  
  6162                                  ; ............................................................................
  6163                                  
  6164                                  ;-----------------------------------------------------------------------------
  6165                                  ; MSDISK.ASM (2) - MSDOS 3.3 - 02/02/1988
  6166                                  ;-----------------------------------------------------------------------------
  6167                                  ; 28/05/2018 - Retro DOS v3.0
  6168                                  ; 24/03/2018 - Retro DOS v2.0 
  6169                                  
  6170                                  ;
  6171                                  ; Check_Wrap is a routine that adjusts the starting sector, starting head
  6172                                  ; and starting cylinder for an Int 13 request that requests I/O of a lot
  6173                                  ; of sectors. It only does this for fixed disks. It is used in the sections
  6174                                  ; of code that handle ECC errors and DMA errors. It is necessary, because
  6175                                  ; ordinarily the ROM would take care of wraps around heads and cylinders,
  6176                                  ; but we break down a request when we get an ECC or DMA error into several
  6177                                  ; I/O of one or more sectors. In this case, we may already be beyond the
  6178                                  ; number of sectors on a track on the medium, and the request would fail.
  6179                                  ;
  6180                                  ; Input conditions:
  6181                                  ;	ALL registers set up for an Int 13 request.
  6182                                  ;
  6183                                  ; Output:
  6184                                  ;	 - contains starting head number for request
  6185                                  ;	 - contains starting sector and cylinder numbers
  6186                                  ;	(The above may or may not have been changed, and are 0-based)
  6187                                  ;	All other registers preserved.
  6188                                  ;
  6189                                  
  6190                                  Check_Wrap:
  6191 00001758 50                      		push	ax
  6192 00001759 53                      		push	bx
  6193 0000175A 1E                      		push	ds
  6194 0000175B 57                      		push	di
  6195 0000175C 2EC606[8501]01          		mov	byte [cs:PHYS_DRV],1;Use phys. drive in AL to get BDS
  6196 00001762 88D0                    		mov	al,dl		; put drive number in AL for get BDS
  6197 00001764 E88EF4                  		call	SETDRIVE	; Get pointer to BDS for drive.
  6198 00001767 2EC606[8501]00          		mov	byte [cs:PHYS_DRV],0; Restore flag to use Logical Drive
  6199 0000176D 725E                    		jc	short No_Wrap	; Do nothing if wrong phys. drive
  6200                                  
  6201 0000176F F745290100              		test	word [DI+BDS.Flags],fNon_Removable
  6202 00001774 7457                    		jz	short No_Wrap	; No wrapping for removable media
  6203 00001776 8B5D13                  		MOV	BX,[DI+BDS.SECLIM]
  6204 00001779 89C8                    		MOV	AX,CX
  6205 0000177B 83E03F                  		AND	AX,003FH	; EXTRACT SECTOR NUMBER
  6206 0000177E 39D8                    		cmp	ax,bx		; If Wrap
  6207 00001780 764B                    		jbe	short No_Wrap
  6208                                  
  6209 00001782 F6F3                    		div	bl		; AH=new sector#, AL = # of head wraps
  6210                                  
  6211                                  ; We need to be careful here.  If the new sector number == 0, then we are
  6212                                  ; on the last sector on that track
  6213 00001784 08E4                    		or	ah,ah
  6214 00001786 7504                    		jnz	short Not_on_Bound
  6215                                  
  6216 00001788 88DC                    		mov	ah,bl		; set sector = SECLIM if on Bndry
  6217 0000178A FEC8                    		dec	al		; and decrement Num. head wraps
  6218                                  
  6219                                  Not_on_Bound:
  6220 0000178C 80E1C0                  		and	CL,0C0H		; zero out sector #
  6221                                  
  6222 0000178F 08E1                    		or	CL,AH		; OR in new sector #
  6223 00001791 30E4                    		xor	ah,ah		; AX = # of head wraps
  6224 00001793 40                      		inc	ax
  6225 00001794 00F0                    		add	al,DH		; add in starting head #
  6226 00001796 80D400                  		adc	ah,0		; catch any carry
  6227 00001799 3B4515                  		CMP	AX,[DI+BDS.HDLIM] ; are we going to wrap around a head?
  6228 0000179C 7635                    		jbe	short No_Wrap_Head ; Do not lose new head number!!
  6229                                  
  6230 0000179E 52                      		push	DX		; preserve drive number and head number
  6231 0000179F 31D2                    		xor	dx,dx
  6232 000017A1 8B5D15                  		mov	bx,[DI+BDS.HDLIM]
  6233 000017A4 F7F3                    		div	bx		; DX=new head #, AX=# of cylinder wraps
  6234                                  ; Careful here! If new head # is 0, then we are on the last head.
  6235 000017A6 09D2                    		or	dx,dx
  6236 000017A8 7507                    		jnz	short No_Head_Bound
  6237                                  
  6238 000017AA 89DA                    		mov	dx,bx		; On boundary. Set to HDLIM
  6239                                  ; If we had some cylinder wraps, we need to reduce them by one!!
  6240 000017AC 09C0                    		or	ax,ax
  6241 000017AE 7401                    		jz	short No_Head_Bound
  6242                                  
  6243 000017B0 48                      		dec	ax		; Reduce number of cylinder wraps
  6244                                  No_Head_Bound:
  6245 000017B1 88D7                    		mov	bh,dl		; bh has new head number
  6246 000017B3 5A                      		POP	DX		; restore drive number and head number
  6247                                  
  6248 000017B4 FECF                    		dec	bh		; get it 0-based
  6249 000017B6 88FE                    		mov	DH,bh		; set up new head number in DH
  6250                                  
  6251 000017B8 88CF                    		mov	bh,CL
  6252 000017BA 80E73F                  		and	bh,3FH		; preserve sector number
  6253 000017BD B306                    		mov	bl,6
  6254 000017BF 86CB                    		xchg	cl,bl
  6255 000017C1 D2EB                    		shr	bl,cl		; get ms cylinder bits to ls end
  6256                                  
  6257 000017C3 00C5                    		ADD	CH,AL		; ADD IN CYLINDER WRAP
  6258 000017C5 10E3                    		adc	bl,ah		; add in high byte
  6259 000017C7 D2E3                    		shl	bl,cl		; move up to ms end
  6260 000017C9 86D9                    		xchg	bl,cl		; restore cylinder bits into CL
  6261 000017CB 08F9                    		or	CL,bh		; OR in sector number
  6262                                  No_Wrap:
  6263 000017CD F8                      		clc			; reset carry
  6264 000017CE 5F                      		pop	di
  6265 000017CF 1F                      		pop	ds
  6266 000017D0 5B                      		pop	bx
  6267 000017D1 58                      		pop	ax
  6268 000017D2 C3                      		retn
  6269                                  
  6270                                  No_Wrap_Head:
  6271 000017D3 88C6                    		mov	DH,al		; Do not lose new head number
  6272 000017D5 FECE                    		dec	DH		; get it 0-based
  6273 000017D7 EBF4                    		jmp	short No_Wrap
  6274                                  
  6275                                  ; INT_2F_13:
  6276                                  ;		This code is chained into the INT_2F interrupt during bios
  6277                                  ;	initialization.  It allows the user to change the ORIG13 int_13 vector
  6278                                  ;	after booting.	This allows testing and implementation of custom int_13
  6279                                  ;	handlers, without giving up MS-DOS error recovery
  6280                                  ;
  6281                                  ;	Entry Conditions
  6282                                  ;		AH	== RESET_Int_13  (13h)
  6283                                  ;		DS:DX	== Address of New INT_13 Handler
  6284                                  ;		ES:BX	== Address of New INT_13 vector used by WARM BOOT
  6285                                  ;								(INT 19)
  6286                                  ;
  6287                                  ;	Exit Conditions
  6288                                  ;		Orig13	== Address of new Int_13 Handler
  6289                                  ;		DS:DX	== Old ORIG13 value
  6290                                  ;		ES:BX	== Old OLD13  value
  6291                                  
  6292                                  INT_2F_13:
  6293 000017D9 80FC13                  		cmp	AH,13h			; IF (interrupt_value != Reset_Int_13)
  6294 000017DC 7405                    		je	short Chg_Orig13
  6295 000017DE 2EFF2E[0C02]            		jmp	far [CS:NEXT2F_13]	;    THEN Continue on Int_2F chain
  6296                                  
  6297                                  Chg_Orig13:					;    ELSE
  6298 000017E3 2EFF36[B400]            		push	word [CS:ORIG13]	;	 Save Old value of OLD13 and
  6299 000017E8 2EFF36[B600]            		push	word [CS:ORIG13+2]	;	 ORIG13 so that we can
  6300                                  
  6301 000017ED 2EFF36[B000]            		push	word [CS:OLD13]		;	 Return them to caller
  6302 000017F2 2EFF36[B200]            		push	word [CS:OLD13+2]
  6303                                  
  6304 000017F7 2E8916[B400]            		mov	word [CS:ORIG13],DX	;	 Orig13 := Addr. Of New INT_13
  6305                                  						;	             		Vector
  6306 000017FC 2E8C1E[B600]            		mov	word [CS:ORIG13+2],DS
  6307                                  
  6308 00001801 2E891E[B000]            		mov	word [CS:OLD13],BX	;	 Old13 := Addr. Of New
  6309                                  						;			  Boot_13 vector
  6310 00001806 2E8C06[B200]            		mov	word [CS:OLD13+2],ES
  6311                                  
  6312 0000180B 07                      		pop	ES			;	 ES:BX := Old OLD13 vector
  6313 0000180C 5B                      		pop	BX
  6314                                  
  6315 0000180D 1F                      		pop	DS			;	 DS:DX := Old ORIG13 vector
  6316 0000180E 5A                      		pop	DX
  6317                                  
  6318 0000180F CF                      		iret				;    END else
  6319                                  
  6320                                  Move:
  6321 00001810 51                      		push	CX
  6322 00001811 B90001                  		mov	CX,512/2
  6323 00001814 FC                      		cld
  6324 00001815 F3A5                    		rep	MOVSW
  6325 00001817 59                      		pop	CX
  6326 00001818 C3                      		retn
  6327                                  
  6328                                  DoINT:
  6329 00001819 8A5608                  		mov	DL,[BP+INT13FRAME.olddx]
  6330 0000181C 30E4                    		xor	AH,AH
  6331 0000181E 08C0                    		or	AL,AL
  6332 00001820 740F                    		jz	short DoIntDone
  6333 00001822 8A6603                  		mov	AH,[BP+INT13FRAME.oldax+1]
  6334 00001825 FF760E                  		push	word [BP+INT13FRAME.oldf]
  6335 00001828 2EFF1E[B400]            		call	far [CS:ORIG13]
  6336 0000182D 9C                      		pushf
  6337 0000182E 8F460E                  		pop	word [BP+INT13FRAME.oldf]
  6338                                  DoIntDone:
  6339 00001831 C3                      		retn
  6340                                  
  6341                                  ;-----------------------------------------------------------------------------
  6342                                  ; MSBIO2.ASM - MSDOS 3.3 - 02/02/1988
  6343                                  ;-----------------------------------------------------------------------------
  6344                                  ; 29/05/2018 - Retro DOS v3.0
  6345                                  ; 25/03/2018 - Retro DOS v2.0 
  6346                                  
  6347                                  ;;Rev 3.30 modification ----------------------------
  6348                                  
  6349                                  INT19SEM:
  6350 00001832 00                      		DB	0		; INDICATE THAT ALL INT 19
  6351                                  					; INITIALIZATION IS COMPLETE
  6352                                  
  6353                                  		;EVENB
  6354 00001833 90                      align 4
  6355                                  
  6356                                  ORIG19:
  6357 00001834 00000000                		dd	0
  6358                                  
  6359                                  	;IRP	AA,<02,08,09,0A,0B,0C,0D,0E,70,72,73,74,76,77>
  6360                                  	;public	Int19OLD&AA
  6361                                  ;Int19OLD&AA	dd	-1		;Orignal hw int. vec for INT 19h.
  6362                                  	;ENDM
  6363                                  
  6364 00001838 FFFFFFFF                INT19OLD02:	dd	-1
  6365 0000183C FFFFFFFF                INT19OLD08:	dd	-1
  6366 00001840 FFFFFFFF                INT19OLD09:	dd	-1
  6367 00001844 FFFFFFFF                INT19OLD0A:	dd	-1
  6368 00001848 FFFFFFFF                INT19OLD0B:	dd	-1
  6369 0000184C FFFFFFFF                INT19OLD0C:	dd	-1
  6370 00001850 FFFFFFFF                INT19OLD0D:	dd	-1
  6371 00001854 FFFFFFFF                INT19OLD0E:	dd	-1
  6372 00001858 FFFFFFFF                INT19OLD70:	dd	-1	
  6373 0000185C FFFFFFFF                INT19OLD72:	dd	-1
  6374 00001860 FFFFFFFF                INT19OLD73:	dd	-1
  6375 00001864 FFFFFFFF                INT19OLD74:	dd	-1
  6376 00001868 FFFFFFFF                INT19OLD76:	dd	-1
  6377 0000186C FFFFFFFF                INT19OLD77:	dd	-1	
  6378                                  
  6379                                  		;EVENB
  6380                                  ;align 2
  6381                                  
  6382                                  DSKDRVS:	; 29/05/2018
  6383 00001870 [4C04]                  		DW	FDRIVE1
  6384 00001872 [9E04]                  		DW	FDRIVE2
  6385 00001874 [F004]                  		DW	FDRIVE3
  6386 00001876 [4205]                  		DW	FDRIVE4
  6387                                  HDSKTAB:
  6388 00001878 [161B]                  		DW	HDRIVE
  6389 0000187A [681B]                  		DW	DRIVEX
  6390                                  
  6391                                  ;* Next area is reserved for mini disk BPB pointers *** 4/7/86
  6392                                  ;* Don't change this pos. Should be add. from DskDrvs *** 4/7/86
  6393                                  MINI_DISK_BPB_PTRS:	
  6394 0000187C 00<rep 28h>             		times 40 db 0 ;4/7/86 - mem res for Mini disk.
  6395                                  
  6396                                  	;EVENB
  6397                                  ;align 2
  6398                                  
  6399                                  INT_2F_NEXT:
  6400 000018A4 00000000                		dd	0
  6401                                  RET_ADDR:
  6402 000018A8 00000000                		dd	0
  6403                                  
  6404                                  ;;End of modification ----------------------------
  6405                                  
  6406                                  
  6407                                  ;  INT19
  6408                                  ;
  6409                                  ;	We "hook" the INT_REBOOT vector, because contrary to IBM documentation,
  6410                                  ;  it does NOT "bootstrap" the machine.  It leaves memory almost untouched.
  6411                                  ;  Since the BIOS_INIT code assumes that certain Interrupt Vectors point to
  6412                                  ;  the ROM_BIOS  we must "unhook" them before issuing the actual INT_REBOOT.
  6413                                  ;  Currently the following vectors need to be unhooked:
  6414                                  ;		  02,08,09,0A,0B,0C,0D,0E,70,72,73,74,75,76,77
  6415                                  ;
  6416                                  
  6417                                  INT19:
  6418 000018AC 31C0                    		xor	AX,AX		; get data segment to
  6419 000018AE 8ED8                    		mov	DS,AX		;   point to the vector table
  6420 000018B0 2EC43E[B000]            		les	DI,[CS:OLD13]	; get ES to point to this segment
  6421 000018B5 893E4C00                		mov	[13h*4],DI	; restore old int13 value
  6422 000018B9 8C064E00                		mov	[13h*4+2],ES
  6423                                  
  6424 000018BD 2E803E[3218]00          		cmp	byte [CS:INT19SEM], 0
  6425 000018C3 7503                    		jnz	short int19vecs
  6426 000018C5 E9FC00                  		jmp	doint19
  6427                                  
  6428                                  ;Stacks code has changed these hardware interrupt vectors
  6429                                  ;STKINIT in SYSINIT1 will initialize Int19hOLDxx values.
  6430                                  
  6431                                  int19vecs:
  6432                                  
  6433                                  ;
  6434                                  ; we now need to unhook all the vector replace to prevent stack overflow
  6435                                  ;
  6436                                  
  6437                                  ;;Rev 3.30 modification ----------------------------
  6438                                  
  6439                                  		; 25/08/2022 (ds=0)
  6440                                  		;XOR	AX,AX
  6441                                  		;MOV	DS,AX
  6442                                  
  6443                                  		;IRP	AA,<02,08,09,0A,0B,0C,0D,0E,70,72,73,74,76,77>
  6444                                  
  6445                                  		;LES	DI,Int19OLD&AA
  6446                                  
  6447 000018C8 2EC43E[3818]            		LES	DI,[CS:INT19OLD02] ; 15/06/2018
  6448                                  
  6449                                  		; 25/08/2022
  6450                                  		;mov	ax,es		; Put segment where we can compare it
  6451                                  		;cmp	ax,-1		; OPT 0ffffh is not likely
  6452                                  		;;je	skip_int&AA	; OPT could get away without checking
  6453                                  		;je	short skip_int02
  6454 000018CD 83FFFF                  		cmp	di,-1		; OPT offset here.
  6455                                  		;je	skip_int&AA
  6456 000018D0 7408                    		je	short skip_int02
  6457                                  
  6458                                  		;MOV	DS:[AA&H*4],DI
  6459 000018D2 893E0800                		mov	[02H*4],DI
  6460                                  		;MOV	DS:[AA&H*4+2],ES
  6461 000018D6 8C060A00                		mov	[02H*4+2],ES
  6462                                  	
  6463                                  ;skip_int&AA:
  6464                                  skip_int02:
  6465                                  		;ENDM
  6466                                  
  6467 000018DA 2EC43E[3C18]            		LES	DI,[CS:INT19OLD08]
  6468                                  
  6469                                  		; 25/08/2022
  6470                                  		;mov	ax,es
  6471                                  		;cmp	ax,-1
  6472                                  		;je	short skip_int08
  6473 000018DF 83FFFF                  		cmp	di,-1
  6474 000018E2 7408                    		je	short skip_int08
  6475                                  
  6476 000018E4 893E2000                		mov	[08H*4],DI
  6477 000018E8 8C062200                		mov	[08H*4+2],ES
  6478                                  	
  6479                                  skip_int08:
  6480 000018EC 2EC43E[4018]            		LES	DI,[CS:INT19OLD09]
  6481                                  
  6482                                  		; 25/08/2022
  6483                                  		;mov	ax,es
  6484                                  		;cmp	ax,-1
  6485                                  		;je	short skip_int09
  6486 000018F1 83FFFF                  		cmp	di,-1
  6487 000018F4 7408                    		je	short skip_int09
  6488                                  
  6489 000018F6 893E2400                		mov	[09H*4],DI
  6490 000018FA 8C062600                		mov	[09H*4+2],ES
  6491                                  	
  6492                                  skip_int09:
  6493 000018FE 2EC43E[4418]            		LES	DI,[CS:INT19OLD0A]
  6494                                  
  6495                                  		; 25/08/2022
  6496                                  		;mov	ax,es
  6497                                  		;cmp	ax,-1
  6498                                  		;je	short skip_int0A
  6499 00001903 83FFFF                  		cmp	di,-1
  6500 00001906 7408                    		je	short skip_int0A
  6501                                  
  6502 00001908 893E2800                		mov	[0AH*4],DI
  6503 0000190C 8C062A00                		mov	[0AH*4+2],ES
  6504                                  	
  6505                                  skip_int0A:
  6506 00001910 2EC43E[4818]            		LES	DI,[CS:INT19OLD0B]
  6507                                  
  6508                                  		; 25/08/2022
  6509                                  		;mov	ax,es
  6510                                  		;cmp	ax,-1
  6511                                  		;je	short skip_int0B
  6512 00001915 83FFFF                  		cmp	di,-1
  6513 00001918 7408                    		je	short skip_int0B
  6514                                  
  6515 0000191A 893E2C00                		mov	[0BH*4],DI
  6516 0000191E 8C062E00                		mov	[0BH*4+2],ES
  6517                                  	
  6518                                  skip_int0B:
  6519 00001922 2EC43E[4C18]            		LES	DI,[CS:INT19OLD0C]
  6520                                  
  6521                                  		; 25/08/2022
  6522                                  		;mov	ax,es
  6523                                  		;cmp	ax,-1
  6524                                  		;je	short skip_int0C
  6525 00001927 83FFFF                  		cmp	di,-1
  6526 0000192A 7408                    		je	short skip_int0C
  6527                                  
  6528 0000192C 893E3000                		mov	[0CH*4],DI
  6529 00001930 8C063200                		mov	[0CH*4+2],ES
  6530                                  	
  6531                                  skip_int0C:
  6532 00001934 2EC43E[5018]            		LES	DI,[CS:INT19OLD0D]
  6533                                  
  6534                                  		; 25/08/2022
  6535                                  		;mov	ax,es
  6536                                  		;cmp	ax,-1
  6537                                  		;je	short skip_int0D
  6538 00001939 83FFFF                  		cmp	di,-1
  6539 0000193C 7408                    		je	short skip_int0D
  6540                                  
  6541 0000193E 893E3400                		mov	[0DH*4],DI
  6542 00001942 8C063600                		mov	[0DH*4+2],ES
  6543                                  	
  6544                                  skip_int0D:
  6545 00001946 2EC43E[5418]            		LES	DI,[CS:INT19OLD0E]
  6546                                  
  6547                                  		; 25/08/2022
  6548                                  		;mov	ax,es
  6549                                  		;cmp	ax,-1
  6550                                  		;je	short skip_int0E
  6551 0000194B 83FFFF                  		cmp	di,-1
  6552 0000194E 7408                    		je	short skip_int0E
  6553                                  
  6554 00001950 893E3800                		mov	[0EH*4],DI
  6555 00001954 8C063A00                		mov	[0EH*4+2],ES
  6556                                  	
  6557                                  skip_int0E:
  6558 00001958 2EC43E[5818]            		LES	DI,[CS:INT19OLD70]
  6559                                  
  6560                                  		; 25/08/2022	
  6561                                  		;mov	ax,es
  6562                                  		;cmp	ax,-1
  6563                                  		;je	short skip_int70
  6564 0000195D 83FFFF                  		cmp	di,-1
  6565 00001960 7408                    		je	short skip_int70
  6566                                  
  6567 00001962 893EC001                		mov	[70H*4],DI
  6568 00001966 8C06C201                		mov	[70H*4+2],ES
  6569                                  	
  6570                                  skip_int70:
  6571 0000196A 2EC43E[5C18]            		LES	DI,[CS:INT19OLD72]
  6572                                  
  6573                                  		; 25/08/2022
  6574                                  		;mov	ax,es
  6575                                  		;cmp	ax,-1
  6576                                  		;je	short skip_int72
  6577 0000196F 83FFFF                  		cmp	di,-1
  6578 00001972 7408                    		je	short skip_int72
  6579                                  
  6580 00001974 893EC801                		mov	[72H*4],DI
  6581 00001978 8C06CA01                		mov	[72H*4+2],ES
  6582                                  	
  6583                                  skip_int72:
  6584 0000197C 2EC43E[6018]            		LES	DI,[CS:INT19OLD73]
  6585                                  
  6586                                  		; 25/08/2022
  6587                                  		;mov	ax,es
  6588                                  		;cmp	ax,-1
  6589                                  		;je	short skip_int73
  6590 00001981 83FFFF                  		cmp	di,-1
  6591 00001984 7408                    		je	short skip_int73
  6592                                  
  6593 00001986 893ECC01                		mov	[73H*4],DI
  6594 0000198A 8C06CE01                		mov	[73H*4+2],ES
  6595                                  	
  6596                                  skip_int73:
  6597 0000198E 2EC43E[6418]            		LES	DI,[CS:INT19OLD74]
  6598                                  
  6599                                  		; 25/08/2022
  6600                                  		;mov	ax,es
  6601                                  		;cmp	ax,-1
  6602                                  		;je	short skip_int74
  6603 00001993 83FFFF                  		cmp	di,-1
  6604 00001996 7408                    		je	short skip_int74
  6605                                  
  6606 00001998 893ED001                		mov	[74H*4],DI
  6607 0000199C 8C06D201                		mov	[74H*4+2],ES
  6608                                  	
  6609                                  skip_int74:
  6610 000019A0 2EC43E[6818]            		LES	DI,[CS:INT19OLD76]
  6611                                  
  6612                                  		; 25/08/2022
  6613                                  		;mov	ax,es
  6614                                  		;cmp	ax,-1
  6615                                  		;je	short skip_int76
  6616 000019A5 83FFFF                  		cmp	di,-1
  6617 000019A8 7408                    		je	short skip_int76
  6618                                  
  6619 000019AA 893ED801                		mov	[76H*4],DI
  6620 000019AE 8C06DA01                		mov	[76H*4+2],ES
  6621                                  	
  6622                                  skip_int76:
  6623 000019B2 2EC43E[6C18]            		LES	DI,[CS:INT19OLD77]
  6624                                  
  6625                                  		; 25/08/2022
  6626                                  		;mov	ax,es
  6627                                  		;cmp	ax,-1
  6628                                  		;je	short skip_int77
  6629 000019B7 83FFFF                  		cmp	di,-1
  6630 000019BA 7408                    		je	short skip_int77
  6631                                  
  6632 000019BC 893EDC01                		mov	[77H*4],DI
  6633 000019C0 8C06DE01                		mov	[77H*4+2],ES
  6634                                  	
  6635                                  skip_int77:
  6636                                  
  6637                                  ;;End of modification ----------------------------
  6638                                  
  6639                                  doint19:
  6640 000019C4 2EC43E[3418]            		LES	DI,[CS:ORIG19]
  6641 000019C9 893E6400                		MOV	[19h*4],DI
  6642 000019CD 8C066600                		MOV	[19h*4+2],ES
  6643                                  
  6644 000019D1 CD19                    		INT	19h
  6645                                  
  6646                                  
  6647                                  ;*****************************************************************************
  6648                                  
  6649                                  DSK$INIT:	; 29/05/2018 - Retro DOS v3.0
  6650 000019D3 0E                      		PUSH	CS
  6651 000019D4 1F                      		POP	DS
  6652                                  
  6653 000019D5 8A26[8301]              		MOV	AH,[DRVMAX]
  6654 000019D9 BF[7018]                		MOV	DI,DSKDRVS
  6655 000019DC E95EF0                  		JMP	SetPTRSAV
  6656                                  
  6657                                  ;
  6658                                  ; Int 2f handler for external block drivers to communicate with the internal
  6659                                  ; block driver in msdisk. The multiplex number chosen is 8. The handler
  6660                                  ; sets up the pointer to the request packet in [PTRSAV] and then jumps to
  6661                                  ; DSK$IN, the entry point for all disk requests.
  6662                                  ; On exit from this driver (at EXIT), we will return to the external driver
  6663                                  ; that issued this Int 2F, and can then remove the flags from the stack.
  6664                                  ; This scheme allows us to have a small external device driver, and makes
  6665                                  ; the maintainance of the various drivers (DRIVER and msBIO) much easier,
  6666                                  ; since we only need to make changes in one place (most of the time).
  6667                                  ;
  6668                                  ; AL contains the Int2F function:
  6669                                  ;   0 - Check for installed handler - RESERVED
  6670                                  ;   1 - Install the BDS into the linked list
  6671                                  ;   2 - DOS request
  6672                                  ;
  6673                                  
  6674                                  MYNUM		EQU	8
  6675                                  
  6676                                  INT2F_DISK:
  6677 000019DF 80FC08                  		cmp	ah,MYNUM
  6678 000019E2 7405                    		je	short Mine
  6679 000019E4 2EFF2E[A418]            		jmp	far [cs:INT_2F_NEXT]	; chain to next Int 2F handler
  6680                                  Mine:
  6681 000019E9 3CF8                    		cmp	al,0F8H 		; IRET on reserved functions
  6682 000019EB 7201                    		jb	short Do_Func
  6683 000019ED CF                      		IRET
  6684                                  Do_Func:
  6685 000019EE 08C0                    		or	al,al			; A GET INSTALLED STATE request?
  6686 000019F0 7503                    		jne	short Disp_Func
  6687 000019F2 B0FF                    		mov	al,0FFH
  6688 000019F4 CF                      		IRET
  6689                                  Disp_Func:
  6690 000019F5 3C01                    		cmp	al,1			; Request for installing BDS?
  6691 000019F7 7504                    		jne	short Do_DOS_Req
  6692 000019F9 E80E00                  		call	INSTALL_BDS
  6693 000019FC CF                      		IRET
  6694                                  Do_DOS_Req:
  6695                                  ; Set up pointer to request packet
  6696 000019FD 2E891E[B800]            		MOV	[CS:PTRSAV],BX
  6697 00001A02 2E8C06[BA00]            		MOV	[CS:PTRSAV+2],ES
  6698 00001A07 E9EEEB                  		jmp	DSK$IN
  6699                                  
  6700                                  ;
  6701                                  ; Install_BDS installs a BDS a location DS:DI into the current linked list of
  6702                                  ; BDS maintained by this device driver. It places the BDS at the END of the
  6703                                  ; list.
  6704                                  
  6705                                  INSTALL_BDS:
  6706                                  ; ds:di point to BDS to be installed
  6707 00001A0A 2EC436[1002]            		les	si,[cs:START_BDS]	; Start at beginning of list
  6708 00001A0F 06                      		push	es			; Save pointer to current BDS
  6709 00001A10 56                      		push	si
  6710                                  ; es:si now point to BDS in linked list
  6711                                  Loop_Next_BDS:
  6712 00001A11 83FEFF                  		cmp	si,-1			; got to end of linked list?
  6713 00001A14 7437                    		jz	short Install_Ret
  6714                                  ; If we have several logical drives using the same physical drive, we must
  6715                                  ; set the I_Am_Mult flag in each of the appropriate BDSs.
  6716 00001A16 8A4504                  		mov	al,[DI+BDS.DriveNum]
  6717 00001A19 26384404                		cmp	[ES:SI+BDS.DriveNum],al
  6718 00001A1D 751F                    		jnz	short Next_BDS
  6719 00001A1F 31DB                    		xor	bx,bx
  6720 00001A21 B310                    		mov	bl,fI_Am_Mult
  6721 00001A23 095D29                  		or	[DI+BDS.Flags],bx	; set flags in both BDSs concerned
  6722 00001A26 26095C29                		or	[ES:SI+BDS.Flags],bx
  6723 00001A2A B320                    		mov	bl,fI_Own_Physical
  6724 00001A2C 83F3FF                  		xor	bx,-1
  6725 00001A2F 215D29                  		and	[DI+BDS.Flags],bx	; reset that flag for 'new' BDS
  6726                                  ; We must also set the fChangeline bit correctly.
  6727 00001A32 268B5C29                		mov	bx,[ES:SI+BDS.Flags]	; determine if changeline available
  6728 00001A36 80E302                  		and	bl,fChangeline
  6729 00001A39 30FF                    		xor	bh,bh
  6730 00001A3B 095D29                  		or	[DI+BDS.Flags],bx
  6731                                  
  6732                                  Next_BDS:
  6733                                  ; Before moving to next BDS, preserve pointer to current one. This is needed at
  6734                                  ; the end when the new BDS is linked into the list.
  6735 00001A3E 5B                      		pop	bx			; discard previous pointer to BDS
  6736 00001A3F 5B                      		pop	bx
  6737 00001A40 06                      		push	es
  6738 00001A41 56                      		push	si
  6739 00001A42 268B5C02                		mov	bx,[ES:SI+BDS.Link+2]
  6740                                  		;mov	si,[ES:SI+BDS.Link]
  6741 00001A46 268B34                  		mov	si,[es:si] ; 05/07/2019
  6742 00001A49 8EC3                    		mov	es,bx
  6743 00001A4B EBC4                    		jmp	short Loop_Next_BDS
  6744                                  
  6745                                  Install_Ret:
  6746 00001A4D 5E                      		pop	si			; Retrieve pointer to last BDS
  6747 00001A4E 07                      		pop	es			; in linked list.
  6748 00001A4F 8CD8                    		mov	ax,ds
  6749 00001A51 26894402                		mov	[ES:SI+BDS.Link+2],ax	; install BDS
  6750                                  		;mov	[ES:SI+BDS.Link],di
  6751 00001A55 26893C                  		mov	[es:si],di ; 05/07/2019
  6752                                  		;mov	word [DI+BDS.Link],-1	; set NEXT pointer to NULL
  6753                                  		;mov	dword [DI+BDS.Link],-1  ; Retro DOS v3.0
  6754 00001A58 C705FFFF                		mov	word [DI],-1 ; 05/07/2019
  6755 00001A5C C3                      		retn
  6756                                  
  6757                                  ;
  6758                                  ; RE_INIT installs the Int 2F vector that will handle communication between
  6759                                  ; external block drivers and the internal driver. It also installs the
  6760                                  ; Reset_Int_13 interface. It is called by SYSYINIT
  6761                                  ;
  6762                                  
  6763                                  RE_INIT:
  6764 00001A5D 50                      		PUSH	AX
  6765 00001A5E 1E                      		PUSH	DS
  6766 00001A5F 57                      		PUSH	DI
  6767 00001A60 31FF                    		XOR	DI,DI
  6768 00001A62 8EDF                    		MOV	DS,DI
  6769 00001A64 BFBC00                  		MOV	DI,2FH*4		; point it to Int 2F Vector
  6770 00001A67 8B05                    		MOV	AX,[DI]
  6771 00001A69 2EA3[A418]              		MOV	[CS:INT_2F_NEXT],AX
  6772 00001A6D 8B4502                  		MOV	AX,[DI+2]		; preserve old Int 2F vector
  6773 00001A70 2EA3[A618]              		MOV	[CS:INT_2F_NEXT+2],AX
  6774                                  
  6775                                  ; INSTALL the Reset_Int_13
  6776                                  ; interface
  6777 00001A74 FA                      		CLI
  6778 00001A75 C705[D917]              		MOV	word [DI],INT_2F_13	; install new vectors
  6779 00001A79 8C4D02                  		MOV	[DI+2],CS
  6780 00001A7C FB                      		STI
  6781 00001A7D 5F                      		POP	DI
  6782 00001A7E 1F                      		POP	DS
  6783 00001A7F 58                      		POP	AX
  6784 00001A80 CB                      		RETF
  6785                                  
  6786                                  
  6787                                  ;-------------------------------------------------
  6788                                  ;
  6789                                  ;  Ask to swap the disk in drive A:
  6790                                  ; Using a different drive in a one drive system so
  6791                                  ; request the user to change disks
  6792                                  ;
  6793                                  
  6794                                  SWPDSK:		; 29/05/2018 - Retro DOS v3.0
  6795                                  
  6796                                  		; 13/04/2018
  6797                                  		; 09/04/2018
  6798                                  		; Retro DOS v2.0 (IBMDOS 2.1, IBMBIO.COM)
  6799                                  
  6800 00001A81 8A4505                  		mov	al,[DI+BDS.DriveLet]	; get the drive letter
  6801 00001A84 0441                    		add	al,"A"
  6802 00001A86 2EA2[C61A]              		mov	[cs:DRVLET],AL
  6803                                  
  6804 00001A8A 1E                      		push	ds			; preserve segment register
  6805 00001A8B 0E                      		push	cs
  6806 00001A8C 1F                      		pop	ds
  6807 00001A8D BE[AA1A]                		mov	SI,SNGMSG		; ds:si -> message
  6808 00001A90 53                      		push	BX
  6809                                  
  6810 00001A91 E80A00                  		call	WRMSG			;Print disk change message
  6811 00001A94 E853EC                  		call	FLUSH
  6812                                  						; wait for a keyboard character
  6813 00001A97 30E4                    		xor	AH, AH			; set command to read character
  6814 00001A99 CD16                    		int	16h			; call rom-bios
  6815 00001A9B 5B                      		POP	BX
  6816 00001A9C 1F                      		pop	ds			; restore segment register
  6817                                  WRMRET:
  6818 00001A9D C3                      		retn
  6819                                  
  6820                                  ;----------------------------------------------
  6821                                  ;
  6822                                  ;  WrMsg writes out message pointed to by [SI]
  6823                                  ;
  6824                                  
  6825                                  WRMSG:
  6826 00001A9E AC                      		lodsb				; get the next character of the message
  6827 00001A9F 08C0                    		or	AL,AL			; see if end of message
  6828 00001AA1 74FA                    		jz	short WRMRET
  6829 00001AA3 9C                      		pushf
  6830 00001AA4 0E                      		push	CS
  6831 00001AA5 E8B8EB                  		call	OUTCHR
  6832 00001AA8 EBF4                    		jmp	SHORT WRMSG
  6833                                  
  6834                                  
  6835                                  ;	INCLUDE BIOMES.INC
  6836                                  
  6837                                  ; BIOMES.INC - 24/07/1987
  6838                                  ;----------------------------------------------------------------------------
  6839                                  ;
  6840                                  ; Single drive message for msbio.com. Nul terminated.
  6841                                  ;
  6842                                  
  6843 00001AAA 0D0A496E7365727420-     SNGMSG:	DB	0Dh,0Ah,"Insert diskette for drive "
  6843 00001AB3 6469736B6574746520-
  6843 00001ABC 666F72206472697665-
  6843 00001AC5 20                 
  6844 00001AC6 413A20616E64207374-     DRVLET:	DB	"A: and strike",0Dh,0Ah,"any key when ready",0Dh,0Ah,0Ah,0
  6844 00001ACF 72696B650D0A616E79-
  6844 00001AD8 206B6579207768656E-
  6844 00001AE1 2072656164790D0A0A-
  6844 00001AEA 00                 
  6845                                  
  6846                                  ;----------------------------------------------------------------------------
  6847                                  
  6848                                  ; 01/06/2018 - Retro DOS v3.0
  6849                                  
  6850                                  ;
  6851                                  ; End of support for multiple floppies with no logical drives
  6852                                  ; This is not 'special' any more because we now have the capability of
  6853                                  ; defining logical drives in CONFIG.SYS. We therefore keep the code for
  6854                                  ; swapping resident ALL the time.
  6855                                  ;
  6856                                  
  6857                                  ;;Rev 3.30 modification ----------------------------
  6858                                  ;Variables for Dynamic Relocatable modules
  6859                                  ;These should be stay resident.
  6860                                  
  6861 00001AEB 00000000                INT6C_RET_ADDR:	DD	0	; ret add from INT 6C for P12 mach
  6862                                  
  6863                                  ;
  6864                                  ;   DATA STRUCTURES FOR REAL-TIME DATE AND TIME
  6865                                  ;
  6866                                  
  6867                                  BIN_DATE_TIME:
  6868 00001AEF 00                      	DB	0		; CENTURY (19 OR 20) OR HOURS (0-23)
  6869 00001AF0 00                      	DB	0		; YEAR IN CENTURY (0-99) OR MINUTES (0-59)
  6870 00001AF1 00                      	DB	0		; MONTH IN YEAR (1-12) OR SECONDS (0-59)
  6871 00001AF2 00                      	DB	0		; DAY IN MONTH (1-31)
  6872                                  MONTH_TABLE:
  6873 00001AF3 0000                    	DW	0		;MJB002 JANUARY
  6874 00001AF5 1F00                    	DW	31		;MJB002 FEBRUARY
  6875 00001AF7 3B00                    	DW	59		;MJB002
  6876 00001AF9 5A00                    	DW	90		;MJB002
  6877 00001AFB 7800                    	DW	120		;MJB002
  6878 00001AFD 9700                    	DW	151		;MJB002
  6879 00001AFF B500                    	DW	181		;MJB002
  6880 00001B01 D400                    	DW	212		;MJB002
  6881 00001B03 F300                    	DW	243		;MJB002
  6882 00001B05 1101                    	DW	273		;MJB002
  6883 00001B07 3001                    	DW	304		;MJB002
  6884 00001B09 4E01                    	DW	334		;MJB002
  6885                                  DAYCNT2:
  6886 00001B0B 0000                    	DW	0		;MJB002 TEMP FOR CNT OF DAYS SINCE 1-1-80
  6887                                  FEB29:
  6888 00001B0D 00                      	DB	0		;MJB002 FEBRUARY 29 IN A LEAP YEAR FLAG
  6889                                  
  6890                                  ;;End of modification ------------------------------
  6891                                  
  6892                                  EndFloppy:
  6893                                  
  6894                                  ;
  6895                                  ; End of code for virtual floppy drives
  6896                                  ;
  6897                                  
  6898                                  EndSwap:
  6899                                  
  6900                                  HNUM:	
  6901 00001B0E 00                      	DB	0			; number of hardfile (hard drives)
  6902                                  HARDDRV:
  6903 00001B0F 80                      	DB	80H			;Physical drive number of first hardfile
  6904                                  
  6905                                  
  6906                                  ;
  6907                                  ;  "HDRIVE" is a hard disk with 512 byte sectors
  6908                                  ;
  6909                                  
  6910                                  	;EVENB
  6911                                  
  6912                                  align 2
  6913                                  
  6914                                  BDSH:
  6915 00001B10 FFFF                    	DW	-1			; Link to next structure
  6916 00001B12 7000                    	DW	KERNEL_SEGMENT
  6917                                  	;DB	80h			; physical drive number
  6918                                  	; Temporary !
  6919                                  	; 25/08/2022 - IBMBIO.COM (IBMBIO33.IDB)
  6920 00001B14 50                      	db	50h
  6921 00001B15 43                      	DB	"C"                     ; Logical Drive Letter
  6922                                  HDRIVE:
  6923 00001B16 0002                    	DW	512
  6924 00001B18 01                      	DB	1			; Sectors/allocation unit
  6925 00001B19 0100                    	DW	1			; Reserved sectors for DOS
  6926 00001B1B 02                      	DB	2			; No. of allocation tables
  6927 00001B1C 1000                    	DW	16			; Number of directory entries
  6928 00001B1E 0000                    	DW	0000			; Number of sectors (at 512 bytes each)
  6929 00001B20 F8                      	DB	11111000B		; Media descriptor
  6930 00001B21 0100                    	DW	1			; Number of FAT sectors
  6931 00001B23 0000                    	DW	00			; Sector limit
  6932 00001B25 0000                    	DW	00			; Head limit
  6933 00001B27 0000                    	DW	00			; Hidden sector count
  6934 00001B29 00                      	DB	0			; TRUE => bigfat
  6935 00001B2A 0000                    OPCNTH:	DW	0			; Open Ref. Count
  6936 00001B2C 4E4F204E414D452020-     VOLIDH:	DB	"NO NAME    ",0         ; Volume ID for this disk
  6936 00001B35 202000             
  6937 00001B38 03                      	DB	3			; Form Factor
  6938 00001B39 2000                    FLAGSH:	DW	0020H			; Various Flags
  6939 00001B3B 2800                    	DW	40			; number of cylinders
  6940                                  RecBPBH:
  6941 00001B3D 00<rep 1Fh>             	times	31 db 0			; Recommended BPB for drive
  6942                                  TRACKH:	
  6943 00001B5C FF                      	DB	-1			; Last track accessed on this drive
  6944                                  TIM_LOH:
  6945 00001B5D FFFF                    	DW	-1			; Keep these two contiguous (?)
  6946                                  TIM_HIH:
  6947 00001B5F FFFF                    	DW	-1
  6948                                  
  6949                                  ;
  6950                                  ; End of single hard disk section
  6951                                  ;
  6952                                  
  6953                                  EndOneHard:
  6954                                  
  6955                                  ;
  6956                                  ;"DRIVEX" is an extra type of drive usually reserved for an
  6957                                  ; additional hard file
  6958                                  ;
  6959                                  
  6960                                  	;EVENB
  6961                                  
  6962 00001B61 90                      align 2
  6963                                  
  6964                                  BDSX:
  6965 00001B62 FFFF                    	DW	-1			; Link to next structure
  6966 00001B64 7000                    	DW	KERNEL_SEGMENT
  6967                                  	;DB	81h			; physical drive number
  6968                                  	; Temporary !
  6969                                  	; 25/08/2022 - IBMBIO.COM (IBMBIO33.IDB)
  6970 00001B66 51                      	db	51h
  6971 00001B67 44                      	DB	"D"                     ; Logical Drive Letter
  6972                                  DRIVEX:
  6973 00001B68 0002                    	DW	512
  6974 00001B6A 00                      	DB	00			; Sectors/allocation unit
  6975 00001B6B 0100                    	DW	1			; Reserved sectors for DOS
  6976 00001B6D 02                      	DB	2			; No. of allocation tables
  6977 00001B6E 0000                    	DW	0000			; Number of directory entries
  6978 00001B70 0000                    	DW	0000			; Number of sectors (at 512 bytes each)
  6979 00001B72 F8                      	DB	11111000B		; Media descriptor
  6980 00001B73 0000                    	DW	0000			; Number of FAT sectors
  6981 00001B75 0000                    	DW	00			; Sector limit
  6982 00001B77 0000                    	DW	00			; Head limit
  6983 00001B79 0000                    	DW	00			; Hidden sector count
  6984 00001B7B 00                      	DB	0			; TRUE => bigfat
  6985 00001B7C 0000                    OPCNTD:	DW	0			; Open Ref. Count
  6986 00001B7E 4E4F204E414D452020-     VOLIDD:	DB	"NO NAME    ",0         ; Volume ID for this disk
  6986 00001B87 202000             
  6987 00001B8A 03                      	DB	3			; Form Factor
  6988 00001B8B 2000                    FLAGSD:	DW	0020H			; Various Flags
  6989 00001B8D 2800                    	DW	40			; number of cylinders
  6990                                  RecBPBD:
  6991 00001B8F 00<rep 1Fh>             	times	31 db 0			; Recommended BPB for drive
  6992                                  TRACKD:
  6993 00001BAE FF                      	DB	-1			; Last track accessed on this drive
  6994                                  TIM_LOD:
  6995 00001BAF FFFF                    	DW	-1			; Keep these two contiguous
  6996                                  TIM_HID:
  6997 00001BB1 FFFF                    	DW	-1
  6998                                  
  6999                                  ;
  7000                                  ; End of section for two hard disks
  7001                                  
  7002                                  EndTwoHard:
  7003                                  
  7004                                  TWOHARD:
  7005                                  
  7006                                  ;
  7007                                  ; End of code for virtual floppy drives
  7008                                  ;
  7009                                  
  7010                                  ; include ms96tpi.inc
  7011                                  
  7012                                  ; MS96TPI.INC - 24/07/1987
  7013                                  ;----------------------------------------------------------------------------
  7014                                  ; 01/06/2018 - Retro DOS v3.0
  7015                                  ; 25/03/2018 - Retro DOS v2.0
  7016                                  
  7017                                  ;------------------------------------------------------------------------
  7018                                  ;									:
  7019                                  ; File: ms96tpi.asm							:
  7020                                  ;									:
  7021                                  ; This file contains code to support the 96 tpi drives.  The code	:
  7022                                  ; is included in the bio if the machine has at least one drive with	:
  7023                                  ; changeline support.  If the machine has no changeline drives then	:
  7024                                  ; the code is not kept in the bio at system initialization time.	:
  7025                                  ;									:
  7026                                  ;------------------------------------------------------------------------
  7027                                  
  7028                                  ;------------------------------------------------------------------------
  7029                                  ;									:
  7030                                  ;		DISK OPEN/CLOSE ROUTINES				:
  7031                                  ;									:
  7032                                  ;------------------------------------------------------------------------
  7033                                  
  7034                                  DSK$OPEN:					; AL is logical drive
  7035 00001BB3 E83FF0                  		call	SETDRIVE		; Get BDS for drive
  7036 00001BB6 FF451A                  		inc	WORD [DI+BDS.Opcnt]
  7037 00001BB9 E990EA                  		jmp	EXIT
  7038                                  
  7039                                  DSK$CLOSE:					; AL is logical drive
  7040 00001BBC E836F0                  		call	SETDRIVE		; Get BDS for drive
  7041 00001BBF 837D1A00                		cmp	WORD [DI+BDS.Opcnt],0
  7042 00001BC3 7403                    		jz	short EXITJX		; Watch out for wrap
  7043 00001BC5 FF4D1A                  		dec	WORD [DI+BDS.Opcnt]
  7044                                  EXITJX:
  7045 00001BC8 E981EA                  		jmp	EXIT
  7046                                  
  7047                                  ;
  7048                                  ; ChkOpCnt checks the number of open files on drive.
  7049                                  ;
  7050                                  ; Input : DS:DI points to current BDS for drive.
  7051                                  ;
  7052                                  ; Return : zero set if no open files
  7053                                  ;	   zero reset if open files
  7054                                  ;
  7055                                  
  7056                                  ChkOpCnt:
  7057 00001BCB 837D1A00                		cmp	WORD [DI+BDS.Opcnt],0
  7058 00001BCF C3                      		retn
  7059                                  
  7060                                  ;
  7061                                  ; At media check time, we need to really get down and check what the change is.
  7062                                  ; This is GUARANTEED to be expensive.
  7063                                  ;
  7064                                  ; On entry AL contains logical drive number
  7065                                  ;
  7066                                  
  7067                                  MediaCheck:
  7068                                  		; 01/06/2018 - Retro DOS v3.0
  7069                                  
  7070                                  		; 13/04/2018
  7071                                  		; 08/04/2018
  7072                                  		; Retro DOS v2.0
  7073                                  
  7074 00001BD0 E86CF0                  		call	CHECKSINGLE	; make sure correct disk is in place
  7075 00001BD3 31F6                    		xor	SI,SI
  7076 00001BD5 E86F01                  		call	HasChange
  7077 00001BD8 742E                    		jz	short MediaRet
  7078 00001BDA E85F01                  		call	CheckROMChange
  7079 00001BDD 752A                    		jnz	short MediaDoVolId
  7080 00001BDF 50                      		push	AX
  7081 00001BE0 52                      		push	DX
  7082                                  					; see if changeline has been triggered
  7083                                  ;;Rev 3.30 Modification
  7084 00001BE1 8A5504                  		mov	DL, [DI+BDS.DriveNum] ; set logical drive number	  
  7085 00001BE4 B416                    		mov	AH, 16h		; get changeline status	  
  7086 00001BE6 CD13                    		int	13h		; call rom diskette routine	  
  7087                                  ;;End of Modification
  7088 00001BE8 5A                      		pop	DX
  7089 00001BE9 58                      		pop	AX
  7090 00001BEA 721D                    		jc	short MediaDoVolId ; if changeline was triggered jmp
  7091 00001BEC BE0100                  		mov	SI,1		; else signal no change
  7092                                  
  7093                                  ; There are some drives with changeline that "lose" the changeline indication
  7094                                  ; if a different drive is accessed after the current one. In order to avoid
  7095                                  ; missing a media change, we return an "I don't know" to DOS if the changeline
  7096                                  ; is not active AND we are accessing a different drive from the last one.
  7097                                  ; If we are accessing the same drive, then we can safely rely on the changeline
  7098                                  ; status.
  7099                                  
  7100                                  LOSECHNG:
  7101 00001BEF 2E8A1E[1502]            		mov	bl,[cs:TIM_DRV] ; get last drive accessed
  7102 00001BF4 385D04                  		cmp	byte [DI+BDS.DriveNum],bl
  7103 00001BF7 740F                    		jz	short MediaRet
  7104                                  
  7105                                  ; Do the 2 second twiddle. If time >= 2 seconds, do a volid check.
  7106                                  ; Otherwise return "I don't know" (Strictly speaking, we should return a
  7107                                  ; "Not Changed" here since the 2 second test said no change.) - RS.
  7108                                  
  7109 00001BF9 50                      		push	ax
  7110 00001BFA 51                      		push	cx
  7111 00001BFB 52                      		push	dx
  7112 00001BFC E8EAED                  		call	CHECK_TIME_OF_ACCESS
  7113 00001BFF 5A                      		pop	dx
  7114 00001C00 59                      		pop	cx
  7115 00001C01 58                      		pop	ax
  7116 00001C02 09F6                    		or	si,si
  7117 00001C04 7403                    		jz	short MediaDoVolId ; Check_Time says ">= 2 secs passed"
  7118 00001C06 31F6                    		xor	si,si		; return "I don't know"
  7119                                  MediaRet:
  7120 00001C08 C3                      		retn
  7121                                  
  7122                                  ; 01/06/2018 - Retro DOS v3.0
  7123                                  
  7124                                  
  7125                                  ;
  7126                                  ; MediaDoVolid:  if this is called somehow the media was changed.  Look at
  7127                                  ; VID to see. We do not look at FAT because this may be different since we
  7128                                  ; only set MedByt when doing a READ or WRITE.
  7129                                  ;
  7130                                  
  7131                                  MediaDoVolId:
  7132 00001C09 E845EE                  		call	GETBP		; build a new BPB in current BDS
  7133 00001C0C 72FA                    		jc	short MediaRet
  7134 00001C0E E83400                  		call	Check_VID
  7135 00001C11 73F5                    		jnc	short MediaRet
  7136 00001C13 E8C9F2                  		call	MAPERROR	; fix up AL for return to DOS
  7137 00001C16 C3                      		retn
  7138                                  
  7139                                  ;
  7140                                  ; Checklatchio:
  7141                                  ;
  7142                                  ; Simple, quick check of latched change.  If no indication, then return
  7143                                  ; otherwise do expensive check.  If the expensive test fails, POP off the
  7144                                  ; return and set AL = 15 (for invalid media change) which will be returned to
  7145                                  ; DOS.
  7146                                  ;
  7147                                  
  7148                                  CheckLatchIO:
  7149                                  ; If returning fake BPB then assume the disk has not changed
  7150                                  ;		test	word [DI+BDS.Flags],RETURN_FAKE_BPB
  7151                                  ;		jnz	short CheckRet
  7152                                  ;;Rev 3.30 Modification
  7153 00001C17 E82D01                  		call	HasChange		;change line supported?
  7154 00001C1A 7405                    		jz	short CheckRet		;No. Just return
  7155                                  ;;End of Modification
  7156 00001C1C E8ACFF                  		call	ChkOpCnt
  7157 00001C1F 7501                    		jnz	short CheckROM
  7158                                  CheckRet:
  7159 00001C21 C3                      		retn
  7160                                  ;
  7161                                  ; Check for past ROM indications.  If no ROM change indicated, then return OK.
  7162                                  ;
  7163                                  
  7164                                  CheckROM:
  7165 00001C22 E81701                  		call	CheckROMChange
  7166 00001C25 74FA                    		jz	short CheckRet		; no change
  7167                                  ;
  7168                                  ; We now see that a change line has been seen in the past.  Let's do the
  7169                                  ; expensive verification.
  7170                                  ;
  7171 00001C27 E827EE                  		call	GETBP			; build BPB in current BDS
  7172 00001C2A 720F                    		jc	short Ret_No_Error_Map	; GETBP has already called MapError
  7173 00001C2C E81600                  		call	Check_VID
  7174 00001C2F 7207                    		jc	short CheckLatchRet	; disk error trying to read in.
  7175 00001C31 09F6                    		or	SI,SI			; Is changed for sure?
  7176 00001C33 79EC                    		jns	short CheckRet
  7177 00001C35 E84800                  		call	ReturnVID
  7178                                  CheckLatchRet:
  7179 00001C38 E8A4F2                  		call	MAPERROR		; fix up AL for return to DOS
  7180                                  Ret_No_Error_Map:
  7181 00001C3B F9                      		stc				; indicate an error
  7182 00001C3C 5E                      		pop	si			; pop off return address
  7183 00001C3D C3                      		retn
  7184                                  
  7185                                  ;
  7186                                  ;  CheckFatVID:
  7187                                  ;
  7188                                  ; Check the FAT and the VID.  Return in DI -1 or 0.  Return with carry set
  7189                                  ; ONLY if there was a disk error.  Return that error code in AX.
  7190                                  ;
  7191                                  
  7192                                  CheckFATVID:
  7193 00001C3E E80402                  		call	FAT_CHECK
  7194 00001C41 09F6                    		or	SI,SI
  7195 00001C43 7810                    		js	short Changed_Drv
  7196                                  ;
  7197                                  ; The fat was the same.  How about the volume ID?
  7198                                  ;
  7199                                  Check_VID:
  7200 00001C45 E83A01                  		call	Read_Volume_ID
  7201 00001C48 720A                    		jc	short CheckFatRet
  7202 00001C4A E8E101                  		call	Check_Volume_ID
  7203                                  
  7204 00001C4D 09F6                    		or	SI,SI
  7205 00001C4F 7504                    		jnz	short Changed_Drv
  7206 00001C51 E8EE00                  		call	ResetChanged
  7207                                  CheckFatRet:
  7208 00001C54 C3                      		retn
  7209                                  Changed_Drv:
  7210 00001C55 2EC606[1502]FF          		mov	byte [cs:TIM_DRV],-1 	; Ensure that we ask ROM for media
  7211 00001C5B C3                      		retn				; check next time round
  7212                                  
  7213                                  ;
  7214                                  ; CheckIO:  At I/O time the rom-bios returned an error.  We need to
  7215                                  ; determine if the error is due to a media change.  If error code is not
  7216                                  ; change-line error (06h) we just return.  We pop off the call and jmp to
  7217                                  ; harderr if we see an error.
  7218                                  ;
  7219                                  ;   On entry:  AH contains error code returned from rom-bios.
  7220                                  ;
  7221                                  
  7222                                  CheckIO:
  7223 00001C5C 80FC06                  		cmp	AH,6			; change line error?
  7224 00001C5F 75F3                    		jnz	short CheckFatRet	; no - just return
  7225 00001C61 E867FF                  		call	ChkOpCnt
  7226 00001C64 74EE                    		jz	short CheckFatRet	; no open files
  7227                                  ; If returning fake BPB then ignore disk changes
  7228                                  ;		test	word [DI+BDS.Flags],RETURN_FAKE_BPB
  7229                                  ;		jnz	short IgnoreChange
  7230 00001C66 E8E8ED                  		call	GETBP			; build up a new BPB in current BDS
  7231 00001C69 7212                    		jc	short No_Error_Map	; GETBP has already called MapError
  7232 00001C6B E8D0FF                  		call	CheckFATVID
  7233 00001C6E 7209                    		jc	short CheckIORet	; disk error trying to read in.
  7234 00001C70 09F6                    		or	SI,SI			; Is changed for sure?
  7235 00001C72 7802                    		js	short CheckIOErr	; yes changed
  7236                                  IgnoreChange:
  7237 00001C74 45                      		inc	BP			; allow a retry
  7238 00001C75 C3                      		retn
  7239                                  CheckIOErr:
  7240 00001C76 E80700                  		call	ReturnVID
  7241                                  CheckIORet:
  7242 00001C79 F9                      		stc				; make sure carry gets passed through
  7243 00001C7A E91EF2                  		jmp	HARDERR
  7244                                  
  7245                                  No_Error_Map:
  7246 00001C7D E91EF2                  		jmp	HARDERR2
  7247                                  
  7248                                  ;
  7249                                  ; Return VID sets up the VID for a return to DOS.
  7250                                  ;
  7251                                  
  7252                                  ReturnVID:
  7253 00001C80 1E                      		push	ds			; save pointer to current BDS
  7254 00001C81 57                      		push	di
  7255 00001C82 51                      		push	cx
  7256 00001C83 E8CF01                  		call	init_vid_loop		; Sets ES:DI -> vid
  7257 00001C86 2EC51E[B800]            		lds	bx,[cs:PTRSAV]
  7258 00001C8B 897F16                  		mov	[BX+EXTRA],DI
  7259 00001C8E 8C4718                  		mov	[BX+EXTRA+2],ES
  7260 00001C91 59                      		pop	cx
  7261 00001C92 5F                      		pop	di			; restore current BDS
  7262 00001C93 1F                      		pop	ds
  7263 00001C94 B406                    		mov	ah,6			; INVALID MEDIA CHANGE
  7264                                  		; 03/09/2022
  7265                                  		;mov	ah,0Fh			; set error as 'invalid media change'
  7266 00001C96 F9                      		stc				; indicate error by setting carry flag
  7267 00001C97 C3                      		retn
  7268                                  
  7269                                  ;
  7270                                  ; Media_Set_VID:
  7271                                  ;
  7272                                  ; Moves the pointer to the volid for the drive into the original request packet
  7273                                  ; On entry, DS:BX points to the original packet.
  7274                                  ; No attempt is made to preserve registers.
  7275                                  ;
  7276                                  
  7277                                  MEDIA_SET_VID:
  7278 00001C98 E8BA01                  		call	init_vid_loop		; Sets ES:DI -> vid
  7279 00001C9B 2EC51E[B800]            		lds	bx,[cs:PTRSAV]		; get pointer to packet
  7280 00001CA0 897F0F                  		mov	[BX+TRANS+1],DI
  7281 00001CA3 8C4711                  		mov	[BX+TRANS+3],ES
  7282 00001CA6 C3                      		retn
  7283                                  
  7284                                  ;
  7285                                  ;   HiDensity - examine a drive/media descriptor to set the media type.  If
  7286                                  ;   the media descriptor is NOT F9 (not 96tpi or 3 1/2), we return and let the
  7287                                  ;   caller do the rest.  Otherwise, we pop off the return and jump to the tail
  7288                                  ;   of GETBP. For 3.5" media, we just return.
  7289                                  ;
  7290                                  ;   Inputs:	DS:DI point to correct BDS for this drive
  7291                                  ;		AH has media byte
  7292                                  ;
  7293                                  ;   Outputs:	Carry clear
  7294                                  ;		    No registers modified
  7295                                  ;		Carry set
  7296                                  ;		    AL = sectors/fat
  7297                                  ;		    BH = number of root directory entries
  7298                                  ;		    BL = sectors per track
  7299                                  ;		    CX = number of sectors
  7300                                  ;		    DH = sectors per allocation unit
  7301                                  ;		    DL = number of heads
  7302                                  ;
  7303                                  
  7304                                  hidensity:
  7305                                  ; Check for correct drive
  7306                                  ;
  7307 00001CA7 F745290200              		test	word [DI+BDS.Flags],fChangeline	; is it special?
  7308 00001CAC 741C                    		jz	short DoFloppy		; no, do normal floppy test
  7309                                  ;
  7310                                  ; We have a media byte that is pretty complex.	Examine drive information
  7311                                  ; table to see what kind it is.
  7312                                  ;
  7313 00001CAE 807D2802                		cmp	byte [DI+BDS.FormFactor],ffSmall;  Is it single-media?
  7314 00001CB2 7416                    		jz	short DoFloppy		; yes, use fatid...
  7315                                  ;
  7316                                  ; 96 tpi drive
  7317                                  ;
  7318 00001CB4 80FCF9                  		cmp	AH,0F9h
  7319 00001CB7 7511                    		jnz	short DoFloppy
  7320 00001CB9 B007                    		mov	al,7			; seven sectors / fat
  7321 00001CBB BB0FE0                  		mov	bx,224*256+0Fh		; 224 root dir entries & 0f sector max
  7322 00001CBE B96009                  		mov	cx,80*15*2		; 80 tracks, 15 sectors/track, 2 sides
  7323 00001CC1 BA0201                  		mov	dx,1*256+2		; sectors/allocation unit & head max
  7324                                  popr:
  7325 00001CC4 83C402                  		add	SP,2			; pop off return address
  7326 00001CC7 E9FEED                  		jmp	HAS1_res		; return to tail of GETBP
  7327                                  		; Temporary !
  7328                                  		; 25/08/2022 - IBMBIO.COM (IBMBIO33.IDB) compatibiliy !
  7329                                  		;jmp	HAS1
  7330                                  
  7331                                  DoFloppy:
  7332 00001CCA C3                      		retn
  7333                                  
  7334                                  ;
  7335                                  ; Certain poorly designed programs avoid DOS altogether and use INT 13 directly.
  7336                                  ; These programs even retry operations and, thus, will ignore the disk change
  7337                                  ; logic.
  7338                                  ;
  7339                                  ; We hook INT 13 and note all errors.
  7340                                  ;
  7341                                  
  7342 00001CCB 00000000                REAL13:		dd	0
  7343 00001CCF 00000000                OLDINT:		dd	0
  7344 00001CD3 0000                    DMY:		dw	0
  7345                                  
  7346                                  INT13:
  7347                                  		; 16/06/2018
  7348 00001CD5 2E8F06[CF1C]            		pop	word [cs:OLDINT]
  7349 00001CDA 2E8F06[D11C]            		pop	word [cs:OLDINT+2]
  7350 00001CDF 2E8F06[D31C]            		pop	word [cs:DMY]
  7351 00001CE4 9C                      		pushf
  7352 00001CE5 2EFF1E[CB1C]            		call	far [cs:REAL13]	; simulate another INT 13
  7353 00001CEA 7205                    		jc	short Err13	; did an error occur?
  7354 00001CEC 2EFF2E[CF1C]            		jmp	far [cs:OLDINT]	; no, return and pop off flags
  7355                                  Err13:
  7356 00001CF1 9C                      		pushf			; save state
  7357 00001CF2 80FC06                  		cmp	AH,06h		; is error a 'change' error?
  7358 00001CF5 7406                    		jz	short GotErr	; yes, jump down
  7359                                  B:		
  7360 00001CF7 9D                      		popf			; no, some other error, ignore it ;;End of Modification
  7361 00001CF8 2EFF2E[CF1C]            		jmp	far [cs:OLDINT]	; return and pop off flags
  7362                                  
  7363                                  GotErr: 	
  7364 00001CFD 08D2                    		or	DL,DL		; is this for the hard disk?
  7365 00001CFF 78F6                    		js	short B		; yes, ignore
  7366 00001D01 2EC706[1602]4000        		mov	word [cs:FlagBits],fChanged
  7367 00001D08 E80200                  		call	Set_Changed_DL
  7368 00001D0B EBEA                    		jmp	short B
  7369                                  
  7370                                  ;
  7371                                  ; Set_Changed_DL - Sets flag bits according to bits set in [FlagBits].
  7372                                  ;		   Essentially used to indicate Changeline, or Format.
  7373                                  ;
  7374                                  ;   Inputs:	DL contains physical drive number
  7375                                  ;		[FlagBits] contains bits to set in the flag field in the BDSs
  7376                                  ;   Outputs:	None
  7377                                  ;   Registers modified: Flags
  7378                                  ;
  7379                                  
  7380                                  Set_Changed_DL:
  7381 00001D0D 53                      		push	BX
  7382 00001D0E 52                      		push	DX
  7383 00001D0F 88D3                    		mov	BL,DL
  7384                                  ALL_SET:
  7385 00001D11 2E8B16[1602]            		mov	dx,[cs:FlagBits] ; get bits to set in flag field
  7386 00001D16 30FF                    		xor	BH,BH
  7387                                  ;
  7388                                  ; In the virtual drive system we *must* flag the other drives as being changed
  7389                                  ;
  7390                                  ; assume first BDS is in this segment
  7391 00001D18 50                      		push	ax
  7392 00001D19 1E                      		push	ds		; save current BDS
  7393 00001D1A 57                      		push	di
  7394 00001D1B 2EC53E[1002]            		lds	di,[cs:START_BDS]
  7395                                  Scan_BDS:
  7396 00001D20 83FFFF                  		cmp	di,-1
  7397 00001D23 7411                    		jz	short SkipSet
  7398 00001D25 385D04                  		cmp	byte [DI+BDS.DriveNum],bl
  7399 00001D28 7503                    		jnz	short Get_Next_BDS
  7400                                  ;
  7401                                  ; Someone may complain, but this *always* must be done when a disk change is
  7402                                  ; noted.  There are *no* other compromising circumstances.
  7403                                  ;
  7404                                  SetChanged:
  7405 00001D2A 095529                  		or	[DI+BDS.Flags],dx ; signal change on other drive
  7406                                  Get_Next_BDS:
  7407 00001D2D 8B4502                  		mov	ax,[DI+BDS.Link+2]  ; go to next BDS
  7408                                  		;mov	di,[DI+BDS.Link]
  7409 00001D30 8B3D                    		mov	di,[di] ; 05/07/2019
  7410 00001D32 8ED8                    		mov	ds,ax
  7411 00001D34 EBEA                    		jmp	short Scan_BDS
  7412                                  SkipSet:
  7413 00001D36 5F                      		pop	di		    ; restore current BDS
  7414 00001D37 1F                      		pop	ds
  7415 00001D38 58                      		pop	ax
  7416 00001D39 5A                      		pop	DX
  7417 00001D3A 5B                      		pop	BX
  7418 00001D3B C3                      		retn
  7419                                  
  7420                                  ;
  7421                                  ; CheckROMChange - see if external program has diddled ROM change line.
  7422                                  ;
  7423                                  ;   Inputs:	DS:DI points to current BDS.
  7424                                  ;   Outputs:	Zero set - no change
  7425                                  ;		Zero reset - change
  7426                                  ;   Registers modified: none
  7427                                  
  7428                                  CheckROMChange:
  7429 00001D3C F745294000              		test	word [DI+BDS.Flags],fChanged
  7430 00001D41 C3                      		retn
  7431                                  
  7432                                  ;
  7433                                  ; ResetChanged - restore value of change line
  7434                                  ;
  7435                                  ;   Inputs:	DS:DI points to current BDS
  7436                                  ;   Outputs:	none
  7437                                  ;   Registers modified: none
  7438                                  
  7439                                  ResetChanged:
  7440 00001D42 836529BF                		and	word [DI+BDS.Flags],~fChanged
  7441 00001D46 C3                      		retn
  7442                                  
  7443                                  ;
  7444                                  ; HasChange - see if drive can supply change line
  7445                                  ;
  7446                                  ;   Inputs:	DS:DI points to current BDS
  7447                                  ;   Outputs:	Zero set - no change line available
  7448                                  ;		Zero reset - change line available
  7449                                  ;   Registers modified: none
  7450                                  
  7451                                  HasChange:
  7452 00001D47 F745290200              		test	word [DI+BDS.Flags],fChangeline
  7453 00001D4C C3                      		retn
  7454                                  
  7455                                  ; 01/06/2018 - Retro DOS v3.0
  7456                                  
  7457                                  ; include msvolid.inc
  7458                                  
  7459                                  ;-------------------------------------------------------------------------
  7460                                  ;
  7461                                  ;  File: msvolid.asm
  7462                                  ;	This file contains the volume_id subroutines and data structures.
  7463                                  ;
  7464                                  ;	Routines in this file are:
  7465                                  ;	   Set_Volume_ID       -	main routine, calls other routines.
  7466                                  ;	   read_volume_id      -	read the volume ID and tells if it has
  7467                                  ;					   been changed.
  7468                                  ;	   Transfer_volume_id  -	copy the volume ID from TMP to special
  7469                                  ;					   drive.
  7470                                  ;	   Check_Volume_ID     -	compare volume ID in TMP area with one
  7471                                  ;					   expected for drive.
  7472                                  ;	   Fat_Check	       -	see of the fatID has changed in the
  7473                                  ;					   specified drive.
  7474                                  ;	   Init_Vid_loop       -	set up for VID scan or move
  7475                                  ;
  7476                                  ;
  7477                                  ;-------------------------------------------------------------------------
  7478                                  
  7479                                  ;
  7480                                  ; length of the volume id
  7481                                  ;
  7482                                  
  7483                                  vid_size    equ 12
  7484                                  
  7485                                  ;
  7486                                  ; null volume id
  7487                                  ;
  7488                                  
  7489                                  nul_vid:
  7490 00001D4D 4E4F204E414D452020-     	db  "NO NAME    ",0
  7490 00001D56 202000             
  7491                                  
  7492                                  ;
  7493                                  ; data scratch area used to hold volume ids
  7494                                  ;
  7495                                  
  7496                                  tmp_vid:
  7497 00001D59 4E4F204E414D452020-     	db  "NO NAME    ",0
  7497 00001D62 202000             
  7498                                  
  7499                                  ;
  7500                                  ; Set_Volume_ID
  7501                                  ;   If drive has changeline support, read in and set the volume_ID
  7502                                  ; and the last FAT_ID byte.  If no change line support then do nothing.
  7503                                  ;
  7504                                  ;   On entry:
  7505                                  ;	DS:DI points to the BDS for this disk.
  7506                                  ;	AH contains media byte
  7507                                  ;
  7508                                  ;   On Exit:
  7509                                  ;	Carry clear:
  7510                                  ;	   Successful call
  7511                                  ;	Carry set
  7512                                  ;	   Error and AX has error code
  7513                                  ;
  7514                                  
  7515                                  Set_Volume_ID:
  7516 00001D65 52                      		push	dx		; save registers
  7517 00001D66 50                      		push	ax
  7518 00001D67 E8DDFF                  		call	HasChange	; does drive have changeline support?
  7519 00001D6A 740D                    		jz	short setvret	; no, get out
  7520 00001D6C 57                      		push	di
  7521 00001D6D E81200                  		call	Read_Volume_ID	; read the volume ID
  7522 00001D70 5F                      		pop	di
  7523 00001D71 720A                    		jc	short SetErr	; if error go to error routine
  7524 00001D73 E8A700                  		call	transfer_volume_ID ; copy the volume id to special drive
  7525 00001D76 E8C9FF                  		call	ResetChanged	; restore value of change line
  7526                                  setvret:				; SET Volume RETurn
  7527 00001D79 F8                      		clc			; no error, clear carry flag
  7528 00001D7A 58                      		pop	ax		; restore registers
  7529 00001D7B 5A                      		pop	dx
  7530 00001D7C C3                      		retn
  7531                                  SetErr:
  7532 00001D7D 5A                      		pop	dx		; pop stack but don't overwrite AX
  7533 00001D7E 5A                      		pop	dx		; restore DX
  7534 00001D7F C3                      		retn
  7535                                  
  7536                                  root_sec:
  7537 00001D80 0000                    		dw	0		;Root sector #
  7538                                  
  7539                                  ;
  7540                                  ; read_volume_id read the volume ID and tells if it has been changed.
  7541                                  ;
  7542                                  ;   On entry:
  7543                                  ;	DS:DI points to current BDS for drive.
  7544                                  ;   On Exit:
  7545                                  ;	Carry Clear
  7546                                  ;	    SI = 1  No change
  7547                                  ;	    SI = 0  ?
  7548                                  ;	    SI = -1 Change
  7549                                  ;
  7550                                  ;	Carry Set:
  7551                                  ;	    Error and AX has error code.
  7552                                  ;
  7553                                  
  7554                                  Read_Volume_ID:
  7555 00001D82 06                      		push	ES		; preserve registers
  7556 00001D83 52                      		push	DX
  7557 00001D84 51                      		push	CX
  7558 00001D85 53                      		push	BX
  7559 00001D86 50                      		push	AX
  7560 00001D87 1E                      		push	DS		; Preserve Current BDS
  7561 00001D88 57                      		push	DI
  7562 00001D89 0E                      		push	cs		; get ES segment correct
  7563 00001D8A 07                      		pop	es
  7564 00001D8B 0E                      		push	cs		; get DS segment correct
  7565 00001D8C 1F                      		pop	ds
  7566 00001D8D BF[591D]                		mov	di,tmp_vid
  7567 00001D90 BE[4D1D]                		mov	si,nul_vid
  7568 00001D93 B90C00                  		mov	cx,vid_size
  7569 00001D96 F3A4                    		rep	movsb		; initialize tmp_vid to null vi_id
  7570                                  
  7571 00001D98 5F                      		pop	DI		; Restore Current BDS
  7572 00001D99 1F                      		pop	DS
  7573 00001D9A 8A450B                  		mov	al,[DI+BDS.cFAT] ; # of fats
  7574 00001D9D 8B4D11                  		mov	cx,[DI+BDS.cSecFat] ; sectors / fat
  7575 00001DA0 F6E1                    		mul	cl			    ; size taken by fats
  7576 00001DA2 034509                  		add	ax,[DI+BDS.RESSEC] ; add on reserved sectors
  7577                                  					; AX is now sector # (0 based)
  7578 00001DA5 2EA3[801D]              		mov	[cs:root_sec],ax ; set initial value
  7579 00001DA9 8B450C                  		mov	ax,[DI+BDS.cDir] ; # root dir entries
  7580 00001DAC B104                    		mov	cl,4		; 16 entries/sector
  7581 00001DAE D3E8                    		shr	ax,cl		; divide by 16
  7582 00001DB0 89C1                    		mov	cx,ax		; cx is # of sectors to scan
  7583                                  next_sec:
  7584 00001DB2 51                      		push	cx		; save outer loop counter
  7585 00001DB3 2EA1[801D]              		mov	ax,[cs:root_sec] ; get sector #
  7586 00001DB7 8B4D13                  		mov	cx,[DI+BDS.SECLIM] ; sectors / track
  7587 00001DBA 31D2                    		xor	DX,DX
  7588 00001DBC F7F1                    		div	cx
  7589                                  				; set up registers for call to read_sector
  7590 00001DBE 42                      		inc	DX	; dx= sectors into track, ax= track count from 0
  7591 00001DBF 88D1                    		mov	cl,dl	; sector to read
  7592 00001DC1 31D2                    		xor	DX,DX
  7593 00001DC3 F77515                  		div	word [DI+BDS.HDLIM] ; # heads on this disc
  7594 00001DC6 88D6                    		mov	dh,dl	; Head number
  7595 00001DC8 88C5                    		mov	ch,al	; Track #
  7596 00001DCA E8B3ED                  		call	READ_SECTOR ; get first sector of the root directory,
  7597                                  				; ES:BX -> BOOT
  7598 00001DCD 724A                    		jc	short ReadVIDErr ; error on read
  7599 00001DCF B91000                  		mov	cx,16		; # of dir entries in a block of root
  7600 00001DD2 B008                    		mov	al,08h		; volume label bit
  7601                                  fvid_loop:
  7602 00001DD4 26803F00                		cmp	byte [es:bx],0	; End of dir?
  7603 00001DD8 743C                    		jz	short no_vid	; yes, no vol id
  7604 00001DDA 26803FE5                		cmp	byte [es:bx],0E5h ; empty entry?
  7605 00001DDE 7406                    		jz	short ent_loop	; yes, skip
  7606 00001DE0 2684470B                		test	[es:bx+11],al	; is volume label bit set in fcb?
  7607 00001DE4 7511                    		jnz	short found_vid	; jmp yes
  7608                                  ent_loop:
  7609 00001DE6 83C320                  		ADD	BX,32		;ADD LENGTH OF DIRECTORY ENTRY
  7610 00001DE9 E2E9                    		loop	fvid_loop
  7611 00001DEB 59                      		pop	cx		; outer loop
  7612 00001DEC 2EFF06[801D]            		inc	word [cs:root_sec] ; next sector
  7613 00001DF1 E2BF                    		loop	next_sec	; continue
  7614                                  NotFound:
  7615 00001DF3 31F6                    		XOR	SI,SI
  7616 00001DF5 EB18                    		jmp	short fvid_ret
  7617                                  
  7618                                  found_vid:
  7619 00001DF7 59                      		pop	cx		; clean stack of outer loop counter
  7620 00001DF8 89DE                    		mov	si,bx		; point to volume_id
  7621 00001DFA 1E                      		push	ds		; preserve currnet BDS
  7622 00001DFB 57                      		push	di
  7623 00001DFC 06                      		push	es		; es:si points to volume id.
  7624 00001DFD 1F                      		pop	ds		; source segment
  7625 00001DFE 0E                      		push	cs
  7626 00001DFF 07                      		pop	es		; destination segment
  7627 00001E00 BF[591D]                		mov	di,tmp_vid	; dest of volume_id
  7628 00001E03 B90B00                  		mov	cx,vid_size-1	; length of string minus NUL
  7629 00001E06 F3A4                    		rep	movsb		; mov volume label to tmp_vid
  7630 00001E08 30C0                    		xor	al,al
  7631 00001E0A AA                      		stosb			; Null terminate
  7632 00001E0B 31F6                    		XOR	SI,SI
  7633 00001E0D 5F                      		pop	DI		; restore current BDS
  7634 00001E0E 1F                      		pop	DS
  7635                                  fvid_ret:
  7636 00001E0F 58                      		pop	ax
  7637 00001E10 F8                      		clc
  7638                                  RVIDRet:
  7639 00001E11 5B                      		pop	BX		; restore register
  7640 00001E12 59                      		pop	CX
  7641 00001E13 5A                      		pop	DX
  7642 00001E14 07                      		pop	ES
  7643 00001E15 C3                      		retn
  7644                                  no_vid:
  7645 00001E16 59                      		pop	cx		; clean stack of outer loop counter
  7646 00001E17 EBDA                    		jmp	short NotFound	; not found
  7647                                  ReadVIDErr:
  7648 00001E19 5E                      		pop	SI
  7649 00001E1A 5E                      		pop	SI
  7650 00001E1B EBF4                    		jmp	short RVIDRet
  7651                                  
  7652                                  ;
  7653                                  ;   Transfer_volume_id - copy the volume ID from TMP to special drive
  7654                                  ;
  7655                                  ;   Inputs:	DS:DI nas current BDS
  7656                                  ;   Outputs:	BDS for drive has volume ID from TMP
  7657                                  ;
  7658                                  
  7659                                  transfer_volume_ID:
  7660 00001E1D 1E                      		push	DS		; preserve current BDS
  7661 00001E1E 57                      		push	DI
  7662 00001E1F 06                      		push	ES
  7663 00001E20 56                      		push	SI
  7664 00001E21 51                      		push	CX
  7665 00001E22 E83000                  		call	init_vid_loop
  7666 00001E25 FC                      		cld
  7667 00001E26 F3A4                    		rep	MOVSB		; transfer
  7668 00001E28 59                      		pop	CX
  7669 00001E29 5E                      		pop	SI
  7670 00001E2A 07                      		pop	ES
  7671 00001E2B 5F                      		pop	DI		; restore current BDS
  7672 00001E2C 1F                      		pop	DS
  7673 00001E2D C3                      		retn
  7674                                  
  7675                                  ;
  7676                                  ;   Check_Volume_ID - compare volume ID in TMP area with one expected for
  7677                                  ;	drive
  7678                                  ;
  7679                                  ;   Inputs:	DS:DI has current BDS for drive
  7680                                  ;   Outputs:	SI = 0 if compare succeeds
  7681                                  ;		SI = -1 if compare fails.
  7682                                  
  7683                                  Check_Volume_ID:
  7684 00001E2E 1E                      		push	DS		; preserve current BDS for drive
  7685 00001E2F 57                      		push	DI
  7686 00001E30 06                      		push	ES
  7687 00001E31 51                      		push	CX
  7688 00001E32 E82000                  		call	init_vid_loop
  7689 00001E35 FC                      		cld
  7690 00001E36 F3A6                    		repz	cmpsb		; are the 2 volume_ids the same?
  7691 00001E38 BE0000                  		mov	si,0		; assume unknown
  7692 00001E3B 7403                    		jz	short check_vid_ret ; carry clear if jump taken
  7693 00001E3D BEFFFF                  		mov	si,-1		; failure
  7694                                  check_vid_ret:
  7695 00001E40 59                      		pop	CX
  7696 00001E41 07                      		pop	ES
  7697 00001E42 5F                      		pop	DI		; restore current BDS
  7698 00001E43 1F                      		pop	DS
  7699 00001E44 C3                      		retn
  7700                                  
  7701                                  ;
  7702                                  ;   Fat_Check - see of the fatID has changed in the specified drive.
  7703                                  ;	      - uses the FAT ID obtained from the boot sector.
  7704                                  ;
  7705                                  ;   Inputs:	MedByt is expected FAT ID
  7706                                  ;		DS:DI points to current BDS
  7707                                  ;   Output:	Carry Clear
  7708                                  ;		    SI = -1 if fat ID different,
  7709                                  ;		    SI = 0 otherwise
  7710                                  ;   No other registers changed.
  7711                                  
  7712                                  FAT_CHECK:
  7713 00001E45 50                      		push	AX
  7714 00001E46 31F6                    		xor	SI,SI		; say FAT ID's are same.
  7715 00001E48 2EA0[1802]              		mov	AL,[cs:MedByt]
  7716                                  					 ; compare it with the BDS medbyte
  7717 00001E4C 3A4510                  		cmp	AL,[DI+BDS.Mediad]
  7718 00001E4F 7401                    		jz	short OkRet1	; carry clear
  7719 00001E51 4E                      		dec	SI
  7720                                  OkRet1:		
  7721 00001E52 F8                      		clc
  7722 00001E53 58                      		pop	AX
  7723 00001E54 C3                      		retn
  7724                                  
  7725                                  ;
  7726                                  ;   Init_Vid_loop - set up for VID scan or move
  7727                                  ;
  7728                                  ;   Inputs:	DS:DI pionts to BDS for the drive
  7729                                  ;   Outputs:	DS:SI points to tmp_vid
  7730                                  ;		ES:DI points to vid for drive
  7731                                  ;		CX has size for VID compare
  7732                                  ;
  7733                                  
  7734                                  init_vid_loop:
  7735 00001E55 50                      		push	ax
  7736 00001E56 1E                      		push	ds
  7737 00001E57 07                      		pop	es
  7738 00001E58 0E                      		push	cs
  7739 00001E59 1F                      		pop	ds
  7740 00001E5A BE[591D]                		mov	si,tmp_vid	; source
  7741 00001E5D 83C71C                  		add	di,BDS.Volid
  7742 00001E60 B90C00                  		mov	cx,vid_size
  7743 00001E63 58                      		pop	ax
  7744 00001E64 C3                      		retn
  7745                                  
  7746                                  ;-----------------------------------------------------------------------------
  7747                                  
  7748                                  End96tpi:
  7749                                  
  7750                                  ;Rev 3.30 modification ----------------------------
  7751                                  ;Memory allocation for BDSM table.
  7752                                  
  7753                                  BDSMs:
  7754                                  		;times BDSM.size*Max_mini_dsk_num db 0	;currently max. 23
  7755                                  
  7756                                  	; 02/08/2019
  7757                                  		%rep	Max_mini_dsk_num ; 23 
  7758                                  ;BDSM:
  7759                                  		DW	-1			; Link to next structure
  7760                                  		DW	0
  7761                                  		DB	50h			; physical drive number
  7762                                  		DB	3                    	; Logical Drive Letter
  7763                                  ;DRIVEM:
  7764                                  		DW	512
  7765                                  		;DB	0
  7766                                  		db	1	; Sectors/allocation unit
  7767                                  		DW	1			; Reserved sectors for DOS
  7768                                  		DB	2			; No. of allocation tables
  7769                                  		DW	16			; Number of directory entries
  7770                                  		DW	0			; Number of sectors (at 512 bytes each)
  7771                                  		DB	11111000b  ; 0F8h	; Media descriptor
  7772                                  		DW	1			; Number of FAT sectors
  7773                                  		DW	0			; Sector limit
  7774                                  		DW	0			; Head limit
  7775                                  		DW	0			; Hidden sector count
  7776                                  		DB	0			; TRUE => bigfat
  7777                                  ;OPCNTM:
  7778                                  		DW	0			; Open Ref. Count
  7779                                  ;VOLIDM: 
  7780                                  		db	"NO NAME    ",0	; Volume ID for this disk
  7781                                  		DB	3			; Form Factor
  7782                                  ;FLAGSM:	
  7783                                  		DW	20h			; Various Flags
  7784                                  		DW	40			; number of cylinders
  7785                                  ;RecBPBM:
  7786                                  		times	31 db 0			; Recommended BPB for drive
  7787                                  ;TRACKM:
  7788                                  		DB	-1			; Last track accessed on this drive
  7789                                  ;BDSM_ISMINI:
  7790                                  		DW	1			; Keep these two contiguous
  7791                                  ;BDSM_HIDDEN_TRKS:
  7792                                  		DW	0
  7793                                  
  7794                                  		%endrep
  7758                              <1> 
  7759 00001E65 FFFF                <1>  DW -1
  7760 00001E67 0000                <1>  DW 0
  7761 00001E69 50                  <1>  DB 50h
  7762 00001E6A 03                  <1>  DB 3
  7763                              <1> 
  7764 00001E6B 0002                <1>  DW 512
  7765                              <1> 
  7766 00001E6D 01                  <1>  db 1
  7767 00001E6E 0100                <1>  DW 1
  7768 00001E70 02                  <1>  DB 2
  7769 00001E71 1000                <1>  DW 16
  7770 00001E73 0000                <1>  DW 0
  7771 00001E75 F8                  <1>  DB 11111000b
  7772 00001E76 0100                <1>  DW 1
  7773 00001E78 0000                <1>  DW 0
  7774 00001E7A 0000                <1>  DW 0
  7775 00001E7C 0000                <1>  DW 0
  7776 00001E7E 00                  <1>  DB 0
  7777                              <1> 
  7778 00001E7F 0000                <1>  DW 0
  7779                              <1> 
  7780 00001E81 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7780 00001E8A 202000              <1>
  7781 00001E8D 03                  <1>  DB 3
  7782                              <1> 
  7783 00001E8E 2000                <1>  DW 20h
  7784 00001E90 2800                <1>  DW 40
  7785                              <1> 
  7786 00001E92 00<rep 1Fh>         <1>  times 31 db 0
  7787                              <1> 
  7788 00001EB1 FF                  <1>  DB -1
  7789                              <1> 
  7790 00001EB2 0100                <1>  DW 1
  7791                              <1> 
  7792 00001EB4 0000                <1>  DW 0
  7793                              <1> 
  7758                              <1> 
  7759 00001EB6 FFFF                <1>  DW -1
  7760 00001EB8 0000                <1>  DW 0
  7761 00001EBA 50                  <1>  DB 50h
  7762 00001EBB 03                  <1>  DB 3
  7763                              <1> 
  7764 00001EBC 0002                <1>  DW 512
  7765                              <1> 
  7766 00001EBE 01                  <1>  db 1
  7767 00001EBF 0100                <1>  DW 1
  7768 00001EC1 02                  <1>  DB 2
  7769 00001EC2 1000                <1>  DW 16
  7770 00001EC4 0000                <1>  DW 0
  7771 00001EC6 F8                  <1>  DB 11111000b
  7772 00001EC7 0100                <1>  DW 1
  7773 00001EC9 0000                <1>  DW 0
  7774 00001ECB 0000                <1>  DW 0
  7775 00001ECD 0000                <1>  DW 0
  7776 00001ECF 00                  <1>  DB 0
  7777                              <1> 
  7778 00001ED0 0000                <1>  DW 0
  7779                              <1> 
  7780 00001ED2 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7780 00001EDB 202000              <1>
  7781 00001EDE 03                  <1>  DB 3
  7782                              <1> 
  7783 00001EDF 2000                <1>  DW 20h
  7784 00001EE1 2800                <1>  DW 40
  7785                              <1> 
  7786 00001EE3 00<rep 1Fh>         <1>  times 31 db 0
  7787                              <1> 
  7788 00001F02 FF                  <1>  DB -1
  7789                              <1> 
  7790 00001F03 0100                <1>  DW 1
  7791                              <1> 
  7792 00001F05 0000                <1>  DW 0
  7793                              <1> 
  7758                              <1> 
  7759 00001F07 FFFF                <1>  DW -1
  7760 00001F09 0000                <1>  DW 0
  7761 00001F0B 50                  <1>  DB 50h
  7762 00001F0C 03                  <1>  DB 3
  7763                              <1> 
  7764 00001F0D 0002                <1>  DW 512
  7765                              <1> 
  7766 00001F0F 01                  <1>  db 1
  7767 00001F10 0100                <1>  DW 1
  7768 00001F12 02                  <1>  DB 2
  7769 00001F13 1000                <1>  DW 16
  7770 00001F15 0000                <1>  DW 0
  7771 00001F17 F8                  <1>  DB 11111000b
  7772 00001F18 0100                <1>  DW 1
  7773 00001F1A 0000                <1>  DW 0
  7774 00001F1C 0000                <1>  DW 0
  7775 00001F1E 0000                <1>  DW 0
  7776 00001F20 00                  <1>  DB 0
  7777                              <1> 
  7778 00001F21 0000                <1>  DW 0
  7779                              <1> 
  7780 00001F23 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7780 00001F2C 202000              <1>
  7781 00001F2F 03                  <1>  DB 3
  7782                              <1> 
  7783 00001F30 2000                <1>  DW 20h
  7784 00001F32 2800                <1>  DW 40
  7785                              <1> 
  7786 00001F34 00<rep 1Fh>         <1>  times 31 db 0
  7787                              <1> 
  7788 00001F53 FF                  <1>  DB -1
  7789                              <1> 
  7790 00001F54 0100                <1>  DW 1
  7791                              <1> 
  7792 00001F56 0000                <1>  DW 0
  7793                              <1> 
  7758                              <1> 
  7759 00001F58 FFFF                <1>  DW -1
  7760 00001F5A 0000                <1>  DW 0
  7761 00001F5C 50                  <1>  DB 50h
  7762 00001F5D 03                  <1>  DB 3
  7763                              <1> 
  7764 00001F5E 0002                <1>  DW 512
  7765                              <1> 
  7766 00001F60 01                  <1>  db 1
  7767 00001F61 0100                <1>  DW 1
  7768 00001F63 02                  <1>  DB 2
  7769 00001F64 1000                <1>  DW 16
  7770 00001F66 0000                <1>  DW 0
  7771 00001F68 F8                  <1>  DB 11111000b
  7772 00001F69 0100                <1>  DW 1
  7773 00001F6B 0000                <1>  DW 0
  7774 00001F6D 0000                <1>  DW 0
  7775 00001F6F 0000                <1>  DW 0
  7776 00001F71 00                  <1>  DB 0
  7777                              <1> 
  7778 00001F72 0000                <1>  DW 0
  7779                              <1> 
  7780 00001F74 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7780 00001F7D 202000              <1>
  7781 00001F80 03                  <1>  DB 3
  7782                              <1> 
  7783 00001F81 2000                <1>  DW 20h
  7784 00001F83 2800                <1>  DW 40
  7785                              <1> 
  7786 00001F85 00<rep 1Fh>         <1>  times 31 db 0
  7787                              <1> 
  7788 00001FA4 FF                  <1>  DB -1
  7789                              <1> 
  7790 00001FA5 0100                <1>  DW 1
  7791                              <1> 
  7792 00001FA7 0000                <1>  DW 0
  7793                              <1> 
  7758                              <1> 
  7759 00001FA9 FFFF                <1>  DW -1
  7760 00001FAB 0000                <1>  DW 0
  7761 00001FAD 50                  <1>  DB 50h
  7762 00001FAE 03                  <1>  DB 3
  7763                              <1> 
  7764 00001FAF 0002                <1>  DW 512
  7765                              <1> 
  7766 00001FB1 01                  <1>  db 1
  7767 00001FB2 0100                <1>  DW 1
  7768 00001FB4 02                  <1>  DB 2
  7769 00001FB5 1000                <1>  DW 16
  7770 00001FB7 0000                <1>  DW 0
  7771 00001FB9 F8                  <1>  DB 11111000b
  7772 00001FBA 0100                <1>  DW 1
  7773 00001FBC 0000                <1>  DW 0
  7774 00001FBE 0000                <1>  DW 0
  7775 00001FC0 0000                <1>  DW 0
  7776 00001FC2 00                  <1>  DB 0
  7777                              <1> 
  7778 00001FC3 0000                <1>  DW 0
  7779                              <1> 
  7780 00001FC5 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7780 00001FCE 202000              <1>
  7781 00001FD1 03                  <1>  DB 3
  7782                              <1> 
  7783 00001FD2 2000                <1>  DW 20h
  7784 00001FD4 2800                <1>  DW 40
  7785                              <1> 
  7786 00001FD6 00<rep 1Fh>         <1>  times 31 db 0
  7787                              <1> 
  7788 00001FF5 FF                  <1>  DB -1
  7789                              <1> 
  7790 00001FF6 0100                <1>  DW 1
  7791                              <1> 
  7792 00001FF8 0000                <1>  DW 0
  7793                              <1> 
  7758                              <1> 
  7759 00001FFA FFFF                <1>  DW -1
  7760 00001FFC 0000                <1>  DW 0
  7761 00001FFE 50                  <1>  DB 50h
  7762 00001FFF 03                  <1>  DB 3
  7763                              <1> 
  7764 00002000 0002                <1>  DW 512
  7765                              <1> 
  7766 00002002 01                  <1>  db 1
  7767 00002003 0100                <1>  DW 1
  7768 00002005 02                  <1>  DB 2
  7769 00002006 1000                <1>  DW 16
  7770 00002008 0000                <1>  DW 0
  7771 0000200A F8                  <1>  DB 11111000b
  7772 0000200B 0100                <1>  DW 1
  7773 0000200D 0000                <1>  DW 0
  7774 0000200F 0000                <1>  DW 0
  7775 00002011 0000                <1>  DW 0
  7776 00002013 00                  <1>  DB 0
  7777                              <1> 
  7778 00002014 0000                <1>  DW 0
  7779                              <1> 
  7780 00002016 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7780 0000201F 202000              <1>
  7781 00002022 03                  <1>  DB 3
  7782                              <1> 
  7783 00002023 2000                <1>  DW 20h
  7784 00002025 2800                <1>  DW 40
  7785                              <1> 
  7786 00002027 00<rep 1Fh>         <1>  times 31 db 0
  7787                              <1> 
  7788 00002046 FF                  <1>  DB -1
  7789                              <1> 
  7790 00002047 0100                <1>  DW 1
  7791                              <1> 
  7792 00002049 0000                <1>  DW 0
  7793                              <1> 
  7758                              <1> 
  7759 0000204B FFFF                <1>  DW -1
  7760 0000204D 0000                <1>  DW 0
  7761 0000204F 50                  <1>  DB 50h
  7762 00002050 03                  <1>  DB 3
  7763                              <1> 
  7764 00002051 0002                <1>  DW 512
  7765                              <1> 
  7766 00002053 01                  <1>  db 1
  7767 00002054 0100                <1>  DW 1
  7768 00002056 02                  <1>  DB 2
  7769 00002057 1000                <1>  DW 16
  7770 00002059 0000                <1>  DW 0
  7771 0000205B F8                  <1>  DB 11111000b
  7772 0000205C 0100                <1>  DW 1
  7773 0000205E 0000                <1>  DW 0
  7774 00002060 0000                <1>  DW 0
  7775 00002062 0000                <1>  DW 0
  7776 00002064 00                  <1>  DB 0
  7777                              <1> 
  7778 00002065 0000                <1>  DW 0
  7779                              <1> 
  7780 00002067 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7780 00002070 202000              <1>
  7781 00002073 03                  <1>  DB 3
  7782                              <1> 
  7783 00002074 2000                <1>  DW 20h
  7784 00002076 2800                <1>  DW 40
  7785                              <1> 
  7786 00002078 00<rep 1Fh>         <1>  times 31 db 0
  7787                              <1> 
  7788 00002097 FF                  <1>  DB -1
  7789                              <1> 
  7790 00002098 0100                <1>  DW 1
  7791                              <1> 
  7792 0000209A 0000                <1>  DW 0
  7793                              <1> 
  7758                              <1> 
  7759 0000209C FFFF                <1>  DW -1
  7760 0000209E 0000                <1>  DW 0
  7761 000020A0 50                  <1>  DB 50h
  7762 000020A1 03                  <1>  DB 3
  7763                              <1> 
  7764 000020A2 0002                <1>  DW 512
  7765                              <1> 
  7766 000020A4 01                  <1>  db 1
  7767 000020A5 0100                <1>  DW 1
  7768 000020A7 02                  <1>  DB 2
  7769 000020A8 1000                <1>  DW 16
  7770 000020AA 0000                <1>  DW 0
  7771 000020AC F8                  <1>  DB 11111000b
  7772 000020AD 0100                <1>  DW 1
  7773 000020AF 0000                <1>  DW 0
  7774 000020B1 0000                <1>  DW 0
  7775 000020B3 0000                <1>  DW 0
  7776 000020B5 00                  <1>  DB 0
  7777                              <1> 
  7778 000020B6 0000                <1>  DW 0
  7779                              <1> 
  7780 000020B8 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7780 000020C1 202000              <1>
  7781 000020C4 03                  <1>  DB 3
  7782                              <1> 
  7783 000020C5 2000                <1>  DW 20h
  7784 000020C7 2800                <1>  DW 40
  7785                              <1> 
  7786 000020C9 00<rep 1Fh>         <1>  times 31 db 0
  7787                              <1> 
  7788 000020E8 FF                  <1>  DB -1
  7789                              <1> 
  7790 000020E9 0100                <1>  DW 1
  7791                              <1> 
  7792 000020EB 0000                <1>  DW 0
  7793                              <1> 
  7758                              <1> 
  7759 000020ED FFFF                <1>  DW -1
  7760 000020EF 0000                <1>  DW 0
  7761 000020F1 50                  <1>  DB 50h
  7762 000020F2 03                  <1>  DB 3
  7763                              <1> 
  7764 000020F3 0002                <1>  DW 512
  7765                              <1> 
  7766 000020F5 01                  <1>  db 1
  7767 000020F6 0100                <1>  DW 1
  7768 000020F8 02                  <1>  DB 2
  7769 000020F9 1000                <1>  DW 16
  7770 000020FB 0000                <1>  DW 0
  7771 000020FD F8                  <1>  DB 11111000b
  7772 000020FE 0100                <1>  DW 1
  7773 00002100 0000                <1>  DW 0
  7774 00002102 0000                <1>  DW 0
  7775 00002104 0000                <1>  DW 0
  7776 00002106 00                  <1>  DB 0
  7777                              <1> 
  7778 00002107 0000                <1>  DW 0
  7779                              <1> 
  7780 00002109 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7780 00002112 202000              <1>
  7781 00002115 03                  <1>  DB 3
  7782                              <1> 
  7783 00002116 2000                <1>  DW 20h
  7784 00002118 2800                <1>  DW 40
  7785                              <1> 
  7786 0000211A 00<rep 1Fh>         <1>  times 31 db 0
  7787                              <1> 
  7788 00002139 FF                  <1>  DB -1
  7789                              <1> 
  7790 0000213A 0100                <1>  DW 1
  7791                              <1> 
  7792 0000213C 0000                <1>  DW 0
  7793                              <1> 
  7758                              <1> 
  7759 0000213E FFFF                <1>  DW -1
  7760 00002140 0000                <1>  DW 0
  7761 00002142 50                  <1>  DB 50h
  7762 00002143 03                  <1>  DB 3
  7763                              <1> 
  7764 00002144 0002                <1>  DW 512
  7765                              <1> 
  7766 00002146 01                  <1>  db 1
  7767 00002147 0100                <1>  DW 1
  7768 00002149 02                  <1>  DB 2
  7769 0000214A 1000                <1>  DW 16
  7770 0000214C 0000                <1>  DW 0
  7771 0000214E F8                  <1>  DB 11111000b
  7772 0000214F 0100                <1>  DW 1
  7773 00002151 0000                <1>  DW 0
  7774 00002153 0000                <1>  DW 0
  7775 00002155 0000                <1>  DW 0
  7776 00002157 00                  <1>  DB 0
  7777                              <1> 
  7778 00002158 0000                <1>  DW 0
  7779                              <1> 
  7780 0000215A 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7780 00002163 202000              <1>
  7781 00002166 03                  <1>  DB 3
  7782                              <1> 
  7783 00002167 2000                <1>  DW 20h
  7784 00002169 2800                <1>  DW 40
  7785                              <1> 
  7786 0000216B 00<rep 1Fh>         <1>  times 31 db 0
  7787                              <1> 
  7788 0000218A FF                  <1>  DB -1
  7789                              <1> 
  7790 0000218B 0100                <1>  DW 1
  7791                              <1> 
  7792 0000218D 0000                <1>  DW 0
  7793                              <1> 
  7758                              <1> 
  7759 0000218F FFFF                <1>  DW -1
  7760 00002191 0000                <1>  DW 0
  7761 00002193 50                  <1>  DB 50h
  7762 00002194 03                  <1>  DB 3
  7763                              <1> 
  7764 00002195 0002                <1>  DW 512
  7765                              <1> 
  7766 00002197 01                  <1>  db 1
  7767 00002198 0100                <1>  DW 1
  7768 0000219A 02                  <1>  DB 2
  7769 0000219B 1000                <1>  DW 16
  7770 0000219D 0000                <1>  DW 0
  7771 0000219F F8                  <1>  DB 11111000b
  7772 000021A0 0100                <1>  DW 1
  7773 000021A2 0000                <1>  DW 0
  7774 000021A4 0000                <1>  DW 0
  7775 000021A6 0000                <1>  DW 0
  7776 000021A8 00                  <1>  DB 0
  7777                              <1> 
  7778 000021A9 0000                <1>  DW 0
  7779                              <1> 
  7780 000021AB 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7780 000021B4 202000              <1>
  7781 000021B7 03                  <1>  DB 3
  7782                              <1> 
  7783 000021B8 2000                <1>  DW 20h
  7784 000021BA 2800                <1>  DW 40
  7785                              <1> 
  7786 000021BC 00<rep 1Fh>         <1>  times 31 db 0
  7787                              <1> 
  7788 000021DB FF                  <1>  DB -1
  7789                              <1> 
  7790 000021DC 0100                <1>  DW 1
  7791                              <1> 
  7792 000021DE 0000                <1>  DW 0
  7793                              <1> 
  7758                              <1> 
  7759 000021E0 FFFF                <1>  DW -1
  7760 000021E2 0000                <1>  DW 0
  7761 000021E4 50                  <1>  DB 50h
  7762 000021E5 03                  <1>  DB 3
  7763                              <1> 
  7764 000021E6 0002                <1>  DW 512
  7765                              <1> 
  7766 000021E8 01                  <1>  db 1
  7767 000021E9 0100                <1>  DW 1
  7768 000021EB 02                  <1>  DB 2
  7769 000021EC 1000                <1>  DW 16
  7770 000021EE 0000                <1>  DW 0
  7771 000021F0 F8                  <1>  DB 11111000b
  7772 000021F1 0100                <1>  DW 1
  7773 000021F3 0000                <1>  DW 0
  7774 000021F5 0000                <1>  DW 0
  7775 000021F7 0000                <1>  DW 0
  7776 000021F9 00                  <1>  DB 0
  7777                              <1> 
  7778 000021FA 0000                <1>  DW 0
  7779                              <1> 
  7780 000021FC 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7780 00002205 202000              <1>
  7781 00002208 03                  <1>  DB 3
  7782                              <1> 
  7783 00002209 2000                <1>  DW 20h
  7784 0000220B 2800                <1>  DW 40
  7785                              <1> 
  7786 0000220D 00<rep 1Fh>         <1>  times 31 db 0
  7787                              <1> 
  7788 0000222C FF                  <1>  DB -1
  7789                              <1> 
  7790 0000222D 0100                <1>  DW 1
  7791                              <1> 
  7792 0000222F 0000                <1>  DW 0
  7793                              <1> 
  7758                              <1> 
  7759 00002231 FFFF                <1>  DW -1
  7760 00002233 0000                <1>  DW 0
  7761 00002235 50                  <1>  DB 50h
  7762 00002236 03                  <1>  DB 3
  7763                              <1> 
  7764 00002237 0002                <1>  DW 512
  7765                              <1> 
  7766 00002239 01                  <1>  db 1
  7767 0000223A 0100                <1>  DW 1
  7768 0000223C 02                  <1>  DB 2
  7769 0000223D 1000                <1>  DW 16
  7770 0000223F 0000                <1>  DW 0
  7771 00002241 F8                  <1>  DB 11111000b
  7772 00002242 0100                <1>  DW 1
  7773 00002244 0000                <1>  DW 0
  7774 00002246 0000                <1>  DW 0
  7775 00002248 0000                <1>  DW 0
  7776 0000224A 00                  <1>  DB 0
  7777                              <1> 
  7778 0000224B 0000                <1>  DW 0
  7779                              <1> 
  7780 0000224D 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7780 00002256 202000              <1>
  7781 00002259 03                  <1>  DB 3
  7782                              <1> 
  7783 0000225A 2000                <1>  DW 20h
  7784 0000225C 2800                <1>  DW 40
  7785                              <1> 
  7786 0000225E 00<rep 1Fh>         <1>  times 31 db 0
  7787                              <1> 
  7788 0000227D FF                  <1>  DB -1
  7789                              <1> 
  7790 0000227E 0100                <1>  DW 1
  7791                              <1> 
  7792 00002280 0000                <1>  DW 0
  7793                              <1> 
  7758                              <1> 
  7759 00002282 FFFF                <1>  DW -1
  7760 00002284 0000                <1>  DW 0
  7761 00002286 50                  <1>  DB 50h
  7762 00002287 03                  <1>  DB 3
  7763                              <1> 
  7764 00002288 0002                <1>  DW 512
  7765                              <1> 
  7766 0000228A 01                  <1>  db 1
  7767 0000228B 0100                <1>  DW 1
  7768 0000228D 02                  <1>  DB 2
  7769 0000228E 1000                <1>  DW 16
  7770 00002290 0000                <1>  DW 0
  7771 00002292 F8                  <1>  DB 11111000b
  7772 00002293 0100                <1>  DW 1
  7773 00002295 0000                <1>  DW 0
  7774 00002297 0000                <1>  DW 0
  7775 00002299 0000                <1>  DW 0
  7776 0000229B 00                  <1>  DB 0
  7777                              <1> 
  7778 0000229C 0000                <1>  DW 0
  7779                              <1> 
  7780 0000229E 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7780 000022A7 202000              <1>
  7781 000022AA 03                  <1>  DB 3
  7782                              <1> 
  7783 000022AB 2000                <1>  DW 20h
  7784 000022AD 2800                <1>  DW 40
  7785                              <1> 
  7786 000022AF 00<rep 1Fh>         <1>  times 31 db 0
  7787                              <1> 
  7788 000022CE FF                  <1>  DB -1
  7789                              <1> 
  7790 000022CF 0100                <1>  DW 1
  7791                              <1> 
  7792 000022D1 0000                <1>  DW 0
  7793                              <1> 
  7758                              <1> 
  7759 000022D3 FFFF                <1>  DW -1
  7760 000022D5 0000                <1>  DW 0
  7761 000022D7 50                  <1>  DB 50h
  7762 000022D8 03                  <1>  DB 3
  7763                              <1> 
  7764 000022D9 0002                <1>  DW 512
  7765                              <1> 
  7766 000022DB 01                  <1>  db 1
  7767 000022DC 0100                <1>  DW 1
  7768 000022DE 02                  <1>  DB 2
  7769 000022DF 1000                <1>  DW 16
  7770 000022E1 0000                <1>  DW 0
  7771 000022E3 F8                  <1>  DB 11111000b
  7772 000022E4 0100                <1>  DW 1
  7773 000022E6 0000                <1>  DW 0
  7774 000022E8 0000                <1>  DW 0
  7775 000022EA 0000                <1>  DW 0
  7776 000022EC 00                  <1>  DB 0
  7777                              <1> 
  7778 000022ED 0000                <1>  DW 0
  7779                              <1> 
  7780 000022EF 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7780 000022F8 202000              <1>
  7781 000022FB 03                  <1>  DB 3
  7782                              <1> 
  7783 000022FC 2000                <1>  DW 20h
  7784 000022FE 2800                <1>  DW 40
  7785                              <1> 
  7786 00002300 00<rep 1Fh>         <1>  times 31 db 0
  7787                              <1> 
  7788 0000231F FF                  <1>  DB -1
  7789                              <1> 
  7790 00002320 0100                <1>  DW 1
  7791                              <1> 
  7792 00002322 0000                <1>  DW 0
  7793                              <1> 
  7758                              <1> 
  7759 00002324 FFFF                <1>  DW -1
  7760 00002326 0000                <1>  DW 0
  7761 00002328 50                  <1>  DB 50h
  7762 00002329 03                  <1>  DB 3
  7763                              <1> 
  7764 0000232A 0002                <1>  DW 512
  7765                              <1> 
  7766 0000232C 01                  <1>  db 1
  7767 0000232D 0100                <1>  DW 1
  7768 0000232F 02                  <1>  DB 2
  7769 00002330 1000                <1>  DW 16
  7770 00002332 0000                <1>  DW 0
  7771 00002334 F8                  <1>  DB 11111000b
  7772 00002335 0100                <1>  DW 1
  7773 00002337 0000                <1>  DW 0
  7774 00002339 0000                <1>  DW 0
  7775 0000233B 0000                <1>  DW 0
  7776 0000233D 00                  <1>  DB 0
  7777                              <1> 
  7778 0000233E 0000                <1>  DW 0
  7779                              <1> 
  7780 00002340 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7780 00002349 202000              <1>
  7781 0000234C 03                  <1>  DB 3
  7782                              <1> 
  7783 0000234D 2000                <1>  DW 20h
  7784 0000234F 2800                <1>  DW 40
  7785                              <1> 
  7786 00002351 00<rep 1Fh>         <1>  times 31 db 0
  7787                              <1> 
  7788 00002370 FF                  <1>  DB -1
  7789                              <1> 
  7790 00002371 0100                <1>  DW 1
  7791                              <1> 
  7792 00002373 0000                <1>  DW 0
  7793                              <1> 
  7758                              <1> 
  7759 00002375 FFFF                <1>  DW -1
  7760 00002377 0000                <1>  DW 0
  7761 00002379 50                  <1>  DB 50h
  7762 0000237A 03                  <1>  DB 3
  7763                              <1> 
  7764 0000237B 0002                <1>  DW 512
  7765                              <1> 
  7766 0000237D 01                  <1>  db 1
  7767 0000237E 0100                <1>  DW 1
  7768 00002380 02                  <1>  DB 2
  7769 00002381 1000                <1>  DW 16
  7770 00002383 0000                <1>  DW 0
  7771 00002385 F8                  <1>  DB 11111000b
  7772 00002386 0100                <1>  DW 1
  7773 00002388 0000                <1>  DW 0
  7774 0000238A 0000                <1>  DW 0
  7775 0000238C 0000                <1>  DW 0
  7776 0000238E 00                  <1>  DB 0
  7777                              <1> 
  7778 0000238F 0000                <1>  DW 0
  7779                              <1> 
  7780 00002391 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7780 0000239A 202000              <1>
  7781 0000239D 03                  <1>  DB 3
  7782                              <1> 
  7783 0000239E 2000                <1>  DW 20h
  7784 000023A0 2800                <1>  DW 40
  7785                              <1> 
  7786 000023A2 00<rep 1Fh>         <1>  times 31 db 0
  7787                              <1> 
  7788 000023C1 FF                  <1>  DB -1
  7789                              <1> 
  7790 000023C2 0100                <1>  DW 1
  7791                              <1> 
  7792 000023C4 0000                <1>  DW 0
  7793                              <1> 
  7758                              <1> 
  7759 000023C6 FFFF                <1>  DW -1
  7760 000023C8 0000                <1>  DW 0
  7761 000023CA 50                  <1>  DB 50h
  7762 000023CB 03                  <1>  DB 3
  7763                              <1> 
  7764 000023CC 0002                <1>  DW 512
  7765                              <1> 
  7766 000023CE 01                  <1>  db 1
  7767 000023CF 0100                <1>  DW 1
  7768 000023D1 02                  <1>  DB 2
  7769 000023D2 1000                <1>  DW 16
  7770 000023D4 0000                <1>  DW 0
  7771 000023D6 F8                  <1>  DB 11111000b
  7772 000023D7 0100                <1>  DW 1
  7773 000023D9 0000                <1>  DW 0
  7774 000023DB 0000                <1>  DW 0
  7775 000023DD 0000                <1>  DW 0
  7776 000023DF 00                  <1>  DB 0
  7777                              <1> 
  7778 000023E0 0000                <1>  DW 0
  7779                              <1> 
  7780 000023E2 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7780 000023EB 202000              <1>
  7781 000023EE 03                  <1>  DB 3
  7782                              <1> 
  7783 000023EF 2000                <1>  DW 20h
  7784 000023F1 2800                <1>  DW 40
  7785                              <1> 
  7786 000023F3 00<rep 1Fh>         <1>  times 31 db 0
  7787                              <1> 
  7788 00002412 FF                  <1>  DB -1
  7789                              <1> 
  7790 00002413 0100                <1>  DW 1
  7791                              <1> 
  7792 00002415 0000                <1>  DW 0
  7793                              <1> 
  7758                              <1> 
  7759 00002417 FFFF                <1>  DW -1
  7760 00002419 0000                <1>  DW 0
  7761 0000241B 50                  <1>  DB 50h
  7762 0000241C 03                  <1>  DB 3
  7763                              <1> 
  7764 0000241D 0002                <1>  DW 512
  7765                              <1> 
  7766 0000241F 01                  <1>  db 1
  7767 00002420 0100                <1>  DW 1
  7768 00002422 02                  <1>  DB 2
  7769 00002423 1000                <1>  DW 16
  7770 00002425 0000                <1>  DW 0
  7771 00002427 F8                  <1>  DB 11111000b
  7772 00002428 0100                <1>  DW 1
  7773 0000242A 0000                <1>  DW 0
  7774 0000242C 0000                <1>  DW 0
  7775 0000242E 0000                <1>  DW 0
  7776 00002430 00                  <1>  DB 0
  7777                              <1> 
  7778 00002431 0000                <1>  DW 0
  7779                              <1> 
  7780 00002433 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7780 0000243C 202000              <1>
  7781 0000243F 03                  <1>  DB 3
  7782                              <1> 
  7783 00002440 2000                <1>  DW 20h
  7784 00002442 2800                <1>  DW 40
  7785                              <1> 
  7786 00002444 00<rep 1Fh>         <1>  times 31 db 0
  7787                              <1> 
  7788 00002463 FF                  <1>  DB -1
  7789                              <1> 
  7790 00002464 0100                <1>  DW 1
  7791                              <1> 
  7792 00002466 0000                <1>  DW 0
  7793                              <1> 
  7758                              <1> 
  7759 00002468 FFFF                <1>  DW -1
  7760 0000246A 0000                <1>  DW 0
  7761 0000246C 50                  <1>  DB 50h
  7762 0000246D 03                  <1>  DB 3
  7763                              <1> 
  7764 0000246E 0002                <1>  DW 512
  7765                              <1> 
  7766 00002470 01                  <1>  db 1
  7767 00002471 0100                <1>  DW 1
  7768 00002473 02                  <1>  DB 2
  7769 00002474 1000                <1>  DW 16
  7770 00002476 0000                <1>  DW 0
  7771 00002478 F8                  <1>  DB 11111000b
  7772 00002479 0100                <1>  DW 1
  7773 0000247B 0000                <1>  DW 0
  7774 0000247D 0000                <1>  DW 0
  7775 0000247F 0000                <1>  DW 0
  7776 00002481 00                  <1>  DB 0
  7777                              <1> 
  7778 00002482 0000                <1>  DW 0
  7779                              <1> 
  7780 00002484 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7780 0000248D 202000              <1>
  7781 00002490 03                  <1>  DB 3
  7782                              <1> 
  7783 00002491 2000                <1>  DW 20h
  7784 00002493 2800                <1>  DW 40
  7785                              <1> 
  7786 00002495 00<rep 1Fh>         <1>  times 31 db 0
  7787                              <1> 
  7788 000024B4 FF                  <1>  DB -1
  7789                              <1> 
  7790 000024B5 0100                <1>  DW 1
  7791                              <1> 
  7792 000024B7 0000                <1>  DW 0
  7793                              <1> 
  7758                              <1> 
  7759 000024B9 FFFF                <1>  DW -1
  7760 000024BB 0000                <1>  DW 0
  7761 000024BD 50                  <1>  DB 50h
  7762 000024BE 03                  <1>  DB 3
  7763                              <1> 
  7764 000024BF 0002                <1>  DW 512
  7765                              <1> 
  7766 000024C1 01                  <1>  db 1
  7767 000024C2 0100                <1>  DW 1
  7768 000024C4 02                  <1>  DB 2
  7769 000024C5 1000                <1>  DW 16
  7770 000024C7 0000                <1>  DW 0
  7771 000024C9 F8                  <1>  DB 11111000b
  7772 000024CA 0100                <1>  DW 1
  7773 000024CC 0000                <1>  DW 0
  7774 000024CE 0000                <1>  DW 0
  7775 000024D0 0000                <1>  DW 0
  7776 000024D2 00                  <1>  DB 0
  7777                              <1> 
  7778 000024D3 0000                <1>  DW 0
  7779                              <1> 
  7780 000024D5 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7780 000024DE 202000              <1>
  7781 000024E1 03                  <1>  DB 3
  7782                              <1> 
  7783 000024E2 2000                <1>  DW 20h
  7784 000024E4 2800                <1>  DW 40
  7785                              <1> 
  7786 000024E6 00<rep 1Fh>         <1>  times 31 db 0
  7787                              <1> 
  7788 00002505 FF                  <1>  DB -1
  7789                              <1> 
  7790 00002506 0100                <1>  DW 1
  7791                              <1> 
  7792 00002508 0000                <1>  DW 0
  7793                              <1> 
  7758                              <1> 
  7759 0000250A FFFF                <1>  DW -1
  7760 0000250C 0000                <1>  DW 0
  7761 0000250E 50                  <1>  DB 50h
  7762 0000250F 03                  <1>  DB 3
  7763                              <1> 
  7764 00002510 0002                <1>  DW 512
  7765                              <1> 
  7766 00002512 01                  <1>  db 1
  7767 00002513 0100                <1>  DW 1
  7768 00002515 02                  <1>  DB 2
  7769 00002516 1000                <1>  DW 16
  7770 00002518 0000                <1>  DW 0
  7771 0000251A F8                  <1>  DB 11111000b
  7772 0000251B 0100                <1>  DW 1
  7773 0000251D 0000                <1>  DW 0
  7774 0000251F 0000                <1>  DW 0
  7775 00002521 0000                <1>  DW 0
  7776 00002523 00                  <1>  DB 0
  7777                              <1> 
  7778 00002524 0000                <1>  DW 0
  7779                              <1> 
  7780 00002526 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7780 0000252F 202000              <1>
  7781 00002532 03                  <1>  DB 3
  7782                              <1> 
  7783 00002533 2000                <1>  DW 20h
  7784 00002535 2800                <1>  DW 40
  7785                              <1> 
  7786 00002537 00<rep 1Fh>         <1>  times 31 db 0
  7787                              <1> 
  7788 00002556 FF                  <1>  DB -1
  7789                              <1> 
  7790 00002557 0100                <1>  DW 1
  7791                              <1> 
  7792 00002559 0000                <1>  DW 0
  7793                              <1> 
  7758                              <1> 
  7759 0000255B FFFF                <1>  DW -1
  7760 0000255D 0000                <1>  DW 0
  7761 0000255F 50                  <1>  DB 50h
  7762 00002560 03                  <1>  DB 3
  7763                              <1> 
  7764 00002561 0002                <1>  DW 512
  7765                              <1> 
  7766 00002563 01                  <1>  db 1
  7767 00002564 0100                <1>  DW 1
  7768 00002566 02                  <1>  DB 2
  7769 00002567 1000                <1>  DW 16
  7770 00002569 0000                <1>  DW 0
  7771 0000256B F8                  <1>  DB 11111000b
  7772 0000256C 0100                <1>  DW 1
  7773 0000256E 0000                <1>  DW 0
  7774 00002570 0000                <1>  DW 0
  7775 00002572 0000                <1>  DW 0
  7776 00002574 00                  <1>  DB 0
  7777                              <1> 
  7778 00002575 0000                <1>  DW 0
  7779                              <1> 
  7780 00002577 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7780 00002580 202000              <1>
  7781 00002583 03                  <1>  DB 3
  7782                              <1> 
  7783 00002584 2000                <1>  DW 20h
  7784 00002586 2800                <1>  DW 40
  7785                              <1> 
  7786 00002588 00<rep 1Fh>         <1>  times 31 db 0
  7787                              <1> 
  7788 000025A7 FF                  <1>  DB -1
  7789                              <1> 
  7790 000025A8 0100                <1>  DW 1
  7791                              <1> 
  7792 000025AA 0000                <1>  DW 0
  7793                              <1> 
  7795                                  
  7796                                  ;** End_of_BDSM defined in MSINIT.ASM will be used to set the appropriate
  7797                                  ;** ending address of BDSM table.
  7798                                  ;;End of modification ----------------------------
  7799                                  
  7800                                  ;
  7801                                  ;;3.3 BUG FIX -SP ------------------------------
  7802                                  ;Paragraph buffer between the BDSMs and MSHARD
  7803                                  ;
  7804                                  ;The relocation code for MSHARD needs this. this cannot be used for 
  7805                                  ;anything. nothing can come before this or after this.....IMPORTANT!!!!
  7806                                  ;don't get too smart and using this buffer for anything!!!!!!
  7807                                  ;
  7808 000025AC 00<rep 10h>             		times 16 db 0
  7809                                  ;
  7810                                  ;end of bug fix buffer
  7811                                  ;;
  7812                                  ;;3.3 BUG FIX -SP------------------------------
  7813                                  
  7814                                  ;-----------------------------------------------------------------------------
  7815                                  ; MSHARD.ASM - MSDOS 3.3 - 24/07/1987
  7816                                  ;-----------------------------------------------------------------------------
  7817                                  ; 02/06/2018 - Retro DOS v3.0
  7818                                  
  7819                                  ;***
  7820                                  ;	Title:	Disk
  7821                                  ;	By:	Michael Hanson
  7822                                  ;	C:	Copyright (C) 1985-1987 by Microsoft corp.
  7823                                  ;	Date:	1/11/85
  7824                                  ;
  7825                                  ;		There is a bug in some versions of IBM's AT ROM BIOS
  7826                                  ;		interupts are not disabled during read operations.
  7827                                  ;
  7828                                  ;	Use:	This program should be chained in line with the disk
  7829                                  ;		interrupt 13h, it intercepts read calls to the hard disk
  7830                                  ;		and handles them appropriately.  For other functions it
  7831                                  ;		passes controll to OLD13, which should contain the
  7832                                  ;		address of the AT ROM disk routine. The entry point for
  7833                                  ;		this program is IBM_DISK_IO.
  7834                                  ;
  7835                                  
  7836                                  	; .286c		;Use 80286 non-protected mode
  7837                                  
  7838                                  BIOSEG	equ	040h	;Segment for ROM BIOS Data
  7839                                  ROMSEG	equ	0F000h	;Segment of ROM
  7840                                  
  7841                                  BAD_DISK equ	01
  7842                                  
  7843                                  HF_PORT	equ	01F0h
  7844                                  HF_REG_PORT equ	03F6h
  7845                                  
  7846                                  ;*	Offsets into Fixed disk parameter table
  7847                                  FDP_PRECOMP	equ 5
  7848                                  FDP_CONTROL	equ 8
  7849                                  
  7850                                  ;DATA	SEGMENT AT BIOSEG	;ROM BIOS data segment
  7851                                  
  7852                                  	;ORG 42h
  7853                                  ;CMD_BLOCK	DB 6 DUP (?)
  7854                                  
  7855                                  CMD_BLOCK equ 42h ; 6 bytes, hard disk controller command bytes	
  7856                                  
  7857                                  ;*	Offsets into CMD_BLOCK for registers
  7858                                  PRE_COMP equ 0	;Write Pre-compensation
  7859                                  SEC_CNT	 equ 1	;Sector count
  7860                                  SEC_NUM	 equ 2	;Sector number
  7861                                  CYL_LOW	 equ 3	;Cylinder number, low part
  7862                                  CYL_HIGH equ 4	;Cylinder number, high part
  7863                                  DRV_HEAD equ 5	;Drive/Head (Bit 7 = ECC mode, Bit 5 = 512 byte sectors, 
  7864                                  		;            Bit 4 = drive number, Bits 3-0 have head number)
  7865                                  CMD_REG  equ 6	;Command register
  7866                                  
  7867                                  	;ORG 074h
  7868                                  
  7869                                  ;DISK_STATUS1 	DB ?
  7870                                  ;HF_NUM		DB ?
  7871                                  ;CONTROL_BYTE	DB ?
  7872                                  
  7873                                  DISK_STATUS1 equ 74h ; 1 byte
  7874                                  HF_NUM	     equ 75h ; 1 byte
  7875                                  CONTROL_BYTE equ 76h ; 1 byte 	  	
  7876                                  
  7877                                  ;DATA	ENDS
  7878                                  
  7879                                  ;***	Define where the ROM routines are actually located
  7880                                  ;ROM	SEGMENT AT ROMSEG
  7881                                  
  7882                                  	;ORG 02E1Eh
  7883                                  ;ROMCOMMAND PROC FAR
  7884                                  ;ROMCOMMAND ENDP
  7885                                  
  7886                                  ROMCOMMAND equ 02E1Eh
  7887                                  
  7888                                  	;ORG 02E7Fh
  7889                                  ;ROMWAIT PROC FAR
  7890                                  ;ROMWAIT ENDP
  7891                                  
  7892                                  ROMWAIT	equ 02E7Fh
  7893                                  
  7894                                  	;ORG 02EE2h
  7895                                  ;ROMWAIT_DRQ PROC FAR
  7896                                  ;ROMWAIT_DRQ ENDP
  7897                                  
  7898                                  ROMWAIT_DRQ equ 02EE2h
  7899                                  
  7900                                  	;ORG 02EF8h
  7901                                  ;ROMCHECK_STATUS PROC FAR
  7902                                  ;ROMCHECK_STATUS ENDP
  7903                                  
  7904                                  ROMCHECK_STATUS equ 02EF8h
  7905                                  
  7906                                  ;	ORG 02F69h
  7907                                  ;ROMCHECK_DMA PROC FAR
  7908                                  ;ROMCHECK_DMA ENDP
  7909                                   
  7910                                  ROMCHECK_DMA equ 02F69h
  7911                                  
  7912                                  ;	ORG 02F8Eh
  7913                                  ;ROMGET_VEC PROC FAR
  7914                                  ;ROMGET_VEC ENDP
  7915                                  
  7916                                  ROMGET_VEC equ 2F8Eh	
  7917                                  
  7918                                  ;	ORG 0FF65h
  7919                                  ;ROMFRET PROC FAR	;Far return at F000:FF65 in AT ROM.
  7920                                  ;ROMFRET ENDP
  7921                                  
  7922                                  ROMFRET	equ 0FF65h
  7923                                  
  7924                                  ;ROM	ENDS
  7925                                  
  7926                                  
  7927                                  ;CODE	SEGMENT BYTE PUBLIC 'code'
  7928                                  
  7929                                  ;EXTRN	OLD13:DWORD		;Link to AT bios int 13h
  7930                                  
  7931                                  ;PUBLIC	IBM_DISK_IO	
  7932                                  
  7933                                  ;	ASSUME CS:CODE
  7934                                  ;	ASSUME DS:DATA
  7935                                  
  7936                                  
  7937                                  ;***	IBM_DISK_IO - main routine, fixes AT ROM bug
  7938                                  ;
  7939                                  ;	ENTRY:	(AH) = function, 02 or 0A for read.
  7940                                  ;		(DL) = drive number (80h or 81h).
  7941                                  ;		(DH) = head number.
  7942                                  ;		(CH) = cylinder number.
  7943                                  ;		(CL) = Sector number (high 2 bits has cylinder number).
  7944                                  ;		(AL) = number of sectors.
  7945                                  ;		(ES:BX) = address of read buffer.
  7946                                  ;		For more on register contents see ROM BIOS listing.
  7947                                  ;		Stack set up for return by an IRET.
  7948                                  ;
  7949                                  ;	EXIT:	(AH) = status of current operation.
  7950                                  ;		(CY) = 1 IF failed, 0 if successful.
  7951                                  ;		For other register contents see ROM BIOS listing.
  7952                                  ;
  7953                                  ;	USES:	
  7954                                  ;
  7955                                  ;
  7956                                  ;	WARNING: Uses OLD13 vector for non-read calls.
  7957                                  ;		Does direct calls to the AT ROM.
  7958                                  ;		Does segment arithmatic.
  7959                                  ;
  7960                                  ;	EFFECTS: Performs DISK I/O operation.
  7961                                  ;
  7962                                  ;IBM_DISK_IO PROC FAR
  7963                                  
  7964                                  IBM_DISK_IO:
  7965 000025BC 80FA80                  		CMP	DL,80h
  7966 000025BF 720A                    		JB	short ATD1	;Pass through floppy disk calls.
  7967 000025C1 80FC02                  		CMP	AH,02h
  7968 000025C4 740A                    		JE	short ATD2	;Intercept call 02 (read sectors).
  7969 000025C6 80FC0A                  		CMP	AH,0Ah
  7970 000025C9 7405                    		JE	short ATD2	;and call 0Ah (read long).
  7971                                  ATD1:
  7972                                  		; 16/06/2018
  7973 000025CB 2EFF2E[B000]            		JMP	far [cs:OLD13]	;Use ROM INT 13h handler.
  7974                                  ATD2:
  7975 000025D0 53                      		PUSH	BX
  7976 000025D1 51                      		PUSH	CX
  7977 000025D2 52                      		PUSH	DX
  7978 000025D3 57                      		PUSH	DI
  7979 000025D4 1E                      		PUSH	DS
  7980 000025D5 06                      		PUSH	ES
  7981 000025D6 50                      		PUSH	AX
  7982 000025D7 B84000                  		MOV	AX,BIOSEG	;Establish BIOS segment addressing.
  7983 000025DA 8ED8                    		MOV	DS,AX
  7984 000025DC C606740000              		MOV	byte [DISK_STATUS1],0 ;Initially no error code.
  7985 000025E1 80E27F                  		AND	DL,07Fh		;Mask to hard disk number
  7986 000025E4 3A167500                		CMP	DL,[HF_NUM]
  7987 000025E8 7207                    		JB	short ATD3	;Disk number in range
  7988 000025EA C606740001              		MOV	byte [DISK_STATUS1],BAD_DISK
  7989 000025EF EB20                    		JMP	SHORT ATD4	;Disk number out of range error, return
  7990                                  
  7991                                  ATD3:
  7992 000025F1 53                      		PUSH	BX
  7993 000025F2 8CC0                    		MOV	AX,ES		;Make ES:BX to Seg:000x form.
  7994 000025F4 C1EB04                  		SHR	BX,4
  7995 000025F7 01D8                    		ADD	AX,BX
  7996 000025F9 8EC0                    		MOV	ES,AX
  7997 000025FB 5B                      		POP	BX
  7998 000025FC 83E30F                  		AND	BX,000Fh
  7999 000025FF 0E                      		PUSH	CS
  8000 00002600 E8DD00                  		CALL	CHECK_DMA
  8001 00002603 720C                    		JC	short ATD4	;Abort if DMA across segment boundary
  8002                                  
  8003 00002605 58                      		POP	AX		;Restore AX register for SETCMD
  8004 00002606 50                      		PUSH	AX
  8005 00002607 E81900                  		CALL	SETCMD		;Set up command block for disk op
  8006 0000260A BAF603                  		MOV	DX,HF_REG_PORT
  8007 0000260D EE                      		OUT	DX,AL		;Write out command modifier
  8008 0000260E E86A00                  		CALL	DOCMD		;Carry out command
  8009                                  ATD4:
  8010 00002611 58                      		POP	AX
  8011 00002612 8A267400                		MOV	AH,[DISK_STATUS1] ;On return AH has error code
  8012                                  		; 16/06/2018
  8013                                  		;STC
  8014                                  		;OR	AH,AH
  8015                                  		;JNZ	short ATD5	;Carry set if error
  8016                                  		;CLC
  8017                                  ;ATD5:
  8018 00002616 80FC01                  		cmp	ah,1
  8019 00002619 F5                      		cmc	
  8020                                  
  8021 0000261A 07                      		POP	ES
  8022 0000261B 1F                      		POP	DS
  8023 0000261C 5F                      		POP	DI
  8024 0000261D 5A                      		POP	DX
  8025 0000261E 59                      		POP	CX
  8026 0000261F 5B                      		POP	BX
  8027                                  		; 16/06/2018
  8028 00002620 CA0200                  		RETF	2		;Far return, dropping flags
  8029                                  
  8030                                  ;IBM_DISK_IO ENDP
  8031                                  
  8032                                  ;***	SETCMD - Set up CMD_BLOCK for the disk operation
  8033                                  ;
  8034                                  ;	ENTRY:	(DS) = BIOS Data segment.
  8035                                  ;		(ES:BX) in seg:000x form.
  8036                                  ;		Other registers as in INT 13h call
  8037                                  ;	
  8038                                  ;	EXIT:	CMD_BLOCK set up for disk read call.
  8039                                  ;		CONTROL_BYTE set up for disk operation.
  8040                                  ;		(AL) = Control byte modifier
  8041                                  ;
  8042                                  ;
  8043                                  ;	Sets the fields of CMD_BLOCK using the register contents
  8044                                  ;	and the contents of the disk parameter block for the given drive.
  8045                                  ;
  8046                                  ;	WARNING: (AX) destroyed.
  8047                                  ;		Does direct calls to the AT ROM.
  8048                                  ;
  8049                                  
  8050                                  ;SETCMD	PROC NEAR
  8051                                  
  8052                                  SETCMD:
  8053 00002623 A24300                  		MOV	[CMD_BLOCK+SEC_CNT],AL
  8054 00002626 C606480020              		MOV	byte [CMD_BLOCK+CMD_REG],020h ;Assume function 02
  8055 0000262B 80FC02                  		CMP	AH, 2
  8056 0000262E 7405                    		JE	short SETC1	;CMD_REG = 20h if function 02 (read)
  8057                                     					;CMD_REG = 22h if function 0A (" long)
  8058 00002630 C606480022              		MOV	byte [CMD_BLOCK+CMD_REG],022h
  8059                                  SETC1:					;No longer need value in AX
  8060 00002635 88C8                    		MOV	AL,CL
  8061 00002637 243F                    		AND	AL,03Fh		;Mask to sector number
  8062 00002639 A24400                  		MOV 	[CMD_BLOCK+SEC_NUM],AL
  8063 0000263C 882E4500                		MOV	[CMD_BLOCK+CYL_LOW],CH
  8064 00002640 88C8                    		MOV	AL,CL
  8065 00002642 C0E806                  		SHR	AL,6		;Get two high bits of cylinder number
  8066 00002645 A24600                  		MOV	[CMD_BLOCK+CYL_HIGH],AL
  8067 00002648 89D0                    		MOV	AX,DX
  8068 0000264A C0E004                  		SHL	AL,4		;Drive number
  8069 0000264D 80E40F                  		AND	AH,0Fh
  8070 00002650 08E0                    		OR	AL,AH		;Head number
  8071 00002652 0CA0                    		OR	AL,0A0h		;Set ECC and 512 bytes per sector
  8072 00002654 A24700                  		MOV	[CMD_BLOCK+DRV_HEAD],AL
  8073 00002657 06                      		PUSH	ES		;GET_VEC destroys ES:BX
  8074 00002658 53                      		PUSH	BX
  8075 00002659 0E                      		PUSH	CS
  8076 0000265A E85B00                  		CALL	GET_VEC
  8077                                  					;Write pre-comp from disk parameters
  8078 0000265D 268B4705                		MOV	AX,[ES:BX+FDP_PRECOMP]
  8079 00002661 C1E802                  		SHR	AX,2
  8080 00002664 A24200                  		MOV	[CMD_BLOCK+PRE_COMP],AL	;Only use low part
  8081 00002667 268A4708                		MOV	AL,[ES:BX+FDP_CONTROL]	;Control byte modifier
  8082 0000266B 5B                      		POP	BX
  8083 0000266C 07                      		POP	ES
  8084 0000266D 8A267600                		MOV	AH,[CONTROL_BYTE]
  8085 00002671 80E4C0                  		AND	AH,0C0h		;Keep disable retry bits
  8086 00002674 08C4                    		OR	AH,AL
  8087 00002676 88267600                		MOV	[CONTROL_BYTE],AH
  8088 0000267A C3                      		RETN
  8089                                  
  8090                                  ;SETCMD	ENDP	
  8091                                  
  8092                                  ;***	DOCMD - Carry out READ operation to AT hard disk
  8093                                  ;
  8094                                  ;	ENTRY:	(ES:BX) = address for read in data.
  8095                                  ;		CMD_BLOCK set up for disk read.
  8096                                  ;
  8097                                  ;	EXIT:	Buffer at (ES:BX) contains data read.
  8098                                  ;		DISK_STATUS1 set to error code (0 if success).
  8099                                  ;
  8100                                  ;	
  8101                                  ;
  8102                                  ;	WARNING: (AX), (BL), (CX), (DX), (DI) destroyed.
  8103                                  ;		No check is made for DMA boundary overrun.
  8104                                  ;
  8105                                  ;	EFFECTS: Programs disk controller.
  8106                                  ;		Performs disk input.
  8107                                  ;
  8108                                  
  8109                                  ;DOCMD	PROC NEAR
  8110                                  DOCMD:
  8111 0000267B 89DF                    		MOV	DI,BX	;(ES:DI) = data buffer addr.
  8112 0000267D 0E                      		PUSH	CS
  8113 0000267E E83F00                  		CALL	COMMAND
  8114 00002681 7534                    		JNZ	short DOC3
  8115                                  DOC1:
  8116 00002683 0E                      		PUSH	CS
  8117 00002684 E84100                  		CALL	_WAIT	;Wait for controller to complete read
  8118 00002687 752E                    		JNZ	short DOC3
  8119 00002689 B90001                  		MOV	CX,100h	;256 words per sector
  8120 0000268C BAF001                  		MOV	DX,HF_PORT
  8121 0000268F FC                      		CLD		;String op goes up
  8122 00002690 FA                      		CLI		;Disable interrupts (BUG WAS FORGETTING THIS)
  8123 00002691 F36D                    		REPZ	INSW	;Read in sector
  8124 00002693 FB                      		STI
  8125 00002694 F606480002              		TEST	byte [CMD_BLOCK+CMD_REG],02h
  8126 00002699 7410                    		JZ	short DOC2 ;No ECC bytes to read.
  8127 0000269B 0E                      		PUSH	CS
  8128 0000269C E83100                  		CALL	WAIT_DRQ
  8129 0000269F 7216                    		JC	short DOC3
  8130 000026A1 B90400                  		MOV	CX,4	;4 bytes of ECC
  8131 000026A4 BAF001                  		MOV	DX,HF_PORT
  8132 000026A7 FA                      		CLI
  8133 000026A8 F36C                    		REPZ	INSB	;Read in ECC
  8134 000026AA FB                      		STI
  8135                                  DOC2:
  8136 000026AB 0E                      		PUSH	CS
  8137 000026AC E82900                  		CALL	CHECK_STATUS
  8138 000026AF 7506                    		JNZ	short DOC3 ;Operation failed
  8139 000026B1 FE0E4300                		DEC	byte  [CMD_BLOCK+SEC_CNT]	
  8140 000026B5 75CC                    		JNZ	short DOC1 ;Loop while more sectors to read
  8141                                  DOC3:
  8142 000026B7 C3                      		RETN
  8143                                  
  8144                                  ;DOCMD	ENDP
  8145                                  
  8146                                  ;***	GET_VEC - Get pointer to hard disk parameters.
  8147                                  ;
  8148                                  ;	ENTRY:	(DL) = Low bit has hard disk number (0 or 1).
  8149                                  ;
  8150                                  ;	EXIT:	(ES:BX) = address of disk parameters table.
  8151                                  ;
  8152                                  ;	USES:	AX for segment computation.
  8153                                  ;
  8154                                  ;	Loads ES:BX from interrupt table in low memory, vector 46h (disk 0)
  8155                                  ;	or 70h (disk 1).
  8156                                  ;	
  8157                                  ;	WARNING: (AX) destroyed.
  8158                                  ;		This does a direct call to the AT ROM.
  8159                                  ;
  8160                                  
  8161                                  ;GET_VEC PROC NEAR
  8162                                  GET_VEC:
  8163                                  		;PUSH	OFFSET ROMFRET
  8164 000026B8 6865FF                  		push	ROMFRET
  8165                                  		;JMP	ROMGET_VEC
  8166 000026BB EA8E2F00F0              		jmp	ROMSEG:ROMGET_VEC
  8167                                  ;GET_VEC ENDP
  8168                                  
  8169                                  ;***	COMMAND - Send contents of CMD_BLOCK to disk controller.
  8170                                  ;
  8171                                  ;	ENTRY:	Control_byte 
  8172                                  ;		CMD_BLOCK - set up with values for hard disk controller.
  8173                                  ;
  8174                                  ;	EXIT:	DISK_STATUS1 = Error code.
  8175                                  ;		NZ if error, ZR for no error.
  8176                                  ;
  8177                                  ;
  8178                                  ;	WARNING: (AX), (CX), (DX) destroyed.
  8179                                  ;		Does a direct call to the AT ROM.
  8180                                  ;
  8181                                  ;	EFFECTS: Programs disk controller.
  8182                                  ;
  8183                                  
  8184                                  ;COMMAND PROC NEAR
  8185                                  COMMAND:
  8186                                  		;PUSH	OFFSET ROMFRET
  8187 000026C0 6865FF                  		push	ROMFRET	
  8188                                  		;JMP	ROMCOMMAND
  8189 000026C3 EA1E2E00F0              		jmp	ROMSEG:ROMCOMMAND
  8190                                  ;COMMAND ENDP
  8191                                  
  8192                                  ;***	WAIT - Wait for disk interrupt
  8193                                  ;
  8194                                  ;	ENTRY:	Nothing.
  8195                                  ;
  8196                                  ;	EXIT:	DISK_STATUS1 = Error code.
  8197                                  ;		NZ if error, ZR if no error.
  8198                                  ;
  8199                                  ;
  8200                                  ;	WARNING: (AX), (BL), (CX) destroyed.
  8201                                  ;		Does a direct call to the AT ROM.
  8202                                  ;		
  8203                                  ;	EFFECTS: Calls int 15h, function 9000h.
  8204                                  ;
  8205                                  
  8206                                  ;WAIT	PROC NEAR
  8207                                  _WAIT:
  8208                                  		;PUSH	OFFSET ROMFRET 
  8209 000026C8 6865FF                  		push	ROMFRET
  8210                                  		;JMP	ROMWAIT
  8211 000026CB EA7F2E00F0              		jmp	ROMSEG:ROMWAIT
  8212                                  ;WAIT	ENDP
  8213                                  
  8214                                  ;***	WAIT_DRQ - Wait for data request.
  8215                                  ;
  8216                                  ;	ENTRY:	Nothing.
  8217                                  ;
  8218                                  ;	EXIT:	DISK_STATUS1 = Error code.
  8219                                  ;		CY if error, NC if no error.
  8220                                  ;
  8221                                  ;
  8222                                  ;	WARNING: (AL), (CX), (DX) destroyed.
  8223                                  ;		Does a direct call to the AT ROM.
  8224                                  ;
  8225                                  
  8226                                  ;WAIT_DRQ PROC NEAR
  8227                                  WAIT_DRQ:
  8228                                  		;PUSH	OFFSET ROMFRET 
  8229 000026D0 6865FF                  		push	ROMFRET
  8230                                  		;JMP	ROMWAIT_DRQ
  8231 000026D3 EAE22E00F0              		jmp	ROMSEG:ROMWAIT_DRQ
  8232                                  ;WAIT_DRQ ENDP
  8233                                  
  8234                                  ;***	CHECK_STATUS - Check hard disk status.
  8235                                  ;
  8236                                  ;	ENTRY:	Nothing.
  8237                                  ;
  8238                                  ;	EXIT:	DISK_STATUS1 = Error code.
  8239                                  ;		NZ if error, ZR if no error.
  8240                                  ;
  8241                                  ;
  8242                                  ;	WARNING: (AX), (CX), (DX) destroyed.
  8243                                  ;		Does a direct call to the AT ROM.
  8244                                  ;
  8245                                  
  8246                                  ;CHECK_STATUS PROC NEAR
  8247                                  CHECK_STATUS:
  8248                                  		;PUSH	OFFSET ROMFRET 
  8249 000026D8 6865FF                  		push	ROMFRET
  8250                                  		;JMP	ROMCHECK_STATUS
  8251 000026DB EAF82E00F0              		jmp	ROMSEG:ROMCHECK_STATUS
  8252                                  ;CHECK_STATUS ENDP
  8253                                  
  8254                                  ;***	CHECK_DMA - check for DMA overrun 64k segment.
  8255                                  ;
  8256                                  ;	ENTRY:	(ES:BX) = addr. of memory buffer in seg:000x form.
  8257                                  ;		CMD_BLOCK set up for operation.
  8258                                  ;
  8259                                  ;	EXIT:	DISK_STATUS1 - Error code.
  8260                                  ;		CY if error, NC if no error.
  8261                                  ;
  8262                                  ;
  8263                                  ;	WARNING: Does a direct call to the AT ROM.
  8264                                  ;
  8265                                  
  8266                                  ;CHECK_DMA PROC NEAR
  8267                                  CHECK_DMA:
  8268                                  		;PUSH	OFFSET ROMFRET 
  8269 000026E0 6865FF                  		push	ROMFRET
  8270                                  		;JMP	ROMCHECK_DMA
  8271 000026E3 EA692F00F0              		jmp	ROMSEG:ROMCHECK_DMA	
  8272                                  ;CHECK_DMA ENDP
  8273                                  
  8274                                  
  8275                                  ;CODE	ENDS
  8276                                  ;	END
  8277                                  
  8278                                  ;-----------------------------------------------------------------------------
  8279                                  ; MSINIT.ASM - MSDOS 3.3 - 02/02/1988
  8280                                  ;-----------------------------------------------------------------------------
  8281                                  ; 02/06/2018 - Retro DOS v3.0
  8282                                  ; 19/03/2018 - Retro DOS v2.0
  8283                                  
  8284                                  ENDATROM:
  8285                                  
  8286                                  ;CMOS Clock setting support routines used by MSCLOCK.		
  8287                                  ;Warning!!! This code will be dynamically relocated by MSINIT.
  8288                                  
  8289                                  Daycnt_To_Day:
  8290                                  ;Entry: [DAYCNT] = number of days since 1-1-80
  8291                                  ;Return: CH=centry in BCD, CL=year in BCD, DH=month in BCD, DL=day in BCD
  8292                                  									 
  8293 000026E8 2EFF36[9E05]            		push	word [cs:DAYCNT]	;save daycnt			 
  8294 000026ED 2E813E[9E05]891C        		cmp	word [cs:DAYCNT], (365*20+(20/4)) 
  8295                                  						;# days from 1-1-1980 to 1-1-2000
  8296 000026F4 730E                    		jae	short century20						 
  8297 000026F6 2EC606[6708]13          		mov	byte [cs:base_century], 19					 
  8298 000026FC 2EC606[6808]50          		mov	byte [cs:base_year], 80						 
  8299 00002702 EB13                    		jmp	short years							 
  8300                                  century20:				;20th century			 
  8301 00002704 2EC606[6708]14          		mov	byte [cs:base_century], 20					 
  8302 0000270A 2EC606[6808]00          		mov	byte [cs:base_year], 0						 
  8303 00002710 2E812E[9E05]891C        		sub	word [cs:DAYCNT], (365*20+(20/4)) ;adjust daycnt			 
  8304                                  years:									 
  8305 00002717 31D2                    		xor	dx, dx							 
  8306 00002719 2EA1[9E05]              		mov	ax, [cs:DAYCNT]						 
  8307 0000271D BBB505                  		mov	bx, (366+365*3) 	;# of days in a Leap year block  
  8308 00002720 F7F3                    		div	bx			;AX = # of leap block, DX=daycnt 
  8309 00002722 2E8916[9E05]            		mov	[cs:DAYCNT], dx		;save daycnt left		 
  8310                                  ;	or	ah, ah				;ax should be less than 256	 
  8311                                  ;	jz	short OK1							 
  8312                                  ;	jmp	Erroroccur						 
  8313                                  ;OK1:									 
  8314 00002727 B304                    		mov	bl, 4							 
  8315 00002729 F6E3                    		mul	bl			;AX=# of years. Less than 100	 
  8316 0000272B 2E0006[6808]            		add	[cs:base_year], al	;So, ah = 0. Adjust year	 
  8317 00002730 2EFF06[9E05]            		inc	word [cs:DAYCNT]	;set daycnt to 1 base		 
  8318 00002735 2E813E[9E05]6E01        		cmp	word [cs:DAYCNT], 366	;daycnt=remainder of leap year bk
  8319 0000273C 7626                    		jbe	short Leapyear		;within 366+355+355+355 days.	 
  8320 0000273E 2EFE06[6808]            		inc	byte [cs:base_year]	;if daycnt <= 366, then leap year
  8321 00002743 2E812E[9E05]6E01        		sub	word [cs:DAYCNT], 366	;else daycnt--, base_year++;	 
  8322                                  					;And next three years are normal 
  8323 0000274A B90300                  		mov	cx, 3							 
  8324                                  Regularyear:								 
  8325 0000274D 2E813E[9E05]6D01        		cmp	word [cs:DAYCNT], 365	;for(i=1; i>3 or daycnt <=365;i++)
  8326 00002754 7614                    		jbe	short Yeardone		;{if (daycnt > 365)		
  8327 00002756 2EFE06[6808]            		inc	byte [cs:base_year]	;  { daycnt -= 365		
  8328 0000275B 2E812E[9E05]6D01        		sub	word [cs:DAYCNT], 365	;  }				
  8329 00002762 E2E9                    		loop	Regularyear		;}				
  8330                                  ;	jmp	Erroroccur		 ;cannot come to here		
  8331                                  Leapyear:								
  8332 00002764 2EC606[6A08]1D          		mov	byte [cs:month_tab+1],29 ;leap year. change month table. 
  8333                                  Yeardone:								
  8334 0000276A 31DB                    		xor	bx, bx							
  8335 0000276C 31D2                    		xor	dx, dx							
  8336 0000276E 2EA1[9E05]              		mov	ax, [cs:DAYCNT]						
  8337 00002772 BE[6908]                		mov	si, month_tab					
  8338 00002775 B90C00                  		mov	cx, 12							
  8339                                  Months: 								
  8340 00002778 FEC3                    		inc	bl			;				
  8341                                  		;mov	dl, [si] ; 28/03/2018
  8342 0000277A 2E8A14                  		mov	dl, [cs:si]		;cmp daycnt for each month til fit
  8343 0000277D 39D0                    		cmp	ax, dx			;dh=0.				 
  8344 0000277F 7605                    		jbe	short Month_done						 
  8345 00002781 46                      		inc	si			;next month			 
  8346 00002782 29D0                    		sub	ax, dx			;adjust daycnt			 
  8347 00002784 E2F2                    		loop	Months							 
  8348                                  ;	jmp	Erroroccur						 
  8349                                  Month_done:								 
  8350 00002786 2EC606[6A08]1C          		mov	byte [cs:month_tab+1], 28 ;restore month table value	 
  8351 0000278C 88DA                    		mov	dl, bl							 
  8352 0000278E 2E8A36[6808]            		mov	dh, [cs:base_year]						 
  8353 00002793 2E8A0E[6708]            		mov	cl, [cs:base_century]	;al=day,dl=month,dh=year,cl=cntry
  8354 00002798 2EFF16[7508]            		call	word [cs:BinToBCD]	;To save 15 bytes, Bin_To_BCD proc
  8355                                  						;was rel from Daycnt_to_Day proc. 
  8356                                  ;	call Bin_To_BCD 			;convert "day" to bcd             
  8357 0000279D 86D0                    		xchg	dl, al			;dl = bcd day, al = month	  
  8358 0000279F 2EFF16[7508]            		call	word [cs:BinToBCD]					  
  8359                                  ;	call Bin_To_BCD 						  
  8360 000027A4 86F0                    		xchg	dh, al			;dh = bcd month, al = year	  
  8361 000027A6 2EFF16[7508]            		call	word [cs:BinToBCD]					  
  8362                                  ;	call Bin_To_BCD 						  
  8363 000027AB 86C8                    		xchg	cl, al			;cl = bcd year, al = century	 
  8364 000027AD 2EFF16[7508]            		call	word [cs:BinToBCD]					 
  8365                                  ;	call Bin_To_BCD						 
  8366 000027B2 88C5                    		mov	ch, al			;ch = bcd century		 
  8367 000027B4 2E8F06[9E05]            		pop	word [cs:DAYCNT]	;restore original value 	 
  8368 000027B9 C3                      		retn								 
  8369                                  						 
  8370                                  	;public	EndDaycntToDay						 
  8371                                  EndDaycntToDay:						 
  8372                                  									 
  8373                                  	;public	Bin_To_BCD						 
  8374                                  Bin_To_BCD:			; real time clock sup
  8375                                  ;Convert a binary input in AL (less than 63h or 99 decimal)
  8376                                  ;into a bcd value in AL.  AH destroyed. 			
  8377 000027BA 51                      		push	cx						
  8378 000027BB 30E4                    		xor	ah, ah						
  8379 000027BD B10A                    		mov	cl, 10						
  8380 000027BF F6F1                    		div	cl			;al=high digit bcd, ah=low digit bcd
  8381 000027C1 B104                    		mov	cl, 4						
  8382 000027C3 D2E0                    		shl	al, cl			;mov the high digit to high nibble
  8383 000027C5 08E0                    		or	al, ah							
  8384 000027C7 59                      		pop	cx							
  8385 000027C8 C3                      		retn								
  8386                                  					
  8387                                  	;Public	EndCMOSClockset 	;End of routines for CMOS clock 
  8388                                  EndCMOSClockSet:
  8389                                  
  8390                                  		;evenb
  8391 000027C9 90                      align 2
  8392                                  
  8393                                  ; 02/06/2018 - Retro DOS v3.0
  8394                                  
  8395                                  ;									
  8396                                  ; THE K09 REQUIRES ROUTINES FOR READING THE CLOCK BECAUSE OF THE SUSPEND/
  8397                                  ; RESUME FACILITY. THE SYSTEM CLOCK NEEDS TO BE RESET AFTER RESUME.	 
  8398                                  ;
  8399                                  
  8400                                  ;	ASSUME	ES:NOTHING									 
  8401                                  									 
  8402                                  ; THE FOLLOWING ROUTINE IS EXECUTED AT RESUME TIME WHEN THE SYSTEM	 
  8403                                  ; POWERED ON AFTER SUSPENSION. IT READS THE REAL TIME CLOCK AND 	 
  8404                                  ; RESETS THE SYSTEM TIME AND DATE, AND THEN IRETS.			 
  8405                                  ; Warning!!! This code will be dynamically relocated by MSINIT.
  8406                                  
  8407                                  ;INT6C	PROC	FAR							 
  8408                                  
  8409                                  INT6C:
  8410 000027CA 0E                      		PUSH	CS							 
  8411 000027CB 1F                      		POP	DS							 
  8412                                  									 
  8413                                  	;ASSUME DS:CODE							 
  8414                                  									 
  8415 000027CC 8F06[EB1A]              		POP	WORD [INT6C_RET_ADDR] ; POP OFF RETURN ADDRESS	 
  8416 000027D0 8F06[ED1A]              		POP	WORD [INT6C_RET_ADDR+2]				 
  8417 000027D4 9D                      		POPF								 
  8418 000027D5 E81300                  		CALL	READ_REAL_DATE		; GET THE DATE FROM THE CLOCK	 
  8419 000027D8 FA                      		CLI								 
  8420 000027D9 8936[9E05]              		MOV	[DAYCNT],SI		; UPDATE DOS COPY OF DATE 	 
  8421 000027DD FB                      		STI								 
  8422 000027DE E8C100                  		CALL	READ_REAL_TIME		; GET THE TIME FROM THE RTC	 
  8423 000027E1 FA                      		CLI								 
  8424 000027E2 B401                    		MOV	AH,01h			; COMMAND TO SET THE TIME
  8425 000027E4 CD1A                    		INT	1Ah			; CALL ROM-BIOS TIME ROUTINE 
  8426 000027E6 FB                      		STI								
  8427 000027E7 FF2E[EB1A]              		JMP	far [INT6C_RET_ADDR]	; LONG JUMP			
  8428                                  									
  8429                                  ;INT6C	ENDP
  8430                                  
  8431                                  	;INCLUDE READCLOCK.INC						
  8432                                  	;INCLUDE CLOCKSUB.INC								
  8433                                  
  8434                                  ; 26/03/2018 - READCLOCK.INC, MSDOS 3.3, 24/07/1987
  8435                                  
  8436                                  ;************************************************************************
  8437                                  ;
  8438                                  ;   read_real_date reads real-time clock for date and returns the number
  8439                                  ;   of days elapsed since 1-1-80 in si
  8440                                  ;
  8441                                  READ_REAL_DATE: 			;MJB002
  8442 000027EB 50                      		PUSH	AX
  8443 000027EC 51                      		PUSH	CX
  8444 000027ED 52                      		PUSH	DX
  8445 000027EE 30E4                    		XOR	AH,AH		; throw away clock roll over
  8446 000027F0 CD1A                    		INT	1AH					
  8447 000027F2 5A                      		POP	DX
  8448 000027F3 59                      		POP	CX
  8449 000027F4 58                      		POP	AX
  8450                                  
  8451 000027F5 50                      		PUSH	AX
  8452 000027F6 53                      		PUSH	BX
  8453 000027F7 51                      		PUSH	CX
  8454 000027F8 52                      		PUSH	DX
  8455                                  		;mov	word [CS:DAYCNT2],1 ; REAL TIME CLOCK ERROR FLAG (+1 DAY)
  8456 000027F9 C706[0B1B]0100          		mov	word [DAYCNT2],1
  8457 000027FF B404                    		mov	AH,4		; read date function code       
  8458 00002801 CD1A                    		int	1Ah		; read real-time clock	     
  8459                                  		; 03/09/2022
  8460 00002803 7303                    		jnc	short read_ok 	; jmp success
  8461 00002805 E98B00                  		jmp	r_d_ret 	; jmp error
  8462                                  read_ok:				; ******* get bcd values in binary *****
  8463 00002808 882E[EF1A]              		mov	[BIN_DATE_TIME+0],ch  ; store as hex value
  8464 0000280C 880E[F01A]              		mov	[BIN_DATE_TIME+1],cl  ; ...
  8465 00002810 8836[F11A]              		mov	[BIN_DATE_TIME+2],dh  ; ...
  8466 00002814 8816[F21A]              		mov	[BIN_DATE_TIME+3],dl  ; ...
  8467                                  		;mov	word [CS:DAYCNT2],2  ; READ OF R-T CLOCK SUCCESSFUL
  8468 00002818 C706[0B1B]0200          		mov	word [DAYCNT2],2
  8469 0000281E E84C01                  		call	bcd_verify	; verify bcd values in range
  8470 00002821 7270                    		jc	short r_d_ret 	; jmp some value out of range
  8471                                  		;mov	word [CS:DAYCNT2],3  ; READ OF R-T CLOCK SUCCESSFUL
  8472 00002823 C706[0B1B]0300          		mov	word [DAYCNT2],3
  8473 00002829 E8EA00                  		call	date_verify	; verify date values in range
  8474 0000282C 7265                    		jc	short r_d_ret 	; jmp some value out of range
  8475                                  		;mov	word [CS:DAYCNT2],0  ; VERIFY SUCCESSFUL		  
  8476 0000282E C706[0B1B]0000          		mov	word [DAYCNT2],0
  8477 00002834 E8A400                  		call	in_bin		; convert date to binary
  8478                                  					; ******* years since 1-1-80 *********
  8479 00002837 A0[F01A]                		mov	al,[BIN_DATE_TIME+1]  ; get years into century
  8480 0000283A 98                      		cbw				     ;
  8481 0000283B 803E[EF1A]14            		cmp	byte [BIN_DATE_TIME+0],20  ; 20th century?
  8482 00002840 7503                    		jnz	short century_19 ; jmp no
  8483 00002842 83C064                  		add	ax,100		; add in a century
  8484                                  century_19:			;
  8485 00002845 83E850                  		sub	ax,80		; subtract off 1-1-80
  8486 00002848 B104                    		mov	cl,4		; leap year every 4
  8487 0000284A F6F1                    		div	cl		; al= # leap year blocks, ah= remainder
  8488 0000284C 88E3                    		mov	bl,ah		; save odd years
  8489 0000284E 98                      		cbw			; zero ah
  8490 0000284F B9B505                  		mov	cx,366+3*365	; # of days in leap year blocks
  8491 00002852 F7E1                    		mul	cx		; dx:ax is result
  8492                                  		;mov	[CS:DAYCNT2],AX	; SAVE COUNT OF DAYS
  8493 00002854 A3[0B1B]                		mov	[DAYCNT2],AX
  8494 00002857 88D8                    		mov	al,bl		; get odd years count
  8495 00002859 98                      		cbw			;
  8496 0000285A 09C0                    		or	ax,ax		; is ax= 0?
  8497 0000285C 740B                    		jz	short leap_year	; jmp if none
  8498 0000285E B96D01                  		mov	cx,365		; days in year
  8499 00002861 F7E1                    		mul	cx		; dx:ax is result
  8500                                  		;add	[CS:DAYCNT2],AX ; ADD ON DAYS IN ODD YEARS
  8501 00002863 0106[0B1B]              		add	[DAYCNT2],AX
  8502 00002867 EB07                    		jmp	short leap_adjustment ; account for leap year
  8503                                  leap_year:			; possibly account for a leap day
  8504 00002869 803E[F11A]02            		cmp	byte [BIN_DATE_TIME+2],2 ; is month february
  8505 0000286E 7604                    		jbe	short no_leap_adjustment ; jan or feb. no leap day yet.
  8506                                  leap_adjustment:			; account for leap day
  8507                                  		;INC	word [CS:DAYCNT2] ; ...
  8508 00002870 FF06[0B1B]              		INC	word [DAYCNT2]
  8509                                  no_leap_adjustment:			; ******* get days of month *******
  8510 00002874 8A0E[F21A]              		mov	cl,[BIN_DATE_TIME+3] ; ...
  8511 00002878 30ED                    		xor	ch,ch		;
  8512 0000287A 49                      		dec	cx		; because of offset from day 1, not day 0
  8513                                  		;add	[CS:DAYCNT2],CX	; ******* GET DAYS IN MONTHS PRECEEDING *****
  8514 0000287B 010E[0B1B]              		add	[DAYCNT2],CX
  8515 0000287F 8A0E[F11A]              		mov	cl,[BIN_DATE_TIME+2] ; get month
  8516 00002883 30ED                    		xor	ch,ch		;
  8517 00002885 49                      		dec	cx		; january starts at offset 0
  8518 00002886 D1E1                    		shl	cx,1		; word offset
  8519 00002888 BE[F31A]                		mov	si,MONTH_TABLE	; beginning of month_table
  8520 0000288B 01CE                    		add	si,cx		; point into month table
  8521 0000288D 8B04                    		mov	ax,[si]		; get # days in previous months
  8522                                  		;add	[CS:DAYCNT2],AX ; ...
  8523 0000288F 0106[0B1B]              		add	[DAYCNT2],AX
  8524                                  r_d_ret:			;
  8525                                  		;MOV	SI,[CS:DAYCNT2] ; RESULT IN SI
  8526 00002893 8B36[0B1B]              		MOV	SI,[DAYCNT2]
  8527 00002897 5A                      		POP	DX
  8528 00002898 59                      		POP	CX
  8529 00002899 5B                      		POP	BX
  8530 0000289A 58                      		POP	AX
  8531 0000289B C3                      		retn			;
  8532                                  
  8533                                  r_t_retj:
  8534 0000289C 31C9                    		xor	cx,cx
  8535 0000289E 31D2                    		xor	dx,dx
  8536 000028A0 EB38                    		jmp	short r_t_ret
  8537                                  ;
  8538                                  ; Read_Real_Time reads the time from the RTC. on exit, it has the number of
  8539                                  ; ticks (at 18.2 ticks per sec.) in CX:DX.
  8540                                  ;
  8541                                  READ_REAL_TIME:
  8542 000028A2 B402                    		mov	ah,2
  8543 000028A4 CD1A                    		int	1AH
  8544 000028A6 72F4                    		jc	short r_t_retj
  8545                                  oktime:
  8546 000028A8 882E[EF1A]              		mov	[BIN_DATE_TIME],ch		; hours
  8547 000028AC 880E[F01A]              		mov	[BIN_DATE_TIME+1],cl		; minutes
  8548 000028B0 8836[F11A]              		mov	[BIN_DATE_TIME+2],dh		; seconds
  8549 000028B4 C606[F21A]00            		mov	byte [BIN_DATE_TIME+3],0	; unused for time
  8550 000028B9 E8B100                  		call	bcd_verify
  8551 000028BC 72DE                    		jc	short r_t_retj
  8552 000028BE E89300                  		call	time_verify
  8553 000028C1 72D9                    		jc	short r_t_retj
  8554 000028C3 E81500                  		call	in_bin
  8555 000028C6 8A2E[EF1A]              		mov	ch,[BIN_DATE_TIME]
  8556 000028CA 8A0E[F01A]              		mov	cl,[BIN_DATE_TIME+1]
  8557 000028CE 8A36[F11A]              		mov	dh,[BIN_DATE_TIME+2]
  8558 000028D2 8A16[F21A]              		mov	dl,[BIN_DATE_TIME+3]
  8559                                  ; get time in ticks in CX:DX
  8560                                  		;CALL	near [cs:TimeToTicks]
  8561 000028D6 FF16[7908]              		CALL	word [TimeToTicks]
  8562                                  r_t_ret:
  8563 000028DA C3                      		retn
  8564                                  
  8565                                  ;
  8566                                  ;   in_bin converts bin_date_time values from bcd to bin
  8567                                  ;
  8568                                  in_bin: 			      ;
  8569 000028DB A0[EF1A]                		mov	al,[BIN_DATE_TIME+0]  ; century or hours
  8570 000028DE E81F00                  		call	bcd_to_bin	      ; ...
  8571 000028E1 A2[EF1A]                		mov	[BIN_DATE_TIME+0],al  ;
  8572 000028E4 A0[F01A]                		mov	al,[BIN_DATE_TIME+1]  ; years or minutes
  8573 000028E7 E81600                  		call	bcd_to_bin	      ; ...
  8574 000028EA A2[F01A]                		mov	[BIN_DATE_TIME+1],al  ;
  8575 000028ED A0[F11A]                		mov	al,[BIN_DATE_TIME+2]  ; months or seconds
  8576 000028F0 E80D00                  		call	bcd_to_bin	      ; ...
  8577 000028F3 A2[F11A]                		mov	[BIN_DATE_TIME+2],al  ;
  8578 000028F6 A0[F21A]                		mov	al,[BIN_DATE_TIME+3]  ; days (not used for time)
  8579 000028F9 E80400                  		call	bcd_to_bin	      ; ...
  8580 000028FC A2[F21A]                		mov	[BIN_DATE_TIME+3],al  ;
  8581 000028FF C3                      		retn			      ;
  8582                                  ;
  8583                                  ;   bcd_to_bin converts two bcd nibbles in al (value <= 99.) to
  8584                                  ;   a binary representation in al
  8585                                  ;   ah is destroyed
  8586                                  ;
  8587                                  bcd_to_bin:				;
  8588 00002900 88C4                    		mov	ah,al		; copy bcd number to ah
  8589 00002902 250FF0                  		and	ax,0F00Fh	; clear unwanted nibbles
  8590 00002905 88C3                    		mov	bl,al		; save units place
  8591 00002907 86E0                    		xchg	ah,al		; 10's place to al
  8592 00002909 30E4                    		xor	ah,ah		; ah not wanted
  8593 0000290B B104                    		mov	cl,4		; shift count
  8594 0000290D D3E8                    		shr	ax,cl		;mjb004 swap nibbles
  8595 0000290F B10A                    		mov	cl,10		; convert al to ...
  8596 00002911 F6E1                    		mul	cl		; ... its binary value
  8597 00002913 00D8                    		add	al,bl		; add in units
  8598 00002915 C3                      		retn
  8599                                  
  8600                                  ; 26/03/2018 - CLOCKSUB.INC, MSDOS 3.3, 24/07/1987					
  8601                                  
  8602                                  ;
  8603                                  ;   date_verify loosely checks bcd date values to be in range in bin_date_time
  8604                                  ;
  8605                                  date_verify:				    	    ;
  8606 00002916 803E[EF1A]20            		cmp	byte [BIN_DATE_TIME+0],20h  ; century check
  8607 0000291B 7735                    		ja	short date_error	    ; jmp error
  8608 0000291D 740E                    		jz	short century_20	    ; jmp in 20th century
  8609 0000291F 803E[EF1A]19            		cmp	byte [BIN_DATE_TIME+0],19h  ; century check
  8610 00002924 722C                    		jb	short date_error	    ; jmp error
  8611 00002926 803E[F01A]80            		cmp	byte [BIN_DATE_TIME+1],80h  ; year check
  8612 0000292B 7225                    		jb	short date_error	    ; jmp error
  8613                                  century_20:				    	    ;
  8614 0000292D 803E[F01A]99            		cmp	byte [BIN_DATE_TIME+1],99h  ; year check
  8615 00002932 771E                    		ja	short date_error	    ; jmp error
  8616 00002934 803E[F11A]12            		cmp	byte [BIN_DATE_TIME+2],12h  ; month check
  8617 00002939 7717                    		ja	short date_error	    ; jmp error
  8618 0000293B 803E[F11A]00            		cmp	byte [BIN_DATE_TIME+2],00h  ; month check
  8619 00002940 7610                    		jbe	short date_error	    ; jmp error
  8620 00002942 803E[F21A]31            		cmp	byte [BIN_DATE_TIME+3],31h  ; day check
  8621 00002947 7709                    		ja	short date_error	    ; jmp error
  8622 00002949 803E[F21A]00            		cmp	byte [BIN_DATE_TIME+3],00h  ; day check
  8623 0000294E 7602                    		jbe	short date_error	    ; jmp error
  8624 00002950 F8                      		clc				    ; set success flag
  8625 00002951 C3                      		ret				    ;
  8626                                  date_error:				   	    ;
  8627 00002952 F9                      		stc				    ; set error flag
  8628 00002953 C3                      		retn				    ;
  8629                                  
  8630                                  ;
  8631                                  ; time_verify very loosely checks bcd date values to be in range in bin_date_time
  8632                                  ;
  8633                                  time_verify:
  8634 00002954 803E[EF1A]24            		cmp	byte [BIN_DATE_TIME+0],24h
  8635 00002959 7710                    		ja	short time_error
  8636 0000295B 803E[F01A]59            		cmp	byte [BIN_DATE_TIME+1],59h
  8637 00002960 7709                    		ja	short time_error
  8638 00002962 803E[F11A]59            		cmp	byte [BIN_DATE_TIME+2],59h
  8639 00002967 7702                    		ja	short time_error
  8640 00002969 F8                      		clc
  8641 0000296A C3                      		retn
  8642                                  time_error:
  8643 0000296B F9                      		stc
  8644 0000296C C3                      		retn
  8645                                  
  8646                                  ;
  8647                                  ;   bcd_verify checks values in bin_date_time to be valid
  8648                                  ;   bcd numerals.  carry set if any nibble out of range
  8649                                  ;
  8650                                  bcd_verify:				  ;
  8651 0000296D B90400                  		mov	cx,4		  ; 4 bytes to check
  8652 00002970 BB[EF1A]                		mov	bx,BIN_DATE_TIME  ;
  8653                                  bv_loop:				  ;
  8654 00002973 8A07                    		mov	al,[bx]		  ; get a bcd number (0..99)
  8655 00002975 88C4                    		mov	ah,al		  ;
  8656 00002977 250FF0                  		and	ax,0F00Fh	  ; 10's place in high ah, 1's in al
  8657 0000297A 3C0A                    		cmp	al,10		  ; is 1's place in range?
  8658 0000297C 7716                    		ja	short bv_error	  ; jmp out of range
  8659 0000297E D0EC                    		shr	ah,1		  ; swap nibbles
  8660 00002980 D0EC                    		shr	ah,1		  ; ...
  8661 00002982 D0EC                    		shr	ah,1		  ; ...
  8662 00002984 D0EC                    		shr	ah,1		  ; ...
  8663 00002986 80E40F                  		and	ah,0fh		  ; get rid of any erroneous bits
  8664 00002989 80FC0A                  		cmp	ah,10		  ; is 10's place in range
  8665 0000298C 7706                    		ja	short bv_error	  ; jmp out of range
  8666 0000298E 43                      		inc	bx		  ; next byte
  8667 0000298F 49                      		dec	cx		  ;
  8668 00002990 75E1                    		jnz	short bv_loop 	  ;
  8669 00002992 F8                      		clc			  ; set success flag
  8670 00002993 C3                      		retn			  ;
  8671                                  bv_error:				  ;
  8672 00002994 F9                      		stc			  ; set error flag
  8673 00002995 C3                      		retn			  ;
  8674                                  
  8675                                  ; 02/06/2018 - Retro DOS v3.0
  8676                                  
  8677                                  ENDK09:
  8678                                  
  8679                                  
  8680                                  	; Temporary !
  8681                                  	; 25/08/2022 - IBMBIO.COM (IBMBIO33.IDB) address compatibility!
  8682                                  	;times	20 db 0 ; 'DRVFAT:' address must be 29FAh
  8683                                  
  8684                                  ;------------------------------------------------------------------------
  8685                                  ;									:
  8686                                  ;	System initialization						:
  8687                                  ;									:
  8688                                  ;	The entry conditions are established by the bootstrap		:
  8689                                  ;	loader and are considered unknown.  The following jobs		:
  8690                                  ;	will be performed by this module:				:
  8691                                  ;									:
  8692                                  ;	1.	All device initialization is performed			:
  8693                                  ;	2.	A local stack is set up and DS:SI are set		:
  8694                                  ;		to point to an initialization table. Then		:
  8695                                  ;		an inter-segment call is made to the first		:
  8696                                  ;		byte of the dos 					:
  8697                                  ;	3.	Once the dos returns from this call the ds		:
  8698                                  ;		register has been set up to point to the start		:
  8699                                  ;		of free memory. The initialization will then		:
  8700                                  ;		load the command program into this area 		:
  8701                                  ;		beginning at 100 hex and transfer control to		:
  8702                                  ;		this program.						:
  8703                                  ;									:
  8704                                  ;------------------------------------------------------------------------
  8705                                  
  8706                                  ; DRVFAT must be the first location of freeable space!
  8707                                  	;EVENB
  8708                                  
  8709                                  align 2
  8710                                  
  8711 00002996 0000                    DRVFAT:	DW	0			; Drive and FAT ID of DOS
  8712                                  ; 03/07/2018
  8713                                  ;BIOS$:	DW	0			; First sector of data
  8714                                  ;DOSCNT:DW	0			; How many sectors to read
  8715                                  
  8716                                  	; Temporary !
  8717                                  	; 25/08/2022 - IBMBIO.COM (IBMBIO33.IDB) address compatibility!
  8718                                  	;dd	0	
  8719                                  
  8720 00002998 00                      fBigFAT: DB	0			; Flags for drive
  8721                                  ; 01/07/2018
  8722                                  ;FatLen:	DW	0		; number of sectors in FAT.
  8723                                  ;FatLoc:	DW	0		; seg addr of fat sector
  8724                                  
  8725                                  	; Temporary !
  8726                                  	; 25/08/2022 - IBMBIO.COM (IBMBIO33.IDB) address compatibility!
  8727                                  	;dd	0
  8728                                  
  8729                                  ;;Rev 3.30 Modification -----------------------------------------------
  8730                                  ; THE FOLLOWING TWO BYTES ARE USED TO SAVE INFO RETURNED BY INT 13, AH=8
  8731                                  ; CALL TO DETERMINE DRIVE PARAMETERS.					
  8732 00002999 02                      NUM_HEADS: DB	2			; NUMBER OF HEADS RETURNED BY ROM
  8733 0000299A 09                      SEC_TRK:   DB	9			; SEC/TRK RETURNED BY ROM	 
  8734 0000299B 28                      NUM_CYLN:  DB	40			; NUMBER OF CYLINDERS RET BY ROM 
  8735                                  									 
  8736 0000299C FF                      MODEL_BYTE: DB	0FFH			; MODEL BYTE. SET UP AT INIT TIME.
  8737                                  					; FF - PC-1, EXPANSION, OLD PC-2 
  8738                                  					; FE - NEWER PC-2 (64/256K PLANAR)
  8739                                  					; FD - 
  8740                                  					; FC - 
  8741 0000299D 00                      Secondary_Model_Byte: DB 0						 
  8742                                  ;;End of Modification -----------------------------------------------
  8743                                  
  8744                                  ;BOOTBIAS equ	200H							 
  8745                                  
  8746                                  	;EVENB
  8747                                  align 2
  8748                                  					 
  8749 0000299E 0002000140000000        DiskTable:  DW	512,	0100h,	64,	0
  8750 000029A6 0008010270000000        	    DW	2048,	0201h,	112,	0
  8751 000029AE 0020020400010000        	    DW	8192,	0402h,	256,	0
  8752 000029B6 A87F030800020000        	    DW	32680,	0803h,	512,	0
  8753 000029BE FFFF041000040000        	    DW	65535,	1004h,	1024,	0
  8754                                  
  8755 000029C6 A87F030800020000        DiskTable2: DW	32680,	0803h,	512,	0
  8756 000029CE FFFF020400024000        	    DW	65535,	0402h,	512,	fBIG
  8757                                  
  8758                                  ;;Rev 3.30 Modification -----------------------------------------------
  8759                                  
  8760                                  ;*************************************************************************
  8761                                  ;Variables for Mini disk initialization
  8762                                  ;*************************************************************************
  8763 000029D6 0000                    End_Of_BDSM:	dw	0		;offset value of the ending add
  8764                                  					;of BDSM table. Needed to figure
  8765                                  					;the Final_DOS_Location.
  8766 000029D8 00                      numh:		db	0		;number of hard files
  8767 000029D9 00                      mininum: 	db	0		;logical drive num for mini disk 
  8768 000029DA 00                      num_mini_dsk:	db	0		;# of mini disk installed	 
  8769 000029DB 80                      Rom_Minidsk_num: db	80h		;physical mini disk number	 
  8770 000029DC 0000                    Mini_HDLIM:	dw	0						 
  8771 000029DE 0000                    Mini_SECLIM:	dw	0						 
  8772 000029E0 0000                    Mini_BPB_ptr:	dw	0		;temporary variable used to save 
  8773                                  					;Mini Disk BPB pt add in DskDrvs.
  8774                                  ;;End of Modification -----------------------------------------------
  8775                                  
  8776 000029E2 30312F31302F383400      Bios_Date:   DB	'01/10/84',0
  8777                                  
  8778                                  
  8779                                  ; 03/09/2022
  8780                                  
  8781                                  %if 0
  8782                                  
  8783                                  ; Temporary !
  8784                                  ; 25/08/2022 - IBMBIO.COM (IBMBIO33.IDB) address compatibility!
  8785                                  ; ------------------------------------------------------------------------
  8786                                  		
  8787                                  		;db 90h
  8788                                  ; 48 tpi diskettes
  8789                                  BPB48T: 	; 02/06/2018 - Retro DOS v3.0
  8790                                  _360K_parameters:
  8791                                  		; 360KB
  8792                                  		dw 512		; Sector size in bytes.
  8793                                  		db 2		; Sector per allocation unit.
  8794                                  		dw 1		; Reserved sectors.
  8795                                  		db 2		; Number of allocation tables.
  8796                                  		dw 112		; Number of directory entrys.
  8797                                  		dw 720		; Number of sectors on the disk.
  8798                                  		; Retro Dos v1.0 - 10/02/2018
  8799                                  		db 0FDh		; Media descriptor
  8800                                  		dw 2		; FAT size in sectors
  8801                                  		dw 9		; Sectors per track
  8802                                  		dw 2		; Number of heads
  8803                                  		; Retro DOS v2.0 - 07/04/2018
  8804                                  		dw 0		; Hidden sectors
  8805                                  		db 90h
  8806                                  ; 96tpi diskettes
  8807                                  BPB96T:		; 02/06/2018 - Retro DOS v3.0
  8808                                  _1200K_parameters:
  8809                                  		; 1.2MB
  8810                                  		dw 512
  8811                                                  db 1
  8812                                                  dw 1	
  8813                                                  db 2
  8814                                                  dw 224
  8815                                  		dw 2400
  8816                                  		; Retro DOS v1.0 - 10/02/2018
  8817                                  		db 0F9h		; Media Descriptor
  8818                                  		dw 7		; FAT size in sectors
  8819                                  		dw 15		; Sectors per track
  8820                                  		dw 2		; Number of heads
  8821                                  		; Retro DOS v2.0 - 07/04/2018
  8822                                  		dw 0		; Hidden sectors
  8823                                  		db 90h
  8824                                  ; 3 1/2 inch diskette bpb
  8825                                  BPB35:		; 02/06/2018 - Retro DOS v3.0	
  8826                                  _720K_paramaters:
  8827                                  		; 720KB
  8828                                  		dw 512		; Sector size in bytes.
  8829                                  		db 2		; Sector per allocation unit.
  8830                                  		dw 1		; Reserved sectors.
  8831                                  		db 2		; Number of allocation tables.
  8832                                  		dw 112		; Number of directory entrys.
  8833                                  		dw 1440		; Number of sectors on the disk.
  8834                                  		; Retro DOS v1.0 - 10/02/2018
  8835                                  		db 0F9h		; Media descriptor
  8836                                  		dw 3		; FAT size in sectors
  8837                                  		dw 9		; Sectors per track
  8838                                  		dw 2		; Number of heads
  8839                                  		; Retro DOS v2.0 - 07/04/2018
  8840                                  		dw 0
  8841                                  		; Retro DOS v3.0 - 02/06/2018
  8842                                  		db 90h
  8843                                  
  8844                                  %endif
  8845                                  
  8846                                  ; 03/09/2022
  8847                                  ;BPBTable:
  8848                                  ;		; 25/08/2022 - IBMBIO.COM (IBMBIO33.IDB) compatibility!
  8849                                  ;		dw	BPB48T	; 48tpi drives
  8850                                  ;		dw	BPB96T	; 96tpi drives
  8851                                  ;		dw	BPB35	; 3.5" drives
  8852                                  
  8853                                  ; 02/06/2018 - Retro DOS v3.0
  8854                                  
  8855                                  PatchTable:
  8856 000029EB 0A00[AB09]              		DW	10,Media_Patch
  8857 000029EF 0300[760A]              		DW	3,GETBP1_PATCH
  8858 000029F3 0300[370A]              		DW	3,SET_PATCH
  8859 000029F7 0300[060D]              		DW	3,DiskIO_PATCH
  8860 000029FB 0300[8A0E]              		DW	3,DSKERR
  8861 000029FF 0A00[3E0F]              		DW	10,Changed_Patch
  8862 00002A03 0300[D709]              		DW	3,INIT_PATCH
  8863 00002A07 0000                    		DW	0
  8864                                  
  8865                                  ;-----------------------------------------------------------------------------
  8866                                  
  8867                                  ; 28/03/2018
  8868                                  ; MSDOS 6.0 - MSINIT.ASM, 1991
  8869 00002A09 0000                    init_bootseg:	dw	0	; seg addr of buffer for reading boot record
  8870                                  
  8871                                  BootBias equ 200h ; 19/03/2018
  8872                                  
  8873                                  ;-----------------------------------------------------------------------------
  8874                                  
  8875 00002A0B 90<rep 5h>              align 16
  8876                                  
  8877                                  ;-----------------------------------------------------------------------------
  8878                                  ; entry point from boot sector
  8879                                  ;-----------------------------------------------------------------------------
  8880                                  ; 02/06/2018 - Retro DOS v3.0
  8881                                  
  8882                                  ;-----------------------------------------------------------------------------
  8883                                  
  8884                                  ; ----------------------------------------------------------------------------
  8885                                  ; SYSINIT PARAMETER ADDRESS EQUALITIES - 25/02/2018 (MSDOS 2.0 'SYSINIT.ASM')
  8886                                  ; ----------------------------------------------------------------------------
  8887                                  ; ('sysinit.s', 'SYSINIT.BIN')
  8888                                  
  8889                                  ; IN SYSINIT SEGMENT (SYSINITSEG):
  8890                                  
  8891                                  CURRENT_DOS_LOCATION EQU 6   ; dw (segment)
  8892                                  FINAL_DOS_LOCATION   EQU 10  ; dw (segment)
  8893                                  DEVICE_LIST	     EQU 12  ; dd (segment:offset)	
  8894                                  DOSSIZE		     EQU 16  ; dw ; Retro DOS 2.0 - 'MSDOS.BIN' size in words
  8895                                  ; 04/06/2018 - Retro DOS v3.0 (MSDOS 3.3)
  8896                                  ;MEMORY_SIZE	     EQU 18  ; dw (paragraphs)	
  8897                                  ;DEFAULT_DRIVE	     EQU 20  ; db
  8898                                  SYSI_COUNTRY	     EQU 18  ; dd (segment:offset) - country table pointer	
  8899                                  STACK_COUNT	     EQU 22  ; dw 	
  8900                                  STACK_SIZE	     EQU 24  ; dw
  8901                                  STACK_ADDR	     EQU 26  ; dd (segment:offset)  
  8902                                  MEMORY_SIZE	     EQU 30  ; dw (paragraphs)
  8903                                  DEFAULT_DRIVE	     EQU 32  ; db 	 						
  8904                                  
  8905                                  ;-----------------------------------------------------------------------------
  8906                                  ; initialization - stage 1
  8907                                  ;-----------------------------------------------------------------------------
  8908                                  ; 02/06/2018 - Retro DOS v3.0
  8909                                  
  8910                                  		; Retro DOS 3.0 Modification on MSDOS 3.3 IBMBIO.COM code
  8911                                  		; (Because of Retro DOS 2.0, MSDOS 3.3 boot sector difference)
  8912                                  
  8913                                  INIT:
  8914                                  		; 07/04/2018
  8915                                  		; Retro DOS v2.0 - registers from FD Boot Sector 
  8916                                                  ; DL = [bsDriveNumber]
  8917                                  		; DH = [bsMedia]
  8918                                  		; AX = [bsSectors] ; Total sectors
  8919                                  		; DS = 0, SS = 0
  8920                                  		; BP = 7C00h
  8921                                  
  8922                                  		; Move Retro DOS v2.0 boot sector parameters to 0060h:0
  8923 00002A10 BB6000                  		mov	bx, 60h
  8924 00002A13 8EC3                    		mov	es, bx
  8925 00002A15 89EE                    		mov	si, bp
  8926 00002A17 29FF                    		sub	di, di
  8927 00002A19 B92300                  		mov	cx, 35 ; 70 bytes, 35 words
  8928                                  		;mov	cl, 35
  8929 00002A1C F3A5                    		rep	movsw
  8930                                  
  8931 00002A1E 0E                      		push	cs
  8932 00002A1F 1F                      		pop	ds
  8933                                  
  8934                                  		; 27/03/2018
  8935 00002A20 B98C63                  		mov	cx, KERNEL_SIZE	; words !
  8936                                  		; 07/04/2018
  8937                                  		;mov	bx, KERNEL_SEGMENT ; 0070h
  8938 00002A23 B370                    		mov	bl, KERNEL_SEGMENT
  8939 00002A25 8EC3                    		mov	es, bx
  8940 00002A27 31FF                    		xor	di, di
  8941 00002A29 89FE                    		mov	si, di
  8942                                  		
  8943                                  		; Move KERNEL file from 1000h:0 to 0070h:0
  8944                                  		; (Retro DOS v2 BS loads 'MSDOS.SYS' at 1000h:0000h)
  8945 00002A2B F3A5                    		rep	movsw
  8946                                  		; 17/06/2018 
  8947                                  		;mov	ds, bx
  8948                                  INIT0:
  8949 00002A2D 06                      		push	es
  8950 00002A2E 68[322A]                		push	INIT1 ; 07/04/2018
  8951 00002A31 CB                      		retf	; jump to 0070h:INIT1
  8952                                  
  8953                                  ;INIT:
  8954                                  INIT1:
  8955                                  ; 02/06/2018 - Retro DOS v3.0
  8956                                  
  8957                                  		; 19/03/2018
  8958                                  		; Retro DOS v2.0 (24/02/2018)
  8959                                  		; [REF: MSDOS 3.3, MSBIO, "MSINIT.ASM"  (24/07/1987)]
  8960                                  
  8961                                  ;------------------------------------------------------------------------
  8962                                  ;									:
  8963                                  ;	System initialization						:
  8964                                  ;									:
  8965                                  ;	The entry conditions are established by the bootstrap		:
  8966                                  ;	loader and are considered unknown.  The following jobs		:
  8967                                  ;	will be performed by this module:				:
  8968                                  ;									:
  8969                                  ;	1.	All device initialization is performed			:
  8970                                  ;	2.	A local stack is set up and DS:SI are set		:
  8971                                  ;		to point to an initialization table. Then		:
  8972                                  ;		an inter-segment call is made to the first		:
  8973                                  ;		byte of the dos 					:
  8974                                  ;	3.	Once the dos returns from this call the ds		:
  8975                                  ;		register has been set up to point to the start		:
  8976                                  ;		of free memory. The initialization will then		:
  8977                                  ;		load the command program into this area 		:
  8978                                  ;		beginning at 100 hex and transfer control to		:
  8979                                  ;		this program.						:
  8980                                  ;									:
  8981                                  ;------------------------------------------------------------------------
  8982                                  
  8983                                  		; MSDOS 3.3 - "MSEQU.INC" (24/07/1987)
  8984                                  		EOI	EQU	20H
  8985                                  		AKPORT	EQU	20H
  8986                                  		INITSPOT EQU	534H	; IBM wants 4 zeros here
  8987                                  		BRKADR	EQU	1BH * 4	; 6CH, 1BH break vector address
  8988                                  		TIMADR	EQU	1CH * 4	; 70H, 1CH timer interrupt
  8989                                  		DSKADR	EQU	1EH * 4	; address of ptr to disk parameters
  8990                                  		SEC9	EQU	522H	; address of disk parameters
  8991                                  		;CHROUT	EQU	29H
  8992                                  		;LSTDRV	EQU     504H
  8993                                  		;;SYSIZE	EQU 200H ;NUMBER OF PARAGRAPHS IN SYSINIT MODULE
  8994                                  		 ; 26/03/2018
  8995                                  		RSINIT	EQU	0A3H
  8996                                  		NORMSETTLE EQU  15
  8997                                  
  8998                                  		; Retro DOS v1.0 (10/02/2018)
  8999                                  		; (Register values from Retro DOS v1.0 Boot Sector)
  9000                                  		; CS = 60h  ; BIO_SEGMENT
  9001                                  		; DS = 0
  9002                                  		; ES = 0
  9003                                  		; SS = 0
  9004                                  		; SP = 0FFFEh
  9005                                   		; BP = 7C00h
  9006                                  		; DL = Physical drive number = 0
  9007                                  		;push	cs
  9008                                  		;pop	ds
  9009                                  
  9010                                  		; Retro DOS v1.0 boot sector (fd0) dos parameters
  9011                                  		; (17 bytes)
  9012                                  		bsBytesPerSec	equ 11
  9013                                  		bsSecPerClust	equ 13
  9014                                  		bsResSectors	equ 14	
  9015                                  		bsFATs		equ 16
  9016                                  		bsRootDirEnts	equ 17
  9017                                  		bsSectors	equ 19	
  9018                                  		bsMedia		equ 21
  9019                                  		bsFATsecs	equ 22
  9020                                  		bsSecPerTrack	equ 24
  9021                                  		bsHeads		equ 26
  9022                                  
  9023                                  		; Retro DOS 1.0 extensions (to boot sector parameters) 
  9024                                  		bsDataStart	equ 64
  9025                                  
  9026                                  		;push	ds
  9027                                  		;pop	es
  9028                                  
  9029                                  		; 14/02/2018
  9030                                  		; Set video mode to 3 (Clear screen)
  9031 00002A32 B80300                  		mov	ax, 3
  9032 00002A35 CD10                    		int	10h
  9033                                  
  9034                                  		; 06/04/2018 - Retro DOS v2.0
  9035                                  		; (IBMDOS 2.1, IBMBIO.COM, 20/10/1983)
  9036                                  		; (by IDA Pro Free Dissassembler)
  9037                                  		; 19/03/2018
  9038                                  		; (Source Code Ref: MSDOS 3.3, MSINIT.ASM, 1991)
  9039                                  		
  9040                                  		; "MSINIT.ASM"
  9041                                  		;---------------------------------------------------------------
  9042                                  		; At this point the registers contain these values:
  9043                                  		;   AX = 0-based drive we booted from
  9044                                  		;   BX = the logical number of the first data sector on the disk
  9045                                  		;   CX = number of floppies including logical one
  9046                                  
  9047                                  		;
  9048                                  		; set up local stack
  9049                                  		;
  9050                                  
  9051                                  		;XOR	BX,BX
  9052                                  		;CLI		; turn interrupts off while manupulating stack
  9053                                  		;MOV	SS,BX	; set stack segment register
  9054                                  		;MOV	SP,700h	; set stack pointer
  9055                                  		;STI		; turn interrupts on
  9056                                  
  9057                                  ; 02/06/2018 - Retro DOS v3.0
  9058                                  
  9059                                  ;
  9060                                  ; Entry from boot sector.  The register contents are:
  9061                                  ;   DL = INT 13 drive number we booted from
  9062                                  ;   CH = media byte
  9063                                  ;   BX = First data sector on disk (0-based)
  9064                                  ;
  9065 00002A37 FA                      		CLI
  9066 00002A38 31C0                    		XOR	AX,AX
  9067 00002A3A 8ED8                    		MOV	DS,AX
  9068                                  ;
  9069                                  ; Preserve original int 13 vector
  9070                                  ;   We need to save INT13 in two places in case we are running on an AT.
  9071                                  ; On ATs we install the IBM supplied ROM_BIOS patch DISK.OBJ which hooks
  9072                                  ; INT13 ahead of ORIG13.  Since INT19 must unhook INT13 to point to the
  9073                                  ; ROM INT13 routine, we must have that ROM address also stored away.
  9074                                  ;
  9075                                  		; 16/06/2018
  9076 00002A3C A14C00                  		MOV	AX,[13h*4]
  9077 00002A3F 2EA3[B000]              		MOV	[CS:OLD13],AX
  9078 00002A43 2EA3[B400]              		MOV	[CS:ORIG13],AX
  9079 00002A47 A14E00                  		MOV	AX,[13h*4+2]
  9080 00002A4A 2EA3[B200]              		MOV	[CS:OLD13+2],AX
  9081 00002A4E 2EA3[B600]              		MOV	[CS:ORIG13+2],AX
  9082                                  
  9083                                  ;
  9084                                  ; Set up INT 13 for new action
  9085                                  ;
  9086 00002A52 C7064C00[340F]          		MOV	WORD [13h*4],Block13
  9087 00002A58 8C0E4E00                		MOV	[13h*4+2],CS
  9088                                  ;
  9089                                  ; Preserve original int 19 vector
  9090                                  ;
  9091 00002A5C A16400                  		MOV	AX,[19h*4]
  9092 00002A5F 2EA3[3418]              		MOV	[CS:ORIG19],AX	
  9093 00002A63 A16600                  		MOV	AX,[19h*4+2]
  9094 00002A66 2EA3[3618]              		MOV	[CS:ORIG19+2],AX
  9095                                  ;
  9096                                  ; Set up INT 19 for new action
  9097                                  ;
  9098 00002A6A C7066400[AC18]          		MOV	WORD[19h*4],INT19
  9099 00002A70 8C0E6600                		MOV	[19h*4+2],CS
  9100 00002A74 FB                      		STI
  9101                                  
  9102                                  		;; 07/04/2018
  9103                                  		;; Retro DOS v2.0
  9104                                  		;INT	11h		; rom-bios equipment determination
  9105                                  		;; 10/04/2018
  9106                                  		;TEST	AL,1
  9107                                  		;JNZ	SHORT CHECKSINGLEFD
  9108                                  		;XOR	AX,AX
  9109                                  		;JMP	SHORT NOFD
  9110                                  ;CHECKSINGLEFD:
  9111                                  		;MOV	CL, 6
  9112                                  		;SHR	AL, CL
  9113                                  		;JNZ	short NOTSINGLE	;ZERO MEANS SINGLE DRIVE SYSTEM
  9114                                  		;INC	byte [Single]	;REMEMBER THIS
  9115                                  ;NOTSINGLE:
  9116                                  		;XOR	AH,AH
  9117                                  		;INC	AL ; 10/04/2018
  9118                                  
  9119                                  		;; 02/06/2018
  9120                                  		;; Retro DOS v3.0  (MSDOS 3.3, MSINIT.ASM, 02/02/1988)
  9121                                  
  9122 00002A75 CD11                    		INT	11h		; rom-bios equipment determination
  9123 00002A77 D0C0                    		ROL	AL,1		;PUT BITS 6 & 7 INTO BITS 0 & 1
  9124 00002A79 D0C0                    		ROL	AL,1
  9125 00002A7B 83E003                  		AND	AX,3		;ONLY LOOK AT BITS 0 & 1
  9126 00002A7E 7506                    		JNZ	short NOTSINGLE	;ZERO MEANS SINGLE DRIVE SYSTEM
  9127 00002A80 40                      		INC	AX		;PRETEND IT'S A TWO DRIVE SYSTEM
  9128 00002A81 2EFE06[8801]            		INC	byte [CS:Single] ;REMEMBER THIS
  9129                                  NOTSINGLE:
  9130 00002A86 40                      		INC	AX		;AX HAS NUMBER OF DRIVES, 2-4
  9131                                  					;IS ALSO 0 INDEXED BOOT DRIVE IF WE
  9132                                  					;  BOOTED OFF HARD FILE
  9133 00002A87 88C1                    		mov	CL,AL		; save number of diskette drives in CL
  9134 00002A89 F6C280                  		test	DL,80h		; booted from hard disk ?
  9135 00002A8C 7502                    		jnz	short GotHrd	; yes, jump down
  9136 00002A8E 31C0                    		xor	AX,AX		; no - indicate boot from drive A
  9137                                  GotHrd:		
  9138                                  		; At this point the registers contain these values:
  9139                                  		;   AX = 0-based drive we booted from
  9140                                  		;   BX = the logical number of the first data sector on the disk
  9141                                  		;   CL = number of floppies including logical one
  9142                                  		;   CH = media byte
  9143                                  		;
  9144                                  ;
  9145                                  ; set up local stack
  9146                                  ;
  9147 00002A90 88F5                    		mov	ch, dh	; 01/07/2018
  9148                                  
  9149 00002A92 31D2                    		xor	DX,DX
  9150 00002A94 FA                      		cli			; turn interrupts off while manupulating stack
  9151 00002A95 8ED2                    		mov	SS,DX		; set stack segment register
  9152 00002A97 BC0007                  		mov	SP,700h 	; set stack pointer
  9153 00002A9A FB                      		sti			; turn interrupts on
  9154                                  	
  9155                                  					; preserve some of the values in registers
  9156 00002A9B 51                      		push	CX ; (***)	; save number of floppies and media byte
  9157                                  		; 03/07/2018
  9158                                  		; 16/06/2018
  9159                                  		;mov	[CS:BIOS$],BX	; save first data sector
  9160 00002A9C 88EC                    		mov	AH,CH		; FAT ID to AH too
  9161 00002A9E 50                      		push	AX ; (**)	; save boot drive number and media byte
  9162                                  
  9163                                  ;;Rev 3.30 Modification -----------------------------------------------
  9164                                  ; Let Model_byte, Secondary_Model_Byte be set here!!!	
  9165 00002A9F B4C0                    		mov	ah,0C0h 	; return system environment 
  9166 00002AA1 CD15                    		int	15h		; call ROM-Bios routine     
  9167 00002AA3 7217                    		jc	short No_Rom_System_Conf ; just use Model_Byte	
  9168 00002AA5 80FC00                  		cmp	ah,0		; double check		
  9169 00002AA8 7512                    		jne	short No_Rom_System_Conf
  9170                                  			 		;get the model byte				
  9171 00002AAA 268A4702                		mov	al,[ES:BX+ROMBIOS_DESC.bios_SD_modelbyte]
  9172 00002AAE 2EA2[9C29]              		mov	[CS:MODEL_BYTE],al
  9173                                  					 ;secondary model byte					
  9174 00002AB2 268A4703                		mov	al, [ES:BX+ROMBIOS_DESC.bios_SD_scnd_modelbyte]
  9175 00002AB6 2EA2[9D29]              		mov	[CS:Secondary_Model_Byte],al				
  9176 00002ABA EB0D                    		jmp	short Turn_Timer_On					
  9177                                  No_Rom_System_Conf:							
  9178 00002ABC BEFFFF                  		MOV	SI,0FFFFH	;MJB001 			
  9179 00002ABF 8EC6                    		MOV	ES,SI		;MJB001 			
  9180 00002AC1 26A00E00                		MOV	AL,[ES:0EH]	; GET MODEL BYTE ARR 2.41	
  9181 00002AC5 2EA2[9C29]              		MOV	[CS:MODEL_BYTE],AL ; SAVE MODEL BYTE ARR 2.41	
  9182                                  ;;End of Modification -----------------------------------------------
  9183                                  	
  9184                                  Turn_Timer_On:								
  9185 00002AC9 B020                    		mov	AL,EOI
  9186 00002ACB E620                    		out	AKPORT,AL	; turn on the timer
  9187                                  
  9188                                  		; 02/06/2018
  9189                                  
  9190                                  ;;Rev 3.30 Modification -----------------------------------------------
  9191 00002ACD BE[FA01]                		mov	si,COM4DEV 
  9192 00002AD0 E80A06                  		call	AUX_INIT
  9193 00002AD3 BE[E801]                		mov	si,COM3DEV
  9194 00002AD6 E80406                  		call	AUX_INIT
  9195                                  ;;End of Modification -----------------------------------------------
  9196 00002AD9 BE[D601]                		mov	SI,COM2DEV
  9197 00002ADC E8FE05                  		call	AUX_INIT		;INIT COM2
  9198 00002ADF BE[8E01]                		mov	SI,COM1DEV
  9199 00002AE2 E8F805                  		call	AUX_INIT		;INIT COM1
  9200                                  
  9201 00002AE5 BE[C401]                		mov	SI,LPT3DEV
  9202 00002AE8 E8EA05                  		call	PRINT_INIT		;INIT LPT3
  9203 00002AEB BE[B201]                		mov	SI,LPT2DEV
  9204 00002AEE E8E405                  		call	PRINT_INIT		;INIT LPT2
  9205 00002AF1 BE[A001]                		mov	SI,LPT1DEV
  9206 00002AF4 E8DE05                  		call	PRINT_INIT		;INIT LPT1
  9207                                  
  9208 00002AF7 31D2                    		xor	DX,DX
  9209 00002AF9 8EDA                    		mov	DS,DX			;TO INITIALIZE PRINT SCREEN VECTOR
  9210 00002AFB 8EC2                    		mov	ES,DX
  9211                                  
  9212 00002AFD 31C0                    		xor	AX,AX
  9213 00002AFF BF3405                  		mov	DI,INITSPOT
  9214 00002B02 AB                      		stosw				;INIT four bytes to 0
  9215 00002B03 AB                      		stosw
  9216                                  
  9217 00002B04 8CC8                    		mov	AX,CS			;FETCH SEGMENT
  9218                                  
  9219 00002B06 C7066C00[0907]          		mov	word [BRKADR],CBREAK	;BREAK ENTRY POINT
  9220 00002B0C A36E00                  		mov	[BRKADR+2],AX		;VECTOR FOR BREAK
  9221                                  
  9222 00002B0F C706A400[6006]          		mov	word [CHROUT*4],OUTCHR
  9223 00002B15 A3A600                  		mov	[CHROUT*4+2],AX
  9224                                  
  9225 00002B18 BF0400                  		mov	DI,4
  9226 00002B1B BB[0F07]                		mov	BX,INTRET		;WILL INITIALIZE REST OF INTERRUPTS
  9227 00002B1E 93                      		xchg	AX,BX
  9228 00002B1F AB                      		stosw				;Location 4
  9229 00002B20 93                      		xchg	AX,BX
  9230 00002B21 AB                      		stosw				;INT 1		;Location 6
  9231 00002B22 83C704                  		add	DI,4
  9232 00002B25 93                      		xchg	AX,BX
  9233 00002B26 AB                      		stosw				;Location 12
  9234 00002B27 93                      		xchg	AX,BX
  9235 00002B28 AB                      		stosw				;INT 3		;Location 14
  9236 00002B29 93                      		xchg	AX,BX
  9237 00002B2A AB                      		stosw				;Location 16
  9238 00002B2B 93                      		xchg	AX,BX
  9239 00002B2C AB                      		stosw				;INT 4		;Location 18
  9240                                  
  9241 00002B2D 89160005                		mov	[500H],DX		;SET PRINT SCREEN & BREAK =0
  9242 00002B31 89160405                		mov	[LSTDRV],DX		;clean out last drive spec
  9243                                  
  9244 00002B35 8B367800                		mov	SI,[DSKADR]
  9245 00002B39 8E1E7A00                		mov	DS,[DSKADR+2]		; DS:SI -> current table
  9246                                  
  9247 00002B3D BF2205                  		mov	DI,SEC9 		; ES:DI -> New Table
  9248 00002B40 B90B00                  		mov	CX,DISK_PARMS.size ; 11
  9249 00002B43 F3A4                    		rep	MOVSB			; Copy Table
  9250 00002B45 06                      		push	ES			;
  9251 00002B46 1F                      		pop	DS			; DS = 0
  9252                                  							
  9253 00002B47 C70678002205            		mov	word [DSKADR],SEC9 	; Point disk parm vector to new table	
  9254 00002B4D 8C1E7A00                		mov	[DSKADR+2],DS 
  9255                                  
  9256                                  ;-----------------------------------------------
  9257                                  ;
  9258                                  ; THE FOLLOWING DEPEND ON THE TYPE OF MACHINE.
  9259                                  ;
  9260                                  		; 16/06/2018
  9261 00002B51 2E803E[9C29]FD          		CMP	byte [CS:MODEL_BYTE],0FDH ; IS THIS AN OLD ROM?
  9262 00002B57 720B                    		JB	short NO_DIDDLE		; NO
  9263 00002B59 C7062B050F02            		MOV	WORD [SEC9+DISK_PARMS.DISK_HEAD_STTL],0200H+NORMSETTLE
  9264                                  						; SET HEAD SETTLE AND MOTOR START
  9265                                  						; ON PC-1 PC-2 PC-XT HAL0
  9266 00002B5F C6062205DF              		MOV	byte [SEC9+DISK_PARMS.DISK_SPECIFY_1],0DFH 
  9267                                  						; SET 1ST SPECIFY BYTE
  9268                                  						; ON PC-1 PC-2 PC-XT HAL0
  9269                                  NO_DIDDLE:
  9270 00002B64 CD12                    		int	12h			; call rom-bios for memory size
  9271 00002B66 B106                    		mov	CL,6			; get ready for shift
  9272 00002B68 D3E0                    		shl	AX,CL			; change from K to 16 byte blocks
  9273 00002B6A 59                      		pop	CX ; (**)		; restore CX
  9274                                  		; 03/07/2018
  9275 00002B6B 0E                      		push	cs
  9276 00002B6C 1F                      		pop	ds
  9277 00002B6D 890E[9629]              		mov	[DRVFAT],cx
  9278                                  		; 16/06/2018
  9279                                  		;mov	[CS:DRVFAT],CX
  9280                                  		;push	AX ; (*)
  9281                                  		; 03/07/2018
  9282 00002B71 89C2                    		mov	dx, ax ; (*)		
  9283                                  
  9284                                  		; 02/06/2018
  9285                                  		;mov	dx,[7C00h + 16h]	; number of sectors/fat from boot sec
  9286                                  		
  9287                                  		;01/07/2018
  9288                                  		;mov	dx,[600h+16h]		; ((Retro DOS v2.0/v3.0 modification))
  9289                                  		
  9290                                  		;xor	dh,dh
  9291                                  		; 17/06/2018
  9292                                  		;push	cs
  9293                                  		;pop	ds
  9294                                  		; 01/07/2018
  9295                                  		;mov	[FatLen],dx
  9296                                  		; 16/06/2018
  9297                                  		;mov	[CS:FatLen],DX
  9298                                  ;
  9299                                  ; Convert sector count to paragraph count:512 bytes / sec / 16 bytes / para
  9300                                  ; = 32 para /sector
  9301                                  ;
  9302                                  ;;Rev 3.30 Modification -----------------------------------------------
  9303                                  		; 01/07/2018
  9304                                  		;SHL	DX,1
  9305                                  		;SHL	DX,1
  9306                                  		;SHL	DX,1
  9307                                  		;SHL	DX,1
  9308                                  		;SHL	DX,1
  9309                                  ;;End of Modification -----------------------------------------------
  9310                                  		;SUB	AX,DX			; room for FAT
  9311                                  		; 16/06/2018
  9312                                  		;MOV	[CS:FatLoc],AX		; location to read fat
  9313                                  		; 01/07/2018
  9314                                  		;; 17/06/2018
  9315                                  		;mov	[FatLoc],ax
  9316                                  
  9317                                  		; 01/07/2018
  9318                                  
  9319                                  		; 08/04/2018
  9320                                  		; 28/03/2018
  9321                                  		; MSDOS 6.0 - MSINIT.ASM, 1991
  9322 00002B73 83E840                  		sub	ax,64		;room for boot record buffer segment (1 kb)
  9323 00002B76 A3[092A]                		mov	[init_bootseg],ax
  9324                                  
  9325                                  		;POP	AX ; (*)
  9326                                  		; 03/07/2018
  9327                                  		;pop	dx ; (*)
  9328                                  
  9329                                  		;; 02/06/2018
  9330                                  		;MOV	word [SYSINIT_START+DEVICE_LIST],CONHeader
  9331                                  		;MOV	[SYSINIT_START+DEVICE_LIST+2],CS
  9332                                  		; 05/07/2018
  9333 00002B79 C706[0C3B][3101]        		MOV	word [SYSINIT+DEVICE_LIST],CONHeader
  9334 00002B7F 8C0E[0E3B]              		MOV	[SYSINIT+DEVICE_LIST+2],CS
  9335                                  
  9336                                  		;; 06/04/2018
  9337                                  		;;MOV	[SYSINIT_START+MEMORY_SIZE],AX ; Top of memory (in paragraphs)
  9338                                  		;mov	[SYSINIT_START+MEMORY_SIZE],dx ; 01/07/2018
  9339                                  		;INC	CL
  9340                                  		;MOV	[SYSINIT_START+DEFAULT_DRIVE],CL ; SAVE DEFAULT DRIVE SPEC
  9341                                  
  9342                                  		; 05/07/2018
  9343                                  		;MOV	[SYSINIT+MEMORY_SIZE],AX
  9344 00002B83 8916[1E3B]              		mov	[SYSINIT+MEMORY_SIZE],dx
  9345 00002B87 FEC1                    		INC	CL
  9346 00002B89 880E[203B]              		MOV	[SYSINIT+DEFAULT_DRIVE],CL
  9347                                  		
  9348                                  		; 02/06/2018
  9349                                  		;mov	dx,ax
  9350                                  
  9351                                  		; 08/04/2018
  9352                                  		; 28/03/2018
  9353                                  		; MSDOS 6.0 - MSINIT.ASM, 1991
  9354                                  		;sub	ax,64		;room for boot record buffer segment (1 kb)
  9355                                  		;mov	[init_bootseg],ax
  9356                                  
  9357 00002B8D B81B05                  		mov	ax,MSDOS_BIN_SEGMENT  ; MSDOS_BIN_OFFSET >> 4
  9358 00002B90 83C070                  		add	ax,KERNEL_SEGMENT ; 26/03/2018
  9359                                  		;MOV	[SYSINIT_START+CURRENT_DOS_LOCATION],AX
  9360                                  		;05/07/2018
  9361 00002B93 A3[063B]                		MOV	[SYSINIT+CURRENT_DOS_LOCATION],AX
  9362                                  		
  9363                                  ; 02/06/2018
  9364                                  ;
  9365                                  ; IMPORTANT: Some old IBM hardware generates spurious INT F's due to bogus
  9366                                  ; printer cards.  We initialize this value to point to an IRET ONLY IF
  9367                                  ;
  9368                                  ; 1) The original segment points to storage inside valid RAM.
  9369                                  ;
  9370                                  ; 2) The original segment is 0F000:xxxx
  9371                                  ;
  9372                                  ; Theses are capricious requests from our OEM for reasons behind them, read
  9373                                  ; the DCR's for the IBM DOS 3.2 project.
  9374                                  ;
  9375                                  		; 03/07/2018
  9376                                  		;push	ax
  9377                                  		
  9378                                  		; 02/06/2018 - Retro DOS v3.0
  9379                                  		;push	ds
  9380                                  		;pop	es
  9381                                  
  9382 00002B96 31C0                    		xor	ax,ax
  9383 00002B98 8ED8                    		mov	ds,ax
  9384                                  
  9385 00002B9A A13E00                  		mov	ax,[0Fh*4+2]		; segment for Int 15
  9386                                  
  9387                                  		;;cmp	ax,[es:SYSINIT_START+MEMORY_SIZE] ; Condition 1
  9388                                  		; 05/07/2018
  9389                                  		;cmp	ax,[es:SYSINIT+MEMORY_SIZE]
  9390 00002B9D 39D0                    		cmp	ax,dx
  9391 00002B9F 7605                    		jna	short ResetIntF
  9392                                  
  9393 00002BA1 3D00F0                  		cmp	ax,0F000h		; Condition 2
  9394 00002BA4 750A                    		jne	short KeepIntF
  9395                                  ResetIntF:
  9396 00002BA6 C7063C00[0F07]          		mov	word [0Fh*4],INTRET
  9397 00002BAC 8C0E3E00                		mov	[0Fh*4+2],cs
  9398                                  KeepIntF:
  9399                                  		;pop	ax
  9400                                  ;
  9401                                  ; END IMPORTANT
  9402                                  ;
  9403                                  
  9404                                  ; 02/06/2018 - Retro DOS v3.0
  9405                                  
  9406                                  ;**************************************************************
  9407                                  ;	WILL INITIALIZE THE NUMBER OF DRIVES		
  9408                                  ;	AFTER THE EQUIPMENT CALL (INT 11H) BITS 6&7 WILL TELL	
  9409                                  ;	THE INDICATIONS ARE AS FOLLOWS: 		
  9410                                  ;							
  9411                                  ;	BITS	7	6	DRIVES			
  9412                                  ;		0	0	1			
  9413                                  ;		0	1	2			
  9414                                  ;		1	0	3			
  9415                                  ;		1	1	4			
  9416                                  ;************************************************************** 
  9417 00002BB0 0E                      		PUSH	CS
  9418 00002BB1 1F                      		POP	DS
  9419 00002BB2 0E                      		PUSH	CS
  9420 00002BB3 07                      		POP	ES
  9421                                  
  9422 00002BB4 E88B06                  		call	CMOS_CLOCK_READ  ;Before doing anything if CMOS clock,
  9423                                  				 ;then set the system time accordingly.
  9424                                  				 ;Also, reset the cmos clock rate.
  9425                                  
  9426 00002BB7 31F6                    		XOR	SI,SI
  9427 00002BB9 C704[0F1B]              		MOV	word [SI],HARDDRV ;set up pointer to hdrive
  9428                                  
  9429 00002BBD 58                      		POP	AX ; (***) ;number of floppies and FAT ID
  9430 00002BBE 30E4                    		XOR	AH,AH	; Chuck FAT ID byte
  9431 00002BC0 A2[1E02]                		MOV	[HARDNUM],AL ;Remember which drive is hard disk
  9432 00002BC3 A2[8301]                		MOV	[DRVMAX],AL  ;And set initial number of drives
  9433 00002BC6 D1E0                    		SHL	AX,1	;Two bytes per address
  9434 00002BC8 BF[7018]                		MOV	DI,DSKDRVS
  9435 00002BCB 01C7                    		ADD	DI,AX	;Point to hardfile location
  9436 00002BCD BE[7818]                		MOV	SI,HDSKTAB
  9437 00002BD0 A5                      		MOVSW		;Two addresses to move
  9438 00002BD1 A5                      		MOVSW
  9439 00002BD2 B280                    		mov	DL,80h	; tell rom bios to look at hard drives
  9440 00002BD4 B408                    		mov	AH,08h	; set command to get drive parameter
  9441 00002BD6 CD13                    		int	13h	; call ROM-BIOS to get number of drives
  9442 00002BD8 7204                    		jc	short ENDDRV ; old, rom therefore no hard disks
  9443 00002BDA 8816[0E1B]              		mov	[HNUM],DL ; save number of hard drives in HNUM
  9444                                  		; ES:DI = Address of Harddisk Parameter Table ; ((*))
  9445                                  ENDDRV:
  9446                                  ;
  9447                                  ; Scan the list of drives to determine their type.  We have three flavors of
  9448                                  ; diskette drives:
  9449                                  ;
  9450                                  ;   48tpi drives    We do nothing special for them
  9451                                  ;   96tpi drives    Mark the fact that they have changeline support.
  9452                                  ;   3 1/2 drives    Mark changeline support and small.
  9453                                  ;
  9454                                  ; The following code uses registers for certain values:
  9455                                  ;   DL - Physical Drive
  9456                                  ;   DS:DI - points to current BDS
  9457                                  ;   CX - Flag bits for BDS
  9458                                  ;   DH - Form Factor for the drive (1 - 48tpi, 2 - 96tpi, 3 - 3.5" medium)
  9459                                  ;
  9460 00002BDE 30D2                    		XOR	DL,DL	; start out with drive 0.
  9461                                  		; 17/06/2018
  9462                                  		;push	cs
  9463                                  		;pop	ds
  9464 00002BE0 C606[2402]09            		mov	byte [EOT],9
  9465 00002BE5 BF[1002]                		mov	di,START_BDS
  9466                                  LOOP_DRIVE:
  9467 00002BE8 3A16[8301]              		cmp	dl,[DRVMAX]
  9468 00002BEC 7203                    		jb	short GOT_MORE
  9469 00002BEE E90401                  		jmp	DONE_DRIVES
  9470                                  GOT_MORE:
  9471 00002BF1 31C9                    		xor	cx,cx		; zero all flags
  9472                                  		;mov	di,[DI+BDS.Link] ; get next BDS
  9473 00002BF3 8B3D                    		mov	di,[di] ; 05/07/2019
  9474 00002BF5 B600                    		mov	dh,ff48tpi	; Set Form Factor to 48 tpi
  9475 00002BF7 C606[9B29]28            		mov	byte [NUM_CYLN],40 ; 40 TRACKS PER SIDE
  9476                                  								
  9477                                  		;PUSH	DS						
  9478 00002BFC 57                      		PUSH	DI						
  9479 00002BFD 52                      		PUSH	DX						
  9480 00002BFE 51                      		PUSH	CX
  9481                                  		; 17/06/2018						
  9482                                  		;PUSH	ES						
  9483 00002BFF 0E                      		push	cs ; ((*))		
  9484                                  						
  9485 00002C00 B408                    		MOV	AH,08h		;GET DRIVE PARAMETERS
  9486 00002C02 CD13                    		INT	13h		;CALL ROM-BIOS		
  9487                                  		;JNC	short PARMSFROMROM					
  9488                                  		;JMP	short NOPARMSFROMROM ; GOT AN OLD ROM
  9489 00002C04 7277                    		jc	short NOPARMSFROMROM ; 03/06/2018
  9490                                  		; ES:DI = Address of Harddisk Parameter Table ; ((*))	
  9491                                  PARMSFROMROM:							
  9492                                  ;If CMOS is bad, it gives ES,AX,BX,CX,DH,DI=0. CY=0.	 
  9493                                  ;In this case, we are going to put bogus informations to BDS table.
  9494                                  ;We are going to set CH=39,CL=9,DH=1 to avoid divide overflow when	
  9495                                  ;they are calculated at the later time.  This is just for the Diagnostic
  9496                                  ;Diskette which need IO.SYS,MSDOS to boot up before it sets CMOS.	
  9497                                  ;This should only happen with drive B.	
  9498                                  
  9499                                  ;;Rev 3.30 Modification -----------------------------------------------
  9500 00002C06 80FD00                  		CMP	CH,0	; if ch=0, then cl,dh=0 too.	 
  9501 00002C09 7506                    		JNE	short PFR_OK							 
  9502 00002C0B B527                    		MOV	CH,39	; ROM gave wrong info.		 
  9503 00002C0D B109                    		MOV	CL,9	; Let's default to 360K.         
  9504 00002C0F B601                    		MOV	DH,1							 
  9505                                  PFR_OK: 								 
  9506 00002C11 FEC6                    		INC	DH	; MAKE NUMBER OF HEADS 1-BASED	 
  9507 00002C13 FEC5                    		INC	CH	; MAKE NUMBER OF CYLINDERS 1-BASED
  9508 00002C15 8836[9929]              		MOV	[NUM_HEADS],DH	; SAVE PARMS RETURNED BY ROM	 
  9509 00002C19 80E13F                  		AND	CL,00111111B	; EXTRACT SECTORS/TRACK 	 
  9510 00002C1C 880E[9A29]              		MOV	[SEC_TRK],CL						 
  9511 00002C20 882E[9B29]              		MOV	[NUM_CYLN],CH	; ASSUME LESS THAN 256 CYLINDERS!! 
  9512                                  ; MAKE SURE THAT EOT CONTAINS THE MAX NUM OF SEC/TRK IN SYSTEM OF FLOPPIES
  9513 00002C24 3A0E[2402]              		CMP	CL,[EOT]	; MAY SET CARRY 		 
  9514 00002C28 7604                    		JBE	short EOT_OK							
  9515 00002C2A 880E[2402]              		MOV	[EOT],CL						
  9516                                  EOT_OK: 							
  9517 00002C2E 07                      		POP	ES ; ((*)) es = cs = ds						
  9518 00002C2F 59                      		POP	CX						
  9519 00002C30 5A                      		POP	DX						
  9520 00002C31 5F                      		POP	DI						
  9521                                  		;POP	DS						
  9522                                  ;
  9523                                  ; Check for presence of changeline
  9524                                  ;
  9525 00002C32 B415                    		mov	AH,15h      	; set command to get DASD type
  9526 00002C34 CD13                    		int	13h	     	; call ROM-BIOS
  9527 00002C36 720D                    		JC	short CHANGELINE_DONE 	
  9528 00002C38 80FC02                  		CMP	AH,2		; CHECK FOR PRESENCE OF CHANGELINE
  9529 00002C3B 7508                    		JNE	short CHANGELINE_DONE 					 
  9530                                  ;;End of Modification -----------------------------------------------
  9531                                  
  9532                                  ;
  9533                                  ; We have a drive with change line support.
  9534                                  ;
  9535 00002C3D 80C902                  		or	CL,fChangeline	; signal type
  9536 00002C40 C606[8601]01            		mov	byte [fHave96],1 ; Remember that we have 96tpi disks
  9537                                  ;									  
  9538                                  ; WE NOW TRY TO SET UP THE FORM FACTOR FOR THE TYPES OF MEDIA THAT WE KNOW
  9539                                  ; AND CAN RECOGNISE. FOR THE REST, WE SET THE FORM FACTOR AS "OTHER".     
  9540                                  ;									  
  9541                                  CHANGELINE_DONE:							  
  9542                                  ; 40 CYLINDERS AND 9 OR LESS SEC/TRK, TREAT AS 48 TPI MEDIUM.		  
  9543 00002C45 803E[9B29]28            		CMP	byte [NUM_CYLN],40						  
  9544 00002C4A 750B                    		JNZ	short TRY_80							  
  9545 00002C4C 803E[9A29]09            		CMP	byte [SEC_TRK],9						  
  9546                                  		;JBE	short GOT_FF
  9547 00002C51 7653                    		jbe	short NEXTDRIVE ; 03/06/2018							  
  9548                                  GOTOTHER:								  
  9549 00002C53 B607                    		MOV	DH,ffOther	; WE HAVE A "STRANGE" MEDIUM     
  9550                                  		;JMP	SHORT GOT_FF
  9551 00002C55 EB4F                    		jmp	short NEXTDRIVE	; 03/06/2018				  
  9552                                  
  9553                                  ;									  
  9554                                  ; 80 CYLINDERS AND 9 SECTORS/TRACK => 720 KB DEVICE			  
  9555                                  ; 80 CYLINDERS AND 15 SEC/TRK => 96 TPI MEDIUM				  
  9556                                  ;									  
  9557                                  TRY_80: 
  9558                                  	; 03/06/2018 - Retro DOS v3.0 - MSDOS 6.0 (MSINIT.ASM, 1991) modifications
  9559                                  	
  9560 00002C57 803E[9B29]50            		CMP	byte [NUM_CYLN],80						
  9561 00002C5C 75F5                    		JNZ	short GOTOTHER
  9562                                  
  9563                                  		; 03/06/2018 (MSDOS 6.0, MSINIT.ASM, 1991)
  9564 00002C5E B609                    		mov	dh,ff288	   ; assume 2.88 MB drive m037
  9565 00002C60 803E[9A29]24            		cmp	byte [SEC_TRK],36  ; is it ?		  m037
  9566 00002C65 743F                    		je	short NEXTDRIVE	   ; yeah, go update	  m037
  9567                                  
  9568 00002C67 803E[9A29]0F            		CMP	byte [SEC_TRK],15						
  9569 00002C6C 740B                    		JZ	short GOT96							
  9570 00002C6E 803E[9A29]09            		CMP	byte [SEC_TRK],9						
  9571 00002C73 75DE                    		JNZ	short GOTOTHER	 ; (1.44MB, 3.5" diskette drive)
  9572 00002C75 B602                    		MOV	DH,ffSmall
  9573                                  		;JMP	SHORT GOT_FF
  9574 00002C77 EB2D                    		jmp	short NEXTDRIVE
  9575                                  GOT96:	
  9576 00002C79 B601                    		MOV	DH,ff96tpi
  9577                                  ;GOT_FF: 
  9578 00002C7B EB29                    		JMP	SHORT NEXTDRIVE 
  9579                                  
  9580                                  ; WE HAVE AN OLD ROM, SO WE EITHER HAVE A 48TPI OR 96TPI DRIVE. IF THE DRIVE
  9581                                  ; HAS CHANGELINE, WE ASSUME IT IS A 96TPI, OTHERWISE IT IS A 48TPI.
  9582                                  
  9583                                  NOPARMSFROMROM:
  9584 00002C7D 07                      		POP	ES ; ; ((*))
  9585 00002C7E 59                      		POP	CX
  9586 00002C7F 5A                      		POP	DX
  9587 00002C80 5F                      		POP	DI
  9588                                  		;POP	DS
  9589                                  
  9590 00002C81 B415                    		MOV	AH,15h		; SET COMMAND TO GET DASD TYPE
  9591 00002C83 CD13                    		INT	13h		; CALL ROM-BIOS
  9592 00002C85 721F                    		JC	short NEXTDRIVE
  9593 00002C87 80FC02                  		CMP	AH,2		; IS THERE CHANGELINE?
  9594 00002C8A 751A                    		JNZ	short NEXTDRIVE
  9595 00002C8C 80C902                  		OR	CL,fChangeline
  9596 00002C8F C606[8601]01            		MOV	byte [fHave96],1 ; REMEMBER WE HAVE 96TPI DRIVES
  9597 00002C94 C606[9B29]50            		MOV	byte [NUM_CYLN],80
  9598 00002C99 B601                    		MOV	DH,ff96tpi
  9599 00002C9B B00F                    		MOV	AL,15		; SET EOT IF NECESSARY
  9600 00002C9D 3A06[2402]              		CMP	AL,[EOT]
  9601 00002CA1 7603                    		JBE	short EOT_OK2
  9602 00002CA3 A2[2402]                		MOV	[EOT],AL
  9603                                  EOT_OK2:
  9604                                  NEXTDRIVE:
  9605 00002CA6 80C920                  		or	cl,fI_Own_Physical ; set this true for all drives
  9606 00002CA9 88D7                    		mov	bh,dl	 	;save Int13 drive number
  9607                                  
  9608                                  ; we need to do special things if we have a single drive system and are setting
  9609                                  ; up a logical drive. it needs to have the same int13 drive number as its
  9610                                  ; counterpart, but the next drive letter. also reset ownership flag.
  9611                                  ; we detect the presence of this situation by examining the flag single for the
  9612                                  ; value 2.
  9613                                  
  9614 00002CAB 803E[8801]02            		cmp	byte [Single],2
  9615 00002CB0 7505                    		jnz	short NOT_SPECIAL
  9616 00002CB2 FECF                    		dec	bh	; int13 drive number same for logical drive
  9617                                  	 			; reset ownership flag for logical drive
  9618 00002CB4 80F120                  		xor	cl,fI_Own_Physical
  9619                                  NOT_SPECIAL:
  9620                                  ; The values that we put in for RHdlim and RSeclim will only remain if the
  9621                                  ; form factor is of type "ffOther".
  9622                                  		
  9623 00002CB7 31C0                    		xor	ax,ax			; fill BDS for drive
  9624 00002CB9 A0[9929]                		mov	al,[NUM_HEADS]
  9625 00002CBC 89453C                  		mov	[di+BDS.RHDLIM],ax
  9626 00002CBF A0[9A29]                		mov	al,[SEC_TRK]
  9627 00002CC2 89453A                  		mov	[di+BDS.RSECLIM],ax
  9628 00002CC5 894D29                  		mov	[di+BDS.Flags],cx
  9629 00002CC8 887528                  		mov	[di+BDS.FormFactor],dh
  9630 00002CCB 885505                  		mov	[di+BDS.DriveLet],dl
  9631 00002CCE 887D04                  		mov	[di+BDS.DriveNum],bh
  9632 00002CD1 8A1E[9B29]              		mov	bl,[NUM_CYLN]
  9633 00002CD5 885D2B                  		mov	[di+BDS.cCyln],bl	; only the l.s. byte is set here
  9634 00002CD8 803E[8801]01            		cmp	byte [Single],1		; Special case for single drive system
  9635 00002CDD 7511                    		jnz	short NO_SINGLE
  9636                                  						; Don't forget we have
  9637 00002CDF C606[8801]02            		mov	byte [Single],2		;   single drive system
  9638 00002CE4 83C910                  		or	cx,fI_Am_Mult		; set that this is one of
  9639                                  						;   several drives
  9640 00002CE7 094D29                  		or	[di+BDS.Flags],cx	; save flags
  9641                                  		;mov	di,[di+BDS.Link]	; move to next BDS in list
  9642 00002CEA 8B3D                    		mov	di,[di] ; 05/07/2019
  9643 00002CEC FEC2                    		inc	dl			; add a number
  9644 00002CEE EBB6                    		jmp	short NEXTDRIVE		; Use same info for BDS as previous
  9645                                  NO_SINGLE:
  9646 00002CF0 FEC2                    		inc	dl
  9647 00002CF2 E9F3FE                  		jmp	LOOP_DRIVE	
  9648                                  
  9649                                  DONE_DRIVES:
  9650                                  		;mov	ax,-1			; Signify end of list by
  9651                                  		;mov	[di+BDS.Link],ax	;    setting pointer to -1
  9652                                  		;mov	word [di+BDS.Link],-1 ; 03/07/2018
  9653 00002CF5 C705FFFF                		mov	word [di],-1 ; 05/07/2019
  9654                                  ;
  9655                                  ; Set up all the hard drives in the system
  9656                                  ;
  9657                                  		; 03/06/2018	
  9658                                  DoHard:
  9659 00002CF9 803E[0E1B]00            		cmp	byte [HNUM], 0		; IF (No_Hard_files)
  9660 00002CFE 7E4F                    		jle	short STATIC_CONFIGURE 	;    THEN EXIT TO CONFIGURE
  9661 00002D00 B280                    		mov	DL,80h			; set first hard file number
  9662 00002D02 BF[101B]                		mov	di,BDSH		    	; Set up first hard file.
  9663 00002D05 8A1E[1E02]              		mov	bl,[HARDNUM]
  9664 00002D09 E8A301                  		call	SETHARD
  9665 00002D0C 730D                    		jnc	short HardFile1_OK
  9666 00002D0E FE0E[0E1B]              		dec	byte [HNUM]		; First hard file is bad.
  9667 00002D12 803E[0E1B]00            		cmp	byte [HNUM],0		; IF (Second_Hard_File)
  9668 00002D17 7F15                    		jg	short Second_Hard	;   THEN Set up second hard file
  9669 00002D19 EB34                    		JMP	SHORT STATIC_CONFIGURE	
  9670                                  	
  9671                                  HardFile1_OK:
  9672 00002D1B E8ECEC                  		call	INSTALL_BDS	    	; install BDS into linked list
  9673 00002D1E 803E[0E1B]02            		cmp	byte [HNUM],2		; IF (Only_one_hardfile)
  9674 00002D23 7219                    		jb	short SetIt	    	;    THEN SetIt "in place"
  9675                                  
  9676 00002D25 8A1E[1E02]              		mov	bl,[HARDNUM]
  9677 00002D29 FEC3                    		inc	BL			; next drive letter
  9678 00002D2B BF[621B]                		mov	di,BDSX
  9679                                  Second_Hard:					; SETUP Second Hard FILE
  9680 00002D2E B281                    		mov	DL,81h			; set second hard file number
  9681 00002D30 E87C01                  		call	SETHARD
  9682 00002D33 7306                    		jnc	short HardFile2_OK
  9683 00002D35 FE0E[0E1B]              		dec	byte [HNUM]
  9684 00002D39 EB03                    		jmp	short SetIt
  9685                                  
  9686                                  HardFile2_OK:
  9687 00002D3B E8CCEC                  		call	INSTALL_BDS
  9688                                  SetIt:
  9689 00002D3E A0[0E1B]                		mov	al,[HNUM]
  9690 00002D41 08C0                    		or	al,al
  9691 00002D43 740A                    		jz	short STATIC_CONFIGURE
  9692 00002D45 0206[1E02]              		add	al,[HARDNUM]
  9693 00002D49 A2[8301]                		mov	[DRVMAX],al
  9694                                  
  9695                                  ; End of physical drive initialization.	
  9696                                  ; *** Do not change the position of the following statement.
  9697                                  ; *** DoMini routine will use [DRVMAX] value for the start of the logical
  9698                                  ; *** drive number of Mini disk(s).
  9699                                  
  9700 00002D4C E8C403                  		call    DoMini		;For setting up mini disks, if found
  9701                                  
  9702                                  ; End of drive initialization.
  9703                                  
  9704                                  ; 03/06/2018 - Retro DOS v3.0
  9705                                  
  9706                                  ;9/24/86 We now decide, based on the configurations available so far,
  9707                                  ;what code or data we need to keep as a stay resident code. The following
  9708                                  ;table shows the configurations under consideration. They are listed in  
  9709                                  ;the order of their current position memory.				  
  9710                                  ;Configuration will be done in two ways:				  
  9711                                  ;First, we are going to set "Static configuration".  Static configuration 
  9712                                  ;will consider from basic configuration to ENDOF96TPI configuration.	  
  9713                                  ;The result of static configuration will be the address the Dynamic	  
  9714                                  ;configuration will use to start with.					  
  9715                                  ;Secondly, "Dynamic cofiguration" will be performed. Dynamic configuration
  9716                                  ;involves possible relocation of CODE/DATA. Dynamic configuration routine 
  9717                                  ;will take care of BDSM tables and AT ROM Fix module thru K09 suspend/res 
  9718                                  ;code individually. After these operation, FINAL_DOS_LOCATION will be set.
  9719                                  ;This will be the place SYSINIT routine will relocate MSDOS module.	  
  9720                                  ;									  
  9721                                  ;   1.	 BASIC CONFIGURATION FOR MSBIO (EndFloppy, EndSwap)		  
  9722                                  ;   2.	 ENDONEHARD							  
  9723                                  ;   3.	 ENDTWOHARD							  
  9724                                  ;   4.	 END96TPI	;a system that supports "Change Line Error"       
  9725                                  ;   5.	 End of BDSM	;BDSM tables for mini disks.			  
  9726                                  ;   6.	 ENDATROM	;Some of AT ROM fix module.			  
  9727                                  ;   7.	 ENDCMOSCLOCKSET;Supporting program for CMOS clock write.	  
  9728                                  ;   8.	 ENDK09 	;K09 CMOS Clock module to handle SUSPEND/RESUME   
  9729                                  ;									  
  9730                                  ;9/24/86.								  
  9731                                  									  
  9732                                  ; *** For mini disk configuration. 4/7/86	 			  
  9733                                  ; *** END_OF_BDSM will contain the ending address(off) of BDSM table for  
  9734                                  ; *** mini disks which is located right after the label END96TPI.	  
  9735                                  ; *** The variable NUM_MINI_DSK will indicate the existance. 4/7/86	  
  9736                                  									  
  9737                                  STATIC_CONFIGURE:							  
  9738                                  		; 05/07/2019						  
  9739                                  		;PUSH	AX ; !@	
  9740                                  							  
  9741 00002D4F B8[651E]                		mov	ax,End96tpi		;let's start with the biggest one.
  9742 00002D52 803E[8601]00            		cmp	byte [fHave96],0	;Is change line support there?	  
  9743 00002D57 7518                    		jnz	short Config96		;Yes.				 
  9744                                  									  
  9745 00002D59 B8[B31B]                		mov	ax,EndTwoHard					
  9746 00002D5C 803E[0E1B]01            		cmp	byte [HNUM],1 		;1 hard file?			
  9747 00002D61 7602                    		jbe	short No_Two_HRD						 
  9748 00002D63 EB2C                    		jmp	short ConfigTwoHard						
  9749                                  No_Two_HRD:								
  9750 00002D65 B8[611B]                		mov	ax,EndOneHard					
  9751 00002D68 7502                    		jnz	short Basic_Floppy						
  9752 00002D6A EB25                    		jmp	short ConfigOneHard						
  9753                                  Basic_Floppy:								
  9754 00002D6C B8[0E1B]                		mov	ax,EndFloppy					 
  9755 00002D6F EB30                    		jmp	short DYNAMIC_CONFIGURE	;static configuration is done!	
  9756                                  ;
  9757                                  ; Keep the 96tpi code
  9758                                  ;
  9759                                  Config96:
  9760                                  ;
  9761                                  ; Save old INT 13 vector
  9762                                  ;
  9763 00002D71 50                      		PUSH	AX
  9764 00002D72 1E                      		PUSH	DS
  9765 00002D73 31C0                    		XOR	AX,AX
  9766 00002D75 8ED8                    		MOV	DS,AX
  9767 00002D77 A14C00                  		MOV	AX,[4*13h]
  9768 00002D7A 2EA3[CB1C]              		MOV	[CS:REAL13],AX
  9769 00002D7E A14E00                  		MOV	AX,[4*13h+2]
  9770 00002D81 2EA3[CD1C]              		MOV	[CS:REAL13+2],AX
  9771                                  ;
  9772                                  ; Insert new vector
  9773                                  ;
  9774 00002D85 C7064C00[D51C]          		MOV	word [4*13h],INT13
  9775 00002D8B 8C0E4E00                		MOV	[4*13h+2],CS
  9776 00002D8F 1F                      		POP	DS
  9777 00002D90 58                      		POP	AX
  9778                                  ;
  9779                                  ; Keep two hard disk BPBs
  9780                                  ;
  9781                                  ConfigTwoHard:
  9782                                  ;
  9783                                  ; Keep one hard disk BPB
  9784                                  ;
  9785                                  ConfigOneHard:
  9786                                  ;
  9787                                  ; Adjust the number of drives to include the hard disks.
  9788                                  ;
  9789 00002D91 50                      		PUSH	AX
  9790 00002D92 A0[1E02]                		MOV	AL,[HARDNUM]
  9791 00002D95 0206[0E1B]              		ADD	AL,[HNUM]
  9792 00002D99 0206[DA29]              		add	al,[num_mini_dsk] ;4/7/86 for mini disks installed	
  9793                                  				;if not installed, then num_mini_dsk = 0.
  9794 00002D9D A2[8301]                		MOV	[DRVMAX],AL
  9795 00002DA0 58                      		POP	AX
  9796                                  
  9797                                  DYNAMIC_CONFIGURE:
  9798 00002DA1 E8D800                  		call	Get_Para_Offset ;For dynamic allocation, we are
  9799                                  					;going to use offset address that
  9800                                  					;is in paragraph boundary.
  9801                                  		; 17/06/2018 (es=cs=ds)
  9802                                  		;push	cs
  9803                                  		;pop	es		;es -> code
  9804                                  		
  9805 00002DA4 FC                      		cld			;clear direction
  9806                                  
  9807 00002DA5 803E[DA29]00            		cmp	byte [num_mini_dsk], 0	;Mini disk(s) installed ?
  9808 00002DAA 7406                    		jz	short CheckATROM	;No.
  9809                                  		; 03/07/2018
  9810 00002DAC A1[D629]                		mov	ax,[End_Of_BDSM]	;set the new ending address
  9811 00002DAF E8CA00                  		call	Get_Para_Offset 	
  9812                                  CheckATROM:				
  9813 00002DB2 803E[9C29]FC            		cmp	byte [MODEL_BYTE],0FCh	;AT ?
  9814 00002DB7 7535                    		jnz	short CheckCMOSClock				
  9815 00002DB9 803E[0E1B]00            		cmp	byte [HNUM],0 		;No hard file?	
  9816 00002DBE 742E                    		jz	short CheckCMOSClock			
  9817 00002DC0 BE00F0                  		mov	si,0F000h					
  9818 00002DC3 8EC6                    		mov	es,si			;ES -> BIOS segment
  9819 00002DC5 BE[E229]                		mov	si,Bios_Date			
  9820 00002DC8 BFF5FF                  		mov	di,0FFF5H	;ROM BIOS string is at F000:FFF5
  9821                                  Cmpbyte:				;Only patch ROM for bios 01/10/84
  9822 00002DCB A6                      		cmpsb							
  9823 00002DCC 7520                    		jnz	short CheckCMOSClock					
  9824 00002DCE 807CFF00                		cmp	byte [si-1],0				
  9825 00002DD2 75F7                    		jnz	short Cmpbyte 					
  9826                                  SetRomCode:				;Now we have to install ROM fix
  9827                                  					;AX is the address to move.
  9828 00002DD4 0E                      		push	cs						
  9829 00002DD5 07                      		pop	es		;set ES to CODE seg	
  9830 00002DD6 A3[B400]                		mov	[ORIG13],ax				
  9831 00002DD9 8C0E[B600]              		mov	[ORIG13+2],cs	;set new ROM bios int 13 vector
  9832 00002DDD B9[E826]                		mov	cx,ENDATROM				
  9833 00002DE0 BE[BC25]                		mov	si,IBM_DISK_IO				
  9834 00002DE3 29F1                    		sub	cx,si		;size of AT ROM FIX module
  9835 00002DE5 89C7                    		mov	di,ax		;destination	
  9836 00002DE7 F3A4                    		rep	movsb		;relocate it		
  9837 00002DE9 89F8                    		mov	ax,di		;new ending address
  9838 00002DEB E88E00                  		call	Get_Para_Offset ;in AX			
  9839                                  CheckCMOSClock: 						
  9840 00002DEE 0E                      		push	cs						
  9841 00002DEF 07                      		pop	es		 ;set ES to CODE seg	
  9842 00002DF0 803E[6608]01            		cmp	byte [HaveCMOSClock],1 ;CMOS Clock exists?	
  9843 00002DF5 7528                    		jne	short CheckK09					
  9844 00002DF7 A3[7708]                		mov	[DaycntToDay],ax ;set the address for MSCLOCK
  9845 00002DFA B9[BA27]                		mov	cx,EndDaycntToDay			
  9846 00002DFD BE[E826]                		mov	si,Daycnt_To_Day				 
  9847 00002E00 29F1                    		sub	cx,si		;size of CMOS clock sub routine  
  9848 00002E02 89C7                    		mov	di,ax							  
  9849 00002E04 F3A4                    		rep	movsb							
  9850 00002E06 89F8                    		mov	ax,di						
  9851 00002E08 E87100                  		call	Get_Para_Offset 					 
  9852 00002E0B A3[7508]                		mov	[BinToBCD],ax	;set the address for MSCLOCK
  9853 00002E0E B9[C927]                		mov	cx,EndCMOSClockSet				
  9854 00002E11 BE[BA27]                		mov	si,Bin_To_BCD				
  9855 00002E14 29F1                    		sub	cx,si							
  9856 00002E16 89C7                    		mov	di,ax							
  9857 00002E18 F3A4                    		rep	movsb							
  9858 00002E1A 89F8                    		mov	ax,di							
  9859 00002E1C E85D00                  		call	Get_Para_Offset 					
  9860                                  CheckK09:								
  9861 00002E1F 50                      		push	ax		;save ax	     		
  9862 00002E20 B80041                  		mov	ax,4100h	;Q: is it a K09 	     
  9863 00002E23 B300                    		mov	bl,0		;
  9864                                  		;xor	bl,bl			  
  9865 00002E25 CD15                    		int	15h		;			   
  9866 00002E27 58                      		pop	ax						
  9867 00002E28 7228                    		jc	short ConfigDone					
  9868                                  								
  9869 00002E2A BE[CA27]                		mov	si,INT6C				
  9870 00002E2D B9[9629]                		mov	cx,ENDK09					
  9871 00002E30 29F1                    		sub	cx,si		;size of K09 routine	
  9872 00002E32 89C7                    		mov	di,ax							
  9873 00002E34 57                      		push	di		;save destination		
  9874 00002E35 F3A4                    		rep	movsb							
  9875 00002E37 89F8                    		mov	ax,di					
  9876 00002E39 E84000                  		call	Get_Para_Offset ;AX = new ending address	
  9877 00002E3C 5F                      		pop	di							
  9878                                  								
  9879 00002E3D 50                      		push	ax							 
  9880 00002E3E 1E                      		push	ds							
  9881 00002E3F C606[8701]01            		mov	byte [fHaveK09],1 ;remember we have a K09 type	
  9882 00002E44 31C0                    		xor	ax,ax							
  9883 00002E46 8ED8                    		mov	ds,ax							
  9884 00002E48 893EB001                		mov	[4*6Ch],di	;new INT 6Ch handler	
  9885 00002E4C 8C0EB201                		mov	[4*6Ch+2],cs					
  9886 00002E50 1F                      		pop	ds							
  9887 00002E51 58                      		pop	ax		;restore the ending address	
  9888                                  ;
  9889                                  ; Set up config stuff for SYSINIT
  9890                                  ;
  9891                                  ConfigDone:
  9892                                  		; 03/06/2018 - Retro DOS v3.0	
  9893                                  		;; 07/04/2018
  9894                                  		;MOV	AX,END_OF_HD2P_TBL
  9895                                  		; 06/04/2018
  9896                                  		;MOV	AX,INIT
  9897 00002E52 83C00F                  		ADD	AX,15
  9898                                  		;SHR	AX,1
  9899 00002E55 D1D8                    		RCR	AX,1
  9900 00002E57 D1E8                    		SHR	AX,1
  9901 00002E59 D1E8                    		SHR	AX,1
  9902 00002E5B D1E8                    		SHR	AX,1
  9903 00002E5D 83C070                  		ADD	AX,KERNEL_SEGMENT
  9904                                  		;MOV	[SYSINIT_START+FINAL_DOS_LOCATION],AX
  9905                                  		; 05/07/2018
  9906 00002E60 A3[0A3B]                		MOV	[SYSINIT+FINAL_DOS_LOCATION],AX
  9907                                  
  9908                                  		; 05/07/2019
  9909                                  		;POP	AX ; !@
  9910                                  
  9911                                  		; 03/06/2018
  9912                                  		; 19/03/2018
  9913 00002E63 B96975                  		mov	cx,msdos_bin_size+1
  9914 00002E66 D1E9                    		shr	cx,1
  9915                                  		;mov	[SYSINIT_START+DOSSIZE],cx ; DOS size in words
  9916                                  		; 05/07/2018
  9917 00002E68 890E[103B]              		mov	[SYSINIT+DOSSIZE],cx
  9918                                  
  9919                                  		; 03/06/2018
  9920 00002E6C 803E[8601]00            		CMP	BYTE [fHave96],0
  9921 00002E71 7503                    		JNZ	SHORT ReadDos
  9922 00002E73 E87B02                  		call	PURGE_96TPI	;mjb001 eliminate calls to 96tpi hoohah
  9923                                  
  9924                                  ReadDos:
  9925                                  		; 06/07/2019
  9926                                  
  9927                                  		; 19/03/2018 (*) No need to read remain clusters of
  9928                                  		; MSDOS kernel because of Retro DOS v2.0 boot sector
  9929                                  		; has loaded all of the kernel file before.
  9930                                  		; ;("MSINIT.ASM" contains kernel file reading code here...)  
  9931                                  
  9932                                  		; 30/03/2018
  9933                                  		;mov	ax,[DRVFAT]
  9934                                  		;call	SETDRIVE
  9935                                  		;call	GETBP
  9936                                  		
  9937                                  		; 24/02/2018 - Retro DOS 2.0 - MSDOS 3.3 ("MSINIT.ASM")
  9938                                  
  9939 00002E76 E8D201                  		CALL	SETDRVPARMS
  9940                                  		
  9941                                  		; 06/07/2018
  9942                                  		
  9943                                  		; 03/06/2018 - Retro DOS v3.0
  9944                                  		;JMP	SYSINIT
  9945                                  		; 05/07/2018
  9946 00002E79 E96D04                  		jmp	_SYSINIT ; GOINIT
  9947                                  
  9948                                  ;-----------------------------------------------------------------------------
  9949                                  ; 03/06/2018 - Retro DOS v3.0
  9950                                  
  9951                                  Get_Para_Offset:
  9952                                  ;in:  AX - offset value
  9953                                  ;out: AX - offset value adjusted for the next paragraph boundary.
  9954 00002E7C 83C00F                  		add	ax, 15		;make a paragraph
  9955 00002E7F D1D8                    		rcr	ax, 1	
  9956 00002E81 D1E8                    		shr	ax, 1	
  9957 00002E83 D1E8                    		shr	ax, 1
  9958 00002E85 D1E8                    		shr	ax, 1
  9959 00002E87 D1E0                    		shl	ax, 1		;now, make it back to offset value
  9960 00002E89 D1E0                    		shl	ax, 1
  9961 00002E8B D1E0                    		shl	ax, 1
  9962 00002E8D D1E0                    		shl	ax, 1
  9963 00002E8F C3                      		retn
  9964                                  
  9965                                  ; 01/07/2018
  9966                                  ;;
  9967                                  ;;	READ A FAT SECTOR INTO fat location
  9968                                  ;;
  9969                                  ;GETFAT:
  9970                                  ;		XOR	DI,DI			; offset
  9971                                  ;		MOV	DX,1			; relative sector (1st sector of fat)
  9972                                  ;		MOV	CX,[FatLen]		; read entire fat.
  9973                                  ;		MOV	AX,[FatLoc]		;
  9974                                  ;		MOV	ES,AX			; location to read
  9975                                  ;		MOV	AX,[DRVFAT]		; AH FAT ID byte, AL drive
  9976                                  ;		JMP	DISKRD
  9977                                  
  9978                                  
  9979                                  ; 02/06/2018 - Retro DOS v3.0	
  9980                                  ; 19/03/2018 - Retro DOS v2.0
  9981                                  
  9982                                  ;	READ A BOOT RECORD INTO 7C0h:BootBias
  9983                                  ;  GetBoot reads the boot record into 7C0h:BootBias
  9984                                  ;  On Entry:
  9985                                  ;	DL contains ROM drive number (80h or 81h)
  9986                                  ;  On Exit:
  9987                                  ;	if carry set error
  9988                                  ;	if carry clear:
  9989                                  ;	   ES:BX piont to boot sector
  9990                                  ;	AX and CX are not preserved
  9991                                  ;	BX and ES are used to return values
  9992                                  ;
  9993                                  GETBOOT:
  9994                                  		; 08/04/2018
  9995                                  		; Retro DOS v2.0 (IBMBIO.COM, IBMDOS 2.1)
  9996                                  
  9997                                  		;mov	AX, 07C0h     ; prepare to load ES
  9998                                  		; 28/03/2018 - MSDOS 6.0 - MSINIT.ASM, 1991	
  9999                                  		;mov	ax, [cs:init_bootseg]
 10000 00002E90 A1[092A]                		mov	ax, [init_bootseg]
 10001 00002E93 8EC0                    		mov	ES, AX	      ; load ES segment register
 10002 00002E95 BB0002                  		mov	BX, BootBias  ; load BX,  ES:BX is where sector goes
 10003 00002E98 B80102                  		mov	AX, 0201h     ; command to read & num sec. to 1
 10004 00002E9B 30F6                    		xor	DH, DH	      ; head number zero
 10005 00002E9D B90100                  		mov	CX, 0001h     ; cylinder zero and sector one
 10006 00002EA0 CD13                    		int	13h	      ; call rom bios
 10007 00002EA2 720A                    		jc	short ERRET
 10008 00002EA4 26813EFE0355AA          		cmp	WORD [ES:BootBias+1FEH],0AA55H	; DAVE LITTON MAGIC WORD?
 10009 00002EAB 7401                    		je	short Norm_Ret
 10010 00002EAD F9                      		stc
 10011                                  ERRET:
 10012                                  Norm_Ret:
 10013 00002EAE C3                      		RETN
 10014                                  
 10015                                  ;
 10016                                  ;   SetHard - generate BPB for a variable sized hard file.  IBM has a
 10017                                  ;   partitioned hard file; we must read physical sector 0 to determine where
 10018                                  ;   our own logical sectors start.  We also read in our boot sector to
 10019                                  ;   determine version number
 10020                                  ;
 10021                                  ;   Inputs:	DL is ROM drive number (80 OR 81)
 10022                                  ;		DS:DI points to BDS
 10023                                  ;   Outputs:	Carry clear -> BPB is filled in
 10024                                  ;		Carry set   -> BPB is left uninitialized due to error
 10025                                  ;
 10026                                  
 10027                                  SETHARD:
 10028                                  		; 03/06/2018 - Retro DOS v3.0
 10029                                  		; (20/03/2018 - Retro DOS v2.0)
 10030                                  
 10031 00002EAF 57                      		push	di
 10032 00002EB0 53                      		push	bx
 10033 00002EB1 1E                      		push	ds
 10034 00002EB2 885D05                  		mov	byte [di+BDS.DriveLet],bl
 10035 00002EB5 885504                  		mov	byte [di+BDS.DriveNum],dl
 10036 00002EB8 31C0                    		xor	ax,ax
 10037 00002EBA 0C01                    		or	al,fNon_Removable
 10038 00002EBC 094529                  		or	[di+BDS.Flags],ax
 10039 00002EBF C6452805                		mov	byte [di+BDS.FormFactor],ffHardFile
 10040 00002EC3 C606[9829]00            		mov	byte [fBigFAT],0	; Assume 12 bit FAT
 10041 00002EC8 52                      		PUSH	DX
 10042                                  
 10043 00002EC9 B408                    		mov	AH,8		; set command to get drive parameters
 10044 00002ECB CD13                    		int	13h		; call rom-bios disk routine
 10045                                  
 10046                                  				; DH is number of heads-1
 10047                                  				; DL is number of hard disks attached
 10048                                  				; Low 6 bits of CL is sectors/track
 10049                                  				; High 2 bits of CL with CH are max # of cylinders
 10050 00002ECD FEC6                    		INC	DH		; get number of heads
 10051 00002ECF 887515                  		MOV	[DI+BDS.HDLIM],DH
 10052 00002ED2 5A                      		POP	DX
 10053 00002ED3 7223                    		JC	short SETRET	; carry here means no hard disk
 10054 00002ED5 80E13F                  		AND	CL,3FH		; extract number of sectors/track
 10055 00002ED8 884D13                  		MOV	[DI+BDS.SECLIM],CL
 10056 00002EDB E8B2FF                  		CALL	GETBOOT		;   if (getBoot ())
 10057 00002EDE 7218                    		JC	short SETRET	;	return -1;
 10058 00002EE0 BBC203                  		MOV	BX,1C2H+BootBias ;   p = &boot[0x1C2];
 10059                                  SET1:
 10060 00002EE3 26803F01                		CMP	BYTE [ES:BX],1	;   while (p->PartitionType != 1 &&
 10061 00002EE7 7418                    		JZ	short SET2
 10062 00002EE9 26803F04                		CMP	Byte [ES:BX],4	;	p->PartitionType != 4) {
 10063 00002EED 7412                    		JZ	short SET2
 10064 00002EEF 83C310                  		ADD	BX,16		;	p += sizeof Partition;
 10065 00002EF2 81FB0204                		CMP	BX,202H+BootBias ;	if (p == &boot[0x202h])
 10066 00002EF6 75EB                    		JNZ	short SET1	;	    return -1;
 10067                                  SETRET:
 10068 00002EF8 F9                      		STC			;	}
 10069 00002EF9 E94B01                  		jmp	Ret_Hard
 10070                                  
 10071                                  ; --- install a mini disk. BX value saved ---
 10072                                  
 10073                                  SetMini:								 
 10074 00002EFC 57                      		push	di							 
 10075 00002EFD 53                      		push	bx							 
 10076 00002EFE 1E                      		push	ds							 
 10077 00002EFF EBE2                    		jmp	short SET1	;will be returned to Find mini partition routine.
 10078                                  					;Some logic has been added to SET1 to 
 10079                                  					;deal with Mini disks.
 10080                                  SET2:
 10081 00002F01 52                      		PUSH	DX
 10082 00002F02 268B4704                		MOV	AX,[ES:BX+4]
 10083 00002F06 268B5706                		MOV	DX,[ES:BX+6]
 10084                                  
 10085                                  ;Decrement the sector count by 1 to make it zero based. Exactly 64k
 10086                                  ;sectors should be allowed	 
 10087                                  ;				 
 10088 00002F0A 83E801                  		SUB	AX,1		; PTM 901    12/12/86 MT
 10089 00002F0D 83DA00                  		SBB	DX,0		; PTM 901    12/12/86 MT
 10090                                  
 10091 00002F10 26034708                		ADD	AX,[ES:BX+8]
 10092 00002F14 2613570A                		ADC	DX,[ES:BX+10]
 10093 00002F18 7405                    		JZ	short OKDrive
 10094 00002F1A 800E[9829]80            		OR	byte [fBigFAT],fTOOBIG
 10095                                  OKDrive:
 10096 00002F1F 5A                      		POP	DX
 10097 00002F20 268B4704                		MOV	AX,[ES:BX+4]
 10098 00002F24 894517                  		MOV	[DI+BDS.HIDSEC],AX	; BPB->HidSecCt = p->PartitionBegin;
 10099 00002F27 268B4708                		MOV	AX,[ES:BX+8]
 10100 00002F2B 83F840                  		CMP	AX,64		;  if (p->PartitionLength < 64)
 10101 00002F2E 72C8                    		JB	short SETRET	;	return -1;
 10102                                  
 10103 00002F30 89450E                  		MOV	[DI+BDS.DRVLIM],AX ; BPB->MaxSec = p->PartitionLength;
 10104 00002F33 50                      		PUSH	AX
 10105                                  
 10106 00002F34 52                      		PUSH	DX
 10107 00002F35 8B4517                  		MOV	AX,[DI+BDS.HIDSEC]	; boot sector number
 10108 00002F38 31D2                    		XOR	DX,DX
 10109 00002F3A 88F7                    		MOV	BH,DH
 10110 00002F3C 8A5D13                  		MOV	BL,[DI+BDS.SECLIM]
 10111 00002F3F F7F3                    		DIV	BX
 10112 00002F41 88D1                    		MOV	CL,DL			; CL is sector number
 10113 00002F43 FEC1                    		INC	CL			; sectors are 1 based
 10114 00002F45 99                      		CWD
 10115 00002F46 8A5D15                  		MOV	BL,[DI+BDS.HDLIM]
 10116 00002F49 F7F3                    		DIV	BX			; DL is head, AX is cylinder
 10117                                  ;
 10118                                  ; DL is head.
 10119                                  ; AX is cylinder
 10120                                  ; CL is sector number
 10121                                  ; TOS is drive
 10122                                  ;
 10123                                  ;
 10124                                  		; 20/03/2018
 10125                                  ;*** For Mini Disks ***  4/7/86 
 10126 00002F4B 837D4D01                		cmp	word [di+BDSM.isMini], 1 ;check for mini disk - 4/7/86
 10127 00002F4F 7503                    		jnz	short OKnotMini		;not mini disk. - 4/7/86
 10128 00002F51 03454F                  		add	ax, [di+BDSM.Hidden_Trks] ;set phy track num - 4/7/86
 10129                                  OKnotMini:				; 4/7/86
 10130                                  ;*** End of added logic for mini disk 
 10131                                  
 10132 00002F54 D0CC                    		ROR	AH,1			; move high two bits of cyl to high
 10133 00002F56 D0CC                    		ROR	AH,1			; two bits of upper byte
 10134 00002F58 80E4C0                  		AND	AH,0C0h 		; turn off remainder of bits
 10135 00002F5B 08E1                    		OR	CL,AH			; move two bits to correct spot
 10136 00002F5D 88C5                    		MOV	CH,AL			; CH is Cylinder
 10137                                  ;
 10138                                  ; CL is sector + 2 high bits of cylinder
 10139                                  ; CH is low 8 bits of cylinder
 10140                                  ; DL is head
 10141                                  ; TOS is drive
 10142                                  ;
 10143 00002F5F 58                      		POP	AX			; AL is drive
 10144 00002F60 88D6                    		MOV	DH,DL			; DH is head
 10145 00002F62 88C2                    		MOV	DL,AL			; DL is drive
 10146                                  ;
 10147                                  ; CL is sector + 2 high bits of cylinder
 10148                                  ; CH is low 8 bits of cylinder
 10149                                  ; DH is head
 10150                                  ; DL is drive
 10151                                  ;
 10152 00002F64 31DB                    		xor	BX, BX			; clear BX -- ES:BX points to buffer
 10153 00002F66 B80102                  		mov	ax, 0201h		; set command to read one sector
 10154 00002F69 CD13                    		int	13h			; call rom-bios to read sector
 10155 00002F6B 58                      		pop	AX
 10156                                  
 10157                                  ;
 10158                                  ; ES:[0] points to the boot sector.  In theory, (ha ha) the BPB in this thing
 10159                                  ; is correct.  We can, therefore, pull out all the relevant statistics on the
 10160                                  ; media if we recognize the version number.
 10161                                  ;
 10162 00002F6C 26813E03004942          		CMP	WORD [ES:3], "IB"  ; "B" SHL 8 + "I"
 10163 00002F73 751C                    		JNZ	short unknownj
 10164 00002F75 26813E05004D20          		CMP	WORD [ES:5], "M "  ; " " SHL 8 + "M"
 10165 00002F7C 7513                    		JNZ	short unknownj
 10166 00002F7E 26813E0800322E          		CMP	WORD [ES:8], "2."  ; "." SHL 8 + "2"
 10167 00002F85 750C                    		JNZ	short Try5
 10168 00002F87 26803E0A0030            		CMP	BYTE [ES:10], "0"
 10169 00002F8D 7504                    		JNZ	short Try5
 10170 00002F8F EB13                    		JMP	SHORT CopyBPB
 10171                                  unknownj:
 10172 00002F91 EB4A                    		jmp	short unknown
 10173                                  Try5:
 10174 00002F93 26813E0800332E          		CMP	WORD [ES:8],"3."  ; "." SHL 8 + "3"
 10175 00002F9A 75F5                    		JNZ	short unknownj
 10176 00002F9C 26803E0A0031            		cmp	byte [es:10],"1"    ;do not trust 3.0 boot record.  4/15/86
 10177 00002FA2 72ED                    		jb	short unknownj	    ;if version >= 3.1, then O.K.  4/15/86
 10178                                  
 10179                                  CopyBPB:
 10180                                  ; We have a valid Boot sector. Use the BPB in it to build the
 10181                                  ; BPB in BIOS. It is assumed that ONLY SecPerClus, cDIR, and
 10182                                  ; cSecFat need to be set (all other values in already). fBigFat
 10183                                  ; is also set.
 10184 00002FA4 26A11300                		MOV	AX,[ES:11+BDS.DRVLIM-BDS.BytePerSec] ; Total sectors
 10185 00002FA8 48                      		DEC	AX			; Subtract # reserved (always 1)
 10186 00002FA9 268B161600              		MOV	DX,[ES:11+BDS.cSecFat-BDS.BytePerSec] ; Sectors for 1 fat
 10187 00002FAE 895511                  		MOV	[DI+BDS.cSecFat],DX 	; Set in BIOS BPB
 10188 00002FB1 D1E2                    		SHL	DX,1			; Always 2 FATs
 10189 00002FB3 29D0                    		SUB	AX,DX			; Sub # FAT sectors
 10190 00002FB5 268B161100              		MOV	DX,[ES:11+BDS.cDir-BDS.BytePerSec] ; # root entries
 10191 00002FBA 89550C                  		MOV	[DI+BDS.cDir],DX	; Set in BIOS BPB
 10192 00002FBD B104                    		MOV	CL,4
 10193 00002FBF D3EA                    		SHR	DX,CL			; Div by 16 ents/sector
 10194 00002FC1 29D0                    		SUB	AX,DX			; Sub # dir sectors
 10195                                  		; AX now contains the # of data sectors.
 10196 00002FC3 268A0E0D00              		MOV	CL,[ES:11+BDS.SecPerClus-BDS.BytePerSec] ; Sectors per cluster
 10197 00002FC8 884D08                  		MOV	[DI+BDS.SecPerClus],CL	; Set in BIOS BPB
 10198 00002FCB 31D2                    		XOR	DX,DX
 10199 00002FCD 88F5                    		MOV	CH,DH
 10200 00002FCF F7F1                    		DIV	CX
 10201                                  		; AX now contains the # clusters.
 10202 00002FD1 3DF60F                  		CMP	AX,4096-10		; is this 16-bit fat?
 10203 00002FD4 7205                    		JB	short GoodRetj		; No
 10204 00002FD6 800E[9829]40            		OR	byte [fBigFAT],fBIG	; 16 bit FAT
 10205                                  GoodRetj:
 10206 00002FDB EB62                    		JMP	short GoodRet
 10207                                  
 10208                                  unknown:
 10209 00002FDD BE[C629]                		MOV	SI,DiskTable2
 10210                                  Scan:
 10211 00002FE0 3B04                    		CMP	AX,[SI]
 10212 00002FE2 7605                    		JBE	short GotParm
 10213 00002FE4 83C608                  		ADD	SI,4*2
 10214 00002FE7 EBF7                    		JMP	short Scan
 10215                                  GotParm:
 10216 00002FE9 8A4C06                  		MOV	CL,[SI+6]
 10217 00002FEC 080E[9829]              		OR	[fBigFAT],CL
 10218 00002FF0 8B4C02                  		MOV	CX,[SI+2]
 10219 00002FF3 8B5404                  		MOV	DX,[SI+4]
 10220                                  ;
 10221                                  ;	AX = number of sectors on disk drive
 10222                                  ;	DX = number of dir entries,
 10223                                  ;	CH = number of sectors per cluster
 10224                                  ;	CL = log base 2 of ch
 10225                                  ;
 10226                                  ;	NOW CALCULATE SIZE OF FAT TABLE
 10227                                  ;
 10228 00002FF6 89550C                  		MOV	[DI+BDS.cDir],DX	;SAVE NUMBER OF DIR ENTRIES
 10229 00002FF9 886D08                  		MOV	[DI+BDS.SecPerClus],CH  ;SAVE SECTORS PER CLUSTER
 10230 00002FFC F606[9829]40            		TEST	byte [fBigFAT],fBIG	;   if (fBigFat)
 10231 00003001 751E                    		JNZ	short DoBig	;	goto DoBig;
 10232 00003003 31DB                    		XOR	BX,BX
 10233 00003005 88EB                    		MOV	BL,CH
 10234 00003007 4B                      		DEC	BX
 10235 00003008 01C3                    		ADD	BX,AX
 10236 0000300A D3EB                    		SHR	BX,CL			;   BX = 1+(BPB->MaxSec+SecPerClus-1)/
 10237 0000300C 43                      		INC	BX			;	    SecPerClus
 10238 0000300D 80E3FE                  		AND	BL,11111110b		;   BX &= ~1; (=number of clusters)
 10239 00003010 89DE                    		MOV	SI,BX
 10240 00003012 D1EB                    		SHR	BX,1
 10241 00003014 01F3                    		ADD	BX,SI
 10242 00003016 81C3FF01                		ADD	BX,511			;   BX += 511 + BX/2
 10243 0000301A D0EF                    		SHR	BH,1			;   BH >>= 1; (=BX/512)
 10244 0000301C 887D11                  		MOV	BYTE [DI+BDS.cSecFat],BH ;SAVE NUMBER OF FAT SECTORS
 10245 0000301F EB1E                    		JMP	SHORT GoodRet	 
 10246                                  DoBig:
 10247 00003021 B104                    		MOV	CL,4			; 16 (2^4) directory entries per sector
 10248 00003023 D3EA                    		SHR	DX,CL			; cSecDir = cDir / 16;
 10249 00003025 29D0                    		SUB	AX,DX			; AX -= cSecDir; AX -= cSecReserved;
 10250 00003027 48                      		DEC	AX			; ax = t - r - d
 10251 00003028 B302                    		MOV	BL,2
 10252 0000302A 8A7D08                  		MOV	BH,[DI+BDS.SecPerClus]	; bx = 256 * secperclus + 2
 10253 0000302D 31D2                    		XOR	DX,DX
 10254 0000302F 01D8                    		ADD	AX,BX			; ax = t-r-d+256*spc+2
 10255 00003031 83D200                  		ADC	DX,0
 10256 00003034 83E801                  		SUB	AX,1			; ax = t-r-d+256*spc+1
 10257 00003037 83DA00                  		SBB	DX,0
 10258 0000303A F7F3                    		DIV	BX			; cSecFat = ceil((total-dir-res)/
 10259                                  						;		 (256*secperclus+2));
 10260 0000303C 894511                  		MOV	[DI+BDS.cSecFat],AX	; number of fat sectors
 10261                                  GoodRet:
 10262 0000303F 8A1E[9829]              		MOV	BL,[fBigFAT]
 10263 00003043 885D19                  		MOV	[DI+BDS.FatSiz],BL	; set size of fat on media
 10264 00003046 F8                      		CLC
 10265                                  Ret_Hard:
 10266 00003047 1F                      		pop	ds
 10267 00003048 5B                      		pop	bx
 10268 00003049 5F                      		pop	di
 10269 0000304A C3                      		RETN	
 10270                                  
 10271                                  ; 03/08/2019
 10272                                  ; (Note: Following offset may change when SYSINIT code will be changed.)
 10273                                  ;BPB_Table equ SYSINIT_START + 1D46h  ; (BPBTable offset in sysinit2.s)
 10274                                  ; 15/09/2022
 10275                                  BPB_Table equ SYSINIT_START + 1D38h  ; (BPBTable offset in sysinit2.s)
 10276                                  
 10277                                  BPBSIZ	  equ 25  ; Retro DOS v3.0 (02/06/2018)	
 10278                                  
 10279                                  ;
 10280                                  ; SetDrvParms sets up the recommended BPB in each BDS in the system based on
 10281                                  ; the form factor. It is assumed that the BPBs for the various form factors
 10282                                  ; are present in the BPBTable. For hard files, the Recommended BPB is the same
 10283                                  ; as the BPB on the drive.
 10284                                  ; No attempt is made to preserve registers since we are going to jump to
 10285                                  ; SYSINIT straight after this routine.
 10286                                  ;
 10287                                  
 10288                                  SETDRVPARMS:
 10289 0000304B 31DB                    		xor	bx,bx
 10290                                  		;les	di,dword ptr [cs:START_BDS] ; get first BDS in list
 10291 0000304D 2EC43E[1002]            		les	di,[cs:START_BDS] ; 03/07/2018
 10292                                  NextBDS:
 10293 00003052 83FFFF                  		cmp	di,-1
 10294 00003055 7501                    		jnz	short Do_SetP
 10295                                  Done_SetParms:
 10296 00003057 C3                      		RETN
 10297                                  Do_SetP:
 10298 00003058 06                      		push	es
 10299 00003059 57                      		push	di			; preserve pointer to BDS
 10300                                  		;mov	bl,es:[di].FormFactor
 10301 0000305A 268A5D28                		mov	bl,[es:di+BDS.FormFactor]
 10302 0000305E 80FB05                  		cmp	bl,ffHardFile
 10303 00003061 7524                    		jnz	short NotHardFF
 10304                                  		;mov	ax,es:[di].DrvLim
 10305 00003063 268B450E                		mov	ax,[es:di+BDS.DRVLIM]
 10306 00003067 50                      		push	ax
 10307                                  		;mov	ax,wo"rd ptr es:[di].hdlim
 10308 00003068 268B4515                		mov	ax,[es:di+BDS.HDLIM]
 10309                                  		;mul	word ptr es:[di].seclim
 10310 0000306C 26F76513                		mul	word [es:di+BDS.SECLIM]
 10311 00003070 89C1                    		mov	cx,ax			; cx has # sectors per cylinder
 10312 00003072 58                      		pop	ax
 10313 00003073 31D2                    		xor	dx,dx			; set up for div
 10314 00003075 F7F1                    		div	cx			; div #sec by sec/cyl to get # cyl
 10315 00003077 09D2                    		or	dx,dx
 10316 00003079 7401                    		jz	short No_Cyl_Rnd	; came out even
 10317 0000307B 40                      		inc	ax			; round up
 10318                                  No_Cyl_Rnd:
 10319                                  		;mov	es:[di].cCyln,ax
 10320 0000307C 2689452B                		mov	[es:di+BDS.cCyln],ax
 10321 00003080 06                      		push	es
 10322 00003081 1F                      		pop	ds
 10323                                  		;lea	si,[di].BytePerSec	; ds:si -> BPB for hard file
 10324 00003082 8D7506                  		lea	si,[di+BDS.BytePerSec]
 10325                                  
 10326 00003085 EB38                    		jmp	short Set_RecBPB
 10327                                  NotHardFF:
 10328 00003087 0E                      		push	cs
 10329 00003088 1F                      		pop	ds
 10330 00003089 80FB07                  		cmp	bl,ffOther		; Special case "other" type of medium
 10331 0000308C 752A                    		JNZ	short NOT_PROCESS_OTHER
 10332                                  Process_Other:
 10333 0000308E 31D2                    		xor	dx,dx
 10334                                  		;mov	ax,[di].cCyln
 10335                                  		;mov	bx,[di].RHdlim
 10336 00003090 8B452B                  		mov	ax,[di+BDS.cCyln]
 10337 00003093 8B5D3C                  		mov	bx,[di+BDS.RHDLIM]
 10338 00003096 F7E3                    		mul	bx
 10339                                  		;mov	bx,[di].RSeclim
 10340 00003098 8B5D3A                  		mov	bx,[di+BDS.RSECLIM]
 10341 0000309B F7E3                    		mul	bx
 10342                                  		;mov	[di].RDrvlim,ax 	; Have the total number of sectors
 10343 0000309D 894535                  		mov	[di+BDS.RDRVLIM],ax
 10344 000030A0 48                      		dec	ax
 10345                                  
 10346                                  ; New logic to get the sectors/fat area.				  
 10347                                  						;Fat entry assumed to be 1.5 bytes
 10348 000030A1 BB0300                  		mov	bx,3
 10349 000030A4 F7E3                    		mul	bx
 10350 000030A6 BB0200                  		mov	bx,2
 10351 000030A9 F7F3                    		div	bx
 10352 000030AB 31D2                    		xor	dx,dx
 10353 000030AD BB0002                  		mov	bx,512
 10354 000030B0 F7F3                    		div	bx
 10355 000030B2 40                      		inc	ax
 10356                                  No_Round_Up:
 10357                                  		;mov	[di].RcSecFat,ax
 10358 000030B3 894538                  		mov	[di+BDS.RcSecFat],ax
 10359 000030B6 EB0F                    		jmp	short Go_To_Next_BDS
 10360                                  
 10361                                  NOT_PROCESS_OTHER:
 10362 000030B8 D1E3                    		shl	bx,1			; bx is word index into table of BPBs
 10363                                  		;mov	si,offset BPBTable
 10364                                  		; 06/07/2018
 10365 000030BA BE[4850]                		mov	si,BPB_Table  ; Retro DOS v3.0 modification (06/07/2018)
 10366                                  				      ; (FD BPB Tables are in SYINIT section)
 10367                                  		;mov	si,word ptr [si+bx]	; get address of BPB
 10368 000030BD 8B30                    		mov	si,[si+bx]
 10369                                  Set_RecBPB:
 10370                                  		;lea	di,[di].RBytePerSec	; es:di -> RecBPB
 10371 000030BF 8D7D2D                  		lea	di,[di+BDS.RBytePerSec]
 10372 000030C2 B91900                  		mov	cx,BPBSIZ
 10373 000030C5 F3A4                    		REP	MOVSB			; MOVE BPBSIZ BYTES
 10374                                  Go_To_Next_BDS:
 10375 000030C7 5F                      		pop	di
 10376 000030C8 07                      		pop	es			; restore pointer to BDS
 10377                                  		;mov	bx,word ptr es:[di].link+2
 10378                                  		;mov	di,word ptr es:[di].link
 10379 000030C9 268B5D02                		mov	bx,[es:di+BDS.Link+2]
 10380                                  		;mov	di,[es:di+BDS.Link]
 10381 000030CD 268B3D                  		mov	di,[es:di] ; 05/07/2019
 10382 000030D0 8EC3                    		mov	es,bx
 10383 000030D2 E97DFF                  		jmp	NextBDS
 10384                                  
 10385                                  ; ----------------------------------------------------------------------------
 10386                                  ; 03/06/2018 - Retro DOS v3.0
 10387                                  
 10388                                  
 10389                                  ; SI POINTS TO DEVICE HEADER
 10390                                  ;
 10391                                  ;  4/22/86 - print_init, aux_init is modified to eliminate the
 10392                                  ;  self-modifying code.
 10393                                  
 10394                                  PRINT_INIT:
 10395 000030D5 E80F00                  		call	GET_DEVICE_NUMBER
 10396 000030D8 B401                    		mov	ah,1		;initalize printer port
 10397 000030DA CD17                    		int	17h		;call ROM-Bios routine
 10398 000030DC C3                      		retn
 10399                                  
 10400                                  AUX_INIT:
 10401 000030DD E80700                  		call	GET_DEVICE_NUMBER
 10402 000030E0 B0A3                    		mov	al,RSINIT	;2400,N,1,8 (MSEQU.INC)
 10403 000030E2 B400                    		mov	ah,0		;initalize AUX port
 10404 000030E4 CD14                    		int	14h		;call ROM-Bios routine
 10405 000030E6 C3                      		retn
 10406                                  
 10407                                  GET_DEVICE_NUMBER:
 10408                                  ;SI -> device header
 10409                                  		; 16/06/2018
 10410 000030E7 2E8A440D                		MOV	AL,[CS:SI+13]	;GET DEVICE NUMBER FROM THE NAME
 10411                                  		;MOV	AL,[SI+13]
 10412 000030EB 2C31                    		SUB	AL,"1"
 10413 000030ED 98                      		CBW
 10414 000030EE 89C2                    		MOV	DX,AX
 10415 000030F0 C3                      		RETN
 10416                                  
 10417                                  ; ----------------------------------------------------------------------------
 10418                                  
 10419                                  ;
 10420                                  ;   purge_96tpi NOP's calls to 96tpi support.
 10421                                  ;
 10422                                  PURGE_96TPI:
 10423 000030F1 1E                      		PUSH	DS
 10424 000030F2 06                      		PUSH	ES
 10425                                  
 10426 000030F3 0E                      		push	cs			;mjb001
 10427 000030F4 07                      		pop	es			;mjb001
 10428 000030F5 0E                      		push	cs			;mjb001
 10429 000030F6 1F                      		pop	ds			;mjb001
 10430                                  		
 10431 000030F7 BE[EB29]                		MOV	SI,PatchTable
 10432                                  PatchLoop:
 10433 000030FA AD                      		LODSW
 10434 000030FB 89C1                    		MOV	CX,AX
 10435 000030FD E309                    		JCXZ	PatchDone
 10436 000030FF AD                      		LODSW
 10437 00003100 89C7                    		MOV	DI,AX
 10438 00003102 B090                    		MOV	AL,90h
 10439 00003104 F3AA                    		REP	STOSB
 10440 00003106 EBF2                    		JMP	short PatchLoop
 10441                                  
 10442                                  PatchDone:
 10443 00003108 BF[1E00]                		mov	di,TABLE_PATCH		;ARR 2.42
 10444 0000310B B8[4C06]                		MOV	AX,EXIT
 10445 0000310E AB                      		STOSW
 10446 0000310F AB                      		STOSW
 10447                                  
 10448 00003110 07                      		POP	ES
 10449 00003111 1F                      		POP	DS
 10450 00003112 C3                      		retn				;mjb001
 10451                                  
 10452                                  ; ----------------------------------------------------------------------------
 10453                                  ; 03/06/2018 - Retro DOS v3.0
 10454                                  ; (19/03/2018 - Retro DOS v2.0)
 10455                                  
 10456                                  ;Mini disk initialization routine. Called right after DoHard - 4/7/86
 10457                                  ; DoMini **************************************************************** 
 10458                                  ; **CS=DS=ES=code							
 10459                                  ; **DoMini will search for every extended partition in the system, and
 10460                                  ;   initialize it.							
 10461                                  ; **BDSM stands for BDS table for Mini disk and located right after the
 10462                                  ;   label End96Tpi. End_Of_BDSM will have the offset value of the ending
 10463                                  ;   address of BDSM table.						 
 10464                                  ; **BDSM is the same as usual BDS except that TIM_LO, TIM_HI entries are
 10465                                  ;   overlapped and used to id mini disk and the number of Hidden_trks.
 10466                                  ;   Right now, they are called as IsMini, Hidden_Trks respectively.
 10467                                  ; **DoMini will use the same routine in SETHARD routine after label SET1
 10468                                  ;   to save coding.							
 10469                                  ; **DRVMAX determined in DoHard routine will be used for the next
 10470                                  ;   available logical mini disk drive number.	
 10471                                  ;								
 10472                                  ; Input: DRVMAX, DSKDRVS					
 10473                                  ;								
 10474                                  ; Output: MiniDisk installed. BDSM table established and installed to BDS.
 10475                                  ;	  num_mini_dsk - number of mini disks installed in the system.
 10476                                  ;	  End_Of_BDSM - ending offset address of BDSM.		
 10477                                  ;								
 10478                                  ;									
 10479                                  ; Called modules:						
 10480                                  ;		  GetBoot, WRMSG, int 13h (AH=8, Rom)		
 10481                                  ;		  FIND_MINI_PARTITION (new), Install_BDSM (new),
 10482                                  ;		  SetMini (new, it will use SET1 routine)	
 10483                                  ; Variables used: End_Of_BDSM, numh, mininum, num_mini_dsk,	
 10484                                  ;		  Rom_Minidsk_num, Mini_HDLIM, Mini_SECLIM		
 10485                                  ;		  BDSMs, BDSM_type (struc), START_BDS			
 10486                                  ;***********************************************************************
 10487                                  ;
 10488                                  
 10489                                  DoMini:
 10490                                  		;push	ax			;Do I need to do this?
 10491                                  
 10492 00003113 BF[651E]                		mov	di,BDSMs		;from now on, DI points to BDSM
 10493 00003116 B280                    		mov	dl,80h 			;look at first hard drive
 10494 00003118 B408                    		mov	ah,08h			;get drive parameters
 10495 0000311A CD13                    		int	13h			;call ROM-Bios
 10496 0000311C 80FA00                  		cmp	dl, 0
 10497 0000311F 7451                    		jz	short DoMiniRet		;no hard file? Then exit.
 10498 00003121 8816[D829]              		mov	[numh],dl		;save the number of hard files.
 10499 00003125 31C0                    		xor	ax,ax
 10500 00003127 A0[8301]                		mov	al,[DRVMAX]
 10501 0000312A A2[D929]                		mov	[mininum],al		;this will be logical drive letter
 10502                                  						;for mini disk to start with.
 10503                                  
 10504 0000312D D1E0                    		shl	ax,1			;ax=number of devices. word bndry
 10505 0000312F 53                      		push	bx
 10506 00003130 BB[7018]                		mov	bx,DSKDRVS
 10507 00003133 01C3                    		add	bx,ax
 10508 00003135 891E[E029]              		mov	[Mini_BPB_ptr], BX	;Mini_BPB_ptr points to first avlb
 10509                                  						;spot in DskDrvs for Mini disk
 10510                                  						;which points to BPB area of BDSM.
 10511 00003139 5B                      		pop	bx
 10512                                  
 10513 0000313A C606[DB29]80            		mov	byte [Rom_Minidsk_num],80h
 10514                                  DoMiniBegin:
 10515 0000313F FEC6                    		inc	dh			;Get # of heads (conv to 1 based)
 10516 00003141 31C0                    		xor	ax,ax
 10517 00003143 88F0                    		mov	al,dh
 10518 00003145 A3[DC29]                		mov	[Mini_HDLIM],ax		;save it.
 10519 00003148 31C0                    		xor	ax,ax
 10520 0000314A 80E13F                  		and	cl,3Fh	 		;Get # of sectors/track
 10521 0000314D 88C8                    		mov	al,cl
 10522 0000314F A3[DE29]                		mov	[Mini_SECLIM],ax 	;and save it.
 10523                                  
 10524 00003152 8A16[DB29]              		mov	dl,[Rom_Minidsk_num]	;drive number <DL>
 10525 00003156 E837FD                  		call	GETBOOT 		;rd master boot rec 7c0:BootBias
 10526 00003159 7203                    		jc	short DoMiniNext
 10527 0000315B E81500                  		call	FIND_MINI_PARTITION
 10528                                  DoMiniNext:
 10529 0000315E FE0E[D829]              		dec	byte [numh]
 10530 00003162 740E                    		jz	short DoMiniRet
 10531 00003164 FE06[DB29]              		inc	byte [Rom_Minidsk_num] 	;Next hard file
 10532 00003168 8A16[DB29]              		mov	dl,[Rom_Minidsk_num]	;look at next hard drive
 10533 0000316C B408                    		mov	ah,08h			;get drive parameters
 10534 0000316E CD13                    		int	13h			;call ROM-Bios
 10535 00003170 EBCD                    		jmp	short DoMiniBegin
 10536                                  
 10537                                  DoMiniRet:
 10538                                  		;pop	ax
 10539                                  FmpRet: 			; 19/03/2018 -  Retro DOS v2.0
 10540 00003172 C3                      		retn
 10541                                  
 10542                                  ;Find_Mini_Partition tries to find every Extended partition on a disk.
 10543                                  ;At entry:	DI -> BDSM entry
 10544                                  ;		ES:BX -> 07C0:BootBias - Master Boot Record
 10545                                  ;		Rom_Minidsk_num - ROM drive number
 10546                                  ;		MiniNum - Logical drive number
 10547                                  ;		Mini_HDLIM, Mini_SECLIM 
 10548                                  ;
 10549                                  ;Called routine: SETMINI which uses SET1 (in SETHARD routine)
 10550                                  ;Variables & equates used from orig BIOS - flags, fNon_Removable, fBigfat
 10551                                  ;
 10552                                  
 10553                                  FIND_MINI_PARTITION:
 10554                                  
 10555 00003173 81C3C201                		add	bx,1C2h			;BX -> system id.
 10556                                  FmpNext:
 10557                                  		; 05/07/2019 - BugFix
 10558 00003177 26803F05                		cmp	byte [ES:BX],5		; 5 = extended partition ID.
 10559 0000317B 740A                    		je	short FmpGot
 10560 0000317D 83C310                  		add	bx,16			; for next entry
 10561 00003180 81FB0204                		cmp	bx,202h+BootBias ; 402h
 10562 00003184 75F1                    		jnz	short FmpNext
 10563                                  		;jmp	short FmpRet		;not found extended partition
 10564 00003186 C3                      		retn
 10565                                  FmpGot:
 10566 00003187 31C0                    		xor	ax,ax
 10567 00003189 0C01                    		or	al,fNon_Removable
 10568 0000318B 094529                  		or	[DI+BDS.Flags],ax
 10569 0000318E C6452805                		mov	byte [DI+BDS.FormFactor],ffHardFile
 10570 00003192 C606[9829]00            		mov	byte [fBigFAT],0	;assume 12 bit Fat.
 10571 00003197 A1[DC29]                		mov	ax,[Mini_HDLIM]
 10572 0000319A 894515                  		mov	[DI+BDS.HDLIM],ax
 10573 0000319D A1[DE29]                		mov	ax,[Mini_SECLIM]
 10574 000031A0 894513                  		mov	[DI+BDS.SECLIM],ax
 10575 000031A3 A0[DB29]                		mov	al,[Rom_Minidsk_num]
 10576 000031A6 884504                  		mov	[DI+BDS.DriveNum],al	;set physical number
 10577 000031A9 A0[D929]                		mov	al,[mininum]
 10578 000031AC 884505                  		mov	[DI+BDS.DriveLet],al	;set logical number
 10579                                  
 10580 000031AF 26837F0840              		cmp	word [ES:BX+8],64 ;**With current BPB, only lower word	
 10581                                  					; is meaningful.			
 10582 000031B4 74BC                    		je	short FmpRet	;should be bigger than 64 sectors at least
 10583 000031B6 83EB04                  		sub	bx,4		;let BX point to the start of the entry 
 10584 000031B9 268A7702                		mov	dh,[ES:BX+2]						
 10585 000031BD 80E6C0                  		and	dh,11000000b		;get higher bits of cyl 
 10586 000031C0 D0C6                    		rol	dh,1
 10587 000031C2 D0C6                    		rol	dh,1	
 10588 000031C4 268A5703                		mov	dl,[ES:BX+3]		;cyl byte
 10589 000031C8 89554F                  		mov	[DI+BDSM.Hidden_Trks],dx ;set hidden trks
 10590                                  ;** Now, read the volume boot record into BootBias.
 10591 000031CB 268B4F02                		mov	cx,[ES:BX+2]		;cylinder,cylinder/sector
 10592 000031CF 268A7701                		mov	dh,[ES:BX+1]		;head
 10593 000031D3 8A16[DB29]              		mov	dl,[Rom_Minidsk_num]	;drive
 10594                                  		; 03/07/2018
 10595                                  		;mov	ax,7C0h 		;
 10596 000031D7 A1[092A]                		mov	ax,[init_bootseg]
 10597 000031DA 8EC0                    		mov	es,ax			;buffer segment
 10598 000031DC BB0002                  		mov	bx,BootBias		;buffer offset
 10599 000031DF B80102                  		mov	ax,0201h		;read,1 sector
 10600 000031E2 CD13                    		int	13h			;call ROM-Bios routine
 10601 000031E4 728C                    		jc	short FmpRet		;cannot continue.
 10602 000031E6 BBC203                  		mov	bx,1c2h+BootBias
 10603                                  
 10604 000031E9 E810FD                  		call	SetMini 		;install a mini disk. BX value saved.
 10605 000031EC 7225                    		jc	short FmpnextChain
 10606                                  
 10607 000031EE E82500                  		call	INSTALL_BDSM		;install the BDSM into the BDS table
 10608 000031F1 FE06[D929]              		inc	byte [mininum] 		;increase the logical drive number for next
 10609 000031F5 FE06[DA29]              		inc	byte [num_mini_dsk]	;increase the number of mini disk installed.
 10610                                  
 10611 000031F9 53                      		push	bx			;now, set the DskDrvs pointer to BPB info.
 10612 000031FA 8B1E[E029]              		mov	bx,[Mini_BPB_ptr]
 10613                                  		;lea	si,[di].BytePerSec	;points to BPB of BDSM
 10614 000031FE 8D7506                  		lea	si,[di+BDSM.mBytePerSec]
 10615 00003201 8937                    		mov	[bx],si
 10616 00003203 FF06[E029]              		inc	word [Mini_BPB_ptr]	;advance to the next address
 10617 00003207 FF06[E029]              		inc	word [Mini_BPB_ptr]
 10618 0000320B 5B                      		pop	bx							 
 10619                                  								 
 10620                                  		;add	DI,type BDSM_type	;adjust to the next BDSM table entry. 
 10621 0000320C 83C751                  		add	DI,BDSM.size
 10622 0000320F 893E[D629]              		mov	[End_Of_BDSM],DI	;set the ending address of BDSM table to this. 
 10623                                  
 10624                                  FmpnextChain:
 10625 00003213 E961FF                  		jmp	FmpNext		;let's find out if we have any chained partition
 10626                                  ;FmpRet: 								 
 10627                                  ;		retn
 10628                                  
 10629                                  ;SetMini:								 
 10630                                  ;		push	di							 
 10631                                  ;		push	bx							 
 10632                                  ;		push	ds							 
 10633                                  ;		jmp	short SET1	;will be returned to Find mini partition routine.
 10634                                  ;					;Some logic has been added to SET1 to 
 10635                                  ;					;deal with Mini disks.				  ;3.30
 10636                                  														  ;3.30
 10637                                  ;									 
 10638                                  ;Install BDSM installs a BDSM (pointed by DS:DI) into the end of the current 
 10639                                  ;linked list of BDS.							 
 10640                                  ;Also, set the current BDSM pointer segment to DS.			 
 10641                                  ;At entry: DS:DI -> BDSM						 
 10642                                  ;
 10643                                  									 
 10644                                  INSTALL_BDSM:								 
 10645 00003216 50                      		push	ax							 
 10646 00003217 56                      		push	si							 
 10647 00003218 06                      		push	es							 
 10648                                  									 
 10649                                  		;les	si, dword ptr cs:START_BDS	;start of the beginning of list
 10650 00003219 C436[1002]              		les	si, [START_BDS]
 10651                                  I_BDSM_Next:								 
 10652 0000321D 26833CFF                		cmp	word [es:si], -1		;end of the list?	 
 10653 00003221 740B                    		jz	short I_BDSM_New						 
 10654                                  		;mov	si, [es:si+BDSM.mLink]
 10655 00003223 268B34                  		mov	si, [es:si] ; 05/07/2019				 
 10656 00003226 268B4402                		mov	ax, [es:si+BDSM.mLink+2]	;next pointer		 
 10657 0000322A 8EC0                    		mov	es, ax							 
 10658 0000322C EBEF                    		jmp	short I_BDSM_Next					 
 10659                                  I_BDSM_New:								 
 10660 0000322E 8CD8                    		mov	ax, ds							 
 10661 00003230 894502                  		mov	[di+BDSM.mLink+2], ax	;BDSM segment had not been initialized.
 10662 00003233 26894402                		mov	[es:si+BDSM.mLink+2], ax				 
 10663                                  		;mov	[es:si+BDSM.mLink], di
 10664 00003237 26893C                  		mov	[es:si], di ; 05/07/2019			 
 10665                                  		;mov	word [di+BDSM.mLink], -1	;make sure it is a null ptr.
 10666 0000323A C705FFFF                		mov	word [di], -1 ; 05/07/2019 
 10667                                  I_BDSM_ret:								 
 10668 0000323E 07                      		pop	es							 
 10669 0000323F 5E                      		pop	si							 
 10670 00003240 58                      		pop	ax							 
 10671 00003241 C3                      		retn								 
 10672                                  									 
 10673                                  ;**End of mini disk initialization**	; 4/7/86
 10674                                  
 10675                                  ; ----------------------------------------------------------------------------
 10676                                  ; 03/06/2018 - Retro DOS v3.0
 10677                                  
 10678                                  CMOS_CLOCK_READ:
 10679                                  														  ;3.30
 10680                                  ; IN ORDER TO DETERMINE IF THERE IS A CLOCK PRESENT IN THE SYSTEM, THE FOLLOWING 
 10681                                  ; NEEDS TO BE DONE.							 
 10682 00003242 50                      		PUSH	AX							 
 10683 00003243 51                      		PUSH	CX							 
 10684 00003244 52                      		PUSH	DX							 
 10685 00003245 55                      		PUSH	BP							 
 10686                                  									 
 10687 00003246 31ED                    		XOR	BP,BP							 
 10688                                  LOOP_CLOCK:								 
 10689 00003248 31C9                    		XOR	CX,CX							 
 10690 0000324A 31D2                    		XOR	DX,DX							 
 10691 0000324C B402                    		MOV	AH,2			;READ REAL TIME CLOCK
 10692 0000324E CD1A                    		INT	1Ah			;CALL ROM-BIOS ROUTINE
 10693 00003250 83F900                  		CMP	CX,0							 
 10694 00003253 7512                    		JNZ	short CLOCK_PRESENT						 
 10695                                  									 
 10696 00003255 83FA00                  		CMP	DX,0							 
 10697 00003258 750D                    		JNZ	short CLOCK_PRESENT						 
 10698                                  									 
 10699 0000325A 83FD01                  		CMP	BP,1			; READ AGAIN AFTER A SLIGHT DELAY, IN CASE CLOCK
 10700 0000325D 741B                    		JZ	short NO_READDATE	; WAS AT ZERO SETTING.		 
 10701                                  									 
 10702 0000325F 45                      		INC	BP			; ONLY PERFORM DELAY ONCE.	 
 10703 00003260 B90040                  		MOV	CX,4000H						 
 10704                                  DELAY:									 
 10705 00003263 E2FE                    		LOOP	DELAY							 
 10706 00003265 EBE1                    		JMP	LOOP_CLOCK						 
 10707                                  									 
 10708                                  CLOCK_PRESENT:								 
 10709                                  		;mov	byte [cs:HaveCMOSClock], 1 ; Set the flag for cmos clock 
 10710 00003267 C606[6608]01            		mov	byte [HaveCMOSClock], 1
 10711                                  									 
 10712 0000326C E81000                  		call	CMOSCK			; Reset CMOS clock rate that may be  
 10713                                  						; possibly destroyed by CP DOS and 
 10714                                  						; POST routine did not restore that.			 
 10715 0000326F 56                       		PUSH	SI							 
 10716 00003270 E878F5                  		CALL	READ_REAL_DATE		;READ REAL-TIME CLOCK FOR DATE 
 10717                                  									 
 10718 00003273 FA                      		CLI			 
 10719 00003274 8936[9E05]              		MOV	[DAYCNT],SI		;SET SYSTEM DATE		 
 10720 00003278 FB                      		STI			 
 10721 00003279 5E                      		POP	SI			 
 10722                                  NO_READDATE:								 
 10723 0000327A 5D                      		POP	BP							 
 10724 0000327B 5A                      		POP	DX							 
 10725 0000327C 59                      		POP	CX							 
 10726 0000327D 58                      		POP	AX							 
 10727 0000327E C3                      		RETN								 
 10728                                  				 
 10729                                  ;									 
 10730                                  ; 10/28/86								 
 10731                                  ; THE FOLLOWING CODE IS WRITTEN BY JACK GULLEY IN ENGINEERING GROUP. 
 10732                                  ; CP DOS IS CHANGING CMOS CLOCK RATE FOR ITS OWN PURPOSES AND IF THE 
 10733                                  ; USE COLD BOOT THE SYSTEM TO USE PC DOS WHILE RUNNING CP DOS, THE CMOS 
 10734                                  ; CLOCK RATE ARE STILL SLOW WHICH SLOW DOWN DISK OPERATIONS OF PC DOS 
 10735                                  ; WHICH USES CMOS CLOCK. PC DOS IS PUT THIS CODE IN MSINIT TO FIX THIS 
 10736                                  ; PROBLEM AT THE REQUEST OF CP DOS. 				 
 10737                                  ; THE PROGRAM IS MODIFIED TO BE RUN ON MSINIT. Equates are defined in CMOSEQU.INC. 
 10738                                  ; This program will be called by CMOS_Clock_Read procedure. 	 
 10739                                  ;									 
 10740                                  ;  The following code CMOSCK is used to insure that the CMOS has not	 
 10741                                  ;	had its rate controls left in an invalid state on older AT's.
 10742                                  ;									 
 10743                                  ;	It checks for an AT model byte "FC" with a submodel type of
 10744                                  ;	00, 01, 02, 03 or 06 and resets the periodic interrupt rate	 
 10745                                  ;	bits incase POST has not done it.  This initilization routine	 
 10746                                  ;	is only needed once when DOS loads.  It should be ran as soon	 
 10747                                  ;	as possible to prevent slow diskette access.			 
 10748                                  ;									 
 10749                                  ;	This code exposes one to DOS clearing CMOS setup done by a	 
 10750                                  ;	resident program that hides and re-boots the system.		 
 10751                                  ;									 
 10752                                  CMOSCK:					; CHECK AND RESET RTC RATE BITS 
 10753                                  									 
 10754                                  ;Model byte and Submodel byte were already determined in MSINIT.	 
 10755 0000327F 50                      		push	ax
 10756                                  
 10757                                  	; 16/06/2018 - Retro DOS v3.0
 10758                                  
 10759                                  	; 19/03/2018 (Model: 0FCh, Sub Model: 01h, REF: AMIBIOS Prog. Guide)							 
 10760                                  
 10761                                  	;cmp	cs:Model_byte, 0FCh ;check for PC-AT model byte	 
 10762 00003280 803E[9C29]FC            		cmp	byte [MODEL_BYTE],0FCh	
 10763                                  	;			 	; EXIT IF NOT "FC" FOR A PC-AT
 10764 00003285 7523                    		JNE	short CMOSCK9	; Exit if not an AT model	 
 10765                                  									 
 10766                                  	;CMP	cs:Secondary_Model_Byte,06H  ; Is it 06 for the industral AT 
 10767 00003287 803E[9D29]06            		CMP	byte [Secondary_Model_Byte],06h
 10768 0000328C 7407                    		JE	short CMOSCK4 	; Go reset CMOS periodic rate if 06 
 10769                                  	;CMP	cs:Secondary_Model_Byte,04H  ; Is it 00, 01, 02, or 03	 
 10770 0000328E 803E[9D29]04            		cmp	byte [Secondary_Model_Byte],04h
 10771 00003293 7315                    		JNB	short CMOSCK9 	; EXIT if problem fixed by POST  
 10772                                  					; Also,Secondary_model_byte = 0 
 10773                                  					;   when AH=0c0h, int 15h failed.
 10774                                  CMOSCK4:				;	RESET THE CMOS PERIODIC RATE 
 10775                                  					;  Model=FC submodel=00,01,02,03 or 06 
 10776                                  
 10777                                  		;mov	al,CMOS_REG_A or NMI	;NMI disabled on return
 10778 00003295 B08A                    		mov	al,CMOS_REG_A + NMI	
 10779 00003297 B426                    		mov	ah,00100110b		;Set divider & rate selection
 10780 00003299 E83000                  		call	CMOS_WRITE
 10781                                  
 10782                                  		;mov	al,CMOS_REG_B or NMI	;NMI disabled on return
 10783 0000329C B08B                    		mov	al,CMOS_REG_B + NMI	
 10784 0000329E E80B00                  		call	CMOS_READ
 10785 000032A1 2407                    		and	al,00000111b		;clear SET,PIE,AIE,UIE,SQWE
 10786 000032A3 88C4                    		mov	ah,al
 10787 000032A5 B00B                    		mov	al,CMOS_REG_B		;NMI enabled on return
 10788 000032A7 E82200                  		call	CMOS_WRITE
 10789                                  
 10790                                  CMOSCK9:					; EXIT ROUTINE		 
 10791 000032AA 58                      		pop	ax							 
 10792 000032AB C3                      		RETN				; RETurn to caller		 
 10793                                  						;  Flags modifyied		 
 10794                                  							 
 10795                                  ;--- CMOS_READ ----------------------------------------------------------------- 
 10796                                  ;		READ BYTE FROM CMOS SYSTEM CLOCK CONFIGURATION TABLE	       :
 10797                                  ;									       :
 10798                                  ; INPUT: (AL)=	CMOS TABLE ADDRESS TO BE READ				       :
 10799                                  ;		BIT    7 = 0 FOR NMI ENABLED AND 1 FOR NMI DISABLED ON EXIT    :
 10800                                  ;		BITS 6-0 = ADDRESS OF TABLE LOCATION TO READ		       :
 10801                                  ;									       :
 10802                                  ; OUTPUT: (AL)	VALUE AT LOCATION (AL) MOVED INTO (AL).  IF BIT 7 OF (AL) WAS  :
 10803                                  ;		ON THEN NMI LEFT DISABLED.  DURING THE CMOS READ BOTH NMI AND  :
 10804                                  ;		NORMAL INTERRUPTS ARE DISABLED TO PROTECT CMOS DATA INTEGRITY. :
 10805                                  ;		THE CMOS ADDRESS REGISTER IS POINTED TO A DEFAULT VALUE AND    :
 10806                                  ;		THE INTERRUPT FLAG RESTORED TO THE ENTRY STATE ON RETURN.      :
 10807                                  ;		ONLY THE (AL) REGISTER AND THE NMI STATE IS CHANGED.	       :
 10808                                  ;------------------------------------------------------------------------------- 
 10809                                  									 
 10810                                  CMOS_READ:				; READ LOCATION (AL) INTO (AL) 
 10811 000032AC 9C                      		PUSHF			; SAVE INTERRUPT ENABLE STATUS AND FLAGS 
 10812                                  
 10813 000032AD FA                      		cli
 10814 000032AE 53                      		push	bx
 10815 000032AF 50                      		push	ax		;save user NMI state
 10816 000032B0 0C80                    		or	al,NMI		;disable NMI for us
 10817 000032B2 E670                    		out	CMOS_PORT,al
 10818 000032B4 90                      		nop			;undocumented delay needed
 10819 000032B5 E471                    		in	al,CMOS_DATA	;get data value
 10820                                  
 10821                                  		 ;set NMI state to user specified 
 10822 000032B7 89C3                    		mov	bx,ax		;save data value
 10823 000032B9 58                      		pop	ax		;get user NMI
 10824 000032BA 2480                    		and	al,NMI
 10825 000032BC 0C0F                    		or	al,CMOS_SHUT_DOWN
 10826 000032BE E670                    		out	CMOS_PORT,al
 10827 000032C0 90                      		nop
 10828 000032C1 E471                    		in	al,CMOS_DATA
 10829                                  
 10830 000032C3 89D8                    		mov	ax,bx		;data value
 10831 000032C5 5B                      		pop	bx
 10832                                  
 10833 000032C6 0E                      		PUSH	CS		; *PLACE CODE SEGMENT IN STACK AND 
 10834 000032C7 E80100                  		CALL	CMOS_POPF	; *HANDLE POPF FOR B- LEVEL 80286 
 10835 000032CA C3                      		RETN			; RETURN WITH FLAGS RESTORED	 
 10836                                  									 
 10837                                  CMOS_POPF:				; POPF FOR LEVEL B- PARTS  
 10838 000032CB CF                      		IRET			; RETURN FAR AND RESTORE FLAGS	 
 10839                                  									 
 10840                                  							 
 10841                                  ;--- CMOS_WRITE ----------------------------------------------------------------
 10842                                  ;		WRITE BYTE TO CMOS SYSTEM CLOCK CONFIGURATION TABLE	       :
 10843                                  ;									       :
 10844                                  ; INPUT: (AL)=	CMOS TABLE ADDRESS TO BE WRITTEN TO			       :
 10845                                  ;		BIT    7 = 0 FOR NMI ENABLED AND 1 FOR NMI DISABLED ON EXIT    :
 10846                                  ;		BITS 6-0 = ADDRESS OF TABLE LOCATION TO WRITE		       :
 10847                                  ;	 (AH)=	NEW VALUE TO BE PLACED IN THE ADDRESSED TABLE LOCATION	       :
 10848                                  ;									       :
 10849                                  ; OUTPUT:	VALUE IN (AH) PLACED IN LOCATION (AL) WITH NMI LEFT DISABLED   :
 10850                                  ;		IF BIT 7 OF (AL) IS ON.  DURING THE CMOS UPDATE BOTH NMI AND   :
 10851                                  ;		NORMAL INTERRUPTS ARE DISABLED TO PROTECT CMOS DATA INTEGRITY. :
 10852                                  ;		THE CMOS ADDRESS REGISTER IS POINTED TO A DEFAULT VALUE AND    :
 10853                                  ;		THE INTERRUPT FLAG RESTORED TO THE ENTRY STATE ON RETURN.      :
 10854                                  ;		ONLY THE CMOS LOCATION AND THE NMI STATE IS CHANGED.	       :
 10855                                  ;-------------------------------------------------------------------------------
 10856                                  									 
 10857                                  CMOS_WRITE:				; WRITE (AH) TO LOCATION (AL) 
 10858 000032CC 9C                      		PUSHF			; SAVE INTERRUPT ENABLE STATUS AND FLAGS 
 10859 000032CD 50                      		PUSH	AX		; SAVE WORK REGISTER VALUES	 
 10860                                  
 10861 000032CE FA                      		cli
 10862 000032CF 50                      		push	ax		;save user NMI state
 10863 000032D0 0C80                    		or	al,NMI		;disable NMI for us
 10864 000032D2 E670                    		out	CMOS_PORT,al
 10865 000032D4 90                      		nop
 10866 000032D5 88E0                    		mov	al,ah
 10867 000032D7 E671                    		out	CMOS_DATA,al	;write data
 10868                                  
 10869                                  		 ;set NMI state to user specified 
 10870 000032D9 58                      		pop	ax 		;get user NMI
 10871 000032DA 2480                    		and	al,NMI
 10872 000032DC 0C0F                    		or	al,CMOS_SHUT_DOWN
 10873 000032DE E670                    		out	CMOS_PORT,al
 10874 000032E0 90                      		nop
 10875 000032E1 E471                    		in	al,CMOS_DATA
 10876                                  
 10877 000032E3 58                      		POP	AX		; RESTORE WORK REGISTERS	 
 10878 000032E4 0E                      		PUSH	CS		; *PLACE CODE SEGMENT IN STACK AND 
 10879 000032E5 E8E3FF                  		CALL	CMOS_POPF	; *HANDLE POPF FOR B- LEVEL 80286 
 10880 000032E8 C3                      		RETN
 10881                                  
 10882                                  ;-----------------------------------------------------------------------------
 10883                                  ; 03/06/2018 - Retro DOS v3.0 
 10884                                  	
 10885                                  		; 07/04/2018 - Retro DOS v2.0
 10886                                  
 10887                                  ; *** SYSINIT1.ASM ***
 10888                                  ; ----------------------------------------------------------------------------
 10889                                  ; START OF MSDOS 3.3 SYSINIT CODE - SYSINIT1.ASM - 24/07/1987
 10890                                  ; ----------------------------------------------------------------------------
 10891                                  ; 02/06/2018 - Retro DOS v3.0	
 10892                                  ; 25/03/2018 - Retro DOS v2.0
 10893                                  
 10894                                  _SYSINIT: 	; 05/07/2018
 10895                                  		;JMP	GOINIT
 10896                                  
 10897                                  ; ..SYSINIT DATA .............................................................
 10898                                  
 10899                                  GOINIT:
 10900                                  		; 03/07/2018
 10901                                  Move_Myself:
 10902                                  		; 03/05/2018
 10903                                  		; 25/02/2018 - Retro DOS 2.0 - MSDOS 2.0 "SYSINIT.ASM"
 10904                                  		; (Modified for Retro DOS 2.0, for NASM 'incbin' method)
 10905                                  
 10906                                  		SYSINITSIZE	EQU  sysinit_code_end - sysinit_code_start
 10907                                  
 10908                                  		; 28/03/2018
 10909                                          	;CLD
 10910 000032E9 BE[1033]                        	MOV     SI,SYSINIT_START   ; MSSTACK (05/07/2018)
 10911 000032EC 31FF                            	XOR     DI,DI
 10912                                  		; 19/03/2018
 10913                                  	       	;mov	CX,[SYSINIT_START+MEMORY_SIZE]
 10914                                  		; 05/07/2018
 10915 000032EE 8B0E[1E3B]              	       	mov	CX,[SYSINIT+MEMORY_SIZE]
 10916                                  
 10917 000032F2 B8A01E                  		MOV	AX,SYSINITSIZE + 15 ; 03/05/2018
 10918 000032F5 D1E8                    		SHR     AX,1                    ; Divide by 16 for paras
 10919 000032F7 D1E8                    		SHR     AX,1
 10920 000032F9 D1E8                    		SHR     AX,1
 10921 000032FB D1E8                    		SHR     AX,1
 10922 000032FD 29C1                    		SUB     CX,AX
 10923 000032FF 8EC1                    		MOV     ES,CX ; SYSINITSEG = [MEMORY_SIZE] - (SYSIZE+15)/16
 10924 00003301 B9921E                  		MOV     CX,SYSINITSIZE + 1
 10925 00003304 D1E9                    		SHR     CX,1                    ; Divide by 2 to get words
 10926 00003306 F3A5                    		REP     MOVSW                   ; RELOCATE SYSINIT
 10927                                  
 10928 00003308 06                      		PUSH    ES
 10929                                  		;XOR	AX,AX ; 0
 10930                                  		;PUSH	AX
 10931                                  
 10932                                  		; 03/07/2018
 10933                                  		;PUSH	CX ; 0
 10934                                  		; 05/07/2018
 10935 00003309 B8F007                  		mov	ax,07F0h ; ((**))
 10936 0000330C 50                      		push	ax
 10937                                  
 10938 0000330D CB                      		RETF	; far jump to final location of SYSINIT code
 10939                                  
 10940 0000330E 90<rep 2h>              align 16
 10941                                  
 10942                                  ; ----------------------------------------------------------------------------
 10943                                  ; MSDOS 3.3 -IBMBIO.COM- SYSINIT CODE -will be relocated-
 10944                                  ; ----------------------------------------------------------------------------
 10945                                  ; 11/06/2018 - Retro DOS v3.0 
 10946                                  
 10947                                  SYSINIT_START equ $
 10948                                  
 10949                                  ; 05/07/2018 - Retro DOS v3.0
 10950                                  ; (NOTE: Following address is sysinit code start address after msstack code
 10951                                  ;  in 'sysinit2.s', it is 07F0h for current SYSINIT, 05/07/2018)	
 10952                                  SYSINIT	equ SYSINIT_START + 07F0h ; ((**))
 10953                                  
 10954                                  sysinit_code_start:
 10955                                  		; 15/09/2022
 10956                                  		;	(Retro DOS v3.30 starting message)
 10957                                  		; 06/07/2019
 10958                                  		; 06/07/2018 ('sysinit2.s' last modification)
 10959                                  		;incbin	'SYSINIT2.BIN' ; Retro DOS 3.0 - MSDOS 3.3 'SYSINIT'
 10960                                  		; 03/09/2022
 10961 00003310 <bin 1E91h>             		incbin	'SYSINI33.BIN' ; Retro DOS 3.0 - MSDOS 3.3 'SYSINIT'
 10962                                  sysinit_code_end:
 10963 000051A1 90                      		db 90h
 10964                                  
 10965 000051A2 90<rep Eh>              align 16 ; Paragraph alignment is necessary here for MSDOS kernel relocation
 10966                                  
 10967                                  ; ----------------------------------------------------------------------------
 10968                                  ; START OF MSDOS 3.3 -IBMDOS.COM- KERNEL CODE (MSDOS.SYS) -will be relocated-
 10969                                  ; ----------------------------------------------------------------------------
 10970                                  ; 11/06/2018 - Retro DOS v3.0 
 10971                                  
 10972                                  MSDOS_BIN_OFFSET:  ; this offset must be paragraph aligned
 10973                                  		; 15/09/2022 - Windows 3.1 compatible Retro DOS v3 kernel
 10974                                  		;
 10975                                  		; -----	MSDOS (PC-DOS) Version 3.30
 10976                                  		; ----- 'IBMDOS.COM' kernel content except 'IBMBIO.COM'
 10977                                  		;
 10978                                  		; Notes: Windows 3.1 does not run if addresses and -most of-
 10979                                  		;	content -code- aren't same with original MSDOS kernel
 10980                                  		;	('temporary' and 'magic code' modification notes
 10981                                  		;	-in 'msdos33.asm'- are for that!).
 10982                                  		;	((NASM puts different opcodes -than MASM- for some
 10983                                  		;	asm instructions. This is a reason for some problems)) 
 10984                                  		;	Also, original ms 'command.com' (v3.30) is needed for
 10985                                  		;	msdos prompt within windows (3.1). (Retro DOS v3
 10986                                  		;	'command.com' is not proper for dos prompt in windows)
 10987                                  		;	((MSDOS v5.0 'HIMEM.SYS' & 'SMARTDRV.SYS' can be used
 10988                                  		;	instead of Windows 3.1 'HIMEM.SYS' & 'SMARTDRV.EXE'))
 10989                                  		;
 10990                                  		;	-!- Even if -previous- Retro DOS v3 Kernel passes
 10991                                  		;	the AARD checkout ('MSDETECT.EXE' utility checks the 
 10992                                  		;	AARD compatibility), Windows 3.1 does not run due to
 10993                                  		;	address and opcode differences in the kernel.
 10994                                  		;	But, this is not as explained in Andrew Schulman's
 10995                                  		;	'Undocumented DOS' book, there are other barriers
 10996                                  		;	-for DOS v3.3 kernel- in addition to the AARD code
 10997                                  		;	in the 'WIN.COM'!?. -!- 
 10998                                  		;
 10999                                  		; 14/09/2022
 11000                                  		; 09/09/2022
 11001                                  		; 06/09/2022 (2022 modification for windows 3.1 running)
 11002                                  		; 22/07/2019 ('msdos3.s' last modification)
 11003                                  		; 20/05/2019 (BugFixed MSDOS3.BIN)
 11004                                  		; 10/09/2018 ('msdos3.s') 
 11005 000051B0 <bin 7568h>             		incbin	'MSDOS33.BIN' ; 05/07/2019 ; 15/09/2022
 11006                                  msdos_bin_size	equ $ - MSDOS_BIN_OFFSET
 11007                                  
 11008                                  align 2
 11009                                  END_OF_KERNEL equ $
