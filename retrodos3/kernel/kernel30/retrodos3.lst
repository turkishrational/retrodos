     1                                  ; ****************************************************************************
     2                                  ; RETRODOS.SYS (MSDOS 3.3 Kernel) - RETRO DOS v3.0 by ERDOGAN TAN
     3                                  ; ----------------------------------------------------------------------------
     4                                  ; Last Update: 22/01/2024 (BugFix) - (Previous: 28/08/2023)
     5                                  ; ----------------------------------------------------------------------------
     6                                  ; Beginning: 24/02/2018 (Retro DOS 2.0), 25/05/2018 (Retro DOS 3.0)
     7                                  ; ----------------------------------------------------------------------------
     8                                  ; Assembler: NASM version 2.11  
     9                                  ; ----------------------------------------------------------------------------
    10                                  ;	    ((nasm retrodos.s -l retrodos.lst -o MSDOS.SYS)) 	
    11                                  ; ----------------------------------------------------------------------------
    12                                  ; This assembly file has three parts: (BIOS+SYSINIT+KERNEL in one kernel file)
    13                                  ; 1a) IBMBIO.COM (IO.SYS) part from beginning to '%incbin MSDOS.BIN'
    14                                  ; 1b) SYSINIT part (at the end of IBMBIO.COM/IO.SYS) as '%incbin SYSINIT.BIN'
    15                                  ; 2) MSDOS.SYS (MSDOS 3.3 Kernel) as included binary file (MSDOS.BIN).
    16                                  ; source : 'retrodos.s' (main), 'sysinit.s' (included), 'msdos.s' (included)	
    17                                  ;
    18                                  ; (Note: RETRO DOS 3.0 boot sector code will load 'MSDOS.SYS' at 1000h:0000h)
    19                                  ; (Original MSDOS 3.3 IBMBIO.COM loads/runs its own init code at 0070h:0000h)
    20                                  
    21                                  ;=============================================================================
    22                                  ; Modified from 'retrodos.s', Retro DOS v1.0 Kernel ("IBMBIO.COM") Source code
    23                                  ; by Erdogan Tan, 20/02/2018
    24                                  ;=============================================================================
    25                                  
    26                                  ; MSBIO (IO.SYS 3.3) source files:
    27                                  ; 	MSBIO1.ASM,MSCON.ASM,MSAUX.ASM,MSLPT.ASM,MSCLOCK.ASM,MSDISK.ASM
    28                                  ;	MSBIO2.ASM,MSHARD.ASM,MSINIT.ASM 
    29                                  ;	SYINIT1.ASM,SYSCONF.ASM,SYSINIT2.ASM,SYSIMES.ASM
    30                                  
    31                                  ;=============================================================================
    32                                  ; MSBIO
    33                                  ;=============================================================================
    34                                  ;msbio1+mscon+msaux+mslpt+msclock+msdisk+
    35                                  ;msbio2+mshard+msinit+sysinit1+sysconf+sysinit2+sysimes,
    36                                  ;msbio
    37                                  
    38                                  SECTOR_SIZE     equ     0200h		; size of a sector
    39                                  PAUSE_KEY       equ     7200h		; scancode + charcode of PAUSE key
    40                                  KEYBUF_NEXT     equ     041Ah		; next character in keyboard buffer
    41                                  KEYBUF_FREE     equ     041Ch		; next free slot in keyboard buffer
    42                                  KEYBUF          equ     041Eh		; keyboard buffer data
    43                                  LOGICAL_DRIVE   equ     0504h		; linear address of logical drive byte
    44                                  ;DOS_SEGMENT	equ     00BFh ; v1.1	; segment in which DOS will run
    45                                  DOS_SEGMENT	equ     00C4h		; Retro DOS v1.0 - 13/02/2018
    46                                  BIO_SEGMENT     equ     0060h		; segment in which BIO is running
    47                                  
    48                                  ; 24/02/2018 (Retro DOS 2.0 - MSDOS 3.3 "DISKPRM.INC" - 24/07/1987)
    49                                  ; The following structure defines the disk parameter table
    50                                  ; pointed to by Interrupt vector 1EH (location 0:78H)
    51                                  
    52                                  struc	DISK_PARMS
    53 00000000 ??                      .DISK_SPECIFY_1:  resb	1
    54 00000001 ??                      .DISK_SPECIFY_2:  resb	1
    55 00000002 ??                      .DISK_MOTOR_WAIT: resb  1	; Wait till motor off
    56 00000003 ??                      .DISK_SECTOR_SIZ: resb 	1	; Bytes/Sector (2 = 512)
    57 00000004 ??                      .DISK_EOT:	  resb  1	; Sectors per track (MAX)
    58 00000005 ??                      .DISK_RW_GAP:	  resb  1	; Read Write Gap
    59 00000006 ??                      .DISK_DTL:	  resb	1
    60 00000007 ??                      .DISK_FORMT_GAP:  resb  1	; Format Gap Length
    61 00000008 ??                      .DISK_FILL:	  resb  1	; Format Fill Byte
    62 00000009 ??                      .DISK_HEAD_STTL:  resb  1	; Head Settle Time (MSec)
    63 0000000A ??                      .DISK_MOTOR_STRT: resb  1	; Motor start delay
    64                                  .size:
    65                                  endstruc
    66                                  
    67                                  ROMStatus	equ	1
    68                                  ROMRead 	equ	2
    69                                  ROMWrite	equ	3
    70                                  ROMVerify	equ	4
    71                                  ROMFormat	equ	5  
    72                                  
    73                                  ; 24/02/2018 (Retro DOS 2.0 - MSDOS 3.3 "MSBDS.INC" - 24/07/1987)
    74                                  ; -------------------------------------------------------------------------
    75                                  ;  BDS is the Bios Data Structure.
    76                                  ;
    77                                  ;  There is one BDS for each logical drive in the system.  All the BDS's
    78                                  ;  are linked together in a list with the pointer to the first BDS being
    79                                  ;  found in START_BDS.	The BDS hold various values important to the disk
    80                                  ;  drive.  For example there is a field for last time accesses.  As actions
    81                                  ;  take place in the system the BDS are update to reflect the actions.
    82                                  ;  For example is there is a read to a disk the last access field for the
    83                                  ;  BDS for that drive is update to the current time.
    84                                  ;
    85                                  ; Values for various flags in BDS.Flags.
    86                                  ;
    87                                  
    88                                  fNon_Removable	    equ     01H 	;For non-removable media
    89                                  fChangeline	    equ     02H 	;If changeline supported on drive
    90                                  RETURN_FAKE_BPB     equ     04H 	; When set, don't do a build BPB
    91                                  					; just return the fake one
    92                                  GOOD_TRACKLAYOUT    equ     08H 	; The track layout has no funny sectors
    93                                  fI_Am_Mult	    equ     10H 	;If more than one logical for this physical
    94                                  fI_Own_Physical     equ     20H 	;Signify logical owner of this physical
    95                                  fChanged	    equ     40H 	;Indicates media changed
    96                                  SET_DASD_true	    equ     80H 	; Set DASD before next format
    97                                  fChanged_By_Format  equ    100h
    98                                  
    99                                  ;
   100                                  ; Various form factors to describe media
   101                                  ;
   102                                  
   103                                  ff48tpi 	    equ     0
   104                                  ff96tpi 	    equ     1
   105                                  ffSmall 	    equ     2
   106                                  ffHardFile	    equ     5
   107                                  ffOther 	    equ     7
   108                                  ; MSDOS 6.0 ("MSBDS.INC", 1991)
   109                                  ff288		    equ     9	; 2.88 MB drive
   110                                  ; Retro DOS v2.0 feature only !
   111                                  ff144		    equ	   10	; 1.44 MB drive			
   112                                  
   113                                  struc	BDS	; BDS_Type
   114 00000000 ????????                .Link:		resd 1		; Link to next BDS
   115 00000004 ??                      .DriveNum:	resb 1		; Physical drive number
   116 00000005 ??                      .DriveLet:	resb 1		; DOS drive number
   117 00000006 ????                    .BytePerSec:	resw 1		; number of bytes/sec
   118 00000008 ??                      .SecPerClus:	resb 1		; sec per allocation unit
   119 00000009 ????                    .RESSEC:	resw 1		; number of reserved sectors
   120 0000000B ??                      .cFAT:		resb 1		; number of fats
   121 0000000C ????                    .cDir:		resw 1		; number of directory entries
   122 0000000E ????                    .DRVLIM:	resw 1		; number of sectors on medium
   123 00000010 ??                      .Mediad:	resb 1		; media descriptor byte
   124 00000011 ????                    .cSecFat: 	resw 1		; number of sectors/fat
   125 00000013 ????                    .SECLIM:	resw 1		; sectors per track
   126 00000015 ????                    .HDLIM:		resw 1		; max number of heads
   127 00000017 ????                    .HIDSEC:	resw 1		; number of hidden sectors
   128 00000019 ??                      .FatSiz:	resb 1		; flags...
   129 0000001A ????                    .Opcnt:		resw 1		; Open ref. count
   130 0000001C <res Ch>                .Volid:		resb 12		; volume ID of medium
   131 00000028 ??                      .FormFactor:	resb 1		; form factor index
   132 00000029 ????                    .Flags:		resw 1		; various flags
   133 0000002B ????                    .cCyln:		resw 1		; max number of cylinders
   134 0000002D ????                    .RBytePerSec:	resw 1		; Recommended BPB
   135 0000002F ??                      .RSecPerClus:	resb 1
   136 00000030 ????                    .RRESSEC: 	resw 1
   137 00000032 ??                      .RcFAT:		resb 1
   138 00000033 ????                    .RcDir:		resw 1
   139 00000035 ????                    .RDRVLIM: 	resw 1
   140 00000037 ??                      .Rmediad: 	resb 1
   141 00000038 ????                    .RcSecFat:	resw 1
   142 0000003A ????                    .RSECLIM: 	resw 1
   143 0000003C ????                    .RHDLIM:	resw 1
   144 0000003E ????                    .RHIDSEC: 	resw 1
   145 00000040 ????                    .RHHIDSEC:	resw 1
   146 00000042 ????????                .RLOGSEC: 	resd 1
   147 00000046 ????????????            .Reserve: 	resb 6		; Reserved for future
   148 0000004C ??                      .Track:		resb 1		; last track accessed on drive
   149 0000004D ????                    .TIM_LO:	resw 1		; Time of last access. Keep
   150 0000004F ????                    .TIM_HI:	resw 1		; these contiguous.
   151                                  endstruc
   152                                  
   153                                  BPBSize	equ	BDS.Track - BDS.RBytePerSec 
   154                                  				; size in bytes of RecBPB area in the BDS
   155                                  
   156                                  ; 23/03/2018
   157                                  
   158                                  ;STATIC REQUEST HEADER (DEVSYM.INC, MSDOS 6.0, 1991)
   159                                  STRUC SRHEAD
   160 00000000 ??                      .REQLEN:	resb 1		;LENGTH IN BYTES OF REQUEST BLOCK
   161 00000001 ??                      .REQUNIT:	resb 1		;DEVICE UNIT NUMBER
   162 00000002 ??                      .REQFUNC:	resb 1		;TYPE OF REQUEST
   163 00000003 ????                    .REQSTAT:	resw 1		;STATUS WORD
   164 00000005 ????????????????        	       	resb 8		;RESERVED FOR QUEUE LINKS
   165                                  .size:
   166                                  endstruc
   167                                  
   168                                  ; GENERIC IOCTL REQUEST STRUCTURE (DEVSYM.INC, MSDOS 6.0, 1991)
   169                                  ;	SEE THE DOS 4.0 DEVICE DRIVER SPEC FOR FURTHER ELABORATION.
   170                                  ;
   171                                  struc IOCTL_REQ
   172                                  	       ;DB    (SIZE SRHEAD) DUP(?)
   173 00000000 <res Dh>                		resb SRHEAD.size	
   174                                  			    	; GENERIC IOCTL ADDITION.
   175 0000000D ??                      .MAJORFUNCTION:	resb 1		;FUNCTION CODE
   176 0000000E ??                      .MINORFUNCTION:	resb 1		;FUNCTION CATEGORY
   177 0000000F ????                    .REG_SI:	resw 1
   178 00000011 ????                    .REG_DI:	resw 1
   179 00000013 ????????                .GENERICIOCTL_PACKET: resd 1	; POINTER TO DATA BUFFER
   180                                  endstruc
   181                                  
   182                                  ; GENERIC IOCTL CATEGORY CODES  (IOCTL.INC, MSDOS 6.0, 1991)
   183                                  IOC_OTHER	EQU	0	; Other device control J.K. 4/29/86
   184                                  IOC_SE		EQU	1	; SERIAL DEVICE CONTROL
   185                                  IOC_TC		EQU	2	; TERMINAL CONTROL
   186                                  IOC_SC		EQU	3	; SCREEN CONTROL
   187                                  IOC_KC		EQU	4	; KEYBOARD CONTROL
   188                                  IOC_PC		EQU	5	; PRINTER CONTROL
   189                                  IOC_DC		EQU	8	; DISK CONTROL (SAME AS RAWIO)
   190                                  
   191                                  ; DEFINITIONS FOR IOCTL_REQ.MINORFUNCTION
   192                                  GEN_IOCTL_WRT_TRK   EQU   40H
   193                                  GEN_IOCTL_RD_TRK    EQU   60H
   194                                  GEN_IOCTL_FN_TST    EQU   20H	; USED TO DIFF. BET READS AND WRTS
   195                                  
   196                                  ;struc A_RETRYCOUNT  ; (IOCTL.INC, MSDOS 6.0, 1991)
   197                                  ;.RC_COUNT:	resw 	1
   198                                  ;endstruc
   199                                  
   200                                  ; 27/03/2018 - DEVSYM.INC - MSDOS 3.3 - 24/07/1987
   201                                  
   202                                  ;
   203                                  ; ATTRIBUTE BIT MASKS
   204                                  ;
   205                                  ; CHARACTER DEVICES:
   206                                  ;
   207                                  ; BIT 15 -> MUST BE 1
   208                                  ;     14 -> 1 IF THE DEVICE UNDERSTANDS IOCTL CONTROL STRINGS
   209                                  ;     13 -> 1 IF THE DEVICE SUPPORTS OUTPUT-UNTIL-BUSY
   210                                  ;     12 -> UNUSED
   211                                  ;     11 -> 1 IF THE DEVICE UNDERSTANDS OPEN/CLOSE
   212                                  ;     10 -> MUST BE 0
   213                                  ;      9 -> MUST BE 0
   214                                  ;      8 -> UNUSED
   215                                  ;      7 -> UNUSED
   216                                  ;      6 -> UNUSED
   217                                  ;      5 -> UNUSED
   218                                  ;      4 -> 1 IF DEVICE IS RECIPIENT OF INT 29H
   219                                  ;      3 -> 1 IF DEVICE IS CLOCK DEVICE
   220                                  ;      2 -> 1 IF DEVICE IS NULL DEVICE
   221                                  ;      1 -> 1 IF DEVICE IS CONSOLE OUTPUT
   222                                  ;      0 -> 1 IF DEVICE IS CONSOLE INPUT
   223                                  ;
   224                                  ; BLOCK DEVICES:
   225                                  ;
   226                                  ; BIT 15 -> MUST BE 0
   227                                  ;     14 -> 1 IF THE DEVICE UNDERSTANDS IOCTL CONTROL STRINGS
   228                                  ;     13 -> 1 IF THE DEVICE DETERMINES MEDIA BY EXAMINING THE FAT ID BYTE.
   229                                  ;	    THIS REQUIRES THE FIRST SECTOR OF THE FAT TO *ALWAYS* RESIDE IN
   230                                  ;	    THE SAME PLACE.
   231                                  ;     12 -> UNUSED
   232                                  ;     11 -> 1 IF THE DEVICE UNDERSTANDS OPEN/CLOSE/REMOVABLE MEDIA
   233                                  ;     10 -> MUST BE 0
   234                                  ;      9 -> MUST BE 0
   235                                  ;      8 -> UNUSED
   236                                  ;      7 -> UNUSED
   237                                  ;      6 -> IF DEVICE HAS SUPPORT FOR GETMAP/SETMAP OF LOGICAL DRIVES.
   238                                  ;	    IF THE DEVICE UNDERSTANDS GENERIC IOCTL FUNCTION CALLS.
   239                                  ;      5 -> UNUSED
   240                                  ;      4 -> UNUSED
   241                                  ;      3 -> UNUSED
   242                                  ;      2 -> UNUSED
   243                                  ;      1 -> UNUSED
   244                                  ;      0 -> UNUSED
   245                                  ;
   246                                  
   247                                  DEVTYP	       EQU   8000H	    ; BIT 15 - 1  IF CHAR, 0 IF BLOCK
   248                                  CHARDEV        EQU   8000H
   249                                  DEVIOCTL       EQU   4000H	    ; BIT 14 - CONTROL MODE BIT
   250                                  ISFATBYDEV     EQU   2000H	    ; BIT 13 - DEVICE USES FAT ID BYTES,
   251                                  				    ;  COMP MEDIA.
   252                                  OUTTILBUSY     EQU   2000H	    ; OUTPUT UNTIL BUSY IS ENABLED
   253                                  ISNET	       EQU   1000H	    ; BIT 12 - 1 IF A NET DEVICE, 0 IF
   254                                  				    ;  NOT.  CURRENTLY BLOCK ONLY.
   255                                  DEVOPCL        EQU   0800H	    ; BIT 11 - 1 IF THIS DEVICE HAS
   256                                  				    ;  OPEN,CLOSE AND REMOVABLE MEDIA
   257                                  				    ;  ENTRY POINTS, 0 IF NOT
   258                                  
   259                                  EXTENTBIT      EQU   0400H	    ; BIT 10 - CURRENTLY 0 ON ALL DEVS
   260                                  				    ;  THIS BIT IS RESERVED FOR FUTURE USE
   261                                  				    ;  TO EXTEND THE DEVICE HEADER BEYOND
   262                                  				    ;  ITS CURRENT FORM.
   263                                  
   264                                  ; NOTE BIT 9 IS CURRENTLY USED ON IBM SYSTEMS TO INDICATE "DRIVE IS SHARED".
   265                                  ;    SEE IOCTL FUNCTION 9. THIS USE IS NOT DOCUMENTED, IT IS USED BY SOME
   266                                  ;    OF THE UTILITIES WHICH ARE SUPPOSED TO FAIL ON SHARED DRIVES ON SERVER
   267                                  ;    MACHINES (FORMAT,CHKDSK,RECOVER,..).
   268                                  
   269                                  DEV320	       EQU   0040H	    ;BIT 6 - FOR BLOCK DEVICES, THIS
   270                                  				    ;DEVICE SUPPORTS SET/GET MAP OF
   271                                  				    ;LOGICAL DRIVES, AND SUPPORTS
   272                                  				    ;GENERIC IOCTL CALLS.
   273                                  				    ;FOR CHARACTER DEVICES, THIS
   274                                  				    ;DEVICE SUPPORTS GENERIC IOCTL.
   275                                  				    ;THIS IS A DOS 3.2 DEVICE DRIVER.
   276                                  ISSPEC	       EQU   0010H	    ;BIT 4 - THIS DEVICE IS SPECIAL
   277                                  ISCLOCK        EQU   0008H	    ;BIT 3 - THIS DEVICE IS THE CLOCK DEVICE.
   278                                  ISNULL	       EQU   0004H	    ;BIT 2 - THIS DEVICE IS THE NULL DEVICE.
   279                                  ISCOUT	       EQU   0002H	    ;BIT 1 - THIS DEVICE IS THE CONSOLE OUTPUT.
   280                                  ISCIN	       EQU   0001H	    ;BIT 0 - THIS DEVICE IS THE CONSOLE INPUT.
   281                                  
   282                                  
   283                                  ; 19/03/2018
   284                                  
   285                                  ;*********************************************************************
   286                                  ;	BDS structure for mini disk
   287                                  ;*********************************************************************	  
   288                                  									  
   289                                  struc	BDSM	; BDSM_type
   290 00000000 ????                    .mLink:		resw	1 ; DW -1		;Link to next structure   
   291 00000002 ????                    		resw	1 ; DW ?
   292 00000004 ??                      .mDriveNum:	resb	1 ; DB 80h		;Int 13 Drive Number	  
   293 00000005 ??                      .mDriveLet:	resb	1 ; DB 3		;Logical Drive Number	  
   294 00000006 ????                    .mBytePerSec:	resw 	1 ; DW 512
   295 00000008 ??                      .mSecPerClus:	resb	1 ; DB 1		;Sectors/allocation unit  
   296 00000009 ????                    .mRESSEC:	resw	1 ; DW 1		;Reserved sectors for DOS 
   297 0000000B ??                      .mcFAT:		resb	1 ; DB 2		;No. of allocation tables 
   298 0000000C ????                    .mcDIR:		resw	1 ; DW 16		;Number of directory entries
   299 0000000E ????                    .mDRVLIM:	resw 	1 ; DW 0		;Num of sectors (at 512 bytes each)
   300 00000010 ??                      .mMediad:	resb	1 ; DB 11111000b	;Media descriptor	  
   301 00000011 ????                    .mcSecFat:	resw 	1 ; DW 1		;Number of FAT sectors	  
   302 00000013 ????                    .mSECLIM:	resw 	1 ; DW 0		;Sector limit		  
   303 00000015 ????                    .mHDLIM:	resw	1 ; DW 0		;Head limit		  
   304 00000017 ????                    .mHIDSEC:	resw 	1 ; DW 0		;Hidden sector count	  
   305 00000019 ??                      .mFatSiz:	resb 	1 ; DB 0		;TRUE => bigfat 	  
   306 0000001A ????                    .mOPCNT:	resw	1 ; DW 0		;Open Ref. Count	  
   307 0000001C <res Bh>                .mVOLID:	resb   11 ; DB "NO NAME    "    ;Volume ID for this disk  
   308 00000027 ??                      		resb 	1 ; DB 0		;ASCIZII for "NO NAME    "
   309 00000028 ??                      .mFormFactor:	resb 	1 ; DB 3		;Form Factor		  
   310 00000029 ????                    .mFLAGS:	resw	1 ; DW 0020H		;Various Flags		  
   311 0000002B ????                    .mcCyln:	resw	1 ; DW 40		;max number of cylinders  
   312 0000002D <res 1Fh>               .mRecBPB:	resb   31 ; DB 31 DUP (0) 	;Recommended BPB for drive
   313 0000004C ??                      .mTrack:	resb	1 ; DB -1						  
   314 0000004D ????                    .isMini:	resw	1 ; DW 1		;Overlapping TIM_LOH	  
   315 0000004F ????                    .Hidden_Trks:	resw 	1 ; DW 0		;Overlapping TIM_HIH	  
   316                                  									  
   317                                  ;.TIM_LOH:	resw	1 ; DW -1		;Keep these two contiguous (?)   
   318                                  ;.TIM_HIH:	resw	1 ; DW -1
   319                                  .size:							  
   320                                  
   321                                  endstruc
   322                                  
   323                                  ; 27/05/2018 - Retro DOS v3.0 
   324                                  ; [MSDOS 3.3, MSDISK.ASM]
   325                                  
   326                                  struc INT13FRAME
   327 00000000 ????                    .oldbp:	resw 1
   328 00000002 ????                    .oldax:	resw 1
   329 00000004 ????                    .oldbx:	resw 1
   330 00000006 ????                    .oldcx:	resw 1
   331 00000008 ????                    .olddx:	resw 1
   332 0000000A ????????                .olddd:	resd 1
   333 0000000E ????                    .oldf:	resw 1
   334                                  .size:
   335                                  endstruc
   336                                  
   337                                  ; 02/06/2018 - Retro DOS v3.0
   338                                  ; [MSDOS 3.3, BIOSTRUC.INC]
   339                                  
   340                                  struc ROMBIOS_DESC		; BIOS_SYSTEM_DESCRIPTOR						  
   341 00000000 ????                    .bios_SD_leng:		resw 1				  
   342 00000002 ??                      .bios_SD_modelbyte:	resb 1					  
   343                                  .bios_SD_scnd_modelbyte: 
   344 00000003 ??                      			resb 1					  
   345 00000004 ??                      			resb 1					  
   346 00000005 ??                      .bios_SD_featurebyte1:	resb 1					  
   347 00000006 ????????                			resb 4					  
   348                                  endstruc
   349                                  							  
   350                                  ;******************************************************************************
   351                                  Max_mini_dsk_num equ	23		; Max # of mini disk bios can support
   352                                  
   353                                  
   354                                  KERNEL_SEGMENT	equ 0070h  ; Retro DOS v2.0 - 17/03/2018
   355                                  
   356                                  ;-----------------------------------------------------------------------------
   357                                  ; Start of code
   358                                  ;-----------------------------------------------------------------------------
   359                                  
   360                                          	[ORG 0]			; segment 0x0060
   361                                  
   362                                  ;-----------------------------------------------------------------------------
   363                                  ; MSDATA.INC - MSDOS 3.3 BIOS - 24/07/1987
   364                                  ;-----------------------------------------------------------------------------
   365                                  ; 21/03/2018 - Retro DOS v2.0
   366                                  
   367                                  START$:
   368 00000000 E9BD2A                  		JMP	INIT		; START$ patch by init to point to
   369                                  					; hdrive BPB
   370                                  
   371                                  SYS_INIT_START EQU SYSINIT_START - START$
   372                                  KERNEL_BYTES EQU END_OF_KERNEL - START$
   373                                  MSDOS_BIN_ADDRESS EQU MSDOS_BIN_OFFSET - START$
   374                                  
   375                                  %define SYSINITSEG SYS_INIT_START >> 4  ; 26/03/2018
   376                                  %define MSDOS_BIN_SEGMENT MSDOS_BIN_ADDRESS >> 4 ; 26/03/2018 
   377                                  %define KERNEL_SIZE KERNEL_BYTES >> 1 ; Retro DOS v2.0 - 26/03/2018
   378                                  
   379                                  
   380                                  ;----------------------------------------------------------------------------
   381                                  ;
   382                                  ;		Command Jump Tables
   383                                  ;
   384                                  ;     These tables hold the entry points for the various service routines
   385                                  ; for the different drivers.  The index in the table is the command code for
   386                                  ; that funcion plus two.  For example the command code for Read (input) is 4,
   387                                  ; The 6th (4 plus 2) entry in the table DSKTBL is DSK$READ - the command to
   388                                  ; read a disk.	Commands which do not exist for a device are filled with
   389                                  ; exit (e.g. MediaCheck for CONTBL).  The first entry in the table is the
   390                                  ; largest command code implemented for that device.  This value is used
   391                                  ; for error checking.  If new command codes are added then the first entry
   392                                  ; in the table must be incremented.
   393                                  ;
   394                                  ;	BEWARE - These tables overlap somewhat! -c.p.
   395                                  ;
   396                                  
   397                                  ;align 2
   398                                  
   399                                  		; 08/04/2018
   400                                  		; Retro DOS v2.0 (IBMBIO.COM, IBMDOS 2.1)
   401                                  		; ((Disassembler: IDA Pro Free))
   402                                  
   403                                  ;
   404                                  ; Disk:
   405                                  ;
   406                                  
   407                                  		;nop
   408                                  DSKTBL:
   409 00000003 18                      		DB	24		; This is the size of the table YUK!!!!
   410 00000004 [791A]                  		DW	DSK$INIT	; code	0: INIT
   411 00000006 [B309]                  		DW	MEDIA$CHK	; code	1: Media Check
   412 00000008 [640A]                  		DW	GET$BPB 	; code	2: BUILD BPB
   413 0000000A [7106]                  		DW	CMDERR		; code	3: IOCTL input
   414 0000000C [760C]                  		DW	DSK$READ	; code	4: INPUT
   415 0000000E [6D06]                  		DW	BUS$EXIT	; code	5: NONDESTRUCITVE INPUT, NO WAIT
   416 00000010 [8806]                  		DW	EXIT		; code	6: INPUT STATUS
   417 00000012 [8806]                  		DW	EXIT		; code	7: INPUT FLUSH
   418 00000014 [640C]                  		DW	DSK$WRIT	; code	8: OUTPUT
   419 00000016 [5B0C]                  		DW	DSK$WRITV	; code	9: OUTPUT with verify
   420 00000018 [8806]                  		DW	EXIT		; code 10: OUTPUT STATUS
   421 0000001A [8806]                  		DW	EXIT		; code 11: OUTPUT FLUSH
   422 0000001C [7106]                  		DW	CMDERR		; code 12: IOCTL output
   423                                  TABLE_PATCH:
   424 0000001E [591C]                  		DW	DSK$OPEN	; code 13: DEVICE OPEN
   425 00000020 [621C]                  		DW	DSK$CLOSE	; code 14: DEVICE CLOSE
   426 00000022 [210C]                  		DW	DSK$REM 	; code 15: REMOVABLE MEDIA
   427 00000024 [8806]                  		DW	EXIT
   428 00000026 [8806]                  		DW	EXIT
   429 00000028 [8806]                  		DW	EXIT
   430 0000002A [D112]                  		DW	GENERIC$IOCTL
   431 0000002C [8806]                  		DW	EXIT
   432 0000002E [8806]                  		DW	EXIT
   433 00000030 [8806]                  		DW	EXIT
   434 00000032 [1217]                  		DW	IOCTL$GETOWN
   435 00000034 [3417]                  		DW	IOCTL$SETOWN
   436                                  
   437                                  
   438                                  ;
   439                                  ; Console:
   440                                  ;
   441                                  		;nop
   442 00000036 00                      		db	0
   443                                  CONTBL:
   444 00000037 0A                      		DB	10
   445 00000038 [8806]                  		DW	EXIT
   446 0000003A [8806]                  		DW	EXIT
   447 0000003C [8806]                  		DW	EXIT
   448 0000003E [7106]                  		DW	CMDERR
   449 00000040 [B206]                  		DW	CON$READ
   450 00000042 [DC06]                  		DW	CON$RDND
   451 00000044 [8806]                  		DW	EXIT
   452 00000046 [2207]                  		DW	CON$FLSH
   453 00000048 [3A07]                  		DW	CON$WRIT
   454 0000004A [3A07]                  		DW	CON$WRIT
   455 0000004C [8806]                  		DW	EXIT
   456                                  
   457                                  ;
   458                                  ; Auxilary:
   459                                  ;
   460                                  		;nop
   461 0000004E 00                      		db	0
   462                                  AUXTBL:
   463 0000004F 0A                      		DB	10
   464 00000050 [8806]                  		DW	EXIT
   465 00000052 [8806]                  		DW	EXIT
   466 00000054 [8806]                  		DW	EXIT
   467 00000056 [7106]                  		DW	CMDERR
   468 00000058 [4E07]                  		DW	AUX$READ
   469 0000005A [7507]                  		DW	AUX$RDND
   470 0000005C [8806]                  		DW	EXIT
   471 0000005E [AE07]                  		DW	AUX$FLSH
   472 00000060 [B707]                  		DW	AUX$WRIT
   473 00000062 [B707]                  		DW	AUX$WRIT
   474 00000064 [9707]                  		DW	AUX$WRST
   475                                  
   476                                  ;
   477                                  ; Clock:
   478                                  ;
   479                                  		;nop
   480 00000066 00                      		db	0
   481                                  TIMTBL:
   482 00000067 09                      		DB	9
   483 00000068 [8806]                  		DW	EXIT
   484 0000006A [8806]                  		DW	EXIT
   485 0000006C [8806]                  		DW	EXIT
   486 0000006E [7106]                  		DW	CMDERR
   487 00000070 [5809]                  		DW	TIM$READ
   488 00000072 [6D06]                  		DW	BUS$EXIT
   489 00000074 [8806]                  		DW	EXIT
   490 00000076 [8806]                  		DW	EXIT
   491 00000078 [B908]                  		DW	TIM$WRIT
   492 0000007A [B908]                  		DW	TIM$WRIT
   493                                  
   494                                  ;
   495                                  ; Printer:
   496                                  ;
   497                                  		;nop
   498 0000007C 00                      		db	0
   499                                  PRNTBL:
   500 0000007D 18                      		DB	24
   501 0000007E [8806]                  		DW	EXIT			;INIT
   502 00000080 [8806]                  		DW	EXIT
   503 00000082 [8806]                  		DW	EXIT
   504 00000084 [7106]                  		DW	CMDERR
   505 00000086 [7F06]                  		DW	EXIT$ZER		;INDICATE ZERO CHARS READ
   506 00000088 [6D06]                  		DW	BUS$EXIT
   507 0000008A [8806]                  		DW	EXIT
   508 0000008C [8806]                  		DW	EXIT
   509 0000008E [DB07]                  		DW	PRN$WRIT
   510 00000090 [DB07]                  		DW	PRN$WRIT
   511 00000092 [F707]                  		DW	PRN$STAT
   512 00000094 [8806]                  		DW	EXIT
   513 00000096 [8806]                  		DW	EXIT
   514 00000098 [8806]                  		DW	EXIT
   515 0000009A [8806]                  		DW	EXIT
   516 0000009C [8806]                  		DW	EXIT
   517 0000009E [2708]                  		DW	PRN$TILBUSY
   518 000000A0 [8806]                  		DW	EXIT
   519 000000A2 [8806]                  		DW	EXIT
   520 000000A4 [6D08]                  		DW	PRN$GENIOCTL
   521 000000A6 [8806]                  		DW	EXIT
   522 000000A8 [8806]                  		DW	EXIT
   523 000000AA [8806]                  		DW	EXIT
   524 000000AC [7106]                  		DW	CMDERR
   525 000000AE [7106]                  		DW	CMDERR
   526                                  
   527                                  ; 11/06/2018 - Retro DOS v3.0 (MSDOS 3.3, MSDATA.INC, 24/07/1987) 
   528                                  
   529                                  	;EVENB
   530                                  align 2
   531                                  OLD13:
   532 000000B0 35393836                		db	'5986'		;Code for 3.30
   533                                  ORIG13:
   534 000000B4 32310000                		db	'21',0,0	;Code for 3.30
   535                                  
   536                                  ;
   537                                  ; PTRSAV - pointer save
   538                                  ;
   539                                  ;   This variable holds the pointer to the Request Header passed by a
   540                                  ; program wishing to use a device driver.  When the strategy routine is
   541                                  ; called it puts the address of the Request header in this variable and
   542                                  ; returns.
   543                                  ;
   544                                  
   545                                  	;EVENB
   546                                  PTRSAV:
   547 000000B8 00000000                		DD	0
   548                                  
   549                                  AUXBUF:
   550 000000BC 00000000                		DB	0,0,0,0	; SET OF 1 BYTE BUFFERS FOR COM 1,2,3, AND 4
   551                                  
   552                                  
   553                                  ; 12/06/2018 - Retro DOS v3.0 (MSDOS 3.3, MSDATA.INC, 24/07/1987)
   554                                  
   555                                  	; EVENB
   556                                  align 2
   557                                  
   558                                  PrevOper:
   559 000000C0 0000                    		DW	0	; Holds ROM DISK INT request (i.e. Register AX).
   560                                  Number_Of_Sec:
   561 000000C2 00                      		DB	0	; Holds number of sectors to read on an ECC error
   562                                  
   563                                  ;;Rev 3.30 Modification
   564                                  ;	IF	($-CODE) GT 100H
   565                                  ;	    %OUT VDISK BUFFER NOT CORRECTLY LOCATED
   566                                  ;	ELSE
   567                                  ;	    ORG 100H
   568                                  ;	ENDIF
   569                                  ;	PUBLIC	VDISK_AREA
   570                                  ;VDISK_AREA DB	108 DUP(0)	;FOR USE BY VDISK
   571                                  ;;End of Modification
   572                                  
   573 000000C3 90<rep 3Dh>             align 256 ; 13/06/2018
   574                                  
   575                                  VDISK_AREA:
   576 00000100 00<rep 6Ch>             	times	108 db 	0	;FOR USE BY VDISK	
   577                                  
   578                                  ;align 2
   579                                  
   580                                  ;
   581                                  ; AUXNUM holds the number of the printer or AUX device requested.  For
   582                                  ; example if printer 2 was called (PRN2$IN) AUXNUM is set to be one; with
   583                                  ; line printer 3 AUXNUM is set to 2.  With this set the printer device driver
   584                                  ; can tell which printer to command applies to.
   585                                  ;
   586                                  ; WARNING!!!  These are addressed together in GETDX
   587                                  ;
   588                                  
   589                                  	;EVENB
   590                                  
   591                                  AUXNUM:
   592 0000016C 00                      		DB	0
   593 0000016D 00                      		DB	0
   594                                  
   595                                  ;
   596                                  ; Device Header for the CON Device Driver
   597                                  ;
   598                                  
   599                                  	;EVENB
   600                                  
   601                                  ;align 2
   602                                  
   603                                  CONHeader:
   604                                  		;DD	AUXDEV2
   605 0000016E [8001]                  		DW	AUXDEV2
   606 00000170 7000                    		DW	KERNEL_SEGMENT ; 27/03/2018
   607 00000172 1380                    		DW	1000000000010011B	; Con in and con out + special
   608 00000174 [DC05]                  		DW	STRATEGY		; Strategy entry point
   609 00000176 [E705]                  		DW	CON$IN			; interrupt entry point
   610 00000178 434F4E2020202020        		DB	'CON     '              ; device name
   611                                  
   612                                  
   613                                  ;
   614                                  ; Device Header for device "AUX"
   615                                  ;
   616                                  
   617                                  	;EVENB
   618                                  ;align 2
   619                                  
   620                                  AUXDEV2:					;HEADER FOR DEVICE "AUX"
   621                                  		;DD	PRNDEV2
   622 00000180 [9201]                  		DW	PRNDEV2
   623 00000182 7000                    		DW	KERNEL_SEGMENT ; 27/03/2018
   624 00000184 0080                    		DW	1000000000000000B	; attribute word, character device
   625 00000186 [DC05]                  		DW	STRATEGY		; device strategy routine
   626 00000188 [ED05]                  		DW	AUX0$IN 		; device interrupt routine
   627 0000018A 4155582020202020        		DB	'AUX     '              ; device name
   628                                  
   629                                  
   630                                  ;
   631                                  ; Device Header for device PRN
   632                                  ;
   633                                  
   634                                  	;EVENB
   635                                  ;align 2
   636                                  
   637                                  PRNDEV2:					 ;HEADER FOR DEVICE "PRN"
   638                                  		;DD	TIMDEV
   639 00000192 [A401]                  		DW	TIMDEV
   640 00000194 7000                    		DW	KERNEL_SEGMENT ; 27/03/2018
   641 00000196 40A0                    		DW	CHARDEV + OUTTILBUSY + DEV320
   642 00000198 [DC05]                  		DW	STRATEGY
   643 0000019A [0806]                  		DW	PRN0$IN
   644 0000019C 50524E2020202020        		DB	'PRN     '
   645                                  
   646                                  
   647                                  ;
   648                                  ; Device Header for device CLOCK$
   649                                  ;
   650                                  
   651                                  	;EVENB
   652                                  ;align 2
   653                                  
   654                                  TIMDEV:
   655                                  		;DD	DSKDEV
   656 000001A4 [B601]                  		DW	DSKDEV
   657 000001A6 7000                    		DW	KERNEL_SEGMENT ; 27/03/2018
   658 000001A8 0880                    		DW	1000000000001000B
   659 000001AA [DC05]                  		DW	STRATEGY
   660 000001AC [2E06]                  		DW	TIM$IN
   661 000001AE 434C4F434B242020        		DB	'CLOCK$  '
   662                                  
   663                                  ;
   664                                  ; Device Header for disk devices
   665                                  ;
   666                                  ;	Device attribute bits:
   667                                  ;		Bit 6 - DOS 3.2 Bit
   668                                  ;
   669                                  
   670                                  	;EVENB
   671                                  ;align 2
   672                                  
   673                                  DSKDEV:
   674                                  		;DD	COM1DEV
   675 000001B6 [CA01]                  		DW	COM1DEV
   676 000001B8 7000                    		DW	KERNEL_SEGMENT ; 27/03/2018
   677 000001BA 4008                    		DW	0000100001000000B	; DOS 3.2
   678 000001BC [DC05]                  		DW	STRATEGY		; strategy routine
   679 000001BE [3406]                  		DW	DSK$IN			; Interrupt entry point
   680                                  
   681                                  ;
   682                                  ; maximum number of drives
   683                                  ;
   684                                  
   685                                  DRVMAX:
   686 000001C0 04                      		DB	4
   687                                  
   688                                  ; 25/05/2018 - Retro DOS 3.0
   689 000001C1 FE                      STEP_DRV:	DB	-2
   690 000001C2 00                      PHYS_DRV:	DB	0
   691                                  
   692                                  ; 11/06/2018 - Retro DOS 3.0
   693 000001C3 00                      fHave96:	db	0
   694 000001C4 00                      fHaveK09:	db	0
   695 000001C5 00                      Single:		db	0 ; 13/06/2018
   696 000001C6 00                      fSetOwner:	db	0
   697 000001C7 00                      NEW_ROM:	db	0
   698 000001C8 6B6A                    Secrete_Code:	dw	'kj'		;Code for 3.30.
   699                                  
   700                                  ;
   701                                  ; Last drive accessed
   702                                  ;
   703                                  
   704                                  		; 09/04/2018
   705                                  ;MEDIACHK_DRV:  ;; 13/04/2018
   706                                  ;		DB	0  ; 25/05/2018 
   707                                  		
   708                                  ;TIM_LO:
   709                                  ;		Dw	0FFFFh
   710                                  ;TIM_HI:
   711                                  ;		Dw	0FFFFh
   712                                  ;WRTVERIFY:
   713                                  ;RFLAG:
   714                                  ;		DB	ROMRead		;2 for read, 3 for write
   715                                  ;VERIFY:
   716                                  ;		DB	0		;1 if verify after write
   717                                  ;Single:
   718                                  ;		DB	0
   719                                  ;CURSECBUF:
   720                                  ;		DB	0
   721                                  ;SECCNT:
   722                                  ;		DW	0
   723                                  ;HARDNUM:
   724                                  ;		DB	99		;logical drive number of first hardfile	
   725                                  ;DRVNUM:
   726                                  ;		DB	0
   727                                  ;CURHD:
   728                                  ;		DB	0
   729                                  ;CURSEC:
   730                                  ;		DB	0
   731                                  ;CURTRK:
   732                                  ;		DW	0
   733                                  ;SPSAV:
   734                                  ;		DW	0
   735                                  
   736                                  ;
   737                                  ; Device Header for device "COM1"
   738                                  ;
   739                                  
   740                                  	;EVENB
   741                                  
   742                                  align 2
   743                                  
   744                                  COM1DEV:
   745                                  		;DD	LPT1DEV
   746 000001CA [DC01]                  		DW	LPT1DEV
   747 000001CC 7000                    		DW	KERNEL_SEGMENT ; 27/03/2018
   748 000001CE 0080                    		DW	1000000000000000B ; attribute word, character device
   749 000001D0 [DC05]                  		DW	STRATEGY	; device strategy routine
   750 000001D2 [ED05]                  		DW	AUX0$IN 	; device interrupt routine
   751 000001D4 434F4D3120202020        		DB	'COM1    '	; device name
   752                                  
   753                                  
   754                                  ;
   755                                  ; Device Header for device LPT1
   756                                  ;
   757                                  
   758                                  	;EVENB
   759                                  ;align 2
   760                                  
   761                                  LPT1DEV:
   762                                  		;DD	LPT2DEV
   763 000001DC [EE01]                  		DW	LPT2DEV
   764 000001DE 7000                    		DW	KERNEL_SEGMENT ; 27/03/2018
   765 000001E0 40A0                    		DW	CHARDEV + OUTTILBUSY + DEV320
   766 000001E2 [DC05]                  		DW	STRATEGY
   767 000001E4 [0E06]                  		DW	PRN1$IN ; 03/08/2019
   768 000001E6 4C50543120202020        		DB	'LPT1    '
   769                                  
   770                                  
   771                                  ;
   772                                  ; Device Header for device LPT2
   773                                  ;
   774                                  
   775                                  	;EVENB
   776                                  ;align 2
   777                                  LPT2DEV:
   778                                  		;DD	LPT3DEV
   779 000001EE [0002]                  		DW	LPT3DEV
   780 000001F0 7000                    		DW	KERNEL_SEGMENT ; 27/03/2018
   781 000001F2 40A0                    		DW	CHARDEV + OUTTILBUSY + DEV320
   782 000001F4 [DC05]                  		DW	STRATEGY
   783 000001F6 [1606]                  		DW	PRN2$IN ; 03/08/2019
   784 000001F8 4C50543220202020        		DB	'LPT2    '
   785                                  
   786                                  ;
   787                                  ; Device Header for device LPT3
   788                                  ;
   789                                  
   790                                  	;EVENB
   791                                  ;align 2
   792                                  
   793                                  LPT3DEV:
   794                                  		;DD	COM2DEV
   795 00000200 [1202]                  		DW	COM2DEV
   796 00000202 7000                    		DW	KERNEL_SEGMENT ; 27/03/2018
   797 00000204 40A0                    		DW	CHARDEV + OUTTILBUSY + DEV320
   798 00000206 [DC05]                  		DW	STRATEGY
   799 00000208 [1E06]                  		DW	PRN3$IN ; 03/08/2019
   800 0000020A 4C50543320202020        		DB	'LPT3    '
   801                                  
   802                                  		; 25/05/2018
   803                                  
   804                                  ;
   805                                  ; Device Header for device "COM2"
   806                                  ;
   807                                  
   808                                  	;EVENB
   809                                  
   810                                  ;align 2
   811                                  
   812                                  COM2DEV:
   813                                  		;DD	COM3DEV
   814 00000212 [2402]                  		DW	COM3DEV
   815 00000214 7000                    		DW	KERNEL_SEGMENT
   816 00000216 0080                    		DW	1000000000000000B	; attribute word, character device
   817 00000218 [DC05]                  		DW	STRATEGY		; device strategy routine
   818 0000021A [F305]                  		DW	AUX1$IN 		; device interrupt routine
   819 0000021C 434F4D3220202020        		DB	'COM2    '              ; device name
   820                                  
   821                                  ;;Rev 3.30 Modification
   822                                  ;
   823                                  ; Device header for device "COM3"
   824                                  ;
   825                                  
   826                                  	;EVENB
   827                                  
   828                                  ;align 2 
   829                                  
   830                                  COM3DEV:
   831                                  		;DD	COM4DEV
   832 00000224 [3602]                  		DW	COM4DEV
   833 00000226 7000                    		DW	KERNEL_SEGMENT
   834 00000228 0080                    		DW	1000000000000000b	; character device attribute
   835 0000022A [DC05]                  		DW	STRATEGY
   836 0000022C [F905]                  		DW	AUX2$IN			; com3 == aux2
   837 0000022E 434F4D3320202020        		DB	'COM3    '
   838                                  
   839                                  ;
   840                                  ; Device header for device "COM4"
   841                                  ;
   842                                  
   843                                  	;EVENB
   844                                  
   845                                  ;align 2 
   846                                  
   847                                  COM4DEV:
   848 00000236 FFFF                    		DW	-1
   849 00000238 7000                    		DW	KERNEL_SEGMENT
   850 0000023A 0080                    		DW	1000000000000000b	; character device attribute
   851 0000023C [DC05]                  		DW	STRATEGY
   852 0000023E [FF05]                  		DW	AUX3$IN			; com4 == aux3
   853 00000240 434F4D3420202020        		DB	'COM4    '
   854                                  
   855                                  
   856                                  ; Hard-wire the link to the next Int2f handler.
   857                                  ;;Rev 3.30 Modification
   858                                  		
   859                                  		;EVENB
   860                                  ;align 2
   861                                  
   862                                  NEXT2F_13:
   863                                  		; 13/06/2018
   864 00000248 [851A]                  		DW	INT2F_DISK		; MSBIO2.ASM
   865 0000024A 7000                    		DW	KERNEL_SEGMENT
   866                                  
   867                                  ;
   868                                  ; Start of linked list of BDS's
   869                                  ;
   870                                  
   871                                  		;EVENB
   872                                  ;align 2
   873                                  
   874                                  START_BDS:
   875                                  		; 13/06/2018
   876 0000024C [8204]                         		Dw      BDS1			;START OF BDS LINKED LIST.
   877 0000024E 7000                    		DW	KERNEL_SEGMENT
   878                                  
   879                                  ;;End of Modification
   880                                  
   881                                  
   882                                  ;
   883                                  ; Some floppy drives do not have changeline support.  The result is a
   884                                  ; large amount of inefficiency in the code.  A media-check always returns
   885                                  ; "I don`t know".  This cause DOS to reread the FAT on every access and
   886                                  ; always discard any cached data.
   887                                  ;    We get around this inefficiency by implementing a "Logical Door Latch".
   888                                  ; The following three items are used to do this.  The logical door latch is
   889                                  ; based on the premise that it is not physically possible to change floppy
   890                                  ; disks in a drive in under two seconds (most people take about 10).  The
   891                                  ; logical door latch is implemented by saving the time of the last successful
   892                                  ; disk operation (in the value TIM_DRV).  When a new request is made the
   893                                  ; current time is compared to the saved time.  If less than two seconds have
   894                                  ; passed then the value "No Change" is returned.  If more than two seconds
   895                                  ; have passed the value "Don't Know" is returned.
   896                                  ;    There is one complecation to this algorithm.  Some programs change the
   897                                  ; value of the timer.  In this unfortunate case we have an invalid timer.
   898                                  ; This possibility is detected by counting the number of disk operations
   899                                  ; which occur without any time passing.  If this count exceeds the value of
   900                                  ; "AccessMax" we assume the counter is invalid and always return "Don't
   901                                  ; Know".  The variable "AccessCount" is used to keep track of the number
   902                                  ; of disk operation which occur without the time changing.
   903                                  ;
   904                                  
   905                                  AccessCount:
   906 00000250 00                      		DB	0		; number of times media check called
   907                                  TIM_DRV:
   908 00000251 FF                      		DB	-1		; time when last disk I/O was performed
   909                                  FlagBits:
   910 00000252 0000                    		DW	0		; Bits to set in flag field when doing
   911                                  					; a Set_Changed_DL
   912                                  MedByt:
   913 00000254 00                      		DB	0		; hold media byte from floppy
   914                                  
   915                                  ;		;EVENB
   916 00000255 90                      align 2
   917                                  		; 13/06/2018
   918                                  WRTVERIFY:
   919                                  RFLAG:
   920 00000256 02                      		DB	ROMRead		;2 for read, 3 for write
   921                                  VERIFY:
   922 00000257 00                      		DB	0		;1 if verify after write
   923                                  SECCNT:
   924 00000258 0000                    		DW	0
   925                                  HARDNUM:
   926 0000025A 63                      		DB	99		;logical drive number of first hardfile	
   927                                  
   928                                  ;
   929                                  ; Some of the older versions of the IBM rom-bios always assumed a seek would
   930                                  ; have to be made to read the diskette.  Consequently a large head settle
   931                                  ; time was always used in the I/O operations.  To get around this problem
   932                                  ; we need to continually adjust the head settle time.  The following
   933                                  ; algorithm is used:
   934                                  ;
   935                                  ;   Get the current head settle value.
   936                                  ;   If it is 1, then
   937                                  ;	set slow = 15
   938                                  ;   else
   939                                  ;	set slow = value
   940                                  ;   ...
   941                                  ;   if we are seeking and writing then
   942                                  ;	use slow
   943                                  ;   else
   944                                  ;	use fast
   945                                  ;   ...
   946                                  ;   restore current head settle value
   947                                  ;
   948                                  
   949                                  MotorStartup:
   950 0000025B 00                      		DB	0			; value from table
   951                                  SettleCurrent:
   952 0000025C 00                      		DB	0			; value from table
   953                                  SettleSlow:
   954 0000025D 00                      		DB	0			; slow settle value
   955                                  NextSpeed:
   956 0000025E 00                       		DB	0			; value of speed to be used
   957                                  Save_head_sttl:
   958 0000025F 00                      		DB	0			;used by READ_SECTOR routine
   959                                  EOT:
   960 00000260 09                      		DB	9
   961                                  
   962                                  ; 11/06/2018
   963                                  
   964                                  ;
   965                                  ; pointer to Disk Parameter Table
   966                                  ;
   967                                  ;
   968                                  ;		;EVENB
   969 00000261 90                      align 2
   970                                  DPT:
   971 00000262 00000000                		dd	0
   972                                  
   973                                  ; 13/06/2018
   974                                  ; 23/03/2018
   975                                  ;
   976                                  ; The following two sets of variables are used to hold values for
   977                                  ; disk I/O operations
   978                                  ; Keep the next two items contiguous - see IOCTL_Block for reason
   979                                  
   980                                  CURSEC:	
   981 00000266 00                      		DB	0			; current sector
   982                                  CURHD:
   983 00000267 00                      		DB	0			; current head
   984                                  CURTRK:
   985 00000268 0000                    		DW	0			; current track
   986                                  SPSAV:
   987 0000026A 0000                    		DW	0			; save the stack pointer
   988                                  
   989                                  ;
   990                                  ; The following are used for IOCTL function calls
   991                                  ;
   992                                  
   993                                  ; 11/06/2018 - Retro DOS v3.0
   994                                  FORMT_EOT:
   995 0000026C 08                      		DB	8			; EOT used for format
   996                                  HDNUM:
   997 0000026D 00                      		DB	0			; Head number
   998                                  TRKNUM:
   999 0000026E 0000                    		DW	0			; Track being manipulated
  1000                                  GAP_PATCH:
  1001 00000270 50                      		DB	50h			; Format gap patched into DPT
  1002                                  
  1003                                  ;
  1004                                  ; Disk errors returned from the IBM rom
  1005                                  ;
  1006                                  
  1007                                  ERRIN:
  1008 00000271 80                      		DB	80H			; no response
  1009 00000272 40                      		DB	40H			; seek failure
  1010 00000273 10                      		DB	10H			; bad CRC
  1011 00000274 08                      		DB	8			; DMA overrun
  1012 00000275 06                      		DB	6			; media change
  1013 00000276 04                      		DB	4			; sector not found
  1014 00000277 03                      		DB	3			; write attempt to write-protect disk
  1015                                  LSTERR:
  1016 00000278 00                      		DB	0			; all other errors
  1017                                  
  1018                                  ;
  1019                                  ; returned error code corresponding to above errors
  1020                                  ;
  1021                                  
  1022                                  ERROUT:
  1023 00000279 02                      		DB	2			; no response
  1024 0000027A 06                      		DB	6			; seek failure
  1025 0000027B 04                      		DB	4			; bad CRC
  1026 0000027C 04                      		DB	4			; DMA overrun
  1027 0000027D 0F                      		DB	15			; invalid media change
  1028 0000027E 08                      		DB	8			; sector not found
  1029 0000027F 00                      		DB	0			; write attempt on write-protect disk
  1030 00000280 0C                      		DB	12			; general error
  1031                                  
  1032                                  NUMERR	EQU	ERROUT-ERRIN
  1033                                  
  1034                                  
  1035 00000281 90                      align 2
  1036                                  
  1037                                  ;-------------------------------------------------------------
  1038                                  ;
  1039                                  ; DiskSector is a 512 byte sector into which the boot sector
  1040                                  ; is read.  It is also used as read sector for DMA check for
  1041                                  ; hard disk.
  1042                                  
  1043                                  DiskSector:
  1044                                  		;db	11 dup(?)	   ; take care of 3 jump bytes plus OEM name.
  1045 00000282 00<rep Bh>              		times	11 db 0
  1046                                  BPB_In_Sector:
  1047 0000028D 0000                    		dw	0
  1048                                  SECPERCLUSINSECTOR:
  1049 0000028F 00                      		db	0
  1050 00000290 0000                    		dw	0
  1051 00000292 00                      		db	0
  1052 00000293 0000                    		dw	0
  1053 00000295 0000                    		dw	0
  1054                                  MediaByte:
  1055 00000297 00                      		db	0
  1056 00000298 0000                    		dw	0
  1057 0000029A 0000                    		dw	0
  1058 0000029C 0000                    		dw	0
  1059 0000029E 0000                    		dw	0
  1060 000002A0 00                      		db	0
  1061                                  		;db	512-($-DiskSector) dup (?)
  1062 000002A1 00<rep 1E1h>            		times	512-($-DiskSector) db 0
  1063                                  
  1064                                  
  1065                                  ; 25/05/2018 (04/04/2018)
  1066                                  
  1067                                  ;---------------------------------------------------------------------
  1068                                  ;
  1069                                  ;	The "BDS"'s contain information for each drive in the system.
  1070                                  ;  There is one BDS for each logical drvie in the system.  The BDS's
  1071                                  ;  are all linked together in a chain.	The BDS contain various values
  1072                                  ;  important to the disk drive. Various values are updated whenever actions
  1073                                  ;  are performed.  For example if a drive is read from the last time
  1074                                  ;  accessed fields are updated to the current time.
  1075                                  ;	Initial values:
  1076                                  ;    *	Sectors/Alloc. unit in BPB initially set to -1 to signify that
  1077                                  ;	the BPB has not been filled.
  1078                                  ;    *	Link is set to -1 to signify end of list.
  1079                                  ;    *	number of cylinders in MaxParms initialized to -1 to indicate
  1080                                  ;	that the parameters have not been set.
  1081                                  ;
  1082                                  ;  START_BDS contains a pointer to the first BDS.  It is through this
  1083                                  ;  pointer that routines find particular BDS (see SetDrive to see how
  1084                                  ;  this is done).
  1085                                  ;
  1086                                  
  1087                                  	;EVENB
  1088                                  ;align 2
  1089                                  
  1090                                  BDS1:
  1091                                  		;DD	BDS2			;LINK TO NEXT STRUCTURE
  1092 00000482 [D404]                  		DW	BDS2
  1093 00000484 7000                    		DW	KERNEL_SEGMENT  ; 28/03/2018
  1094 00000486 00                      		DB	0			;ROM DISK INT Drive Number
  1095 00000487 00                      		DB	0			;Logical Drive Letter
  1096                                  FDRIVE1:
  1097 00000488 0002                    		DW	512			;Physical sector size in bytes
  1098 0000048A FF                      		DB	-1			;Sectors/allocation unit
  1099 0000048B 0100                    		DW	1			;Reserved sectors for DOS
  1100 0000048D 02                      		DB	2			;No. allocation tables
  1101 0000048E 4000                    		DW	64			;Number directory entries
  1102 00000490 6801                    		DW	9*40			;Number sectors (at 512 bytes ea.)
  1103 00000492 00                      		DB	00000000b		;Media descriptor, initially 00H.
  1104 00000493 0200                    		DW	2			;Number of FAT sectors
  1105 00000495 0900                    		DW	9			;Sector limit
  1106 00000497 0100                    		DW	1			;Head limit
  1107 00000499 0000                    		DW	0			;Hidden sector count
  1108 0000049B 00                      		DB	0			; TRUE => Large fats
  1109                                  OPCNT1:
  1110 0000049C 0000                    		DW	0			;Open Ref. Count
  1111                                  VOLID1:
  1112 0000049E 4E4F204E414D452020-     		DB	"NO NAME    ",0         ;Volume ID for this disk
  1112 000004A7 202000             
  1113 000004AA 03                      		DB	3			;Form Factor
  1114                                  FLAGS1:
  1115 000004AB 2000                    		DW	0020H			;Various Flags
  1116                                  	;	DB	9 dup (0)		;Reserved for future use
  1117 000004AD 2800                    		dw	40			; number of cylinders
  1118                                  RecBPB1:
  1119 000004AF 0002                    		DW	512			;Physical sector size in bytes
  1120 000004B1 01                      		DB	1			;Sectors/allocation unit
  1121 000004B2 0100                    		DW	1			;Reserved sectors for DOS
  1122 000004B4 02                      		DB	2			;No. allocation tables
  1123 000004B5 E000                    		DW	0E0H			;NUMBER DIRECTORY ENTRIES
  1124 000004B7 6801                    		DW	9*40			;Number sectors (at 512 bytes ea.)
  1125 000004B9 F0                      		DB	0F0h			;Media descriptor, initially 00H.
  1126 000004BA 0200                    		DW	2			;Number of FAT sectors
  1127 000004BC 0900                    		DW	9			;Sector limit
  1128 000004BE 0200                    		DW	2			;HEAD LIMIT
  1129 000004C0 0000                    		DW	0			;Hidden sector count
  1130                                  		;DB	12 DUP (?)
  1131 000004C2 00<rep Ch>              		times	12 db 0
  1132                                  TRACK1:
  1133 000004CE FF                      		DB	-1			;Last track accessed on this drive
  1134                                  TIM_LO1:
  1135 000004CF FFFF                    		DW	-1			;Keep these two contiguous (?)
  1136                                  TIM_HI1:
  1137 000004D1 FFFF                    		DW	-1
  1138                                  
  1139                                  	;EVENB
  1140 000004D3 90                      align 2
  1141                                  BDS2:
  1142                                  		;DD	BDS3			;LINK TO NEXT STRUCTURE
  1143 000004D4 [2605]                  		DW	BDS3
  1144 000004D6 7000                    		DW	KERNEL_SEGMENT ; 28/03/2018
  1145 000004D8 00                      		DB	0			;INT 13 DRIVE NUMBER
  1146 000004D9 00                      		DB	0			;Logical Drive Letter
  1147                                  FDRIVE2:
  1148 000004DA 0002                    		DW	512			;Physical sector size in bytes
  1149 000004DC FF                      		DB	-1			;Sectors/allocation unit
  1150 000004DD 0100                    		DW	1			;Reserved sectors for DOS
  1151 000004DF 02                      		DB	2			;No. allocation tables
  1152 000004E0 4000                    		DW	64			;Number directory entries
  1153 000004E2 6801                    		DW	9*40			;Number sectors (at 512 bytes ea.)
  1154 000004E4 00                      		DB	00000000b		;Media descriptor, initially 00H.
  1155 000004E5 0200                    		DW	2			;Number of FAT sectors
  1156 000004E7 0900                    		DW	9			;Sector limit
  1157 000004E9 0100                    		DW	1			;Head limit
  1158 000004EB 0000                    		DW	0			;Hidden sector count
  1159 000004ED 00                      		DB	0			; TRUE => Large fats
  1160                                  OPCNT2:
  1161 000004EE 0000                    		DW	0			;Open Ref. Count
  1162                                  VOLID2:
  1163 000004F0 4E4F204E414D452020-     		DB	"NO NAME    ",0         ;Volume ID for this disk
  1163 000004F9 202000             
  1164 000004FC 03                      		DB	3			;Form Factor
  1165                                  FLAGS2:
  1166 000004FD 2000                    		DW	0020H			;Various Flags
  1167                                  	;	DB	9 dup (0)		;Reserved for future use
  1168 000004FF 2800                    		dw	40			; number of cylinders
  1169                                  RecBPB2:
  1170 00000501 0002                    		DW	512			;Physical sector size in bytes
  1171 00000503 01                      		DB	1			;Sectors/allocation unit
  1172 00000504 0100                    		DW	1			;Reserved sectors for DOS
  1173 00000506 02                      		DB	2			;No. allocation tables
  1174 00000507 E000                    		DW	0E0H			;NUMBER DIRECTORY ENTRIES
  1175 00000509 6801                    		DW	9*40			;Number sectors (at 512 bytes ea.)
  1176 0000050B F0                      		DB	0F0h			;Media descriptor, initially 00H.
  1177 0000050C 0200                    		DW	2			;Number of FAT sectors
  1178 0000050E 0900                    		DW	9			;Sector limit
  1179 00000510 0200                    		DW	2			;HEAD LIMIT
  1180 00000512 0000                    		DW	0			;Hidden sector count
  1181                                  		;DB	12 DUP (?)
  1182 00000514 00<rep Ch>              		times	12 db 0
  1183                                  TRACK2:
  1184 00000520 FF                      		DB	-1			;Last track accessed on this drive
  1185                                  TIM_LO2:
  1186 00000521 FFFF                    		DW	-1			;Keep these two contiguous (?)
  1187                                  TIM_HI2:
  1188 00000523 FFFF                    		DW	-1
  1189                                  
  1190                                  	;EVENB
  1191 00000525 90                      align 2
  1192                                  BDS3:
  1193                                  		;DD	BDS4			;LINK TO NEXT STRUCTURE
  1194 00000526 [7805]                  		DW	BDS4
  1195 00000528 7000                    		DW	KERNEL_SEGMENT ; 28/03/2018
  1196 0000052A 00                      		DB	0			;INT 13 DRIVE NUMBER
  1197 0000052B 00                      		DB	0			;Logical Drive Letter
  1198                                  FDRIVE3:
  1199 0000052C 0002                    		DW	512			;Physical sector size in bytes
  1200 0000052E FF                      		DB	-1			;Sectors/allocation unit
  1201 0000052F 0100                    		DW	1			;Reserved sectors for DOS
  1202 00000531 02                      		DB	2			;No. allocation tables
  1203 00000532 4000                    		DW	64			;Number directory entries
  1204 00000534 6801                    		DW	9*40			;Number sectors (at 512 bytes ea.)
  1205 00000536 00                      		DB	00000000b		;Media descriptor, initially 00H.
  1206 00000537 0200                    		DW	2			;Number of FAT sectors
  1207 00000539 0900                    		DW	9			;Sector limit
  1208 0000053B 0100                    		DW	1			;Head limit
  1209 0000053D 0000                    		DW	0			;Hidden sector count
  1210 0000053F 00                      		DB	0			; TRUE => Large fats
  1211                                  OPCNT3:
  1212 00000540 0000                    		DW	0			;Open Ref. Count
  1213                                  VOLID3:
  1214 00000542 4E4F204E414D452020-     		DB	"NO NAME    ",0         ;Volume ID for this disk
  1214 0000054B 202000             
  1215 0000054E 03                      		DB	3			;Form Factor
  1216                                  FLAGS3:
  1217 0000054F 2000                    		DW	0020H			;Various Flags
  1218                                  	;	DB	9 dup (0)		;Reserved for future use
  1219 00000551 2800                    		dw	40			; number of cylinders
  1220                                  RecBPB3:
  1221 00000553 0002                    		DW	512			;Physical sector size in bytes
  1222 00000555 01                      		DB	1			;Sectors/allocation unit
  1223 00000556 0100                    		DW	1			;Reserved sectors for DOS
  1224 00000558 02                      		DB	2			;No. allocation tables
  1225 00000559 E000                    		DW	0E0H			;NUMBER DIRECTORY ENTRIES
  1226 0000055B 6801                    		DW	9*40			;Number sectors (at 512 bytes ea.)
  1227 0000055D F0                      		DB	0F0h			;Media descriptor, initially 00H.
  1228 0000055E 0200                    		DW	2			;Number of FAT sectors
  1229 00000560 0900                    		DW	9			;Sector limit
  1230 00000562 0200                    		DW	2			;HEAD LIMIT
  1231 00000564 0000                    		DW	0			;Hidden sector count
  1232                                  		;DB	12 DUP (?)
  1233 00000566 00<rep Ch>              		times	12 db 0	
  1234                                  TRACK3:
  1235 00000572 FF                      		DB	-1			;Last track accessed on this drive
  1236                                  TIM_LO3:
  1237 00000573 FFFF                    		DW	-1			;Keep these two contiguous (?)
  1238                                  TIM_HI3:
  1239 00000575 FFFF                    		DW	-1
  1240                                  
  1241                                  	;EVENB
  1242 00000577 90                      align 2
  1243                                  BDS4:
  1244 00000578 FFFF                    		DW	-1			;Link to next structure
  1245                                  		;DW	Code
  1246 0000057A 7000                    		DW	KERNEL_SEGMENT
  1247 0000057C 00                      		DB	0			;INT 13 DRIVE NUMBER
  1248 0000057D 00                      		DB	0			;Logical Drive Letter
  1249                                  FDRIVE4:
  1250 0000057E 0002                    		DW	512			;Physical sector size in bytes
  1251 00000580 FF                      		DB	-1			;Sectors/allocation unit
  1252 00000581 0100                    		DW	1			;Reserved sectors for DOS
  1253 00000583 02                      		DB	2			;No. allocation tables
  1254 00000584 4000                    		DW	64			;Number directory entries
  1255 00000586 6801                    		DW	9*40			;Number sectors (at 512 bytes ea.)
  1256 00000588 00                      		DB	00000000b		;Media descriptor, initially 00H.
  1257 00000589 0200                    		DW	2			;Number of FAT sectors
  1258 0000058B 0900                    		DW	9			;Sector limit
  1259 0000058D 0100                    		DW	1			;Head limit
  1260 0000058F 0000                    		DW	0			;Hidden sector count
  1261 00000591 00                      		DB	0			; TRUE => Large fats
  1262                                  OPCNT4:
  1263 00000592 0000                    		DW	0			;Open Ref. Count
  1264                                  VOLID4:
  1265 00000594 4E4F204E414D452020-     		DB	"NO NAME    ",0         ;Volume ID for this disk
  1265 0000059D 202000             
  1266 000005A0 03                      		DB	3			;Form Factor
  1267                                  FLAGS4:
  1268 000005A1 2000                    		DW	0020H			;Various Flags
  1269                                  	;	DB	9 dup (0)		;Reserved for future use
  1270 000005A3 2800                    		dw	40			; number of cylinders
  1271                                  ;;Rev 3.30 Modification
  1272                                  RECBPB4:
  1273 000005A5 0002                    		DW	512			;BYTES PER SECTOR
  1274 000005A7 01                      		DB	1			;SECTORS/ALLOCATION UNIT
  1275 000005A8 0100                    		DW	1			;RESERVED SECTORS FOR DOS
  1276 000005AA 02                      		DB	2			;NO. ALLOCATION TABLES
  1277 000005AB E000                    		DW	0E0H			;NUMBER DIRECTORY ENTRIES
  1278 000005AD 6801                    		DW	9*40			;NUMBER SECTORS (AT 512 BYTES EA.)
  1279 000005AF F0                      		DB	0F0H			;MEDIA DESCRIPTOR, INITIALLY F0H.
  1280 000005B0 0200                    		DW	2			;NUMBER OF FAT SECTORS
  1281 000005B2 0900                    		DW	9			;SECTOR LIMIT
  1282 000005B4 0200                    		DW	2			;HEAD LIMIT
  1283 000005B6 0000                    		DW	0			;HIDDEN SECTOR COUNT
  1284                                  		;DB	12 DUP (?)
  1285 000005B8 00<rep Ch>              		times	12 db 0
  1286                                  ;;End of Modification
  1287                                  TRACK4:
  1288 000005C4 FF                      		DB	-1			;Last track accessed on this drive
  1289                                  TIM_LO4:
  1290 000005C5 FFFF                    		DW	-1			;Keep these two contiguous (?)
  1291                                  TIM_HI4:
  1292 000005C7 FFFF                    		DW	-1
  1293                                  
  1294                                  struc bpbType
  1295 00000000 ??                      .spf:	resb 	1
  1296 00000001 ??                      .spt:	resb 	1
  1297 00000002 ??                      .cdire:	resb 	1
  1298 00000003 ????                    .csec:	resw 	1
  1299 00000005 ??                      .spa:	resb	1
  1300 00000006 ??                      .chead:	resb	1
  1301                                  .size:
  1302                                  endstruc
  1303                                  
  1304                                  SM92:   ; bpbType
  1305 000005C9 03                      		db	3	; .spf
  1306 000005CA 09                      		db	9	; .spt
  1307 000005CB 70                      		db	70h	; .cdire
  1308 000005CC A005                    		dw	2*9*80	; .csec
  1309 000005CE 02                      		db	2	; .spa	
  1310 000005CF 02                      		db	2	; .chead
  1311                                  
  1312                                  	
  1313                                  ;
  1314                                  ; ALTAH is a single character buffer used to handle special keys.
  1315                                  ;
  1316                                  
  1317                                  ALTAH:
  1318 000005D0 00                      		DB	0			;Special key handling
  1319                                  
  1320                                  ;
  1321                                  ; The following variable can be modified via IOCTL sub-function 16. In this
  1322                                  ; way, the wait can be set to suit the speed of the particular printer being
  1323                                  ; used. One for each printer device.
  1324                                  ;
  1325                                  
  1326                                  PRINTDEV:
  1327 000005D1 00                      		DB	0		; Index into following array
  1328                                  
  1329                                  ;EVENB
  1330                                  align 2
  1331                                  
  1332                                  WAIT_COUNT:
  1333                                  		;DW	4 dup (50h)	; Array of Retry counts for printer
  1334 000005D2 5000<rep 4h>            		times	4 dw 50h	 	
  1335                                  
  1336                                  ;
  1337                                  ; DAYCNT is the number of days since 1-1-80.
  1338                                  ; Each time the clock is read it is necessary to check if another day has
  1339                                  ; passed.  The ROM only returns the day rollover once so if it is missed
  1340                                  ; the time will be off by a day.
  1341                                  ;
  1342                                  
  1343                                  ;EVENB
  1344                                  ;align 2
  1345                                  
  1346                                  DAYCNT:
  1347 000005DA 0000                    		DW	0
  1348                                  
  1349                                  ;-----------------------------------------------------------------------------
  1350                                  ; MSBIO1.ASM  - MSDOS 3.3 - 24/07/1987
  1351                                  ;-----------------------------------------------------------------------------
  1352                                  ; 23/03/2018 - Retro DOS v2.0
  1353                                  
  1354                                  ;
  1355                                  ; The next nine equ's describe the offset into the request header for
  1356                                  ; different information.  For example STATUS is in byte 3 of the request
  1357                                  ; header (starting count at zero).
  1358                                  ;
  1359                                  
  1360                                  CMDLEN	equ	0			; length of this command
  1361                                  UNIT	equ	1			; sub unit specifier
  1362                                  CMD	equ	2			; command code
  1363                                  STATUS	equ	3			; status
  1364                                  MEDIA	equ	13			; media descriptor
  1365                                  TRANS	equ	14			; transfer address
  1366                                  COUNT	equ	18			; count of blocks or characters
  1367                                  START	equ	20			; first block to transfer
  1368                                  EXTRA	equ	22			; Usually pointer to Vol Id for error 15
  1369                                  
  1370                                  ;
  1371                                  ; Strategy is the strategy entry point for all default bio device drivers.
  1372                                  ; All that is done is to save the pointer to the request header in the
  1373                                  ; variable PtrSav.
  1374                                  ;
  1375                                  
  1376                                  STRATEGY:
  1377 000005DC 2E891E[B800]            		mov	[CS:PTRSAV],BX
  1378 000005E1 2E8C06[BA00]            		mov	[CS:PTRSAV+2],ES
  1379 000005E6 CB                      		retf
  1380                                  
  1381                                  ;------------------------------------------------------------------------------
  1382                                  ;
  1383                                  ;			Device entry point
  1384                                  ;
  1385                                  ; The following ten pieces of code are the interrupt entry points for the
  1386                                  ; default device drivers.  These small pieces of code have two jobs.
  1387                                  ;
  1388                                  ;	1) Make SI point to the beginning of the proper command jump  table.
  1389                                  ;	   SI must first be pushed to preserve original contents.
  1390                                  ;	2) If the call is an AUX or a printer save the number of the
  1391                                  ;	   request in AL.  AL is moved to AUXNUM below.
  1392                                  ;
  1393                                  
  1394                                  ;
  1395                                  ; Con device:
  1396                                  ;
  1397                                  CON$IN:
  1398 000005E7 56                      		PUSH	SI
  1399 000005E8 BE[3700]                		MOV	SI,CONTBL
  1400 000005EB EB4B                    		JMP	SHORT ENTRY
  1401                                  AUX0$IN:
  1402 000005ED 56                      		PUSH	SI
  1403 000005EE 50                      		PUSH	AX
  1404 000005EF 30C0                    		XOR	AL,AL
  1405 000005F1 EB10                    		JMP	SHORT AUXENT
  1406                                  AUX1$IN:
  1407 000005F3 56                      		PUSH	SI
  1408 000005F4 50                      		PUSH	AX
  1409 000005F5 B001                    		MOV	AL,1
  1410 000005F7 EB0A                    		JMP	short AUXENT
  1411                                  
  1412                                  		; 25/05/2018
  1413                                  AUX2$IN:
  1414 000005F9 56                      		PUSH	SI
  1415 000005FA 50                      		PUSH	AX
  1416 000005FB B002                    		MOV	AL,2
  1417 000005FD EB04                    		JMP	short AUXENT
  1418                                  AUX3$IN:
  1419 000005FF 56                      		PUSH	SI
  1420 00000600 50                      		PUSH	AX
  1421 00000601 B003                    		MOV	AL,3
  1422                                  		;JMP	short AUXENT
  1423                                  AUXENT:
  1424 00000603 BE[4F00]                		MOV	SI,AUXTBL
  1425 00000606 EB31                    		JMP	SHORT ENTRY1
  1426                                  
  1427                                  PRN0$IN:
  1428 00000608 56                      		PUSH	SI
  1429 00000609 50                      		PUSH	AX
  1430 0000060A 31C0                    		XOR	AX,AX
  1431 0000060C EB16                    		JMP	SHORT PRNENT
  1432                                  PRN1$IN:
  1433 0000060E 56                      		PUSH	SI
  1434 0000060F 50                      		PUSH	AX
  1435 00000610 30C0                    		XOR	AL,AL
  1436 00000612 B401                    		MOV	AH,1
  1437 00000614 EB0E                    		JMP	SHORT PRNENT
  1438                                  PRN2$IN:
  1439 00000616 56                      		PUSH	SI
  1440 00000617 50                      		PUSH	AX
  1441 00000618 B001                    		MOV	AL,1
  1442 0000061A B402                    		MOV	AH,2
  1443 0000061C EB06                    		JMP	SHORT PRNENT
  1444                                  PRN3$IN:
  1445 0000061E 56                      		PUSH	SI
  1446 0000061F 50                      		PUSH	AX
  1447 00000620 B002                    		MOV	AL,2
  1448 00000622 B403                    		MOV	AH,3
  1449                                  PRNENT:
  1450 00000624 BE[7D00]                		MOV	SI,PRNTBL
  1451 00000627 2E8826[D105]            		MOV	[CS:PRINTDEV],AH
  1452 0000062C EB0B                    		JMP	SHORT ENTRY1
  1453                                  
  1454                                  TIM$IN:
  1455 0000062E 56                      		PUSH	SI
  1456 0000062F BE[6700]                		MOV	SI,TIMTBL
  1457 00000632 EB04                    		JMP	SHORT ENTRY
  1458                                  
  1459                                  DSK$IN:
  1460 00000634 56                      		PUSH	SI
  1461 00000635 BE[0300]                		mov	SI,DSKTBL
  1462                                  
  1463                                  ;
  1464                                  ;  This section is the prolog to all default device drivers.  All registers
  1465                                  ; are saved, the registers are filled with information from the request header,
  1466                                  ; and the routine from the jump table is called. Error checking is done
  1467                                  ; to assure command code is valid. Before calling the routine in the
  1468                                  ; jump table the register are:
  1469                                  ;
  1470                                  ;	AH = Media Descriptor
  1471                                  ;	AL = Unit Code
  1472                                  ;	BX = offset to PTRSAV (request header is therefore at DS:BX)
  1473                                  ;	CX = count from request header
  1474                                  ;	DX = start sector
  1475                                  ;	ES:DI = transfer address
  1476                                  ;	SI = points to jump table
  1477                                  ;	DS = points to this segment
  1478                                  ;
  1479                                  ; Once the routine finishes its job it jumps back to one of the eight
  1480                                  ; pieces of code below labeled Exit Points.
  1481                                  ;
  1482                                  
  1483                                  ENTRY:
  1484 00000638 50                      		push	AX
  1485                                  ENTRY1:
  1486 00000639 51                      		push	CX			; save all registers
  1487 0000063A 52                      		push	DX
  1488 0000063B 57                      		push	DI
  1489 0000063C 55                      		push	BP
  1490 0000063D 1E                      		push	DS
  1491 0000063E 06                      		push	ES
  1492 0000063F 53                      		push	BX
  1493                                  
  1494 00000640 2EA2[6C01]              		mov	[CS:AUXNUM],AL		; save choice of AUX/PRN device
  1495                                  
  1496 00000644 2EC51E[B800]            		lds	BX,[CS:PTRSAV]		; get pointer to I/O packet
  1497                                  	
  1498 00000649 8A4701                  		mov	AL,[BX+UNIT]		;AL = UNIT CODE
  1499 0000064C 8A670D                  		mov	AH,[BX+MEDIA]		;AH = MEDIA DESCRIP
  1500 0000064F 8B4F12                  		mov	CX,[BX+COUNT]		;CX = COUNT
  1501 00000652 8B5714                  		mov	DX,[BX+START]		;DX = START SECTOR
  1502                                  
  1503 00000655 97                      		xchg	DI,AX
  1504 00000656 8A4702                  		mov	AL,[BX+CMD]
  1505                                  		; 11/04/2018 (25/05/2018)
  1506 00000659 2E3A04                  		cmp	AL,[CS:SI]		; is command code a valid number?
  1507 0000065C 7713                    		ja	SHORT CMDERR		; no, jump to handle error
  1508                                  
  1509                                  		;XOR	AH,AH
  1510 0000065E 98                      		CBW				; note that AL <= 15 means OK
  1511 0000065F D1E0                    		shl	AX,1
  1512 00000661 01C6                    		add	SI,AX			; get SI to point to address of routine
  1513                                  		
  1514 00000663 97                      		xchg	AX,DI			; put proper value back into AX
  1515 00000664 C47F0E                  		les	DI,[BX+TRANS]		; get ES:DI to point to transfer address
  1516 00000667 0E                      		push	CS			; get DS equal to CS
  1517 00000668 1F                      		pop	DS
  1518                                  
  1519 00000669 FC                      		cld				; clear the direction flag
  1520                                  		; 25/05/2018
  1521 0000066A FF6401                  		jmp	WORD [SI+1]		; go to the command
  1522                                  
  1523                                  
  1524                                  ;=====================================================
  1525                                  ;=
  1526                                  ;=	SUBROUTINES SHARED BY MULTIPLE DEVICES
  1527                                  ;=
  1528                                  ;=====================================================
  1529                                  
  1530                                  ;----------------------------------------------------------
  1531                                  ;
  1532                                  ;		Exit  Points
  1533                                  ;
  1534                                  ; All device driver call return through one of these eight
  1535                                  ; pieces of code.  The code set error and status conditions
  1536                                  ; and then restores the registers.
  1537                                  ;
  1538                                  		
  1539                                  BUS$EXIT:				; device busy exit
  1540                                  
  1541 0000066D B403                    		mov	AH,00000011b		; set error code
  1542 0000066F EB19                    		jmp	SHORT ERR1
  1543                                  CMDERR:
  1544 00000671 B003                    		mov	AL,3			; unknown command error
  1545                                  ERR$CNT:
  1546 00000673 2EC51E[B800]            		lds	BX,[CS:PTRSAV]
  1547                                  		;lds	BX,[PTRSAV]	; 11/04/2018
  1548 00000678 294F12                  		sub	[BX+COUNT],CX		;# of successful I/O's
  1549                                  ERR$EXIT:
  1550 0000067B B481                    		mov	AH,10000001b		; mark error and return
  1551 0000067D EB0B                    		jmp	SHORT ERR1
  1552                                  
  1553                                  EXIT$ZER:
  1554                                  		;lds	BX,[CS:PTRSAV]
  1555 0000067F C51E[B800]              		lds	BX,[PTRSAV]		; IBMDOS 3.3 (IBMBIO.COM)
  1556 00000683 31C0                    		xor	AX,AX
  1557 00000685 894712                  		mov	[BX+COUNT],AX		; indicate no character read
  1558                                  
  1559                                  EXIT:
  1560 00000688 B401                    		mov	AH,00000001b
  1561                                  ERR1:
  1562 0000068A 2EC51E[B800]            		lds	BX,[CS:PTRSAV]
  1563                                  		;lds	BX,[PTRSAV]	; 11/04/2018
  1564 0000068F 894703                  		mov	[BX+STATUS],AX		; mark operation complete
  1565                                  
  1566 00000692 5B                      		pop	BX			; restore register and return
  1567 00000693 07                      		pop	ES
  1568 00000694 1F                      		pop	DS
  1569 00000695 5D                      		pop	BP
  1570 00000696 5F                      		pop	DI
  1571 00000697 5A                      		pop	DX
  1572 00000698 59                      		pop	CX
  1573 00000699 58                      		pop	AX
  1574 0000069A 5E                      		pop	SI
  1575 0000069B CB                      		retf
  1576                                  
  1577                                  
  1578                                  ;-------------------------------------------------------------
  1579                                  ;
  1580                                  ; Chrout - write out character in AL using current attribute
  1581                                  ;
  1582                                  ;   called via int 29h
  1583                                  ;
  1584                                  
  1585                                  CHROUT	equ 29H
  1586                                  
  1587                                  OUTCHR:
  1588                                  		; 13/06/2018 (IBMDOS 3.3, IBMBIO.COM) ; **
  1589                                  		; 08/04/2018 (IBMDOS 2.1, IBMBIO.COM) ; *
  1590                                  		;sti ; *
  1591 0000069C 50                      		push	AX			; preserve affect registers
  1592 0000069D 56                      		push	SI ; **
  1593 0000069E 57                      		push	DI ; **
  1594 0000069F 55                      		push	BP ; **
  1595                                  		;push	BX			;
  1596 000006A0 B40E                    		mov	AH,0Eh 			; set command to write a character
  1597                                  		;mov	BH,0			;
  1598                                  		;mov	BL,7			; set foreground color
  1599 000006A2 BB0700                  		mov	BX,7
  1600 000006A5 CD10                    		int	10h			; call rom-bios
  1601                                  		;pop	BX			;
  1602 000006A7 5D                      		pop	BP ; **			; restore registers
  1603 000006A8 5F                      		pop	DI ; **
  1604 000006A9 5E                      		pop	SI ; **
  1605 000006AA 58                      		pop	AX
  1606 000006AB CF                      		iret
  1607                                  
  1608                                  ;----------------------------------------------
  1609                                  ;
  1610                                  ; Fill DX register with value in AUXNUM
  1611                                  ;
  1612                                  
  1613                                  GETDX:
  1614                                  		; IBMDOS 2.1
  1615                                  		;mov	dl, [AUXNUM]
  1616                                  		;xor	dh,dh
  1617                                  
  1618                                  		; MSDOS 3.3
  1619 000006AC 2E8B16[6C01]            		mov	DX,[CS:AUXNUM]
  1620 000006B1 C3                      		retn
  1621                                  
  1622                                  ;-----------------------------------------------------------------------------
  1623                                  ; MSCON.ASM - MSDOS 3.3 - 24/07/1987
  1624                                  ;-----------------------------------------------------------------------------
  1625                                  ; 23/03/2018 - Retro DOS v2.0
  1626                                  
  1627                                  ;----------------------------------------------------------------
  1628                                  ;								:
  1629                                  ;	      C O N - CONSOLE DEVICE DRIVER			:
  1630                                  ;								:
  1631                                  ;								:
  1632                                  ;   This file contains the Console Device Driver.  The		:
  1633                                  ; console device driver sends characters to the moniter and	:
  1634                                  ; gets characters from the keyboard.				:
  1635                                  ;								:
  1636                                  ;----------------------------------------------------------------
  1637                                  
  1638                                  
  1639                                  ;----------------------------------------------------------------
  1640                                  ;								:
  1641                                  ;		    Console read routine			:
  1642                                  ;								:
  1643                                  ;----------------------------------------------------------------
  1644                                  ;
  1645                                  
  1646                                  CON$READ:					; if CX is zero, no characters
  1647 000006B2 E306                    		jcxz	CON$EXIT		;   to be read -- just exit
  1648                                  CON$LOOP:
  1649 000006B4 E80500                  		call	CHRIN			; get char in AL
  1650 000006B7 AA                      		stosb				; store char at ES:DI, specified buffer
  1651 000006B8 E2FA                    		loop	CON$LOOP		; if CX is non-zero more char to read
  1652                                  CON$EXIT:
  1653 000006BA EBCC                    		jmp	short EXIT		; all done, successful return
  1654                                  
  1655                                  
  1656                                  ;----------------------------------------------------------------
  1657                                  ;								:
  1658                                  ;	    Input single character into AL			:
  1659                                  ;								:
  1660                                  ;----------------------------------------------------------------
  1661                                  CHRIN:
  1662                                  						; set command to read character
  1663 000006BC 31C0                    		xor	AX, AX			;  and clear AL
  1664 000006BE 8606[D005]              		xchg	AL,[ALTAH]		; get character & zero ALTAH
  1665 000006C2 08C0                    		or	AL, AL			; see if buffer has a character
  1666 000006C4 7515                    		jnz	short KEYRET		; if so - return this character
  1667                                  						; if not - read single character
  1668 000006C6 CD16                    		int	16h			; call ROM-Bios keyboard routine
  1669                                  ALT10:
  1670 000006C8 09C0                    		or	AX,AX			; Check for non-key after BREAK
  1671 000006CA 74F0                    		jz	short CHRIN
  1672 000006CC 3D0072                  		cmp	AX,7200h		; Check for CTRL-PRTSC
  1673 000006CF 7502                    		jnz	short ALT15
  1674 000006D1 B010                    		mov	AL,16			; indicate prtsc
  1675                                  ALT15:
  1676 000006D3 08C0                    		or	AL,AL			; special case?
  1677 000006D5 7504                    		jnz	short KEYRET		; no, return with character
  1678 000006D7 8826[D005]              		mov	[ALTAH], AH		; yes, store special key
  1679                                  KEYRET:
  1680 000006DB C3                      		RETN
  1681                                  
  1682                                  ;----------------------------------------------------------------
  1683                                  ;								:
  1684                                  ;	   Keyboard non destructive read, no wait		:
  1685                                  ;								:
  1686                                  ; If bit 10 is set by the DOS in the status word of the request :
  1687                                  ; packet, and there is no character in the input buffer, the	:
  1688                                  ; driver issues a system WAIT request to the ROM. On return	:
  1689                                  ; from the ROM, it returns a 'char-not-found' to the DOS.       :
  1690                                  ;								:
  1691                                  ;----------------------------------------------------------------
  1692                                  
  1693                                  		; 13/06/2018 (Retro DOS v3.0, IBMDOS 3.0, IBMBIO.COM) 
  1694                                  ;CONBUSJ:
  1695                                  ;		JMP	short CONBUS
  1696                                  
  1697                                  CON$RDND:
  1698 000006DC A0[D005]                		mov	AL,[ALTAH]		; first see if there is a
  1699 000006DF 08C0                    		or	AL,AL			; character in the buffer?
  1700                                  		;jz	short RD1		; with debugging code it is
  1701                                  		;jmp	short RDEXIT		; too far for conditional jump
  1702 000006E1 7532                    		jnz	short RDEXIT
  1703                                  
  1704                                  RD1:				     		; set command to 'see if
  1705 000006E3 B401                    		mov	AH, 1	     		; character available'
  1706 000006E5 CD16                    		int	16h	     		; call ROM-BIOS keyboard routine
  1707 000006E7 7402                    		jz	short nochr		; with debugging code it is
  1708 000006E9 EB1B                    		jmp	short gotchr		; to far for conditional jump
  1709                                  nochr:
  1710 000006EB 803E[C401]00            		cmp	byte [fHaveK09], 0
  1711                                  		;jz	short CONBUSJ
  1712 000006F0 742D                    		jz	short CONBUS
  1713 000006F2 C51E[B800]              		lds	bx,[PTRSAV]		; get pointer to request header
  1714 000006F6 F747030004              		test	word [bx+STATUS],0400h	; System WAIT enabled?
  1715                                  		;jz	short CONBUSJ 		; no, get out
  1716 000006FB 7422                    		jz	short CONBUS
  1717                                  
  1718 000006FD B80041                  		mov	AX, 4100h     		; set command for Wait on External
  1719                                  				      		; event and condition type to
  1720                                  				      		; any external event
  1721 00000700 30DB                    		xor	BL,BL			; no timeout value
  1722 00000702 CD15                    		int	15h	      		; call rom-bios sleep function
  1723 00000704 EB19                    		jmp	short CONBUS		; after wait exit to con busy
  1724                                  
  1725                                  gotchr:
  1726 00000706 09C0                    		or	AX, AX			; check for null after break
  1727 00000708 7504                    		JNZ	short NOTBRK		; no, skip down
  1728                                  		;mov	ah, 0
  1729                                  ; note: AH is already zero, no need to set command
  1730 0000070A CD16                    		int	16h			; yes, read the null
  1731 0000070C EBCE                    		Jmp	short CON$RDND		; and get a real status
  1732                                  
  1733                                  NOTBRK:
  1734 0000070E 3D0072                  		cmp	AX, 7200H		; check for ctrl-prtsc
  1735 00000711 7502                    		jnz	short RDEXIT		; no
  1736 00000713 B010                    		mov	AL, 16			; yes, indicate ctrl-prtsc
  1737                                  
  1738                                  RDEXIT:
  1739 00000715 C51E[B800]              		lds	BX, [PTRSAV]		; get pointer to request header
  1740 00000719 88470D                  		mov	[BX+MEDIA], AL		; move character into req. header
  1741                                  EXVEC:
  1742 0000071C E969FF                  		jmp	EXIT			; all done -- successful return
  1743                                  CONBUS:
  1744 0000071F E94BFF                  		Jmp	BUS$EXIT		; done -- con device is busy
  1745                                  
  1746                                  ;----------------------------------------------------------------
  1747                                  ;								:
  1748                                  ;		Keyboard flush routine				:
  1749                                  ;								:
  1750                                  ;----------------------------------------------------------------
  1751                                  
  1752                                  CON$FLSH:
  1753 00000722 E80300                  		call	FLUSH
  1754 00000725 E960FF                  		jmp	EXIT
  1755                                  
  1756                                  FLUSH:
  1757 00000728 C606[D005]00            		mov	byte [ALTAH], 0	; clear out holding buffer
  1758                                  
  1759                                  FlLoop:
  1760                                  				 	; Is there a char there?
  1761 0000072D B401                    		mov	AH, 1	 	; command code for check status
  1762 0000072F CD16                    		int	16h	 	; call rom-bios keyboard routine
  1763                                  					; if z flag is set then no character
  1764 00000731 7406                    		jz	short FlDone	; is ready, buffer is empty -- get out
  1765 00000733 30E4                    		xor	AH, AH	 	; if zf is nof set, get character
  1766 00000735 CD16                    		int	16h	 	; call rom-bios to get character
  1767 00000737 EBF4                    		jmp	short FlLoop	; repeat until buffer is empty
  1768                                  FlDone:
  1769 00000739 C3                      		retn
  1770                                  
  1771                                  ;----------------------------------------------------------------
  1772                                  ;								:
  1773                                  ;	       Console Write Routine				:
  1774                                  ;								:
  1775                                  ;----------------------------------------------------------------
  1776                                  	
  1777                                  CON$WRIT:
  1778 0000073A E3E0                    		jcxz	EXVEC			; if CX is zero, get out
  1779                                  CON$LP:
  1780                                  		; 13/06/2018 - Retro DOS v3.0 (IBMDOS 3.3, IBMBIO.COM)
  1781 0000073C 268A05                  		mov	AL,[ES:DI]		; get character
  1782 0000073F 47                      		inc	DI			; point to next character
  1783 00000740 CD29                    		int	CHROUT			; Output character
  1784 00000742 E2F8                    		loop	CON$LP			; repeat until all through
  1785 00000744 E941FF                  		jmp	EXIT
  1786                                  
  1787                                  ;-----------------------------------------------
  1788                                  ;
  1789                                  ;	BREAK KEY HANDLING
  1790                                  ;
  1791                                  
  1792                                  CBREAK:
  1793 00000747 2EC606[D005]03          		mov	byte [CS:ALTAH], 3	; indicate break key set
  1794                                  
  1795                                  INTRET:
  1796 0000074D CF                      		IRET
  1797                                  
  1798                                  ;-----------------------------------------------------------------------------
  1799                                  ; MSAUX.ASM - MSDOS 3.3 - 24/07/1987
  1800                                  ;-----------------------------------------------------------------------------
  1801                                  ; 23/03/2018 - Retro DOS v2.0
  1802                                  
  1803                                  ;----------------------------------------------------------------
  1804                                  ;								:
  1805                                  ;	     A U X - AUXILARY DEVICE DRIVER			:
  1806                                  ;								:
  1807                                  ;								:
  1808                                  ;   This file contains the Auxilary Device Driver.  The 	:
  1809                                  ; auxilary driver handles calls to and from the RS-232 port.	:
  1810                                  ; Three devices uses this code: AUX, COM1, and COM2.  AUX and	:
  1811                                  ; COM1 talk to the zero RS-232 card and COM2 talks to the	:
  1812                                  ; 'one' RS-232 card.  The beginning of the interrupt entry      :
  1813                                  ; point for these devices sets the variable AUXNUM in the	:
  1814                                  ; msbio.asm module.  If the value is 0 the routines in this	:
  1815                                  ; file will talk to the the 'zero' card.  If the value in       :
  1816                                  ; AUXNUM is 1 the routines will talk to the 'one' card.         :
  1817                                  ; The procedure GETDX is called to put the value 0 or 1 in	:
  1818                                  ; the DX register depending on the value in AUXBUF.		:
  1819                                  ;								:
  1820                                  ;   The routines in this files are:				:
  1821                                  ;								:
  1822                                  ;	routine 		function			:
  1823                                  ;	------- 		--------			:
  1824                                  ;	AUX$READ		Read characters from the	:
  1825                                  ;				  specified device.		:
  1826                                  ;	AUX$RDND		Non-desrucrtive read with	:
  1827                                  ;				  no waiting.			:
  1828                                  ;	AUX$FLSH		Flush specified device input	:
  1829                                  ;				  buffer.			:
  1830                                  ;	AUX$WRIT		Write characters to the 	:
  1831                                  ;				  specified device.		:
  1832                                  ;	AUX$WRST		Get status of specified 	:
  1833                                  ;				  device			:
  1834                                  ;								:
  1835                                  ;  These routines are not called directly.  Call are made via	:
  1836                                  ; the strategy and interrupt entry point (see Device Header).	:
  1837                                  ;								:
  1838                                  ;  Data structure:						:
  1839                                  ;    The Aux Device has a two byte buffer called AUXBUF.  The	:
  1840                                  ;  first byte is for the zero card, the second byte is for the	:
  1841                                  ;  one card.  A zero value in the byte indicates the buffer is	:
  1842                                  ;  empty.  The routines use GETBX to get the address of the	:
  1843                                  ;  buffer.							:
  1844                                  ;								:
  1845                                  ;----------------------------------------------------------------
  1846                                  
  1847                                  ;		VALUES IN AH, REQUESTING FUNCTION OF INT 14H IN ROM BIOS
  1848                                  AUXFUNC_SEND	 EQU	1	;TRANSMIT
  1849                                  AUXFUNC_RECEIVE  EQU	2	;READ
  1850                                  AUXFUNC_STATUS	 EQU	3	;REQUEST STATUS
  1851                                  
  1852                                  ;		ERROR FLAGS, REPORTED BY INT 14H
  1853                                  
  1854                                  ;	 THESE FLAGS REPORTED IN AH:
  1855                                  FLAG_DATA_READY  EQU	01H	;DATA READY
  1856                                  FLAG_OVERRUN	 EQU	02H	;OVERRUN ERROR
  1857                                  FLAG_PARITY	 EQU	04H	;PARITY ERROR
  1858                                  FLAG_FRAME	 EQU	08H	;FRAMING ERROR
  1859                                  FLAG_BREAK	 EQU	10H	;BREAK DETECT
  1860                                  FLAG_TRANHOL_EMP EQU	20H	;TRANSMIT HOLDING REGISTER EMPTY
  1861                                  FLAG_TRANSHF_EMP EQU	40H	;TRANSMIT SHIFT REGISTER EMPTY
  1862                                  FLAG_TIMEOUT	 EQU	80H	;TIMEOUT
  1863                                  
  1864                                  ;	THESE FLAGS REPORTED IN AL:
  1865                                  FLAG_DELTA_CTS	 EQU	01H	;DELTA CLEAR TO SEND
  1866                                  FLAG_DELTA_DSR	 EQU	02H	;DELTA DATA SET READY
  1867                                  FLAG_TRAIL_RING  EQU	04H	;TRAILING EDGE RING INDICATOR
  1868                                  FLAG_DELTA_SIG	 EQU	08H	;DELTA RECEIVE LINE SIGNAL DETECT
  1869                                  FLAG_CTS	 EQU	10H	;CLEAR TO SEND
  1870                                  FLAG_DSR	 EQU	20H	;DATA SET READY
  1871                                  FLAG_RING	 EQU	40H	;RING INDICATOR
  1872                                  FLAG_REC_SIG	 EQU	80H	;RECEIVE LINE SIGNAL DETECT
  1873                                  
  1874                                  ;------------------------------------------------------------------
  1875                                  ;								  :
  1876                                  ;	Read zero or more characters from Auxilary Device	  :
  1877                                  ;								  :
  1878                                  ;	input:es:[di] points to area to receive aux data	  :
  1879                                  ;	      cx has number of bytes to be read 		  :
  1880                                  ;	      "auxnum" first byte has number of aux device (rel 0):
  1881                                  ;								  :
  1882                                  ;------------------------------------------------------------------
  1883                                  
  1884                                  AUX$READ:
  1885 0000074E E311                    		jcxz	EXVEC2		; if no characters, get out
  1886 00000750 E87E00                  		call	GETBX		; put address of AUXBUF in BX
  1887 00000753 31C0                    		xor	AX,AX		; clear AX register
  1888 00000755 8607                    		xchg	AL,[BX] 	; Get character , if any, from
  1889                                  					;   buffer and clear buffer
  1890 00000757 08C0                    		or	AL,AL		; if AL is nonzero there was a
  1891                                  					;   character in the buffer
  1892 00000759 7503                    		jnz	short AUX2	; if so skip AUXIN call
  1893                                  AUX1:					;
  1894 0000075B E80600                  		call	AUXIN		; get character from port
  1895                                  AUX2:					;
  1896 0000075E AA                      		stosb			; store character
  1897 0000075F E2FA                    		loop	AUX1		; if more character, go around again
  1898                                  EXVEC2: 				;
  1899 00000761 E924FF                  		jmp	EXIT		; all done, successful exit
  1900                                  
  1901                                  ;
  1902                                  ; AUXIN: make a call on ROM BIOS to read character from
  1903                                  ;	 the auxilary device, then do some error checking.
  1904                                  ;	 If an error occurs then AUXIN jumps to ERR$CNT and
  1905                                  ;	 does NOT return to where it was called from.
  1906                                  ;
  1907                                  
  1908                                  AUXIN:
  1909 00000764 B402                    		mov	ah,AUXFUNC_RECEIVE
  1910 00000766 E83F00                  		call	AUXOP
  1911                                  		 			;check for Frame, Parity, or Overrun errors
  1912                                  		 			;WARNING: these error bits are unpredictable 
  1913                                  		 			;         if timeout (bit 7) is set
  1914 00000769 F6C40E                  		test	ah,FLAG_FRAME|FLAG_PARITY|FLAG_OVERRUN
  1915 0000076C 7406                    		jz	short AROK	;No error if all bits are clear
  1916                                  
  1917                                  		; 26/05/2018
  1918                                  		;Error getting character
  1919                                  		;add	sp,2		;Remove rtn address (near call)
  1920                                  		;xor	al,al
  1921                                  		;or	al,FLAG_REC_SIG | FLAG_DSR | FLAG_CTS
  1922                                  
  1923                                  		; 13/06/2018 (IBMDOS 3.3, IBMBIO.COM)
  1924 0000076E 58                      		pop	ax
  1925 0000076F B0B0                    		mov	al,FLAG_REC_SIG+FLAG_DSR+FLAG_CTS 
  1926                                  
  1927 00000771 E9FFFE                  		jmp	ERR$CNT
  1928                                  AROK:
  1929 00000774 C3                      		RETN			;CHAR JUST READ IS IN AL, STATUS IS IN AH
  1930                                  
  1931                                  ;----------------------------------------------------------------
  1932                                  ;								:
  1933                                  ;	Aux non-destructive read with no waiting		:
  1934                                  ;								:
  1935                                  ;	input: es:[di] points to area to receive aux data	:
  1936                                  ;								:
  1937                                  ;----------------------------------------------------------------
  1938                                  ;
  1939                                  
  1940                                  AUX$RDND:
  1941 00000775 E85900                  		call	GETBX		; have BX point to AUXBUF
  1942 00000778 8A07                    		mov	AL,[BX] 	; copy contents of buffer to AL
  1943 0000077A 08C0                    		or	AL,AL		; if AL is non-zero (char in buffer)
  1944 0000077C 7514                    		jnz	short AUXRDX	;   then return character
  1945 0000077E E82500                  		call	AUXSTAT 	;   if not, get status of AUX device
  1946 00000781 F6C401                  		TEST	AH,FLAG_DATA_READY ;TEST DATA READY
  1947 00000784 740E                    		jz	short AUXBUS	;   then device is busy (not ready)
  1948                                  
  1949 00000786 A820                    		TEST	AL,FLAG_DSR	;TEST DATA SET READY
  1950 00000788 740A                    		jz	short AUXBUS	;   then device is busy (not ready)
  1951 0000078A E8D7FF                  		call	AUXIN		;   else aux is ready, get character
  1952 0000078D E84100                  		call	GETBX		; have bx point to AUXBUF
  1953 00000790 8807                    		mov	[BX],AL 	; save character in buffer
  1954                                  AUXRDX: 				;
  1955 00000792 EB81                    		jmp	RDEXIT		; return character
  1956                                  
  1957                                  AUXBUS: 				;
  1958 00000794 E9D6FE                  		Jmp	BUS$EXIT	; jump to device busy exit
  1959                                  
  1960                                  ;----------------------------------------------------------------
  1961                                  ;								:
  1962                                  ;		Aux Output Status				:
  1963                                  ;								:
  1964                                  ;----------------------------------------------------------------
  1965                                  
  1966                                  AUX$WRST:
  1967 00000797 E80C00                  		call	AUXSTAT 	; get status of AUX in AX
  1968                                  					; now test to see if device is busy
  1969                                  					; if this bit is not set,
  1970 0000079A A820                    		TEST	AL,FLAG_DSR	;TEST DATA SET READY
  1971 0000079C 74F6                    		jz	short AUXBUS	;   then device is busy (not ready)
  1972 0000079E F6C420                  		TEST	AH,FLAG_TRANHOL_EMP ;TEST TRANSMIT HOLD REG EMPTY
  1973 000007A1 74F1                    		jz	short AUXBUS	;   then device is busy (not ready)
  1974 000007A3 E9E2FE                  		jmp	EXIT
  1975                                  
  1976                                  ;
  1977                                  ; AUXSTAT makes a call on the ROM-BIOS to determine the status
  1978                                  ;	  of the auxilary device
  1979                                  ;	  Outputs:
  1980                                  ;		AX is filled with status of port.
  1981                                  ;		DX is changes to specify which card - either 0, 1 (, 2, 3) ;ba
  1982                                  ;		NO other registers are modified
  1983                                  ;
  1984                                  
  1985                                  AUXSTAT:
  1986 000007A6 B403                    		mov	ah,AUXFUNC_STATUS
  1987                                  		;call	AUXOP
  1988                                  		;retn
  1989                                  AUXOP:					;AH=FUNCTION CODE
  1990                                  					;0=INIT, 1=SEND, 2=RECEIVE, 3=STATUS
  1991 000007A8 E801FF                  		call	GETDX		; have DX point to proper card
  1992 000007AB CD14                    		int	14h		; call rom-bios for status
  1993 000007AD C3                      		retn
  1994                                  
  1995                                  ;----------------------------------------------------------------
  1996                                  ;								:
  1997                                  ;  Flush AUX Input buffer - set contents of AUXBUF to zero	:
  1998                                  ;								:
  1999                                  ;----------------------------------------------------------------
  2000                                  
  2001                                  AUX$FLSH:
  2002 000007AE E82000                  		call	GETBX		; get BX to point to AUXBUF
  2003 000007B1 C60700                  		mov	byte [BX],0	; zero out buffer
  2004 000007B4 E9D1FE                  		jmp	EXIT		; all done, successful return
  2005                                  	
  2006                                  ;----------------------------------------------------------------
  2007                                  ;								:
  2008                                  ;		Write to Auxilary Device			:
  2009                                  ;								:
  2010                                  ;----------------------------------------------------------------
  2011                                  
  2012                                  AUX$WRIT:
  2013 000007B7 E3A8                    		jcxz	EXVEC2		; if CX is zero, no characters
  2014                                  				;   to be written, jump to exit
  2015                                  AUX$LOOP:
  2016 000007B9 268A05                  		mov	AL,[ES:DI]	; get character to be written
  2017 000007BC 47                      		inc	DI		; move DI pointer to next character
  2018 000007BD B401                    		MOV	AH,AUXFUNC_SEND ;VALUE=1, INDICATES A WRITE
  2019 000007BF E8E6FF                  		CALL	AUXOP		;SEND CHARACTER OVER AUX PORT
  2020                                  
  2021 000007C2 F6C480                  		TEST	AH,FLAG_TIMEOUT ;CHECK FOR ERROR
  2022 000007C5 7405                    		jz	short AWOK	;   then no error
  2023 000007C7 B00A                    		mov	AL,10		;   else indicate write fault
  2024 000007C9 E9A7FE                  		jmp	ERR$CNT 	; call error routines
  2025                                  
  2026                                  					; if CX is non-zero, still more
  2027                                  AWOK:
  2028 000007CC E2EB                    		loop	AUX$LOOP	; more characrter to print
  2029 000007CE E9B7FE                  		jmp	EXIT		; all done, successful return
  2030                                  
  2031                                  ;
  2032                                  ;  GETBX puts the address of AUXBUF (the Auxilary Device buffer)
  2033                                  ;	 in BX.  After calling GETBX, a routine can get to AUXBUF
  2034                                  ;	 with [BX].
  2035                                  ;
  2036                                  ;  NOTE: The getdx routine is in msbio1 and looks like:
  2037                                  ;	mov	dx,word ptr cs:[auxnum]
  2038                                  ;
  2039                                  
  2040                                  GETBX:
  2041 000007D1 E8D8FE                  		call	GETDX
  2042 000007D4 89D3                    		mov	BX,DX
  2043 000007D6 81C3[BC00]              		add	BX,AUXBUF
  2044 000007DA C3                      		retn
  2045                                  
  2046                                  ;-----------------------------------------------------------------------------
  2047                                  ; MSLPT.ASM - MSDOS 3.3 - 24/07/1987
  2048                                  ;-----------------------------------------------------------------------------
  2049                                  ; 23/03/2018 - Retro DOS v2.0
  2050                                  
  2051                                  ;----------------------------------------------------------------
  2052                                  ;								:
  2053                                  ;	P R N - PRINTER DEVICE					:
  2054                                  ;								:
  2055                                  ;								:
  2056                                  ;   This file contains the Printer Device Driver.  The		:
  2057                                  ; printer driver handles calls to the printers.  Four devices	:
  2058                                  ; use this code: PRN, LPT1, LPT2, and LPT3.  The beginning	:
  2059                                  ; of the interrupt entry point for these device sets the	:
  2060                                  ; variable AUXNUM in the msbio.asm module.  The number is	:
  2061                                  ; in AUXNUM dictates which device will to written to: 0 for	:
  2062                                  ; PRN and LPT1, 1 for LPT2, and 2 for LPT3.			:
  2063                                  ;								:
  2064                                  ;   The routines in this files are:				:
  2065                                  ;								:
  2066                                  ;	routine 		function			:
  2067                                  ;	------- 		--------			:
  2068                                  ;	PRN$WRIT		Write to printer device 	:
  2069                                  ;	PRN$STAT		Printer status routine		:
  2070                                  ;	PRN$TilBusy		Print spooler routine		:
  2071                                  ;	Prn$GenIOCTL		Generic IOCTL routine		:
  2072                                  ;								:
  2073                                  ;  These routines are not called directly.  Call are made via	:
  2074                                  ; the strategy and interrupt entry point (see Device Header).	:
  2075                                  ;								:
  2076                                  ;----------------------------------------------------------------
  2077                                  
  2078                                  ; IBM ROM STATUS BITS (I DON'T TRUST THEM, NEITHER SHOULD YOU)             
  2079                                  									   
  2080                                  NOTBUSYSTATUS	equ 10000000b		; NOT BUSY			   
  2081                                  ACKSTATUS	equ 01000000b		; ACKNOWLEDGE (FOR WHAT?)	   
  2082                                  NOPAPERSTATUS	equ 00100000b		; NO MORE PAPER 		   
  2083                                  SELECTEDSTATUS	equ 00010000b		; THE PRINTER SAID IT WAS SELECTED 
  2084                                  IOERRSTATUS	equ 00001000b		; SOME KINDA ERROR		   
  2085                                  RESERVED	equ 00000110b		; NOPS				   
  2086                                  TIMEOUTSTATUS	equ 00000001b		; TIME OUT.			   
  2087                                  									   
  2088                                  									   
  2089                                  ; WARNING!!! THE IBM ROM DOES NOT RETURN JUST ONE BIT. IT RETURNS A	   
  2090                                  ; WHOLE SLEW OF BITS, ONLY ONE OF WHICH IS CORRECT.			   
  2091                                  									   
  2092                                  ;----------------------------------------------------------------
  2093                                  ;								:
  2094                                  ;		WRITE TO PRINTER DEVICE 			:
  2095                                  ;								:
  2096                                  ;   CX has count of bytes to be printed 			:
  2097                                  ;   ES:DI point to source buffer contains characters		:
  2098                                  ;   AuxNum (in msbio.asm) has printer number			:
  2099                                  ;								:
  2100                                  ;----------------------------------------------------------------
  2101                                  						   
  2102                                  PRN$WRIT:
  2103 000007DB E310                    		jcxz	EXVEC3			; no chars to output, Get out
  2104                                  PRN$LOOP:
  2105 000007DD BB0200                  		mov	BX,2			; Initialize retry flag
  2106                                  PRN$out:
  2107 000007E0 268A05                  		mov	AL,[ES:DI]		; Get a character into AL
  2108 000007E3 47                      		inc	DI			; Point to next character
  2109 000007E4 30E4                    		XOR	AH,AH			; AH=0 => OUTPUT CHAR IN DL	   
  2110 000007E6 E82400                  		call	PRNOP			; print character
  2111 000007E9 7505                    		jnz	short PrRetry 		; if error, try to print again
  2112 000007EB E2F0                    		loop	PRN$LOOP		; if more character, keep printing
  2113                                  EXVEC3:
  2114 000007ED E998FE                  		jmp	EXIT
  2115                                  
  2116                                  PrRetry:
  2117 000007F0 4F                      		dec	DI			; undo the inc above...
  2118 000007F1 4B                      		dec	BX			; Decrement retry count
  2119 000007F2 75EC                    		jnz	short PRN$out 		; See if done with retrys
  2120                                  PMESSG:
  2121 000007F4 E97CFE                  		JMP	ERR$CNT 		; if so return with the error
  2122                                  
  2123                                  ;----------------------------------------------------------------
  2124                                  ;								:
  2125                                  ;		PRINTER STATUS ROUTINE				:
  2126                                  ;								:
  2127                                  ;----------------------------------------------------------------
  2128                                  ;
  2129                                  						   
  2130                                  PRN$STAT:
  2131 000007F7 E81100                  		call	PRNSTAT 		; get the status
  2132 000007FA 75F8                    		jnz	short PMESSG		; if error jump to error routine
  2133 000007FC B009                    		MOV	AL,9			; AGAIN, ASSUME OUT OF PAPER...    
  2134 000007FE F6C420                  		TEST	AH,NOPAPERSTATUS					   
  2135 00000801 75F1                    		JNZ	short PMESSG
  2136 00000803 F6C480                  		TEST	AH,NOTBUSYSTATUS					   
  2137 00000806 75E5                    		jnz	short EXVEC3		; if not busy return via EXVEC3
  2138 00000808 E962FE                  		JMP	BUS$EXIT		; else busy, return to busy exit   
  2139                                  
  2140                                  ;
  2141                                  ;   PRNSTAT	get printer status
  2142                                  ;   PRNOP	print a character
  2143                                  ;
  2144                                  ; PRNSTAT and PRNOP are two routines which call on the ROM-BIOS
  2145                                  ; printer routines.  The routines share code which calls on the bios and
  2146                                  ; then determines which, if any, error occured. PRNSTAT and PRNOP differ
  2147                                  ; only by the value put into AH before the ROM-BIOS call.
  2148                                  ;
  2149                                  ;   INPUT	if PRNOP then character in AL
  2150                                  ;
  2151                                  ;   OUTPUT	- AL holds error code
  2152                                  ;		- AH status byte from printer
  2153                                  ;		- flag NZ if error
  2154                                  
  2155                                  PRNSTAT:						   
  2156 0000080B B402                    		mov	AH,2			; set command for get status   *
  2157                                  PRNOP:
  2158 0000080D E89CFE                  		call	GETDX			; determine which printer      *
  2159 00000810 CD17                    		int	17h			; call ROM-BIOS printer routine  *
  2160                                  
  2161 00000812 F6C408                  		TEST	AH,IOERRSTATUS		; I/O ERROR?			   
  2162 00000815 740A                    		JZ	short CHECKNOTREADY	; NO, TRY NOT READY		   
  2163                                  									   
  2164                                  ; AT THIS POINT, WE KNOW WE HAVE AN ERROR. THE CONVERSE IS NOT TRUE.	   
  2165                                  									   
  2166 00000817 B009                    		MOV	AL,9			; FIRST, ASSUME OUT OF PAPER	   
  2167 00000819 F6C420                  		TEST	AH,NOPAPERSTATUS	; OUT OF PAPER SET?		   
  2168 0000081C 7502                    		JNZ	short RET1			; YES, ERROR IS SET
  2169 0000081E FEC0                    		INC	AL			; INDICATE I/O ERROR		   
  2170                                  RET1:									   
  2171                                  									   
  2172                                  ; WE HAVE TRIAGED NOW FOR OUT OF PAPER AND IO ERR (IGNORING TIME-OUT)	   
  2173                                  									   
  2174 00000820 C3                      		RETN				; RETURN WITH ERROR		   
  2175                                  									   
  2176                                  ; THE BITS SAID NO ERROR.  UNFORTUNATELY, THERE MAY BE OTHER THINGS AT WOR  K
  2177                                  ; HERE. 								   
  2178                                  									   
  2179                                  CHECKNOTREADY:								   
  2180 00000821 B002                    		MOV	AL,2			; ASSUME NOT-READY		   
  2181 00000823 F6C401                  		TEST	AH,TIMEOUTSTATUS	; IS TIME-OUT SET?		   
  2182                                  						; IF NZ THEN ERROR, ELSE OK???	   
  2183                                  PRNOP2: 								   
  2184 00000826 C3                      		RETN
  2185                                  
  2186                                  ;26/05/2018
  2187                                  
  2188                                  ;----------------------------------------------------------------
  2189                                  ;								:
  2190                                  ;		Output until Busy				:
  2191                                  ;								:
  2192                                  ; Output until busy.  This entry point is used EXCLUSIVELY by	:
  2193                                  ; the print spoolers.  Under no curcumstances should the device :
  2194                                  ; driver block waiting for the device to become ready.		:
  2195                                  ;								:
  2196                                  ;   Inputs:	CX has count of bytes to output.		:
  2197                                  ;		ES:DI points to source buffer			:
  2198                                  ;   Outputs:	Set the number of bytes transferred		:
  2199                                  ;		  appropriately.				:
  2200                                  ;								:
  2201                                  ;----------------------------------------------------------------
  2202                                  
  2203                                  PRN$TILBUSY:
  2204 00000827 1E                      	push	DS			; save DS
  2205 00000828 06                      	push	ES			; copy ES to DS
  2206 00000829 1F                      	pop	DS
  2207 0000082A 89FE                    	mov	SI,DI			; everything is set for LODSB
  2208                                  PRN$TilBLoop:
  2209 0000082C 51                      	push	CX
  2210 0000082D 53                      	push	BX
  2211 0000082E 31DB                    	xor	BX,BX
  2212 00000830 2E8A1E[D105]            	mov	BL,[CS:PRINTDEV]
  2213 00000835 D1E3                    	shl	BX,1
  2214 00000837 2E8B8F[D205]            	mov	CX,[CS:BX+WAIT_COUNT]	; wait COUNT times to come ready
  2215 0000083C 5B                      	pop	BX
  2216                                  PRN$GetStat:
  2217 0000083D E8CBFF                  	call	PRNSTAT 		; get status
  2218 00000840 751E                    	jnz	short PRN$BPERR		; if error jump to error routine
  2219 00000842 F6C480                  	TEST	AH,10000000B		; READY YET?
  2220 00000845 E1F6                    	loopz	PRN$GetStat		; if busy keep trying
  2221 00000847 59                      	pop	CX			; get original count
  2222 00000848 7417                    	jz	short PRN$BErr		; still not ready => done
  2223 0000084A AC                      	lodsb
  2224 0000084B 30E4                    	XOR	AH,AH
  2225 0000084D E8BDFF                  	call	PRNOP			; print the character
  2226 00000850 750F                    	jnz	short PRN$BErr		; error
  2227 00000852 E2D8                    	loop	PRN$TilBLoop		; go for more
  2228                                  PRN$B:
  2229 00000854 1F                      	pop	DS			; recover DS
  2230 00000855 2EC51E[B800]            	lds	BX,[CS:PTRSAV]		; get pointer to header
  2231                                  
  2232 0000085A 294F12                  	sub	[BX+COUNT],CX		; Determine number of succ. I/O's
  2233 0000085D E928FE                  	jmp	EXIT			; all done, successful return
  2234                                  
  2235                                  PRN$BPERR:
  2236 00000860 59                      	pop	CX			; recover number of char left
  2237                                  PRN$BErr:
  2238 00000861 1F                      	pop	DS			; get pointer to header
  2239 00000862 2EC51E[B800]            	lds	BX,[CS:PTRSAV]
  2240 00000867 294F12                  	sub	[BX+COUNT],CX		; Determine number of succ. I/O's
  2241 0000086A E90EFE                  	jmp	ERR$EXIT		; jump to error exit
  2242                                  
  2243                                  ;
  2244                                  ; Prn$GenIOCTL:
  2245                                  ;
  2246                                  ; Manipulates the value in WAIT_COUNT depending on the value passed in the
  2247                                  ; Generic IOCTL packet.
  2248                                  ; It either sets or returns the current value for the retry count for the
  2249                                  ; device.
  2250                                  ;
  2251                                  
  2252                                  PRN$GENIOCTL:
  2253                                  
  2254 0000086D C43E[B800]              	les	di,[PTRSAV]
  2255 00000871 26807D0D05              	cmp	byte [es:di+IOCTL_REQ.MAJORFUNCTION],IOC_PC
  2256 00000876 7403                    	je	short PrnFunc_OK
  2257                                  PrnFuncErr:
  2258 00000878 E9F6FD                  	jmp	CMDERR
  2259                                  
  2260                                  PrnFunc_OK:
  2261 0000087B 268A450E                	mov	al,[es:di+IOCTL_REQ.MINORFUNCTION]
  2262 0000087F 26C47D13                	les	di,[es:di+IOCTL_REQ.GENERICIOCTL_PACKET]
  2263 00000883 31DB                    	xor	bx,bx
  2264 00000885 8A1E[D105]              	mov	bl,[PRINTDEV]		; get index into retry counts
  2265 00000889 D1E3                    	shl	bx,1
  2266 0000088B 8B8F[D205]              	mov	CX,[BX+WAIT_COUNT]	; pull out retry count for device
  2267 0000088F 3C65                    	cmp	al,GET_RETRY_COUNT
  2268 00000891 7407                    	jz	short PrnGetCount
  2269 00000893 3C45                    	cmp	al,SET_RETRY_COUNT
  2270 00000895 75E1                    	jnz	short PrnFuncErr
  2271 00000897 268B0D                  	mov	cx,[es:di+A_RETRYCOUNT.RC_COUNT]  ; A_RETRYCOUNT.RC_COUNT = 0 
  2272                                  PrnGetCount:
  2273 0000089A 898F[D205]              	mov	[BX+WAIT_COUNT],CX	; place "new" retry count
  2274 0000089E 26890D                  	mov	[es:di+A_RETRYCOUNT.RC_COUNT],cx ; return current retry count
  2275 000008A1 E9E4FD                  	jmp	EXIT
  2276                                  
  2277                                  ;-----------------------------------------------------------------------------
  2278                                  ; MSCLOCK.ASM - MSDOS 3.3 - 24/07/1987
  2279                                  ;-----------------------------------------------------------------------------
  2280                                  ; 23/03/2018 - Retro DOS v2.0
  2281                                  
  2282                                  ;----------------------------------------				  
  2283                                  ;	CMOS EQUATES FOR THIS SYSTEM	:  ; 26/03/2018 - CMOSEQU.INC, 1987
  2284                                  ;-----------------------------------------------------------------------------
  2285                                  CMOS_PORT	EQU	070H		; I/O ADDRESS OF CMOS ADDRESS PORT	 
  2286                                  CMOS_DATA	EQU	071H		; I/O ADDRESS OF CMOS DATA PORT 	 
  2287                                  NMI		EQU	10000000B	; DISABLE NMI INTERRUPTS MASK - 	 
  2288                                  					;  HIGH BIT OF CMOS LOCATION ADDRESS
  2289                                  ;---------- CMOS TABLE LOCATION ADDRESS'S ## --------------------------------- 
  2290                                  CMOS_SECONDS	EQU	000H		; SECONDS				 
  2291                                  CMOS_SEC_ALARM	EQU	001H		; SECONDS ALARM  ## NOTE:  ALL LOCATIONS 
  2292                                  CMOS_MINUTES	EQU	002H		; MINUTES	      | IN THE CMOS AREA 
  2293                                  CMOS_MIN_ALARM	EQU	003H		; MINUTES ALARM       | ARE IBM USE ONLY 
  2294                                  CMOS_HOURS	EQU	004H		; HOURS 	      | AND  SUBJECT  TO 
  2295                                  CMOS_HR_ALARM	EQU	005H		; HOURS ALARM	      | CHANGE. ONLY THE 
  2296                                  CMOS_DAY_WEEK	EQU	006H		; DAY OF THE WEEK     | POST & BIOS CODE 
  2297                                  CMOS_DAY_MONTH	EQU	007H		; DAY OF THE MONTH    | SHOULD	DIRECTLY 
  2298                                  CMOS_MONTH	EQU	008H		; MONTH 	      | ACCESS LOCATIONS 
  2299                                  CMOS_YEAR	EQU	009H		; YEAR (TWO DIGITS)   | IN CMOS STORAGE. 
  2300                                  CMOS_REG_A	EQU	00AH		; STATUS REGISTER A   '----------------- 
  2301                                  CMOS_REG_B	EQU	00BH		; STATUS REGISTER B  ALARM		 
  2302                                  CMOS_REG_C	EQU	00CH		; STATUS REGISTER C  FLAGS		 
  2303                                  CMOS_REG_D	EQU	00DH		; STATUS REGISTER D  BATTERY		 
  2304                                  CMOS_DIAG	EQU	00EH		; POST DIAGNOSTIC STATUS RESULTS BYTE	 
  2305                                  CMOS_SHUT_DOWN	EQU	00FH		; SHUTDOWN STATUS COMMAND BYTE		 
  2306                                  CMOS_DISKETTE	EQU	010H		; DISKETTE DRIVE TYPE BYTE	      ;  
  2307                                  ;		EQU	011H		; - RESERVED			      ;C 
  2308                                  CMOS_DISK	EQU	012H		; FIXED DISK TYPE BYTE		      ;H 
  2309                                  ;		EQU	013H		; - RESERVED			      ;E 
  2310                                  CMOS_EQUIP	EQU	014H		; EQUIPMENT WORD LOW BYTE	      ;C 
  2311                                  CMOS_B_M_S_LO	EQU	015H		; BASE MEMORY SIZE - LOW BYTE (X1024) ;K 
  2312                                  CMOS_B_M_S_HI	EQU	016H		; BASE MEMORY SIZE - HIGH BYTE	      ;S 
  2313                                  CMOS_E_M_S_LO	EQU	017H		; EXPANSION MEMORY SIZE - LOW BYTE    ;U 
  2314                                  CMOS_E_M_S_HI	EQU	018H		; EXPANSION MEMORY SIZE - HIGH BYTE   ;M 
  2315                                  CMOS_DISK_1	EQU	019H		; FIXED DISK TYPE - DRIVE C EXTENSION ;E 
  2316                                  CMOS_DISK_2	EQU	01AH		; FIXED DISK TYPE - DRIVE D EXTENSION ;D 
  2317                                  ;		EQU	01BH		; - 1BH THROUGH 2DH - RESERVED	      ;  
  2318                                  CMOS_CKSUM_HI	EQU	02EH		; CMOS CHECKSUM - HIGH BYTE	      ;* 
  2319                                  CMOS_CKSUM_LO	EQU	02FH		; CMOS CHECKSUM - LOW BYTE	      ;* 
  2320                                  CMOS_U_M_S_LO	EQU	030H		; USABLE MEMORY ABOVE 1 MEG - LOW BYTE	 
  2321                                  CMOS_U_M_S_HI	EQU	031H		; USABLE MEMORY ABOVE 1 MEG - HIGH BYTE  
  2322                                  CMOS_CENTURY	EQU	032H		; DATE CENTURY BYTE (BCD)		 
  2323                                  CMOS_INFO128	EQU	033H		; 128KB INFORMATION STATUS FLAG BYTE	 
  2324                                  ;		EQU	034H		; - 34H THROUGH 3FH - RESERVED
  2325                                  
  2326                                  ;----------------------------------------------------------------
  2327                                  ;								:
  2328                                  ;		    CLOCK DEVICE DRIVER 			:
  2329                                  ;								:
  2330                                  ;								:
  2331                                  ;   This file contains the Clock Device Driver. 		:
  2332                                  ;								:
  2333                                  ;   The routines in this files are:				:
  2334                                  ;								:
  2335                                  ;	routine 		function			:
  2336                                  ;	------- 		--------			:
  2337                                  ;	TIM$WRIT		Set the current time		:
  2338                                  ;	TIM$READ		Read the current time		:
  2339                                  ;	Time_To_Ticks		Convert time to corresponding	:
  2340                                  ;				  number of clock ticks 	:
  2341                                  ;								:
  2342                                  ; The clock ticks at the rate of:				:
  2343                                  ;								:
  2344                                  ;	1193180/65536 ticks/second (about 18.2 ticks per second):
  2345                                  ; See each routine for information on the use.			:
  2346                                  ;								:
  2347                                  ;----------------------------------------------------------------
  2348                                  
  2349                                  ;
  2350                                  ; DAYCNT is the number of days since 1-1-80.
  2351                                  ; Each time the clock is read it is necessary to check if another day has
  2352                                  ; passed.  The ROM only returns the day rollover once so if it is missed
  2353                                  ; the time will be off by a day.
  2354                                  ;
  2355                                  
  2356                                  ;26/05/2018
  2357                                  
  2358                                  ; variables for real time clock setting
  2359                                  HaveCMOSClock:
  2360 000008A4 00                      		db	0	;set by MSINIT.
  2361                                  base_century:
  2362 000008A5 13                      		db	19
  2363                                  base_year:
  2364 000008A6 50                      		db	80
  2365                                  month_tab:
  2366 000008A7 1F1C1F1E1F1E1F1F1E-     		db	31,28,31,30,31,30,31,31,30,31,30,31
  2366 000008B0 1F1E1F             
  2367                                  
  2368                                  ; The following are indirect intra-segment call addresses. The
  2369                                  ;procedures are defined in MSINIT for relocation.  MSINIT will set these
  2370                                  ;address when the relocation is done.
  2371                                  	
  2372                                  BinToBCD:
  2373 000008B3 0000                    		dw	0	;should point to Bin_To_BCD proc in MSINIT
  2374                                  
  2375                                  DaycntToDay:
  2376 000008B5 0000                    		dw	0	;should point to Daycnt_to_day in MSINIT
  2377                                  
  2378                                  ;********************************************************************
  2379                                  ; Indirect call address of TIME_TO_TICKS procedure.
  2380                                  ;This will be used by the relocatable portable suspend/resume code.
  2381                                  
  2382                                  TimeToTicks:
  2383 000008B7 [1309]                  		dw	TIME_TO_TICKS
  2384                                  
  2385                                  ;--------------------------------------------------------------------
  2386                                  ;
  2387                                  ; Settime sets the current time
  2388                                  ;
  2389                                  ; On entry ES:[DI] has the current time:
  2390                                  ;
  2391                                  ;	number of days since 1-1-80	(WORD)
  2392                                  ;	minutes (0-59)			(BYTE)
  2393                                  ;	hours (0-23)			(BYTE)
  2394                                  ;	hundredths of seconds (0-99)	(BYTE)
  2395                                  ;	seconds (0-59)			(BYTE)
  2396                                  ;
  2397                                  ; Each number has been checked for the correct range.
  2398                                  ;
  2399                                  
  2400                                  TIM$WRIT:
  2401 000008B9 268B05                  		mov	AX,[ES:DI]
  2402 000008BC 50                      		push	AX		;DAYCNT. We need to set this at the very
  2403                                  					;  end to avoid tick windows.
  2404                                  		
  2405                                  		;11/06/2018
  2406                                  		;26/05/2018
  2407                                  
  2408                                  		;;Rev 3.30 Modification
  2409 000008BD 803E[A408]00            		cmp	byte [HaveCMOSClock], 0
  2410 000008C2 7426                    		je	short No_CMOS_1
  2411 000008C4 268A4503                		mov	al,[es:di+3]		;get binary hours
  2412 000008C8 FF16[B308]              		call	word [BinToBCD]		;convert to BCD
  2413 000008CC 88C5                    		mov	ch,al			;CH = BCD hours
  2414 000008CE 268A4502                		mov	al,[es:di+2]		;get binary minutes
  2415 000008D2 FF16[B308]              		call	word [BinToBCD]		;convert to BCD
  2416 000008D6 88C1                    		mov	cl,al			;CL = BCD minutes
  2417 000008D8 268A4505                		mov	al,[es:di+5]		;get binary seconds
  2418 000008DC FF16[B308]              		call	word [BinToBCD]		;convert to BCD
  2419 000008E0 88C6                    		mov	dh,al			;DH = BCD seconds
  2420 000008E2 B200                    		mov	dl,0			;DL = 0 (ST) or 1 (DST)
  2421 000008E4 FA                      		cli				;turn off timer
  2422 000008E5 B403                    		mov	ah,03h			;set RTC time
  2423 000008E7 CD1A                    		int	1Ah			;call rom bios clock routine
  2424 000008E9 FB                      		sti
  2425                                  		;;End of Modification
  2426                                  No_CMOS_1:
  2427 000008EA 268B4D02                		mov	CX,[ES:DI+2]
  2428 000008EE 268B5504                		mov	DX,[ES:DI+4]
  2429                                  		;;Rev 3.30 Modification
  2430 000008F2 E81E00                  		call	TIME_TO_TICKS		; convert time to ticks
  2431                                  						;CX:DX now has time in ticks
  2432 000008F5 FA                      		cli				; Turn off timer
  2433 000008F6 B401                    		mov	AH, 1			; command is set time in clock
  2434 000008F8 CD1A                    		int	1Ah			; call rom-bios clock routines
  2435 000008FA 8F06[DA05]              		pop	word [DAYCNT]
  2436 000008FE FB                      		sti
  2437                                  		;CMOS clock -------------------------------------
  2438 000008FF 803E[A408]00            		cmp	byte [HaveCMOSClock], 0
  2439 00000904 740A                    		je	short No_CMOS_2
  2440                                  		; 13/06/2018
  2441 00000906 FF16[B508]              		call	word [DaycntToDay]	; convert to BCD format
  2442 0000090A FA                      		cli				; Turn off timer
  2443 0000090B B405                    		mov	AH,05h			; set RTC date
  2444 0000090D CD1A                    		int	1Ah			; call rom-bios clock routines
  2445 0000090F FB                      		sti
  2446                                  		;------------------------------------------------
  2447                                  No_CMOS_2:
  2448 00000910 E975FD                  		jmp	EXIT
  2449                                  		;;End of Modification
  2450                                  
  2451                                  ;
  2452                                  ; convert time to ticks
  2453                                  ; input : time in CX and DX
  2454                                  ; ticks returned in CX:DX
  2455                                  ;
  2456                                  
  2457                                  TIME_TO_TICKS:
  2458                                  		; first convert from Hour,min,sec,hund. to
  2459                                  		; total number of 100th of seconds
  2460 00000913 B03C                    		mov	AL,60
  2461 00000915 F6E5                    		mul	CH		;Hours to minutes
  2462 00000917 B500                    		mov	CH,0
  2463 00000919 01C8                    		add	AX,CX		;Total minutes
  2464 0000091B B97017                  		mov	CX,6000 	;60*100
  2465 0000091E 89D3                    		mov	BX,DX		;Get out of the way of the multiply
  2466 00000920 F7E1                    		mul	CX		;Convert to 1/100 sec
  2467 00000922 89C1                    		mov	CX,AX
  2468 00000924 B064                    		mov	AL,100
  2469 00000926 F6E7                    		mul	BH		;Convert seconds to 1/100 sec
  2470 00000928 01C1                    		add	CX,AX		;Combine seconds with hours and min.
  2471 0000092A 83D200                  		adc	DX,0		;Ripple carry
  2472 0000092D B700                    		mov	BH,0
  2473 0000092F 01D9                    		add	CX,BX		;Combine 1/100 sec
  2474 00000931 83D200                  		adc	DX,0
  2475                                  
  2476                                  		;;Rev 3.30 Modification
  2477                                  		;DX:CX IS TIME IN 1/100 SEC
  2478 00000934 92                      		XCHG	AX,DX
  2479 00000935 91                      		XCHG	AX,CX		;NOW TIME IS IN CX:AX
  2480 00000936 BB0BE9                  		MOV	BX,59659
  2481 00000939 F7E3                    		MUL	BX		;MULTIPLY LOW HALF
  2482 0000093B 87D1                    		XCHG	DX,CX
  2483 0000093D 92                      		XCHG	AX,DX		;CX->AX, AX->DX, DX->CX
  2484 0000093E F7E3                    		MUL	BX		;MULTIPLY HIGH HALF
  2485 00000940 01C8                    		ADD	AX,CX		;COMBINE OVERLAPPING PRODUCTS
  2486 00000942 83D200                  		ADC	DX,0
  2487 00000945 92                      		XCHG	AX,DX		;AX:DX=TIME*59659
  2488 00000946 BB0500                  		MOV	BX,5
  2489 00000949 F6F3                    		DIV	BL		;DIVIDE HIGH HALF BY 5
  2490 0000094B 88C1                    		MOV	CL,AL
  2491 0000094D B500                    		MOV	CH,0
  2492 0000094F 88E0                    		MOV	AL,AH		;REMAINDER OF DIVIDE-BY-5
  2493 00000951 98                      		CBW
  2494 00000952 92                      		XCHG	AX,DX		;USE IT TO EXTEND LOW HALF
  2495 00000953 F7F3                    		DIV	BX		;DIVIDE LOW HALF BY 5
  2496 00000955 89C2                    		MOV	DX,AX
  2497                                  			; CX:DX is now number of ticks in time
  2498 00000957 C3                      		retn
  2499                                  
  2500                                  ;
  2501                                  ; Gettime reads date and time
  2502                                  ; and returns the following information:
  2503                                  ;
  2504                                  ;	ES:[DI]  =count of days since 1-1-80
  2505                                  ;	ES:[DI+2]=hours
  2506                                  ;	ES:[DI+3]=minutes
  2507                                  ;	ES:[DI+4]=seconds
  2508                                  ;	ES:[DI+5]=hundredths of seconds
  2509                                  ;
  2510                                  
  2511                                  TIM$READ:				; read the clock
  2512 00000958 30E4                    		xor	AH, AH		; set command to read clock
  2513 0000095A CD1A                    		int	1Ah		; call rom-bios to get time
  2514                                  
  2515 0000095C 08C0                    		or	al,al		; check for a new day
  2516 0000095E 7404                    		jz	short noroll1 	; if al=0 then don't reset day count
  2517 00000960 FF06[DA05]              		INC	word [DAYCNT]	; CATCH ROLLOVE
  2518                                  noroll1:
  2519 00000964 8B36[DA05]              		MOV	SI,[DAYCNT]
  2520                                  
  2521                                  ;
  2522                                  ; we now need to convert the time in tick to the time in 100th of
  2523                                  ; seconds.  The relation between tick and seconds is:
  2524                                  ;
  2525                                  ;		 65536 seconds
  2526                                  ;	       ----------------
  2527                                  ;		1,193,180 tick
  2528                                  ;
  2529                                  ; To get to 100th of second we need to multiply by 100. The equation is:
  2530                                  ;
  2531                                  ;	Ticks from clock  * 65536 * 100
  2532                                  ;      ---------------------------------  = time in 100th of seconds
  2533                                  ;		1,193,180
  2534                                  ;
  2535                                  ; Fortunately this formula simplifies to:
  2536                                  ;
  2537                                  ;	Ticks from clock * 5 * 65,536
  2538                                  ;      --------------------------------- = time in 100th of seconds
  2539                                  ;		59,659
  2540                                  ;
  2541                                  ; The calculation is done by first multipling tick by 5. Next we divide by
  2542                                  ; 59,659.  In this division we multiply by 65,536 by shifting the dividend
  2543                                  ; my 16 bits to the left.
  2544                                  ;
  2545                                  ; start with ticks in CX:DX
  2546                                  ; multiply by 5
  2547 00000968 89C8                    		MOV	AX,CX
  2548 0000096A 89D3                    		MOV	BX,DX
  2549 0000096C D1E2                    		SHL	DX,1
  2550 0000096E D1D1                    		RCL	CX,1		;TIMES 2
  2551 00000970 D1E2                    		SHL	DX,1
  2552 00000972 D1D1                    		RCL	CX,1		;TIMES 4
  2553 00000974 01DA                    		ADD	DX,BX
  2554 00000976 11C8                    		ADC	AX,CX		;TIMES 5
  2555 00000978 92                      		XCHG	AX,DX		
  2556                                  	
  2557                                  
  2558                                  ; now have ticks * 5 in DX:AX
  2559                                  ; we now need to multiply by 65,536 and divide by 59659 d.
  2560                                  
  2561 00000979 B90BE9                  		mov	CX,59659	; get divisor
  2562 0000097C F7F1                    		div	CX
  2563                                  					; DX now has remainder
  2564                                  					; AX has high word of final quotient
  2565 0000097E 89C3                    		mov	BX,AX		; put high work if safe place
  2566 00000980 31C0                    		xor	AX,AX		; this is the multiply by 65536
  2567 00000982 F7F1                    		div	CX		; BX:AX now has time in 100th of seconds
  2568                                  
  2569                                  ;
  2570                                  ;Rounding based on the remainder may be added here
  2571                                  ;The result in BX:AX is time in 1/100 second.
  2572 00000984 89DA                    		mov	DX,BX
  2573 00000986 B9C800                  		mov	CX,200		;Extract 1/100's
  2574                                  ;Division by 200 is necessary to ensure no overflow--max result
  2575                                  ;is number of seconds in a day/2 = 43200.
  2576 00000989 F7F1                    		div	CX
  2577 0000098B 80FA64                  		cmp	DL,100		;Remainder over 100?
  2578 0000098E 7203                    		jb	short NOADJ
  2579 00000990 80EA64                  		sub	DL,100		;Keep 1/100's less than 100
  2580                                  NOADJ:
  2581 00000993 F5                      		cmc			;If we subtracted 100, carry is now set
  2582 00000994 88D3                    		mov	BL,DL		;Save 1/100's
  2583                                  ;To compensate for dividing by 200 instead of 100, we now multiply
  2584                                  ;by two, shifting a one in if the remainder had exceeded 100.
  2585 00000996 D1D0                    		rcl	AX,1
  2586 00000998 B200                    		mov	DL,0
  2587 0000099A D1D2                    		rcl	DX,1
  2588 0000099C B93C00                  		mov	CX,60		;Divide out seconds
  2589 0000099F F7F1                    		div	CX
  2590 000009A1 88D7                    		mov	BH,DL		;Save the seconds
  2591 000009A3 F6F1                    		div	CL		;Break into hours and minutes
  2592 000009A5 86C4                    		xchg	AL,AH
  2593                                  
  2594                                  ;Time is now in AX:BX (hours, minutes, seconds, 1/100 sec)
  2595                                  
  2596 000009A7 50                      		push	AX
  2597 000009A8 89F0                    		MOV	AX,SI		; DAYCNT
  2598 000009AA AB                      		stosw
  2599 000009AB 58                      		pop	AX
  2600 000009AC AB                      		stosw
  2601 000009AD 89D8                    		mov	AX,BX
  2602 000009AF AB                      		stosw
  2603 000009B0 E9D5FC                  		jmp	EXIT
  2604                                  
  2605                                  ;-----------------------------------------------------------------------------
  2606                                  ; MSDISK.ASM (1) - MSDOS 3.3 - 02/02/1988
  2607                                  ;-----------------------------------------------------------------------------
  2608                                  ; 26/05/2018 - Retro DOS v3.0
  2609                                  ; 23/03/2018 - Retro DOS v2.0
  2610                                  
  2611                                  ;------------------------------------------------------------------------
  2612                                  ;									:
  2613                                  ;	       DISK INTERFACE ROUTINES					:
  2614                                  ;									:
  2615                                  ;									:
  2616                                  ;   This file contains the Disk Device Driver.				:
  2617                                  ;									:
  2618                                  ;   The routines in this files are:					:
  2619                                  ;									:
  2620                                  ;	routine 		function				:
  2621                                  ;	------- 		--------				:
  2622                                  ;									:
  2623                                  ;	MEDIA$CHK		Determine if media in drive has changed :
  2624                                  ;									:
  2625                                  ;	GET$BPB 		Build a valid BPB for drive		:
  2626                                  ;									:
  2627                                  ;	DSK$REM 		Determine if disk has removable media	:
  2628                                  ;									:
  2629                                  ;	DSK$WRTV		Disk write with verify			:
  2630                                  ;									:
  2631                                  ;	DSK$WRT 		Disk write				:
  2632                                  ;									:
  2633                                  ;	DSK$READ		Read disk				:
  2634                                  ;									:
  2635                                  ;									:
  2636                                  ;  These routines are not called directly.  Call are made via		:
  2637                                  ; the strategy and interrupt entry point (see Device Header).		:
  2638                                  ;									:
  2639                                  ;  Data structures:							:
  2640                                  ;	There are two main types of data structures associated with	:
  2641                                  ;  the disk drives.  The first is the BDS.  BDS is the Bios Data	:
  2642                                  ;  structure.  There is one BDS for each logical drive in the system.	:
  2643                                  ;  All the BDS's are linked together in a list with the pointer to the  :
  2644                                  ;  first BDS being found in START_BDS.	The BDS hold various values	:
  2645                                  ;  important to the disk drive.  For example there is a field for last	:
  2646                                  ;  time accesses.  As actions take place in the system the BDS are	:
  2647                                  ;  update to reflect the actions.  For example if there is a read to	:
  2648                                  ;  a disk the last access field for the BDS for that drive is updated	:
  2649                                  ;  to the current time. 						:
  2650                                  ;	 The second data structure associated with disk drives is the	:
  2651                                  ;  BPB.  A BPB is a Bios Parameter Block.  The BPB contains information :
  2652                                  ;  about the media inside a disk drive.  Some on the fields in the BPB	:
  2653                                  ;  are Sectors per track, number of FATs, and number of tracks.  This	:
  2654                                  ;  information is used to tell where sectors are on the disk.  For	:
  2655                                  ;  example,  if we need to read logical sector 52:			:
  2656                                  ;									:
  2657                                  ;	Diskette			Track	Sector	Side		:
  2658                                  ;    single density							:
  2659                                  ;    eight sectors per track		  6	   5	  0		:
  2660                                  ;									:
  2661                                  ;    double density							:
  2662                                  ;    nine sectors per track		  2	   7	  1		:
  2663                                  ;									:
  2664                                  ;  The BPB for the media in the drive is stored in the BDS for the	:
  2665                                  ;  drive.  If the user changes the floppy in the drive a call is	:
  2666                                  ;  made to GET$BPB to build a new BPB in the BDS.  See this routine	:
  2667                                  ;  for the algorithm.							:
  2668                                  ;									:
  2669                                  ;									:
  2670                                  ;------------------------------------------------------------------------
  2671                                  
  2672                                  ;
  2673                                  ; Maximum number of retries in case of error
  2674                                  ;
  2675                                  
  2676                                  MAXERR	EQU 5
  2677                                  LSTDRV	EQU 0504h
  2678                                  
  2679                                  ;
  2680                                  ; Some floppy drives do not have changeline support.  The result is a
  2681                                  ; large amount of inefficiency in the code.  A media-check always returns
  2682                                  ; "I don`t know".  This cause DOS to reread the FAT on every access and
  2683                                  ; always discard any cached data.
  2684                                  ;    We get around this inefficiency by implementing a "Logical Door Latch".
  2685                                  ; The following three items are used to do this.  The logical door latch is
  2686                                  ; based on the premise that it is not physically possible to change floppy
  2687                                  ; disks in a drive in under two seconds (most people take about 10).  The
  2688                                  ; logical door latch is implemented by saving the time of the last successful
  2689                                  ; disk operation (in the value TIM_DRV).  When a new request is made the
  2690                                  ; current time is compared to the saved time.  If less than two seconds have
  2691                                  ; passed then the value "No Change" is returned.  If more than two seconds
  2692                                  ; have passed the value "Don't Know" is returned.
  2693                                  ;    There is one complecation to this algorithm.  Some programs change the
  2694                                  ; value of the timer.  In this unfortunate case we have an invalid timer.
  2695                                  ; This possiblity is detected by counting the number of disk operations
  2696                                  ; which occur without any time passing.  If this count exceeds the value of
  2697                                  ; "AccessMax" we assume the counter is invalid and always return "Don't
  2698                                  ; Know".  The variable "AccessCount" is used to keep track of the number
  2699                                  ; of disk operation which occur without the time changing.
  2700                                  ;
  2701                                  
  2702                                  AccessMax EQU 5
  2703                                  
  2704                                  ;
  2705                                  ; Some of the older versions of the IBM rom-bios always assumed a seek would
  2706                                  ; have to be made to read the diskette.  Consequently a large head settle
  2707                                  ; time was always used in the I/O operations.  To get around this problem
  2708                                  ; we need to continually adjust the head settle time.  The following
  2709                                  ; algorithm is used:
  2710                                  ;
  2711                                  ;   Get the current head settle value.
  2712                                  ;   If it is 1, then
  2713                                  ;	set slow = 15
  2714                                  ;   else
  2715                                  ;	set slow = value
  2716                                  ;   ...
  2717                                  ;   if we are seeking and writing then
  2718                                  ;	use slow
  2719                                  ;   else
  2720                                  ;	use fast
  2721                                  ;   ...
  2722                                  ;   restore current head settle value
  2723                                  ;
  2724                                  
  2725                                  ;
  2726                                  ; flags for size of FAT
  2727                                  ;
  2728                                  
  2729                                  fTOOBIG	EQU 80h
  2730                                  fBIG	EQU 40h
  2731                                  
  2732                                  error_unknown_media equ	7	; for use in BUILD BPB call
  2733                                  
  2734                                  struc BPB_TYPE
  2735 00000000 ????                    .SECSIZE:	resw 1
  2736 00000002 ??                      .SECALL:	resb 1
  2737 00000003 ????                    .RESNUM:	resw 1
  2738 00000005 ??                      .FATNUM:	resb 1
  2739 00000006 ????                    .DIRNUM:	resw 1
  2740 00000008 ????                    .SECNUM:	resw 1
  2741 0000000A ??                      .FATID:		resb 1
  2742 0000000B ????                    .FATSIZE:	resw 1
  2743 0000000D ????                    .SLIM:		resw 1
  2744 0000000F ????                    .HLIM:		resw 1
  2745 00000011 ????                    .HIDDEN:	resw 1
  2746                                  .size:
  2747                                  endstruc
  2748                                  
  2749                                  ;------------------------------------------------------------------------
  2750                                  ;									:
  2751                                  ; The next 100 or so lines of code do the Media Check.	Media Check	:
  2752                                  ; determines if the diskette (media) in the drive has been changed.	:
  2753                                  ;									:
  2754                                  ;	SI is used to hold media check code:				:
  2755                                  ;			-1	media changed				:
  2756                                  ;			 0	Don't know                              :
  2757                                  ;			 1	media has not been changed		:
  2758                                  ;									:
  2759                                  ; The algorithm used is a follows:					:
  2760                                  ;	if (hard disk)							:
  2761                                  ;	    if (changed by format)					:
  2762                                  ;		   return (not changed) 				:
  2763                                  ;	    if	not (changed by format) 				:
  2764                                  ;		   return (changed)					:
  2765                                  ;	else we have a floppy						:
  2766                                  ;	    if floppy has change line support go ask the floppy 	:
  2767                                  ;	    if floppy does not have change line do the following	:
  2768                                  ;		read the time						:
  2769                                  ;		if more than two second have passed return don't know   :
  2770                                  ;		if no time has passed then might be unreliable		:
  2771                                  ;		  counter (some program fool with the counter when	:
  2772                                  ;		  they should not).  See note below for procedure with	:
  2773                                  ;		  unreliable counter					:
  2774                                  ;		if sometime has passed but not two second return	:
  2775                                  ;		  media has not changed.  This is based on the		:
  2776                                  ;		  assumption that it is not physically possible to	:
  2777                                  ;		  change a disk in less the two seconds (most people	:
  2778                                  ;		  take about 10 seconds).				:
  2779                                  ;									:
  2780                                  ;------------------------------------------------------------------------
  2781                                  
  2782                                  MEDIA$CHK:
  2783                                  		; 13/06/2018
  2784                                  		; 26/05/2018 - Retro DOS v3.0
  2785                                  		; (Volume Serial Number Check)
  2786                                  
  2787                                  		; 08/04/2018
  2788                                  		; Retro DOS v2.0
  2789                                  		; (Media check code here is mix of MSDOS 2.0, MSDOS 3.3
  2790                                  		; and Retro DOS v2.0 special media -disk change- check code..)
  2791                                  		; (..it is not compatible with MSDOS 3.3 mediacheck)
  2792                                  		; (Excluded methods: Volume Serial Number Check,
  2793                                  		; "fChanged_By_Format" check -via int 13h hook-)
  2794                                  
  2795                                  		; 26/05/2018
  2796                                  
  2797 000009B3 E87B02                  		call	SETDRIVE ; point DS:DI to BDS for specified drive	
  2798                                  
  2799 000009B6 2E813E[C801]6B6A        		cmp	word [CS:Secrete_Code], 'kj' ; Secrete code for
  2800 000009BD 7546                    		jne	short Media$Done	; DOS 3.3 MSBIO.
  2801                                  		
  2802                                  		;cmp	AL, 1	; Retro DOS v2.0 method
  2803                                  				; We will not check disk change status
  2804                                  				; if disk/unit number > 1.
  2805                                  				; (hard disk or diskette 3 ! or diskette 4 !)
  2806                                  		;ja	short Media$Done
  2807                                  
  2808                                  ;
  2809                                  ; For non-removable disks only return changed if changed by format,
  2810                                  ; otherwise return 'not changed'.
  2811                                  ;
  2812 000009BF BE0100                  		mov	si,1		; assume no change
  2813 000009C2 F745290001              		test	word [DI+BDS.Flags],fChanged_By_Format
  2814 000009C7 7417                    		jz	short WeAreNotFakingIt
  2815                                  					; reset flag
  2816 000009C9 816529FFFE              		and	word [DI+BDS.Flags],~fChanged_By_Format
  2817                                  
  2818                                  ;
  2819                                  ; If media has been changed by format, must use the ROM.
  2820                                  ; Cannot rely on the 2 second time check.
  2821                                  ;
  2822 000009CE 2EC606[5102]FF          		mov	byte [CS:TIM_DRV],-1  ; Ensure that we ask the ROM if
  2823                                  					      ; media has changed
  2824 000009D4 F745290100              		test	word [DI+BDS.Flags],fNon_Removable
  2825 000009D9 740C                    		jz	short WeHaveAFloppy
  2826 000009DB BEFFFF                  		mov	SI,-1			; Indicate media changed
  2827 000009DE EB25                    		jmp	short Media$Done
  2828                                  ;
  2829                                  ; return 'not changed' if disk is a hard file.
  2830                                  ;
  2831                                  
  2832                                  WeAreNotFakingIt:
  2833 000009E0 F745290100              		test	word [DI+BDS.Flags],fNon_Removable
  2834 000009E5 751E                    		jnz	short Media$Done
  2835                                  
  2836                                  		;
  2837                                  		; return 'not changed' if disk is a hard file.
  2838                                  		;
  2839                                  
  2840                                  		;mov	si,1    ; not changed
  2841                                  
  2842                                  		;cmp	al, [CS:HARDNUM]
  2843                                  		;jnb	short Media$Done ; fixed/hard disk !
  2844                                  
  2845                                  ;
  2846                                  ; If this code is reached disk is a diskette drive
  2847                                  ;
  2848                                  
  2849                                  WeHaveAFloppy:
  2850 000009E7 31F6                    		xor	si,si	; Presume "I don't know"
  2851                                  
  2852                                  		; 11/04/2018
  2853                                  		;mov	[CS:MEDIACHK_DRV], al ; Retro DOS v2.0 method 
  2854                                  		; 13/04/2018
  2855                                  		;mov	[MEDIACHK_DRV], al
  2856                                  
  2857                                  ;
  2858                                  ; If drive is a floppy with changeline support the rom is called to
  2859                                  ; determine if the media has changed. It is not necessary to do the 2
  2860                                  ; second check on these drives.
  2861                                  ;
  2862                                  		;CALL	MediaCheck
  2863                                  
  2864                                  		; DL = drive number (0..3) ; 13/04/2018
  2865                                  
  2866                                  		;and	si, si
  2867                                  		;jnz	short Media$Done
  2868                                  
  2869                                  		; SI = 0, "I don't know" (if media has been changed or not!?)
  2870                                  
  2871                                  		;inc	si	; 1 = no change
  2872                                  		 
  2873                                  		; 26/05/2018 - Retro DOS v3.0
  2874                                  		;----------------------------------------|
  2875                                  		; Warning: Do not change the following. ;|
  2876                                  		;	   It gets patched in MSINIT	;|
  2877                                  							;|
  2878                                  Media_Patch:						;|
  2879 000009E9 E88A12                  		CALL	MediaCheck			;|
  2880 000009EC 7233                    		jc	short ERR$EXITJ			;|
  2881 000009EE E8FC13                  		call	HasChange			;|
  2882 000009F1 7512                    		jnz	short Media$Done		;|
  2883                                  		;----------------------------------------|
  2884                                  
  2885                                  ;
  2886                                  ; If this code is reached the drive is a floppy with no changeline support
  2887                                  ;
  2888                                  
  2889 000009F3 BE0100                  		MOV	SI,1			; PRESUME NO CHANGE
  2890 000009F6 2EA0[5102]              		mov	al,[CS:TIM_DRV] 	; last drive accessed
  2891                                  						;is drive of last access the same?
  2892                                  		;mov	al,[TIM_DRV]
  2893                                  		;;CMP	AL,[CS:MEDIACHK_DRV]
  2894                                  		;;cmp	al,[MEDIACHK_DRV]  ; 11/04/2018
  2895                                  		;CMP	AL,DL ; 13/04/2018
  2896                                  
  2897 000009FA 3A4504                  		cmp	al,[DI+BDS.DriveNum] ; 26/05/2018
  2898 000009FD 7505                    		JNE	short Media$Unk		; no, then return don't know
  2899                                  ;
  2900                                  ; CHECK TO SEE IF THIS DRIVE HAS BEEN ACCESSED IN THE LAST 2 SECONDS.
  2901                                  ;
  2902 000009FF E82500                  		call	CHECK_TIME_OF_ACCESS
  2903 00000A02 EB01                    		jmp	short Media$Done
  2904                                  
  2905                                  Media$Unk:
  2906 00000A04 4E                      		DEC	SI			; RETURN "I DON'T KNOW"
  2907                                  
  2908                                  ;
  2909                                  ; SI now contains the correct value for media change. Clean up the left overs
  2910                                  ;
  2911                                  Media$Done:
  2912 00000A05 2EC41E[B800]            		les	bx,[CS:PTRSAV]		; get original packet
  2913                                  		;les	bx,[PTRSAV] ; 11/04/2018
  2914 00000A0A 2689770E                		mov	[ES:BX+TRANS],SI
  2915 00000A0E 09F6                    		or	SI,SI
  2916                                  		;jns	EXIT
  2917 00000A10 7803                    		js	short INIT_PATCH
  2918 00000A12 E973FC                  		jmp	EXIT
  2919                                  
  2920                                  		;; make sure we ask ROM for media check
  2921                                  		;mov	byte [CS:TIM_DRV],-1
  2922                                  		;;mov	byte [TIM_DRV],-1 ; 11/04/2018
  2923                                  		;jmp	EXIT
  2924                                  
  2925                                  		; 26/05/2018 - Retro DOS v3.0
  2926                                  		;----------------------------------------|
  2927                                  		; Warning: Do not change the following. ;|
  2928                                  		;	   It gets patched in msinit	;|
  2929                                  							;|
  2930                                  INIT_PATCH:						;|
  2931 00000A15 E82613                  		CALL	MEDIA_SET_VID			;|
  2932                                  		;----------------------------------------|
  2933 00000A18 2EC606[5102]FF          		mov	byte [cs:TIM_DRV],-1 ; make sure we ask ROM for media check
  2934                                  VOLIDOK:
  2935 00000A1E E967FC                  		jmp	EXIT
  2936                                  
  2937                                  ERR$EXITJ:
  2938 00000A21 E8F604                  		CALL	MAPERROR
  2939 00000A24 E954FC                  		JMP	ERR$EXIT
  2940                                  
  2941                                  ;
  2942                                  ; PERFORM A CHECK ON THE TIME PASSED SINCE THE LAST ACCESS FOR THIS
  2943                                  ; PHYSICAL DRIVE.
  2944                                  ; WE ARE ACCESSING THE SAME DRIVE.  IF THE TIME OF LAST SUCCESSFUL ACCESS
  2945                                  ; WAS LESS THAN 2 SECONDS AGO, THEN WE MAY PRESUME THAT THE DISK WAS NOT
  2946                                  ; CHANGED
  2947                                  ; RETURNS IN SI:
  2948                                  ;	0 - IF TIME OF LAST ACCESS WAS >= 2 SECONDS
  2949                                  ;	1 - IF TIME WAS < 2 SECONDS (I.E NO MEDIA CHANGE ASSUMED)
  2950                                  ; REGISTERS AFFECTED AX,CX,DX, FLAGS.
  2951                                  ;
  2952                                  
  2953                                  CHECK_TIME_OF_ACCESS:
  2954                                  		; 27/05/2018 - Retro DOS v3.0
  2955 00000A27 BE0100                  		mov	si,1			; Presume no change
  2956                                  		;;Rev 3.30 Modification
  2957 00000A2A 30E4                    		xor	AH, AH			; set command to read time
  2958 00000A2C CD1A                    		int	1Ah			; call rom-bios clock routine
  2959                                  
  2960                                  ;
  2961                                  ; Once time is read, must make sure the date wrap is not lost.	The ROM will
  2962                                  ; return the value only once, it must check for day wrap on each call.
  2963                                  ;
  2964 00000A2E D0E8                    		SHR	AL,1
  2965 00000A30 2E8316[DA05]00          		ADC	word [CS:DAYCNT],0	; ADD IT TO OUR SAVED DAY COUNT
  2966                                  		;ADC	word [DAYCNT], 0 ; 11/04/2018
  2967                                  ;
  2968                                  ; Compute elapsed time1
  2969                                  ;
  2970                                  		; 27/05/2018
  2971                                  		; Retro DOS v3.0
  2972 00000A36 8B454D                  		MOV	AX,[DI+BDS.TIM_LO]	; GET STORED TIME
  2973 00000A39 29C2                    		SUB	DX,AX
  2974 00000A3B 8B454F                  		MOV	AX,[DI+BDS.TIM_HI]
  2975 00000A3E 19C1                    		SBB	CX,AX
  2976                                  ;
  2977                                  ; CX:DX is the elapsed time
  2978                                  ;
  2979 00000A40 751D                    		JNZ	short TimeCheck_Unk	; CX <> 0 => > 1 hour
  2980 00000A42 09D2                    		OR	DX,DX			; did some time pass?
  2981 00000A44 7514                    		JNZ	short TimePassed	; yes, examine max value
  2982                                  ;
  2983                                  ; No noticeable time has passed. There are two possibilities. First there
  2984                                  ; could be two driver calls with in one clock tick (55 milliseconds).  The
  2985                                  ; second possibility is the program has reprogramed the counter -- this is
  2986                                  ; the unreliable counter case. To distinguish between the case a count is
  2987                                  ; kept of the number of calls that happen without a clock tick (the variable
  2988                                  ; is AccessCount).  If this count exceeds a set limit (MaxAccess) it is
  2989                                  ; assumed the counter is unreliable and the value don't know is returned.
  2990                                  ; If AccessCount is less than MaxAccess we assume the time is valid and
  2991                                  ; therefore the media has not changed.
  2992                                  ;
  2993 00000A46 2EFE06[5002]            		inc	byte [cs:AccessCount]
  2994                                  						; Exceeded threshold for count?
  2995 00000A4B 2E803E[5002]05          		cmp	byte [cs:AccessCount],AccessMax
  2996 00000A51 720D                    		jb	short TimeCheck_Ret	; no, return media unchanged
  2997 00000A53 2EFE0E[5002]            		dec	byte [cs:AccessCount]	; don't let the count wrap
  2998 00000A58 EB05                    		jmp	short TimeCheck_Unk	; "I don't know" if media changed
  2999                                  
  3000                                  ;
  3001                                  ; If this code is reached some time has passed.  Need to determine if
  3002                                  ; 2 seconds have passed.  Note: 18.2 ticks per second.
  3003                                  ;
  3004                                  TimePassed:
  3005 00000A5A 83FA24                  		CMP	DX,18*2			; IF ( Time_passed <= 2secs )
  3006 00000A5D 7601                    		JBE	short TimeCheck_Ret	;      presume no change
  3007                                  
  3008                                  
  3009                                  ; Everything indicates that we do not know what has happened.
  3010                                  ;
  3011                                  TimeCheck_Unk:
  3012 00000A5F 4E                      		DEC	SI			; Presume I don't know
  3013                                  TimeCheck_Ret:
  3014 00000A60 C3                      		RETN
  3015                                  
  3016                                  ERR$EXITJ2:
  3017 00000A61 E917FC                  		JMP 	ERR$EXIT
  3018                                  
  3019                                  
  3020                                  ;------------------------------------------------------------------------
  3021                                  ;									:
  3022                                  ;		Get Bios Parameter Block				:
  3023                                  ;									:
  3024                                  ; GET$BPB is called to build a valid BPB for the media in the disk	:
  3025                                  ; drive.  A BPB (Bios Parameter Block) contains information about	:
  3026                                  ; the media which is currently in the drive.  The values stored is	:
  3027                                  ; information like number of fat sectors, size of drive, 8 or 9 sectors,:
  3028                                  ; etc.									:
  3029                                  ;									:
  3030                                  ;	This routine is called by the device drive code.		:
  3031                                  ;									:
  3032                                  ;	On entry AL contains the logical drive number which needs	:
  3033                                  ;	  the BPB built.						:
  3034                                  ;	ES:[DI] points to a buffer; the first byte of the buffer is a	:
  3035                                  ;	   media decriptor byte.					:
  3036                                  ;									:
  3037                                  ;------------------------------------------------------------------------
  3038                                  ;
  3039                                  ; Build a valid BPB for the disk in the drive.
  3040                                  ;
  3041                                  
  3042                                  GET$BPB:
  3043 00000A64 268A25                  		mov	AH,[ES:DI]		; get FAT ID byte read by DOS
  3044 00000A67 E8C701                  		call	SETDRIVE		; get the correct BDS for the drv
  3045                                  		; 27/05/2018
  3046                                  		;;Rev 3.30 Modification
  3047 00000A6A F745290100              		TEST	word [DI+BDS.Flags],fNon_Removable
  3048 00000A6F 7508                    		JNZ	short ALREADY_GOTBPB	; NO NEED TO BUILD FOR FIXED DISKS
  3049                                  		;End of Modification
  3050 00000A71 E81C00                  		call	GETBP			; build a BPB if necessary.
  3051 00000A74 72EB                    		jc	short ERR$EXITJ2	; if error exit
  3052                                  SET_PATCH:
  3053 00000A76 E89213                  		CALL	Set_Volume_ID
  3054                                  ALREADY_GOTBPB:
  3055 00000A79 83C706                  		add	di,BDS.BytePerSec	; return the BPB that is in the current BDS
  3056                                  
  3057                                  SetPTRSAV:					; return point for DSK$INIT
  3058 00000A7C 2EC41E[B800]            		les	BX,[CS:PTRSAV]
  3059 00000A81 2688670D                		mov	[ES:BX+MEDIA],AH
  3060 00000A85 26897F12                		mov	[ES:BX+COUNT],DI
  3061 00000A89 268C5F14                		mov	[ES:BX+COUNT+2],DS
  3062 00000A8D E9F8FB                  		jmp	EXIT
  3063                                  
  3064                                  ; 13/06/2018
  3065                                  ; 27/05/2018 - Retro DOS v3.0
  3066                                  
  3067                                  ;
  3068                                  ;      GETBP fills the BDS with the BPB for the media currently in the drive.
  3069                                  ; The following steps are followed:
  3070                                  ;	If the Return_Fake_BPB flag is set then the GETBP just returns.
  3071                                  ;	If the BDS is for a hard disk (non-removable) then GETBP returns since
  3072                                  ;   the BPB cannot change on a hard disk drive.
  3073                                  ;	For all other cases GETBP reads the boot sector and looks for a BPB
  3074                                  ;   in the boot sector. (All DOS 2.X and about disks should have a valid
  3075                                  ;   BPB in the boot sector.)
  3076                                  ;	If no valid BPB is found (DOS 1.X disk) then GETBP reads the FAT
  3077                                  ;   sector and gets the FAT ID byte.  With this byte a valid BPB is build.
  3078                                  ;
  3079                                  ;	Inputs:
  3080                                  ;		DS:DI points to correct BDS
  3081                                  ;
  3082                                  ;	Outputs:
  3083                                  ;		Fills in BPB in current BDS if valid BPB or FAT ID on disk.
  3084                                  ;		Carry set, and AL=7 if invalid disk.
  3085                                  ;		Carry set and error code in AL if other error.
  3086                                  ;
  3087                                  
  3088                                  GETBP:
  3089                                  					; if non-removable or returning
  3090                                  					; fake BPB then return BPB as is.
  3091 00000A90 F745290500              		TEST	WORD [DI+BDS.Flags],RETURN_FAKE_BPB|fNon_Removable
  3092 00000A95 7403                    		jz	short GETBP1
  3093 00000A97 E98E00                  		JMP	GETRET_Exit
  3094                                  
  3095                                  GETBP1:
  3096 00000A9A 51                      		push	cx
  3097 00000A9B 52                      		push	dx
  3098 00000A9C 06                      		push	es
  3099 00000A9D 53                      		push	bx
  3100                                  ;
  3101                                  ; Attempt to read in boot sector and determine BPB.
  3102                                  ; We assume that the 2.x and greater DOS disks all have a valid boot sector.
  3103                                  ;
  3104                                  Rdboot:
  3105 00000A9E E88D00                  		call	READBOOTSEC
  3106 00000AA1 7233                    		jc	short GetBP_Err_Ret
  3107                                  		;jnc	short NoRdErr
  3108                                  		;jmp	GetBP_Err_Ret	; Carry set if there was error.
  3109                                  NoRdErr:
  3110 00000AA3 83FB00                  		cmp	bx,0		; BX is 0 if boot sector is valid.
  3111                                  		;or	bx, bx
  3112 00000AA6 7505                    		jnz	short DoFatBPB	; if not go read FAT
  3113                                  
  3114 00000AA8 E8DD00                  		call	MOVBPB		; Move BPB into registers.
  3115 00000AAB EB5F                    		jmp	short HAS1
  3116                                  	
  3117                                  ;
  3118                                  ; At this point the drive contains a 1.X diskette.  We read the FAT byte
  3119                                  ; and fill in the BPB from there.
  3120                                  ;
  3121                                  
  3122                                  DoFatBPB:
  3123 00000AAD E8FA00                          	call    READFAT		; puts media descriptor byte in AH
  3124 00000AB0 7224                            	jc	short GetBP_Err_Ret ; if carry set, there was error, get out
  3125                                  
  3126                                  		;----------------------------------------|
  3127                                  		; Warning: Do not change the following. ;|
  3128                                  		;          It gets patched in msinit    ;|
  3129                                  							;|
  3130                                  GETBP1_PATCH:   		                        ;|
  3131 00000AB2 E89812                  		call    hidensity               	;|
  3132                                  		;----------------------------------------|
  3133                                  		
  3134                                  		; Test for a valid 3.5" medium
  3135 00000AB5 807D2802                        	cmp     byte [DI+BDS.FormFactor],ffSmall
  3136 00000AB9 7520                            	jnz	short Is_Floppy
  3137                                          
  3138 00000ABB 80FCF9                  		cmp     ah,0F9H		; is it a valid fat ID byte for 3.5" ?
  3139 00000ABE 7569                    		jnz     short Got_Unknown_Medium
  3140 00000AC0 BB[C905]                        	mov     bx,SM92		; pointer to correct BPB
  3141 00000AC3 0E                              	push    cs
  3142 00000AC4 07                              	pop     es
  3143                                  ;--------------------------------------------------------------bug330a08
  3144                                  		;mov	al,[es:bx+bpbType.spf]
  3145 00000AC5 268A07                  		mov	al,[es:bx]  ; 05/07/2019
  3146 00000AC8 268B4F03                        	mov     cx,[es:bx+bpbType.csec]
  3147 00000ACC 268B5705                        	mov     dx,[es:bx+bpbType.spa]
  3148 00000AD0 268B5F01                        	mov     bx,[es:bx+bpbType.spt]
  3149                                  ;--------------------------------------------------------------bug330a08
  3150 00000AD4 EB33                    		jmp	short HAS1_res	; Need to load reserved sectors
  3151                                  
  3152                                  		; 13/06/2018
  3153                                  GetBP_Err_Ret:
  3154 00000AD6 E84104                  		CALL	MAPERROR
  3155 00000AD9 EB49                    		JMP	SHORT GETRET
  3156                                  
  3157                                  ;
  3158                                  ; must be a 5.25" floppy if we come here
  3159                                  ;
  3160                                  Is_Floppy:
  3161 00000ADB 88E1                    		mov     CL,AH		; save media
  3162 00000ADD 80E1F8                  		and     CL,0F8H		; normalize
  3163 00000AE0 80F9F8                  		cmp     CL,0F8H		; compare with good media byte
  3164 00000AE3 7544                            	jnz     short Got_Unknown_Medium
  3165                                  
  3166 00000AE5 B001                    GOODID: 	mov     AL,1		; set number of FAT sectors
  3167 00000AE7 BB0840                          	mov     BX,64*256+8	; set dir entries and sector max
  3168 00000AEA B94001                          	mov     CX,40*8		; set size of drive
  3169 00000AED BA0101                          	mov     DX,01*256+1	; set head limit and sec/all unit
  3170 00000AF0 F6C402                         		test    AH,00000010B	; test for 8 or 9 sectors
  3171 00000AF3 7507                            	jnz	short HAS8	; NZ = has 8 sectors
  3172 00000AF5 FEC0                            	inc     AL		; inc number of FAT sectors
  3173 00000AF7 FEC3                            	inc     BL		; inc sector max
  3174 00000AF9 83C128                          	add     CX,40		; increase size
  3175 00000AFC F6C401                  HAS8:   	test    AH,00000001B	; test for 1 or 2 heads
  3176 00000AFF 7408                    		jz	short HAS1_res	; Z = 1 head
  3177 00000B01 01C9                    		add     CX,CX		; double size of disk
  3178 00000B03 B770                    		mov     BH,112		; increase number of directory entries
  3179 00000B05 FEC6                    		inc     DH		; inc sec/all unit
  3180 00000B07 FEC2                    		inc     DL		; inc head limit
  3181                                  HAS1_res:
  3182 00000B09 8B7509                  		mov	si,[DI+BDS.RESSEC]
  3183                                  					; save values in BDS
  3184 00000B0C 887508                  HAS1:		mov     [DI+BDS.SecPerClus],DH
  3185 00000B0F 887D0C                          	mov     [DI+BDS.cDir],BH
  3186 00000B12 894D0E                          	mov     [DI+BDS.DRVLIM],CX
  3187 00000B15 886510                          	mov     [DI+BDS.Mediad],AH
  3188 00000B18 884511                          	mov     [DI+BDS.cSecFat],AL
  3189 00000B1B 885D13                          	mov     [DI+BDS.SECLIM],BL
  3190 00000B1E 885515                          	mov     [DI+BDS.HDLIM],DL
  3191 00000B21 897509                          	mov     [DI+BDS.RESSEC],SI
  3192                                  GETRET: 
  3193 00000B24 5B                      		pop     bx
  3194 00000B25 07                      		pop	es
  3195 00000B26 5A                      		pop	dx
  3196 00000B27 59                      		pop	cx	
  3197                                  GETRET_Exit:
  3198 00000B28 C3                      		retn
  3199                                  
  3200                                  ;
  3201                                  ; We have a 3.5" diskette for which we cannot build a BPB. We do not assume any
  3202                                  ; type of BPB for this medium.
  3203                                  ;
  3204                                  Got_Unknown_Medium:
  3205 00000B29 B007                    		mov	al,error_unknown_media
  3206 00000B2B F9                      		stc
  3207 00000B2C EBF6                    		jmp	short GETRET
  3208                                  
  3209                                  ;
  3210                                  ; Read in the boot sector. Set carry if error in reading sector.
  3211                                  ; BX is set to 1 if the boot sector is invalid, otherwise it is 0.
  3212                                  ;
  3213                                  READBOOTSEC:
  3214 00000B2E B90100                  		mov	CX,0001h	; set track and sector number
  3215 00000B31 30F6                    		xor     DH,DH		; set head number for read_sector
  3216 00000B33 E88600                  		call	READ_SECTOR
  3217 00000B36 724F                    		jc	short Err_ret	; error - get out
  3218 00000B38 31DB                    		xor	bx,bx		; assume valid boot sector.
  3219                                  
  3220                                  				; at this point the boot sector has been
  3221                                  				; read in from the disk.  We now need to
  3222                                  				; determine if the boot sector contains
  3223                                  				; a valid BPB.	Currently there are only
  3224                                  				; a few simple checks.	Expanding the
  3225                                  				; number or types of checks would not be
  3226                                  				; a bad idea.
  3227                                  
  3228                                  ;*******************************************************************************
  3229                                  ; Put a sanity check for the boot sector in here to detect boot sectors that
  3230                                  ; do not have valid BPBs.
  3231                                  ; We examine the first two bytes - they must contain a long jump or a short
  3232                                  ; jump followed by a NOP.
  3233                                  ; If this test is passed, we further check by examining the signature at
  3234                                  ; the end of the boot sector for the word AA55H.
  3235                                  ; If the signature is not present, we examine the media descriptor byte to
  3236                                  ; see if it is valid.
  3237                                  ;******************************************************************************
  3238 00000B3A 2E803E[8202]69          		cmp	byte [cs:DiskSector],069H    ; Is it a direct jump?
  3239 00000B40 7418                    		JE	short Check_bpb_MediaByte    ; DON'T NEED TO FIND A NOP
  3240 00000B42 2E803E[8202]E9          		cmp	byte [cs:DiskSector],0E9H    ; DOS 2.0 jump?
  3241 00000B48 7410                    		JE	short Check_bpb_MediaByte    ; NO NEED FOR NOP
  3242 00000B4A 2E803E[8202]EB          		cmp	byte [cs:DiskSector],0EBH    ; How about a short jump.
  3243 00000B50 7533                    		JNE	short INVALIDBOOTSEC
  3244 00000B52 2E803E[8402]90          		cmp	byte [cs:DiskSector+2],090H  ; Is next one a NOP?
  3245 00000B58 752B                    		JNE	short INVALIDBOOTSEC
  3246                                  
  3247                                  ; Don't have to perform the following signature check since
  3248                                  ; we need to check the media byte even with the good signatured diskette.
  3249                                  ;CHECK_SIGNATURE:
  3250                                  ;		CMP	word [cs:DiskSector+1FEh],0AA55h ; SEE IF NON-IBM
  3251                                  ;							 ; DISK OR 1.X MEDIA.
  3252                                  ;		JZ	short CHECKSINGLESIDED ; GO SEE IF SINGLE SIDED MEDIUM.
  3253                                  ;					       ; MAY NEED SOME SPECIAL HANDLING
  3254                                  ;
  3255                                  ; CHECK FOR NON-IBM DISKS WHICH DO NOT HAVE THE SIGNATURE AA55 AT THE
  3256                                  ; END OF THE BOOT SECTOR, BUT STILL HAVE A VALID BOOT SECTOR. THIS IS DONE
  3257                                  ; BY EXAMINING THE MEDIA DESCRIPTOR IN THE BOOT SECTOR.
  3258                                  ;
  3259                                  
  3260                                  ;;Rev 3.30 Modification
  3261                                  Check_bpb_MediaByte:
  3262                                  
  3263 00000B5A 2EA0[9702]              		MOV	AL,[CS:MediaByte]
  3264 00000B5E 24F0                    		AND	AL,0F0H
  3265 00000B60 3CF0                    		CMP	AL,0F0H		; ALLOW FOR STRANGE MEDIA
  3266 00000B62 7521                    		JNZ	short INVALIDBOOTSEC 
  3267                                  ;
  3268                                  ; THERE WERE SOME (APPARENTLY A BUNCH) DISKETTES THAT HAD BEEN FORMATTED
  3269                                  ; UNDER DOS 3.1 AND EARLIER VERSIONS WHICH HAVE INVALID BPBS IN THEIR BOOT
  3270                                  ; SECTORS. THESE ARE SPECIFICALLY DISKETTES THAT WERE FORMATTED IN DRIVES
  3271                                  ; WITH ONE HEAD, OR WHOSE SIDE 0 WAS BAD. THESE CONTAIN BPBS IN THE BOOT
  3272                                  ; SECT THAT HAVE THE SEC/CLUS FIELD SET TO 2 INSTEAD OF 1, AS IS STANDARD
  3273                                  ; IN DOS. TO SUPPORT THEM, WE HAVE TO INTRODUCE A "HACK" THAT WILL
  3274                                  ; HELP OUR BUILD BPB ROUTINE TO RECOGNISE THESE SPECIFIC CASES, AND TO
  3275                                  ; SET UP OUT COPY OF THE BPB ACCORDINGLY.
  3276                                  ; WE DO THIS BY CHECKING TO SEE IF THE BOOT SECTOR IS OFF A DISKETTE THAT
  3277                                  ; IS SINGLE-SIDED AND IS A PRE-DOS 3.20 DISKETTE. IF IT IS, WE SET THE
  3278                                  ; SEC/CLUS FIELD TO 1. IF NOT, WE CARRY ON AS NORMAL.
  3279                                  CHECKSINGLESIDED:
  3280 00000B64 2EA0[9702]              		MOV	AL,[CS:MediaByte]
  3281 00000B68 A801                    		TEST	AL,0001H ; IS LOW BIT SET? - INDICATES DOUBLE SIDED
  3282 00000B6A 751A                    		JNZ	short GoodDsk
  3283 00000B6C 2E813E[8A02]332E        		CMP	word [CS:DiskSector+8],"3."
  3284 00000B73 7508                    		JNZ	short MUSTBEEARLIER
  3285 00000B75 2E803E[8C02]32          		CMP	byte [CS:DiskSector+10],"2"
  3286 00000B7B 7309                    		JAE	short GoodDsk
  3287                                  
  3288                                  ; WE MUST HAVE A PRE-3.20 DISKETTE. SET THE SEC/CLUS FIELD TO 1
  3289                                  MUSTBEEARLIER:
  3290 00000B7D 2EC606[8F02]01          		MOV	BYTE [CS:SECPERCLUSINSECTOR],1
  3291 00000B83 EB01                    		JMP	short GoodDsk
  3292                                  
  3293                                  INVALIDBOOTSEC:
  3294 00000B85 43                      		INC	BX		; SET THAT BOOT SECTOR INVALID
  3295                                  ;;End of Modification
  3296                                  
  3297                                  GoodDsk:				; carry already reset
  3298 00000B86 F8                      		clc
  3299                                  Err_ret:
  3300 00000B87 C3                      		retn
  3301                                  
  3302                                  ;Err_Ret:				; carry is already set on entry here
  3303                                  ;		retn
  3304                                  
  3305                                  ;
  3306                                  ; MovBPB moves the BPB read from the Boot sector into registers for use by
  3307                                  ; GETBP routine at Has1
  3308                                  ;
  3309                                  MOVBPB:
  3310 00000B88 1E                      		push	ds
  3311 00000B89 57                      		push	di
  3312 00000B8A 0E                      		push	cs
  3313 00000B8B 1F                      		pop	ds
  3314 00000B8C BF[8D02]                		mov	di,BPB_In_Sector
  3315 00000B8F 8A7502                  		mov	dh,[DI+BPB_TYPE.SECALL]	;sectors per unit
  3316 00000B92 8A7D06                  		mov	bh,[DI+BPB_TYPE.DIRNUM]	;number of directory entries
  3317 00000B95 8B4D08                  		mov	cx,[DI+BPB_TYPE.SECNUM]	;size of drive
  3318 00000B98 8A650A                  		mov	ah,[DI+BPB_TYPE.FATID]	;media descriptor
  3319 00000B9B 8A450B                  		mov	al,[DI+BPB_TYPE.FATSIZE] ;number of FAT sectors
  3320 00000B9E 8A5D0D                  		mov	bl,[DI+BPB_TYPE.SLIM]	;sectors per track
  3321 00000BA1 8A550F                  		mov	dl,[DI+BPB_TYPE.HLIM]	;number of heads
  3322 00000BA4 8B7503                  		mov	si,[DI+BPB_TYPE.RESNUM]	;reserved sectors
  3323 00000BA7 5F                      		pop	di
  3324 00000BA8 1F                      		pop	ds
  3325 00000BA9 C3                      		retn
  3326                                  
  3327                                  ;
  3328                                  ; Read in the FAT sector and get the Media Byte from it.
  3329                                  ; Input : AL contains logical drive.
  3330                                  ; Output:
  3331                                  ;	  Carry set if an error occurs, AX contains error code.
  3332                                  ;	  Otherwise, AH contains media byte on exit. AL is preserved.
  3333                                  
  3334                                  READFAT:
  3335 00000BAA 50                      		push	ax		   ; preserve logical drive in AL
  3336 00000BAB B600                    		MOV	DH,0		   ; HEAD 0
  3337 00000BAD B90200                  		mov	CX,2		   ; set track and sector number
  3338 00000BB0 E80900                  		call	READ_SECTOR	   ; CS:BX points to fat sector
  3339 00000BB3 7205                    		jc	short Bad_FAT_Ret  ; error, get out
  3340 00000BB5 58                      		pop	ax		   ; reset logical drive
  3341 00000BB6 2E8A27                  		mov	ah,[CS:BX]	   ; media byte
  3342 00000BB9 C3                      		retn
  3343                                  
  3344                                  Bad_FAT_Ret:				   ; carry set on entry
  3345 00000BBA 59                      		pop	cx	           ; clear stack
  3346 00000BBB C3                      		retn
  3347                                  
  3348                                  ;
  3349                                  ; Read_sector reads a single sector into the tempory buffer 'DiskSector'.
  3350                                  ; Up to three retries are done in case of error.
  3351                                  ;
  3352                                  ;    Inputs:
  3353                                  ;	DS:DI	points to BDS for drive
  3354                                  ;	CH - track number
  3355                                  ;	CL - sector number
  3356                                  ;	DH - head number
  3357                                  ;
  3358                                  ;    Outputs:
  3359                                  ;	If carry is clear -- successful read
  3360                                  ;	   CS:BX points to buffer holding sector
  3361                                  ;	   AX, BX are not preserved, CX, DX, BP, and ES are preserved
  3362                                  ;
  3363                                  ;	If carry is set -- error on read
  3364                                  ;	   AX, BX, and DX are not preserved; CX, BP, and ES are preserved
  3365                                  ;
  3366                                  ;
  3367                                  
  3368                                  READ_SECTOR:
  3369 00000BBC 55                      		push	BP		; preserve BP register
  3370 00000BBD BD0300                  		mov	BP,3		; BP is retry count, set to 3
  3371 00000BC0 06                      		push	ES		; preserve ES also
  3372 00000BC1 8A5504                  		mov	DL,[DI+BDS.DriveNum]
  3373 00000BC4 BB[8202]                		mov	BX,DiskSector	; Get ES:BX to point to buffer
  3374 00000BC7 0E                      		push	CS		;    get the segment right
  3375 00000BC8 07                      		pop	ES		; now ES:BX is correct
  3376                                  
  3377                                  RD_RET:
  3378                                  					; set command to read (AH=2) and
  3379 00000BC9 B80102                  		mov	AX,0201h	; number of sectors to 1 (AL=1)
  3380 00000BCC CD13                    		int	13h		; call rom-bios disk routines
  3381 00000BCE 733C                    		jnc	short OKRET2	; if no carry then no error - done
  3382                                  Rd_rty:
  3383 00000BD0 E8C80A                  		call	AGAIN		; reset disk and decrement BP
  3384 00000BD3 7434                    		jz	short ERR_RD_RET
  3385 00000BD5 F745290100              		test	word [DI+BDS.Flags],fNon_Removable
  3386 00000BDA 75ED                    		JNZ	short RD_RET
  3387                                  
  3388                                  ;;Rev 3.30 Modification -----------------------------------------
  3389 00000BDC 1E                      		push	ds		; For retry, set head settle
  3390 00000BDD 50                      		push	ax		; time to 0Fh.
  3391 00000BDE 2EC536[6202]            		lds	si,[CS:DPT]
  3392 00000BE3 8A4409                  		mov	al,[SI+DISK_PARMS.DISK_HEAD_STTL]
  3393 00000BE6 2EA2[5F02]              		mov	[CS:Save_head_sttl],al
  3394 00000BEA C644090F                		mov	byte [SI+DISK_PARMS.DISK_HEAD_STTL],NORMSETTLE
  3395 00000BEE 58                      		pop	ax
  3396 00000BEF 1F                      		pop	ds
  3397                                  					; SET CMD TO READ (AH=2) AND
  3398 00000BF0 B80102                  		MOV	AX,0201h	; NUM OF SECTORS TO 1 (AL=1)
  3399 00000BF3 CD13                    		INT	13h		; CALL ROM-BIOS DISK ROUTINES
  3400 00000BF5 1E                      		push	ds
  3401 00000BF6 50                      		push	ax
  3402 00000BF7 2EC536[6202]            		lds	si,[CS:DPT]
  3403 00000BFC 2EA0[5F02]              		mov	al,[CS:Save_head_sttl]
  3404 00000C00 884409                  		mov	[SI+DISK_PARMS.DISK_HEAD_STTL],al
  3405 00000C03 58                      		pop	ax
  3406 00000C04 1F                      		pop	ds
  3407 00000C05 7305                    		jnc	short OKRET2
  3408 00000C07 EBC7                    		jmp	short Rd_rty
  3409                                  ERR_RD_RET:
  3410 00000C09 B2FF                    		MOV	DL,-1	; MAKE SURE WE ASK ROM IF MEDIA  CHANGED
  3411 00000C0B F9                      		STC		; RETURN ERROR
  3412                                  ;;End of Modification -----------------------------------------
  3413                                  
  3414                                  			; Update information pertaining to last drive
  3415                                  			; accessed, time of access, last track accessed
  3416                                  			; in that drive.
  3417                                  OKRET2:
  3418                                  				; set up for head settle logic in DISK
  3419 00000C0C 2E8816[C101]            		mov	[CS:STEP_DRV],DL ; save last drive accessed
  3420 00000C11 2E8816[5102]            		mov	[CS:TIM_DRV],DL	; save the values
  3421 00000C16 886D4C                  		mov	[DI+BDS.Track],CH ;
  3422 00000C19 9C                      		pushf			; save the flags
  3423 00000C1A E81503                  		call	SET_TIM
  3424 00000C1D 9D                      		popf			; restore flags
  3425 00000C1E 07                      		pop	ES		; restore registers
  3426 00000C1F 5D                      		pop	BP
  3427 00000C20 C3                      		retn
  3428                                  
  3429                                  ;27/05/2018 - Retro DOS v3.0
  3430                                  
  3431                                  ;------------------------------------------------------------------------
  3432                                  ;									:
  3433                                  ;		Disk Removable Routine					:
  3434                                  ;									:
  3435                                  ;  This routine determines if a particular logical drive has		:
  3436                                  ;  removable media.							:
  3437                                  ;									:
  3438                                  ;  Input								:
  3439                                  ;     AL contains the logical drive number which the check is being	:
  3440                                  ;  done.								:
  3441                                  ;------------------------------------------------------------------------
  3442                                  
  3443                                  DSK$REM:				;ARR 2.41
  3444 00000C21 E80D00                  		call	SETDRIVE	; get BDS for this drive
  3445 00000C24 F745290100              		test	word [DI+BDS.Flags],fNon_Removable
  3446 00000C29 7503                    		jnz	short NON_REM
  3447 00000C2B E95AFA                  		jmp	EXIT
  3448                                  
  3449                                  NON_REM:				; if non removable set busy bit
  3450 00000C2E E93CFA                  		jmp	BUS$EXIT
  3451                                  
  3452                                  ;
  3453                                  ; SetDrive scans through the data structure of BDSs and returns a
  3454                                  ; pointer to the BDS that belongs to the drive specified in AL.
  3455                                  ; Carry is set if no BDS has a logical drive number which matches the
  3456                                  ; value in AL.
  3457                                  ;	Input:
  3458                                  ;	  AL contains the logical drive number
  3459                                  ;	Output:
  3460                                  ;	  DS:DI points to correct BDS if Carry is clear.
  3461                                  ;
  3462                                  ;	 All register execpt DS and DI are preserved
  3463                                  ;
  3464                                  
  3465                                  SETDRIVE:
  3466                                  		; 27/05/2018 - Retro DOS v3.0
  3467                                  		; (MSDOS v3.3, 'MSDISK.ASM')
  3468                                  		
  3469 00000C31 53                      		push	bx
  3470 00000C32 0E                      		push	cs
  3471 00000C33 1F                      		pop	ds
  3472                                  
  3473 00000C34 8B3E[4C02]              		mov	di,[START_BDS] 
  3474                                  Scan_Loop:
  3475                                  ;;Rev 3.30 Modification -----------------------------------------
  3476 00000C38 2E803E[C201]01          		CMP	BYTE [CS:PHYS_DRV],1 ; DOES AL HAVE PHYS DRV?
  3477 00000C3E 7207                    		JB	short USE_LOGICAL_DRV
  3478 00000C40 384504                  		CMP	BYTE [DI+BDS.DriveNum],AL
  3479 00000C43 7414                    		JE	short SetDrv
  3480 00000C45 EB05                    		JMP	SHORT GET_NXT_BDS
  3481                                  USE_LOGICAL_DRV:
  3482 00000C47 384505                  		CMP	[DI+BDS.DriveLet],AL
  3483 00000C4A 740D                    		JE	short SetDrv
  3484                                  GET_NXT_BDS:
  3485 00000C4C 8B5D02                  		MOV	BX,[DI+BDS.Link+2] ; GO TO NEXT BDS
  3486                                  		;MOV	DI,[DI+BDS.Link]
  3487 00000C4F 8B3D                    		mov	di,[di] ; 05/07/2019
  3488 00000C51 8EDB                    		mov	ds,bx
  3489                                  ;;End of Modification -----------------------------------------
  3490                                  
  3491 00000C53 83FFFF                  		cmp	di,-1		; at end of list?
  3492 00000C56 75E0                    		jnz	short Scan_Loop	; no, keep looking
  3493 00000C58 F9                      		stc			; yes, indicate error set carry
  3494                                  SetDrv:
  3495 00000C59 5B                      		pop	bx		; restore bx
  3496 00000C5A C3                      		retn
  3497                                  
  3498                                  ;------------------------------------------------------------------------
  3499                                  ;									:
  3500                                  ;		DISK I/O ROUTINES					:
  3501                                  ;									:
  3502                                  ;  On entry the register contain the following values:			:
  3503                                  ;									:
  3504                                  ;	AH - Media Descriptor byte					:
  3505                                  ;	AL - logical drive number					:
  3506                                  ;	CX - count of sectors to be read or written			:
  3507                                  ;	DX - start sector						:
  3508                                  ;	DI - offset of destination buffer				:
  3509                                  ;									:
  3510                                  ;------------------------------------------------------------------------
  3511                                  
  3512                                  
  3513                                  ;------------------------------------------------------------------------
  3514                                  ;									:
  3515                                  ;		Disk Write with Verify					:
  3516                                  ;									:
  3517                                  ;  Input								:
  3518                                  ;	See about header for register contents on entry.		:
  3519                                  ;									:
  3520                                  ;------------------------------------------------------------------------
  3521                                  
  3522                                  
  3523                                  DSK$WRITV:
  3524 00000C5B 2EC706[5602]0301        		MOV	WORD [CS:WRTVERIFY],103H
  3525 00000C62 EB07                    		JMP	SHORT DSK$CL
  3526                                  
  3527                                  ;------------------------------------------------------------------------
  3528                                  ;									:
  3529                                  ;		       Disk Write					:
  3530                                  ;									:
  3531                                  ;  Input								:
  3532                                  ;	See about header for register contents on entry.		:
  3533                                  ;									:
  3534                                  ;------------------------------------------------------------------------
  3535                                  
  3536                                  DSK$WRIT:
  3537 00000C64 2EC706[5602]0300        		MOV	WORD [CS:WRTVERIFY],ROMWrite
  3538                                  
  3539                                  DSK$CL:
  3540 00000C6B E88F00                  		CALL	DISKIO
  3541                                  DSK$IO:
  3542 00000C6E 7203                    		JC	short DSKBad
  3543 00000C70 E915FA                  		JMP	EXIT
  3544                                  DSKBad:
  3545 00000C73 E9FDF9                  		JMP	ERR$CNT
  3546                                  
  3547                                  ;------------------------------------------------------------------------
  3548                                  ;									:
  3549                                  ;			Disk Read					:
  3550                                  ;									:
  3551                                  ;  Input								:
  3552                                  ;	See about header for register contents on entry.		:
  3553                                  ;									:
  3554                                  ;------------------------------------------------------------------------
  3555                                  
  3556                                  DSK$READ:
  3557 00000C76 E87F00                  		CALL	DISKRD
  3558 00000C79 EBF3                    		JMP	short DSK$IO
  3559                                  
  3560                                  ;
  3561                                  ; Miscellaneous odd jump routines.  Moved out of mainline for speed.
  3562                                  ;
  3563                                  
  3564                                  ;
  3565                                  ; CheckSingle determines if the drive specified is a virtual drive (more
  3566                                  ; than one logical drive associated with one physical drive). If this
  3567                                  ; is the case we need to prompt the user to place the correct disk in
  3568                                  ; the drive.
  3569                                  ;
  3570                                  ;	Input:
  3571                                  ;	   DS:DI pints to the BDS for the drive being checked.
  3572                                  ;
  3573                                  ;	If there is a error the carry flag is set on return
  3574                                  ;
  3575                                  ;  All registers are preserved.
  3576                                  ;
  3577                                  
  3578                                  CHECKSINGLE:
  3579                                  		; 27/05/2018 - Retro DOS v3.0
  3580 00000C7B 50                      		push	AX		; save affected registers
  3581 00000C7C 53                      		push	BX
  3582                                  
  3583 00000C7D 8B5D29                  		mov	BX,[DI+BDS.Flags]
  3584                                  					;Can't change disk
  3585 00000C80 F6C321                  		TEST	BL,fNon_Removable | fI_Own_Physical
  3586 00000C83 7562                    		jnz	short SingleRet	; on hard drive so return
  3587                                  					; is there a drive sharing this
  3588 00000C85 F6C310                  		TEST	BL,fI_Am_Mult	;   physical drive?
  3589 00000C88 745D                    		jz	short SingleRet	; if not, then return
  3590                                  
  3591                                  			; At this point there is more than one
  3592                                  			; logical drive mapped to this physical drive.
  3593                                  			; But the drive being accessed is not the
  3594                                  			; owner of the physical drive.	What needs to
  3595                                  			; be done is find the current owner BDS and
  3596                                  			; turn off the owner flag and then make current
  3597                                  			; BDS the owner of the drive.  Then prompt the
  3598                                  			; user to change disks.
  3599                                  	
  3600 00000C8A 8A4504                  		mov	al,[DI+BDS.DriveNum] ; get physical drive number
  3601 00000C8D 1E                      		push	ds		; preserve pointer to current BDS
  3602 00000C8E 57                      		push	di
  3603 00000C8F 0E                      		push	cs
  3604 00000C90 1F                      		pop	ds		; Point to start of BDS linked list
  3605                                  
  3606 00000C91 BF[4C02]                		mov	di,START_BDS
  3607                                  Scan_List:
  3608 00000C94 8B5D02                  		mov	bx,[DI+BDS.Link+2] ; go to next BDS
  3609                                  		;mov	di,[DI+BDS.Link]
  3610 00000C97 8B3D                    		mov	di,[di] ; 05/07/2019
  3611 00000C99 8EDB                    		mov	ds,bx
  3612                                  		
  3613 00000C9B 83FFFF                  		cmp	di,-1		; end of list?
  3614 00000C9E 744A                    		jz	short Single_Err_Ret ; if so there must be an error
  3615                                  					; same physical drive?
  3616 00000CA0 384504                  		cmp	[DI+BDS.DriveNum],al
  3617 00000CA3 75EF                    		jnz	short Scan_List	; no, keep looking
  3618                                  
  3619                                  Check_Own:				; yes, check to see if owner
  3620 00000CA5 8B5D29                  		mov	bx,[DI+BDS.Flags]
  3621 00000CA8 F6C320                  		test	bl,fI_Own_Physical
  3622 00000CAB 74E7                    		jz	short Scan_List	; not owner, keep looking
  3623 00000CAD 80F320                  		xor	bl,fI_Own_Physical ; yes owner, reset ownership flag
  3624 00000CB0 895D29                  		mov	[DI+BDS.Flags],bx
  3625 00000CB3 5F                      		pop	di		; Restore pointer to current BDS
  3626 00000CB4 1F                      		pop	ds
  3627 00000CB5 31DB                    		xor	bx,bx
  3628 00000CB7 80CB20                  		or	bl,fI_Own_Physical ; establish current BDS as owner
  3629 00000CBA 095D29                  		or	[DI+BDS.Flags],bx
  3630                                  
  3631                                  			;
  3632                                  			; We examine the fSetOwner flag. If it is
  3633                                  			; set, then we are using the code in
  3634                                  			; CheckSingle to just set the owner of
  3635                                  			; a drive. We must not issue the prompt
  3636                                  			; in this case.
  3637                                  			;
  3638                                  
  3639 00000CBD 2E803E[C601]01          		cmp	byte [cs:fSetOwner],1
  3640 00000CC3 7422                    		jz	short SingleRet
  3641                                  	
  3642                                  			;
  3643                                  			; To support "backward" compatibility with
  3644                                  			; IBM's "single drive status byte" we now
  3645                                  			; check to see if we are in a single drive
  3646                                  			; system and the Application has "cleverly"
  3647                                  			; diddled the SDSB (Single Drive Status Byte)
  3648                                  			;
  3649                                  
  3650 00000CC5 2E803E[C501]02          		cmp	byte [cs:Single],2	   ; single drive system?
  3651 00000CCB 7517                    		jne	short Ignore_SDSB  ; no, jump down
  3652                                  
  3653 00000CCD 1E                      		push	ds		   ; yes...		
  3654 00000CCE 57                      		push	di
  3655 00000CCF 50                      		push	ax
  3656                                  
  3657 00000CD0 8A4505                  		mov	al,[DI+BDS.DriveLet] ; IF (Curr_drv == Req_drv)
  3658 00000CD3 88C4                    		mov	ah,al
  3659 00000CD5 31FF                    		xor	di,di
  3660 00000CD7 8EDF                    		mov	ds,di
  3661 00000CD9 86060405                		xchg	al,[LSTDRV]	    ; THEN swap(Curr_drv,Req_drv)
  3662 00000CDD 38C4                    		cmp	ah,al		    ; ELSE
  3663 00000CDF 58                      		pop	ax		    ;     swap(Curr_drv,Req_drv)	
  3664 00000CE0 5F                      		pop	di		    ;	  Issue Swap_dsk_msg	
  3665 00000CE1 1F                      		pop	ds
  3666 00000CE2 7403                    		je	short SingleRet	
  3667                                  
  3668                                  Ignore_SDSB:
  3669 00000CE4 E8400E                  		call	SWPDSK		; ask user for correct disk
  3670                                  
  3671                                  SingleRet:
  3672 00000CE7 5B                      		pop	BX		; restore registers
  3673 00000CE8 58                      		pop	AX
  3674 00000CE9 C3                      		retn			; return
  3675                                  
  3676                                  Single_Err_Ret:
  3677 00000CEA F9                      		stc			; set carry flage to indicate error
  3678 00000CEB 5F                      		pop	di		; restore current BDS
  3679 00000CEC 1F                      		pop	ds
  3680 00000CED EBF8                    		jmp	short SingleRet
  3681                                  
  3682                                  ;
  3683                                  ; BadDrive is called when sector specified is greater than last
  3684                                  ; sector on disk.
  3685                                  ; or when BDS is not found for drive
  3686                                  ;
  3687                                  
  3688                                  BadDrive:
  3689 00000CEF B008                    		mov	AL,8		; error code 'sector not found'
  3690 00000CF1 F9                      		stc			; indicate error
  3691                                  IORET:	
  3692 00000CF2 C3                      		retn			; return
  3693                                  
  3694                                  BogusSettle:
  3695 00000CF3 B00F                    		MOV	AL,NORMSETTLE	; someone has diddled the settle
  3696 00000CF5 E9B100                  		JMP	GotSlowSettle
  3697                                  
  3698                                  ;------------------------------------------------------------
  3699                                  ;
  3700                                  ;	DISK I/O HANDLER
  3701                                  ;
  3702                                  ;   On entry:
  3703                                  ;	AL = Drive Number (0-6)
  3704                                  ;	AH = Media Descriptor
  3705                                  ;	CX = sector count
  3706                                  ;	DX = first sector
  3707                                  ;	DS = CS
  3708                                  ;	ES:DI = transfer address
  3709                                  ;	[RFLAG] = operation (2 for read, 3 for write)
  3710                                  ;	[VERIFY] = 1 for verity after write
  3711                                  ;
  3712                                  ;   On exit:
  3713                                  ;	if successful carry flag = 0
  3714                                  ;	  else CF=1 and AL contains error code
  3715                                  ;
  3716                                  
  3717                                  DISKRD:		; 27/05/2018 - Retro DOS v3.0
  3718                                  		;mov	byte [CS:RFLAG],ROMRead	; set command to read
  3719 00000CF8 C606[5602]02            		mov	byte [RFLAG],ROMRead	 ; 11/04/2018
  3720                                  DISKIO:
  3721                                  		; 13/04/2018
  3722                                  		; 08/04/2018
  3723                                  		; Retro DOS v2.0 (IBMDOS 2.1, IBMBIO.COM)
  3724                                  
  3725                                  		;clc
  3726                                  		;jcxz	IORET
  3727                                  		
  3728                                  		;;mov	[CS:SPSAV],SP		; save the sp value
  3729                                  		;mov	[SPSAV],sp
  3730                                  
  3731 00000CFD 89FB                    		mov	BX,DI			; ES:BX is transfer address
  3732 00000CFF E82FFF                  		call	SETDRIVE		; map logical and physical
  3733 00000D02 72EB                    		jc	short BadDrive		; carry means BDS not found
  3734 00000D04 8A4510                  		mov	al,[DI+BDS.Mediad]
  3735 00000D07 2EA2[5402]              		mov	[CS:MedByt],al		; Preserve media byte for drive for use
  3736                                  						; in determining media change.
  3737 00000D0B E3E5                    		jcxz	IORET
  3738 00000D0D 2E8926[6A02]            		mov	[CS:SPSAV],SP		; save the sp value
  3739                                  
  3740                                  		; DX = Sector address (offset)
  3741                                  		; BX = Buffer address (offset)
  3742                                  		
  3743                                  ; Ensure that we are trying to access valid sectors on the drive
  3744                                  ;
  3745 00000D12 89D6                    		mov	SI,DX			; start with first sector
  3746 00000D14 01CE                    		add	SI,CX			; add in sector count
  3747 00000D16 035517                  		add	DX,[DI+BDS.HIDSEC]	; add in the hidden sectors
  3748 00000D19 3B750E                  		cmp	SI,[DI+BDS.DRVLIM]	; compare against max (volume size)
  3749 00000D1C 77D1                    		ja	short BadDrive		; if greater than max, error
  3750 00000D1E 2E890E[5802]            		mov	[CS:SECCNT],CX		; save sector count
  3751                                  
  3752                                  ;;Rev 3.30 Modification -----------------------------------------
  3753                                  ; SET UP POINTER TO DISK BASE TABLE IN [DPT]. WE CANNOT ASSUME THAT IOSETUP
  3754                                  ; WILL DO IT BECAUSE WE WILL SKIP THE SET UP STUFF WITH HARD DISKS.
  3755 00000D23 1E                      		PUSH	DS
  3756 00000D24 31C0                    		XOR	AX,AX
  3757 00000D26 8ED8                    		MOV	DS,AX
  3758 00000D28 C5367800                		LDS	SI,[DSKADR]		; CURRENT DISK PARM TABLE
  3759 00000D2C 2E8936[6202]            		MOV	[CS:DPT],SI
  3760 00000D31 2E8C1E[6402]            		MOV	[CS:DPT+2],DS
  3761 00000D36 1F                      		POP	DS
  3762                                  ;;End of Modification -----------------------------------------
  3763                                  
  3764                                  
  3765                                  ; For hard drives do not do media check or set DPT.
  3766                                  ;
  3767                                  
  3768 00000D37 F745290100              		test	word [DI+BDS.Flags],fNon_Removable
  3769 00000D3C 7509                    		jnz	short Skip_Setup
  3770                                  	
  3771 00000D3E E83AFF                  		CALL	CHECKSINGLE
  3772                                  
  3773                                  ;
  3774                                  ; Check to see if we have previously noted a change line.  The routine
  3775                                  ; returns if everything is OK.	Otherwise, it pops off the stack and returns
  3776                                  ; the proper error code.
  3777                                  ;
  3778                                  		;----------------------------------------|
  3779                                  		; Warning: Do not change the following. ;|
  3780                                  		;	   It gets patched in msinit	;|
  3781                                  							;|
  3782                                  DiskIO_PATCH:						;|
  3783 00000D41 E8790F                  		CALL	CheckLatchIO			;|
  3784                                  		;----------------------------------------|
  3785                                  ;
  3786                                  ; Set up tables and variables for I/O
  3787 00000D44 E82900                  		call	IOSETUP
  3788                                  ;
  3789                                  ; Now the settle values are correct for the following code
  3790                                  ;
  3791                                  Skip_Setup:
  3792 00000D47 89D0                    		mov	AX,DX		; setup locical sector for divide
  3793 00000D49 31D2                    		xor	DX,DX
  3794 00000D4B F77513                  		div	word [DI+BDS.SECLIM] ; divide by sectors per track
  3795 00000D4E FEC2                    		inc	DL
  3796 00000D50 2E8816[6602]            		mov	[CS:CURSEC],DL	; save current sector
  3797 00000D55 8B4D15                  		mov	CX,[DI+BDS.HDLIM]  ; get number of heads
  3798 00000D58 31D2                    		xor	DX,DX		; divide tracks by heads per cylinder
  3799 00000D5A F7F1                    		div	CX
  3800 00000D5C 2E8816[6702]            		mov	[CS:CURHD],DL	; save current head
  3801 00000D61 2EA3[6802]              		mov	[CS:CURTRK],AX	; save current track
  3802                                  ;
  3803                                  ; We are now set up for the I/O.  Normally, we consider the DMA boundary
  3804                                  ; violations here.  Not true.  We perform the operation as if everything is
  3805                                  ; symmetric; let the DISK INT handler worry about the DMA violations.
  3806                                  ;
  3807 00000D65 2EA1[5802]              		mov	AX,[CS:SECCNT]
  3808 00000D69 E87100                  		call	BLOCK
  3809 00000D6C E84100                  		call	DONE
  3810 00000D6F C3                      		retn
  3811                                  
  3812                                  ; 27/05/2018 - Retro DOS v3.0
  3813                                  
  3814                                  ; IOSetUp:
  3815                                  ;
  3816                                  ; IOSetUp does the following functions:
  3817                                  ;   *	Set the drive-last-accessed flag (for diskette only).  No need to
  3818                                  ;	update these flags for hard disks becuase we know a hard disk will
  3819                                  ;	not be removed.
  3820                                  ;   *	Set the proper last sector number in the Disk Parameter Table (DPT)
  3821                                  ;   *	Set the proper motor start up time in DPT
  3822                                  ;   *	Set the proper head settle time in the DPT
  3823                                  ;
  3824                                  ; Input:
  3825                                  ;	DS:DI -> current BDS.
  3826                                  ; Output:
  3827                                  ;	AX,CX,SI are destroyed.
  3828                                  ;
  3829                                  
  3830                                  IOSETUP:
  3831 00000D70 8A4504                  		MOV	AL,[DI+BDS.DriveNum]
  3832 00000D73 2EA2[5102]              		MOV	[CS:TIM_DRV],AL	; SAVE DRIVE LETTER
  3833                                  ;
  3834                                  ; determine proper head settle values
  3835                                  ;
  3836 00000D77 8CD9                    		mov	CX,DS
  3837 00000D79 2EC536[6202]            		LDS	SI,[CS:DPT]	; GET POINTER TO DISK BASE TABLE
  3838 00000D7E 2EA0[6002]              		MOV	AL,[CS:EOT]
  3839 00000D82 884404                  		mov	[SI+DISK_PARMS.DISK_EOT],AL	; bump for us
  3840 00000D85 8A440A                  		mov	AL,[SI+DISK_PARMS.DISK_MOTOR_STRT] 
  3841                                  					; preserve old motor start time
  3842 00000D88 2EA2[5B02]              		mov	[CS:MotorStartup],AL
  3843                                  ;
  3844                                  ; For 3.5" drives, both external as well as on the K09, we need to set the
  3845                                  ; Motor Start Time to 4. This checking for every I/O is going to affect
  3846                                  ; performance across the board, but is necessary!!
  3847                                  ;
  3848 00000D8C 06                      		push	es
  3849 00000D8D 8EC1                    		mov	es,cx		; ES:DI -> to current BDS
  3850 00000D8F 26807D2802              		cmp	byte [es:di+BDS.FormFactor],ffSmall
  3851 00000D94 7505                    		jnz	short Motor_Start_OK
  3852 00000D96 B004                    		mov	AL,4
  3853 00000D98 86440A                  		xchg	AL,[SI+DISK_PARMS.DISK_MOTOR_STRT]
  3854                                  Motor_Start_OK:
  3855 00000D9B 07                      		pop	ES
  3856                                  ;
  3857                                  ; DS:SI now points to disk parameter table.  Get current settle and set fast
  3858                                  ; settle
  3859                                  ;
  3860 00000D9C 30C0                    		XOR	AL,AL
  3861 00000D9E FEC0                    		INC	AL		; IBM WANTS FAST SETTLE = 1 - RS
  3862 00000DA0 864409                  		xchg	AL,[SI+DISK_PARMS.DISK_HEAD_STTL]
  3863                                  					; get settle and set up for fast
  3864 00000DA3 2EA2[5C02]              		mov	[CS:SettleCurrent],AL
  3865 00000DA7 B00F                    		MOV	AL,NORMSETTLE	; SOMEONE HAS DIDDLED THE SETTLE
  3866                                  GotSlowSettle:
  3867 00000DA9 8ED9                    		mov	DS,CX
  3868 00000DAB 2EA2[5D02]              		mov	[CS:SettleSlow],AL
  3869 00000DAF C3                      		retn
  3870                                  
  3871                                  ;
  3872                                  ; Set time of last access, and reset default values in the DPT.
  3873                                  ;
  3874                                  DONE:
  3875 00000DB0 F745290100              		test	word [DI+BDS.Flags],fNon_Removable
  3876 00000DB5 7525                    		jnz	short RETZ	; Do not set for non-removable Media
  3877 00000DB7 E87801                  		call	SET_TIM		; set time of last access for drive
  3878                                  ;
  3879                                  ; Restore head settle and EOT values
  3880                                  ;
  3881                                  DiddleBack:
  3882 00000DBA 50                      		push	ax			; preserve AX
  3883 00000DBB 8CDA                    		mov	DX,DS			; save DS in DX
  3884 00000DBD 2EA0[5C02]              		mov	AL,[cs:SettleCurrent]	; get value in registers
  3885 00000DC1 2E8A26[5B02]            		mov	AH,[cs:MotorStartup]
  3886 00000DC6 2EC536[6202]            		lds	SI,[CS:DPT]		; get pointer to DPT
  3887 00000DCB C6440409                		mov	byte [SI+DISK_PARMS.DISK_EOT],9 ; save values in DPT
  3888 00000DCF 884409                  		mov	[SI+DISK_PARMS.DISK_HEAD_STTL],AL
  3889 00000DD2 C6440302                		mov	byte [SI+DISK_PARMS.DISK_SECTOR_SIZ],2
  3890 00000DD6 88640A                  		mov	[SI+DISK_PARMS.DISK_MOTOR_STRT],AH
  3891 00000DD9 8EDA                    		mov	DS,DX			; restore DS
  3892 00000DDB 58                      		pop	ax			; restore AX
  3893                                  RETZ:
  3894 00000DDC C3                      		retn
  3895                                  
  3896                                  ;
  3897                                  ; Block reads or writes the number of sectors specified in AX
  3898                                  ; handling track boundaries.  For example, on an 8 sector per track
  3899                                  ; disk there might be a request to read 6 sectors starting at the 5th
  3900                                  ; sector.  Block breaks this request into a read of sectors 5-8 on
  3901                                  ; the first track and a read of sectors 1-2 on the next track.	Disk is
  3902                                  ; called to do the actual read.
  3903                                  ;
  3904                                  ;   Inputs:
  3905                                  ;	AX - number of sectors to be read
  3906                                  ;	DS:DI points to BDS for disk drive
  3907                                  ;	cs:CurSec - sector on track where read should start
  3908                                  ;	cs:CurTrk - track where read should start
  3909                                  ;	cs:CurHd - head for read
  3910                                  ;	ES:BX - transfer address
  3911                                  ; AX, CX, and BL are not preserved
  3912                                  ;
  3913                                  
  3914                                  BLOCK:
  3915 00000DDD 09C0                    		or	AX,AX		; see if any sectors to read
  3916 00000DDF 74FB                    		jz	short RETZ	; if not, return
  3917                                  ;;Rev 3.30 Modification -----------------------------------------
  3918                                  ; Fixed disk will not be restricted to the trk-by-trk basis.
  3919 00000DE1 F745290100              		test	word [DI+BDS.Flags], fNon_Removable
  3920 00000DE6 7406                    		jz	short BLOCK_FLOPPY
  3921 00000DE8 E82600                  		call	DISK
  3922 00000DEB 31C0                    		xor	ax,ax
  3923 00000DED C3                      		RETN
  3924                                  BLOCK_FLOPPY:
  3925                                  ;;End of Modification -----------------------------------------
  3926                                  ;
  3927                                  ; READ AT MOST 1 TRACK WORTH.  PERFORM MINIMIZATION AT SECTOR / TRACK
  3928                                  ;
  3929 00000DEE 8A4D13                  		mov	CL,[DI+BDS.SECLIM] ; get sectors per track
  3930 00000DF1 FEC1                    		inc	CL
  3931 00000DF3 2E2A0E[6602]            		sub	CL,[CS:CURSEC]	; set CX to number of sector after current
  3932 00000DF8 30ED                    		xor	CH,CH		;    sector on the current track
  3933 00000DFA 39C8                    		cmp	AX,CX		; is all of request on current track?
  3934 00000DFC 7302                    		jae	short GotMin	; no, jump down
  3935 00000DFE 89C1                    		mov	CX,AX	; yes, set number of sector on this track to AX
  3936                                  GotMin:
  3937                                  				; now
  3938                                  				; AX is the requested number of sectors to read
  3939                                  				; CX is the number that we can do on this track
  3940 00000E00 50                      		push	AX
  3941 00000E01 51                      		push	CX
  3942 00000E02 89C8                    		mov	AX,CX	; AL is number of sectors to read
  3943 00000E04 E80A00                  		call	DISK
  3944 00000E07 59                      		pop	CX
  3945 00000E08 58                      		pop	AX
  3946                                  
  3947                                  				; CX is the number of sectors just transferred
  3948 00000E09 29C8                    		sub	AX,CX	; reduce sectors-remaining by last I/O
  3949 00000E0B D0E1                    		shl	CL,1
  3950 00000E0D 00CF                    		add	BH,CL	; adjust transfer address
  3951 00000E0F EBCC                    		jmp	short BLOCK ; jump to do any remaining sectors
  3952                                  
  3953                                  
  3954                                  ; 27/05/2018 - Retro DOS v3.0
  3955                                  ;
  3956                                  ;  DISK:
  3957                                  ; Disk is called to read or write one or more sectors on a track.
  3958                                  ; Retries are make if an error occurs.
  3959                                  ;
  3960                                  ;    Input:
  3961                                  ;	AL - number of sector to be read/written (they must all be on one track)
  3962                                  ;	DS:DI points to BDS for the drive
  3963                                  ;	ES:BX is transfer address (must not cross 64k physical boundry)
  3964                                  ;	[RFLAG] is 2 for read and 3 for write
  3965                                  ;	[VERIFY] is 0 for normal, 1 for verify after write
  3966                                  ;	[CurTrk] is track (cylinder) to be read/written.
  3967                                  ;	[CurHd] is head to be used in operation.
  3968                                  ;	[CurSec] is sector to start read on.
  3969                                  ;
  3970                                  ; The following are overwritten: BP,
  3971                                  ;   Output:
  3972                                  ;	[SECCNT] is decrement by the number of sectors read or written
  3973                                  
  3974                                  DISK:
  3975 00000E11 BD0500                  		mov	BP,MAXERR	; set up retry count
  3976 00000E14 2E8A26[5602]            		MOV	AH,[CS:RFLAG]	;GET READ/WRITE INDICATOR
  3977                                  
  3978                                  RETRY:
  3979                                  				; AX is overwritten in int 13 call, so
  3980                                  				; to do a retry we need to save the
  3981                                  				; value by pushing on the stack
  3982 00000E19 50                      		push	AX
  3983                                  				; the next five lines of code put the
  3984                                  				; sector number in bit 5-0 of CL and the
  3985                                  				; cylinder number in CH and bits 7-6 of
  3986                                  				; CL.  The register must be set up in this
  3987                                  				; way for the bios.
  3988 00000E1A 2E8B16[6802]            		mov	DX,[CS:CURTRK]	;Load current cylinder
  3989                                  ;;Rev 3.30 Modification -----------------------------------------
  3990 00000E1F F745290100              		test	word [DI+BDS.Flags],fNon_Removable ;Fixed disk
  3991 00000E24 7409                    		jz	short DISK_NOT_MINI 	;no, skip this.
  3992                                  		;cmp	byte [DI+BDSM.isMini], 1
  3993 00000E26 837D4D01                		cmp	word [DI+BDSM.isMini], 1 ;Is this a mini disk?
  3994 00000E2A 7503                    		jnz	short DISK_NOT_MINI	;No. continue to next.
  3995 00000E2C 03554F                  		add	dx, [DI+BDSM.Hidden_Trks] ;else add hidden trks.
  3996                                  DISK_NOT_MINI:
  3997                                  ;;End of Modification -----------------------------------------
  3998 00000E2F D0CE                    		ror	DH,1 ; get high two bits of cylinder in correct place
  3999 00000E31 D0CE                    		ror	DH,1
  4000                                  
  4001 00000E33 2E0A36[6602]            		or	DH,[cs:CURSEC]	; get sector value
  4002 00000E38 89D1                    		mov	CX,DX ; put cylinder/sector values in correct register
  4003                                  				; get head value
  4004 00000E3A 86E9                    		xchg	CH,CL	; put bytes in correct place
  4005 00000E3C 2E8A36[6702]            		mov	DH,[CS:CURHD]
  4006                                  				; get drive number
  4007 00000E41 8A5504                  		mov	DL,[DI+BDS.DriveNum]
  4008                                  
  4009 00000E44 807D2805                		CMP	BYTE [DI+BDS.FormFactor],ffHardFile
  4010 00000E48 7414                    		JZ	short DO_Fast ; HARD FILES USE FAST SPEED
  4011                                  ;
  4012                                  ; The registers are now all set up for call on rom-bios.
  4013                                  ; The next dozen or so line determines whether we call Do_Fast or Do_Norm
  4014                                  ; for the actual I/O read.  Do_Fast calls FastSpeed for the actual I/O.
  4015                                  ; Do_Norm calls NormSpeed.  NormSpeed changes the value for the head settle
  4016                                  ; time in the disk parameter table to a larger value and then calls FastSpeed
  4017                                  ; to do the I/O.  So Do_Fast just has a shorter head settle time.
  4018                                  ;
  4019 00000E4A 2E803E[C101]FF          		CMP	byte [CS:STEP_DRV],-1
  4020                                  		;jz	short Do_Writej
  4021 00000E50 7459                    		jz	short DO_WRITE ; 14/06/2018
  4022                                  
  4023 00000E52 80FC02                  		cmp	AH,ROMRead	; For read...
  4024 00000E55 7407                    		je	short DO_Fast	;   ... alway use fast
  4025                                  
  4026 00000E57 80FC04                  		cmp	AH, ROMVerify	; For verify...
  4027 00000E5A 7402                    		je	short DO_Fast	;   ... alway use fast
  4028                                  
  4029                                  Do_Writej:
  4030 00000E5C EB4D                    		jmp	short DO_WRITE	; Jump down for write...
  4031                                  
  4032                                  DO_Fast:
  4033 00000E5E E8AB00                  		CALL	FASTSPEED	; do I/O carry set if error
  4034                                  TestErr:
  4035 00000E61 7262                    		jc	short DSKERR	; error -- get out
  4036                                  ; SET DRIVE AND TRACK OF LAST ACCESS
  4037 00000E63 2E8816[C101]            		mov	[CS:STEP_DRV],DL ; save the last drive accessed
  4038 00000E68 886D4C                  		mov	[DI+BDS.Track],CH ; save in BDS
  4039                                  
  4040                                  NO_SET:
  4041 00000E6B 2E813E[5602]0301        		cmp	word [CS:WRTVERIFY],103H ; Check for write and verify
  4042 00000E72 7448                    		jz	short DOVERIFY	; yes -- go do verify
  4043                                  NOVERIFY:
  4044 00000E74 58                      		pop	AX		; pop command and num sec. from stack
  4045 00000E75 80E13F                  		and	CL,03FH		; Eliminate cylinder bits from sector
  4046 00000E78 30E4                    		xor	AH,AH
  4047 00000E7A 2E2906[5802]            		sub	[CS:SECCNT],AX	; Reduce count of sectors to go
  4048 00000E7F 00C1                    		add	CL,AL		; Next sector
  4049 00000E81 2E880E[6602]            		mov	[CS:CURSEC],CL
  4050                                  					 ; See if sector/track limit reached
  4051 00000E86 3A4D13                  		cmp	CL,[DI+BDS.SECLIM]
  4052 00000E89 761E                    		jbe	short Disk_Ret	; yes, return
  4053                                  NextTrack:
  4054 00000E8B 2EC606[6602]01          		mov	byte [CS:CURSEC],1 ; Start with first sector of next track
  4055 00000E91 2E8A36[6702]            		mov	DH,[CS:CURHD]
  4056 00000E96 FEC6                    		inc	DH		; go to next head
  4057 00000E98 3A7515                  		cmp	DH,[DI+BDS.HDLIM] ; at head limit?
  4058 00000E9B 7207                    		jb	short NOXOR	; no, jump down
  4059 00000E9D 30F6                    		xor	DH,DH		; at head limit, reset to head zero ...
  4060 00000E9F 2EFF06[6802]            		inc	word [CS:CURTRK] ; 	and go to next head
  4061                                  NOXOR:
  4062 00000EA4 2E8836[6702]            		mov	[CS:CURHD],DH	; save new head number
  4063                                  Disk_Ret:
  4064 00000EA9 F8                      		clc			; successful return so clear error flag
  4065 00000EAA C3                      		retn			; all done
  4066                                  
  4067                                  ;
  4068                                  ; The request is for write.  Determine if we are talking about the same
  4069                                  ; track and drive.  If so, use the fast speed.
  4070                                  ;
  4071                                  DO_WRITE:
  4072 00000EAB 2E3A16[C101]            		cmp	DL,[CS:STEP_DRV] ; same drive?
  4073 00000EB0 7505                    		jnz	short DO_Norm 	 ; no, do normal speed
  4074 00000EB2 3A6D4C                  		cmp	CH,[DI+BDS.Track] ; same track on drive
  4075 00000EB5 74A7                    		jz	short DO_Fast	; yes, do fast speed
  4076                                  DO_Norm:
  4077 00000EB7 E83300                  		call	NORMSPEED	; use larger head settle time
  4078 00000EBA EBA5                    		jmp	SHORT TestErr	; test for error
  4079                                  
  4080                                  ;
  4081                                  ; we have a verify request also.  Get state info and go verify
  4082                                  ;
  4083                                  
  4084                                  DOVERIFY:
  4085 00000EBC 58                      		pop	AX		; get number of sectors from stack
  4086 00000EBD 50                      		push	AX		;    in non-detructive fashion
  4087 00000EBE B404                    		MOV	AH,ROMVerify	; REQUEST VERIFY
  4088 00000EC0 E84900                  		CALL	FASTSPEED	; MZ  2.21 change settle mode
  4089 00000EC3 73AF                    		JNC	short NOVERIFY
  4090                                  
  4091                                  ;
  4092                                  ; Need to special case the change-line error AH=06h.  If we get this, we
  4093                                  ; need to return it.
  4094                                  ;
  4095                                  	;----------------------------------------|
  4096                                  	; Warning: Do not change the following. ;|
  4097                                  	;	   It gets patched in msinit	;|
  4098                                  						;|
  4099                                  DSKERR:						;|
  4100 00000EC5 E83A0E                  		CALL	CheckIO 		;|
  4101                                  	;---------------------------------------;|
  4102                                  
  4103 00000EC8 E8D007                  		Call	AGAIN	; reset the disk and decrement retry cnt
  4104 00000ECB 7409                    		jz	short HARDERR ; if z flag set, did all retries-give up
  4105 00000ECD 80FC80                  		cmp	AH,80H		; timeout?
  4106 00000ED0 7404                    		jz	short HARDERR ; yes, jump to hard error
  4107                                  DSKERR1:
  4108 00000ED2 58                      		pop	AX		; Restore sector count
  4109 00000ED3 E943FF                  		jmp	RETRY		;     and try again
  4110                                  
  4111                                  HARDERR:
  4112 00000ED6 E84100                  		CALL	MAPERROR
  4113                                  
  4114                                  HARDERR2:			; for routines that call MapError themselves
  4115 00000ED9 2EC606[5102]FF          		mov	byte [CS:TIM_DRV],-1 ;Force a media check through ROM
  4116 00000EDF 2E8B0E[5802]            		mov	CX,[CS:SECCNT]	;Get count of sectors to go
  4117 00000EE4 2E8B26[6A02]            		mov	SP,[CS:SPSAV]	;Recover entry stack pointer
  4118                                  ;
  4119                                  ; Since we are performing a non-local goto, restore the disk parameters
  4120                                  ;
  4121                                  MedByt_OK:
  4122 00000EE9 E8CEFE                  		call	DiddleBack
  4123 00000EEC C3                      		retn			;and return
  4124                                  
  4125                                  ;
  4126                                  ; change settle value from SettleCurrent to whatever is appropriate
  4127                                  ;
  4128                                  NORMSPEED:
  4129 00000EED 1E                      		push	DS		; save two registers
  4130 00000EEE 50                      		push	AX
  4131                                  				; change value in current disk parm tbl
  4132 00000EEF 2EA0[5D02]              		mov	AL,[CS:SettleSlow] 
  4133 00000EF3 2EC536[6202]            		lds	SI,[CS:DPT]	; current disk parm table
  4134 00000EF8 884409                  		mov	[SI+DISK_PARMS.DISK_HEAD_STTL],AL
  4135 00000EFB 58                      		pop	AX		; restore command and sector count
  4136 00000EFC 1F                      		pop	DS
  4137 00000EFD E80C00                  		call	FASTSPEED	; do I/0
  4138 00000F00 1E                      		push	DS	; restore the value in disk parm table
  4139 00000F01 2EC536[6202]            		lds	SI,[CS:DPT]
  4140 00000F06 C6440901                		mov	byte [SI+DISK_PARMS.DISK_HEAD_STTL],1 ; 1 is fast settle
  4141 00000F0A 1F                      		pop	DS
  4142 00000F0B C3                      		retn
  4143                                  
  4144                                  FASTSPEED:
  4145                                  ;
  4146                                  ; If the drive has been marked as too big (i.e. starting sector of the
  4147                                  ; partition is > 16 bits, then ALWAYS return drive not ready.
  4148                                  ;
  4149 00000F0C F6451980                		TEST	BYTE [DI+BDS.FatSiz],fTOOBIG
  4150 00000F10 7503                    		JNZ	short NotReady
  4151                                  
  4152 00000F12 CD13                    		int	13h		; call rom-bios disk routines
  4153                                  Death:
  4154 00000F14 C3                      		retn
  4155                                  NotReady:
  4156 00000F15 F9                      		stc			; set carry to indicate error
  4157 00000F16 B480                    		mov	AH,80h		; put error code in AH
  4158 00000F18 EBFA                    		jmp	short Death	; jump to ret
  4159                                  
  4160                                  ;
  4161                                  ; Map error returned by ROM into corresponding code to be returned to
  4162                                  ; DOS in AL.
  4163                                  ;
  4164                                  MAPERROR:
  4165 00000F1A 51                      		push	CX		; save cx
  4166 00000F1B 0E                      		push	CS
  4167 00000F1C 07                      		pop	ES		; make ES the local segment
  4168 00000F1D 88E0                    		mov	AL,AH		; move error code into AL
  4169 00000F1F 2EA2[7802]              		mov	[CS:LSTERR],AL	; terminate list with error code
  4170 00000F23 B90800                  		mov	CX,NUMERR	; number of possible error conditions
  4171 00000F26 BF[7102]                		mov	DI,ERRIN	; point to error conditions
  4172 00000F29 F2AE                    		repne	SCASB
  4173 00000F2B 2E8A4507                		mov	AL,[CS:DI+NUMERR-1] ; get translation
  4174 00000F2F 59                      		pop	cx		; restore cx
  4175 00000F30 F9                      		stc			; flag error condition
  4176 00000F31 C3                      		retn
  4177                                  
  4178                                  ;
  4179                                  ; Set the time of last access for this drive. This is done only for removable
  4180                                  ; media.
  4181                                  ;
  4182                                  SET_TIM:
  4183 00000F32 50                      		push	ax
  4184 00000F33 30E4                    		xor	AH, AH		; set command to get time
  4185 00000F35 CD1A                    		int	1Ah		; call rom-bios timer function
  4186 00000F37 08C0                    		or	AL,AL		; is there 24 hour rollover?
  4187 00000F39 7405                    		jz	short NOROLL3 	; no, skip down
  4188 00000F3B 2EFF06[DA05]            		inc	word [CS:DAYCNT] ; yes, then increment DayCnt
  4189                                  NOROLL3:
  4190                                  ; We have the new time. If we see that the time has passed, then we reset
  4191                                  ; the threshold counter...
  4192 00000F40 3B554D                  		cmp	DX,[DI+BDS.TIM_LO] ; Did any time pass?
  4193 00000F43 7505                    		jnz	short SetAccess	; yes, update access time
  4194 00000F45 3B4D4F                  		cmp	CX,[DI+BDS.TIM_HI] ; now look at the high bits
  4195 00000F48 740C                    		jz	short Done_Set	; if equal then no time passed
  4196                                  SetAccess:				; we get here if some time has passed
  4197                                  					; zero AccessCount to show time passage
  4198 00000F4A 2EC606[5002]00          		mov	byte [CS:AccessCount],0
  4199 00000F50 89554D                  		MOV	[DI+BDS.TIM_LO],DX ; save low time bits
  4200 00000F53 894D4F                  		MOV	[DI+BDS.TIM_HI],CX ; save high time bit
  4201                                  Done_Set:
  4202 00000F56 F8                      		clc			; indicate no error
  4203 00000F57 58                      		pop	ax		; restore AX register
  4204 00000F58 C3                      		retn
  4205                                  
  4206                                  ; 28/05/2018 - Retro DOS v3.0
  4207                                  
  4208                                  ;
  4209                                  ; This is the true DISK INT handler.  We parse the request to see if there is
  4210                                  ; a DMA violation.  If so, depending on the function, we:
  4211                                  ;   READ/WRITE	Break the request into three pieces and move the middle one
  4212                                  ;	into our internal buffer.
  4213                                  ;   FORMAT	Copy the format table into the buffer
  4214                                  ;   VERIFY	Point the transfer address into the buffer
  4215                                  ;
  4216                                  ; This is the biggest bogosity of all.	The IBM controller does NOT handle
  4217                                  ; operations that cross physical 64K boundaries.  In these cases, we copy
  4218                                  ; the offending sector into the buffer below and do the I/O from there.
  4219                                  ;
  4220                                  
  4221                                  ;;Rev 3.30 Modification -----------------------------------------
  4222                                  ;To handle the INT 13h, AH = 8 Problem.
  4223                                  ;Save Registers here.
  4224 00000F59 0000                    Save_AX:   DW  0
  4225 00000F5B 0000                    Save_BX:   DW  0
  4226 00000F5D 0000                    Save_CX:   DW  0
  4227 00000F5F 0000                    Save_DX:   DW  0
  4228 00000F61 0000                    Save_DI:   DW  0
  4229 00000F63 0000                    Save_SI:   DW  0
  4230 00000F65 0000                    Save_BP:   DW  0
  4231 00000F67 0000                    Save_DS:   DW  0
  4232 00000F69 0000                    Save_ES:   DW  0
  4233 00000F6B 0000                    Prev_DX:   DW  0
  4234 00000F6D 0000                    Save_Flag: DW  0
  4235                                  ;;End of Modification -----------------------------------------
  4236                                  
  4237                                  ;
  4238                                  ; Block13:
  4239                                  ;
  4240                                  ;   Entry conditions:
  4241                                  ;	AH = function
  4242                                  ;	AL = number of sectors
  4243                                  ;	ES:BX = DMA address
  4244                                  ;	CX = packed track and sector
  4245                                  ;	DX = head and drive
  4246                                  ;   Output conditions:
  4247                                  ;	NO DMA violation.
  4248                                  ;
  4249                                  
  4250                                  Block13:
  4251                                  ;
  4252                                  ; Let the operation proceed.  If there is a DMA violation, then we do things.
  4253                                  ;
  4254 00000F6F 2EA3[C000]              		mov	 [cs:PrevOper],AX	; save request
  4255 00000F73 9C                      		pushf				; preserve the flags
  4256 00000F74 80FC05                  		cmp	AH,ROMFormat		; format request?
  4257 00000F77 750A                    		jnz	short Not_Format	;    no, skip down
  4258                                  
  4259                                  	; Set changed by format bit for all logical drives using this physical drive
  4260                                  		;---------------------------------------------------------|
  4261                                  		; Warning: Do Not Change the following. 		  |
  4262                                  		; It gets patched in at INIT time			  |
  4263                                  Changed_Patch:
  4264 00000F79 2EC706[5202]4001        		mov	word [cs:FlagBits],fChanged_By_Format+fChanged
  4265 00000F80 E8300E                  		call	Set_Changed_DL	; Indicate that media changed by format
  4266                                  		;							  |
  4267                                  		;---------------------------------------------------------|
  4268                                  
  4269                                  Not_Format:
  4270                                  ;;Rev 3.30 Modification -----------------------------------------
  4271 00000F83 80FC08                  		cmp	ah, 8			; Read Driver Parm ?
  4272 00000F86 7412                    		je	short Bus_Problem
  4273 00000F88 80FC15                  		cmp	ah, 15h
  4274 00000F8B 740D                    		je	short Bus_Problem
  4275 00000F8D 2EFF1E[B400]            		CALL	far [CS:ORIG13]		; SIMULATE INT 13
  4276 00000F92 7203                    		JC	short GOTERR13_br	; ERROR?
  4277                                  		;14/06/2018
  4278 00000F94 CA0200                  		RETF	2			; NO, RETURN AND CLEAR FLAGS
  4279                                  
  4280                                  GOTERR13_br: 
  4281 00000F97 E98000                  		jmp	GotErr13
  4282                                  
  4283                                  ;Some machines have a problem with Int 13h function=8
  4284                                  ;This function does not reset the common buses after the execution.
  4285                                  ;To solve this problem, when we detect AH=8h, then we will save the result
  4286                                  ;and will issue AH=1 (Read Status) call to reset the buses.
  4287                                  
  4288                                  Bus_Problem:
  4289 00000F9A 2E8916[6B0F]            		mov	[cs:Prev_DX], DX	;save orignal drive number
  4290 00000F9F 2EFF1E[B400]            		call	far [CS:ORIG13]		;Do "Read drive parm"
  4291                                  
  4292 00000FA4 2EA3[590F]              		mov	[cs:Save_AX], AX	;Save registers,flag
  4293 00000FA8 2E891E[5B0F]            		mov	[cs:Save_BX], BX
  4294 00000FAD 2E890E[5D0F]            		mov	[cs:Save_CX], CX
  4295 00000FB2 2E8916[5F0F]            		mov	[cs:Save_DX], DX
  4296 00000FB7 2E893E[610F]            		mov	[cs:Save_DI], DI
  4297 00000FBC 2E8936[630F]            		mov	[cs:Save_SI], SI
  4298 00000FC1 2E892E[650F]            		mov	[cs:Save_BP], BP
  4299 00000FC6 2E8C1E[670F]            		mov	[cs:Save_DS], DS
  4300 00000FCB 2E8C06[690F]            		mov	[cs:Save_ES], ES
  4301 00000FD0 9C                      		pushf
  4302 00000FD1 2E8F06[6D0F]            		pop	word [cs:Save_Flag]
  4303                                  
  4304 00000FD6 2E8B16[6B0F]            		mov	dx, [cs:Prev_DX]	;restore orignal drive
  4305 00000FDB 9C                      		pushf
  4306 00000FDC B401                    		mov	ah, 1			;Read Status.
  4307 00000FDE 2EFF1E[B400]            		call	far [CS:ORIG13]		;Reset the bus as a side effect
  4308                                  
  4309 00000FE3 2EA1[590F]              		mov	AX, [cs:Save_AX]	;restore registers,flag
  4310 00000FE7 2E8B1E[5B0F]            		mov	BX, [cs:Save_BX]
  4311 00000FEC 2E8B0E[5D0F]            		mov	CX, [cs:Save_CX]
  4312 00000FF1 2E8B16[5F0F]            		mov	DX, [cs:Save_DX]
  4313 00000FF6 2E8B3E[610F]            		mov	DI, [cs:Save_DI]
  4314 00000FFB 2E8B36[630F]            		mov	SI, [cs:Save_SI]
  4315 00001000 2E8B2E[650F]            		mov	BP, [cs:Save_BP]
  4316 00001005 2E8E1E[670F]            		mov	DS, [cs:Save_DS]
  4317 0000100A 2E8E06[690F]            		mov	ES, [cs:Save_ES]
  4318 0000100F 2EFF36[6D0F]            		push	word [cs:Save_Flag]
  4319 00001014 9D                      		popf
  4320 00001015 7203                    		jc	short GotErr13		;AH=8 had been an error?
  4321                                  		;14/06/2018
  4322 00001017 CA0200                  		retf	2
  4323                                  ;
  4324                                  ; Some kind of error occurred.	See if it is DMA violation
  4325                                  ;
  4326                                  GotErr13:
  4327 0000101A 9C                      		pushf
  4328 0000101B 80FC09                  		cmp	AH, 09h			; is error DMA error code?
  4329 0000101E 7502                    		JNZ	short CHECK_ECC
  4330 00001020 EB58                    		JMP	short GotDMAErr
  4331                                  CHECK_ECC:
  4332 00001022 80FC11                  		CMP	AH,11H
  4333 00001025 7404                    		JZ	short OK11
  4334 00001027 9D                      		POPF
  4335                                  		;14/06/2018
  4336 00001028 CA0200                  		RETF	2
  4337                                  ;
  4338                                  ; We have an error status 11h.	This indicates an ECC-corrected error.	Note
  4339                                  ; that this indicates that the data is PROBABLY correct but not CERTAINLY
  4340                                  ; correct. The ROMs on PC-1s and PC_XTs have a 'bug' in that if an ECC error
  4341                                  ; occurs for a multi-sector read, only the sectors up to the one where the
  4342                                  ; error occurred are read in. We have no way of knowing how many were read in
  4343                                  ; this case, so we redo the operation, reading one sector at a time. If we
  4344                                  ; get an ECC error on reading one sector, we ignore the error because the
  4345                                  ; sector has been read in.
  4346                                  ;
  4347                                  
  4348                                  OK11:
  4349                                  ;		popf			; restore flags
  4350                                  ;;Rev 3.30 Modification -----------------------------------------
  4351                                  ; Here, it is better reset the system. So, we are going to
  4352                                  ; call Orig13 again
  4353 0000102B B400                    		mov	ah,0
  4354 0000102D 2EFF1E[B400]            		call	far [CS:ORIG13]	;reset. Don't care about result
  4355                                  ;;End of Modification -----------------------------------------
  4356                                  
  4357 00001032 2EA1[C000]              		mov	ax,[cs:PrevOper] ; Retrieve request
  4358                                  ;
  4359                                  ; This will provide a termination point.
  4360                                  ;
  4361 00001036 3C01                    		cmp	AL,1		; If request for one sector, assume OK
  4362 00001038 7505                    		jnz	short ECC_Err_Handle ; more than one sector -- jump down
  4363 0000103A 30E4                    		xor	AH,AH		; clear carry too!
  4364                                  		;14/06/2018
  4365 0000103C CA0200                  		retf	2
  4366                                  
  4367                                  ECC_Err_Handle:
  4368 0000103F 53                      		push	bx
  4369 00001040 51                      		push	cx
  4370 00001041 52                      		push	dx
  4371 00001042 2EA2[C200]              		mov	[cs:Number_Of_Sec],AL
  4372                                  Loop_ECC:
  4373 00001046 2EA1[C000]              		mov	AX,[CS:PrevOper] ; set command to previos command
  4374 0000104A B001                    		mov	AL,1		 ;     but request only one sector
  4375                                  ;
  4376                                  ; we do reads one sector at a time. this ensures that we will eventually
  4377                                  ; finish the request since ecc errors on 1 sector do read in that sector.
  4378                                  ;
  4379                                  ; we need  some "intelligence" in the ecc handler to handle reads
  4380                                  ; that attempt to read more sectors than are available on a particular
  4381                                  ; track.
  4382                                  ; we call check_wrap to set up the sector #, head # and cylinder # for
  4383                                  ; this request.
  4384                                  ; at this point, all registers are set up for the call to orig13, except
  4385                                  ; that there maybe a starting sector number that is bigger than the number
  4386                                  ; of sectors on a track.
  4387                                  ;
  4388 0000104C E84707                  		CALL	Check_Wrap	; see if wrapping around cylinder
  4389                                  
  4390 0000104F 9C                      		pushf			; save flags
  4391 00001050 2EFF1E[B400]            		call	far [CS:ORIG13]	; call original rom-bios code
  4392                                  ;;Rev 3.30 Modification ------------------------------------------------------
  4393 00001055 730D                    		JNC	short OK11_Op
  4394 00001057 80FC11                  		CMP	AH,11H		; ONLY ALLOW ECC ERRORS
  4395 0000105A 7517                    		JNZ	short OK11_EXIT_err ; Other error?
  4396 0000105C B400                    		mov	ah,0		; ECC error. Reset it again.
  4397 0000105E 9C                      		pushf
  4398 0000105F 2EFF1E[B400]            		call	far [CS:ORIG13]
  4399                                  OK11_Op:
  4400                                  					; adjust number of sectors for one read
  4401 00001064 2EFE0E[C200]            		dec	byte [CS:Number_Of_Sec]	
  4402 00001069 7409                    		jz	short OK11_Exit	; all done?
  4403 0000106B FEC1                    		inc	CL		; advance sector number
  4404 0000106D FEC7                    		inc	BH		; add 200H to address
  4405 0000106F FEC7                    		inc	BH
  4406 00001071 EBD3                    		jmp	short Loop_ECC	; and around for reading another sector
  4407                                  
  4408                                  OK11_EXIT_err:
  4409 00001073 F9                      		stc			; Set carry bit again.
  4410                                  ;;End of Modification ------------------------------------------------------
  4411                                  
  4412                                  OK11_Exit:
  4413 00001074 5A                      		pop	dx
  4414 00001075 59                      		pop	cx
  4415 00001076 5B                      		pop	bx
  4416                                  		;14/06/2018
  4417 00001077 CA0200                  		retf	2
  4418                                  
  4419                                  ;
  4420                                  ; we truly have a DMA violation.  Restore register AX and retry the
  4421                                  ; operation as best we can.
  4422                                  ;
  4423                                  GotDMAErr:
  4424 0000107A 58                      		pop	AX		; clean up stack
  4425 0000107B 2EA1[C000]              		mov	AX,[cs:PrevOper] ; restore command
  4426 0000107F FB                      		sti			; restore interrupts
  4427 00001080 80FC02                  		cmp	AH,ROMRead	; determine the command
  4428 00001083 7266                    		jb	short IntDone
  4429 00001085 80FC04                  		cmp	AH,ROMVerify
  4430 00001088 7439                    		jz	short IntVerify
  4431 0000108A 80FC05                  		cmp	AH,ROMFormat
  4432 0000108D 7446                    		jz	short IntFormat
  4433 0000108F 775A                    		ja	short IntDone
  4434                                  ;
  4435                                  ; We are doing a read/write call.  Check for DMA problems
  4436                                  ;
  4437 00001091 52                      		push	dx		; save registers we overwrite
  4438 00001092 51                      		push	cx
  4439 00001093 53                      		push	bx
  4440 00001094 50                      		push	ax
  4441                                  
  4442 00001095 55                      		push	BP
  4443 00001096 89E5                    		mov	BP,SP
  4444 00001098 8CC2                    		mov	DX,ES		; Check for 64k boundary error
  4445                                  
  4446 0000109A D1E2                    		shl	DX,1
  4447 0000109C D1E2                    		shl	DX,1
  4448 0000109E D1E2                    		shl	DX,1
  4449 000010A0 D1E2                    		shl	DX,1		; Segment converted to absolute address
  4450                                  
  4451 000010A2 01DA                    		add	DX,BX		; Combine with offset
  4452 000010A4 81C2FF01                		add	DX,511		; simulate a transfer
  4453                                  ;
  4454                                  ; If carry is set, then we are within 512 bytes of the end of the segment.
  4455                                  ; We skip the first transfer and perform the remaining buffering and transfer
  4456                                  ;
  4457 000010A8 7306                    		JNC	short NO_SKIP_FIRST
  4458 000010AA 8A7609                  		mov	DH,[bp+INT13FRAME.olddx+1] ; set correct head number
  4459 000010AD E99A00                  		jmp	Buffer
  4460                                  
  4461                                  NO_SKIP_FIRST:
  4462                                  ;
  4463                                  ; DX is the physical 16 bits of start of transfer.  Compute remaining
  4464                                  ; sectors in segment.
  4465                                  ;
  4466 000010B0 D0EE                    		shr	DH,1		; DH = number of sectors before address
  4467 000010B2 B480                    		mov	AH,128		; AH = max number of sectors in segment
  4468 000010B4 28F4                    		sub	AH,DH
  4469                                  ;
  4470                                  ; AH is now the number of sectors that we can successfully write in this
  4471                                  ; segment.  If this number is above or equal to the requested number, then we
  4472                                  ; continue the operation as normal.  Otherwise, we break it into pieces.
  4473                                  ;
  4474 000010B6 38C4                    		cmp	AH,AL		; can we fit it in?
  4475 000010B8 7236                    		jb	short DoBlock	; no, perform blocking.
  4476                                  ;
  4477                                  ; Yes, the request fits.  Let it happen
  4478                                  ;
  4479 000010BA 8A7609                  		MOV	DH,[BP+INT13FRAME.olddx+1] ; SET UP HEAD NUMBER
  4480 000010BD E89707                  		call	DoINT
  4481 000010C0 E9F100                  		jmp	Bad13
  4482                                  ;
  4483                                  ; Verify the given sectors.  Place the buffer pointer into our space.
  4484                                  ;
  4485                                  IntVerify:
  4486 000010C3 06                      		push	es
  4487 000010C4 53                      		push	bx
  4488 000010C5 0E                      		push	CS
  4489 000010C6 07                      		pop	ES
  4490                                  DoSimple:
  4491 000010C7 BB[8202]                		mov	BX,DiskSector
  4492 000010CA 9C                      		pushf
  4493 000010CB 2EFF1E[B400]            		call	far [CS:ORIG13]
  4494 000010D0 5B                      		pop	bx
  4495 000010D1 07                      		pop	es
  4496                                  		;14/06/2018
  4497 000010D2 CA0200                  		retf	2
  4498                                  
  4499                                  ;
  4500                                  ; Format operation.  Copy the parameter table into memory
  4501                                  ;
  4502                                  IntFormat:
  4503 000010D5 06                      		push	es
  4504 000010D6 53                      		push	bx
  4505 000010D7 56                      		push	si
  4506 000010D8 57                      		push	di
  4507 000010D9 1E                      		push	ds
  4508 000010DA 06                      		push	ES
  4509 000010DB 0E                      		push	CS
  4510 000010DC 07                      		pop	ES
  4511 000010DD 1F                      		pop	DS
  4512 000010DE 89DE                    		mov	SI,BX
  4513 000010E0 BF[8202]                		mov	DI,DiskSector
  4514 000010E3 E86807                  		call	Move
  4515 000010E6 1F                      		pop	ds
  4516 000010E7 5F                      		pop	di
  4517 000010E8 5E                      		pop	si
  4518 000010E9 EBDC                    		jmp	short DoSimple
  4519                                  ;
  4520                                  ; Inline continuation of operation
  4521                                  ;
  4522                                  IntDone:
  4523 000010EB 2EFF2E[B400]            		jmp	far [CS:ORIG13]
  4524                                  ;
  4525                                  ; We can't fit the request into the entire block.  Perform the operation on
  4526                                  ; the first block.
  4527                                  ;
  4528                                  ;
  4529                                  ; DoBlock is modified to correctly handle multi-sector disk I/O. 
  4530                                  ; Old DoBlock had added the number of sectors I/Oed (AH in Old DoBlock) after
  4531                                  ; the DoInt call to CL.  Observing only the lower 6 bits of CL(=max. 64) can
  4532                                  ; represent a starting sector, if AH was big, then CL would be clobbered.
  4533                                  ; By the way, we still are going to use CL for this purpose since Checkwrap
  4534                                  ; routine will use it as an input.  To prevent CL from being clobbered, a 
  4535                                  ; safe number of sectors should be calculated like "63 - # of sectors/track".
  4536                                  ; DoBlock will handle the first block of requested sectors within the
  4537                                  ; boundary of this safe value.
  4538                                  
  4539                                  ;Try to get the # of sectors/track from BDS via Rom drive number.
  4540                                  ;For any mini disks installed, here we have to pray that they have the
  4541                                  ;same # of sector/track as the main DOS partition disk drive.
  4542                                  
  4543                                  DoBlock:
  4544                                  ;;Rev 3.30 Modification ------------------------------------------------------
  4545                                  		;mov	dx,[bp+INT13FRAME] 	;set head #
  4546 000010F0 8B5608                  		mov	dx,[bp+INT13FRAME.olddx] ;set head # ; 17/07/2019
  4547 000010F3 57                      		push	di					
  4548 000010F4 1E                      		push	ds					
  4549 000010F5 50                      		push	ax		;AH=# of sectors before DMA err
  4550                                  					;AL - User requested # of sectors
  4551 000010F6 2EC606[C201]01          		mov	byte [CS:PHYS_DRV],1				
  4552 000010FC 88D0                    		mov	al, dl							
  4553 000010FE E830FB                  		call	SETDRIVE	;get BDS pointer for this DISK. 
  4554 00001101 58                      		pop	ax							
  4555 00001102 2EC606[C201]00          		mov	byte [CS:PHYS_DRV],0				
  4556 00001108 F745290100              		test	word [DI+BDS.Flags],fNon_Removable ;don't have to worry
  4557 0000110D 7504                    		jnz	short DoBlockHard ;about floppies. They are track by
  4558                                  					;track operations	
  4559 0000110F 88E0                    		mov	al, ah		;set al = ah for floppies
  4560 00001111 EB0F                    		jmp	short DoBlockCont			
  4561                                  DoBlockHard:					
  4562 00001113 51                      		push	cx				
  4563 00001114 31C9                    		xor	cx, cx				
  4564 00001116 8B4D13                  		mov	cx, [DI+BDS.SECLIM] ;# of sectors/track
  4565 00001119 B53F                    		mov	ch, 63						
  4566 0000111B 28CD                    		sub	ch, cl						
  4567 0000111D 88E8                    		mov	al, ch						
  4568 0000111F 86E0                    		xchg	ah, al		;now ah - safe # of sectors
  4569                                  					;al - # of sectors before DMA err
  4570 00001121 59                      		pop	cx							
  4571                                  DoBlockCont:								
  4572 00001122 1F                      		pop	ds							
  4573 00001123 5F                      		pop	di							
  4574                                  DoBlockContinue:							
  4575 00001124 38C4                    		cmp	ah, al		;if safe_# >= #_of_sectors_to_go_before DMA,
  4576 00001126 7305                    		jae	short DoBlocklast ;then #_of_sectors_to_go as it is for DoInt.
  4577 00001128 50                      		push	ax		;save AH, AL				
  4578 00001129 88E0                    		mov	al, ah		;Otherwise, set al to ah to operate.
  4579                                  			;DoInt will set AH to a proper function in [BP.Oldax]	
  4580 0000112B EB03                    		jmp	short DoBlockDoInt 
  4581                                  DoBlocklast:						
  4582 0000112D 88C4                    		mov	ah, al					
  4583 0000112F 50                      		push	ax		;save AH	
  4584                                  DoBlockDoInt:				;let AH=AL=# of sectors this shot
  4585 00001130 E82407                  		CALL	DoINT							 
  4586 00001133 727F                    		JC	short Bad13	;something happened, bye!	 
  4587 00001135 58                      		pop	ax
  4588                                  					;decrement by the successful operation							 
  4589 00001136 286602                  		SUB	BYTE [BP+INT13FRAME.oldax], AH 	
  4590 00001139 00E1                    		ADD	CL,AH		;advance sector number. Safety guaranteed.	
  4591 0000113B 00E7                    		ADD	BH,AH		;advance DMA address			
  4592 0000113D 00E7                    		ADD	BH,AH		;twice for 512 byte sectors.	
  4593 0000113F 38C4                    		cmp	ah, al		;check the previous value	
  4594 00001141 7407                    		je	short Buffer	;if #_of_sectors_to_go < safe_#, 
  4595                                  					; then we are done already. 
  4596 00001143 28E0                    		sub	al, ah		;otherwise, 
  4597                                  					; #_sector_to_go = #_of_sector_to_go - safe_#  
  4598 00001145 E84E06                  		call	Check_Wrap	;get new CX, DH for the next operation. 		  
  4599 00001148 EBDA                    		jmp	short DoBlockContinue ;handles next sectors left.			
  4600                                  ;;End of Modification ------------------------------------------------------
  4601                                  ;
  4602                                  Buffer:
  4603 0000114A 53                      		push	BX
  4604 0000114B 8A6603                  		mov	AH,[BP+INT13FRAME.oldax+1]
  4605 0000114E 80FC03                  		cmp	AH,ROMWrite
  4606 00001151 7525                    		jnz	short DoRead
  4607                                  ;
  4608                                  ; Copy the offending sector into local buffer
  4609                                  ;
  4610 00001153 1E                      		push	ds
  4611 00001154 06                      		push	es
  4612 00001155 56                      		push	si
  4613 00001156 57                      		push	di
  4614 00001157 0E                      		push	CS		; exchange segment registers
  4615 00001158 06                      		push	ES
  4616 00001159 1F                      		pop	DS
  4617 0000115A 07                      		pop	ES
  4618 0000115B BF[8202]                		mov	DI,DiskSector	; where to move
  4619 0000115E 57                      		push	DI		; save it
  4620 0000115F 89DE                    		mov	SI,BX		; source
  4621 00001161 E8EA06                  		call	Move
  4622 00001164 5B                      		pop	BX		; new transfer address
  4623 00001165 5F                      		pop	di
  4624 00001166 5E                      		pop	si
  4625 00001167 B001                    		mov	AL,1
  4626 00001169 8A5608                  		mov	DL,[BP+INT13FRAME.olddx] ; set drive number
  4627 0000116C E82706                  		call	Check_Wrap	; check for head or cylinder wrap
  4628                                  ;
  4629                                  ;   AH is function
  4630                                  ;   AL is 1 for single sector transfer
  4631                                  ;   ES:BX is local transfer addres
  4632                                  ;   CX is track/sector number
  4633                                  ;   DX is head/drive number
  4634                                  ;   SI,DI unchanged
  4635                                  ;
  4636 0000116F E8E506                  		CALL	DoINT
  4637 00001172 07                      		pop	es
  4638 00001173 1F                      		pop	ds
  4639 00001174 723E                    		jc	short Bad13	; go clean up
  4640 00001176 EB26                    		jmp	SHORT DoTail
  4641                                  ;
  4642                                  ; Reading a sector.  Do INT first, then move things around
  4643                                  ;
  4644                                  DoRead:
  4645 00001178 06                      		push	es
  4646 00001179 53                      		push	bx
  4647 0000117A 0E                      		push	CS
  4648 0000117B 07                      		pop	ES
  4649 0000117C BB[8202]                		mov	BX,DiskSector
  4650 0000117F B001                    		mov	AL,1
  4651 00001181 8A5608                  		mov	DL,[BP+INT13FRAME.olddx] ; set drive number
  4652 00001184 E80F06                  		call	Check_Wrap	; check for head or cylinder wrap
  4653                                  ;
  4654                                  ;   AH = function
  4655                                  ;   AL = 1 for single sector
  4656                                  ;   ES:BX points to local buffer
  4657                                  ;   CX, DX are track/sector, head/drive
  4658                                  ;
  4659 00001187 E8CD06                  		CALL	DoINT
  4660 0000118A 5B                      		pop	bx
  4661 0000118B 07                      		pop	es
  4662 0000118C 7226                    		jc	short Bad13	; error => clean up
  4663 0000118E 1E                      		push	ds
  4664 0000118F 56                      		push	si
  4665 00001190 57                      		push	di
  4666 00001191 0E                      		push	CS
  4667 00001192 1F                      		pop	DS
  4668 00001193 89DF                    		mov	DI,BX
  4669 00001195 BE[8202]                		mov	SI,DiskSector
  4670 00001198 E8B306                  		call	Move
  4671 0000119B 5F                      		pop	di
  4672 0000119C 5E                      		pop	si
  4673 0000119D 1F                      		pop	ds
  4674                                  ;
  4675                                  ; Note the fact that we've done 1 more sector
  4676                                  ;
  4677                                  DoTail:
  4678 0000119E 5B                      		pop	BX		; retrieve new DMA area
  4679 0000119F 80C702                  		add	BH,2		; advance over sector
  4680 000011A2 41                      		inc	CX
  4681 000011A3 8A4602                  		mov	AL,[BP+INT13FRAME.oldax]
  4682 000011A6 F8                      		clc
  4683 000011A7 FEC8                    		dec	AL
  4684 000011A9 7409                    		jz	short Bad13	; no more I/O
  4685 000011AB 8A5608                  		mov	DL,[BP+INT13FRAME.olddx] ; set drive number
  4686 000011AE E8E505                  		call	Check_Wrap	; check for head or cylinder wrap
  4687 000011B1 E8A306                  		call	DoINT
  4688                                  ;
  4689                                  ; We are done.	AX has the final code; we throw away what we got before
  4690                                  ;
  4691                                  Bad13:
  4692 000011B4 89EC                    		mov	SP,BP
  4693 000011B6 5D                      		pop	bp
  4694 000011B7 5B                      		pop	bx
  4695 000011B8 5B                      		pop	bx
  4696 000011B9 59                      		pop	cx
  4697 000011BA 5A                      		pop	dx
  4698                                  		; 06/07/2018
  4699 000011BB CA0200                  		retf	2
  4700                                  
  4701                                  ; include msioctl.inc
  4702                                  
  4703                                  ;-----------------------------------------------------------------------------
  4704                                  ; include msioctl.inc - MSDOS 3.3 - MSDISK.ASM - 02/02/1988
  4705                                  ;-----------------------------------------------------------------------------
  4706                                  ; 24/03/2018 - Retro DOS v2.0
  4707                                  
  4708                                  		; include ioctl.inc
  4709                                  
  4710                                  ; IOCTL.INC - MSDOS 6.0 - 1991
  4711                                  ; ............................................................................
  4712                                  
  4713                                  ;*** J.K.
  4714                                  ;General Guide -
  4715                                  ;Category Code:
  4716                                  ; 0... .... DOS Defined
  4717                                  ; 1... .... User defined
  4718                                  ; .xxx xxxx Code
  4719                                  
  4720                                  ;Function Code:
  4721                                  ; 0... .... Return error if unsupported
  4722                                  ; 1... .... Ignore if unsupported
  4723                                  ; .0.. .... Intercepted by DOS
  4724                                  ; .1.. .... Passed to driver
  4725                                  ; ..0. .... Sends data/commands to device
  4726                                  ; ..1. .... Quries data/info from device
  4727                                  ; ...x .... Subfunction
  4728                                  ;
  4729                                  ; Note that "Sends/queries" data bit is intended only to regularize the
  4730                                  ; function set.  It plays no critical role; some functions may contain both
  4731                                  ; command and query elements. The convention is that such commands are
  4732                                  ; defined as "sends data".
  4733                                  
  4734                                  ;*****************************;*
  4735                                  ; BLOCK DRIVERS 	      ;*
  4736                                  ;*****************************;*
  4737                                  
  4738                                  ; IOCTL SUB-FUNCTIONS
  4739                                  IOCTL_GET_DEVICE_INFO	EQU	0
  4740                                  IOCTL_SET_DEVICE_INFO	EQU	1
  4741                                  IOCTL_READ_HANDLE	EQU	2
  4742                                  IOCTL_WRITE_HANDLE	EQU	3
  4743                                  IOCTL_READ_DRIVE	EQU	4
  4744                                  IOCTL_WRITE_DRIVE	EQU	5
  4745                                  IOCTL_GET_INPUT_STATUS	EQU	6
  4746                                  IOCTL_GET_OUTPUT_STATUS EQU	7
  4747                                  IOCTL_CHANGEABLE?	EQU	8
  4748                                  IOCTL_DeviceLocOrRem?	EQU	9
  4749                                  IOCTL_HandleLocOrRem?	EQU	0Ah   ;10
  4750                                  IOCTL_SHARING_RETRY	EQU	0Bh   ;11
  4751                                  GENERIC_IOCTL_HANDLE	EQU	0Ch   ;12
  4752                                  GENERIC_IOCTL		EQU	0Dh   ;13
  4753                                  IOCTL_GET_DRIVE_MAP 	EQU	0Eh   ;14
  4754                                  IOCTL_SET_DRIVE_MAP	EQU	0Fh   ;15
  4755                                  IOCTL_QUERY_HANDLE	EQU	10h   ;16
  4756                                  IOCTL_QUERY_BLOCK	EQU	11h   ;17
  4757                                  
  4758                                  ; GENERIC IOCTL SUB-FUNCTIONS
  4759                                  RAWIO			EQU	8
  4760                                  
  4761                                  ; RAWIO SUB-FUNCTIONS
  4762                                  GET_DEVICE_PARAMETERS	EQU	60H
  4763                                  SET_DEVICE_PARAMETERS	EQU	40H
  4764                                  READ_TRACK		EQU	61H
  4765                                  WRITE_TRACK		EQU	41H
  4766                                  VERIFY_TRACK		EQU	62H
  4767                                  FORMAT_TRACK		EQU	42H
  4768                                  GET_MEDIA_ID		EQU	66h	;AN000;AN003;changed from 63h
  4769                                  SET_MEDIA_ID		EQU	46h	;AN000;AN003;changed from 43h
  4770                                  GET_ACCESS_FLAG 	EQU	67h	;AN002;AN003;Unpublished function.Changed from 64h
  4771                                  SET_ACCESS_FLAG 	EQU	47h	;AN002;AN003;Unpublished function.Changed from 44h
  4772                                  SENSE_MEDIA_TYPE	EQU	68H	;Added for 5.00
  4773                                  
  4774                                  
  4775                                  ; SPECIAL FUNCTION FOR GET DEVICE PARAMETERS
  4776                                  BUILD_DEVICE_BPB	EQU	000000001B
  4777                                  
  4778                                  ; SPECIAL FUNCTIONS FOR SET DEVICE PARAMETERS
  4779                                  INSTALL_FAKE_BPB	EQU	000000001B
  4780                                  ONLY_SET_TRACKLAYOUT	EQU	000000010B
  4781                                  TRACKLAYOUT_IS_GOOD	EQU	000000100B
  4782                                  
  4783                                  ; SPECIAL FUNCTION FOR FORMAT TRACK
  4784                                  STATUS_FOR_FORMAT	EQU	000000001B
  4785                                  DO_FAST_FORMAT		EQU	000000010B ;AN001;
  4786                                  ; CODES RETURNED FROM FORMAT STATUS CALL
  4787                                  FORMAT_NO_ROM_SUPPORT	EQU	000000001B
  4788                                  FORMAT_COMB_NOT_SUPPORTED EQU	000000010B
  4789                                  
  4790                                  ; DEVICETYPE VALUES
  4791                                  MAX_SECTORS_IN_TRACK	EQU	63	; MAXIMUM SECTORS ON A DISK.(Was 40 in DOS 3.2)
  4792                                  DEV_5INCH		EQU	0
  4793                                  DEV_5INCH96TPI		EQU	1
  4794                                  DEV_3INCH720KB		EQU	2
  4795                                  DEV_8INCHSS		EQU	3
  4796                                  DEV_8INCHDS		EQU	4
  4797                                  DEV_HARDDISK		EQU	5
  4798                                  DEV_OTHER		EQU	7
  4799                                  ;DEV_3INCH1440KB	EQU	7
  4800                                  DEV_3INCH2880KB		EQU	9
  4801                                  ; Retro DOS v2.0 - 26/03/2018
  4802                                  ;;DEV_TAPE		EQU	6
  4803                                  ;;DEV_ERIMO		EQU	8
  4804                                  ;DEV_3INCH2880KB	EQU	9
  4805                                  DEV_3INCH1440KB		EQU	10
  4806                                  
  4807                                  ;MAX_DEV_TYPE		EQU	9	; MAXIMUM DEVICE TYPE THAT WE
  4808                                  					; CURRENTLY SUPPORT.
  4809                                  MAX_DEV_TYPE		EQU	10
  4810                                  
  4811                                  struc A_SECTORTABLE
  4812 00000000 ????                    .ST_SECTORNUMBER:	resw	1
  4813 00000002 ????                    .ST_SECTORSIZE:		resw	1
  4814                                  .size:
  4815                                  endstruc
  4816                                  
  4817                                  ; MSDOS 6.0 - BPB.INC - 1991
  4818                                  ; ####
  4819                                  ;**	BIOS PARAMETER BLOCK DEFINITION
  4820                                  ;
  4821                                  ;	The BPB contains information about the disk structure. It dates
  4822                                  ;	back to the earliest FAT systems and so FAT information is
  4823                                  ;	intermingled with physical driver information.
  4824                                  ;
  4825                                  ;	A boot sector contains a BPB for its device; for other disks
  4826                                  ;	the driver creates a BPB. DOS keeps copies of some of this
  4827                                  ;	information in the DPB.
  4828                                  ;
  4829                                  ;	The BDS structure contains a BPB within it.
  4830                                  ;
  4831                                  
  4832                                  struc A_BPB
  4833 00000000 ????                    .BPB_BYTESPERSECTOR:	resw	1
  4834 00000002 ??                      .BPB_SECTORSPERCLUSTER:	resb	1
  4835 00000003 ????                    .BPB_RESERVEDSECTORS:	resw	1
  4836 00000005 ??                      .BPB_NUMBEROFFATS:	resb	1
  4837 00000006 ????                    .BPB_ROOTENTRIES: 	resw	1
  4838 00000008 ????                    .BPB_TOTALSECTORS:	resw	1
  4839 0000000A ??                      .BPB_MEDIADESCRIPTOR:	resb	1
  4840 0000000B ????                    .BPB_SECTORSPERFAT:	resw	1
  4841 0000000D ????                    .BPB_SECTORSPERTRACK:	resw	1
  4842 0000000F ????                    .BPB_HEADS:		resw	1
  4843 00000011 ????                    .BPB_HIDDENSECTORS:	resw	1
  4844 00000013 ????                    			resw	1
  4845 00000015 ????                    .BPB_BIGTOTALSECTORS:	resw	1
  4846 00000017 ????                    			resw	1
  4847 00000019 ????????????            			resb	6	; NOTE:  many times these
  4848                                  ;					; 	 6 bytes are omitted
  4849                                  ;					;	 when BPB manipulations
  4850                                  ;					;	 are performed!
  4851                                  .size:
  4852                                  endstruc
  4853                                  ; ####
  4854                                  
  4855                                  struc A_DEVICEPARAMETERS
  4856 00000000 ??                      .DP_SPECIALFUNCTIONS:	resb	1
  4857 00000001 ??                      .DP_DEVICETYPE:		resb	1
  4858 00000002 ????                    .DP_DEVICEATTRIBUTES:	resw	1
  4859 00000004 ????                    .DP_CYLINDERS:		resw	1
  4860 00000006 ??                      .DP_MEDIATYPE:		resb	1
  4861 00000007 <res 1Fh>               .DP_BPB:		resb	A_BPB.size
  4862 00000026 ????                    .DP_TRACKTABLEENTRIES:	resw	1
  4863 00000028 <res FCh>               .DP_SECTORTABLE:	resb	MAX_SECTORS_IN_TRACK * A_SECTORTABLE.size
  4864                                  endstruc
  4865                                  
  4866                                  struc A_TRACKREADWRITEPACKET
  4867 00000000 ??                      .TRWP_SPECIALFUNCTIONS:	resb	1
  4868 00000001 ????                    .TRWP_HEAD:		resw	1
  4869 00000003 ????                    .TRWP_CYLINDER:		resw	1
  4870 00000005 ????                    .TRWP_FIRSTSECTOR:	resw	1
  4871 00000007 ????                    .TRWP_SECTORSTOREADWRITE: resw	1
  4872 00000009 ????????                .TRWP_TRANSFERADDRESS:	resd	1
  4873                                  endstruc
  4874                                  
  4875                                  ;AN001; - FP_TRACKCOUNT is only meaningful when FP_SPECIALFUNCTIONS bit 1 = 1.
  4876                                  struc A_FORMATPACKET
  4877 00000000 ??                      .FP_SPECIALFUNCTIONS:	resb	1  ; db ?
  4878 00000001 ????                    .FP_HEAD: 		resw	1  ; dw ? 
  4879 00000003 ????                    .FP_CYLINDER:		resw	1  ; dw ?
  4880 00000005 ????                    .FP_TRACKCOUNT:		resw	1  ; dw 1 ; !
  4881                                  endstruc
  4882                                  
  4883                                  struc A_VERIFYPACKET
  4884 00000000 ??                      .VP_SPECIALFUNCTIONS:	resb	1
  4885 00000001 ????                    .VP_HEAD: 		resw	1
  4886 00000003 ????                    .VP_CYLINDER:		resw	1
  4887                                  endstruc
  4888                                  
  4889                                  struc A_MEDIA_ID_INFO
  4890 00000000 ????                    .MI_LEVEL:		resw	1  ; dw 0 ; !		;J.K. 87 Info. level
  4891 00000002 ????????                .MI_SERIAL:		resd	1  ; dd ?		;J.K. 87 Serial #
  4892 00000006 <res Bh>                .MI_LABEL:		resb	11 ; db 11 DUP (' ') ;!	;J.K. 87 volume label
  4893 00000011 ????????????????        .MI_SYSTEM:		resb 	8  ; db 8 DUP (' ')  ;!	;J.K. 87 File system type
  4894                                  endstruc
  4895                                  
  4896                                  struc A_DISKACCESS_CONTROL	   ;AN002; Unpublished function. Only for Hard file.
  4897 00000000 ??                      .DAC_SPECIALFUNCTIONS:	resb 	1  ; db 0 ; ! ;AN002; Always 0
  4898 00000001 ??                      .DAC_ACCESS_FLAG: 	resb 	1  ; db 0 ; ! 
  4899                                  				   ; Non Zero - allow disk I/O to unformatted hard file
  4900                                  endstruc			   ; 0 - Disallow disk I/O to unformatted hard file
  4901                                  
  4902                                  
  4903                                  struc A_MEDIA_SENSE			; Media sense structure added 5.00
  4904 00000000 ??                      .MS_ISDEFAULT:		resb	1	; If 1 type returned is drv default
  4905 00000001 ??                      .MS_DEVICETYPE:		resb	1	; Drive type 
  4906 00000002 ??                      .MS_RESERVED1:		resb	1	; RESERVED
  4907 00000003 ??                      .MS_RESERVED2:		resb 	1	; RESERVED 
  4908                                  endstruc
  4909                                  
  4910                                  ;********************************;*
  4911                                  ; CHARACTER DEVICES (PRINTERS)	 ;*
  4912                                  ;********************************;*
  4913                                  
  4914                                  ;RAWIO SUB-FUNCTIONS
  4915                                  GET_RETRY_COUNT 	EQU	65H
  4916                                  SET_RETRY_COUNT 	EQU	45H
  4917                                  
  4918                                  struc A_RETRYCOUNT
  4919 00000000 ????                    .RC_COUNT:		resw 1
  4920                                  endstruc
  4921                                  
  4922                                  ;********************************;*		;J.K. 4/29/86
  4923                                  ; CHARACTER DEVICES (SCREEN)	 ;*
  4924                                  ;********************************;*		;J.K. 4/29/86
  4925                                  ;
  4926                                  ;SC_MODE_INFO	 struc
  4927                                  ;SC_INFO_LENGTH 	 DW	 9
  4928                                  ;SC_MODE		 DB	 0
  4929                                  ;SC_COLORS		 DW	 0
  4930                                  ;SC_WIDTH		 DW	 0
  4931                                  ;SC_LENGTH		 DW	 0
  4932                                  ;SC_MODE_INFO	 ends
  4933                                  ;
  4934                                  ;SC_INFO_PACKET_LENGTH	 EQU	 9		 ;LENGTH OF THE INFO PACKET.
  4935                                  
  4936                                  ;SUBFUNCTIONS FOR CON$GENIOCTL
  4937                                  ;GET_SC_MODE		 EQU	 60h
  4938                                  ;SET_SC_MODE		 EQU	 40h
  4939                                  ;The following subfunctions are reserved for installable CODE PAGE switch
  4940                                  ;console devices. - J.K. 4/29/86
  4941                                  ;Get_active_codepage	 equ	 6Ah
  4942                                  ;Invoke_active_codepage  equ	 4Ah
  4943                                  ;Start_designate_codepage equ	 4Ch
  4944                                  ;End_designate_codepage  equ	 4Dh
  4945                                  ;Get_list_of_designated_codepage equ 6Bh
  4946                                  ;J.K. 4/29/86 *** End of Con$genioctl equates & structures
  4947                                  
  4948                                  ; 28/05/2018 - Retro DOS v3.0
  4949                                  
  4950                                  ;
  4951                                  ; Generic IOCTL dispatch tables
  4952                                  ;
  4953                                  IOReadJumpTable: 
  4954 000011BE 02                      		db	2
  4955 000011BF [0D13]                  		dw	GetDeviceParameters
  4956 000011C1 [7C15]                  		dw	ReadTrack
  4957 000011C3 [5715]                  		dw	VerifyTrack
  4958                                  
  4959                                  IOWriteJumpTable:
  4960 000011C5 02                      		db	2
  4961 000011C6 [4913]                  		dw	SetDeviceParameters
  4962 000011C8 [8415]                  		dw	WriteTrack
  4963 000011CA [0A14]                  		dw	FormatTrack
  4964                                  
  4965                                  MAX_SECTORS_CURR_SUP	EQU	63	; CURRENT MAXIMUM SEC/TRK THAT	  ;3.30
  4966                                  					; WE SUPPORT (Was 40 in DOS 3.2)  ;3.30
  4967                                  ;
  4968                                  ; TrackTable is an area for saving information passwd by the set device
  4969                                  ; parameter function for laster use my Read/Write/Format/Verify.
  4970                                  ;
  4971                                  ; Entries are 4-Tuples (C,H,R,N) where:
  4972                                  ;   C = Cylinder, H = Head, R = Sector, N = Bytes/Sector
  4973                                  ;
  4974                                  ; fixed for bug0016 - initialised table with values - sp
  4975                                  TrackTable:
  4976 000011CC 00000102                		db	0,0,1,2
  4977 000011D0 00000202                		db	0,0,2,2
  4978 000011D4 00000302                		db	0,0,3,2
  4979 000011D8 00000402                		db	0,0,4,2
  4980 000011DC 00000502                		db	0,0,5,2
  4981 000011E0 00000602                		db	0,0,6,2
  4982 000011E4 00000702                		db	0,0,7,2
  4983 000011E8 00000802                		db	0,0,8,2
  4984 000011EC 00000902                		db	0,0,9,2
  4985 000011F0 00000A02                		db	0,0,10,2
  4986 000011F4 00000B02                		db	0,0,11,2
  4987 000011F8 00000C02                		db	0,0,12,2
  4988 000011FC 00000D02                		db	0,0,13,2
  4989 00001200 00000E02                		db	0,0,14,2
  4990 00001204 00000F02                		db	0,0,15,2
  4991 00001208 00001002                		db	0,0,16,2
  4992 0000120C 00001102                		db	0,0,17,2
  4993 00001210 00001202                		db	0,0,18,2
  4994 00001214 00<rep B4h>                             times (MAX_SECTORS_CURR_SUP*A_SECTORTABLE.size)-($-TrackTable) db 0
  4995                                  
  4996                                  SectorsPerTrack:
  4997 000012C8 0F00                    		dw      15
  4998                                  
  4999                                  ; This is a real ugly place to put this
  5000                                  ; it should really go in the BDS
  5001 000012CA 00                      mediaType:	db	0
  5002                                  
  5003                                  Media_Set_For_Format:
  5004 000012CB 00                      		db	0		; 1 if we have done an Int 13 Set Media
  5005                                  					; Type for Format call
  5006                                  ; Rev 3.30 *****************************************************************
  5007                                  Had_Format_Error:
  5008 000012CC 00                      		db	0		; 1 if the previous format operation
  5009                                  					; failed.
  5010                                  Dsk_time_out_Err	equ	80h	; Time out error (No media present).
  5011                                  Dsk_change_line_Err	equ	6h	; Change line error
  5012                                  Dsk_illegal_combination equ	0Ch	; Return code of ah=18h function.
  5013                                  ; Rev 3.30 *****************************************************************
  5014                                  
  5015                                  ;
  5016                                  ; TempDPT is a temporary place to hold a pointer to the original
  5017                                  ; Disk Parameter Table while DPT is made to point to a table returned
  5018                                  ; by a BIOS call.  A value of -1 indicateds no value has been saved.
  5019                                  ;
  5020                                  
  5021                                  TempDPT:
  5022 000012CD FFFFFFFF                		DD	-1
  5023                                  
  5024                                  ;
  5025                                  ; Generic$IOCTL:
  5026                                  ;    Perform Generic IOCTL request
  5027                                  ;    Input:
  5028                                  ;	al	- unit number
  5029                                  ;    Output:
  5030                                  ;	if carry set then al contains error code
  5031                                  ;
  5032                                  
  5033                                  GENERIC$IOCTL:
  5034 000012D1 2EC41E[B800]            		les	bx,[cs:PTRSAV]		; es:bx points to request header.
  5035 000012D6 E858F9                  		call	SETDRIVE		; ds:di points to BDS for drive.
  5036                                  ;
  5037                                  ; At this point:
  5038                                  ;    es:bx - points to the Request Header
  5039                                  ;    ds:di points to the BDS for the drive
  5040                                  ;
  5041 000012D9 26807F0D08              		cmp	byte [es:bx+IOCTL_REQ.MAJORFUNCTION],RAWIO
  5042 000012DE 752A                    		jne	IOCTL_Func_Err
  5043 000012E0 268A470E                		mov	al,[es:bx+IOCTL_REQ.MINORFUNCTION]
  5044 000012E4 BE[BE11]                		mov	si,IOReadJumpTable
  5045 000012E7 A820                    		test	al,GEN_IOCTL_FN_TST	; Test of req. function
  5046 000012E9 7503                    		jnz	short NotGenericIoctlWrite	;   function is a Read.
  5047 000012EB BE[C511]                		mov	si,IOWriteJumpTable
  5048                                  NotGenericIoctlWrite:
  5049 000012EE 240F                    		and	al,0FH
  5050 000012F0 2E3A04                  		cmp	al,[cs:si]
  5051 000012F3 7715                    		ja	short IOCTL_Func_Err
  5052 000012F5 98                      		cbw
  5053 000012F6 D1E0                    		shl	ax, 1
  5054 000012F8 46                      		inc	si
  5055 000012F9 01C6                    		add	si,ax
  5056 000012FB 26C45F13                		les	bx,[es:bx+IOCTL_REQ.GENERICIOCTL_PACKET]
  5057 000012FF 2EFF14                  		call	[cs:si]
  5058 00001302 7203                    		jc	short FailGeneric$IOCTL
  5059 00001304 E981F3                  		jmp	EXIT
  5060                                  
  5061                                  FailGeneric$IOCTL:
  5062 00001307 E971F3                  		jmp	ERR$EXIT
  5063                                  
  5064                                  IOCTL_Func_Err:
  5065 0000130A E964F3                  		jmp	CMDERR
  5066                                  
  5067                                  ;
  5068                                  ; GetDeviceParameters:
  5069                                  ;
  5070                                  ; Input: DS:DI points to BDS for drive
  5071                                  ;	 ES:BX points to device parameter packet
  5072                                  ;
  5073                                  
  5074                                  GetDeviceParameters:
  5075                                  ; Copy info from BDS to the device parameters packet
  5076 0000130D 8A4528                  		mov	al,[DI+BDS.FormFactor]
  5077 00001310 26884701                		mov	[es:bx+A_DEVICEPARAMETERS.DP_DEVICETYPE], al
  5078 00001314 8B4529                  		mov	ax,[DI+BDS.Flags]
  5079 00001317 83E003                  		and	ax,fNon_Removable+fChangeline	; mask off other bits
  5080 0000131A 26894702                		mov	[es:bx+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES], ax
  5081 0000131E 8B452B                  		mov	ax,[DI+BDS.cCyln]
  5082 00001321 26894704                		mov	[es:bx+A_DEVICEPARAMETERS.DP_CYLINDERS], ax
  5083                                  
  5084                                  ; Set media type to default
  5085 00001325 30C0                    		xor	al, al
  5086 00001327 26884706                		mov	[es:bx+A_DEVICEPARAMETERS.DP_MEDIATYPE],al
  5087                                  
  5088                                  ; Copy recommended BPB
  5089 0000132B 8D752D                  		lea	si, [DI+BDS.RBytePerSec]
  5090                                  		;test	byte [es:bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],BUILD_DEVICE_BPB
  5091 0000132E 26F60701                		test	byte [es:bx],BUILD_DEVICE_BPB ; 05/07/2019
  5092 00001332 740B                    		jz	short use_BPB_present
  5093                                  ; Get the correct disk in the drive
  5094 00001334 E844F9                  		call	CHECKSINGLE
  5095                                  ; Build the BPB from scratch
  5096 00001337 E856F7                  		call	GETBP
  5097 0000133A 720C                    		jc	short Get_Parm_Ret
  5098 0000133C 8D7506                  		lea	si,[DI+BDS.BytePerSec]
  5099                                  use_BPB_present:
  5100 0000133F 8D7F07                  		lea	di,[bx+A_DEVICEPARAMETERS.DP_BPB]
  5101 00001342 B91300                  		mov	cx,BPB_TYPE.size	; for now use 'small' BPB
  5102 00001345 F3A4                    		rep	movsb
  5103 00001347 F8                      		clc
  5104                                  Get_Parm_Ret:
  5105 00001348 C3                      		retn
  5106                                  
  5107                                  ;
  5108                                  ; SetDeviceParameters:
  5109                                  ;
  5110                                  ; Input: DS:DI points to BDS for drive
  5111                                  ;	 ES:BX points to device parameter packet
  5112                                  ;
  5113                                  
  5114                                  SetDeviceParameters:
  5115                                  
  5116                                  ; Make sure the fChanged_By_Format flag gets set to kick DOS into looking at
  5117                                  ; the BPB
  5118 00001349 814D294001              		or	word [DI+BDS.Flags],fChanged_By_Format | fChanged
  5119                                  		;test	byte [es:bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],ONLY_SET_TRACKLAYOUT
  5120 0000134E 26F60702                		test	byte [es:bx],ONLY_SET_TRACKLAYOUT ; 05/07/2019
  5121                                  		;jz	short SetDevParm_1
  5122                                  		;jmp	short SetTrackTable		; Originally TrackLayout
  5123 00001352 756D                    		jnz	short SetTrackTable ; 05/07/2019 
  5124                                  SetDevParm_1:
  5125                                  ; Copy info from the device parameters packet to BDS
  5126 00001354 268A4701                		mov	al,[es:bx+A_DEVICEPARAMETERS.DP_DEVICETYPE]
  5127 00001358 884528                  		mov	[DI+BDS.FormFactor], al
  5128                                  
  5129 0000135B 268B4704                		mov	ax,[es:bx+A_DEVICEPARAMETERS.DP_CYLINDERS]
  5130 0000135F 89452B                  		mov	[DI+BDS.cCyln],ax
  5131                                  
  5132                                  ; If change line is not loaded then ignore changeling flag
  5133 00001362 268B4702                		mov	ax,[es:bx+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES]
  5134 00001366 2E803E[C301]00          		cmp	byte [cs:fHave96],0
  5135 0000136C 7503                    		jnz	short Have_Change
  5136 0000136E 83E0FD                  		and	ax,~fChangeline
  5137                                  Have_Change:
  5138                                  ; ignore all bits except Non_removable and Changeline
  5139 00001371 83E003                  		and	ax,fNon_Removable | fChangeline
  5140 00001374 8B4D29                  		mov	cx,[DI+BDS.Flags]
  5141 00001377 83E1F4                  		and	cx,~(fNon_Removable | fChangeline | GOOD_TRACKLAYOUT)
  5142 0000137A 09C8                    		or	ax,cx
  5143 0000137C 894529                  		mov	[DI+BDS.Flags],ax
  5144                                  
  5145                                  ; Set media type
  5146 0000137F 268A4706                		mov	al,[es:bx+A_DEVICEPARAMETERS.DP_MEDIATYPE]
  5147 00001383 2EA2[CA12]              		mov	[cs:mediaType],al
  5148                                  ; the media changed (maybe) so we will have to do a SetDASD the next time
  5149                                  ; we format a track
  5150 00001387 814D298000              		or	word [DI+BDS.Flags],SET_DASD_true
  5151                                  
  5152 0000138C 1E                      		push	ds
  5153 0000138D 57                      		push	di
  5154 0000138E 06                      		push	es
  5155 0000138F 53                      		push	bx
  5156                                  ; Figure out what we are supposed to do with the BPB
  5157                                  
  5158                                  ; Were we asked to install a fake BPB?
  5159                                  		;test	byte [es:bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],INSTALL_FAKE_BPB
  5160 00001390 26F60701                		test	byte [es:bx],INSTALL_FAKE_BPB ; 05/07/2019
  5161 00001394 7515                    		jnz	short InstallFakeBPB
  5162                                  
  5163                                  ; Were we returning a fake BPB when asked to build a BPB?
  5164 00001396 F745290400              		test	word [DI+BDS.Flags],RETURN_FAKE_BPB
  5165 0000139B 7406                    		jz	short InstallRecommendedBPB
  5166                                  
  5167                                  ; We were returning a fake BPB but we can stop now
  5168 0000139D 836529FB                		and	word[DI+BDS.Flags],~RETURN_FAKE_BPB
  5169 000013A1 EB17                    		jmp	short DoneWithBPBstuff
  5170                                  
  5171                                  InstallRecommendedBPB:
  5172 000013A3 B91F00                  		mov	cx,A_BPB.size
  5173 000013A6 8D7D2D                  		lea	di,[DI+BDS.RBytePerSec]
  5174 000013A9 EB06                    		jmp	short CopyTheBPB
  5175                                  
  5176                                  InstallFakeBPB:
  5177 000013AB B91300                  		mov	cx,BPB_TYPE.size    ; move 'smaller' BPB
  5178 000013AE 8D7D06                  		lea	di,[DI+BDS.BytePerSec]
  5179                                  CopyTheBPB:
  5180 000013B1 8D7707                  		lea	si,[bx+A_DEVICEPARAMETERS.DP_BPB]
  5181                                  ; exchange es and ds
  5182 000013B4 06                      		push	es
  5183 000013B5 1E                      		push	ds
  5184 000013B6 07                      		pop	es
  5185 000013B7 1F                      		pop	ds
  5186                                  
  5187 000013B8 F3A4                    		rep	movsb
  5188                                  
  5189                                  DoneWithBPBstuff:
  5190 000013BA E8AD03                  		call	RestoreOldDPT
  5191 000013BD 5B                      		pop	bx
  5192 000013BE 07                      		pop	es
  5193 000013BF 5F                      		pop	di
  5194 000013C0 1F                      		pop	ds
  5195                                  
  5196                                  ; Set up track table (if neccessary)
  5197                                  SetTrackTable:
  5198 000013C1 268B4F26                		mov	cx,[es:bx+A_DEVICEPARAMETERS.DP_TRACKTABLEENTRIES]
  5199 000013C5 2E890E[C812]            		mov	[cs:SectorsPerTrack],cx
  5200 000013CA 836529F7                		and	word [DI+BDS.Flags],~GOOD_TRACKLAYOUT
  5201                                  		;test	byte [es:bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],TRACKLAYOUT_IS_GOOD
  5202 000013CE 26F60704                		test	byte [es:bx],TRACKLAYOUT_IS_GOOD ; 05/07/2019
  5203 000013D2 7404                    		jz	short UglyTrackLayout
  5204 000013D4 834D2908                		or	word [DI+BDS.Flags],GOOD_TRACKLAYOUT
  5205                                  
  5206                                  UglyTrackLayout:
  5207 000013D8 83F93F                  		cmp	cx,MAX_SECTORS_IN_TRACK
  5208 000013DB 7729                    		ja	short TooManySectorsPerTrack
  5209 000013DD E325                    		jcxz	SectorInfoSaved		; if no value don't copy table
  5210                                  						; save information in the track table
  5211                                  
  5212 000013DF 53                      		push    BX			; get ES:BX to point to sector
  5213 000013E0 83C328                  		add     BX,A_DEVICEPARAMETERS.DP_SECTORTABLE ;  table in Device param. struct
  5214                                  	
  5215 000013E3 57                      		push    DI
  5216 000013E4 BF[CE11]                		mov     DI,TrackTable + 2	; CS:DI now points to sector id
  5217                                                                                  ; of the first track table entry
  5218 000013E7 50                      		push    AX			; preserve AX value
  5219                                  
  5220                                                                                  ; For MAX_SECTORS_IN_TRACK
  5221                                  TrackLoop:                                      ;   DO:
  5222 000013E8 268B07                  		mov     AX,[ES:BX]		;   get sector number
  5223 000013EB 2E8805                  		mov	[CS:DI],AL		;   save in track table
  5224                                  
  5225 000013EE 268B4702                	        mov     AX,[ES:BX+2]		;   get sector size
  5226 000013F2 E83602                  	        call    SectorSizeToSectorIndex ;   convert size to index number
  5227 000013F5 2E884501                		mov     [CS:DI+1],AL		;   save size in track table
  5228                                  
  5229 000013F9 83C304                  		add     BX,A_SECTORTABLE.size	;   advance pointers to next
  5230 000013FC 83C704                  		add     DI,A_SECTORTABLE.size	;   entries
  5231 000013FF E0E7                    		loopnz  TrackLoop		; End FOR
  5232                                  
  5233 00001401 58                      		pop     AX 			; restore the saved values
  5234 00001402 5F                      		pop     DI
  5235 00001403 5B                      		pop     BX
  5236                                  
  5237                                  SectorInfoSaved:
  5238 00001404 F8                      		clc
  5239 00001405 C3                      		retn
  5240                                  
  5241                                  TooManySectorsPerTrack:
  5242 00001406 B00C                    		mov	al, 0Ch
  5243 00001408 F9                      		stc
  5244 00001409 C3                      		retn
  5245                                  
  5246                                  ;
  5247                                  ; FormatTrack:
  5248                                  ; If SpecialFunction byte is 1, then this is a status call to see if there is
  5249                                  ; ROM support for the combination of sec/trk and # of cyln, and if the
  5250                                  ; combination is legal. If SpecialFunction byte is 0, then format the track.
  5251                                  ;
  5252                                  ; Input: DS:DI points to BDS for drive
  5253                                  ;        ES:BX points to format packet
  5254                                  ;
  5255                                  ; Output:
  5256                                  ;       For status call:
  5257                                  ;       SpecialFunction byte set to:
  5258                                  ;               0 - ROM support + legal combination
  5259                                  ;               1 - No ROM support
  5260                                  ;               2 - Illegal Combination
  5261                                  ;		3 - no media present			;Rev 3.30
  5262                                  ;       Carry cleared.
  5263                                  ;
  5264                                  ;       For format track:
  5265                                  ;               Carry set if error
  5266                                  ;
  5267                                  ;
  5268                                  ;  Flags also may be altered. All other registers preserved.
  5269                                  ;  If the call to ROM returns no error, then the current DPT is "replaced" by
  5270                                  ;  the one returned by the ROM. This is done by changing the pointer in [DPT]
  5271                                  ;  to the one returned. The original pointer to the disk base table is stored
  5272                                  ;  in TempDPT, until it is restored.
  5273                                  ;
  5274                                  ;  This proc was changed to force a status for format call if we are on the
  5275                                  ;  new ROM.
  5276                                  ;
  5277                                  ;
  5278                                  FormatTrack:
  5279                                  		;test	byte [es:bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],STATUS_FOR_FORMAT
  5280 0000140A 26F60701                		test	byte [es:bx],STATUS_FOR_FORMAT ; 05/07/2019
  5281 0000140E 7408                    		jz	short SkipStatusOnly
  5282                                  
  5283                                  Do_Status_Only:
  5284 00001410 E89900                  		call	FormatStatus
  5285                                  		;mov	[es:bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],al
  5286 00001413 268807                  		mov	[es:bx],al ; 05/07/2019
  5287                                  		;clc
  5288 00001416 F8                      		clc	; 05/07/2019 (CF=1 is possible from 'FormatStatus')
  5289 00001417 C3                      		retn
  5290                                  	
  5291                                  SkipStatusOnly:                       ; for a hard disk only do the verify
  5292 00001418 807D2805                        	cmp     byte [DI+BDS.FormFactor],DEV_HARDDISK
  5293 0000141C 7503                    		jnz	short SkipVerify
  5294 0000141E E98700                  		jmp	DoVerifyTrack
  5295                                  SkipVerify:
  5296 00001421 1E                      		push	ds			; Format a Track
  5297 00001422 57                      		push	di
  5298 00001423 06                      		push	es
  5299 00001424 53                      		push	bx
  5300 00001425 E88400                  		call	FormatStatus		; SetDASD checks media_set_for_format
  5301                                  		;;14/06/2018 (IBMDOS 3.3,IBMBIO.COM)
  5302                                  		;cmp	al,1
  5303                                  		;je	short NeedToSetDasd
  5304 00001428 3C03                    		cmp	al,3			; Check for time out
  5305                                  		;jne	short NoSetDasd
  5306 0000142A 745D                    		je	short Format_Failed	; Fail if time out
  5307                                  		;jmp	short Format_Failed
  5308                                  NeedToSetDasd:
  5309 0000142C E81202                          	call    SetDASD
  5310                                  ;
  5311                                  ; Store Cylinder,Head in track table
  5312                                  ;                       ***** ASSUMPTION *******
  5313                                  ;       Since format requests on Fixed Media are converted to Verifies, we
  5314                                  ;       assume that we are formatting a floppy and hence have 255 or less
  5315                                  ;       tracks and heads. We therefore must change the Cylinder, Head data
  5316                                  ;       from the Request Packet Size to that of the TrackTable (see Int 13
  5317                                  ;       interface in IBM's Tech Ref.).
  5318                                  
  5319                                  ; Check to ensure correct disk is in drive
  5320                                  NoSetDasd:
  5321 0000142F E849F8                  		call    CHECKSINGLE
  5322                                  
  5323 00001432 268B4703                		mov     ax,[es:bx+A_FORMATPACKET.FP_CYLINDER]
  5324 00001436 2EA3[6E02]              		mov     [cs:TRKNUM],ax
  5325 0000143A 268B4F01                		mov     cx,[es:bx+A_FORMATPACKET.FP_HEAD]
  5326 0000143E 2E880E[6D02]            		mov     [cs:HDNUM],cl
  5327 00001443 88CC                    		mov     ah,cl
  5328                                                          ; this next piece of code copies the correct head
  5329                                                          ; and cylinder numbers to the tracktable
  5330 00001445 57                      		push    di			; preserve DI
  5331 00001446 BF[CC11]                		mov     di,TrackTable
  5332 00001449 2E8B0E[C812]            		mov     CX,[cs:SectorsPerTrack] ; get number of sectors
  5333 0000144E E308                            	jcxz    EndSetUpTrackTable	; if nothing to do skip down
  5334                                  SetUpLoop:
  5335 00001450 2E8905                  		mov     [cs:di],AX		; set head and track value
  5336 00001453 83C704                  		add     di,4			; move to next entry
  5337 00001456 E0F8                    		loopnz  SetUpLoop		; loop if not done yet
  5338                                  EndSetUpTrackTable:
  5339 00001458 5F                              	pop     di			; restore DI (BDS pointer)
  5340 00001459 B90500                          	mov     cx,MAXERR		; Set up retry count
  5341                                  FormatRetry:
  5342 0000145C 51                      		push    cx
  5343                                                                  		; set up registers for format call to TO_ROM
  5344 0000145D 2EA1[C812]              		mov     AX,[CS:SectorsPerTrack]	; set number of sectors
  5345 00001461 B405                    		mov     AH,ROMFormat
  5346 00001463 0E                      		push    cs			; set ES:BX to point to
  5347 00001464 07                      		pop     es			;    the track table
  5348 00001465 BB[CC11]                		mov     BX,TrackTable
  5349                                                                                  ; don't need to set CL on format
  5350 00001468 E84202                  		call    To_ROM
  5351 0000146B 59                      		pop	cx
  5352 0000146C 7330                    		jnc	short FormatOk
  5353                                  		;pop     cx
  5354 0000146E 2EC606[CC12]01          		mov	byte [cs:Had_Format_Error],1	; Mark the error
  5355 00001474 50                      		push	ax		
  5356 00001475 51                      		push	cx			
  5357 00001476 52                      		push	dx
  5358 00001477 E82602                  		call    ResetDisk
  5359 0000147A E82F00                  		call	FormatStatus
  5360 0000147D 3C01                    		cmp	al,1
  5361 0000147F 7503                    		jnz	short While_Err
  5362 00001481 E8BD01                  		call	SetDASD 
  5363                                  While_Err:
  5364 00001484 5A                      		pop	dx
  5365 00001485 59                      		pop	cx
  5366 00001486 58                      		pop	ax
  5367 00001487 E2D3                    		loop    FormatRetry
  5368                                  
  5369                                  ; Format failed
  5370                                  Format_Failed:
  5371 00001489 2EC606[CC12]01          		mov	byte [cs:Had_Format_Error],1	; Indicate a format error
  5372 0000148F 80FC06                  		cmp	ah,Dsk_change_line_Err		; Convert change line to
  5373 00001492 7502                    		jne	short Map_Err			;   to time out.
  5374 00001494 B480                    		mov	ah,Dsk_time_out_Err
  5375                                  Map_Err:
  5376 00001496 E881FA                          	call    MAPERROR
  5377 00001499 5B                      		pop	bx
  5378 0000149A 07                      		pop	es
  5379 0000149B 5F                      		pop	di
  5380 0000149C 1F                      		pop	ds
  5381 0000149D C3                      		retn
  5382                                  
  5383                                  FormatOk:
  5384 0000149E 2EC606[CC12]00          		mov	byte [cs:Had_Format_Error],0 ; Reset format error flag
  5385                                  		;pop     cx			; clean up stack after bailing out
  5386                                  						; of FormatRetry loop early
  5387 000014A4 5B                      		pop	bx
  5388 000014A5 07                      		pop	es
  5389 000014A6 5F                      		pop	di
  5390 000014A7 1F                      		pop	ds
  5391                                  DoVerifyTrack:
  5392 000014A8 E8AC00                  	        call    VerifyTrack             ; Will reset DPT entries.
  5393 000014AB C3                      		retn
  5394                                  
  5395                                  ;
  5396                                  ; FormatStatus:
  5397                                  ; If SpecialFunction byte is 1, then this routine is called to see if there is
  5398                                  ; ROM support for the combination of sec/trk and # of cyln, and if the
  5399                                  ; combination is legal.
  5400                                  ;
  5401                                  ; Input: DS:DI points to BDS for drive
  5402                                  ;	 ES:BX points to format packet
  5403                                  ;
  5404                                  ; Output:
  5405                                  ;	SpecialFunction byte set to:
  5406                                  ;		0 - ROM support + legal combination
  5407                                  ;		1 - No ROM support
  5408                                  ;		2 - Illegal Combination
  5409                                  ;		3 - No media present, ROM support exists but can't determine
  5410                                  ;		    media
  5411                                  ;	Carry cleared.
  5412                                  ;
  5413                                  ;	For format track:
  5414                                  ;		Carry set if error
  5415                                  ;
  5416                                  ;
  5417                                  ;  Flags also may be altered. All other registers preserved.
  5418                                  ;  If the call to ROM returns no error, then the current DPT is "replaced" by
  5419                                  ;  the one returned by the ROM. This is done by changing the pointer in [DPT]
  5420                                  ;  to the one returned. The original pointer to the disk base table is stored
  5421                                  ;  in TempDPT, until it is restored.
  5422                                  ;
  5423                                  ;
  5424                                  FormatStatus:
  5425 000014AC 51                      		push	cx
  5426 000014AD 52                      		push	dx
  5427                                  			; Are we here because of a format err
  5428 000014AE 2E803E[CC12]01          		cmp	byte [cs:Had_Format_Error],1
  5429 000014B4 7411                    		je	short Fstat01
  5430 000014B6 2E803E[CB12]01          		cmp	byte [cs:Media_Set_For_Format],1
  5431 000014BC 7503                    		jnz	short FStat03
  5432 000014BE E99200                  		jmp	Stat_Ret
  5433                                  FStat03:
  5434 000014C1 2EC606[CB12]00          		mov	byte [cs:Media_Set_For_Format],0
  5435                                  ;
  5436                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  5437                                  ;			modification - sp001
  5438                                  ;	
  5439                                  ;	remove check for new rom from here. we shall just assume the
  5440                                  ;	prescence of the new rom and go ahead and issue the int13 call
  5441                                  ;	anyway. later on if there is an error we shall check this to
  5442                                  ;	see if it is there because of lack of rom support, in which
  5443                                  ;	case the appropriate error will be indicated by setting al to 1
  5444                                  ;
  5445                                  ;	I would ideally like to see the new rom testing code shifted to
  5446                                  ;	msinit and this code reintroduced. however for this version we
  5447                                  ;	are aiming to stick close to the IBM variety. 
  5448                                  ;
  5449                                  ;	More changes to support this commenting out will follow. All
  5450                                  ;	will be marked as modification sp001
  5451                                  ;
  5452                                  ;	mov	al,1			; No ROM support available error code
  5453                                  ;	test	byte ptr cs:[NEW_ROM],1
  5454                                  ;	jnz	short FStat01
  5455                                  ;	jmp	Stat_Ret
  5456                                  Fstat01:
  5457 000014C7 1E                      		push	ds
  5458 000014C8 56                      		push	si
  5459                                  
  5460 000014C9 31C0                    		xor	ax,ax
  5461 000014CB 8ED8                    		mov	ds,ax
  5462 000014CD C5367800                		lds	si,[DSKADR]		; DS:SI := pDPT
  5463                                  
  5464 000014D1 2E8936[6202]            		mov	word [cs:DPT],si	; cs:[DPT] := pDPT
  5465 000014D6 2E8C1E[6402]            		mov	word [cs:DPT+2],ds
  5466                                  
  5467 000014DB 5E                      		pop	si
  5468 000014DC 1F                      		pop	ds
  5469                                  
  5470                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  5471                                  ;			modification sp001
  5472                                  ;	
  5473                                  ;	the following instruction introduced for the new rom modification
  5474                                  ;
  5475 000014DD 2EC606[C701]01          		mov	byte [cs:NEW_ROM],1		; assume new rom
  5476                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  5477 000014E3 8B452B                  		mov	ax,[DI+BDS.cCyln]
  5478 000014E6 8B4D13                  		mov	cx,[DI+BDS.SECLIM]
  5479                                  					; set up registers for format status call
  5480 000014E9 80E403                  		and	AH,03h		; 'and' out unneeded track bits
  5481 000014EC D0CC                    		ror	AH,1		; get track and sector values correct
  5482 000014EE D0CC                    		ror	AH,1
  5483 000014F0 08CC                    		or	AH,CL		; set sector number
  5484 000014F2 86E0                    		xchg	AH,AL
  5485 000014F4 89C1                    		mov	CX,AX
  5486 000014F6 FECD                    		dec	CH
  5487 000014F8 8A5504                  		mov	DL,[DI+BDS.DriveNum] ; get drive number
  5488 000014FB B418                    		mov	AH,18h	; set command to "sec/trk supported?"
  5489                                  
  5490 000014FD 06                      		push	es
  5491 000014FE 57                      		push	di
  5492 000014FF 1E                      		push	ds
  5493 00001500 56                      		push	si
  5494                                  
  5495 00001501 CD13                    		int	13h		; call rom bios to see if supported
  5496 00001503 7234                    		jc	short Format_Stat_Err ; if carry, combination is not supported
  5497                                  
  5498                                  				; ES:DI points to new Disk Base Table
  5499                                  				; combination for this drive replace
  5500                                  				; current (DskAdr) pointer with new one,
  5501                                  				; saving the old one in TempDPT.
  5502                                  
  5503                                  		; Are we here because of a format err
  5504 00001505 2E803E[CC12]01          		cmp	byte [cs:Had_Format_Error],1
  5505 0000150B 7508                    		jnz	short Fstat02	; Then skip the disk base setup
  5506                                  	
  5507 0000150D 30C0                    		xor	al,al			; Supported and OK
  5508 0000150F 2EA2[CC12]              		mov	[cs:Had_Format_Error],al ; Clear format error
  5509 00001513 EB3A                    		jmp	short Pop_Stat_Ret	; Back to work
  5510                                  Fstat02:
  5511 00001515 31C0                    		xor	ax,ax
  5512 00001517 8ED8                    		mov	ds,ax
  5513 00001519 C5367800                		lds	si,[DSKADR]	; DS:SI := pDPT
  5514                                  
  5515 0000151D 2E8936[CD12]            		mov	[cs:TempDPT],si
  5516 00001522 2E8C1E[CF12]            		mov	[cs:TempDPT+2],ds ; Save pDPT
  5517                                  
  5518 00001527 893E7800                		mov	[DSKADR],DI 	; Setup New DPT returned by
  5519 0000152B 8C067A00                		mov	[DSKADR+2],ES	; ROM
  5520                                  
  5521 0000152F 2EC606[CB12]01          		mov	byte [cs:Media_Set_For_Format],1 ; set flag
  5522 00001535 30C0                    		xor	al,al		; Legal combination + ROM support code
  5523 00001537 EB16                    		jmp	short Pop_Stat_Ret
  5524                                  
  5525                                  Format_Stat_Err:
  5526 00001539 B003                    		mov	al,3			; Assume a time out
  5527 0000153B 80FC80                  		cmp	ah,Dsk_time_out_Err	; Was it a time out???
  5528 0000153E 740F                    		jz	short Pop_Stat_Ret	;  Yes - then done
  5529 00001540 FEC8                    		dec	al			; Assume an illegal comb.
  5530 00001542 80FC0C                  		cmp	ah,Dsk_illegal_combination ; Was it an illegal comb???
  5531 00001545 7408                    		jz	short Pop_Stat_Ret	; Yes - then done
  5532 00001547 FEC8                    		dec	al			; Assume No ROM Support	
  5533                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  5534                                  ;			modification sp001
  5535                                  ;
  5536                                  ;	the following instruction was introduced for the new_rom modification
  5537                                  ;
  5538 00001549 2EC606[C701]00          		mov	byte [cs:NEW_ROM],0	; the old rom
  5539                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  5540                                  
  5541                                  ; Return result of status call
  5542                                  Pop_Stat_Ret:
  5543 0000154F 5E                      		pop	si
  5544 00001550 1F                      		pop	ds
  5545 00001551 5F                      		pop	di
  5546 00001552 07                      		pop	es
  5547                                  Stat_Ret:
  5548 00001553 F8                      		clc
  5549 00001554 5A                      		pop	dx
  5550 00001555 59                      		pop	cx
  5551 00001556 C3                      		retn
  5552                                  
  5553                                  ;
  5554                                  ; VerifyTrack:
  5555                                  ;
  5556                                  ; Input: DS:DI points to BDS for drive
  5557                                  ;	 ES:BX points to verify packet
  5558                                  ;
  5559                                  
  5560                                  VerifyTrack:
  5561 00001557 2EC606[5602]04          		mov	byte [cs:RFLAG],ROMVerify
  5562 0000155D 268B4703                		mov	ax,[es:bx+A_VERIFYPACKET.VP_CYLINDER]
  5563 00001561 2EA3[6802]              		mov	[cs:CURTRK], ax
  5564 00001565 268B4701                		mov	ax,[es:bx+A_VERIFYPACKET.VP_HEAD]
  5565                                  
  5566                                  ;	****** ASSUMPTION ******
  5567                                  ;	we assume that we have less than 256 heads, and that the Request
  5568                                  ;	Header Data Structure is unneccessarily big
  5569 00001569 2EA2[6702]              		mov	[cs:CURHD],al
  5570 0000156D 31C0                    		xor	ax,ax
  5571 0000156F 2E8B0E[C812]            		mov	cx,[cs:SectorsPerTrack]
  5572                                  ; Use 0:0 as the transfer address for verify
  5573 00001574 31DB                    		xor	bx, bx
  5574 00001576 8EC3                    		mov	es, bx
  5575 00001578 E83100                  		call	TrackIO
  5576 0000157B C3                      		retn
  5577                                  
  5578                                  ;
  5579                                  ; ReadTrack:
  5580                                  ;
  5581                                  ; Input: DS:DI points to BDS for drive
  5582                                  ;	 ES:BX points to read packet
  5583                                  ;
  5584                                  
  5585                                  ReadTrack:
  5586 0000157C 2EC606[5602]02          		mov	byte [cs:RFLAG],ROMRead
  5587 00001582 EB08                    		jmp	short ReadWriteTrack
  5588                                  
  5589                                  ;
  5590                                  ; WriteTrack:
  5591                                  ;
  5592                                  ; Input: DS:DI points to BDS for drive
  5593                                  ;	 ES:BX points to write packet
  5594                                  ;
  5595                                  
  5596                                  WriteTrack:
  5597 00001584 2EC606[5602]03          		mov	byte [cs:RFLAG],ROMWrite
  5598 0000158A EB00                    		jmp	short ReadWriteTrack
  5599                                  ;
  5600                                  ; ReadWriteTrack:
  5601                                  ;
  5602                                  ; Input:
  5603                                  ;    DS:DI points to BDS for drive
  5604                                  ;    ES:BX points to write packet
  5605                                  ;    RFLAG - 2 for read, 3 for write
  5606                                  ;
  5607                                  
  5608                                  ReadWriteTrack:
  5609 0000158C 268B4703                		mov	ax,[es:bx+A_TRACKREADWRITEPACKET.TRWP_CYLINDER]
  5610 00001590 2EA3[6802]              		mov	[cs:CURTRK],ax
  5611 00001594 268B4701                		mov	ax,[es:bx+A_TRACKREADWRITEPACKET.TRWP_HEAD]
  5612                                  
  5613                                  ;	****** ASSUMPTION ******
  5614                                  ;	we assume that we have less than 256 heads, and that the Request
  5615                                  ;	Header Data Structure is unneccessarily big
  5616 00001598 2EA2[6702]              		mov	[cs:CURHD],al
  5617 0000159C 268B4705                		mov	ax,[es:bx+A_TRACKREADWRITEPACKET.TRWP_FIRSTSECTOR]
  5618 000015A0 268B4F07                		mov	cx,[es:bx+A_TRACKREADWRITEPACKET.TRWP_SECTORSTOREADWRITE]
  5619 000015A4 26C45F09                		les	bx,[es:bx+A_TRACKREADWRITEPACKET.TRWP_TRANSFERADDRESS]
  5620 000015A8 E80100                  		call	TrackIO
  5621 000015AB C3                      		retn
  5622                                  ;
  5623                                  ; TrackIO:
  5624                                  ;    Performs Track Read/Write/Verify
  5625                                  ;
  5626                                  ;   Input:
  5627                                  ;      RFLAG	- 2 = Read
  5628                                  ;		  3 = Write
  5629                                  ;		  4 = Verify
  5630                                  ;      ax	- Index into track table of first sector to IO
  5631                                  ;      cx	- number of sectors to IO
  5632                                  ;      es:bx	- Transfer address
  5633                                  ;      ds:di	- pointer to BDS
  5634                                  ;      curtrk	- current cylinder
  5635                                  ;      curhd	- current head
  5636                                  ;
  5637                                  
  5638                                  TrackIO:
  5639                                  ; procedure `disk' will pop stack to SPsav and return if error
  5640 000015AC 2E8926[6A02]            		mov	[cs:SPSAV], sp
  5641                                  ; Ensure correct disk is in drive
  5642 000015B1 E8C7F6                  		call	CHECKSINGLE
  5643                                  ;
  5644                                  ; Set up tables and variables for I/O
  5645                                  ;
  5646 000015B4 2E803E[CB12]01          		cmp	byte [cs:Media_Set_For_Format],1
  5647 000015BA 7407                    		jz	short DPTAlreadySet
  5648                                  ;
  5649                                  ; SET UP TABLES AND VARIABLES FOR I/O
  5650                                  ;
  5651 000015BC 50                      		push	ax
  5652 000015BD 51                      		push	cx
  5653 000015BE E8AFF7                  		call	IOSETUP
  5654 000015C1 59                      		pop	cx
  5655 000015C2 58                      		pop	ax
  5656                                  ;
  5657                                  ; point si at the table entry of the first sector to be IO'd
  5658                                  ;
  5659                                  DPTAlreadySet:
  5660 000015C3 BE[CC11]                		mov	si,TrackTable
  5661 000015C6 D1E0                    		shl	ax,1
  5662 000015C8 D1E0                    		shl	ax,1
  5663 000015CA 01C6                    		add	si,ax
  5664                                  ;
  5665                                  ; we want:
  5666                                  ;    cx to be the number of times we have to loop
  5667                                  ;    dx to be the number of sectors we read on each iteration
  5668 000015CC BA0100                  		mov	dx,1
  5669 000015CF F745290800              		test	word [DI+BDS.Flags],GOOD_TRACKLAYOUT
  5670 000015D4 7402                    		jz	short IOnextSector
  5671                                  
  5672                                  ; Hey! we can read all the sectors in one blow
  5673 000015D6 87D1                    		xchg	dx, cx
  5674                                  
  5675                                  IOnextSector:
  5676 000015D8 51                      		push	cx
  5677 000015D9 52                      		push	dx
  5678                                  ; skip over the cylinder and head in the track table
  5679 000015DA 46                      		inc	si
  5680 000015DB 46                      		inc	si
  5681                                  
  5682                                  ; Get sector id from track table
  5683 000015DC 2E8A04                  		mov     AL,[cs:si]	; get current sector value
  5684 000015DF 2EA2[6602]              		mov     [cs:CURSEC], AL	; save cursec value
  5685                                          
  5686                                  ;*** For a Fixed disk multi-track disk I/O -  4/14/86
  5687                                  ;Assumptions: 1). In the input CX (# of sectors to go) to TRACKIO, only CL is
  5688                                  ;valid.  2). Sector size should be set to 512 bytes. 3). GOODTRACKLAYOUT.
  5689                                  ;
  5690 000015E3 F745290100              		test	word [DI+BDS.Flags],fNon_Removable ;Fixed disk? - J.K
  5691 000015E8 740E                    		jz	short IOREMOVABLE		;no -
  5692 000015EA 2E8916[5802]            		mov	[cs:SECCNT], dx 		;# of sectors to I/O -
  5693 000015EF 89D0                    		mov	ax, dx				;		 
  5694 000015F1 E81DF8                  		call	DISK				;		
  5695 000015F4 5A                      		pop	dx				;		 
  5696 000015F5 59                      		pop	cx				;		
  5697 000015F6 F8                      		clc					;		
  5698 000015F7 C3                      		retn					;		
  5699                                  
  5700                                  IOREMOVABLE:		 
  5701 000015F8 2E8A4401                        	mov     AL,[cs:si+1]	; get sector size index
  5702                                  
  5703                                  		; The next eight lines put sector size index in DPT
  5704 000015FC 06                      		push    ES                      ; save value while getting pointer
  5705 000015FD 56                      		push    SI                      ;    to DPT
  5706 000015FE 50                      		push	AX
  5707                                  
  5708 000015FF 2EC436[6202]            		les     SI,[cs:DPT]		; ES:SI points to DPT
  5709                                                                                  ; put size in DPT
  5710 00001604 26884403                		mov     [ES:SI+DISK_PARMS.DISK_SECTOR_SIZ], AL
  5711 00001608 8B4513                  		mov     AX,[DI+BDS.SECLIM]        ; get number of sector/track
  5712 0000160B 26884404                		mov     [ES:SI+DISK_PARMS.DISK_EOT],AL ; patch in DPT
  5713                                  
  5714 0000160F 58                      		pop	AX			; restore register values
  5715 00001610 5E                      		pop     SI     
  5716 00001611 07                      		pop     ES
  5717                                                                          ; convert index to byte value
  5718 00001612 E82200                  		call    SectorSizeIndexToSectorSize
  5719 00001615 50                      		push    AX                      ; save number of bytes in sector
  5720 00001616 89D0                    		mov     AX, DX                  ; get number of sector for I/0
  5721                                  
  5722                                  DoTheIO:
  5723 00001618 2EA3[5802]              		mov	[cs:SECCNT],ax	; set up the count of sectors to I/O
  5724 0000161C E8F2F7                  		call	DISK		
  5725                                  					; advance buffer pointer by adding
  5726                                  					;   sector size
  5727 0000161F 58                      		pop	ax
  5728 00001620 01C3                    		add	bx, ax
  5729 00001622 5A                      		pop	dx
  5730 00001623 59                      		pop	cx
  5731 00001624 E2B2                    		loop	IOnextSector
  5732 00001626 E887F7                  		call	DONE		; Set time of last access, and reset
  5733 00001629 F8                      		clc			; entries in DPT.
  5734 0000162A C3                      		retn
  5735                                  
  5736                                  ;
  5737                                  ; The sector size in bytes needs to be converted to an index value for the IBM
  5738                                  ; ROM. (0=>128, 1=>256,2=>512,3=>1024). It is assumed that only these values
  5739                                  ; are permissible.
  5740                                  ; On Input   AX contains sector size in bytes
  5741                                  ; On Output  AL contains index
  5742                                  ;
  5743                                  
  5744                                  SectorSizeToSectorIndex:
  5745 0000162B 80E407                  		and     AH, 07h 	; very simple error correction
  5746 0000162E 88E0                    		mov     AL, AH          ; shift left 8 bits
  5747 00001630 3C04                    		cmp     AL, 4           ; size 1024?
  5748 00001632 7502                    		jnz	short SecToIndexRet ; no, then we are done
  5749 00001634 2C01                    		sub     AL, 1           ; if 1024, adjust index to 3
  5750                                  SecToIndexRet:
  5751 00001636 C3                      		retn
  5752                                  
  5753                                  SectorSizeIndexToSectorSize:
  5754                                  ; value in AH on entry is not important
  5755 00001637 51                      		push    CX              ; save CX value
  5756 00001638 88C1                    		mov     CL, AL          ; use index number as shift size
  5757 0000163A B88000                  		mov     AX, 0080h       ; set AX to 128
  5758 0000163D D3E0                    		shl     AX, CL          ; shift by index to get proper value
  5759 0000163F 59                      		pop     CX              ; restore CX value
  5760 00001640 C3                      		retn
  5761                                  
  5762                                  ;
  5763                                  ; Set up the ROM for formatting.
  5764                                  ; we have to tell the ROM BIOS what type of disk is in the drive.
  5765                                  ; On Input   - DS:DI - points to BDS
  5766                                  ;
  5767                                  SetDASD:
  5768                                  ; See if we have new ROM and have issues Set Media Type For Format call
  5769 00001641 2EF606[CB12]01                  	test    byte [cs:Media_Set_For_Format],1
  5770 00001647 7549                    		jnz	short DasdHasBeenSet
  5771                                  ; See if we have previously set DASD type
  5772 00001649 2E803E[CC12]01          		cmp	byte [cs:Had_Format_Error],1
  5773 0000164F 740C                    		je	short DoSetDasd
  5774 00001651 F745298000              		test    word [DI+BDS.Flags],SET_DASD_true
  5775 00001656 743A                    		jz	short DasdHasBeenSet
  5776 00001658 8165297FFF              		and     word [DI+BDS.Flags],~SET_DASD_true
  5777                                                  ; the next nine lines determine and put the DASD type in AL
  5778                                  DoSetDasd:
  5779 0000165D 2EC606[CC12]00          		mov	byte [cs:Had_Format_Error],0
  5780 00001663 2EC606[7002]50                  	mov	byte [cs:GAP_PATCH],50h	; assume 48tpi or 3.5" drive
  5781 00001669 807D2802                        	cmp     byte [DI+BDS.FormFactor],ffSmall ; is 3.5" drive?
  5782 0000166D 7504                            	jnz	short Not35Drive	; no, skip down
  5783 0000166F B004                            	mov     AL,04h			; yes set proper DASD value
  5784 00001671 EB18                    		jmp     short Do_Set            ; jump down
  5785                                  
  5786                                  Not35Drive:
  5787 00001673 B001                    		mov     AL,01h			;
  5788 00001675 807D2801                		cmp     byte [DI+BDS.FormFactor],ff96tpi; 96tpi disk drive?
  5789 00001679 7510                    		jnz	short Do_Set		; no skip down to rom call
  5790 0000167B FEC0                    		inc     AL                      ; reflect 96tpi drive in DASD type
  5791 0000167D 807D130F                		cmp     byte [DI+BDS.SECLIM],15 ; 96tpi media in drive?
  5792 00001681 7508                    		jnz	short Do_Set		; no, skip down to rom call
  5793 00001683 FEC0                    		inc     AL                      ; reflect 96tpi media in DASD type
  5794 00001685 2EC606[7002]54          		mov	byte [cs:GAP_PATCH],54h ;  and in the GAP_PATCH
  5795                                  Do_Set:
  5796 0000168B B417                    		mov     AH,17h			; set command to Set DASD type
  5797 0000168D 8A5504                  		mov     DL,[DI+BDS.DriveNum]	; set drive number
  5798 00001690 CD13                    		int     13h                     ; call rom-bios
  5799                                  DasdHasBeenSet:
  5800 00001692 8A6513                  		mov     ah,[DI+BDS.SECLIM]
  5801 00001695 2E8826[6C02]            		mov	[cs:FORMT_EOT],ah
  5802 0000169A C3                      		retn
  5803                                  
  5804                                  ;
  5805                                  ; This routine is called if an error occurs while formatting or verifying.
  5806                                  ; It resets the drive, and decrements the retry count.
  5807                                  ; On Entry - DS:DI - points to BDS for the drive
  5808                                  ;	     BP    - contains retry count
  5809                                  ; On Exit    Flags indicate result of decrementing retry count
  5810                                  ;
  5811                                  ;
  5812                                  ;  There are some drives that "lose" the changeline indication if another
  5813                                  ;  floppy drive is accessed before the changeline is recorded by the device
  5814                                  ;  driver. In this situation, it is possible for the ROM to also not detect
  5815                                  ;  that the medium has changed. So, the end result is that we could have a
  5816                                  ;  diskette in the drive for which we can not even read the boot sector.
  5817                                  ;  We "fix" this by setting the byte at location DISK_STATE_MACHINE_DRV_0 (hex)
  5818                                  ;  for physical drive 0 (or DISK_STATE_MACHINE_DRV_1  for drive 1) to 0 (See
  5819                                  ;  IBM PC/AT "blessed" addresses Document for explanation) . This tells the ROM
  5820                                  ;  that the medium is 'unknown'.  The ROM actually uses these locations for
  5821                                  ;  itself.  Note that we do this only for internal drives; we do not do this for
  5822                                  ;  fixed disks or for physical drives > 1. We may end up corrupting some
  5823                                  ;  other bytes in memory that may be used for something else.
  5824                                  ;  NOTE: We do not stuff this byte if the last operation was a FORMAT because
  5825                                  ;  the ROM loses track of what it is trying to format!!
  5826                                  ;
  5827                                  ;  This routine was changed to only stuff 61H when the drive indicated it
  5828                                  ;  supported changeline. The Phoenix ROM was taking a very long time
  5829                                  ;  to figure out what the media was which caused disk time outs to take
  5830                                  ;  forever
  5831                                  ;
  5832                                  ;  We assume that DS:DI points to the current BDS for this drive.
  5833                                  ;	no registers should be touched
  5834                                  ;
  5835                                  
  5836                                  AGAIN:
  5837 0000169B E80200                  		call	ResetDisk
  5838 0000169E 4D                      		dec	bp		; decrement retry count
  5839 0000169F C3                      		RETN
  5840                                  
  5841                                  ResetDisk:
  5842 000016A0 50                      		push	ax
  5843 000016A1 30E4                    		xor	AH, AH			; set command to reset disk
  5844 000016A3 CD13                    		int	13h			; call the rom-bios
  5845 000016A5 58                      		pop	ax
  5846 000016A6 2EC606[C101]FF          		mov	byte [cs:STEP_DRV],-1	; zap up the speed
  5847 000016AC C3                      		retn
  5848                                  
  5849                                  ;
  5850                                  ; This routine sets up the Drive Parameter Table with the values needed for
  5851                                  ; Format, does an Int 13. Values in DPT are restored after a VERIFY is done.
  5852                                  ;
  5853                                  ; On Entry  -	DS:DI - points to BDS for the drive
  5854                                  ;		ES:BX - points to TRKBUF
  5855                                  ;		AL    - number of sectors
  5856                                  ;		AH    - Int 13 function code
  5857                                  ;		CL    - Sector number for verify
  5858                                  ; On Exit   -	DS,DI,ES,BX remain unchanged.
  5859                                  ;		ax and flags are the results of the int 13
  5860                                  ;
  5861                                  
  5862                                  To_ROM:
  5863 000016AD 1E                      		push	ds
  5864 000016AE 57                      		push	di
  5865 000016AF 06                      		push	es
  5866 000016B0 53                      		push	bx
  5867 000016B1 56                      		push	si
  5868                                  
  5869                                  ; The below line was replaced because saving the DPT is predicated upon
  5870                                  ; whether the functionality of the new ROM was used, not if it exists.
  5871                                  ;		test	byte ptr cs:[NEW_ROM],1
  5872                                  
  5873 000016B2 2EF606[CB12]01          		test	byte [cs:Media_Set_For_Format],1
  5874 000016B8 753D                    		jnz	short Got_Valid_DPT
  5875                                  
  5876                                  ; Set up values in the DPT
  5877                                  ; Set up motor start correctly for 3.5" drives.
  5878 000016BA 50                      		push	ax
  5879 000016BB 1E                      		push	ds
  5880                                  
  5881 000016BC 31C0                    		xor	ax,ax
  5882 000016BE 8ED8                    		mov	ds,ax
  5883 000016C0 C5367800                		lds	si,[DSKADR]	; DS:SI := pDPT
  5884                                  
  5885 000016C4 2E8936[6202]            		mov	[cs:DPT],si
  5886 000016C9 2E8C1E[6402]            		mov	[cs:DPT+2],ds	; Save pDPT
  5887                                  
  5888 000016CE 1F                      		pop     ds
  5889 000016CF 06                      		push    ES		; save value in ES
  5890 000016D0 2EC436[6202]            		LES     SI,[CS:DPT]
  5891                                  
  5892 000016D5 8B5513                  		mov     DX,[DI+BDS.SECLIM] ; set the sector per track in
  5893 000016D8 26885404                		mov     [es:si+DISK_PARMS.DISK_EOT],DL	; the Disk Parameter Table
  5894 000016DC 83FA0F                  		cmp     DX, 15                  ; 96tip media?
  5895 000016DF 7409                    		jz	short To_ROM1		; yes, skip down
  5896                                                                  ; no - set Format Gap to 320/360 media value
  5897 000016E1 2E8A0E[7002]            		mov     CL,[cs:GAP_PATCH]
  5898 000016E6 26884C07                		mov     [ES:SI+DISK_PARMS.DISK_FORMT_GAP],CL
  5899                                  To_ROM1:                                ; 3.5" floppy drive?
  5900 000016EA 807D2802                		cmp     byte [DI+BDS.FormFactor],ffSmall
  5901 000016EE 7505                    		jnz	short To_ROM2	; no, skip down
  5902                                                                  ; yes - reset disk motor start value
  5903 000016F0 26C6440A04              		mov     byte [ES:SI+DISK_PARMS.DISK_MOTOR_STRT],4
  5904                                  To_ROM2:
  5905 000016F5 07                      		pop     ES		; restore ES value
  5906 000016F6 58                      		pop     ax
  5907                                  
  5908                                  Got_Valid_DPT:
  5909                                   					; now set up the registers
  5910 000016F7 8A5504                          	mov     DL,[DI+BDS.DriveNum] ; set drive number
  5911 000016FA 2E8A36[6D02]                    	mov     DH,[CS:HDNUM]	; set head number
  5912 000016FF 2E8B0E[6E02]            		mov     CX,[CS:TRKNUM]	; set track number
  5913 00001704 D0CD                    		ror     CH,1
  5914 00001706 D0CD                    		ror     CH,1
  5915 00001708 86E9                    		xchg    CH, CL
  5916 0000170A CD13                    		int     13h		; call the rom-bios disk routines
  5917 0000170C 5E                      		pop	si
  5918 0000170D 5B                      		pop	bx
  5919 0000170E 07                      		pop	es
  5920 0000170F 5F                      		pop	di
  5921 00001710 1F                      		pop	ds
  5922 00001711 C3                      		retn
  5923                                  
  5924                                  ;
  5925                                  ; Get the owner of the physical drive represented by the logical drive in BL.
  5926                                  ; The assumption is that we **ALWAYS** keep track of the owner of a drive!!
  5927                                  ; If this is not the case, the system may hang, just following the linked list.
  5928                                  ;
  5929                                  
  5930                                  IOCTL$GETOWN:
  5931 00001712 E81CF5                  		call	SETDRIVE
  5932 00001715 8A4504                  		mov	al,[DI+BDS.DriveNum]	; Get physical drive number
  5933 00001718 0E                      		push	cs
  5934 00001719 1F                      		pop	ds
  5935 0000171A BF[4C02]                		mov	di,START_BDS
  5936                                  Own_Loop:
  5937 0000171D 384504                  		cmp	[DI+BDS.DriveNum],al
  5938 00001720 7507                    		jne	short GetNextBDS
  5939 00001722 F745292000              		test	word [DI+BDS.Flags],fI_Own_Physical
  5940 00001727 7509                    		jnz	short Done_GetOwn
  5941                                  GetNextBDS:
  5942 00001729 8B5D02                  		mov	bx,[DI+BDS.Link+2]
  5943                                  		;mov	di,[DI+BDS.Link]
  5944 0000172C 8B3D                    		mov	di,[di] ; 05/07/2019
  5945 0000172E 8EDB                    		mov	ds,bx
  5946 00001730 EBEB                    		jmp	short Own_Loop
  5947                                  Done_GetOwn:
  5948 00001732 EB1D                    		JMP	SHORT EXIT_OWN
  5949                                  
  5950                                  ;
  5951                                  ; Set the ownership of the physical drive represented by the logical drive in
  5952                                  ; BL.
  5953                                  ;
  5954                                  
  5955                                  IOCTL$SETOWN:
  5956 00001734 E8FAF4                  		call	SETDRIVE
  5957 00001737 2EC606[C601]01          		mov	byte [cs:fSetOwner],1	; set flag for CheckSingle to
  5958                                  						; look at.
  5959 0000173D E83BF5                  		call	CHECKSINGLE		; Set ownership of drive
  5960 00001740 2EC606[C601]00          		mov	byte [cs:fSetOwner],0	; reset flag
  5961 00001746 31DB                    		xor	bx,bx
  5962 00001748 8EC3                    		mov	es,bx
  5963 0000174A B1FF                    		mov	cl,-1
  5964 0000174C 26880E0405              		mov	byte [es:LSTDRV],cl 	; Set up SDSB as well
  5965                                  
  5966                                  EXIT_OWN:
  5967                                  ; If there is only one logical drive assigned to this physical drive, return
  5968                                  ; 0 to user to indicate this.
  5969 00001751 30C9                    		xor	cl,cl
  5970 00001753 F745291000              		test	word [DI+BDS.Flags],fI_Am_Mult
  5971 00001758 7405                    		jz	short EXIT_NO_MULT
  5972 0000175A 8A4D05                  		mov	cl,[DI+BDS.DriveLet]	; Get logical drive number
  5973 0000175D FEC1                    		inc	cl			; get it 1-based
  5974                                  EXIT_NO_MULT:
  5975 0000175F 2EC51E[B800]            		LDS	BX,[CS:PTRSAV]
  5976 00001764 884F01                  		mov	[BX+UNIT],CL
  5977 00001767 E91EEF                  		jmp	EXIT
  5978                                  
  5979                                  ;
  5980                                  ; Moves the old DPT that had been saved in TempDPT back to DPT. This is done
  5981                                  ; only if the first byte of TempDPT is not -1.
  5982                                  ; All registers (including flags) are preserved.
  5983                                  ;
  5984                                  
  5985                                  RestoreOldDPT:
  5986                                  ; If we have already restored the disk base table earlier, do not do it
  5987                                  ; again.
  5988 0000176A 50                      		push	ax
  5989 0000176B 30C0                    		xor	al,al
  5990                                  ; Reset flag and get current flag setting
  5991 0000176D 2EA2[CC12]              		mov	[cs:Had_Format_Error],al
  5992 00001771 2E8606[CB12]            		xchg	[cs:Media_Set_For_Format],al
  5993 00001776 08C0                    		or	al,al
  5994 00001778 7419                    		jz	short DontRestore
  5995 0000177A 56                      		push	si
  5996 0000177B 1E                      		push	ds
  5997 0000177C 06                      		push	es
  5998 0000177D 2EC536[CD12]            		LDS	SI,[CS:TempDPT]
  5999 00001782 31C0                    		xor	ax,ax
  6000 00001784 8EC0                    		mov	es,ax			; have ES -> segment 0
  6001 00001786 2689367800              		MOV	[ES:DSKADR],SI
  6002 0000178B 268C1E7A00              		MOV	[ES:DSKADR+2],DS
  6003                                  GotCurrentDPT:
  6004 00001790 07                      		pop	es
  6005 00001791 1F                      		pop	ds
  6006 00001792 5E                      		pop	si
  6007                                  DontRestore:
  6008 00001793 58                      		pop	ax
  6009 00001794 F8                      		clc				; clear carry
  6010 00001795 C3                      		retn				; (7/31/86)
  6011                                  
  6012                                  ;end of file msioctl.asm
  6013                                  
  6014                                  ; ............................................................................
  6015                                  
  6016                                  ;-----------------------------------------------------------------------------
  6017                                  ; MSDISK.ASM (2) - MSDOS 3.3 - 02/02/1988
  6018                                  ;-----------------------------------------------------------------------------
  6019                                  ; 28/05/2018 - Retro DOS v3.0
  6020                                  ; 24/03/2018 - Retro DOS v2.0 
  6021                                  
  6022                                  ;
  6023                                  ; Check_Wrap is a routine that adjusts the starting sector, starting head
  6024                                  ; and starting cylinder for an Int 13 request that requests I/O of a lot
  6025                                  ; of sectors. It only does this for fixed disks. It is used in the sections
  6026                                  ; of code that handle ECC errors and DMA errors. It is necessary, because
  6027                                  ; ordinarily the ROM would take care of wraps around heads and cylinders,
  6028                                  ; but we break down a request when we get an ECC or DMA error into several
  6029                                  ; I/O of one or more sectors. In this case, we may already be beyond the
  6030                                  ; number of sectors on a track on the medium, and the request would fail.
  6031                                  ;
  6032                                  ; Input conditions:
  6033                                  ;	ALL registers set up for an Int 13 request.
  6034                                  ;
  6035                                  ; Output:
  6036                                  ;	 - contains starting head number for request
  6037                                  ;	 - contains starting sector and cylinder numbers
  6038                                  ;	(The above may or may not have been changed, and are 0-based)
  6039                                  ;	All other registers preserved.
  6040                                  ;
  6041                                  
  6042                                  Check_Wrap:
  6043 00001796 50                      		push	ax
  6044 00001797 53                      		push	bx
  6045 00001798 1E                      		push	ds
  6046 00001799 57                      		push	di
  6047 0000179A 2EC606[C201]01          		mov	byte [cs:PHYS_DRV],1;Use phys. drive in AL to get BDS
  6048 000017A0 88D0                    		mov	al,dl		; put drive number in AL for get BDS
  6049 000017A2 E88CF4                  		call	SETDRIVE	; Get pointer to BDS for drive.
  6050 000017A5 2EC606[C201]00          		mov	byte [cs:PHYS_DRV],0; Restore flag to use Logical Drive
  6051 000017AB 725E                    		jc	short No_Wrap	; Do nothing if wrong phys. drive
  6052                                  
  6053 000017AD F745290100              		test	word [DI+BDS.Flags],fNon_Removable
  6054 000017B2 7457                    		jz	short No_Wrap	; No wrapping for removable media
  6055 000017B4 8B5D13                  		MOV	BX,[DI+BDS.SECLIM]
  6056 000017B7 89C8                    		MOV	AX,CX
  6057 000017B9 83E03F                  		AND	AX,003FH	; EXTRACT SECTOR NUMBER
  6058 000017BC 39D8                    		cmp	ax,bx		; If Wrap
  6059 000017BE 764B                    		jbe	short No_Wrap
  6060                                  
  6061 000017C0 F6F3                    		div	bl		; AH=new sector#, AL = # of head wraps
  6062                                  
  6063                                  ; We need to be careful here.  If the new sector number == 0, then we are
  6064                                  ; on the last sector on that track
  6065 000017C2 08E4                    		or	ah,ah
  6066 000017C4 7504                    		jnz	short Not_on_Bound
  6067                                  
  6068 000017C6 88DC                    		mov	ah,bl		; set sector = SECLIM if on Bndry
  6069 000017C8 FEC8                    		dec	al		; and decrement Num. head wraps
  6070                                  
  6071                                  Not_on_Bound:
  6072 000017CA 80E1C0                  		and	CL,0C0H		; zero out sector #
  6073                                  
  6074 000017CD 08E1                    		or	CL,AH		; OR in new sector #
  6075 000017CF 30E4                    		xor	ah,ah		; AX = # of head wraps
  6076 000017D1 40                      		inc	ax
  6077 000017D2 00F0                    		add	al,DH		; add in starting head #
  6078 000017D4 80D400                  		adc	ah,0		; catch any carry
  6079 000017D7 3B4515                  		CMP	AX,[DI+BDS.HDLIM] ; are we going to wrap around a head?
  6080 000017DA 7635                    		jbe	short No_Wrap_Head ; Do not lose new head number!!
  6081                                  
  6082 000017DC 52                      		push	DX		; preserve drive number and head number
  6083 000017DD 31D2                    		xor	dx,dx
  6084 000017DF 8B5D15                  		mov	bx,[DI+BDS.HDLIM]
  6085 000017E2 F7F3                    		div	bx		; DX=new head #, AX=# of cylinder wraps
  6086                                  ; Careful here! If new head # is 0, then we are on the last head.
  6087 000017E4 09D2                    		or	dx,dx
  6088 000017E6 7507                    		jnz	short No_Head_Bound
  6089                                  
  6090 000017E8 89DA                    		mov	dx,bx		; On boundary. Set to HDLIM
  6091                                  ; If we had some cylinder wraps, we need to reduce them by one!!
  6092 000017EA 09C0                    		or	ax,ax
  6093 000017EC 7401                    		jz	short No_Head_Bound
  6094                                  
  6095 000017EE 48                      		dec	ax		; Reduce number of cylinder wraps
  6096                                  No_Head_Bound:
  6097 000017EF 88D7                    		mov	bh,dl		; bh has new head number
  6098 000017F1 5A                      		POP	DX		; restore drive number and head number
  6099                                  
  6100 000017F2 FECF                    		dec	bh		; get it 0-based
  6101 000017F4 88FE                    		mov	DH,bh		; set up new head number in DH
  6102                                  
  6103 000017F6 88CF                    		mov	bh,CL
  6104 000017F8 80E73F                  		and	bh,3FH		; preserve sector number
  6105 000017FB B306                    		mov	bl,6
  6106 000017FD 86CB                    		xchg	cl,bl
  6107 000017FF D2EB                    		shr	bl,cl		; get ms cylinder bits to ls end
  6108                                  
  6109 00001801 00C5                    		ADD	CH,AL		; ADD IN CYLINDER WRAP
  6110 00001803 10E3                    		adc	bl,ah		; add in high byte
  6111 00001805 D2E3                    		shl	bl,cl		; move up to ms end
  6112 00001807 86D9                    		xchg	bl,cl		; restore cylinder bits into CL
  6113 00001809 08F9                    		or	CL,bh		; OR in sector number
  6114                                  No_Wrap:
  6115 0000180B F8                      		clc			; reset carry
  6116 0000180C 5F                      		pop	di
  6117 0000180D 1F                      		pop	ds
  6118 0000180E 5B                      		pop	bx
  6119 0000180F 58                      		pop	ax
  6120 00001810 C3                      		retn
  6121                                  
  6122                                  No_Wrap_Head:
  6123 00001811 88C6                    		mov	DH,al		; Do not lose new head number
  6124 00001813 FECE                    		dec	DH		; get it 0-based
  6125 00001815 EBF4                    		jmp	short No_Wrap
  6126                                  
  6127                                  ; INT_2F_13:
  6128                                  ;		This code is chained into the INT_2F interrupt during bios
  6129                                  ;	initialization.  It allows the user to change the ORIG13 int_13 vector
  6130                                  ;	after booting.	This allows testing and implementation of custom int_13
  6131                                  ;	handlers, without giving up MS-DOS error recovery
  6132                                  ;
  6133                                  ;	Entry Conditions
  6134                                  ;		AH	== RESET_Int_13  (13h)
  6135                                  ;		DS:DX	== Address of New INT_13 Handler
  6136                                  ;		ES:BX	== Address of New INT_13 vector used by WARM BOOT
  6137                                  ;								(INT 19)
  6138                                  ;
  6139                                  ;	Exit Conditions
  6140                                  ;		Orig13	== Address of new Int_13 Handler
  6141                                  ;		DS:DX	== Old ORIG13 value
  6142                                  ;		ES:BX	== Old OLD13  value
  6143                                  
  6144                                  INT_2F_13:
  6145 00001817 80FC13                  		cmp	AH,13h			; IF (interrupt_value != Reset_Int_13)
  6146 0000181A 7405                    		je	short Chg_Orig13
  6147 0000181C 2EFF2E[4802]            		jmp	far [CS:NEXT2F_13]	;    THEN Continue on Int_2F chain
  6148                                  
  6149                                  Chg_Orig13:					;    ELSE
  6150 00001821 2EFF36[B400]            		push	word [CS:ORIG13]	;	 Save Old value of OLD13 and
  6151 00001826 2EFF36[B600]            		push	word [CS:ORIG13+2]	;	 ORIG13 so that we can
  6152                                  
  6153 0000182B 2EFF36[B000]            		push	word [CS:OLD13]		;	 Return them to caller
  6154 00001830 2EFF36[B200]            		push	word [CS:OLD13+2]
  6155                                  
  6156 00001835 2E8916[B400]            		mov	word [CS:ORIG13],DX	;	 Orig13 := Addr. Of New INT_13
  6157                                  						;	             		Vector
  6158 0000183A 2E8C1E[B600]            		mov	word [CS:ORIG13+2],DS
  6159                                  
  6160 0000183F 2E891E[B000]            		mov	word [CS:OLD13],BX	;	 Old13 := Addr. Of New
  6161                                  						;			  Boot_13 vector
  6162 00001844 2E8C06[B200]            		mov	word [CS:OLD13+2],ES
  6163                                  
  6164 00001849 07                      		pop	ES			;	 ES:BX := Old OLD13 vector
  6165 0000184A 5B                      		pop	BX
  6166                                  
  6167 0000184B 1F                      		pop	DS			;	 DS:DX := Old ORIG13 vector
  6168 0000184C 5A                      		pop	DX
  6169                                  
  6170 0000184D CF                      		iret				;    END else
  6171                                  
  6172                                  Move:
  6173 0000184E 51                      		push	CX
  6174 0000184F B90001                  		mov	CX,512/2
  6175 00001852 FC                      		cld
  6176 00001853 F3A5                    		rep	MOVSW
  6177 00001855 59                      		pop	CX
  6178 00001856 C3                      		retn
  6179                                  
  6180                                  DoINT:
  6181 00001857 8A5608                  		mov	DL,[BP+INT13FRAME.olddx]
  6182 0000185A 30E4                    		xor	AH,AH
  6183 0000185C 08C0                    		or	AL,AL
  6184 0000185E 740F                    		jz	short DoIntDone
  6185 00001860 8A6603                  		mov	AH,[BP+INT13FRAME.oldax+1]
  6186 00001863 FF760E                  		push	word [BP+INT13FRAME.oldf]
  6187 00001866 2EFF1E[B400]            		call	far [CS:ORIG13]
  6188 0000186B 9C                      		pushf
  6189 0000186C 8F460E                  		pop	word [BP+INT13FRAME.oldf]
  6190                                  DoIntDone:
  6191 0000186F C3                      		retn
  6192                                  
  6193                                  ;-----------------------------------------------------------------------------
  6194                                  ; MSBIO2.ASM - MSDOS 3.3 - 02/02/1988
  6195                                  ;-----------------------------------------------------------------------------
  6196                                  ; 29/05/2018 - Retro DOS v3.0
  6197                                  ; 25/03/2018 - Retro DOS v2.0 
  6198                                  
  6199                                  ;;Rev 3.30 modification ----------------------------
  6200                                  
  6201                                  INT19SEM:
  6202 00001870 00                      		DB	0		; INDICATE THAT ALL INT 19
  6203                                  					; INITIALIZATION IS COMPLETE
  6204                                  
  6205                                  		;EVENB
  6206 00001871 90<rep 3h>              align 4
  6207                                  
  6208                                  ORIG19:
  6209 00001874 00000000                		dd	0
  6210                                  
  6211                                  	;IRP	AA,<02,08,09,0A,0B,0C,0D,0E,70,72,73,74,76,77>
  6212                                  	;public	Int19OLD&AA
  6213                                  ;Int19OLD&AA	dd	-1		;Orignal hw int. vec for INT 19h.
  6214                                  	;ENDM
  6215                                  
  6216 00001878 FFFFFFFF                INT19OLD02:	dd	-1
  6217 0000187C FFFFFFFF                INT19OLD08:	dd	-1
  6218 00001880 FFFFFFFF                INT19OLD09:	dd	-1
  6219 00001884 FFFFFFFF                INT19OLD0A:	dd	-1
  6220 00001888 FFFFFFFF                INT19OLD0B:	dd	-1
  6221 0000188C FFFFFFFF                INT19OLD0C:	dd	-1
  6222 00001890 FFFFFFFF                INT19OLD0D:	dd	-1
  6223 00001894 FFFFFFFF                INT19OLD0E:	dd	-1
  6224 00001898 FFFFFFFF                INT19OLD70:	dd	-1	
  6225 0000189C FFFFFFFF                INT19OLD72:	dd	-1
  6226 000018A0 FFFFFFFF                INT19OLD73:	dd	-1
  6227 000018A4 FFFFFFFF                INT19OLD74:	dd	-1
  6228 000018A8 FFFFFFFF                INT19OLD76:	dd	-1
  6229 000018AC FFFFFFFF                INT19OLD77:	dd	-1	
  6230                                  
  6231                                  		;EVENB
  6232                                  ;align 2
  6233                                  
  6234                                  DSKDRVS:	; 29/05/2018
  6235 000018B0 [8804]                  		DW	FDRIVE1
  6236 000018B2 [DA04]                  		DW	FDRIVE2
  6237 000018B4 [2C05]                  		DW	FDRIVE3
  6238 000018B6 [7E05]                  		DW	FDRIVE4
  6239                                  HDSKTAB:
  6240 000018B8 [BC1B]                  		DW	HDRIVE
  6241 000018BA [0E1C]                  		DW	DRIVEX
  6242                                  
  6243                                  ;* Next area is reserved for mini disk BPB pointers *** 4/7/86
  6244                                  ;* Don't change this pos. Should be add. from DskDrvs *** 4/7/86
  6245                                  MINI_DISK_BPB_PTRS:	
  6246 000018BC 00<rep 28h>             		times 40 db 0 ;4/7/86 - mem res for Mini disk.
  6247                                  
  6248                                  	;EVENB
  6249                                  ;align 2
  6250                                  
  6251                                  INT_2F_NEXT:
  6252 000018E4 00000000                		dd	0
  6253                                  RET_ADDR:
  6254 000018E8 00000000                		dd	0
  6255                                  
  6256                                  ;;End of modification ----------------------------
  6257                                  
  6258                                  
  6259                                  ;  INT19
  6260                                  ;
  6261                                  ;	We "hook" the INT_REBOOT vector, because contrary to IBM documentation,
  6262                                  ;  it does NOT "bootstrap" the machine.  It leaves memory almost untouched.
  6263                                  ;  Since the BIOS_INIT code assumes that certain Interrupt Vectors point to
  6264                                  ;  the ROM_BIOS  we must "unhook" them before issuing the actual INT_REBOOT.
  6265                                  ;  Currently the following vectors need to be unhooked:
  6266                                  ;		  02,08,09,0A,0B,0C,0D,0E,70,72,73,74,75,76,77
  6267                                  ;
  6268                                  
  6269                                  INT19:
  6270 000018EC 31C0                    		xor	AX,AX		; get data segment to
  6271 000018EE 8ED8                    		mov	DS,AX		;   point to the vector table
  6272 000018F0 2EC43E[B000]            		les	DI,[CS:OLD13]	; get ES to point to this segment
  6273 000018F5 893E4C00                		mov	[13h*4],DI	; restore old int13 value
  6274 000018F9 8C064E00                		mov	[13h*4+2],ES
  6275                                  
  6276 000018FD 2E803E[7018]00          		cmp	byte [CS:INT19SEM], 0
  6277 00001903 7503                    		jnz	short int19vecs
  6278 00001905 E96201                  		jmp	doint19
  6279                                  
  6280                                  ;Stacks code has changed these hardware interrupt vectors
  6281                                  ;STKINIT in SYSINIT1 will initialize Int19hOLDxx values.
  6282                                  
  6283                                  int19vecs:
  6284                                  
  6285                                  ;
  6286                                  ; we now need to unhook all the vector replace to prevent stack overflow
  6287                                  ;
  6288                                  
  6289                                  ;;Rev 3.30 modification ----------------------------
  6290                                  
  6291 00001908 31C0                    		XOR	AX,AX
  6292 0000190A 8ED8                    		MOV	DS,AX
  6293                                  
  6294                                  		;IRP	AA,<02,08,09,0A,0B,0C,0D,0E,70,72,73,74,76,77>
  6295                                  
  6296                                  		;LES	DI,Int19OLD&AA
  6297                                  
  6298 0000190C 2EC43E[7818]            		LES	DI,[CS:INT19OLD02] ; 15/06/2018
  6299                                  
  6300 00001911 8CC0                    		mov	ax,es		; Put segment where we can compare it
  6301 00001913 83F8FF                  		cmp	ax,-1		; OPT 0ffffh is not likely
  6302                                  		;je	skip_int&AA	; OPT could get away without checking
  6303 00001916 740D                    		je	short skip_int02
  6304 00001918 83FFFF                  		cmp	di,-1		; OPT offset here.
  6305                                  		;je	skip_int&AA
  6306 0000191B 7408                    		je	short skip_int02
  6307                                  
  6308                                  		;MOV	DS:[AA&H*4],DI
  6309 0000191D 893E0800                		mov	[02H*4],DI
  6310                                  		;MOV	DS:[AA&H*4+2],ES
  6311 00001921 8C060A00                		mov	[02H*4+2],ES
  6312                                  	
  6313                                  ;skip_int&AA:
  6314                                  skip_int02:
  6315                                  		;ENDM
  6316                                  
  6317 00001925 2EC43E[7C18]            		LES	DI,[CS:INT19OLD08]
  6318                                  
  6319 0000192A 8CC0                    		mov	ax,es
  6320 0000192C 83F8FF                  		cmp	ax,-1
  6321 0000192F 740D                    		je	short skip_int08
  6322 00001931 83FFFF                  		cmp	di,-1
  6323 00001934 7408                    		je	short skip_int08
  6324                                  
  6325 00001936 893E2000                		mov	[08H*4],DI
  6326 0000193A 8C062200                		mov	[08H*4+2],ES
  6327                                  	
  6328                                  skip_int08:
  6329 0000193E 2EC43E[8018]            		LES	DI,[CS:INT19OLD09]
  6330                                  
  6331 00001943 8CC0                    		mov	ax,es
  6332 00001945 83F8FF                  		cmp	ax,-1
  6333 00001948 740D                    		je	short skip_int09
  6334 0000194A 83FFFF                  		cmp	di,-1
  6335 0000194D 7408                    		je	short skip_int09
  6336                                  
  6337 0000194F 893E2400                		mov	[09H*4],DI
  6338 00001953 8C062600                		mov	[09H*4+2],ES
  6339                                  	
  6340                                  skip_int09:
  6341 00001957 2EC43E[8418]            		LES	DI,[CS:INT19OLD0A]
  6342                                  
  6343 0000195C 8CC0                    		mov	ax,es
  6344 0000195E 83F8FF                  		cmp	ax,-1
  6345 00001961 740D                    		je	short skip_int0A
  6346 00001963 83FFFF                  		cmp	di,-1
  6347 00001966 7408                    		je	short skip_int0A
  6348                                  
  6349 00001968 893E2800                		mov	[0AH*4],DI
  6350 0000196C 8C062A00                		mov	[0AH*4+2],ES
  6351                                  	
  6352                                  skip_int0A:
  6353 00001970 2EC43E[8818]            		LES	DI,[CS:INT19OLD0B]
  6354                                  
  6355 00001975 8CC0                    		mov	ax,es
  6356 00001977 83F8FF                  		cmp	ax,-1
  6357 0000197A 740D                    		je	short skip_int0B
  6358 0000197C 83FFFF                  		cmp	di,-1
  6359 0000197F 7408                    		je	short skip_int0B
  6360                                  
  6361 00001981 893E2C00                		mov	[0BH*4],DI
  6362 00001985 8C062E00                		mov	[0BH*4+2],ES
  6363                                  	
  6364                                  skip_int0B:
  6365 00001989 2EC43E[8C18]            		LES	DI,[CS:INT19OLD0C]
  6366                                  
  6367 0000198E 8CC0                    		mov	ax,es
  6368 00001990 83F8FF                  		cmp	ax,-1
  6369 00001993 740D                    		je	short skip_int0C
  6370 00001995 83FFFF                  		cmp	di,-1
  6371 00001998 7408                    		je	short skip_int0C
  6372                                  
  6373 0000199A 893E3000                		mov	[0CH*4],DI
  6374 0000199E 8C063200                		mov	[0CH*4+2],ES
  6375                                  	
  6376                                  skip_int0C:
  6377 000019A2 2EC43E[9018]            		LES	DI,[CS:INT19OLD0D]
  6378                                  
  6379 000019A7 8CC0                    		mov	ax,es
  6380 000019A9 83F8FF                  		cmp	ax,-1
  6381 000019AC 740D                    		je	short skip_int0D
  6382 000019AE 83FFFF                  		cmp	di,-1
  6383 000019B1 7408                    		je	short skip_int0D
  6384                                  
  6385 000019B3 893E3400                		mov	[0DH*4],DI
  6386 000019B7 8C063600                		mov	[0DH*4+2],ES
  6387                                  	
  6388                                  skip_int0D:
  6389 000019BB 2EC43E[9418]            		LES	DI,[CS:INT19OLD0E]
  6390                                  
  6391 000019C0 8CC0                    		mov	ax,es
  6392 000019C2 83F8FF                  		cmp	ax,-1
  6393 000019C5 740D                    		je	short skip_int0E
  6394 000019C7 83FFFF                  		cmp	di,-1
  6395 000019CA 7408                    		je	short skip_int0E
  6396                                  
  6397 000019CC 893E3800                		mov	[0EH*4],DI
  6398 000019D0 8C063A00                		mov	[0EH*4+2],ES
  6399                                  	
  6400                                  skip_int0E:
  6401 000019D4 2EC43E[9818]            		LES	DI,[CS:INT19OLD70]
  6402                                  
  6403 000019D9 8CC0                    		mov	ax,es
  6404 000019DB 83F8FF                  		cmp	ax,-1
  6405 000019DE 740D                    		je	short skip_int70
  6406 000019E0 83FFFF                  		cmp	di,-1
  6407 000019E3 7408                    		je	short skip_int70
  6408                                  
  6409 000019E5 893EC001                		mov	[70H*4],DI
  6410 000019E9 8C06C201                		mov	[70H*4+2],ES
  6411                                  	
  6412                                  skip_int70:
  6413 000019ED 2EC43E[9C18]            		LES	DI,[CS:INT19OLD72]
  6414                                  
  6415 000019F2 8CC0                    		mov	ax,es
  6416 000019F4 83F8FF                  		cmp	ax,-1
  6417 000019F7 740D                    		je	short skip_int72
  6418 000019F9 83FFFF                  		cmp	di,-1
  6419 000019FC 7408                    		je	short skip_int72
  6420                                  
  6421 000019FE 893EC801                		mov	[72H*4],DI
  6422 00001A02 8C06CA01                		mov	[72H*4+2],ES
  6423                                  	
  6424                                  skip_int72:
  6425 00001A06 2EC43E[A018]            		LES	DI,[CS:INT19OLD73]
  6426                                  
  6427 00001A0B 8CC0                    		mov	ax,es
  6428 00001A0D 83F8FF                  		cmp	ax,-1
  6429 00001A10 740D                    		je	short skip_int73
  6430 00001A12 83FFFF                  		cmp	di,-1
  6431 00001A15 7408                    		je	short skip_int73
  6432                                  
  6433 00001A17 893ECC01                		mov	[73H*4],DI
  6434 00001A1B 8C06CE01                		mov	[73H*4+2],ES
  6435                                  	
  6436                                  skip_int73:
  6437 00001A1F 2EC43E[A418]            		LES	DI,[CS:INT19OLD74]
  6438                                  
  6439 00001A24 8CC0                    		mov	ax,es
  6440 00001A26 83F8FF                  		cmp	ax,-1
  6441 00001A29 740D                    		je	short skip_int74
  6442 00001A2B 83FFFF                  		cmp	di,-1
  6443 00001A2E 7408                    		je	short skip_int74
  6444                                  
  6445 00001A30 893ED001                		mov	[74H*4],DI
  6446 00001A34 8C06D201                		mov	[74H*4+2],ES
  6447                                  	
  6448                                  skip_int74:
  6449 00001A38 2EC43E[A818]            		LES	DI,[CS:INT19OLD76]
  6450                                  
  6451 00001A3D 8CC0                    		mov	ax,es
  6452 00001A3F 83F8FF                  		cmp	ax,-1
  6453 00001A42 740D                    		je	short skip_int76
  6454 00001A44 83FFFF                  		cmp	di,-1
  6455 00001A47 7408                    		je	short skip_int76
  6456                                  
  6457 00001A49 893ED801                		mov	[76H*4],DI
  6458 00001A4D 8C06DA01                		mov	[76H*4+2],ES
  6459                                  	
  6460                                  skip_int76:
  6461 00001A51 2EC43E[AC18]            		LES	DI,[CS:INT19OLD77]
  6462                                  
  6463 00001A56 8CC0                    		mov	ax,es
  6464 00001A58 83F8FF                  		cmp	ax,-1
  6465 00001A5B 740D                    		je	short skip_int77
  6466 00001A5D 83FFFF                  		cmp	di,-1
  6467 00001A60 7408                    		je	short skip_int77
  6468                                  
  6469 00001A62 893EDC01                		mov	[77H*4],DI
  6470 00001A66 8C06DE01                		mov	[77H*4+2],ES
  6471                                  	
  6472                                  skip_int77:
  6473                                  
  6474                                  ;;End of modification ----------------------------
  6475                                  
  6476                                  doint19:
  6477 00001A6A 2EC43E[7418]            		LES	DI,[CS:ORIG19]
  6478 00001A6F 893E6400                		MOV	[19h*4],DI
  6479 00001A73 8C066600                		MOV	[19h*4+2],ES
  6480                                  
  6481 00001A77 CD19                    		INT	19h
  6482                                  
  6483                                  
  6484                                  ;*****************************************************************************
  6485                                  
  6486                                  DSK$INIT:	; 29/05/2018 - Retro DOS v3.0
  6487 00001A79 0E                      		PUSH	CS
  6488 00001A7A 1F                      		POP	DS
  6489                                  
  6490 00001A7B 8A26[C001]              		MOV	AH,[DRVMAX]
  6491 00001A7F BF[B018]                		MOV	DI,DSKDRVS
  6492 00001A82 E9F7EF                  		JMP	SetPTRSAV
  6493                                  
  6494                                  ;
  6495                                  ; Int 2f handler for external block drivers to communicate with the internal
  6496                                  ; block driver in msdisk. The multiplex number chosen is 8. The handler
  6497                                  ; sets up the pointer to the request packet in [PTRSAV] and then jumps to
  6498                                  ; DSK$IN, the entry point for all disk requests.
  6499                                  ; On exit from this driver (at EXIT), we will return to the external driver
  6500                                  ; that issued this Int 2F, and can then remove the flags from the stack.
  6501                                  ; This scheme allows us to have a small external device driver, and makes
  6502                                  ; the maintainance of the various drivers (DRIVER and msBIO) much easier,
  6503                                  ; since we only need to make changes in one place (most of the time).
  6504                                  ;
  6505                                  ; AL contains the Int2F function:
  6506                                  ;   0 - Check for installed handler - RESERVED
  6507                                  ;   1 - Install the BDS into the linked list
  6508                                  ;   2 - DOS request
  6509                                  ;
  6510                                  
  6511                                  MYNUM		EQU	8
  6512                                  
  6513                                  INT2F_DISK:
  6514 00001A85 80FC08                  		cmp	ah,MYNUM
  6515 00001A88 7405                    		je	short Mine
  6516 00001A8A 2EFF2E[E418]            		jmp	far [cs:INT_2F_NEXT]	; chain to next Int 2F handler
  6517                                  Mine:
  6518 00001A8F 3CF8                    		cmp	al,0F8H 		; IRET on reserved functions
  6519 00001A91 7201                    		jb	short Do_Func
  6520 00001A93 CF                      		IRET
  6521                                  Do_Func:
  6522 00001A94 08C0                    		or	al,al			; A GET INSTALLED STATE request?
  6523 00001A96 7503                    		jne	short Disp_Func
  6524 00001A98 B0FF                    		mov	al,0FFH
  6525 00001A9A CF                      		IRET
  6526                                  Disp_Func:
  6527 00001A9B 3C01                    		cmp	al,1			; Request for installing BDS?
  6528 00001A9D 7504                    		jne	short Do_DOS_Req
  6529 00001A9F E80E00                  		call	INSTALL_BDS
  6530 00001AA2 CF                      		IRET
  6531                                  Do_DOS_Req:
  6532                                  ; Set up pointer to request packet
  6533 00001AA3 2E891E[B800]            		MOV	[CS:PTRSAV],BX
  6534 00001AA8 2E8C06[BA00]            		MOV	[CS:PTRSAV+2],ES
  6535 00001AAD E984EB                  		jmp	DSK$IN
  6536                                  
  6537                                  ;
  6538                                  ; Install_BDS installs a BDS a location DS:DI into the current linked list of
  6539                                  ; BDS maintained by this device driver. It places the BDS at the END of the
  6540                                  ; list.
  6541                                  
  6542                                  INSTALL_BDS:
  6543                                  ; ds:di point to BDS to be installed
  6544 00001AB0 2EC436[4C02]            		les	si,[cs:START_BDS]	; Start at beginning of list
  6545 00001AB5 06                      		push	es			; Save pointer to current BDS
  6546 00001AB6 56                      		push	si
  6547                                  ; es:si now point to BDS in linked list
  6548                                  Loop_Next_BDS:
  6549 00001AB7 83FEFF                  		cmp	si,-1			; got to end of linked list?
  6550 00001ABA 7437                    		jz	short Install_Ret
  6551                                  ; If we have several logical drives using the same physical drive, we must
  6552                                  ; set the I_Am_Mult flag in each of the appropriate BDSs.
  6553 00001ABC 8A4504                  		mov	al,[DI+BDS.DriveNum]
  6554 00001ABF 26384404                		cmp	[ES:SI+BDS.DriveNum],al
  6555 00001AC3 751F                    		jnz	short Next_BDS
  6556 00001AC5 31DB                    		xor	bx,bx
  6557 00001AC7 B310                    		mov	bl,fI_Am_Mult
  6558 00001AC9 095D29                  		or	[DI+BDS.Flags],bx	; set flags in both BDSs concerned
  6559 00001ACC 26095C29                		or	[ES:SI+BDS.Flags],bx
  6560 00001AD0 B320                    		mov	bl,fI_Own_Physical
  6561 00001AD2 83F3FF                  		xor	bx,-1
  6562 00001AD5 215D29                  		and	[DI+BDS.Flags],bx	; reset that flag for 'new' BDS
  6563                                  ; We must also set the fChangeline bit correctly.
  6564 00001AD8 268B5C29                		mov	bx,[ES:SI+BDS.Flags]	; determine if changeline available
  6565 00001ADC 80E302                  		and	bl,fChangeline
  6566 00001ADF 30FF                    		xor	bh,bh
  6567 00001AE1 095D29                  		or	[DI+BDS.Flags],bx
  6568                                  
  6569                                  Next_BDS:
  6570                                  ; Before moving to next BDS, preserve pointer to current one. This is needed at
  6571                                  ; the end when the new BDS is linked into the list.
  6572 00001AE4 5B                      		pop	bx			; discard previous pointer to BDS
  6573 00001AE5 5B                      		pop	bx
  6574 00001AE6 06                      		push	es
  6575 00001AE7 56                      		push	si
  6576 00001AE8 268B5C02                		mov	bx,[ES:SI+BDS.Link+2]
  6577                                  		;mov	si,[ES:SI+BDS.Link]
  6578 00001AEC 268B34                  		mov	si,[es:si] ; 05/07/2019
  6579 00001AEF 8EC3                    		mov	es,bx
  6580 00001AF1 EBC4                    		jmp	short Loop_Next_BDS
  6581                                  
  6582                                  Install_Ret:
  6583 00001AF3 5E                      		pop	si			; Retrieve pointer to last BDS
  6584 00001AF4 07                      		pop	es			; in linked list.
  6585 00001AF5 8CD8                    		mov	ax,ds
  6586 00001AF7 26894402                		mov	[ES:SI+BDS.Link+2],ax	; install BDS
  6587                                  		;mov	[ES:SI+BDS.Link],di
  6588 00001AFB 26893C                  		mov	[es:si],di ; 05/07/2019
  6589                                  		;mov	word [DI+BDS.Link],-1	; set NEXT pointer to NULL
  6590                                  		;mov	dword [DI+BDS.Link],-1  ; Retro DOS v3.0
  6591 00001AFE C705FFFF                		mov	word [DI],-1 ; 05/07/2019
  6592 00001B02 C3                      		retn
  6593                                  
  6594                                  ;
  6595                                  ; RE_INIT installs the Int 2F vector that will handle communication between
  6596                                  ; external block drivers and the internal driver. It also installs the
  6597                                  ; Reset_Int_13 interface. It is called by SYSYINIT
  6598                                  ;
  6599                                  
  6600                                  RE_INIT:
  6601 00001B03 50                      		PUSH	AX
  6602 00001B04 1E                      		PUSH	DS
  6603 00001B05 57                      		PUSH	DI
  6604 00001B06 31FF                    		XOR	DI,DI
  6605 00001B08 8EDF                    		MOV	DS,DI
  6606 00001B0A BFBC00                  		MOV	DI,2FH*4		; point it to Int 2F Vector
  6607 00001B0D 8B05                    		MOV	AX,[DI]
  6608 00001B0F 2EA3[E418]              		MOV	[CS:INT_2F_NEXT],AX
  6609 00001B13 8B4502                  		MOV	AX,[DI+2]		; preserve old Int 2F vector
  6610 00001B16 2EA3[E618]              		MOV	[CS:INT_2F_NEXT+2],AX
  6611                                  
  6612                                  ; INSTALL the Reset_Int_13
  6613                                  ; interface
  6614 00001B1A FA                      		CLI
  6615 00001B1B C705[1718]              		MOV	word [DI],INT_2F_13	; install new vectors
  6616 00001B1F 8C4D02                  		MOV	[DI+2],CS
  6617 00001B22 FB                      		STI
  6618 00001B23 5F                      		POP	DI
  6619 00001B24 1F                      		POP	DS
  6620 00001B25 58                      		POP	AX
  6621 00001B26 CB                      		RETF
  6622                                  
  6623                                  
  6624                                  ;-------------------------------------------------
  6625                                  ;
  6626                                  ;  Ask to swap the disk in drive A:
  6627                                  ; Using a different drive in a one drive system so
  6628                                  ; request the user to change disks
  6629                                  ;
  6630                                  
  6631                                  SWPDSK:		; 29/05/2018 - Retro DOS v3.0
  6632                                  
  6633                                  		; 13/04/2018
  6634                                  		; 09/04/2018
  6635                                  		; Retro DOS v2.0 (IBMDOS 2.1, IBMBIO.COM)
  6636                                  
  6637 00001B27 8A4505                  		mov	al,[DI+BDS.DriveLet]	; get the drive letter
  6638 00001B2A 0441                    		add	al,"A"
  6639 00001B2C 2EA2[6C1B]              		mov	[cs:DRVLET],AL
  6640                                  
  6641 00001B30 1E                      		push	ds			; preserve segment register
  6642 00001B31 0E                      		push	cs
  6643 00001B32 1F                      		pop	ds
  6644 00001B33 BE[501B]                		mov	SI,SNGMSG		; ds:si -> message
  6645 00001B36 53                      		push	BX
  6646                                  
  6647 00001B37 E80A00                  		call	WRMSG			;Print disk change message
  6648 00001B3A E8EBEB                  		call	FLUSH
  6649                                  						; wait for a keyboard character
  6650 00001B3D 30E4                    		xor	AH, AH			; set command to read character
  6651 00001B3F CD16                    		int	16h			; call rom-bios
  6652 00001B41 5B                      		POP	BX
  6653 00001B42 1F                      		pop	ds			; restore segment register
  6654                                  WRMRET:
  6655 00001B43 C3                      		retn
  6656                                  
  6657                                  ;----------------------------------------------
  6658                                  ;
  6659                                  ;  WrMsg writes out message pointed to by [SI]
  6660                                  ;
  6661                                  
  6662                                  WRMSG:
  6663 00001B44 AC                      		lodsb				; get the next character of the message
  6664 00001B45 08C0                    		or	AL,AL			; see if end of message
  6665 00001B47 74FA                    		jz	short WRMRET
  6666 00001B49 9C                      		pushf
  6667 00001B4A 0E                      		push	CS
  6668 00001B4B E84EEB                  		call	OUTCHR
  6669 00001B4E EBF4                    		jmp	SHORT WRMSG
  6670                                  
  6671                                  
  6672                                  ;	INCLUDE BIOMES.INC
  6673                                  
  6674                                  ; BIOMES.INC - 24/07/1987
  6675                                  ;----------------------------------------------------------------------------
  6676                                  ;
  6677                                  ; Single drive message for msbio.com. Nul terminated.
  6678                                  ;
  6679                                  
  6680 00001B50 0D0A496E7365727420-     SNGMSG:	DB	0Dh,0Ah,"Insert diskette for drive "
  6680 00001B59 6469736B6574746520-
  6680 00001B62 666F72206472697665-
  6680 00001B6B 20                 
  6681 00001B6C 413A20616E64207374-     DRVLET:	DB	"A: and strike",0Dh,0Ah,"any key when ready",0Dh,0Ah,0Ah,0
  6681 00001B75 72696B650D0A616E79-
  6681 00001B7E 206B6579207768656E-
  6681 00001B87 2072656164790D0A0A-
  6681 00001B90 00                 
  6682                                  
  6683                                  ;----------------------------------------------------------------------------
  6684                                  
  6685                                  ; 01/06/2018 - Retro DOS v3.0
  6686                                  
  6687                                  ;
  6688                                  ; End of support for multiple floppies with no logical drives
  6689                                  ; This is not 'special' any more because we now have the capability of
  6690                                  ; defining logical drives in CONFIG.SYS. We therefore keep the code for
  6691                                  ; swapping resident ALL the time.
  6692                                  ;
  6693                                  
  6694                                  ;;Rev 3.30 modification ----------------------------
  6695                                  ;Variables for Dynamic Relocatable modules
  6696                                  ;These should be stay resident.
  6697                                  
  6698 00001B91 00000000                INT6C_RET_ADDR:	DD	0	; ret add from INT 6C for P12 mach
  6699                                  
  6700                                  ;
  6701                                  ;   DATA STRUCTURES FOR REAL-TIME DATE AND TIME
  6702                                  ;
  6703                                  
  6704                                  BIN_DATE_TIME:
  6705 00001B95 00                      	DB	0		; CENTURY (19 OR 20) OR HOURS (0-23)
  6706 00001B96 00                      	DB	0		; YEAR IN CENTURY (0-99) OR MINUTES (0-59)
  6707 00001B97 00                      	DB	0		; MONTH IN YEAR (1-12) OR SECONDS (0-59)
  6708 00001B98 00                      	DB	0		; DAY IN MONTH (1-31)
  6709                                  MONTH_TABLE:
  6710 00001B99 0000                    	DW	0		;MJB002 JANUARY
  6711 00001B9B 1F00                    	DW	31		;MJB002 FEBRUARY
  6712 00001B9D 3B00                    	DW	59		;MJB002
  6713 00001B9F 5A00                    	DW	90		;MJB002
  6714 00001BA1 7800                    	DW	120		;MJB002
  6715 00001BA3 9700                    	DW	151		;MJB002
  6716 00001BA5 B500                    	DW	181		;MJB002
  6717 00001BA7 D400                    	DW	212		;MJB002
  6718 00001BA9 F300                    	DW	243		;MJB002
  6719 00001BAB 1101                    	DW	273		;MJB002
  6720 00001BAD 3001                    	DW	304		;MJB002
  6721 00001BAF 4E01                    	DW	334		;MJB002
  6722                                  DAYCNT2:
  6723 00001BB1 0000                    	DW	0		;MJB002 TEMP FOR CNT OF DAYS SINCE 1-1-80
  6724                                  FEB29:
  6725 00001BB3 00                      	DB	0		;MJB002 FEBRUARY 29 IN A LEAP YEAR FLAG
  6726                                  
  6727                                  ;;End of modification ------------------------------
  6728                                  
  6729                                  EndFloppy:
  6730                                  
  6731                                  ;
  6732                                  ; End of code for virtual floppy drives
  6733                                  ;
  6734                                  
  6735                                  EndSwap:
  6736                                  
  6737                                  HNUM:	
  6738 00001BB4 00                      	DB	0			; number of hardfile (hard drives)
  6739                                  HARDDRV:
  6740 00001BB5 80                      	DB	80H			;Physical drive number of first hardfile
  6741                                  
  6742                                  
  6743                                  ;
  6744                                  ;  "HDRIVE" is a hard disk with 512 byte sectors
  6745                                  ;
  6746                                  
  6747                                  	;EVENB
  6748                                  
  6749                                  align 2
  6750                                  
  6751                                  BDSH:
  6752 00001BB6 FFFF                    	DW	-1			; Link to next structure
  6753 00001BB8 7000                    	DW	KERNEL_SEGMENT
  6754 00001BBA 80                      	DB	80h			; physical drive number
  6755 00001BBB 43                      	DB	"C"                     ; Logical Drive Letter
  6756                                  HDRIVE:
  6757 00001BBC 0002                    	DW	512
  6758 00001BBE 01                      	DB	1			; Sectors/allocation unit
  6759 00001BBF 0100                    	DW	1			; Reserved sectors for DOS
  6760 00001BC1 02                      	DB	2			; No. of allocation tables
  6761 00001BC2 1000                    	DW	16			; Number of directory entries
  6762 00001BC4 0000                    	DW	0000			; Number of sectors (at 512 bytes each)
  6763 00001BC6 F8                      	DB	11111000B		; Media descriptor
  6764 00001BC7 0100                    	DW	1			; Number of FAT sectors
  6765 00001BC9 0000                    	DW	00			; Sector limit
  6766 00001BCB 0000                    	DW	00			; Head limit
  6767 00001BCD 0000                    	DW	00			; Hidden sector count
  6768 00001BCF 00                      	DB	0			; TRUE => bigfat
  6769 00001BD0 0000                    OPCNTH:	DW	0			; Open Ref. Count
  6770 00001BD2 4E4F204E414D452020-     VOLIDH:	DB	"NO NAME    ",0         ; Volume ID for this disk
  6770 00001BDB 202000             
  6771 00001BDE 03                      	DB	3			; Form Factor
  6772 00001BDF 2000                    FLAGSH:	DW	0020H			; Various Flags
  6773 00001BE1 2800                    	DW	40			; number of cylinders
  6774                                  RecBPBH:
  6775 00001BE3 00<rep 1Fh>             	times	31 db 0			; Recommended BPB for drive
  6776                                  TRACKH:	
  6777 00001C02 FF                      	DB	-1			; Last track accessed on this drive
  6778                                  TIM_LOH:
  6779 00001C03 FFFF                    	DW	-1			; Keep these two contiguous (?)
  6780                                  TIM_HIH:
  6781 00001C05 FFFF                    	DW	-1
  6782                                  
  6783                                  ;
  6784                                  ; End of single hard disk section
  6785                                  ;
  6786                                  
  6787                                  EndOneHard:
  6788                                  
  6789                                  ;
  6790                                  ;"DRIVEX" is an extra type of drive usually reserved for an
  6791                                  ; additional hard file
  6792                                  ;
  6793                                  
  6794                                  	;EVENB
  6795                                  
  6796 00001C07 90                      align 2
  6797                                  
  6798                                  BDSX:
  6799 00001C08 FFFF                    	DW	-1			; Link to next structure
  6800 00001C0A 7000                    	DW	KERNEL_SEGMENT
  6801 00001C0C 81                      	DB	81h			; physical drive number
  6802 00001C0D 44                      	DB	"D"                     ; Logical Drive Letter
  6803                                  DRIVEX:
  6804 00001C0E 0002                    	DW	512
  6805 00001C10 00                      	DB	00			; Sectors/allocation unit
  6806 00001C11 0100                    	DW	1			; Reserved sectors for DOS
  6807 00001C13 02                      	DB	2			; No. of allocation tables
  6808 00001C14 0000                    	DW	0000			; Number of directory entries
  6809 00001C16 0000                    	DW	0000			; Number of sectors (at 512 bytes each)
  6810 00001C18 F8                      	DB	11111000B		; Media descriptor
  6811 00001C19 0000                    	DW	0000			; Number of FAT sectors
  6812 00001C1B 0000                    	DW	00			; Sector limit
  6813 00001C1D 0000                    	DW	00			; Head limit
  6814 00001C1F 0000                    	DW	00			; Hidden sector count
  6815 00001C21 00                      	DB	0			; TRUE => bigfat
  6816 00001C22 0000                    OPCNTD:	DW	0			; Open Ref. Count
  6817 00001C24 4E4F204E414D452020-     VOLIDD:	DB	"NO NAME    ",0         ; Volume ID for this disk
  6817 00001C2D 202000             
  6818 00001C30 03                      	DB	3			; Form Factor
  6819 00001C31 2000                    FLAGSD:	DW	0020H			; Various Flags
  6820 00001C33 2800                    	DW	40			; number of cylinders
  6821                                  RecBPBD:
  6822 00001C35 00<rep 1Fh>             	times	31 db 0			; Recommended BPB for drive
  6823                                  TRACKD:
  6824 00001C54 FF                      	DB	-1			; Last track accessed on this drive
  6825                                  TIM_LOD:
  6826 00001C55 FFFF                    	DW	-1			; Keep these two contiguous
  6827                                  TIM_HID:
  6828 00001C57 FFFF                    	DW	-1
  6829                                  
  6830                                  ;
  6831                                  ; End of section for two hard disks
  6832                                  
  6833                                  EndTwoHard:
  6834                                  
  6835                                  TWOHARD:
  6836                                  
  6837                                  ;
  6838                                  ; End of code for virtual floppy drives
  6839                                  ;
  6840                                  
  6841                                  ; include ms96tpi.inc
  6842                                  
  6843                                  ; MS96TPI.INC - 24/07/1987
  6844                                  ;----------------------------------------------------------------------------
  6845                                  ; 01/06/2018 - Retro DOS v3.0
  6846                                  ; 25/03/2018 - Retro DOS v2.0
  6847                                  
  6848                                  ;------------------------------------------------------------------------
  6849                                  ;									:
  6850                                  ; File: ms96tpi.asm							:
  6851                                  ;									:
  6852                                  ; This file contains code to support the 96 tpi drives.  The code	:
  6853                                  ; is included in the bio if the machine has at least one drive with	:
  6854                                  ; changeline support.  If the machine has no changeline drives then	:
  6855                                  ; the code is not kept in the bio at system initialization time.	:
  6856                                  ;									:
  6857                                  ;------------------------------------------------------------------------
  6858                                  
  6859                                  ;------------------------------------------------------------------------
  6860                                  ;									:
  6861                                  ;		DISK OPEN/CLOSE ROUTINES				:
  6862                                  ;									:
  6863                                  ;------------------------------------------------------------------------
  6864                                  
  6865                                  DSK$OPEN:					; AL is logical drive
  6866 00001C59 E8D5EF                  		call	SETDRIVE		; Get BDS for drive
  6867 00001C5C FF451A                  		inc	WORD [DI+BDS.Opcnt]
  6868 00001C5F E926EA                  		jmp	EXIT
  6869                                  
  6870                                  DSK$CLOSE:					; AL is logical drive
  6871 00001C62 E8CCEF                  		call	SETDRIVE		; Get BDS for drive
  6872 00001C65 837D1A00                		cmp	WORD [DI+BDS.Opcnt],0
  6873 00001C69 7403                    		jz	short EXITJX		; Watch out for wrap
  6874 00001C6B FF4D1A                  		dec	WORD [DI+BDS.Opcnt]
  6875                                  EXITJX:
  6876 00001C6E E917EA                  		jmp	EXIT
  6877                                  
  6878                                  ;
  6879                                  ; ChkOpCnt checks the number of open files on drive.
  6880                                  ;
  6881                                  ; Input : DS:DI points to current BDS for drive.
  6882                                  ;
  6883                                  ; Return : zero set if no open files
  6884                                  ;	   zero reset if open files
  6885                                  ;
  6886                                  
  6887                                  ChkOpCnt:
  6888 00001C71 837D1A00                		cmp	WORD [DI+BDS.Opcnt],0
  6889 00001C75 C3                      		retn
  6890                                  
  6891                                  ;
  6892                                  ; At media check time, we need to really get down and check what the change is.
  6893                                  ; This is GUARANTEED to be expensive.
  6894                                  ;
  6895                                  ; On entry AL contains logical drive number
  6896                                  ;
  6897                                  
  6898                                  MediaCheck:
  6899                                  		; 01/06/2018 - Retro DOS v3.0
  6900                                  
  6901                                  		; 13/04/2018
  6902                                  		; 08/04/2018
  6903                                  		; Retro DOS v2.0
  6904                                  
  6905 00001C76 E802F0                  		call	CHECKSINGLE	; make sure correct disk is in place
  6906 00001C79 31F6                    		xor	SI,SI
  6907 00001C7B E86F01                  		call	HasChange
  6908 00001C7E 742E                    		jz	short MediaRet
  6909 00001C80 E85F01                  		call	CheckROMChange
  6910 00001C83 752A                    		jnz	short MediaDoVolId
  6911 00001C85 50                      		push	AX
  6912 00001C86 52                      		push	DX
  6913                                  					; see if changeline has been triggered
  6914                                  ;;Rev 3.30 Modification
  6915 00001C87 8A5504                  		mov	DL, [DI+BDS.DriveNum] ; set logical drive number	  
  6916 00001C8A B416                    		mov	AH, 16h		; get changeline status	  
  6917 00001C8C CD13                    		int	13h		; call rom diskette routine	  
  6918                                  ;;End of Modification
  6919 00001C8E 5A                      		pop	DX
  6920 00001C8F 58                      		pop	AX
  6921 00001C90 721D                    		jc	short MediaDoVolId ; if changeline was triggered jmp
  6922 00001C92 BE0100                  		mov	SI,1		; else signal no change
  6923                                  
  6924                                  ; There are some drives with changeline that "lose" the changeline indication
  6925                                  ; if a different drive is accessed after the current one. In order to avoid
  6926                                  ; missing a media change, we return an "I don't know" to DOS if the changeline
  6927                                  ; is not active AND we are accessing a different drive from the last one.
  6928                                  ; If we are accessing the same drive, then we can safely rely on the changeline
  6929                                  ; status.
  6930                                  
  6931                                  LOSECHNG:
  6932 00001C95 2E8A1E[5102]            		mov	bl,[cs:TIM_DRV] ; get last drive accessed
  6933 00001C9A 385D04                  		cmp	byte [DI+BDS.DriveNum],bl
  6934 00001C9D 740F                    		jz	short MediaRet
  6935                                  
  6936                                  ; Do the 2 second twiddle. If time >= 2 seconds, do a volid check.
  6937                                  ; Otherwise return "I don't know" (Strictly speaking, we should return a
  6938                                  ; "Not Changed" here since the 2 second test said no change.) - RS.
  6939                                  
  6940 00001C9F 50                      		push	ax
  6941 00001CA0 51                      		push	cx
  6942 00001CA1 52                      		push	dx
  6943 00001CA2 E882ED                  		call	CHECK_TIME_OF_ACCESS
  6944 00001CA5 5A                      		pop	dx
  6945 00001CA6 59                      		pop	cx
  6946 00001CA7 58                      		pop	ax
  6947 00001CA8 09F6                    		or	si,si
  6948 00001CAA 7403                    		jz	short MediaDoVolId ; Check_Time says ">= 2 secs passed"
  6949 00001CAC 31F6                    		xor	si,si		; return "I don't know"
  6950                                  MediaRet:
  6951 00001CAE C3                      		retn
  6952                                  
  6953                                  ; 01/06/2018 - Retro DOS v3.0
  6954                                  
  6955                                  
  6956                                  ;
  6957                                  ; MediaDoVolid:  if this is called somehow the media was changed.  Look at
  6958                                  ; VID to see. We do not look at FAT because this may be different since we
  6959                                  ; only set MedByt when doing a READ or WRITE.
  6960                                  ;
  6961                                  
  6962                                  MediaDoVolId:
  6963 00001CAF E8DEED                  		call	GETBP		; build a new BPB in current BDS
  6964 00001CB2 72FA                    		jc	short MediaRet
  6965 00001CB4 E83400                  		call	Check_VID
  6966 00001CB7 73F5                    		jnc	short MediaRet
  6967 00001CB9 E85EF2                  		call	MAPERROR	; fix up AL for return to DOS
  6968 00001CBC C3                      		retn
  6969                                  
  6970                                  ;
  6971                                  ; Checklatchio:
  6972                                  ;
  6973                                  ; Simple, quick check of latched change.  If no indication, then return
  6974                                  ; otherwise do expensive check.  If the expensive test fails, POP off the
  6975                                  ; return and set AL = 15 (for invalid media change) which will be returned to
  6976                                  ; DOS.
  6977                                  ;
  6978                                  
  6979                                  CheckLatchIO:
  6980                                  ; If returning fake BPB then assume the disk has not changed
  6981                                  ;		test	word [DI+BDS.Flags],RETURN_FAKE_BPB
  6982                                  ;		jnz	short CheckRet
  6983                                  ;;Rev 3.30 Modification
  6984 00001CBD E82D01                  		call	HasChange		;change line supported?
  6985 00001CC0 7405                    		jz	short CheckRet		;No. Just return
  6986                                  ;;End of Modification
  6987 00001CC2 E8ACFF                  		call	ChkOpCnt
  6988 00001CC5 7501                    		jnz	short CheckROM
  6989                                  CheckRet:
  6990 00001CC7 C3                      		retn
  6991                                  ;
  6992                                  ; Check for past ROM indications.  If no ROM change indicated, then return OK.
  6993                                  ;
  6994                                  
  6995                                  CheckROM:
  6996 00001CC8 E81701                  		call	CheckROMChange
  6997 00001CCB 74FA                    		jz	short CheckRet		; no change
  6998                                  ;
  6999                                  ; We now see that a change line has been seen in the past.  Let's do the
  7000                                  ; expensive verification.
  7001                                  ;
  7002 00001CCD E8C0ED                  		call	GETBP			; build BPB in current BDS
  7003 00001CD0 720F                    		jc	short Ret_No_Error_Map	; GETBP has already called MapError
  7004 00001CD2 E81600                  		call	Check_VID
  7005 00001CD5 7207                    		jc	short CheckLatchRet	; disk error trying to read in.
  7006 00001CD7 09F6                    		or	SI,SI			; Is changed for sure?
  7007 00001CD9 79EC                    		jns	short CheckRet
  7008 00001CDB E84800                  		call	ReturnVID
  7009                                  CheckLatchRet:
  7010 00001CDE E839F2                  		call	MAPERROR		; fix up AL for return to DOS
  7011                                  Ret_No_Error_Map:
  7012 00001CE1 F9                      		stc				; indicate an error
  7013 00001CE2 5E                      		pop	si			; pop off return address
  7014 00001CE3 C3                      		retn
  7015                                  
  7016                                  ;
  7017                                  ;  CheckFatVID:
  7018                                  ;
  7019                                  ; Check the FAT and the VID.  Return in DI -1 or 0.  Return with carry set
  7020                                  ; ONLY if there was a disk error.  Return that error code in AX.
  7021                                  ;
  7022                                  
  7023                                  CheckFATVID:
  7024 00001CE4 E80402                  		call	FAT_CHECK
  7025 00001CE7 09F6                    		or	SI,SI
  7026 00001CE9 7810                    		js	short Changed_Drv
  7027                                  ;
  7028                                  ; The fat was the same.  How about the volume ID?
  7029                                  ;
  7030                                  Check_VID:
  7031 00001CEB E83A01                  		call	Read_Volume_ID
  7032 00001CEE 720A                    		jc	short CheckFatRet
  7033 00001CF0 E8E101                  		call	Check_Volume_ID
  7034                                  
  7035 00001CF3 09F6                    		or	SI,SI
  7036 00001CF5 7504                    		jnz	short Changed_Drv
  7037 00001CF7 E8EE00                  		call	ResetChanged
  7038                                  CheckFatRet:
  7039 00001CFA C3                      		retn
  7040                                  Changed_Drv:
  7041 00001CFB 2EC606[5102]FF          		mov	byte [cs:TIM_DRV],-1 	; Ensure that we ask ROM for media
  7042 00001D01 C3                      		retn				; check next time round
  7043                                  
  7044                                  ;
  7045                                  ; CheckIO:  At I/O time the rom-bios returned an error.  We need to
  7046                                  ; determine if the error is due to a media change.  If error code is not
  7047                                  ; change-line error (06h) we just return.  We pop off the call and jmp to
  7048                                  ; harderr if we see an error.
  7049                                  ;
  7050                                  ;   On entry:  AH contains error code returned from rom-bios.
  7051                                  ;
  7052                                  
  7053                                  CheckIO:
  7054 00001D02 80FC06                  		cmp	AH,6			; change line error?
  7055 00001D05 75F3                    		jnz	short CheckFatRet	; no - just return
  7056 00001D07 E867FF                  		call	ChkOpCnt
  7057 00001D0A 74EE                    		jz	short CheckFatRet	; no open files
  7058                                  ; If returning fake BPB then ignore disk changes
  7059                                  ;		test	word [DI+BDS.Flags],RETURN_FAKE_BPB
  7060                                  ;		jnz	short IgnoreChange
  7061 00001D0C E881ED                  		call	GETBP			; build up a new BPB in current BDS
  7062 00001D0F 7212                    		jc	short No_Error_Map	; GETBP has already called MapError
  7063 00001D11 E8D0FF                  		call	CheckFATVID
  7064 00001D14 7209                    		jc	short CheckIORet	; disk error trying to read in.
  7065 00001D16 09F6                    		or	SI,SI			; Is changed for sure?
  7066 00001D18 7802                    		js	short CheckIOErr	; yes changed
  7067                                  IgnoreChange:
  7068 00001D1A 45                      		inc	BP			; allow a retry
  7069 00001D1B C3                      		retn
  7070                                  CheckIOErr:
  7071 00001D1C E80700                  		call	ReturnVID
  7072                                  CheckIORet:
  7073 00001D1F F9                      		stc				; make sure carry gets passed through
  7074 00001D20 E9B3F1                  		jmp	HARDERR
  7075                                  
  7076                                  No_Error_Map:
  7077 00001D23 E9B3F1                  		jmp	HARDERR2
  7078                                  
  7079                                  ;
  7080                                  ; Return VID sets up the VID for a return to DOS.
  7081                                  ;
  7082                                  
  7083                                  ReturnVID:
  7084 00001D26 1E                      		push	DS			; save pointer to current BDS
  7085 00001D27 57                      		push	di
  7086 00001D28 51                      		push	cx
  7087 00001D29 E8CF01                  		call	init_vid_loop		; Sets ES:DI -> vid
  7088 00001D2C 2EC51E[B800]            		lds	BX,[cs:PTRSAV]
  7089 00001D31 897F16                  		mov	[BX+EXTRA],DI
  7090 00001D34 8C4718                  		mov	[BX+EXTRA+2],ES
  7091 00001D37 59                      		pop	cx
  7092 00001D38 5F                      		pop	di			; restore current BDS
  7093 00001D39 1F                      		pop	DS
  7094                                  ;;		MOV	AH,6			; INVALID MEDIA CHANGE
  7095 00001D3A B40F                    		mov	AH,0Fh			; set error as 'invalid media change'
  7096 00001D3C F9                      		stc				; indicate error by setting carry flag
  7097 00001D3D C3                      		retn
  7098                                  
  7099                                  ;
  7100                                  ; Media_Set_VID:
  7101                                  ;
  7102                                  ; Moves the pointer to the volid for the drive into the original request packet
  7103                                  ; On entry, DS:BX points to the original packet.
  7104                                  ; No attempt is made to preserve registers.
  7105                                  ;
  7106                                  
  7107                                  MEDIA_SET_VID:
  7108 00001D3E E8BA01                  		call	init_vid_loop		; Sets ES:DI -> vid
  7109 00001D41 2EC51E[B800]            		lds	bx,[cs:PTRSAV]		; get pointer to packet
  7110 00001D46 897F0F                  		mov	[BX+TRANS+1],DI
  7111 00001D49 8C4711                  		mov	[BX+TRANS+3],ES
  7112 00001D4C C3                      		retn
  7113                                  
  7114                                  ;
  7115                                  ;   HiDensity - examine a drive/media descriptor to set the media type.  If
  7116                                  ;   the media descriptor is NOT F9 (not 96tpi or 3 1/2), we return and let the
  7117                                  ;   caller do the rest.  Otherwise, we pop off the return and jump to the tail
  7118                                  ;   of GETBP. For 3.5" media, we just return.
  7119                                  ;
  7120                                  ;   Inputs:	DS:DI point to correct BDS for this drive
  7121                                  ;		AH has media byte
  7122                                  ;
  7123                                  ;   Outputs:	Carry clear
  7124                                  ;		    No registers modified
  7125                                  ;		Carry set
  7126                                  ;		    AL = sectors/fat
  7127                                  ;		    BH = number of root directory entries
  7128                                  ;		    BL = sectors per track
  7129                                  ;		    CX = number of sectors
  7130                                  ;		    DH = sectors per allocation unit
  7131                                  ;		    DL = number of heads
  7132                                  ;
  7133                                  
  7134                                  hidensity:
  7135                                  ; Check for correct drive
  7136                                  ;
  7137 00001D4D F745290200              		test	word [DI+BDS.Flags],fChangeline	; is it special?
  7138 00001D52 741C                    		jz	short DoFloppy		; no, do normal floppy test
  7139                                  ;
  7140                                  ; We have a media byte that is pretty complex.	Examine drive information
  7141                                  ; table to see what kind it is.
  7142                                  ;
  7143 00001D54 807D2802                		cmp	byte [DI+BDS.FormFactor],ffSmall;  Is it single-media?
  7144 00001D58 7416                    		jz	short DoFloppy		; yes, use fatid...
  7145                                  ;
  7146                                  ; 96 tpi drive
  7147                                  ;
  7148 00001D5A 80FCF9                  		cmp	AH,0F9h
  7149 00001D5D 7511                    		jnz	short DoFloppy
  7150 00001D5F B007                    		mov	al,7			; seven sectors / fat
  7151 00001D61 BB0FE0                  		mov	bx,224*256+0Fh		; 224 root dir entries & 0f sector max
  7152 00001D64 B96009                  		mov	cx,80*15*2		; 80 tracks, 15 sectors/track, 2 sides
  7153 00001D67 BA0201                  		mov	dx,1*256+2		; sectors/allocation unit & head max
  7154                                  popr:
  7155 00001D6A 83C402                  		add	SP,2			; pop off return address
  7156 00001D6D E999ED                  		jmp	HAS1_res		; return to tail of GETBP
  7157                                  
  7158                                  
  7159                                  DoFloppy:
  7160 00001D70 C3                      		retn
  7161                                  
  7162                                  ;
  7163                                  ; Certain poorly designed programs avoid DOS altogether and use INT 13 directly.
  7164                                  ; These programs even retry operations and, thus, will ignore the disk change
  7165                                  ; logic.
  7166                                  ;
  7167                                  ; We hook INT 13 and note all errors.
  7168                                  ;
  7169                                  
  7170 00001D71 00000000                REAL13:		dd	0
  7171 00001D75 00000000                OLDINT:		dd	0
  7172 00001D79 0000                    DMY:		dw	0
  7173                                  
  7174                                  INT13:
  7175                                  		; 16/06/2018
  7176 00001D7B 2E8F06[751D]            		pop	word [cs:OLDINT]
  7177 00001D80 2E8F06[771D]            		pop	word [cs:OLDINT+2]
  7178 00001D85 2E8F06[791D]            		pop	word [cs:DMY]
  7179 00001D8A 9C                      		pushf
  7180 00001D8B 2EFF1E[711D]            		call	far [cs:REAL13]	; simulate another INT 13
  7181 00001D90 7205                    		jc	short Err13	; did an error occur?
  7182 00001D92 2EFF2E[751D]            		jmp	far [cs:OLDINT]	; no, return and pop off flags
  7183                                  Err13:
  7184 00001D97 9C                      		pushf			; save state
  7185 00001D98 80FC06                  		cmp	AH,06h		; is error a 'change' error?
  7186 00001D9B 7406                    		jz	short GotErr	; yes, jump down
  7187                                  B:		
  7188 00001D9D 9D                      		popf			; no, some other error, ignore it ;;End of Modification
  7189 00001D9E 2EFF2E[751D]            		jmp	far [cs:OLDINT]	; return and pop off flags
  7190                                  
  7191                                  GotErr: 	
  7192 00001DA3 08D2                    		or	DL,DL		; is this for the hard disk?
  7193 00001DA5 78F6                    		js	short B		; yes, ignore
  7194 00001DA7 2EC706[5202]4000        		mov	word [cs:FlagBits],fChanged
  7195 00001DAE E80200                  		call	Set_Changed_DL
  7196 00001DB1 EBEA                    		jmp	short B
  7197                                  
  7198                                  ;
  7199                                  ; Set_Changed_DL - Sets flag bits according to bits set in [FlagBits].
  7200                                  ;		   Essentially used to indicate Changeline, or Format.
  7201                                  ;
  7202                                  ;   Inputs:	DL contains physical drive number
  7203                                  ;		[FlagBits] contains bits to set in the flag field in the BDSs
  7204                                  ;   Outputs:	None
  7205                                  ;   Registers modified: Flags
  7206                                  ;
  7207                                  
  7208                                  Set_Changed_DL:
  7209 00001DB3 53                      		push	BX
  7210 00001DB4 52                      		push	DX
  7211 00001DB5 88D3                    		mov	BL,DL
  7212                                  ALL_SET:
  7213 00001DB7 2E8B16[5202]            		mov	dx,[cs:FlagBits] ; get bits to set in flag field
  7214 00001DBC 30FF                    		xor	BH,BH
  7215                                  ;
  7216                                  ; In the virtual drive system we *must* flag the other drives as being changed
  7217                                  ;
  7218                                  ; assume first BDS is in this segment
  7219 00001DBE 50                      		push	ax
  7220 00001DBF 1E                      		push	ds		; save current BDS
  7221 00001DC0 57                      		push	di
  7222 00001DC1 2EC53E[4C02]            		lds	di,[cs:START_BDS]
  7223                                  Scan_BDS:
  7224 00001DC6 83FFFF                  		cmp	di,-1
  7225 00001DC9 7411                    		jz	short SkipSet
  7226 00001DCB 385D04                  		cmp	byte [DI+BDS.DriveNum],bl
  7227 00001DCE 7503                    		jnz	short Get_Next_BDS
  7228                                  ;
  7229                                  ; Someone may complain, but this *always* must be done when a disk change is
  7230                                  ; noted.  There are *no* other compromising circumstances.
  7231                                  ;
  7232                                  SetChanged:
  7233 00001DD0 095529                  		or	[DI+BDS.Flags],dx ; signal change on other drive
  7234                                  Get_Next_BDS:
  7235 00001DD3 8B4502                  		mov	ax,[DI+BDS.Link+2]  ; go to next BDS
  7236                                  		;mov	di,[DI+BDS.Link]
  7237 00001DD6 8B3D                    		mov	di,[di] ; 05/07/2019
  7238 00001DD8 8ED8                    		mov	ds,ax
  7239 00001DDA EBEA                    		jmp	short Scan_BDS
  7240                                  SkipSet:
  7241 00001DDC 5F                      		pop	di		    ; restore current BDS
  7242 00001DDD 1F                      		pop	ds
  7243 00001DDE 58                      		pop	ax
  7244 00001DDF 5A                      		pop	DX
  7245 00001DE0 5B                      		pop	BX
  7246 00001DE1 C3                      		retn
  7247                                  
  7248                                  ;
  7249                                  ; CheckROMChange - see if external program has diddled ROM change line.
  7250                                  ;
  7251                                  ;   Inputs:	DS:DI points to current BDS.
  7252                                  ;   Outputs:	Zero set - no change
  7253                                  ;		Zero reset - change
  7254                                  ;   Registers modified: none
  7255                                  
  7256                                  CheckROMChange:
  7257 00001DE2 F745294000              		test	word [DI+BDS.Flags],fChanged
  7258 00001DE7 C3                      		retn
  7259                                  
  7260                                  ;
  7261                                  ; ResetChanged - restore value of change line
  7262                                  ;
  7263                                  ;   Inputs:	DS:DI points to current BDS
  7264                                  ;   Outputs:	none
  7265                                  ;   Registers modified: none
  7266                                  
  7267                                  ResetChanged:
  7268 00001DE8 836529BF                		and	word [DI+BDS.Flags],~fChanged
  7269 00001DEC C3                      		retn
  7270                                  
  7271                                  ;
  7272                                  ; HasChange - see if drive can supply change line
  7273                                  ;
  7274                                  ;   Inputs:	DS:DI points to current BDS
  7275                                  ;   Outputs:	Zero set - no change line available
  7276                                  ;		Zero reset - change line available
  7277                                  ;   Registers modified: none
  7278                                  
  7279                                  HasChange:
  7280 00001DED F745290200              		test	word [DI+BDS.Flags],fChangeline
  7281 00001DF2 C3                      		retn
  7282                                  
  7283                                  ; 01/06/2018 - Retro DOS v3.0
  7284                                  
  7285                                  ; include msvolid.inc
  7286                                  
  7287                                  ;-------------------------------------------------------------------------
  7288                                  ;
  7289                                  ;  File: msvolid.asm
  7290                                  ;	This file contains the volume_id subroutines and data structures.
  7291                                  ;
  7292                                  ;	Routines in this file are:
  7293                                  ;	   Set_Volume_ID       -	main routine, calls other routines.
  7294                                  ;	   read_volume_id      -	read the volume ID and tells if it has
  7295                                  ;					   been changed.
  7296                                  ;	   Transfer_volume_id  -	copy the volume ID from TMP to special
  7297                                  ;					   drive.
  7298                                  ;	   Check_Volume_ID     -	compare volume ID in TMP area with one
  7299                                  ;					   expected for drive.
  7300                                  ;	   Fat_Check	       -	see of the fatID has changed in the
  7301                                  ;					   specified drive.
  7302                                  ;	   Init_Vid_loop       -	set up for VID scan or move
  7303                                  ;
  7304                                  ;
  7305                                  ;-------------------------------------------------------------------------
  7306                                  
  7307                                  ;
  7308                                  ; length of the volume id
  7309                                  ;
  7310                                  
  7311                                  vid_size    equ 12
  7312                                  
  7313                                  ;
  7314                                  ; null volume id
  7315                                  ;
  7316                                  
  7317                                  nul_vid:
  7318 00001DF3 4E4F204E414D452020-     	db  "NO NAME    ",0
  7318 00001DFC 202000             
  7319                                  
  7320                                  ;
  7321                                  ; data scratch area used to hold volume ids
  7322                                  ;
  7323                                  
  7324                                  tmp_vid:
  7325 00001DFF 4E4F204E414D452020-     	db  "NO NAME    ",0
  7325 00001E08 202000             
  7326                                  
  7327                                  ;
  7328                                  ; Set_Volume_ID
  7329                                  ;   If drive has changeline support, read in and set the volume_ID
  7330                                  ; and the last FAT_ID byte.  If no change line support then do nothing.
  7331                                  ;
  7332                                  ;   On entry:
  7333                                  ;	DS:DI points to the BDS for this disk.
  7334                                  ;	AH contains media byte
  7335                                  ;
  7336                                  ;   On Exit:
  7337                                  ;	Carry clear:
  7338                                  ;	   Successful call
  7339                                  ;	Carry set
  7340                                  ;	   Error and AX has error code
  7341                                  ;
  7342                                  
  7343                                  Set_Volume_ID:
  7344 00001E0B 52                      		push	dx		; save registers
  7345 00001E0C 50                      		push	ax
  7346 00001E0D E8DDFF                  		CALL	HasChange	; does drive have changeline support?
  7347 00001E10 740D                    		jz	short setvret	; no, get out
  7348 00001E12 57                      		push	di
  7349 00001E13 E81200                  		call	Read_Volume_ID	; read the volume ID
  7350 00001E16 5F                      		pop	di
  7351 00001E17 720A                    		jc	short SetErr	; if error go to error routine
  7352 00001E19 E8A700                  		call	transfer_volume_ID ; copy the volume id to special drive
  7353 00001E1C E8C9FF                  		call	ResetChanged	; restore value of change line
  7354                                  setvret:				; SET Volume RETurn
  7355 00001E1F F8                      		clc			; no error, clear carry flag
  7356 00001E20 58                      		pop	ax		; restore registers
  7357 00001E21 5A                      		pop	dx
  7358 00001E22 C3                      		retn
  7359                                  SetErr:
  7360 00001E23 5A                      		pop	dx		; pop stack but don't overwrite AX
  7361 00001E24 5A                      		pop	dx		; restore DX
  7362 00001E25 C3                      		retn
  7363                                  
  7364                                  root_sec:
  7365 00001E26 0000                    		DW	0		;Root sector #
  7366                                  
  7367                                  ;
  7368                                  ; read_volume_id read the volume ID and tells if it has been changed.
  7369                                  ;
  7370                                  ;   On entry:
  7371                                  ;	DS:DI points to current BDS for drive.
  7372                                  ;   On Exit:
  7373                                  ;	Carry Clear
  7374                                  ;	    SI = 1  No change
  7375                                  ;	    SI = 0  ?
  7376                                  ;	    SI = -1 Change
  7377                                  ;
  7378                                  ;	Carry Set:
  7379                                  ;	    Error and AX has error code.
  7380                                  ;
  7381                                  
  7382                                  Read_Volume_ID:
  7383 00001E28 06                      		push	ES		; preserve registers
  7384 00001E29 52                      		push	DX
  7385 00001E2A 51                      		push	CX
  7386 00001E2B 53                      		push	BX
  7387 00001E2C 50                      		push	AX
  7388 00001E2D 1E                      		push	DS		; Preserve Current BDS
  7389 00001E2E 57                      		push	DI
  7390 00001E2F 0E                      		push	cs		; get ES segment correct
  7391 00001E30 07                      		pop	es
  7392 00001E31 0E                      		push	cs		; get DS segment correct
  7393 00001E32 1F                      		pop	ds
  7394 00001E33 BF[FF1D]                		mov	di,tmp_vid
  7395 00001E36 BE[F31D]                		mov	si,nul_vid
  7396 00001E39 B90C00                  		mov	cx,vid_size
  7397 00001E3C F3A4                    		rep	movsb		; initialize tmp_vid to null vi_id
  7398                                  
  7399 00001E3E 5F                      		pop	DI		; Restore Current BDS
  7400 00001E3F 1F                      		pop	DS
  7401 00001E40 8A450B                  		mov	al,[DI+BDS.cFAT] ; # of fats
  7402 00001E43 8B4D11                  		mov	cx,[DI+BDS.cSecFat] ; sectors / fat
  7403 00001E46 F6E1                    		mul	cl			    ; size taken by fats
  7404 00001E48 034509                  		add	ax,[DI+BDS.RESSEC] ; add on reserved sectors
  7405                                  					; AX is now sector # (0 based)
  7406 00001E4B 2EA3[261E]              		mov	[cs:root_sec],ax ; set initial value
  7407 00001E4F 8B450C                  		mov	ax,[DI+BDS.cDir] ; # root dir entries
  7408 00001E52 B104                    		mov	cl,4		; 16 entries/sector
  7409 00001E54 D3E8                    		shr	ax,cl		; divide by 16
  7410 00001E56 89C1                    		mov	cx,ax		; cx is # of sectors to scan
  7411                                  next_sec:
  7412 00001E58 51                      		push	cx		; save outer loop counter
  7413 00001E59 2EA1[261E]              		mov	ax,[cs:root_sec] ; get sector #
  7414 00001E5D 8B4D13                  		mov	cx,[DI+BDS.SECLIM] ; sectors / track
  7415 00001E60 31D2                    		xor	DX,DX
  7416 00001E62 F7F1                    		div	cx
  7417                                  				; set up registers for call to read_sector
  7418 00001E64 42                      		inc	DX	; dx= sectors into track, ax= track count from 0
  7419 00001E65 88D1                    		mov	cl,dl	; sector to read
  7420 00001E67 31D2                    		xor	DX,DX
  7421 00001E69 F77515                  		div	word [DI+BDS.HDLIM] ; # heads on this disc
  7422 00001E6C 88D6                    		mov	dh,dl	; Head number
  7423 00001E6E 88C5                    		mov	ch,al	; Track #
  7424 00001E70 E849ED                  		call	READ_SECTOR ; get first sector of the root directory,
  7425                                  				; ES:BX -> BOOT
  7426 00001E73 724A                    		jc	short ReadVIDErr ; error on read
  7427 00001E75 B91000                  		mov	cx,16		; # of dir entries in a block of root
  7428 00001E78 B008                    		mov	al,08h		; volume label bit
  7429                                  fvid_loop:
  7430 00001E7A 26803F00                		cmp	byte [es:bx],0	; End of dir?
  7431 00001E7E 743C                    		jz	short no_vid	; yes, no vol id
  7432 00001E80 26803FE5                		cmp	byte [es:bx],0E5h ; empty entry?
  7433 00001E84 7406                    		jz	short ent_loop	; yes, skip
  7434 00001E86 2684470B                		test	[es:bx+11],al	; is volume label bit set in fcb?
  7435 00001E8A 7511                    		jnz	short found_vid	; jmp yes
  7436                                  ent_loop:
  7437 00001E8C 83C320                  		ADD	BX,32		;ADD LENGTH OF DIRECTORY ENTRY
  7438 00001E8F E2E9                    		loop	fvid_loop
  7439 00001E91 59                      		pop	cx		; outer loop
  7440 00001E92 2EFF06[261E]            		inc	word [cs:root_sec] ; next sector
  7441 00001E97 E2BF                    		loop	next_sec	; continue
  7442                                  NotFound:
  7443 00001E99 31F6                    		XOR	SI,SI
  7444 00001E9B EB18                    		jmp	short fvid_ret
  7445                                  
  7446                                  found_vid:
  7447 00001E9D 59                      		pop	cx		; clean stack of outer loop counter
  7448 00001E9E 89DE                    		mov	si,bx		; point to volume_id
  7449 00001EA0 1E                      		push	ds		; preserve currnet BDS
  7450 00001EA1 57                      		push	di
  7451 00001EA2 06                      		push	es		; es:si points to volume id.
  7452 00001EA3 1F                      		pop	ds		; source segment
  7453 00001EA4 0E                      		push	cs
  7454 00001EA5 07                      		pop	es		; destination segment
  7455 00001EA6 BF[FF1D]                		mov	di,tmp_vid	; dest of volume_id
  7456 00001EA9 B90B00                  		mov	cx,vid_size-1	; length of string minus NUL
  7457 00001EAC F3A4                    		rep	movsb		; mov volume label to tmp_vid
  7458 00001EAE 30C0                    		xor	al,al
  7459 00001EB0 AA                      		stosb			; Null terminate
  7460 00001EB1 31F6                    		XOR	SI,SI
  7461 00001EB3 5F                      		pop	DI		; restore current BDS
  7462 00001EB4 1F                      		pop	DS
  7463                                  fvid_ret:
  7464 00001EB5 58                      		pop	ax
  7465 00001EB6 F8                      		clc
  7466                                  RVIDRet:
  7467 00001EB7 5B                      		pop	BX		; restore register
  7468 00001EB8 59                      		pop	CX
  7469 00001EB9 5A                      		pop	DX
  7470 00001EBA 07                      		pop	ES
  7471 00001EBB C3                      		retn
  7472                                  no_vid:
  7473 00001EBC 59                      		pop	cx		; clean stack of outer loop counter
  7474 00001EBD EBDA                    		jmp	short NotFound	; not found
  7475                                  ReadVIDErr:
  7476 00001EBF 5E                      		pop	SI
  7477 00001EC0 5E                      		pop	SI
  7478 00001EC1 EBF4                    		jmp	short RVIDRet
  7479                                  
  7480                                  ;
  7481                                  ;   Transfer_volume_id - copy the volume ID from TMP to special drive
  7482                                  ;
  7483                                  ;   Inputs:	DS:DI nas current BDS
  7484                                  ;   Outputs:	BDS for drive has volume ID from TMP
  7485                                  ;
  7486                                  
  7487                                  transfer_volume_ID:
  7488 00001EC3 1E                      		push	DS		; preserve current BDS
  7489 00001EC4 57                      		push	DI
  7490 00001EC5 06                      		push	ES
  7491 00001EC6 56                      		push	SI
  7492 00001EC7 51                      		push	CX
  7493 00001EC8 E83000                  		call	init_vid_loop
  7494 00001ECB FC                      		cld
  7495 00001ECC F3A4                    		rep	MOVSB		; transfer
  7496 00001ECE 59                      		pop	CX
  7497 00001ECF 5E                      		pop	SI
  7498 00001ED0 07                      		pop	ES
  7499 00001ED1 5F                      		pop	DI		; restore current BDS
  7500 00001ED2 1F                      		pop	DS
  7501 00001ED3 C3                      		retn
  7502                                  
  7503                                  ;
  7504                                  ;   Check_Volume_ID - compare volume ID in TMP area with one expected for
  7505                                  ;	drive
  7506                                  ;
  7507                                  ;   Inputs:	DS:DI has current BDS for drive
  7508                                  ;   Outputs:	SI = 0 if compare succeeds
  7509                                  ;		SI = -1 if compare fails.
  7510                                  
  7511                                  Check_Volume_ID:
  7512 00001ED4 1E                      		push	DS		; preserve current BDS for drive
  7513 00001ED5 57                      		push	DI
  7514 00001ED6 06                      		push	ES
  7515 00001ED7 51                      		push	CX
  7516 00001ED8 E82000                  		call	init_vid_loop
  7517 00001EDB FC                      		cld
  7518 00001EDC F3A6                    		repz	cmpsb		; are the 2 volume_ids the same?
  7519 00001EDE BE0000                  		mov	si,0		; assume unknown
  7520 00001EE1 7403                    		jz	short check_vid_ret ; carry clear if jump taken
  7521 00001EE3 BEFFFF                  		mov	si,-1		; failure
  7522                                  check_vid_ret:
  7523 00001EE6 59                      		pop	CX
  7524 00001EE7 07                      		pop	ES
  7525 00001EE8 5F                      		pop	DI		; restore current BDS
  7526 00001EE9 1F                      		pop	DS
  7527 00001EEA C3                      		retn
  7528                                  
  7529                                  ;
  7530                                  ;   Fat_Check - see of the fatID has changed in the specified drive.
  7531                                  ;	      - uses the FAT ID obtained from the boot sector.
  7532                                  ;
  7533                                  ;   Inputs:	MedByt is expected FAT ID
  7534                                  ;		DS:DI points to current BDS
  7535                                  ;   Output:	Carry Clear
  7536                                  ;		    SI = -1 if fat ID different,
  7537                                  ;		    SI = 0 otherwise
  7538                                  ;   No other registers changed.
  7539                                  
  7540                                  FAT_CHECK:
  7541 00001EEB 50                      		push	AX
  7542 00001EEC 31F6                    		xor	SI,SI		; say FAT ID's are same.
  7543 00001EEE 2EA0[5402]              		mov	AL,[cs:MedByt]
  7544                                  					 ; compare it with the BDS medbyte
  7545 00001EF2 3A4510                  		cmp	AL,[DI+BDS.Mediad]
  7546 00001EF5 7401                    		jz	short OkRet1	; carry clear
  7547 00001EF7 4E                      		dec	SI
  7548                                  OkRet1:		
  7549 00001EF8 F8                      		clc
  7550 00001EF9 58                      		pop	AX
  7551 00001EFA C3                      		retn
  7552                                  
  7553                                  ;
  7554                                  ;   Init_Vid_loop - set up for VID scan or move
  7555                                  ;
  7556                                  ;   Inputs:	DS:DI pionts to BDS for the drive
  7557                                  ;   Outputs:	DS:SI points to tmp_vid
  7558                                  ;		ES:DI points to vid for drive
  7559                                  ;		CX has size for VID compare
  7560                                  ;
  7561                                  
  7562                                  init_vid_loop:
  7563 00001EFB 50                      		push	ax
  7564 00001EFC 1E                      		push	ds
  7565 00001EFD 07                      		pop	es
  7566 00001EFE 0E                      		push	cs
  7567 00001EFF 1F                      		pop	ds
  7568 00001F00 BE[FF1D]                		mov	si,tmp_vid	; source
  7569 00001F03 83C71C                  		add	di,BDS.Volid
  7570 00001F06 B90C00                  		mov	cx,vid_size
  7571 00001F09 58                      		pop	ax
  7572 00001F0A C3                      		retn
  7573                                  
  7574                                  ;-----------------------------------------------------------------------------
  7575                                  
  7576                                  End96tpi:
  7577                                  
  7578                                  ;Rev 3.30 modification ----------------------------
  7579                                  ;Memory allocation for BDSM table.
  7580                                  
  7581                                  BDSMs:
  7582                                  		;times BDSM.size*Max_mini_dsk_num db 0	;currently max. 23
  7583                                  
  7584                                  	; 02/08/2019
  7585                                  		%rep	Max_mini_dsk_num ; 23 
  7586                                  ;BDSM:
  7587                                  		DW	-1			; Link to next structure
  7588                                  		DW	0
  7589                                  		DB	50h			; physical drive number
  7590                                  		DB	3                    	; Logical Drive Letter
  7591                                  ;DRIVEM:
  7592                                  		DW	512
  7593                                  		;DB	0
  7594                                  		db	1	; Sectors/allocation unit
  7595                                  		DW	1			; Reserved sectors for DOS
  7596                                  		DB	2			; No. of allocation tables
  7597                                  		DW	16			; Number of directory entries
  7598                                  		DW	0			; Number of sectors (at 512 bytes each)
  7599                                  		DB	11111000b  ; 0F8h	; Media descriptor
  7600                                  		DW	1			; Number of FAT sectors
  7601                                  		DW	0			; Sector limit
  7602                                  		DW	0			; Head limit
  7603                                  		DW	0			; Hidden sector count
  7604                                  		DB	0			; TRUE => bigfat
  7605                                  ;OPCNTM:
  7606                                  		DW	0			; Open Ref. Count
  7607                                  ;VOLIDM: 
  7608                                  		db	"NO NAME    ",0	; Volume ID for this disk
  7609                                  		DB	3			; Form Factor
  7610                                  ;FLAGSM:	
  7611                                  		DW	20h			; Various Flags
  7612                                  		DW	40			; number of cylinders
  7613                                  ;RecBPBM:
  7614                                  		times	31 db 0			; Recommended BPB for drive
  7615                                  ;TRACKM:
  7616                                  		DB	-1			; Last track accessed on this drive
  7617                                  ;BDSM_ISMINI:
  7618                                  		DW	1			; Keep these two contiguous
  7619                                  ;BDSM_HIDDEN_TRKS:
  7620                                  		DW	0
  7621                                  
  7622                                  		%endrep
  7586                              <1> 
  7587 00001F0B FFFF                <1>  DW -1
  7588 00001F0D 0000                <1>  DW 0
  7589 00001F0F 50                  <1>  DB 50h
  7590 00001F10 03                  <1>  DB 3
  7591                              <1> 
  7592 00001F11 0002                <1>  DW 512
  7593                              <1> 
  7594 00001F13 01                  <1>  db 1
  7595 00001F14 0100                <1>  DW 1
  7596 00001F16 02                  <1>  DB 2
  7597 00001F17 1000                <1>  DW 16
  7598 00001F19 0000                <1>  DW 0
  7599 00001F1B F8                  <1>  DB 11111000b
  7600 00001F1C 0100                <1>  DW 1
  7601 00001F1E 0000                <1>  DW 0
  7602 00001F20 0000                <1>  DW 0
  7603 00001F22 0000                <1>  DW 0
  7604 00001F24 00                  <1>  DB 0
  7605                              <1> 
  7606 00001F25 0000                <1>  DW 0
  7607                              <1> 
  7608 00001F27 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7608 00001F30 202000              <1>
  7609 00001F33 03                  <1>  DB 3
  7610                              <1> 
  7611 00001F34 2000                <1>  DW 20h
  7612 00001F36 2800                <1>  DW 40
  7613                              <1> 
  7614 00001F38 00<rep 1Fh>         <1>  times 31 db 0
  7615                              <1> 
  7616 00001F57 FF                  <1>  DB -1
  7617                              <1> 
  7618 00001F58 0100                <1>  DW 1
  7619                              <1> 
  7620 00001F5A 0000                <1>  DW 0
  7621                              <1> 
  7586                              <1> 
  7587 00001F5C FFFF                <1>  DW -1
  7588 00001F5E 0000                <1>  DW 0
  7589 00001F60 50                  <1>  DB 50h
  7590 00001F61 03                  <1>  DB 3
  7591                              <1> 
  7592 00001F62 0002                <1>  DW 512
  7593                              <1> 
  7594 00001F64 01                  <1>  db 1
  7595 00001F65 0100                <1>  DW 1
  7596 00001F67 02                  <1>  DB 2
  7597 00001F68 1000                <1>  DW 16
  7598 00001F6A 0000                <1>  DW 0
  7599 00001F6C F8                  <1>  DB 11111000b
  7600 00001F6D 0100                <1>  DW 1
  7601 00001F6F 0000                <1>  DW 0
  7602 00001F71 0000                <1>  DW 0
  7603 00001F73 0000                <1>  DW 0
  7604 00001F75 00                  <1>  DB 0
  7605                              <1> 
  7606 00001F76 0000                <1>  DW 0
  7607                              <1> 
  7608 00001F78 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7608 00001F81 202000              <1>
  7609 00001F84 03                  <1>  DB 3
  7610                              <1> 
  7611 00001F85 2000                <1>  DW 20h
  7612 00001F87 2800                <1>  DW 40
  7613                              <1> 
  7614 00001F89 00<rep 1Fh>         <1>  times 31 db 0
  7615                              <1> 
  7616 00001FA8 FF                  <1>  DB -1
  7617                              <1> 
  7618 00001FA9 0100                <1>  DW 1
  7619                              <1> 
  7620 00001FAB 0000                <1>  DW 0
  7621                              <1> 
  7586                              <1> 
  7587 00001FAD FFFF                <1>  DW -1
  7588 00001FAF 0000                <1>  DW 0
  7589 00001FB1 50                  <1>  DB 50h
  7590 00001FB2 03                  <1>  DB 3
  7591                              <1> 
  7592 00001FB3 0002                <1>  DW 512
  7593                              <1> 
  7594 00001FB5 01                  <1>  db 1
  7595 00001FB6 0100                <1>  DW 1
  7596 00001FB8 02                  <1>  DB 2
  7597 00001FB9 1000                <1>  DW 16
  7598 00001FBB 0000                <1>  DW 0
  7599 00001FBD F8                  <1>  DB 11111000b
  7600 00001FBE 0100                <1>  DW 1
  7601 00001FC0 0000                <1>  DW 0
  7602 00001FC2 0000                <1>  DW 0
  7603 00001FC4 0000                <1>  DW 0
  7604 00001FC6 00                  <1>  DB 0
  7605                              <1> 
  7606 00001FC7 0000                <1>  DW 0
  7607                              <1> 
  7608 00001FC9 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7608 00001FD2 202000              <1>
  7609 00001FD5 03                  <1>  DB 3
  7610                              <1> 
  7611 00001FD6 2000                <1>  DW 20h
  7612 00001FD8 2800                <1>  DW 40
  7613                              <1> 
  7614 00001FDA 00<rep 1Fh>         <1>  times 31 db 0
  7615                              <1> 
  7616 00001FF9 FF                  <1>  DB -1
  7617                              <1> 
  7618 00001FFA 0100                <1>  DW 1
  7619                              <1> 
  7620 00001FFC 0000                <1>  DW 0
  7621                              <1> 
  7586                              <1> 
  7587 00001FFE FFFF                <1>  DW -1
  7588 00002000 0000                <1>  DW 0
  7589 00002002 50                  <1>  DB 50h
  7590 00002003 03                  <1>  DB 3
  7591                              <1> 
  7592 00002004 0002                <1>  DW 512
  7593                              <1> 
  7594 00002006 01                  <1>  db 1
  7595 00002007 0100                <1>  DW 1
  7596 00002009 02                  <1>  DB 2
  7597 0000200A 1000                <1>  DW 16
  7598 0000200C 0000                <1>  DW 0
  7599 0000200E F8                  <1>  DB 11111000b
  7600 0000200F 0100                <1>  DW 1
  7601 00002011 0000                <1>  DW 0
  7602 00002013 0000                <1>  DW 0
  7603 00002015 0000                <1>  DW 0
  7604 00002017 00                  <1>  DB 0
  7605                              <1> 
  7606 00002018 0000                <1>  DW 0
  7607                              <1> 
  7608 0000201A 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7608 00002023 202000              <1>
  7609 00002026 03                  <1>  DB 3
  7610                              <1> 
  7611 00002027 2000                <1>  DW 20h
  7612 00002029 2800                <1>  DW 40
  7613                              <1> 
  7614 0000202B 00<rep 1Fh>         <1>  times 31 db 0
  7615                              <1> 
  7616 0000204A FF                  <1>  DB -1
  7617                              <1> 
  7618 0000204B 0100                <1>  DW 1
  7619                              <1> 
  7620 0000204D 0000                <1>  DW 0
  7621                              <1> 
  7586                              <1> 
  7587 0000204F FFFF                <1>  DW -1
  7588 00002051 0000                <1>  DW 0
  7589 00002053 50                  <1>  DB 50h
  7590 00002054 03                  <1>  DB 3
  7591                              <1> 
  7592 00002055 0002                <1>  DW 512
  7593                              <1> 
  7594 00002057 01                  <1>  db 1
  7595 00002058 0100                <1>  DW 1
  7596 0000205A 02                  <1>  DB 2
  7597 0000205B 1000                <1>  DW 16
  7598 0000205D 0000                <1>  DW 0
  7599 0000205F F8                  <1>  DB 11111000b
  7600 00002060 0100                <1>  DW 1
  7601 00002062 0000                <1>  DW 0
  7602 00002064 0000                <1>  DW 0
  7603 00002066 0000                <1>  DW 0
  7604 00002068 00                  <1>  DB 0
  7605                              <1> 
  7606 00002069 0000                <1>  DW 0
  7607                              <1> 
  7608 0000206B 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7608 00002074 202000              <1>
  7609 00002077 03                  <1>  DB 3
  7610                              <1> 
  7611 00002078 2000                <1>  DW 20h
  7612 0000207A 2800                <1>  DW 40
  7613                              <1> 
  7614 0000207C 00<rep 1Fh>         <1>  times 31 db 0
  7615                              <1> 
  7616 0000209B FF                  <1>  DB -1
  7617                              <1> 
  7618 0000209C 0100                <1>  DW 1
  7619                              <1> 
  7620 0000209E 0000                <1>  DW 0
  7621                              <1> 
  7586                              <1> 
  7587 000020A0 FFFF                <1>  DW -1
  7588 000020A2 0000                <1>  DW 0
  7589 000020A4 50                  <1>  DB 50h
  7590 000020A5 03                  <1>  DB 3
  7591                              <1> 
  7592 000020A6 0002                <1>  DW 512
  7593                              <1> 
  7594 000020A8 01                  <1>  db 1
  7595 000020A9 0100                <1>  DW 1
  7596 000020AB 02                  <1>  DB 2
  7597 000020AC 1000                <1>  DW 16
  7598 000020AE 0000                <1>  DW 0
  7599 000020B0 F8                  <1>  DB 11111000b
  7600 000020B1 0100                <1>  DW 1
  7601 000020B3 0000                <1>  DW 0
  7602 000020B5 0000                <1>  DW 0
  7603 000020B7 0000                <1>  DW 0
  7604 000020B9 00                  <1>  DB 0
  7605                              <1> 
  7606 000020BA 0000                <1>  DW 0
  7607                              <1> 
  7608 000020BC 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7608 000020C5 202000              <1>
  7609 000020C8 03                  <1>  DB 3
  7610                              <1> 
  7611 000020C9 2000                <1>  DW 20h
  7612 000020CB 2800                <1>  DW 40
  7613                              <1> 
  7614 000020CD 00<rep 1Fh>         <1>  times 31 db 0
  7615                              <1> 
  7616 000020EC FF                  <1>  DB -1
  7617                              <1> 
  7618 000020ED 0100                <1>  DW 1
  7619                              <1> 
  7620 000020EF 0000                <1>  DW 0
  7621                              <1> 
  7586                              <1> 
  7587 000020F1 FFFF                <1>  DW -1
  7588 000020F3 0000                <1>  DW 0
  7589 000020F5 50                  <1>  DB 50h
  7590 000020F6 03                  <1>  DB 3
  7591                              <1> 
  7592 000020F7 0002                <1>  DW 512
  7593                              <1> 
  7594 000020F9 01                  <1>  db 1
  7595 000020FA 0100                <1>  DW 1
  7596 000020FC 02                  <1>  DB 2
  7597 000020FD 1000                <1>  DW 16
  7598 000020FF 0000                <1>  DW 0
  7599 00002101 F8                  <1>  DB 11111000b
  7600 00002102 0100                <1>  DW 1
  7601 00002104 0000                <1>  DW 0
  7602 00002106 0000                <1>  DW 0
  7603 00002108 0000                <1>  DW 0
  7604 0000210A 00                  <1>  DB 0
  7605                              <1> 
  7606 0000210B 0000                <1>  DW 0
  7607                              <1> 
  7608 0000210D 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7608 00002116 202000              <1>
  7609 00002119 03                  <1>  DB 3
  7610                              <1> 
  7611 0000211A 2000                <1>  DW 20h
  7612 0000211C 2800                <1>  DW 40
  7613                              <1> 
  7614 0000211E 00<rep 1Fh>         <1>  times 31 db 0
  7615                              <1> 
  7616 0000213D FF                  <1>  DB -1
  7617                              <1> 
  7618 0000213E 0100                <1>  DW 1
  7619                              <1> 
  7620 00002140 0000                <1>  DW 0
  7621                              <1> 
  7586                              <1> 
  7587 00002142 FFFF                <1>  DW -1
  7588 00002144 0000                <1>  DW 0
  7589 00002146 50                  <1>  DB 50h
  7590 00002147 03                  <1>  DB 3
  7591                              <1> 
  7592 00002148 0002                <1>  DW 512
  7593                              <1> 
  7594 0000214A 01                  <1>  db 1
  7595 0000214B 0100                <1>  DW 1
  7596 0000214D 02                  <1>  DB 2
  7597 0000214E 1000                <1>  DW 16
  7598 00002150 0000                <1>  DW 0
  7599 00002152 F8                  <1>  DB 11111000b
  7600 00002153 0100                <1>  DW 1
  7601 00002155 0000                <1>  DW 0
  7602 00002157 0000                <1>  DW 0
  7603 00002159 0000                <1>  DW 0
  7604 0000215B 00                  <1>  DB 0
  7605                              <1> 
  7606 0000215C 0000                <1>  DW 0
  7607                              <1> 
  7608 0000215E 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7608 00002167 202000              <1>
  7609 0000216A 03                  <1>  DB 3
  7610                              <1> 
  7611 0000216B 2000                <1>  DW 20h
  7612 0000216D 2800                <1>  DW 40
  7613                              <1> 
  7614 0000216F 00<rep 1Fh>         <1>  times 31 db 0
  7615                              <1> 
  7616 0000218E FF                  <1>  DB -1
  7617                              <1> 
  7618 0000218F 0100                <1>  DW 1
  7619                              <1> 
  7620 00002191 0000                <1>  DW 0
  7621                              <1> 
  7586                              <1> 
  7587 00002193 FFFF                <1>  DW -1
  7588 00002195 0000                <1>  DW 0
  7589 00002197 50                  <1>  DB 50h
  7590 00002198 03                  <1>  DB 3
  7591                              <1> 
  7592 00002199 0002                <1>  DW 512
  7593                              <1> 
  7594 0000219B 01                  <1>  db 1
  7595 0000219C 0100                <1>  DW 1
  7596 0000219E 02                  <1>  DB 2
  7597 0000219F 1000                <1>  DW 16
  7598 000021A1 0000                <1>  DW 0
  7599 000021A3 F8                  <1>  DB 11111000b
  7600 000021A4 0100                <1>  DW 1
  7601 000021A6 0000                <1>  DW 0
  7602 000021A8 0000                <1>  DW 0
  7603 000021AA 0000                <1>  DW 0
  7604 000021AC 00                  <1>  DB 0
  7605                              <1> 
  7606 000021AD 0000                <1>  DW 0
  7607                              <1> 
  7608 000021AF 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7608 000021B8 202000              <1>
  7609 000021BB 03                  <1>  DB 3
  7610                              <1> 
  7611 000021BC 2000                <1>  DW 20h
  7612 000021BE 2800                <1>  DW 40
  7613                              <1> 
  7614 000021C0 00<rep 1Fh>         <1>  times 31 db 0
  7615                              <1> 
  7616 000021DF FF                  <1>  DB -1
  7617                              <1> 
  7618 000021E0 0100                <1>  DW 1
  7619                              <1> 
  7620 000021E2 0000                <1>  DW 0
  7621                              <1> 
  7586                              <1> 
  7587 000021E4 FFFF                <1>  DW -1
  7588 000021E6 0000                <1>  DW 0
  7589 000021E8 50                  <1>  DB 50h
  7590 000021E9 03                  <1>  DB 3
  7591                              <1> 
  7592 000021EA 0002                <1>  DW 512
  7593                              <1> 
  7594 000021EC 01                  <1>  db 1
  7595 000021ED 0100                <1>  DW 1
  7596 000021EF 02                  <1>  DB 2
  7597 000021F0 1000                <1>  DW 16
  7598 000021F2 0000                <1>  DW 0
  7599 000021F4 F8                  <1>  DB 11111000b
  7600 000021F5 0100                <1>  DW 1
  7601 000021F7 0000                <1>  DW 0
  7602 000021F9 0000                <1>  DW 0
  7603 000021FB 0000                <1>  DW 0
  7604 000021FD 00                  <1>  DB 0
  7605                              <1> 
  7606 000021FE 0000                <1>  DW 0
  7607                              <1> 
  7608 00002200 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7608 00002209 202000              <1>
  7609 0000220C 03                  <1>  DB 3
  7610                              <1> 
  7611 0000220D 2000                <1>  DW 20h
  7612 0000220F 2800                <1>  DW 40
  7613                              <1> 
  7614 00002211 00<rep 1Fh>         <1>  times 31 db 0
  7615                              <1> 
  7616 00002230 FF                  <1>  DB -1
  7617                              <1> 
  7618 00002231 0100                <1>  DW 1
  7619                              <1> 
  7620 00002233 0000                <1>  DW 0
  7621                              <1> 
  7586                              <1> 
  7587 00002235 FFFF                <1>  DW -1
  7588 00002237 0000                <1>  DW 0
  7589 00002239 50                  <1>  DB 50h
  7590 0000223A 03                  <1>  DB 3
  7591                              <1> 
  7592 0000223B 0002                <1>  DW 512
  7593                              <1> 
  7594 0000223D 01                  <1>  db 1
  7595 0000223E 0100                <1>  DW 1
  7596 00002240 02                  <1>  DB 2
  7597 00002241 1000                <1>  DW 16
  7598 00002243 0000                <1>  DW 0
  7599 00002245 F8                  <1>  DB 11111000b
  7600 00002246 0100                <1>  DW 1
  7601 00002248 0000                <1>  DW 0
  7602 0000224A 0000                <1>  DW 0
  7603 0000224C 0000                <1>  DW 0
  7604 0000224E 00                  <1>  DB 0
  7605                              <1> 
  7606 0000224F 0000                <1>  DW 0
  7607                              <1> 
  7608 00002251 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7608 0000225A 202000              <1>
  7609 0000225D 03                  <1>  DB 3
  7610                              <1> 
  7611 0000225E 2000                <1>  DW 20h
  7612 00002260 2800                <1>  DW 40
  7613                              <1> 
  7614 00002262 00<rep 1Fh>         <1>  times 31 db 0
  7615                              <1> 
  7616 00002281 FF                  <1>  DB -1
  7617                              <1> 
  7618 00002282 0100                <1>  DW 1
  7619                              <1> 
  7620 00002284 0000                <1>  DW 0
  7621                              <1> 
  7586                              <1> 
  7587 00002286 FFFF                <1>  DW -1
  7588 00002288 0000                <1>  DW 0
  7589 0000228A 50                  <1>  DB 50h
  7590 0000228B 03                  <1>  DB 3
  7591                              <1> 
  7592 0000228C 0002                <1>  DW 512
  7593                              <1> 
  7594 0000228E 01                  <1>  db 1
  7595 0000228F 0100                <1>  DW 1
  7596 00002291 02                  <1>  DB 2
  7597 00002292 1000                <1>  DW 16
  7598 00002294 0000                <1>  DW 0
  7599 00002296 F8                  <1>  DB 11111000b
  7600 00002297 0100                <1>  DW 1
  7601 00002299 0000                <1>  DW 0
  7602 0000229B 0000                <1>  DW 0
  7603 0000229D 0000                <1>  DW 0
  7604 0000229F 00                  <1>  DB 0
  7605                              <1> 
  7606 000022A0 0000                <1>  DW 0
  7607                              <1> 
  7608 000022A2 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7608 000022AB 202000              <1>
  7609 000022AE 03                  <1>  DB 3
  7610                              <1> 
  7611 000022AF 2000                <1>  DW 20h
  7612 000022B1 2800                <1>  DW 40
  7613                              <1> 
  7614 000022B3 00<rep 1Fh>         <1>  times 31 db 0
  7615                              <1> 
  7616 000022D2 FF                  <1>  DB -1
  7617                              <1> 
  7618 000022D3 0100                <1>  DW 1
  7619                              <1> 
  7620 000022D5 0000                <1>  DW 0
  7621                              <1> 
  7586                              <1> 
  7587 000022D7 FFFF                <1>  DW -1
  7588 000022D9 0000                <1>  DW 0
  7589 000022DB 50                  <1>  DB 50h
  7590 000022DC 03                  <1>  DB 3
  7591                              <1> 
  7592 000022DD 0002                <1>  DW 512
  7593                              <1> 
  7594 000022DF 01                  <1>  db 1
  7595 000022E0 0100                <1>  DW 1
  7596 000022E2 02                  <1>  DB 2
  7597 000022E3 1000                <1>  DW 16
  7598 000022E5 0000                <1>  DW 0
  7599 000022E7 F8                  <1>  DB 11111000b
  7600 000022E8 0100                <1>  DW 1
  7601 000022EA 0000                <1>  DW 0
  7602 000022EC 0000                <1>  DW 0
  7603 000022EE 0000                <1>  DW 0
  7604 000022F0 00                  <1>  DB 0
  7605                              <1> 
  7606 000022F1 0000                <1>  DW 0
  7607                              <1> 
  7608 000022F3 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7608 000022FC 202000              <1>
  7609 000022FF 03                  <1>  DB 3
  7610                              <1> 
  7611 00002300 2000                <1>  DW 20h
  7612 00002302 2800                <1>  DW 40
  7613                              <1> 
  7614 00002304 00<rep 1Fh>         <1>  times 31 db 0
  7615                              <1> 
  7616 00002323 FF                  <1>  DB -1
  7617                              <1> 
  7618 00002324 0100                <1>  DW 1
  7619                              <1> 
  7620 00002326 0000                <1>  DW 0
  7621                              <1> 
  7586                              <1> 
  7587 00002328 FFFF                <1>  DW -1
  7588 0000232A 0000                <1>  DW 0
  7589 0000232C 50                  <1>  DB 50h
  7590 0000232D 03                  <1>  DB 3
  7591                              <1> 
  7592 0000232E 0002                <1>  DW 512
  7593                              <1> 
  7594 00002330 01                  <1>  db 1
  7595 00002331 0100                <1>  DW 1
  7596 00002333 02                  <1>  DB 2
  7597 00002334 1000                <1>  DW 16
  7598 00002336 0000                <1>  DW 0
  7599 00002338 F8                  <1>  DB 11111000b
  7600 00002339 0100                <1>  DW 1
  7601 0000233B 0000                <1>  DW 0
  7602 0000233D 0000                <1>  DW 0
  7603 0000233F 0000                <1>  DW 0
  7604 00002341 00                  <1>  DB 0
  7605                              <1> 
  7606 00002342 0000                <1>  DW 0
  7607                              <1> 
  7608 00002344 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7608 0000234D 202000              <1>
  7609 00002350 03                  <1>  DB 3
  7610                              <1> 
  7611 00002351 2000                <1>  DW 20h
  7612 00002353 2800                <1>  DW 40
  7613                              <1> 
  7614 00002355 00<rep 1Fh>         <1>  times 31 db 0
  7615                              <1> 
  7616 00002374 FF                  <1>  DB -1
  7617                              <1> 
  7618 00002375 0100                <1>  DW 1
  7619                              <1> 
  7620 00002377 0000                <1>  DW 0
  7621                              <1> 
  7586                              <1> 
  7587 00002379 FFFF                <1>  DW -1
  7588 0000237B 0000                <1>  DW 0
  7589 0000237D 50                  <1>  DB 50h
  7590 0000237E 03                  <1>  DB 3
  7591                              <1> 
  7592 0000237F 0002                <1>  DW 512
  7593                              <1> 
  7594 00002381 01                  <1>  db 1
  7595 00002382 0100                <1>  DW 1
  7596 00002384 02                  <1>  DB 2
  7597 00002385 1000                <1>  DW 16
  7598 00002387 0000                <1>  DW 0
  7599 00002389 F8                  <1>  DB 11111000b
  7600 0000238A 0100                <1>  DW 1
  7601 0000238C 0000                <1>  DW 0
  7602 0000238E 0000                <1>  DW 0
  7603 00002390 0000                <1>  DW 0
  7604 00002392 00                  <1>  DB 0
  7605                              <1> 
  7606 00002393 0000                <1>  DW 0
  7607                              <1> 
  7608 00002395 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7608 0000239E 202000              <1>
  7609 000023A1 03                  <1>  DB 3
  7610                              <1> 
  7611 000023A2 2000                <1>  DW 20h
  7612 000023A4 2800                <1>  DW 40
  7613                              <1> 
  7614 000023A6 00<rep 1Fh>         <1>  times 31 db 0
  7615                              <1> 
  7616 000023C5 FF                  <1>  DB -1
  7617                              <1> 
  7618 000023C6 0100                <1>  DW 1
  7619                              <1> 
  7620 000023C8 0000                <1>  DW 0
  7621                              <1> 
  7586                              <1> 
  7587 000023CA FFFF                <1>  DW -1
  7588 000023CC 0000                <1>  DW 0
  7589 000023CE 50                  <1>  DB 50h
  7590 000023CF 03                  <1>  DB 3
  7591                              <1> 
  7592 000023D0 0002                <1>  DW 512
  7593                              <1> 
  7594 000023D2 01                  <1>  db 1
  7595 000023D3 0100                <1>  DW 1
  7596 000023D5 02                  <1>  DB 2
  7597 000023D6 1000                <1>  DW 16
  7598 000023D8 0000                <1>  DW 0
  7599 000023DA F8                  <1>  DB 11111000b
  7600 000023DB 0100                <1>  DW 1
  7601 000023DD 0000                <1>  DW 0
  7602 000023DF 0000                <1>  DW 0
  7603 000023E1 0000                <1>  DW 0
  7604 000023E3 00                  <1>  DB 0
  7605                              <1> 
  7606 000023E4 0000                <1>  DW 0
  7607                              <1> 
  7608 000023E6 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7608 000023EF 202000              <1>
  7609 000023F2 03                  <1>  DB 3
  7610                              <1> 
  7611 000023F3 2000                <1>  DW 20h
  7612 000023F5 2800                <1>  DW 40
  7613                              <1> 
  7614 000023F7 00<rep 1Fh>         <1>  times 31 db 0
  7615                              <1> 
  7616 00002416 FF                  <1>  DB -1
  7617                              <1> 
  7618 00002417 0100                <1>  DW 1
  7619                              <1> 
  7620 00002419 0000                <1>  DW 0
  7621                              <1> 
  7586                              <1> 
  7587 0000241B FFFF                <1>  DW -1
  7588 0000241D 0000                <1>  DW 0
  7589 0000241F 50                  <1>  DB 50h
  7590 00002420 03                  <1>  DB 3
  7591                              <1> 
  7592 00002421 0002                <1>  DW 512
  7593                              <1> 
  7594 00002423 01                  <1>  db 1
  7595 00002424 0100                <1>  DW 1
  7596 00002426 02                  <1>  DB 2
  7597 00002427 1000                <1>  DW 16
  7598 00002429 0000                <1>  DW 0
  7599 0000242B F8                  <1>  DB 11111000b
  7600 0000242C 0100                <1>  DW 1
  7601 0000242E 0000                <1>  DW 0
  7602 00002430 0000                <1>  DW 0
  7603 00002432 0000                <1>  DW 0
  7604 00002434 00                  <1>  DB 0
  7605                              <1> 
  7606 00002435 0000                <1>  DW 0
  7607                              <1> 
  7608 00002437 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7608 00002440 202000              <1>
  7609 00002443 03                  <1>  DB 3
  7610                              <1> 
  7611 00002444 2000                <1>  DW 20h
  7612 00002446 2800                <1>  DW 40
  7613                              <1> 
  7614 00002448 00<rep 1Fh>         <1>  times 31 db 0
  7615                              <1> 
  7616 00002467 FF                  <1>  DB -1
  7617                              <1> 
  7618 00002468 0100                <1>  DW 1
  7619                              <1> 
  7620 0000246A 0000                <1>  DW 0
  7621                              <1> 
  7586                              <1> 
  7587 0000246C FFFF                <1>  DW -1
  7588 0000246E 0000                <1>  DW 0
  7589 00002470 50                  <1>  DB 50h
  7590 00002471 03                  <1>  DB 3
  7591                              <1> 
  7592 00002472 0002                <1>  DW 512
  7593                              <1> 
  7594 00002474 01                  <1>  db 1
  7595 00002475 0100                <1>  DW 1
  7596 00002477 02                  <1>  DB 2
  7597 00002478 1000                <1>  DW 16
  7598 0000247A 0000                <1>  DW 0
  7599 0000247C F8                  <1>  DB 11111000b
  7600 0000247D 0100                <1>  DW 1
  7601 0000247F 0000                <1>  DW 0
  7602 00002481 0000                <1>  DW 0
  7603 00002483 0000                <1>  DW 0
  7604 00002485 00                  <1>  DB 0
  7605                              <1> 
  7606 00002486 0000                <1>  DW 0
  7607                              <1> 
  7608 00002488 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7608 00002491 202000              <1>
  7609 00002494 03                  <1>  DB 3
  7610                              <1> 
  7611 00002495 2000                <1>  DW 20h
  7612 00002497 2800                <1>  DW 40
  7613                              <1> 
  7614 00002499 00<rep 1Fh>         <1>  times 31 db 0
  7615                              <1> 
  7616 000024B8 FF                  <1>  DB -1
  7617                              <1> 
  7618 000024B9 0100                <1>  DW 1
  7619                              <1> 
  7620 000024BB 0000                <1>  DW 0
  7621                              <1> 
  7586                              <1> 
  7587 000024BD FFFF                <1>  DW -1
  7588 000024BF 0000                <1>  DW 0
  7589 000024C1 50                  <1>  DB 50h
  7590 000024C2 03                  <1>  DB 3
  7591                              <1> 
  7592 000024C3 0002                <1>  DW 512
  7593                              <1> 
  7594 000024C5 01                  <1>  db 1
  7595 000024C6 0100                <1>  DW 1
  7596 000024C8 02                  <1>  DB 2
  7597 000024C9 1000                <1>  DW 16
  7598 000024CB 0000                <1>  DW 0
  7599 000024CD F8                  <1>  DB 11111000b
  7600 000024CE 0100                <1>  DW 1
  7601 000024D0 0000                <1>  DW 0
  7602 000024D2 0000                <1>  DW 0
  7603 000024D4 0000                <1>  DW 0
  7604 000024D6 00                  <1>  DB 0
  7605                              <1> 
  7606 000024D7 0000                <1>  DW 0
  7607                              <1> 
  7608 000024D9 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7608 000024E2 202000              <1>
  7609 000024E5 03                  <1>  DB 3
  7610                              <1> 
  7611 000024E6 2000                <1>  DW 20h
  7612 000024E8 2800                <1>  DW 40
  7613                              <1> 
  7614 000024EA 00<rep 1Fh>         <1>  times 31 db 0
  7615                              <1> 
  7616 00002509 FF                  <1>  DB -1
  7617                              <1> 
  7618 0000250A 0100                <1>  DW 1
  7619                              <1> 
  7620 0000250C 0000                <1>  DW 0
  7621                              <1> 
  7586                              <1> 
  7587 0000250E FFFF                <1>  DW -1
  7588 00002510 0000                <1>  DW 0
  7589 00002512 50                  <1>  DB 50h
  7590 00002513 03                  <1>  DB 3
  7591                              <1> 
  7592 00002514 0002                <1>  DW 512
  7593                              <1> 
  7594 00002516 01                  <1>  db 1
  7595 00002517 0100                <1>  DW 1
  7596 00002519 02                  <1>  DB 2
  7597 0000251A 1000                <1>  DW 16
  7598 0000251C 0000                <1>  DW 0
  7599 0000251E F8                  <1>  DB 11111000b
  7600 0000251F 0100                <1>  DW 1
  7601 00002521 0000                <1>  DW 0
  7602 00002523 0000                <1>  DW 0
  7603 00002525 0000                <1>  DW 0
  7604 00002527 00                  <1>  DB 0
  7605                              <1> 
  7606 00002528 0000                <1>  DW 0
  7607                              <1> 
  7608 0000252A 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7608 00002533 202000              <1>
  7609 00002536 03                  <1>  DB 3
  7610                              <1> 
  7611 00002537 2000                <1>  DW 20h
  7612 00002539 2800                <1>  DW 40
  7613                              <1> 
  7614 0000253B 00<rep 1Fh>         <1>  times 31 db 0
  7615                              <1> 
  7616 0000255A FF                  <1>  DB -1
  7617                              <1> 
  7618 0000255B 0100                <1>  DW 1
  7619                              <1> 
  7620 0000255D 0000                <1>  DW 0
  7621                              <1> 
  7586                              <1> 
  7587 0000255F FFFF                <1>  DW -1
  7588 00002561 0000                <1>  DW 0
  7589 00002563 50                  <1>  DB 50h
  7590 00002564 03                  <1>  DB 3
  7591                              <1> 
  7592 00002565 0002                <1>  DW 512
  7593                              <1> 
  7594 00002567 01                  <1>  db 1
  7595 00002568 0100                <1>  DW 1
  7596 0000256A 02                  <1>  DB 2
  7597 0000256B 1000                <1>  DW 16
  7598 0000256D 0000                <1>  DW 0
  7599 0000256F F8                  <1>  DB 11111000b
  7600 00002570 0100                <1>  DW 1
  7601 00002572 0000                <1>  DW 0
  7602 00002574 0000                <1>  DW 0
  7603 00002576 0000                <1>  DW 0
  7604 00002578 00                  <1>  DB 0
  7605                              <1> 
  7606 00002579 0000                <1>  DW 0
  7607                              <1> 
  7608 0000257B 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7608 00002584 202000              <1>
  7609 00002587 03                  <1>  DB 3
  7610                              <1> 
  7611 00002588 2000                <1>  DW 20h
  7612 0000258A 2800                <1>  DW 40
  7613                              <1> 
  7614 0000258C 00<rep 1Fh>         <1>  times 31 db 0
  7615                              <1> 
  7616 000025AB FF                  <1>  DB -1
  7617                              <1> 
  7618 000025AC 0100                <1>  DW 1
  7619                              <1> 
  7620 000025AE 0000                <1>  DW 0
  7621                              <1> 
  7586                              <1> 
  7587 000025B0 FFFF                <1>  DW -1
  7588 000025B2 0000                <1>  DW 0
  7589 000025B4 50                  <1>  DB 50h
  7590 000025B5 03                  <1>  DB 3
  7591                              <1> 
  7592 000025B6 0002                <1>  DW 512
  7593                              <1> 
  7594 000025B8 01                  <1>  db 1
  7595 000025B9 0100                <1>  DW 1
  7596 000025BB 02                  <1>  DB 2
  7597 000025BC 1000                <1>  DW 16
  7598 000025BE 0000                <1>  DW 0
  7599 000025C0 F8                  <1>  DB 11111000b
  7600 000025C1 0100                <1>  DW 1
  7601 000025C3 0000                <1>  DW 0
  7602 000025C5 0000                <1>  DW 0
  7603 000025C7 0000                <1>  DW 0
  7604 000025C9 00                  <1>  DB 0
  7605                              <1> 
  7606 000025CA 0000                <1>  DW 0
  7607                              <1> 
  7608 000025CC 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7608 000025D5 202000              <1>
  7609 000025D8 03                  <1>  DB 3
  7610                              <1> 
  7611 000025D9 2000                <1>  DW 20h
  7612 000025DB 2800                <1>  DW 40
  7613                              <1> 
  7614 000025DD 00<rep 1Fh>         <1>  times 31 db 0
  7615                              <1> 
  7616 000025FC FF                  <1>  DB -1
  7617                              <1> 
  7618 000025FD 0100                <1>  DW 1
  7619                              <1> 
  7620 000025FF 0000                <1>  DW 0
  7621                              <1> 
  7586                              <1> 
  7587 00002601 FFFF                <1>  DW -1
  7588 00002603 0000                <1>  DW 0
  7589 00002605 50                  <1>  DB 50h
  7590 00002606 03                  <1>  DB 3
  7591                              <1> 
  7592 00002607 0002                <1>  DW 512
  7593                              <1> 
  7594 00002609 01                  <1>  db 1
  7595 0000260A 0100                <1>  DW 1
  7596 0000260C 02                  <1>  DB 2
  7597 0000260D 1000                <1>  DW 16
  7598 0000260F 0000                <1>  DW 0
  7599 00002611 F8                  <1>  DB 11111000b
  7600 00002612 0100                <1>  DW 1
  7601 00002614 0000                <1>  DW 0
  7602 00002616 0000                <1>  DW 0
  7603 00002618 0000                <1>  DW 0
  7604 0000261A 00                  <1>  DB 0
  7605                              <1> 
  7606 0000261B 0000                <1>  DW 0
  7607                              <1> 
  7608 0000261D 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7608 00002626 202000              <1>
  7609 00002629 03                  <1>  DB 3
  7610                              <1> 
  7611 0000262A 2000                <1>  DW 20h
  7612 0000262C 2800                <1>  DW 40
  7613                              <1> 
  7614 0000262E 00<rep 1Fh>         <1>  times 31 db 0
  7615                              <1> 
  7616 0000264D FF                  <1>  DB -1
  7617                              <1> 
  7618 0000264E 0100                <1>  DW 1
  7619                              <1> 
  7620 00002650 0000                <1>  DW 0
  7621                              <1> 
  7623                                  
  7624                                  ;** End_of_BDSM defined in MSINIT.ASM will be used to set the appropriate
  7625                                  ;** ending address of BDSM table.
  7626                                  ;;End of modification ----------------------------
  7627                                  
  7628                                  ;
  7629                                  ;;3.3 BUG FIX -SP ------------------------------
  7630                                  ;Paragraph buffer between the BDSMs and MSHARD
  7631                                  ;
  7632                                  ;The relocation code for MSHARD needs this. this cannot be used for 
  7633                                  ;anything. nothing can come before this or after this.....IMPORTANT!!!!
  7634                                  ;don't get too smart and using this buffer for anything!!!!!!
  7635                                  ;
  7636 00002652 00<rep 10h>             		times 16 db 0
  7637                                  ;
  7638                                  ;end of bug fix buffer
  7639                                  ;;
  7640                                  ;;3.3 BUG FIX -SP------------------------------
  7641                                  
  7642                                  ;-----------------------------------------------------------------------------
  7643                                  ; MSHARD.ASM - MSDOS 3.3 - 24/07/1987
  7644                                  ;-----------------------------------------------------------------------------
  7645                                  ; 02/06/2018 - Retro DOS v3.0
  7646                                  
  7647                                  ;***
  7648                                  ;	Title:	Disk
  7649                                  ;	By:	Michael Hanson
  7650                                  ;	C:	Copyright (C) 1985-1987 by Microsoft corp.
  7651                                  ;	Date:	1/11/85
  7652                                  ;
  7653                                  ;		There is a bug in some versions of IBM's AT ROM BIOS
  7654                                  ;		interupts are not disabled during read operations.
  7655                                  ;
  7656                                  ;	Use:	This program should be chained in line with the disk
  7657                                  ;		interrupt 13h, it intercepts read calls to the hard disk
  7658                                  ;		and handles them appropriately.  For other functions it
  7659                                  ;		passes controll to OLD13, which should contain the
  7660                                  ;		address of the AT ROM disk routine. The entry point for
  7661                                  ;		this program is IBM_DISK_IO.
  7662                                  ;
  7663                                  
  7664                                  	; .286c		;Use 80286 non-protected mode
  7665                                  
  7666                                  BIOSEG	equ	040h	;Segment for ROM BIOS Data
  7667                                  ROMSEG	equ	0F000h	;Segment of ROM
  7668                                  
  7669                                  BAD_DISK equ	01
  7670                                  
  7671                                  HF_PORT	equ	01F0h
  7672                                  HF_REG_PORT equ	03F6h
  7673                                  
  7674                                  ;*	Offsets into Fixed disk parameter table
  7675                                  FDP_PRECOMP	equ 5
  7676                                  FDP_CONTROL	equ 8
  7677                                  
  7678                                  ;DATA	SEGMENT AT BIOSEG	;ROM BIOS data segment
  7679                                  
  7680                                  	;ORG 42h
  7681                                  ;CMD_BLOCK	DB 6 DUP (?)
  7682                                  
  7683                                  CMD_BLOCK equ 42h ; 6 bytes, hard disk controller command bytes	
  7684                                  
  7685                                  ;*	Offsets into CMD_BLOCK for registers
  7686                                  PRE_COMP equ 0	;Write Pre-compensation
  7687                                  SEC_CNT	 equ 1	;Sector count
  7688                                  SEC_NUM	 equ 2	;Sector number
  7689                                  CYL_LOW	 equ 3	;Cylinder number, low part
  7690                                  CYL_HIGH equ 4	;Cylinder number, high part
  7691                                  DRV_HEAD equ 5	;Drive/Head (Bit 7 = ECC mode, Bit 5 = 512 byte sectors, 
  7692                                  		;            Bit 4 = drive number, Bits 3-0 have head number)
  7693                                  CMD_REG  equ 6	;Command register
  7694                                  
  7695                                  	;ORG 074h
  7696                                  
  7697                                  ;DISK_STATUS1 	DB ?
  7698                                  ;HF_NUM		DB ?
  7699                                  ;CONTROL_BYTE	DB ?
  7700                                  
  7701                                  DISK_STATUS1 equ 74h ; 1 byte
  7702                                  HF_NUM	     equ 75h ; 1 byte
  7703                                  CONTROL_BYTE equ 76h ; 1 byte 	  	
  7704                                  
  7705                                  ;DATA	ENDS
  7706                                  
  7707                                  ;***	Define where the ROM routines are actually located
  7708                                  ;ROM	SEGMENT AT ROMSEG
  7709                                  
  7710                                  	;ORG 02E1Eh
  7711                                  ;ROMCOMMAND PROC FAR
  7712                                  ;ROMCOMMAND ENDP
  7713                                  
  7714                                  ROMCOMMAND equ 02E1Eh
  7715                                  
  7716                                  	;ORG 02E7Fh
  7717                                  ;ROMWAIT PROC FAR
  7718                                  ;ROMWAIT ENDP
  7719                                  
  7720                                  ROMWAIT	equ 02E7Fh
  7721                                  
  7722                                  	;ORG 02EE2h
  7723                                  ;ROMWAIT_DRQ PROC FAR
  7724                                  ;ROMWAIT_DRQ ENDP
  7725                                  
  7726                                  ROMWAIT_DRQ equ 02EE2h
  7727                                  
  7728                                  	;ORG 02EF8h
  7729                                  ;ROMCHECK_STATUS PROC FAR
  7730                                  ;ROMCHECK_STATUS ENDP
  7731                                  
  7732                                  ROMCHECK_STATUS equ 02EF8h
  7733                                  
  7734                                  ;	ORG 02F69h
  7735                                  ;ROMCHECK_DMA PROC FAR
  7736                                  ;ROMCHECK_DMA ENDP
  7737                                   
  7738                                  ROMCHECK_DMA equ 02F69h
  7739                                  
  7740                                  ;	ORG 02F8Eh
  7741                                  ;ROMGET_VEC PROC FAR
  7742                                  ;ROMGET_VEC ENDP
  7743                                  
  7744                                  ROMGET_VEC equ 2F8Eh	
  7745                                  
  7746                                  ;	ORG 0FF65h
  7747                                  ;ROMFRET PROC FAR	;Far return at F000:FF65 in AT ROM.
  7748                                  ;ROMFRET ENDP
  7749                                  
  7750                                  ROMFRET	equ 0FF65h
  7751                                  
  7752                                  ;ROM	ENDS
  7753                                  
  7754                                  
  7755                                  ;CODE	SEGMENT BYTE PUBLIC 'code'
  7756                                  
  7757                                  ;EXTRN	OLD13:DWORD		;Link to AT bios int 13h
  7758                                  
  7759                                  ;PUBLIC	IBM_DISK_IO	
  7760                                  
  7761                                  ;	ASSUME CS:CODE
  7762                                  ;	ASSUME DS:DATA
  7763                                  
  7764                                  
  7765                                  ;***	IBM_DISK_IO - main routine, fixes AT ROM bug
  7766                                  ;
  7767                                  ;	ENTRY:	(AH) = function, 02 or 0A for read.
  7768                                  ;		(DL) = drive number (80h or 81h).
  7769                                  ;		(DH) = head number.
  7770                                  ;		(CH) = cylinder number.
  7771                                  ;		(CL) = Sector number (high 2 bits has cylinder number).
  7772                                  ;		(AL) = number of sectors.
  7773                                  ;		(ES:BX) = address of read buffer.
  7774                                  ;		For more on register contents see ROM BIOS listing.
  7775                                  ;		Stack set up for return by an IRET.
  7776                                  ;
  7777                                  ;	EXIT:	(AH) = status of current operation.
  7778                                  ;		(CY) = 1 IF failed, 0 if successful.
  7779                                  ;		For other register contents see ROM BIOS listing.
  7780                                  ;
  7781                                  ;	USES:	
  7782                                  ;
  7783                                  ;
  7784                                  ;	WARNING: Uses OLD13 vector for non-read calls.
  7785                                  ;		Does direct calls to the AT ROM.
  7786                                  ;		Does segment arithmatic.
  7787                                  ;
  7788                                  ;	EFFECTS: Performs DISK I/O operation.
  7789                                  ;
  7790                                  ;IBM_DISK_IO PROC FAR
  7791                                  
  7792                                  IBM_DISK_IO:
  7793 00002662 80FA80                  		CMP	DL,80h
  7794 00002665 720A                    		JB	short ATD1	;Pass through floppy disk calls.
  7795 00002667 80FC02                  		CMP	AH,02h
  7796 0000266A 740A                    		JE	short ATD2	;Intercept call 02 (read sectors).
  7797 0000266C 80FC0A                  		CMP	AH,0Ah
  7798 0000266F 7405                    		JE	short ATD2	;and call 0Ah (read long).
  7799                                  ATD1:
  7800                                  		; 16/06/2018
  7801 00002671 2EFF2E[B000]            		JMP	far [cs:OLD13]	;Use ROM INT 13h handler.
  7802                                  ATD2:
  7803 00002676 53                      		PUSH	BX
  7804 00002677 51                      		PUSH	CX
  7805 00002678 52                      		PUSH	DX
  7806 00002679 57                      		PUSH	DI
  7807 0000267A 1E                      		PUSH	DS
  7808 0000267B 06                      		PUSH	ES
  7809 0000267C 50                      		PUSH	AX
  7810 0000267D B84000                  		MOV	AX,BIOSEG	;Establish BIOS segment addressing.
  7811 00002680 8ED8                    		MOV	DS,AX
  7812 00002682 C606740000              		MOV	byte [DISK_STATUS1],0 ;Initially no error code.
  7813 00002687 80E27F                  		AND	DL,07Fh		;Mask to hard disk number
  7814 0000268A 3A167500                		CMP	DL,[HF_NUM]
  7815 0000268E 7207                    		JB	short ATD3	;Disk number in range
  7816 00002690 C606740001              		MOV	byte [DISK_STATUS1],BAD_DISK
  7817 00002695 EB20                    		JMP	SHORT ATD4	;Disk number out of range error, return
  7818                                  
  7819                                  ATD3:
  7820 00002697 53                      		PUSH	BX
  7821 00002698 8CC0                    		MOV	AX,ES		;Make ES:BX to Seg:000x form.
  7822 0000269A C1EB04                  		SHR	BX,4
  7823 0000269D 01D8                    		ADD	AX,BX
  7824 0000269F 8EC0                    		MOV	ES,AX
  7825 000026A1 5B                      		POP	BX
  7826 000026A2 83E30F                  		AND	BX,000Fh
  7827 000026A5 0E                      		PUSH	CS
  7828 000026A6 E8DD00                  		CALL	CHECK_DMA
  7829 000026A9 720C                    		JC	short ATD4	;Abort if DMA across segment boundary
  7830                                  
  7831 000026AB 58                      		POP	AX		;Restore AX register for SETCMD
  7832 000026AC 50                      		PUSH	AX
  7833 000026AD E81900                  		CALL	SETCMD		;Set up command block for disk op
  7834 000026B0 BAF603                  		MOV	DX,HF_REG_PORT
  7835 000026B3 EE                      		OUT	DX,AL		;Write out command modifier
  7836 000026B4 E86A00                  		CALL	DOCMD		;Carry out command
  7837                                  ATD4:
  7838 000026B7 58                      		POP	AX
  7839 000026B8 8A267400                		MOV	AH,[DISK_STATUS1] ;On return AH has error code
  7840                                  		; 16/06/2018
  7841                                  		;STC
  7842                                  		;OR	AH,AH
  7843                                  		;JNZ	short ATD5	;Carry set if error
  7844                                  		;CLC
  7845                                  ;ATD5:
  7846 000026BC 80FC01                  		cmp	ah,1
  7847 000026BF F5                      		cmc	
  7848                                  
  7849 000026C0 07                      		POP	ES
  7850 000026C1 1F                      		POP	DS
  7851 000026C2 5F                      		POP	DI
  7852 000026C3 5A                      		POP	DX
  7853 000026C4 59                      		POP	CX
  7854 000026C5 5B                      		POP	BX
  7855                                  		; 16/06/2018
  7856 000026C6 CA0200                  		RETF	2		;Far return, dropping flags
  7857                                  
  7858                                  ;IBM_DISK_IO ENDP
  7859                                  
  7860                                  ;***	SETCMD - Set up CMD_BLOCK for the disk operation
  7861                                  ;
  7862                                  ;	ENTRY:	(DS) = BIOS Data segment.
  7863                                  ;		(ES:BX) in seg:000x form.
  7864                                  ;		Other registers as in INT 13h call
  7865                                  ;	
  7866                                  ;	EXIT:	CMD_BLOCK set up for disk read call.
  7867                                  ;		CONTROL_BYTE set up for disk operation.
  7868                                  ;		(AL) = Control byte modifier
  7869                                  ;
  7870                                  ;
  7871                                  ;	Sets the fields of CMD_BLOCK using the register contents
  7872                                  ;	and the contents of the disk parameter block for the given drive.
  7873                                  ;
  7874                                  ;	WARNING: (AX) destroyed.
  7875                                  ;		Does direct calls to the AT ROM.
  7876                                  ;
  7877                                  
  7878                                  ;SETCMD	PROC NEAR
  7879                                  
  7880                                  SETCMD:
  7881 000026C9 A24300                  		MOV	[CMD_BLOCK+SEC_CNT],AL
  7882 000026CC C606480020              		MOV	byte [CMD_BLOCK+CMD_REG],020h ;Assume function 02
  7883 000026D1 80FC02                  		CMP	AH, 2
  7884 000026D4 7405                    		JE	short SETC1	;CMD_REG = 20h if function 02 (read)
  7885                                     					;CMD_REG = 22h if function 0A (" long)
  7886 000026D6 C606480022              		MOV	byte [CMD_BLOCK+CMD_REG],022h
  7887                                  SETC1:					;No longer need value in AX
  7888 000026DB 88C8                    		MOV	AL,CL
  7889 000026DD 243F                    		AND	AL,03Fh		;Mask to sector number
  7890 000026DF A24400                  		MOV 	[CMD_BLOCK+SEC_NUM],AL
  7891 000026E2 882E4500                		MOV	[CMD_BLOCK+CYL_LOW],CH
  7892 000026E6 88C8                    		MOV	AL,CL
  7893 000026E8 C0E806                  		SHR	AL,6		;Get two high bits of cylinder number
  7894 000026EB A24600                  		MOV	[CMD_BLOCK+CYL_HIGH],AL
  7895 000026EE 89D0                    		MOV	AX,DX
  7896 000026F0 C0E004                  		SHL	AL,4		;Drive number
  7897 000026F3 80E40F                  		AND	AH,0Fh
  7898 000026F6 08E0                    		OR	AL,AH		;Head number
  7899 000026F8 0CA0                    		OR	AL,0A0h		;Set ECC and 512 bytes per sector
  7900 000026FA A24700                  		MOV	[CMD_BLOCK+DRV_HEAD],AL
  7901 000026FD 06                      		PUSH	ES		;GET_VEC destroys ES:BX
  7902 000026FE 53                      		PUSH	BX
  7903 000026FF 0E                      		PUSH	CS
  7904 00002700 E85B00                  		CALL	GET_VEC
  7905                                  					;Write pre-comp from disk parameters
  7906 00002703 268B4705                		MOV	AX,[ES:BX+FDP_PRECOMP]
  7907 00002707 C1E802                  		SHR	AX,2
  7908 0000270A A24200                  		MOV	[CMD_BLOCK+PRE_COMP],AL	;Only use low part
  7909 0000270D 268A4708                		MOV	AL,[ES:BX+FDP_CONTROL]	;Control byte modifier
  7910 00002711 5B                      		POP	BX
  7911 00002712 07                      		POP	ES
  7912 00002713 8A267600                		MOV	AH,[CONTROL_BYTE]
  7913 00002717 80E4C0                  		AND	AH,0C0h		;Keep disable retry bits
  7914 0000271A 08C4                    		OR	AH,AL
  7915 0000271C 88267600                		MOV	[CONTROL_BYTE],AH
  7916 00002720 C3                      		RETN
  7917                                  
  7918                                  ;SETCMD	ENDP	
  7919                                  
  7920                                  ;***	DOCMD - Carry out READ operation to AT hard disk
  7921                                  ;
  7922                                  ;	ENTRY:	(ES:BX) = address for read in data.
  7923                                  ;		CMD_BLOCK set up for disk read.
  7924                                  ;
  7925                                  ;	EXIT:	Buffer at (ES:BX) contains data read.
  7926                                  ;		DISK_STATUS1 set to error code (0 if success).
  7927                                  ;
  7928                                  ;	
  7929                                  ;
  7930                                  ;	WARNING: (AX), (BL), (CX), (DX), (DI) destroyed.
  7931                                  ;		No check is made for DMA boundary overrun.
  7932                                  ;
  7933                                  ;	EFFECTS: Programs disk controller.
  7934                                  ;		Performs disk input.
  7935                                  ;
  7936                                  
  7937                                  ;DOCMD	PROC NEAR
  7938                                  DOCMD:
  7939 00002721 89DF                    		MOV	DI,BX	;(ES:DI) = data buffer addr.
  7940 00002723 0E                      		PUSH	CS
  7941 00002724 E83F00                  		CALL	COMMAND
  7942 00002727 7534                    		JNZ	short DOC3
  7943                                  DOC1:
  7944 00002729 0E                      		PUSH	CS
  7945 0000272A E84100                  		CALL	_WAIT	;Wait for controller to complete read
  7946 0000272D 752E                    		JNZ	short DOC3
  7947 0000272F B90001                  		MOV	CX,100h	;256 words per sector
  7948 00002732 BAF001                  		MOV	DX,HF_PORT
  7949 00002735 FC                      		CLD		;String op goes up
  7950 00002736 FA                      		CLI		;Disable interrupts (BUG WAS FORGETTING THIS)
  7951 00002737 F36D                    		REPZ	INSW	;Read in sector
  7952 00002739 FB                      		STI
  7953 0000273A F606480002              		TEST	byte [CMD_BLOCK+CMD_REG],02h
  7954 0000273F 7410                    		JZ	short DOC2 ;No ECC bytes to read.
  7955 00002741 0E                      		PUSH	CS
  7956 00002742 E83100                  		CALL	WAIT_DRQ
  7957 00002745 7216                    		JC	short DOC3
  7958 00002747 B90400                  		MOV	CX,4	;4 bytes of ECC
  7959 0000274A BAF001                  		MOV	DX,HF_PORT
  7960 0000274D FA                      		CLI
  7961 0000274E F36C                    		REPZ	INSB	;Read in ECC
  7962 00002750 FB                      		STI
  7963                                  DOC2:
  7964 00002751 0E                      		PUSH	CS
  7965 00002752 E82900                  		CALL	CHECK_STATUS
  7966 00002755 7506                    		JNZ	short DOC3 ;Operation failed
  7967 00002757 FE0E4300                		DEC	byte  [CMD_BLOCK+SEC_CNT]	
  7968 0000275B 75CC                    		JNZ	short DOC1 ;Loop while more sectors to read
  7969                                  DOC3:
  7970 0000275D C3                      		RETN
  7971                                  
  7972                                  ;DOCMD	ENDP
  7973                                  
  7974                                  ;***	GET_VEC - Get pointer to hard disk parameters.
  7975                                  ;
  7976                                  ;	ENTRY:	(DL) = Low bit has hard disk number (0 or 1).
  7977                                  ;
  7978                                  ;	EXIT:	(ES:BX) = address of disk parameters table.
  7979                                  ;
  7980                                  ;	USES:	AX for segment computation.
  7981                                  ;
  7982                                  ;	Loads ES:BX from interrupt table in low memory, vector 46h (disk 0)
  7983                                  ;	or 70h (disk 1).
  7984                                  ;	
  7985                                  ;	WARNING: (AX) destroyed.
  7986                                  ;		This does a direct call to the AT ROM.
  7987                                  ;
  7988                                  
  7989                                  ;GET_VEC PROC NEAR
  7990                                  GET_VEC:
  7991                                  		;PUSH	OFFSET ROMFRET
  7992 0000275E 6865FF                  		push	ROMFRET
  7993                                  		;JMP	ROMGET_VEC
  7994 00002761 EA8E2F00F0              		jmp	ROMSEG:ROMGET_VEC
  7995                                  ;GET_VEC ENDP
  7996                                  
  7997                                  ;***	COMMAND - Send contents of CMD_BLOCK to disk controller.
  7998                                  ;
  7999                                  ;	ENTRY:	Control_byte 
  8000                                  ;		CMD_BLOCK - set up with values for hard disk controller.
  8001                                  ;
  8002                                  ;	EXIT:	DISK_STATUS1 = Error code.
  8003                                  ;		NZ if error, ZR for no error.
  8004                                  ;
  8005                                  ;
  8006                                  ;	WARNING: (AX), (CX), (DX) destroyed.
  8007                                  ;		Does a direct call to the AT ROM.
  8008                                  ;
  8009                                  ;	EFFECTS: Programs disk controller.
  8010                                  ;
  8011                                  
  8012                                  ;COMMAND PROC NEAR
  8013                                  COMMAND:
  8014                                  		;PUSH	OFFSET ROMFRET
  8015 00002766 6865FF                  		push	ROMFRET	
  8016                                  		;JMP	ROMCOMMAND
  8017 00002769 EA1E2E00F0              		jmp	ROMSEG:ROMCOMMAND
  8018                                  ;COMMAND ENDP
  8019                                  
  8020                                  ;***	WAIT - Wait for disk interrupt
  8021                                  ;
  8022                                  ;	ENTRY:	Nothing.
  8023                                  ;
  8024                                  ;	EXIT:	DISK_STATUS1 = Error code.
  8025                                  ;		NZ if error, ZR if no error.
  8026                                  ;
  8027                                  ;
  8028                                  ;	WARNING: (AX), (BL), (CX) destroyed.
  8029                                  ;		Does a direct call to the AT ROM.
  8030                                  ;		
  8031                                  ;	EFFECTS: Calls int 15h, function 9000h.
  8032                                  ;
  8033                                  
  8034                                  ;WAIT	PROC NEAR
  8035                                  _WAIT:
  8036                                  		;PUSH	OFFSET ROMFRET 
  8037 0000276E 6865FF                  		push	ROMFRET
  8038                                  		;JMP	ROMWAIT
  8039 00002771 EA7F2E00F0              		jmp	ROMSEG:ROMWAIT
  8040                                  ;WAIT	ENDP
  8041                                  
  8042                                  ;***	WAIT_DRQ - Wait for data request.
  8043                                  ;
  8044                                  ;	ENTRY:	Nothing.
  8045                                  ;
  8046                                  ;	EXIT:	DISK_STATUS1 = Error code.
  8047                                  ;		CY if error, NC if no error.
  8048                                  ;
  8049                                  ;
  8050                                  ;	WARNING: (AL), (CX), (DX) destroyed.
  8051                                  ;		Does a direct call to the AT ROM.
  8052                                  ;
  8053                                  
  8054                                  ;WAIT_DRQ PROC NEAR
  8055                                  WAIT_DRQ:
  8056                                  		;PUSH	OFFSET ROMFRET 
  8057 00002776 6865FF                  		push	ROMFRET
  8058                                  		;JMP	ROMWAIT_DRQ
  8059 00002779 EAE22E00F0              		jmp	ROMSEG:ROMWAIT_DRQ
  8060                                  ;WAIT_DRQ ENDP
  8061                                  
  8062                                  ;***	CHECK_STATUS - Check hard disk status.
  8063                                  ;
  8064                                  ;	ENTRY:	Nothing.
  8065                                  ;
  8066                                  ;	EXIT:	DISK_STATUS1 = Error code.
  8067                                  ;		NZ if error, ZR if no error.
  8068                                  ;
  8069                                  ;
  8070                                  ;	WARNING: (AX), (CX), (DX) destroyed.
  8071                                  ;		Does a direct call to the AT ROM.
  8072                                  ;
  8073                                  
  8074                                  ;CHECK_STATUS PROC NEAR
  8075                                  CHECK_STATUS:
  8076                                  		;PUSH	OFFSET ROMFRET 
  8077 0000277E 6865FF                  		push	ROMFRET
  8078                                  		;JMP	ROMCHECK_STATUS
  8079 00002781 EAF82E00F0              		jmp	ROMSEG:ROMCHECK_STATUS
  8080                                  ;CHECK_STATUS ENDP
  8081                                  
  8082                                  ;***	CHECK_DMA - check for DMA overrun 64k segment.
  8083                                  ;
  8084                                  ;	ENTRY:	(ES:BX) = addr. of memory buffer in seg:000x form.
  8085                                  ;		CMD_BLOCK set up for operation.
  8086                                  ;
  8087                                  ;	EXIT:	DISK_STATUS1 - Error code.
  8088                                  ;		CY if error, NC if no error.
  8089                                  ;
  8090                                  ;
  8091                                  ;	WARNING: Does a direct call to the AT ROM.
  8092                                  ;
  8093                                  
  8094                                  ;CHECK_DMA PROC NEAR
  8095                                  CHECK_DMA:
  8096                                  		;PUSH	OFFSET ROMFRET 
  8097 00002786 6865FF                  		push	ROMFRET
  8098                                  		;JMP	ROMCHECK_DMA
  8099 00002789 EA692F00F0              		jmp	ROMSEG:ROMCHECK_DMA	
  8100                                  ;CHECK_DMA ENDP
  8101                                  
  8102                                  
  8103                                  ;CODE	ENDS
  8104                                  ;	END
  8105                                  
  8106                                  ;-----------------------------------------------------------------------------
  8107                                  ; MSINIT.ASM - MSDOS 3.3 - 02/02/1988
  8108                                  ;-----------------------------------------------------------------------------
  8109                                  ; 02/06/2018 - Retro DOS v3.0
  8110                                  ; 19/03/2018 - Retro DOS v2.0
  8111                                  
  8112                                  ENDATROM:
  8113                                  
  8114                                  ;CMOS Clock setting support routines used by MSCLOCK.		
  8115                                  ;Warning!!! This code will be dynamically relocated by MSINIT.
  8116                                  
  8117                                  Daycnt_To_Day:
  8118                                  ;Entry: [DAYCNT] = number of days since 1-1-80
  8119                                  ;Return: CH=centry in BCD, CL=year in BCD, DH=month in BCD, DL=day in BCD
  8120                                  									 
  8121 0000278E 2EFF36[DA05]            		push	word [cs:DAYCNT]	;save daycnt			 
  8122 00002793 2E813E[DA05]891C        		cmp	word [cs:DAYCNT], (365*20+(20/4)) 
  8123                                  						;# days from 1-1-1980 to 1-1-2000
  8124 0000279A 730E                    		jae	short century20						 
  8125 0000279C 2EC606[A508]13          		mov	byte [cs:base_century], 19					 
  8126 000027A2 2EC606[A608]50          		mov	byte [cs:base_year], 80						 
  8127 000027A8 EB13                    		jmp	short years							 
  8128                                  century20:				;20th century			 
  8129 000027AA 2EC606[A508]14          		mov	byte [cs:base_century], 20					 
  8130 000027B0 2EC606[A608]00          		mov	byte [cs:base_year], 0						 
  8131 000027B6 2E812E[DA05]891C        		sub	word [cs:DAYCNT], (365*20+(20/4)) ;adjust daycnt			 
  8132                                  years:									 
  8133 000027BD 31D2                    		xor	dx, dx							 
  8134 000027BF 2EA1[DA05]              		mov	ax, [cs:DAYCNT]						 
  8135 000027C3 BBB505                  		mov	bx, (366+365*3) 	;# of days in a Leap year block  
  8136 000027C6 F7F3                    		div	bx			;AX = # of leap block, DX=daycnt 
  8137 000027C8 2E8916[DA05]            		mov	[cs:DAYCNT], dx		;save daycnt left		 
  8138                                  ;	or	ah, ah				;ax should be less than 256	 
  8139                                  ;	jz	short OK1							 
  8140                                  ;	jmp	Erroroccur						 
  8141                                  ;OK1:									 
  8142 000027CD B304                    		mov	bl, 4							 
  8143 000027CF F6E3                    		mul	bl			;AX=# of years. Less than 100	 
  8144 000027D1 2E0006[A608]            		add	[cs:base_year], al	;So, ah = 0. Adjust year	 
  8145 000027D6 2EFF06[DA05]            		inc	word [cs:DAYCNT]	;set daycnt to 1 base		 
  8146 000027DB 2E813E[DA05]6E01        		cmp	word [cs:DAYCNT], 366	;daycnt=remainder of leap year bk
  8147 000027E2 7626                    		jbe	short Leapyear		;within 366+355+355+355 days.	 
  8148 000027E4 2EFE06[A608]            		inc	byte [cs:base_year]	;if daycnt <= 366, then leap year
  8149 000027E9 2E812E[DA05]6E01        		sub	word [cs:DAYCNT], 366	;else daycnt--, base_year++;	 
  8150                                  					;And next three years are normal 
  8151 000027F0 B90300                  		mov	cx, 3							 
  8152                                  Regularyear:								 
  8153 000027F3 2E813E[DA05]6D01        		cmp	word [cs:DAYCNT], 365	;for(i=1; i>3 or daycnt <=365;i++)
  8154 000027FA 7614                    		jbe	short Yeardone		;{if (daycnt > 365)		
  8155 000027FC 2EFE06[A608]            		inc	byte [cs:base_year]	;  { daycnt -= 365		
  8156 00002801 2E812E[DA05]6D01        		sub	word [cs:DAYCNT], 365	;  }				
  8157 00002808 E2E9                    		loop	Regularyear		;}				
  8158                                  ;	jmp	Erroroccur		 ;cannot come to here		
  8159                                  Leapyear:								
  8160 0000280A 2EC606[A808]1D          		mov	byte [cs:month_tab+1],29 ;leap year. change month table. 
  8161                                  Yeardone:								
  8162 00002810 31DB                    		xor	bx, bx							
  8163 00002812 31D2                    		xor	dx, dx							
  8164 00002814 2EA1[DA05]              		mov	ax, [cs:DAYCNT]						
  8165 00002818 BE[A708]                		mov	si, month_tab					
  8166 0000281B B90C00                  		mov	cx, 12							
  8167                                  Months: 								
  8168 0000281E FEC3                    		inc	bl			;				
  8169                                  		;mov	dl, [si] ; 28/03/2018
  8170 00002820 2E8A14                  		mov	dl, [cs:si]		;cmp daycnt for each month til fit
  8171 00002823 39D0                    		cmp	ax, dx			;dh=0.				 
  8172 00002825 7605                    		jbe	short Month_done						 
  8173 00002827 46                      		inc	si			;next month			 
  8174 00002828 29D0                    		sub	ax, dx			;adjust daycnt			 
  8175 0000282A E2F2                    		loop	Months							 
  8176                                  ;	jmp	Erroroccur						 
  8177                                  Month_done:								 
  8178 0000282C 2EC606[A808]1C          		mov	byte [cs:month_tab+1], 28 ;restore month table value	 
  8179 00002832 88DA                    		mov	dl, bl							 
  8180 00002834 2E8A36[A608]            		mov	dh, [cs:base_year]						 
  8181 00002839 2E8A0E[A508]            		mov	cl, [cs:base_century]	;al=day,dl=month,dh=year,cl=cntry
  8182 0000283E 2EFF16[B308]            		call	word [cs:BinToBCD]	;To save 15 bytes, Bin_To_BCD proc
  8183                                  						;was rel from Daycnt_to_Day proc. 
  8184                                  ;	call Bin_To_BCD 			;convert "day" to bcd             
  8185 00002843 86D0                    		xchg	dl, al			;dl = bcd day, al = month	  
  8186 00002845 2EFF16[B308]            		call	word [cs:BinToBCD]					  
  8187                                  ;	call Bin_To_BCD 						  
  8188 0000284A 86F0                    		xchg	dh, al			;dh = bcd month, al = year	  
  8189 0000284C 2EFF16[B308]            		call	word [cs:BinToBCD]					  
  8190                                  ;	call Bin_To_BCD 						  
  8191 00002851 86C8                    		xchg	cl, al			;cl = bcd year, al = century	 
  8192 00002853 2EFF16[B308]            		call	word [cs:BinToBCD]					 
  8193                                  ;	call Bin_To_BCD						 
  8194 00002858 88C5                    		mov	ch, al			;ch = bcd century		 
  8195 0000285A 2E8F06[DA05]            		pop	word [cs:DAYCNT]	;restore original value 	 
  8196 0000285F C3                      		retn								 
  8197                                  						 
  8198                                  	;public	EndDaycntToDay						 
  8199                                  EndDaycntToDay:						 
  8200                                  									 
  8201                                  	;public	Bin_To_BCD						 
  8202                                  Bin_To_BCD:			; real time clock sup
  8203                                  ;Convert a binary input in AL (less than 63h or 99 decimal)
  8204                                  ;into a bcd value in AL.  AH destroyed. 			
  8205 00002860 51                      		push	cx						
  8206 00002861 30E4                    		xor	ah, ah						
  8207 00002863 B10A                    		mov	cl, 10						
  8208 00002865 F6F1                    		div	cl			;al=high digit bcd, ah=low digit bcd
  8209 00002867 B104                    		mov	cl, 4						
  8210 00002869 D2E0                    		shl	al, cl			;mov the high digit to high nibble
  8211 0000286B 08E0                    		or	al, ah							
  8212 0000286D 59                      		pop	cx							
  8213 0000286E C3                      		retn								
  8214                                  					
  8215                                  	;Public	EndCMOSClockset 	;End of routines for CMOS clock 
  8216                                  EndCMOSClockSet:
  8217                                  
  8218                                  		;evenb
  8219 0000286F 90                      align 2
  8220                                  
  8221                                  ; 02/06/2018 - Retro DOS v3.0
  8222                                  
  8223                                  ;									
  8224                                  ; THE K09 REQUIRES ROUTINES FOR READING THE CLOCK BECAUSE OF THE SUSPEND/
  8225                                  ; RESUME FACILITY. THE SYSTEM CLOCK NEEDS TO BE RESET AFTER RESUME.	 
  8226                                  ;
  8227                                  
  8228                                  ;	ASSUME	ES:NOTHING									 
  8229                                  									 
  8230                                  ; THE FOLLOWING ROUTINE IS EXECUTED AT RESUME TIME WHEN THE SYSTEM	 
  8231                                  ; POWERED ON AFTER SUSPENSION. IT READS THE REAL TIME CLOCK AND 	 
  8232                                  ; RESETS THE SYSTEM TIME AND DATE, AND THEN IRETS.			 
  8233                                  ; Warning!!! This code will be dynamically relocated by MSINIT.
  8234                                  
  8235                                  ;INT6C	PROC	FAR							 
  8236                                  
  8237                                  INT6C:
  8238 00002870 0E                      		PUSH	CS							 
  8239 00002871 1F                      		POP	DS							 
  8240                                  									 
  8241                                  	;ASSUME DS:CODE							 
  8242                                  									 
  8243 00002872 8F06[911B]              		POP	WORD [INT6C_RET_ADDR] ; POP OFF RETURN ADDRESS	 
  8244 00002876 8F06[931B]              		POP	WORD [INT6C_RET_ADDR+2]				 
  8245 0000287A 9D                      		POPF								 
  8246 0000287B E81300                  		CALL	READ_REAL_DATE		; GET THE DATE FROM THE CLOCK	 
  8247 0000287E FA                      		CLI								 
  8248 0000287F 8936[DA05]              		MOV	[DAYCNT],SI		; UPDATE DOS COPY OF DATE 	 
  8249 00002883 FB                      		STI								 
  8250 00002884 E8C000                  		CALL	READ_REAL_TIME		; GET THE TIME FROM THE RTC	 
  8251 00002887 FA                      		CLI								 
  8252 00002888 B401                    		MOV	AH,01h			; COMMAND TO SET THE TIME
  8253 0000288A CD1A                    		INT	1Ah			; CALL ROM-BIOS TIME ROUTINE 
  8254 0000288C FB                      		STI								
  8255 0000288D FF2E[911B]              		JMP	far [INT6C_RET_ADDR]	; LONG JUMP			
  8256                                  									
  8257                                  ;INT6C	ENDP
  8258                                  
  8259                                  	;INCLUDE READCLOCK.INC						
  8260                                  	;INCLUDE CLOCKSUB.INC								
  8261                                  
  8262                                  ; 26/03/2018 - READCLOCK.INC, MSDOS 3.3, 24/07/1987
  8263                                  
  8264                                  ;************************************************************************
  8265                                  ;
  8266                                  ;   read_real_date reads real-time clock for date and returns the number
  8267                                  ;   of days elapsed since 1-1-80 in si
  8268                                  ;
  8269                                  READ_REAL_DATE: 			;MJB002
  8270 00002891 50                      		PUSH	AX
  8271 00002892 51                      		PUSH	CX
  8272 00002893 52                      		PUSH	DX
  8273 00002894 30E4                    		XOR	AH,AH		; throw away clock roll over
  8274 00002896 CD1A                    		INT	1AH					
  8275 00002898 5A                      		POP	DX
  8276 00002899 59                      		POP	CX
  8277 0000289A 58                      		POP	AX
  8278                                  
  8279 0000289B 50                      		PUSH	AX
  8280 0000289C 53                      		PUSH	BX
  8281 0000289D 51                      		PUSH	CX
  8282 0000289E 52                      		PUSH	DX
  8283                                  		;mov	word [CS:DAYCNT2],1 ; REAL TIME CLOCK ERROR FLAG (+1 DAY)
  8284 0000289F C706[B11B]0100          		mov	word [DAYCNT2],1
  8285 000028A5 B404                    		mov	AH,4		; read date function code       
  8286 000028A7 CD1A                    		int	1Ah		; read real-time clock	     
  8287                                  		;jnc	short read_ok 	; jmp success
  8288                                  		;jmp	r_d_ret 	; jmp error
  8289 000028A9 0F828B00                		jc	r_d_ret
  8290                                  read_ok:				; ******* get bcd values in binary *****
  8291 000028AD 882E[951B]              		mov	[BIN_DATE_TIME+0],ch  ; store as hex value
  8292 000028B1 880E[961B]              		mov	[BIN_DATE_TIME+1],cl  ; ...
  8293 000028B5 8836[971B]              		mov	[BIN_DATE_TIME+2],dh  ; ...
  8294 000028B9 8816[981B]              		mov	[BIN_DATE_TIME+3],dl  ; ...
  8295                                  		;mov	word [CS:DAYCNT2],2  ; READ OF R-T CLOCK SUCCESSFUL
  8296 000028BD C706[B11B]0200          		mov	word [DAYCNT2],2
  8297 000028C3 E84C01                  		call	bcd_verify	; verify bcd values in range
  8298 000028C6 7270                    		jc	short r_d_ret 	; jmp some value out of range
  8299                                  		;mov	word [CS:DAYCNT2],3  ; READ OF R-T CLOCK SUCCESSFUL
  8300 000028C8 C706[B11B]0300          		mov	word [DAYCNT2],3
  8301 000028CE E8EA00                  		call	date_verify	; verify date values in range
  8302 000028D1 7265                    		jc	short r_d_ret 	; jmp some value out of range
  8303                                  		;mov	word [CS:DAYCNT2],0  ; VERIFY SUCCESSFUL		  
  8304 000028D3 C706[B11B]0000          		mov	word [DAYCNT2],0
  8305 000028D9 E8A400                  		call	in_bin		; convert date to binary
  8306                                  					; ******* years since 1-1-80 *********
  8307 000028DC A0[961B]                		mov	al,[BIN_DATE_TIME+1]  ; get years into century
  8308 000028DF 98                      		cbw				     ;
  8309 000028E0 803E[951B]14            		cmp	byte [BIN_DATE_TIME+0],20  ; 20th century?
  8310 000028E5 7503                    		jnz	short century_19 ; jmp no
  8311 000028E7 83C064                  		add	ax,100		; add in a century
  8312                                  century_19:			;
  8313 000028EA 83E850                  		sub	ax,80		; subtract off 1-1-80
  8314 000028ED B104                    		mov	cl,4		; leap year every 4
  8315 000028EF F6F1                    		div	cl		; al= # leap year blocks, ah= remainder
  8316 000028F1 88E3                    		mov	bl,ah		; save odd years
  8317 000028F3 98                      		cbw			; zero ah
  8318 000028F4 B9B505                  		mov	cx,366+3*365	; # of days in leap year blocks
  8319 000028F7 F7E1                    		mul	cx		; dx:ax is result
  8320                                  		;mov	[CS:DAYCNT2],AX	; SAVE COUNT OF DAYS
  8321 000028F9 A3[B11B]                		mov	[DAYCNT2],AX
  8322 000028FC 88D8                    		mov	al,bl		; get odd years count
  8323 000028FE 98                      		cbw			;
  8324 000028FF 09C0                    		or	ax,ax		; is ax= 0?
  8325 00002901 740B                    		jz	short leap_year	; jmp if none
  8326 00002903 B96D01                  		mov	cx,365		; days in year
  8327 00002906 F7E1                    		mul	cx		; dx:ax is result
  8328                                  		;add	[CS:DAYCNT2],AX ; ADD ON DAYS IN ODD YEARS
  8329 00002908 0106[B11B]              		add	[DAYCNT2],AX
  8330 0000290C EB07                    		jmp	short leap_adjustment ; account for leap year
  8331                                  leap_year:			; possibly account for a leap day
  8332 0000290E 803E[971B]02            		cmp	byte [BIN_DATE_TIME+2],2 ; is month february
  8333 00002913 7604                    		jbe	short no_leap_adjustment ; jan or feb. no leap day yet.
  8334                                  leap_adjustment:			; account for leap day
  8335                                  		;INC	word [CS:DAYCNT2] ; ...
  8336 00002915 FF06[B11B]              		INC	word [DAYCNT2]
  8337                                  no_leap_adjustment:			; ******* get days of month *******
  8338 00002919 8A0E[981B]              		mov	cl,[BIN_DATE_TIME+3] ; ...
  8339 0000291D 30ED                    		xor	ch,ch		;
  8340 0000291F 49                      		dec	cx		; because of offset from day 1, not day 0
  8341                                  		;add	[CS:DAYCNT2],CX	; ******* GET DAYS IN MONTHS PRECEEDING *****
  8342 00002920 010E[B11B]              		add	[DAYCNT2],CX
  8343 00002924 8A0E[971B]              		mov	cl,[BIN_DATE_TIME+2] ; get month
  8344 00002928 30ED                    		xor	ch,ch		;
  8345 0000292A 49                      		dec	cx		; january starts at offset 0
  8346 0000292B D1E1                    		shl	cx,1		; word offset
  8347 0000292D BE[991B]                		mov	si,MONTH_TABLE	; beginning of month_table
  8348 00002930 01CE                    		add	si,cx		; point into month table
  8349 00002932 8B04                    		mov	ax,[si]		; get # days in previous months
  8350                                  		;add	[CS:DAYCNT2],AX ; ...
  8351 00002934 0106[B11B]              		add	[DAYCNT2],AX
  8352                                  r_d_ret:			;
  8353                                  		;MOV	SI,[CS:DAYCNT2] ; RESULT IN SI
  8354 00002938 8B36[B11B]              		MOV	SI,[DAYCNT2]
  8355 0000293C 5A                      		POP	DX
  8356 0000293D 59                      		POP	CX
  8357 0000293E 5B                      		POP	BX
  8358 0000293F 58                      		POP	AX
  8359 00002940 C3                      		retn			;
  8360                                  
  8361                                  r_t_retj:
  8362 00002941 31C9                    		xor	cx,cx
  8363 00002943 31D2                    		xor	dx,dx
  8364 00002945 EB38                    		jmp	short r_t_ret
  8365                                  ;
  8366                                  ; Read_Real_Time reads the time from the RTC. on exit, it has the number of
  8367                                  ; ticks (at 18.2 ticks per sec.) in CX:DX.
  8368                                  ;
  8369                                  READ_REAL_TIME:
  8370 00002947 B402                    		mov	ah,2
  8371 00002949 CD1A                    		int	1AH
  8372 0000294B 72F4                    		jc	short r_t_retj
  8373                                  oktime:
  8374 0000294D 882E[951B]              		mov	[BIN_DATE_TIME],ch		; hours
  8375 00002951 880E[961B]              		mov	[BIN_DATE_TIME+1],cl		; minutes
  8376 00002955 8836[971B]              		mov	[BIN_DATE_TIME+2],dh		; seconds
  8377 00002959 C606[981B]00            		mov	byte [BIN_DATE_TIME+3],0	; unused for time
  8378 0000295E E8B100                  		call	bcd_verify
  8379 00002961 72DE                    		jc	short r_t_retj
  8380 00002963 E89300                  		call	time_verify
  8381 00002966 72D9                    		jc	short r_t_retj
  8382 00002968 E81500                  		call	in_bin
  8383 0000296B 8A2E[951B]              		mov	ch,[BIN_DATE_TIME]
  8384 0000296F 8A0E[961B]              		mov	cl,[BIN_DATE_TIME+1]
  8385 00002973 8A36[971B]              		mov	dh,[BIN_DATE_TIME+2]
  8386 00002977 8A16[981B]              		mov	dl,[BIN_DATE_TIME+3]
  8387                                  ; get time in ticks in CX:DX
  8388                                  		;CALL	near [cs:TimeToTicks]
  8389 0000297B FF16[B708]              		CALL	word [TimeToTicks]
  8390                                  r_t_ret:
  8391 0000297F C3                      		retn
  8392                                  
  8393                                  ;
  8394                                  ;   in_bin converts bin_date_time values from bcd to bin
  8395                                  ;
  8396                                  in_bin: 			      ;
  8397 00002980 A0[951B]                		mov	al,[BIN_DATE_TIME+0]  ; century or hours
  8398 00002983 E81F00                  		call	bcd_to_bin	      ; ...
  8399 00002986 A2[951B]                		mov	[BIN_DATE_TIME+0],al  ;
  8400 00002989 A0[961B]                		mov	al,[BIN_DATE_TIME+1]  ; years or minutes
  8401 0000298C E81600                  		call	bcd_to_bin	      ; ...
  8402 0000298F A2[961B]                		mov	[BIN_DATE_TIME+1],al  ;
  8403 00002992 A0[971B]                		mov	al,[BIN_DATE_TIME+2]  ; months or seconds
  8404 00002995 E80D00                  		call	bcd_to_bin	      ; ...
  8405 00002998 A2[971B]                		mov	[BIN_DATE_TIME+2],al  ;
  8406 0000299B A0[981B]                		mov	al,[BIN_DATE_TIME+3]  ; days (not used for time)
  8407 0000299E E80400                  		call	bcd_to_bin	      ; ...
  8408 000029A1 A2[981B]                		mov	[BIN_DATE_TIME+3],al  ;
  8409 000029A4 C3                      		retn			      ;
  8410                                  ;
  8411                                  ;   bcd_to_bin converts two bcd nibbles in al (value <= 99.) to
  8412                                  ;   a binary representation in al
  8413                                  ;   ah is destroyed
  8414                                  ;
  8415                                  bcd_to_bin:				;
  8416 000029A5 88C4                    		mov	ah,al		; copy bcd number to ah
  8417 000029A7 250FF0                  		and	ax,0F00Fh	; clear unwanted nibbles
  8418 000029AA 88C3                    		mov	bl,al		; save units place
  8419 000029AC 86E0                    		xchg	ah,al		; 10's place to al
  8420 000029AE 30E4                    		xor	ah,ah		; ah not wanted
  8421 000029B0 B104                    		mov	cl,4		; shift count
  8422 000029B2 D3E8                    		shr	ax,cl		;mjb004 swap nibbles
  8423 000029B4 B10A                    		mov	cl,10		; convert al to ...
  8424 000029B6 F6E1                    		mul	cl		; ... its binary value
  8425 000029B8 00D8                    		add	al,bl		; add in units
  8426 000029BA C3                      		retn
  8427                                  
  8428                                  ; 26/03/2018 - CLOCKSUB.INC, MSDOS 3.3, 24/07/1987					
  8429                                  
  8430                                  ;
  8431                                  ;   date_verify loosely checks bcd date values to be in range in bin_date_time
  8432                                  ;
  8433                                  date_verify:				    	    ;
  8434 000029BB 803E[951B]20            		cmp	byte [BIN_DATE_TIME+0],20h  ; century check
  8435 000029C0 7735                    		ja	short date_error	    ; jmp error
  8436 000029C2 740E                    		jz	short century_20	    ; jmp in 20th century
  8437 000029C4 803E[951B]19            		cmp	byte [BIN_DATE_TIME+0],19h  ; century check
  8438 000029C9 722C                    		jb	short date_error	    ; jmp error
  8439 000029CB 803E[961B]80            		cmp	byte [BIN_DATE_TIME+1],80h  ; year check
  8440 000029D0 7225                    		jb	short date_error	    ; jmp error
  8441                                  century_20:				    	    ;
  8442 000029D2 803E[961B]99            		cmp	byte [BIN_DATE_TIME+1],99h  ; year check
  8443 000029D7 771E                    		ja	short date_error	    ; jmp error
  8444 000029D9 803E[971B]12            		cmp	byte [BIN_DATE_TIME+2],12h  ; month check
  8445 000029DE 7717                    		ja	short date_error	    ; jmp error
  8446 000029E0 803E[971B]00            		cmp	byte [BIN_DATE_TIME+2],00h  ; month check
  8447 000029E5 7610                    		jbe	short date_error	    ; jmp error
  8448 000029E7 803E[981B]31            		cmp	byte [BIN_DATE_TIME+3],31h  ; day check
  8449 000029EC 7709                    		ja	short date_error	    ; jmp error
  8450 000029EE 803E[981B]00            		cmp	byte [BIN_DATE_TIME+3],00h  ; day check
  8451 000029F3 7602                    		jbe	short date_error	    ; jmp error
  8452 000029F5 F8                      		clc				    ; set success flag
  8453 000029F6 C3                      		ret				    ;
  8454                                  date_error:				   	    ;
  8455 000029F7 F9                      		stc				    ; set error flag
  8456 000029F8 C3                      		retn				    ;
  8457                                  
  8458                                  ;
  8459                                  ; time_verify very loosely checks bcd date values to be in range in bin_date_time
  8460                                  ;
  8461                                  time_verify:
  8462 000029F9 803E[951B]24            		cmp	byte [BIN_DATE_TIME+0],24h
  8463 000029FE 7710                    		ja	short time_error
  8464 00002A00 803E[961B]59            		cmp	byte [BIN_DATE_TIME+1],59h
  8465 00002A05 7709                    		ja	short time_error
  8466 00002A07 803E[971B]59            		cmp	byte [BIN_DATE_TIME+2],59h
  8467 00002A0C 7702                    		ja	short time_error
  8468 00002A0E F8                      		clc
  8469 00002A0F C3                      		retn
  8470                                  time_error:
  8471 00002A10 F9                      		stc
  8472 00002A11 C3                      		retn
  8473                                  
  8474                                  ;
  8475                                  ;   bcd_verify checks values in bin_date_time to be valid
  8476                                  ;   bcd numerals.  carry set if any nibble out of range
  8477                                  ;
  8478                                  bcd_verify:				  ;
  8479 00002A12 B90400                  		mov	cx,4		  ; 4 bytes to check
  8480 00002A15 BB[951B]                		mov	bx,BIN_DATE_TIME  ;
  8481                                  bv_loop:				  ;
  8482 00002A18 8A07                    		mov	al,[bx]		  ; get a bcd number (0..99)
  8483 00002A1A 88C4                    		mov	ah,al		  ;
  8484 00002A1C 250FF0                  		and	ax,0F00Fh	  ; 10's place in high ah, 1's in al
  8485 00002A1F 3C0A                    		cmp	al,10		  ; is 1's place in range?
  8486 00002A21 7716                    		ja	short bv_error	  ; jmp out of range
  8487 00002A23 D0EC                    		shr	ah,1		  ; swap nibbles
  8488 00002A25 D0EC                    		shr	ah,1		  ; ...
  8489 00002A27 D0EC                    		shr	ah,1		  ; ...
  8490 00002A29 D0EC                    		shr	ah,1		  ; ...
  8491 00002A2B 80E40F                  		and	ah,0fh		  ; get rid of any erroneous bits
  8492 00002A2E 80FC0A                  		cmp	ah,10		  ; is 10's place in range
  8493 00002A31 7706                    		ja	short bv_error	  ; jmp out of range
  8494 00002A33 43                      		inc	bx		  ; next byte
  8495 00002A34 49                      		dec	cx		  ;
  8496 00002A35 75E1                    		jnz	short bv_loop 	  ;
  8497 00002A37 F8                      		clc			  ; set success flag
  8498 00002A38 C3                      		retn			  ;
  8499                                  bv_error:				  ;
  8500 00002A39 F9                      		stc			  ; set error flag
  8501 00002A3A C3                      		retn			  ;
  8502                                  
  8503                                  ; 02/06/2018 - Retro DOS v3.0
  8504                                  
  8505                                  ENDK09:
  8506                                  
  8507                                  ;------------------------------------------------------------------------
  8508                                  ;									:
  8509                                  ;	System initialization						:
  8510                                  ;									:
  8511                                  ;	The entry conditions are established by the bootstrap		:
  8512                                  ;	loader and are considered unknown.  The following jobs		:
  8513                                  ;	will be performed by this module:				:
  8514                                  ;									:
  8515                                  ;	1.	All device initialization is performed			:
  8516                                  ;	2.	A local stack is set up and DS:SI are set		:
  8517                                  ;		to point to an initialization table. Then		:
  8518                                  ;		an inter-segment call is made to the first		:
  8519                                  ;		byte of the dos 					:
  8520                                  ;	3.	Once the dos returns from this call the ds		:
  8521                                  ;		register has been set up to point to the start		:
  8522                                  ;		of free memory. The initialization will then		:
  8523                                  ;		load the command program into this area 		:
  8524                                  ;		beginning at 100 hex and transfer control to		:
  8525                                  ;		this program.						:
  8526                                  ;									:
  8527                                  ;------------------------------------------------------------------------
  8528                                  
  8529                                  ; DRVFAT must be the first location of freeable space!
  8530                                  	;EVENB
  8531                                  
  8532 00002A3B 90                      align 2
  8533                                  
  8534 00002A3C 0000                    DRVFAT:	DW	0			; Drive and FAT ID of DOS
  8535                                  ; 03/07/2018
  8536                                  ;BIOS$:	DW	0			; First sector of data
  8537                                  ;DOSCNT:DW	0			; How many sectors to read
  8538 00002A3E 00                      fBigFAT: DB	0			; Flags for drive
  8539                                  ; 01/07/2018
  8540                                  ;FatLen:	DW	0		; number of sectors in FAT.
  8541                                  ;FatLoc:	DW	0		; seg addr of fat sector
  8542                                  
  8543                                  ;;Rev 3.30 Modification -----------------------------------------------
  8544                                  ; THE FOLLOWING TWO BYTES ARE USED TO SAVE INFO RETURNED BY INT 13, AH=8
  8545                                  ; CALL TO DETERMINE DRIVE PARAMETERS.					
  8546 00002A3F 02                      NUM_HEADS: DB	2			; NUMBER OF HEADS RETURNED BY ROM
  8547 00002A40 09                      SEC_TRK:   DB	9			; SEC/TRK RETURNED BY ROM	 
  8548 00002A41 28                      NUM_CYLN:  DB	40			; NUMBER OF CYLINDERS RET BY ROM 
  8549                                  									 
  8550 00002A42 FF                      MODEL_BYTE: DB	0FFH			; MODEL BYTE. SET UP AT INIT TIME.
  8551                                  					; FF - PC-1, EXPANSION, OLD PC-2 
  8552                                  					; FE - NEWER PC-2 (64/256K PLANAR)
  8553                                  					; FD - 
  8554                                  					; FC - 
  8555 00002A43 00                      Secondary_Model_Byte: DB 0						 
  8556                                  ;;End of Modification -----------------------------------------------
  8557                                  
  8558                                  ;BOOTBIAS equ	200H							 
  8559                                  
  8560                                  	;EVENB
  8561                                  align 2
  8562                                  					 
  8563 00002A44 0002000140000000        DiskTable:  DW	512,	0100h,	64,	0
  8564 00002A4C 0008010270000000        	    DW	2048,	0201h,	112,	0
  8565 00002A54 0020020400010000        	    DW	8192,	0402h,	256,	0
  8566 00002A5C A87F030800020000        	    DW	32680,	0803h,	512,	0
  8567 00002A64 FFFF041000040000        	    DW	65535,	1004h,	1024,	0
  8568                                  
  8569 00002A6C A87F030800020000        DiskTable2: DW	32680,	0803h,	512,	0
  8570 00002A74 FFFF020400024000        	    DW	65535,	0402h,	512,	fBIG
  8571                                  
  8572                                  ;;Rev 3.30 Modification -----------------------------------------------
  8573                                  
  8574                                  ;*************************************************************************
  8575                                  ;Variables for Mini disk initialization
  8576                                  ;*************************************************************************
  8577 00002A7C 0000                    End_Of_BDSM:	dw	0		;offset value of the ending add
  8578                                  					;of BDSM table. Needed to figure
  8579                                  					;the Final_DOS_Location.
  8580 00002A7E 00                      numh:		db	0		;number of hard files
  8581 00002A7F 00                      mininum: 	db	0		;logical drive num for mini disk 
  8582 00002A80 00                      num_mini_dsk:	db	0		;# of mini disk installed	 
  8583 00002A81 80                      Rom_Minidsk_num: db	80h		;physical mini disk number	 
  8584 00002A82 0000                    Mini_HDLIM:	dw	0						 
  8585 00002A84 0000                    Mini_SECLIM:	dw	0						 
  8586 00002A86 0000                    Mini_BPB_ptr:	dw	0		;temporary variable used to save 
  8587                                  					;Mini Disk BPB pt add in DskDrvs.
  8588                                  ;;End of Modification -----------------------------------------------
  8589                                  
  8590 00002A88 30312F31302F383400      Bios_Date:   DB	'01/10/84',0
  8591                                  
  8592                                  ; 02/06/2018 - Retro DOS v3.0
  8593                                  
  8594                                  PatchTable:
  8595 00002A91 0A00[E909]              		DW	10,Media_Patch
  8596 00002A95 0300[B20A]              		DW	3,GETBP1_PATCH
  8597 00002A99 0300[760A]              		DW	3,SET_PATCH
  8598 00002A9D 0300[410D]              		DW	3,DiskIO_PATCH
  8599 00002AA1 0300[C50E]              		DW	3,DSKERR
  8600 00002AA5 0A00[790F]              		DW	10,Changed_Patch
  8601 00002AA9 0300[150A]              		DW	3,INIT_PATCH
  8602 00002AAD 0000                    		DW	0
  8603                                  
  8604                                  ;-----------------------------------------------------------------------------
  8605                                  
  8606                                  ; 28/03/2018
  8607                                  ; MSDOS 6.0 - MSINIT.ASM, 1991
  8608 00002AAF 0000                    init_bootseg:	dw	0	; seg addr of buffer for reading boot record
  8609                                  
  8610                                  BootBias equ 200h ; 19/03/2018
  8611                                  
  8612                                  ;-----------------------------------------------------------------------------
  8613                                  
  8614 00002AB1 90<rep Fh>              align 16
  8615                                  
  8616                                  ;-----------------------------------------------------------------------------
  8617                                  ; entry point from boot sector
  8618                                  ;-----------------------------------------------------------------------------
  8619                                  ; 02/06/2018 - Retro DOS v3.0
  8620                                  
  8621                                  ;-----------------------------------------------------------------------------
  8622                                  
  8623                                  ; ----------------------------------------------------------------------------
  8624                                  ; SYSINIT PARAMETER ADDRESS EQUALITIES - 25/02/2018 (MSDOS 2.0 'SYSINIT.ASM')
  8625                                  ; ----------------------------------------------------------------------------
  8626                                  ; ('sysinit.s', 'SYSINIT.BIN')
  8627                                  
  8628                                  ; IN SYSINIT SEGMENT (SYSINITSEG):
  8629                                  
  8630                                  CURRENT_DOS_LOCATION EQU 6   ; dw (segment)
  8631                                  FINAL_DOS_LOCATION   EQU 10  ; dw (segment)
  8632                                  DEVICE_LIST	     EQU 12  ; dd (segment:offset)	
  8633                                  DOSSIZE		     EQU 16  ; dw ; Retro DOS 2.0 - 'MSDOS.BIN' size in words
  8634                                  ; 04/06/2018 - Retro DOS v3.0 (MSDOS 3.3)
  8635                                  ;MEMORY_SIZE	     EQU 18  ; dw (paragraphs)	
  8636                                  ;DEFAULT_DRIVE	     EQU 20  ; db
  8637                                  SYSI_COUNTRY	     EQU 18  ; dd (segment:offset) - country table pointer	
  8638                                  STACK_COUNT	     EQU 22  ; dw 	
  8639                                  STACK_SIZE	     EQU 24  ; dw
  8640                                  STACK_ADDR	     EQU 26  ; dd (segment:offset)  
  8641                                  MEMORY_SIZE	     EQU 30  ; dw (paragraphs)
  8642                                  DEFAULT_DRIVE	     EQU 32  ; db 	 						
  8643                                  
  8644                                  ;-----------------------------------------------------------------------------
  8645                                  ; initialization - stage 1
  8646                                  ;-----------------------------------------------------------------------------
  8647                                  ; 02/06/2018 - Retro DOS v3.0
  8648                                  
  8649                                  		; Retro DOS 3.0 Modification on MSDOS 3.3 IBMBIO.COM code
  8650                                  		; (Because of Retro DOS 2.0, MSDOS 3.3 boot sector difference)
  8651                                  
  8652                                  INIT:
  8653                                  		; 07/04/2018
  8654                                  		; Retro DOS v2.0 - registers from FD Boot Sector 
  8655                                                  ; DL = [bsDriveNumber]
  8656                                  		; DH = [bsMedia]
  8657                                  		; AX = [bsSectors] ; Total sectors
  8658                                  		; DS = 0, SS = 0
  8659                                  		; BP = 7C00h
  8660                                  
  8661                                  		; Move Retro DOS v2.0 boot sector parameters to 0060h:0
  8662 00002AC0 BB6000                  		mov	bx, 60h
  8663 00002AC3 8EC3                    		mov	es, bx
  8664 00002AC5 89EE                    		mov	si, bp
  8665 00002AC7 29FF                    		sub	di, di
  8666 00002AC9 B92300                  		mov	cx, 35 ; 70 bytes, 35 words
  8667                                  		;mov	cl, 35
  8668 00002ACC F3A5                    		rep	movsw
  8669                                  
  8670 00002ACE 0E                      		push	cs
  8671 00002ACF 1F                      		pop	ds
  8672                                  
  8673                                  		; 27/03/2018
  8674 00002AD0 B99064                  		mov	cx, KERNEL_SIZE	; words !
  8675                                  		; 07/04/2018
  8676                                  		;mov	bx, KERNEL_SEGMENT ; 0070h
  8677 00002AD3 B370                    		mov	bl, KERNEL_SEGMENT
  8678 00002AD5 8EC3                    		mov	es, bx
  8679 00002AD7 31FF                    		xor	di, di
  8680 00002AD9 89FE                    		mov	si, di
  8681                                  		
  8682                                  		; Move KERNEL file from 1000h:0 to 0070h:0
  8683                                  		; (Retro DOS v2 BS loads 'MSDOS.SYS' at 1000h:0000h)
  8684 00002ADB F3A5                    		rep	movsw
  8685                                  		; 17/06/2018 
  8686                                  		;mov	ds, bx
  8687                                  INIT0:
  8688 00002ADD 06                      		push	es
  8689 00002ADE 68[E22A]                		push	INIT1 ; 07/04/2018
  8690 00002AE1 CB                      		retf	; jump to 0070h:INIT1
  8691                                  
  8692                                  ;INIT:
  8693                                  INIT1:
  8694                                  ; 02/06/2018 - Retro DOS v3.0
  8695                                  
  8696                                  		; 19/03/2018
  8697                                  		; Retro DOS v2.0 (24/02/2018)
  8698                                  		; [REF: MSDOS 3.3, MSBIO, "MSINIT.ASM"  (24/07/1987)]
  8699                                  
  8700                                  ;------------------------------------------------------------------------
  8701                                  ;									:
  8702                                  ;	System initialization						:
  8703                                  ;									:
  8704                                  ;	The entry conditions are established by the bootstrap		:
  8705                                  ;	loader and are considered unknown.  The following jobs		:
  8706                                  ;	will be performed by this module:				:
  8707                                  ;									:
  8708                                  ;	1.	All device initialization is performed			:
  8709                                  ;	2.	A local stack is set up and DS:SI are set		:
  8710                                  ;		to point to an initialization table. Then		:
  8711                                  ;		an inter-segment call is made to the first		:
  8712                                  ;		byte of the dos 					:
  8713                                  ;	3.	Once the dos returns from this call the ds		:
  8714                                  ;		register has been set up to point to the start		:
  8715                                  ;		of free memory. The initialization will then		:
  8716                                  ;		load the command program into this area 		:
  8717                                  ;		beginning at 100 hex and transfer control to		:
  8718                                  ;		this program.						:
  8719                                  ;									:
  8720                                  ;------------------------------------------------------------------------
  8721                                  
  8722                                  		; MSDOS 3.3 - "MSEQU.INC" (24/07/1987)
  8723                                  		EOI	EQU	20H
  8724                                  		AKPORT	EQU	20H
  8725                                  		INITSPOT EQU	534H	; IBM wants 4 zeros here
  8726                                  		BRKADR	EQU	1BH * 4	; 6CH, 1BH break vector address
  8727                                  		TIMADR	EQU	1CH * 4	; 70H, 1CH timer interrupt
  8728                                  		DSKADR	EQU	1EH * 4	; address of ptr to disk parameters
  8729                                  		SEC9	EQU	522H	; address of disk parameters
  8730                                  		;CHROUT	EQU	29H
  8731                                  		;LSTDRV	EQU     504H
  8732                                  		;;SYSIZE	EQU 200H ;NUMBER OF PARAGRAPHS IN SYSINIT MODULE
  8733                                  		 ; 26/03/2018
  8734                                  		RSINIT	EQU	0A3H
  8735                                  		NORMSETTLE EQU  15
  8736                                  
  8737                                  		; Retro DOS v1.0 (10/02/2018)
  8738                                  		; (Register values from Retro DOS v1.0 Boot Sector)
  8739                                  		; CS = 60h  ; BIO_SEGMENT
  8740                                  		; DS = 0
  8741                                  		; ES = 0
  8742                                  		; SS = 0
  8743                                  		; SP = 0FFFEh
  8744                                   		; BP = 7C00h
  8745                                  		; DL = Physical drive number = 0
  8746                                  		;push	cs
  8747                                  		;pop	ds
  8748                                  
  8749                                  		; Retro DOS v1.0 boot sector (fd0) dos parameters
  8750                                  		; (17 bytes)
  8751                                  		bsBytesPerSec	equ 11
  8752                                  		bsSecPerClust	equ 13
  8753                                  		bsResSectors	equ 14	
  8754                                  		bsFATs		equ 16
  8755                                  		bsRootDirEnts	equ 17
  8756                                  		bsSectors	equ 19	
  8757                                  		bsMedia		equ 21
  8758                                  		bsFATsecs	equ 22
  8759                                  		bsSecPerTrack	equ 24
  8760                                  		bsHeads		equ 26
  8761                                  
  8762                                  		; Retro DOS 1.0 extensions (to boot sector parameters) 
  8763                                  		bsDataStart	equ 64
  8764                                  
  8765                                  		;push	ds
  8766                                  		;pop	es
  8767                                  
  8768                                  		; 14/02/2018
  8769                                  		; Set video mode to 3 (Clear screen)
  8770 00002AE2 B80300                  		mov	ax, 3
  8771 00002AE5 CD10                    		int	10h
  8772                                  
  8773                                  		; 06/04/2018 - Retro DOS v2.0
  8774                                  		; (IBMDOS 2.1, IBMBIO.COM, 20/10/1983)
  8775                                  		; (by IDA Pro Free Dissassembler)
  8776                                  		; 19/03/2018
  8777                                  		; (Source Code Ref: MSDOS 3.3, MSINIT.ASM, 1991)
  8778                                  		
  8779                                  		; "MSINIT.ASM"
  8780                                  		;---------------------------------------------------------------
  8781                                  		; At this point the registers contain these values:
  8782                                  		;   AX = 0-based drive we booted from
  8783                                  		;   BX = the logical number of the first data sector on the disk
  8784                                  		;   CX = number of floppies including logical one
  8785                                  
  8786                                  		;
  8787                                  		; set up local stack
  8788                                  		;
  8789                                  
  8790                                  		;XOR	BX,BX
  8791                                  		;CLI		; turn interrupts off while manupulating stack
  8792                                  		;MOV	SS,BX	; set stack segment register
  8793                                  		;MOV	SP,700h	; set stack pointer
  8794                                  		;STI		; turn interrupts on
  8795                                  
  8796                                  ; 02/06/2018 - Retro DOS v3.0
  8797                                  
  8798                                  ;
  8799                                  ; Entry from boot sector.  The register contents are:
  8800                                  ;   DL = INT 13 drive number we booted from
  8801                                  ;   CH = media byte
  8802                                  ;   BX = First data sector on disk (0-based)
  8803                                  ;
  8804 00002AE7 FA                      		CLI
  8805 00002AE8 31C0                    		XOR	AX,AX
  8806 00002AEA 8ED8                    		MOV	DS,AX
  8807                                  ;
  8808                                  ; Preserve original int 13 vector
  8809                                  ;   We need to save INT13 in two places in case we are running on an AT.
  8810                                  ; On ATs we install the IBM supplied ROM_BIOS patch DISK.OBJ which hooks
  8811                                  ; INT13 ahead of ORIG13.  Since INT19 must unhook INT13 to point to the
  8812                                  ; ROM INT13 routine, we must have that ROM address also stored away.
  8813                                  ;
  8814                                  		; 16/06/2018
  8815 00002AEC A14C00                  		MOV	AX,[13h*4]
  8816 00002AEF 2EA3[B000]              		MOV	[CS:OLD13],AX
  8817 00002AF3 2EA3[B400]              		MOV	[CS:ORIG13],AX
  8818 00002AF7 A14E00                  		MOV	AX,[13h*4+2]
  8819 00002AFA 2EA3[B200]              		MOV	[CS:OLD13+2],AX
  8820 00002AFE 2EA3[B600]              		MOV	[CS:ORIG13+2],AX
  8821                                  
  8822                                  ;
  8823                                  ; Set up INT 13 for new action
  8824                                  ;
  8825 00002B02 C7064C00[6F0F]          		MOV	WORD [13h*4],Block13
  8826 00002B08 8C0E4E00                		MOV	[13h*4+2],CS
  8827                                  ;
  8828                                  ; Preserve original int 19 vector
  8829                                  ;
  8830 00002B0C A16400                  		MOV	AX,[19h*4]
  8831 00002B0F 2EA3[7418]              		MOV	[CS:ORIG19],AX	
  8832 00002B13 A16600                  		MOV	AX,[19h*4+2]
  8833 00002B16 2EA3[7618]              		MOV	[CS:ORIG19+2],AX
  8834                                  ;
  8835                                  ; Set up INT 19 for new action
  8836                                  ;
  8837 00002B1A C7066400[EC18]          		MOV	WORD[19h*4],INT19
  8838 00002B20 8C0E6600                		MOV	[19h*4+2],CS
  8839 00002B24 FB                      		STI
  8840                                  
  8841                                  		;; 07/04/2018
  8842                                  		;; Retro DOS v2.0
  8843                                  		;INT	11h		; rom-bios equipment determination
  8844                                  		;; 10/04/2018
  8845                                  		;TEST	AL,1
  8846                                  		;JNZ	SHORT CHECKSINGLEFD
  8847                                  		;XOR	AX,AX
  8848                                  		;JMP	SHORT NOFD
  8849                                  ;CHECKSINGLEFD:
  8850                                  		;MOV	CL, 6
  8851                                  		;SHR	AL, CL
  8852                                  		;JNZ	short NOTSINGLE	;ZERO MEANS SINGLE DRIVE SYSTEM
  8853                                  		;INC	byte [Single]	;REMEMBER THIS
  8854                                  ;NOTSINGLE:
  8855                                  		;XOR	AH,AH
  8856                                  		;INC	AL ; 10/04/2018
  8857                                  
  8858                                  		;; 02/06/2018
  8859                                  		;; Retro DOS v3.0  (MSDOS 3.3, MSINIT.ASM, 02/02/1988)
  8860                                  
  8861 00002B25 CD11                    		INT	11h		; rom-bios equipment determination
  8862 00002B27 D0C0                    		ROL	AL,1		;PUT BITS 6 & 7 INTO BITS 0 & 1
  8863 00002B29 D0C0                    		ROL	AL,1
  8864 00002B2B 83E003                  		AND	AX,3		;ONLY LOOK AT BITS 0 & 1
  8865 00002B2E 7506                    		JNZ	short NOTSINGLE	;ZERO MEANS SINGLE DRIVE SYSTEM
  8866 00002B30 40                      		INC	AX		;PRETEND IT'S A TWO DRIVE SYSTEM
  8867 00002B31 2EFE06[C501]            		INC	byte [CS:Single] ;REMEMBER THIS
  8868                                  NOTSINGLE:
  8869 00002B36 40                      		INC	AX		;AX HAS NUMBER OF DRIVES, 2-4
  8870                                  					;IS ALSO 0 INDEXED BOOT DRIVE IF WE
  8871                                  					;  BOOTED OFF HARD FILE
  8872 00002B37 88C1                    		mov	CL,AL		; save number of diskette drives in CL
  8873 00002B39 F6C280                  		test	DL,80h		; booted from hard disk ?
  8874 00002B3C 7502                    		jnz	short GotHrd	; yes, jump down
  8875 00002B3E 31C0                    		xor	AX,AX		; no - indicate boot from drive A
  8876                                  GotHrd:		
  8877                                  		; At this point the registers contain these values:
  8878                                  		;   AX = 0-based drive we booted from
  8879                                  		;   BX = the logical number of the first data sector on the disk
  8880                                  		;   CL = number of floppies including logical one
  8881                                  		;   CH = media byte
  8882                                  		;
  8883                                  ;
  8884                                  ; set up local stack
  8885                                  ;
  8886 00002B40 88F5                    		mov	ch, dh	; 01/07/2018
  8887                                  
  8888 00002B42 31D2                    		xor	DX,DX
  8889 00002B44 FA                      		cli			; turn interrupts off while manupulating stack
  8890 00002B45 8ED2                    		mov	SS,DX		; set stack segment register
  8891 00002B47 BC0007                  		mov	SP,700h 	; set stack pointer
  8892 00002B4A FB                      		sti			; turn interrupts on
  8893                                  	
  8894                                  					; preserve some of the values in registers
  8895 00002B4B 51                      		push	CX ; (***)	; save number of floppies and media byte
  8896                                  		; 03/07/2018
  8897                                  		; 16/06/2018
  8898                                  		;mov	[CS:BIOS$],BX	; save first data sector
  8899 00002B4C 88EC                    		mov	AH,CH		; FAT ID to AH too
  8900 00002B4E 50                      		push	AX ; (**)	; save boot drive number and media byte
  8901                                  
  8902                                  ;;Rev 3.30 Modification -----------------------------------------------
  8903                                  ; Let Model_byte, Secondary_Model_Byte be set here!!!	
  8904 00002B4F B4C0                    		mov	ah,0C0h 	; return system environment 
  8905 00002B51 CD15                    		int	15h		; call ROM-Bios routine     
  8906 00002B53 7217                    		jc	short No_Rom_System_Conf ; just use Model_Byte	
  8907 00002B55 80FC00                  		cmp	ah,0		; double check		
  8908 00002B58 7512                    		jne	short No_Rom_System_Conf
  8909                                  			 		;get the model byte				
  8910 00002B5A 268A4702                		mov	al,[ES:BX+ROMBIOS_DESC.bios_SD_modelbyte]
  8911 00002B5E 2EA2[422A]              		mov	[CS:MODEL_BYTE],al
  8912                                  					 ;secondary model byte					
  8913 00002B62 268A4703                		mov	al, [ES:BX+ROMBIOS_DESC.bios_SD_scnd_modelbyte]
  8914 00002B66 2EA2[432A]              		mov	[CS:Secondary_Model_Byte],al				
  8915 00002B6A EB0D                    		jmp	short Turn_Timer_On					
  8916                                  No_Rom_System_Conf:							
  8917 00002B6C BEFFFF                  		MOV	SI,0FFFFH	;MJB001 			
  8918 00002B6F 8EC6                    		MOV	ES,SI		;MJB001 			
  8919 00002B71 26A00E00                		MOV	AL,[ES:0EH]	; GET MODEL BYTE ARR 2.41	
  8920 00002B75 2EA2[422A]              		MOV	[CS:MODEL_BYTE],AL ; SAVE MODEL BYTE ARR 2.41	
  8921                                  ;;End of Modification -----------------------------------------------
  8922                                  	
  8923                                  Turn_Timer_On:								
  8924 00002B79 B020                    		mov	AL,EOI
  8925 00002B7B E620                    		out	AKPORT,AL	; turn on the timer
  8926                                  
  8927                                  		; 02/06/2018
  8928                                  
  8929                                  ;;Rev 3.30 Modification -----------------------------------------------
  8930 00002B7D BE[3602]                		mov	si,COM4DEV 
  8931 00002B80 E80E06                  		call	AUX_INIT
  8932 00002B83 BE[2402]                		mov	si,COM3DEV
  8933 00002B86 E80806                  		call	AUX_INIT
  8934                                  ;;End of Modification -----------------------------------------------
  8935 00002B89 BE[1202]                		mov	SI,COM2DEV
  8936 00002B8C E80206                  		call	AUX_INIT		;INIT COM2
  8937 00002B8F BE[CA01]                		mov	SI,COM1DEV
  8938 00002B92 E8FC05                  		call	AUX_INIT		;INIT COM1
  8939                                  
  8940 00002B95 BE[0002]                		mov	SI,LPT3DEV
  8941 00002B98 E8EE05                  		call	PRINT_INIT		;INIT LPT3
  8942 00002B9B BE[EE01]                		mov	SI,LPT2DEV
  8943 00002B9E E8E805                  		call	PRINT_INIT		;INIT LPT2
  8944 00002BA1 BE[DC01]                		mov	SI,LPT1DEV
  8945 00002BA4 E8E205                  		call	PRINT_INIT		;INIT LPT1
  8946                                  
  8947 00002BA7 31D2                    		xor	DX,DX
  8948 00002BA9 8EDA                    		mov	DS,DX			;TO INITIALIZE PRINT SCREEN VECTOR
  8949 00002BAB 8EC2                    		mov	ES,DX
  8950                                  
  8951 00002BAD 31C0                    		xor	AX,AX
  8952 00002BAF BF3405                  		mov	DI,INITSPOT
  8953 00002BB2 AB                      		stosw				;INIT four bytes to 0
  8954 00002BB3 AB                      		stosw
  8955                                  
  8956 00002BB4 8CC8                    		mov	AX,CS			;FETCH SEGMENT
  8957                                  
  8958 00002BB6 C7066C00[4707]          		mov	word [BRKADR],CBREAK	;BREAK ENTRY POINT
  8959 00002BBC A36E00                  		mov	[BRKADR+2],AX		;VECTOR FOR BREAK
  8960                                  
  8961 00002BBF C706A400[9C06]          		mov	word [CHROUT*4],OUTCHR
  8962 00002BC5 A3A600                  		mov	[CHROUT*4+2],AX
  8963                                  
  8964 00002BC8 BF0400                  		mov	DI,4
  8965 00002BCB BB[4D07]                		mov	BX,INTRET		;WILL INITIALIZE REST OF INTERRUPTS
  8966 00002BCE 93                      		xchg	AX,BX
  8967 00002BCF AB                      		stosw				;Location 4
  8968 00002BD0 93                      		xchg	AX,BX
  8969 00002BD1 AB                      		stosw				;INT 1		;Location 6
  8970 00002BD2 83C704                  		add	DI,4
  8971 00002BD5 93                      		xchg	AX,BX
  8972 00002BD6 AB                      		stosw				;Location 12
  8973 00002BD7 93                      		xchg	AX,BX
  8974 00002BD8 AB                      		stosw				;INT 3		;Location 14
  8975 00002BD9 93                      		xchg	AX,BX
  8976 00002BDA AB                      		stosw				;Location 16
  8977 00002BDB 93                      		xchg	AX,BX
  8978 00002BDC AB                      		stosw				;INT 4		;Location 18
  8979                                  
  8980 00002BDD 89160005                		mov	[500H],DX		;SET PRINT SCREEN & BREAK =0
  8981 00002BE1 89160405                		mov	[LSTDRV],DX		;clean out last drive spec
  8982                                  
  8983 00002BE5 8B367800                		mov	SI,[DSKADR]
  8984 00002BE9 8E1E7A00                		mov	DS,[DSKADR+2]		; DS:SI -> current table
  8985                                  
  8986 00002BED BF2205                  		mov	DI,SEC9 		; ES:DI -> New Table
  8987 00002BF0 B90B00                  		mov	CX,DISK_PARMS.size ; 11
  8988 00002BF3 F3A4                    		rep	MOVSB			; Copy Table
  8989 00002BF5 06                      		push	ES			;
  8990 00002BF6 1F                      		pop	DS			; DS = 0
  8991                                  							
  8992 00002BF7 C70678002205            		mov	word [DSKADR],SEC9 	; Point disk parm vector to new table	
  8993 00002BFD 8C1E7A00                		mov	[DSKADR+2],DS 
  8994                                  
  8995                                  ;-----------------------------------------------
  8996                                  ;
  8997                                  ; THE FOLLOWING DEPEND ON THE TYPE OF MACHINE.
  8998                                  ;
  8999                                  		; 16/06/2018
  9000 00002C01 2E803E[422A]FD          		CMP	byte [CS:MODEL_BYTE],0FDH ; IS THIS AN OLD ROM?
  9001 00002C07 720B                    		JB	short NO_DIDDLE		; NO
  9002 00002C09 C7062B050F02            		MOV	WORD [SEC9+DISK_PARMS.DISK_HEAD_STTL],0200H+NORMSETTLE
  9003                                  						; SET HEAD SETTLE AND MOTOR START
  9004                                  						; ON PC-1 PC-2 PC-XT HAL0
  9005 00002C0F C6062205DF              		MOV	byte [SEC9+DISK_PARMS.DISK_SPECIFY_1],0DFH 
  9006                                  						; SET 1ST SPECIFY BYTE
  9007                                  						; ON PC-1 PC-2 PC-XT HAL0
  9008                                  NO_DIDDLE:
  9009 00002C14 CD12                    		int	12h			; call rom-bios for memory size
  9010 00002C16 B106                    		mov	CL,6			; get ready for shift
  9011 00002C18 D3E0                    		shl	AX,CL			; change from K to 16 byte blocks
  9012 00002C1A 59                      		pop	CX ; (**)		; restore CX
  9013                                  		; 03/07/2018
  9014 00002C1B 0E                      		push	cs
  9015 00002C1C 1F                      		pop	ds
  9016 00002C1D 890E[3C2A]              		mov	[DRVFAT],cx
  9017                                  		; 16/06/2018
  9018                                  		;mov	[CS:DRVFAT],CX
  9019                                  		;push	AX ; (*)
  9020                                  		; 03/07/2018
  9021 00002C21 89C2                    		mov	dx, ax ; (*)		
  9022                                  
  9023                                  		; 02/06/2018
  9024                                  		;mov	dx,[7C00h + 16h]	; number of sectors/fat from boot sec
  9025                                  		
  9026                                  		;01/07/2018
  9027                                  		;mov	dx,[600h+16h]		; ((Retro DOS v2.0/v3.0 modification))
  9028                                  		
  9029                                  		;xor	dh,dh
  9030                                  		; 17/06/2018
  9031                                  		;push	cs
  9032                                  		;pop	ds
  9033                                  		; 01/07/2018
  9034                                  		;mov	[FatLen],dx
  9035                                  		; 16/06/2018
  9036                                  		;mov	[CS:FatLen],DX
  9037                                  ;
  9038                                  ; Convert sector count to paragraph count:512 bytes / sec / 16 bytes / para
  9039                                  ; = 32 para /sector
  9040                                  ;
  9041                                  ;;Rev 3.30 Modification -----------------------------------------------
  9042                                  		; 01/07/2018
  9043                                  		;SHL	DX,1
  9044                                  		;SHL	DX,1
  9045                                  		;SHL	DX,1
  9046                                  		;SHL	DX,1
  9047                                  		;SHL	DX,1
  9048                                  ;;End of Modification -----------------------------------------------
  9049                                  		;SUB	AX,DX			; room for FAT
  9050                                  		; 16/06/2018
  9051                                  		;MOV	[CS:FatLoc],AX		; location to read fat
  9052                                  		; 01/07/2018
  9053                                  		;; 17/06/2018
  9054                                  		;mov	[FatLoc],ax
  9055                                  
  9056                                  		; 01/07/2018
  9057                                  
  9058                                  		; 08/04/2018
  9059                                  		; 28/03/2018
  9060                                  		; MSDOS 6.0 - MSINIT.ASM, 1991
  9061 00002C23 83E840                  		sub	ax,64		;room for boot record buffer segment (1 kb)
  9062 00002C26 A3[AF2A]                		mov	[init_bootseg],ax
  9063                                  
  9064                                  		;POP	AX ; (*)
  9065                                  		; 03/07/2018
  9066                                  		;pop	dx ; (*)
  9067                                  
  9068                                  		;; 02/06/2018
  9069                                  		;MOV	word [SYSINIT_START+DEVICE_LIST],CONHeader
  9070                                  		;MOV	[SYSINIT_START+DEVICE_LIST+2],CS
  9071                                  		; 05/07/2018
  9072 00002C29 C706[CC3B][6E01]        		MOV	word [SYSINIT+DEVICE_LIST],CONHeader
  9073 00002C2F 8C0E[CE3B]              		MOV	[SYSINIT+DEVICE_LIST+2],CS
  9074                                  
  9075                                  		;; 06/04/2018
  9076                                  		;;MOV	[SYSINIT_START+MEMORY_SIZE],AX ; Top of memory (in paragraphs)
  9077                                  		;mov	[SYSINIT_START+MEMORY_SIZE],dx ; 01/07/2018
  9078                                  		;INC	CL
  9079                                  		;MOV	[SYSINIT_START+DEFAULT_DRIVE],CL ; SAVE DEFAULT DRIVE SPEC
  9080                                  
  9081                                  		; 05/07/2018
  9082                                  		;MOV	[SYSINIT+MEMORY_SIZE],AX
  9083 00002C33 8916[DE3B]              		mov	[SYSINIT+MEMORY_SIZE],dx
  9084 00002C37 FEC1                    		INC	CL
  9085 00002C39 880E[E03B]              		MOV	[SYSINIT+DEFAULT_DRIVE],CL
  9086                                  		
  9087                                  		; 02/06/2018
  9088                                  		;mov	dx,ax
  9089                                  
  9090                                  		; 08/04/2018
  9091                                  		; 28/03/2018
  9092                                  		; MSDOS 6.0 - MSINIT.ASM, 1991
  9093                                  		;sub	ax,64		;room for boot record buffer segment (1 kb)
  9094                                  		;mov	[init_bootseg],ax
  9095                                  
  9096 00002C3D B82705                  		mov	ax,MSDOS_BIN_SEGMENT  ; MSDOS_BIN_OFFSET >> 4
  9097 00002C40 83C070                  		add	ax,KERNEL_SEGMENT ; 26/03/2018
  9098                                  		;MOV	[SYSINIT_START+CURRENT_DOS_LOCATION],AX
  9099                                  		;05/07/2018
  9100 00002C43 A3[C63B]                		MOV	[SYSINIT+CURRENT_DOS_LOCATION],AX
  9101                                  		
  9102                                  ; 02/06/2018
  9103                                  ;
  9104                                  ; IMPORTANT: Some old IBM hardware generates spurious INT F's due to bogus
  9105                                  ; printer cards.  We initialize this value to point to an IRET ONLY IF
  9106                                  ;
  9107                                  ; 1) The original segment points to storage inside valid RAM.
  9108                                  ;
  9109                                  ; 2) The original segment is 0F000:xxxx
  9110                                  ;
  9111                                  ; Theses are capricious requests from our OEM for reasons behind them, read
  9112                                  ; the DCR's for the IBM DOS 3.2 project.
  9113                                  ;
  9114                                  		; 03/07/2018
  9115                                  		;push	ax
  9116                                  		
  9117                                  		; 02/06/2018 - Retro DOS v3.0
  9118                                  		;push	ds
  9119                                  		;pop	es
  9120                                  
  9121 00002C46 31C0                    		xor	ax,ax
  9122 00002C48 8ED8                    		mov	ds,ax
  9123                                  
  9124 00002C4A A13E00                  		mov	ax,[0Fh*4+2]		; segment for Int 15
  9125                                  
  9126                                  		;;cmp	ax,[es:SYSINIT_START+MEMORY_SIZE] ; Condition 1
  9127                                  		; 05/07/2018
  9128                                  		;cmp	ax,[es:SYSINIT+MEMORY_SIZE]
  9129 00002C4D 39D0                    		cmp	ax,dx
  9130 00002C4F 7605                    		jna	short ResetIntF
  9131                                  
  9132 00002C51 3D00F0                  		cmp	ax,0F000h		; Condition 2
  9133 00002C54 750A                    		jne	short KeepIntF
  9134                                  ResetIntF:
  9135 00002C56 C7063C00[4D07]          		mov	word [0Fh*4],INTRET
  9136 00002C5C 8C0E3E00                		mov	[0Fh*4+2],cs
  9137                                  KeepIntF:
  9138                                  		;pop	ax
  9139                                  ;
  9140                                  ; END IMPORTANT
  9141                                  ;
  9142                                  
  9143                                  ; 02/06/2018 - Retro DOS v3.0
  9144                                  
  9145                                  ;**************************************************************
  9146                                  ;	WILL INITIALIZE THE NUMBER OF DRIVES		
  9147                                  ;	AFTER THE EQUIPMENT CALL (INT 11H) BITS 6&7 WILL TELL	
  9148                                  ;	THE INDICATIONS ARE AS FOLLOWS: 		
  9149                                  ;							
  9150                                  ;	BITS	7	6	DRIVES			
  9151                                  ;		0	0	1			
  9152                                  ;		0	1	2			
  9153                                  ;		1	0	3			
  9154                                  ;		1	1	4			
  9155                                  ;************************************************************** 
  9156 00002C60 0E                      		PUSH	CS
  9157 00002C61 1F                      		POP	DS
  9158 00002C62 0E                      		PUSH	CS
  9159 00002C63 07                      		POP	ES
  9160                                  
  9161 00002C64 E88F06                  		call	CMOS_CLOCK_READ  ;Before doing anything if CMOS clock,
  9162                                  				 ;then set the system time accordingly.
  9163                                  				 ;Also, reset the cmos clock rate.
  9164                                  
  9165 00002C67 31F6                    		XOR	SI,SI
  9166 00002C69 C704[B51B]              		MOV	word [SI],HARDDRV ;set up pointer to hdrive
  9167                                  
  9168 00002C6D 58                      		POP	AX ; (***) ;number of floppies and FAT ID
  9169 00002C6E 30E4                    		XOR	AH,AH	; Chuck FAT ID byte
  9170 00002C70 A2[5A02]                		MOV	[HARDNUM],AL ;Remember which drive is hard disk
  9171 00002C73 A2[C001]                		MOV	[DRVMAX],AL  ;And set initial number of drives
  9172 00002C76 D1E0                    		SHL	AX,1	;Two bytes per address
  9173 00002C78 BF[B018]                		MOV	DI,DSKDRVS
  9174 00002C7B 01C7                    		ADD	DI,AX	;Point to hardfile location
  9175 00002C7D BE[B818]                		MOV	SI,HDSKTAB
  9176 00002C80 A5                      		MOVSW		;Two addresses to move
  9177 00002C81 A5                      		MOVSW
  9178 00002C82 B280                    		mov	DL,80h	; tell rom bios to look at hard drives
  9179 00002C84 B408                    		mov	AH,08h	; set command to get drive parameter
  9180 00002C86 CD13                    		int	13h	; call ROM-BIOS to get number of drives
  9181 00002C88 7204                    		jc	short ENDDRV ; old, rom therefore no hard disks
  9182 00002C8A 8816[B41B]              		mov	[HNUM],DL ; save number of hard drives in HNUM
  9183                                  		; ES:DI = Address of Harddisk Parameter Table ; ((*))
  9184                                  ENDDRV:
  9185                                  ;
  9186                                  ; Scan the list of drives to determine their type.  We have three flavors of
  9187                                  ; diskette drives:
  9188                                  ;
  9189                                  ;   48tpi drives    We do nothing special for them
  9190                                  ;   96tpi drives    Mark the fact that they have changeline support.
  9191                                  ;   3 1/2 drives    Mark changeline support and small.
  9192                                  ;
  9193                                  ; The following code uses registers for certain values:
  9194                                  ;   DL - Physical Drive
  9195                                  ;   DS:DI - points to current BDS
  9196                                  ;   CX - Flag bits for BDS
  9197                                  ;   DH - Form Factor for the drive (1 - 48tpi, 2 - 96tpi, 3 - 3.5" medium)
  9198                                  ;
  9199 00002C8E 30D2                    		XOR	DL,DL	; start out with drive 0.
  9200                                  		; 17/06/2018
  9201                                  		;push	cs
  9202                                  		;pop	ds
  9203 00002C90 C606[6002]09            		MOV	byte [EOT],9
  9204 00002C95 BF[4C02]                		mov	di,START_BDS
  9205                                  LOOP_DRIVE:
  9206 00002C98 3A16[C001]              		cmp	dl,[DRVMAX]
  9207 00002C9C 7203                    		jb	short GOT_MORE
  9208 00002C9E E90401                  		jmp	DONE_DRIVES
  9209                                  GOT_MORE:
  9210 00002CA1 31C9                    		xor	cx,cx		; zero all flags
  9211                                  		;mov	di,[DI+BDS.Link] ; get next BDS
  9212 00002CA3 8B3D                    		mov	di,[di] ; 05/07/2019
  9213 00002CA5 B600                    		mov	dh,ff48tpi	; Set Form Factor to 48 tpi
  9214 00002CA7 C606[412A]28            		MOV	byte [NUM_CYLN],40 ; 40 TRACKS PER SIDE
  9215                                  								
  9216                                  		;PUSH	DS						
  9217 00002CAC 57                      		PUSH	DI						
  9218 00002CAD 52                      		PUSH	DX						
  9219 00002CAE 51                      		PUSH	CX
  9220                                  		; 17/06/2018						
  9221                                  		;PUSH	ES						
  9222 00002CAF 0E                      		push	cs ; ((*))		
  9223                                  						
  9224 00002CB0 B408                    		MOV	AH,08h		;GET DRIVE PARAMETERS
  9225 00002CB2 CD13                    		INT	13h		;CALL ROM-BIOS		
  9226                                  		;JNC	short PARMSFROMROM					
  9227                                  		;JMP	short NOPARMSFROMROM ; GOT AN OLD ROM
  9228 00002CB4 7277                    		jc	short NOPARMSFROMROM ; 03/06/2018
  9229                                  		; ES:DI = Address of Harddisk Parameter Table ; ((*))	
  9230                                  PARMSFROMROM:							
  9231                                  ;If CMOS is bad, it gives ES,AX,BX,CX,DH,DI=0. CY=0.	 
  9232                                  ;In this case, we are going to put bogus informations to BDS table.
  9233                                  ;We are going to set CH=39,CL=9,DH=1 to avoid divide overflow when	
  9234                                  ;they are calculated at the later time.  This is just for the Diagnostic
  9235                                  ;Diskette which need IO.SYS,MSDOS to boot up before it sets CMOS.	
  9236                                  ;This should only happen with drive B.	
  9237                                  
  9238                                  ;;Rev 3.30 Modification -----------------------------------------------
  9239 00002CB6 80FD00                  		CMP	CH,0	; if ch=0, then cl,dh=0 too.	 
  9240 00002CB9 7506                    		JNE	short PFR_OK							 
  9241 00002CBB B527                    		MOV	CH,39	; ROM gave wrong info.		 
  9242 00002CBD B109                    		MOV	CL,9	; Let's default to 360K.         
  9243 00002CBF B601                    		MOV	DH,1							 
  9244                                  PFR_OK: 								 
  9245 00002CC1 FEC6                    		INC	DH	; MAKE NUMBER OF HEADS 1-BASED	 
  9246 00002CC3 FEC5                    		INC	CH	; MAKE NUMBER OF CYLINDERS 1-BASED
  9247 00002CC5 8836[3F2A]              		MOV	[NUM_HEADS],DH	; SAVE PARMS RETURNED BY ROM	 
  9248 00002CC9 80E13F                  		AND	CL,00111111B	; EXTRACT SECTORS/TRACK 	 
  9249 00002CCC 880E[402A]              		MOV	[SEC_TRK],CL						 
  9250 00002CD0 882E[412A]              		MOV	[NUM_CYLN],CH	; ASSUME LESS THAN 256 CYLINDERS!! 
  9251                                  ; MAKE SURE THAT EOT CONTAINS THE MAX NUM OF SEC/TRK IN SYSTEM OF FLOPPIES
  9252 00002CD4 3A0E[6002]              		CMP	CL,[EOT]	; MAY SET CARRY 		 
  9253 00002CD8 7604                    		JBE	short EOT_OK							
  9254 00002CDA 880E[6002]              		MOV	[EOT],CL						
  9255                                  EOT_OK: 							
  9256 00002CDE 07                      		POP	ES ; ((*)) es = cs = ds						
  9257 00002CDF 59                      		POP	CX						
  9258 00002CE0 5A                      		POP	DX						
  9259 00002CE1 5F                      		POP	DI						
  9260                                  		;POP	DS						
  9261                                  ;
  9262                                  ; Check for presence of changeline
  9263                                  ;
  9264 00002CE2 B415                    		mov	AH,15h      	; set command to get DASD type
  9265 00002CE4 CD13                    		int	13h	     	; call ROM-BIOS
  9266 00002CE6 720D                    		JC	short CHANGELINE_DONE 	
  9267 00002CE8 80FC02                  		CMP	AH,2		; CHECK FOR PRESENCE OF CHANGELINE
  9268 00002CEB 7508                    		JNE	short CHANGELINE_DONE 					 
  9269                                  ;;End of Modification -----------------------------------------------
  9270                                  
  9271                                  ;
  9272                                  ; We have a drive with change line support.
  9273                                  ;
  9274 00002CED 80C902                  		or	CL,fChangeline	; signal type
  9275 00002CF0 C606[C301]01            		mov	byte [fHave96],1 ; Remember that we have 96tpi disks
  9276                                  ;									  
  9277                                  ; WE NOW TRY TO SET UP THE FORM FACTOR FOR THE TYPES OF MEDIA THAT WE KNOW
  9278                                  ; AND CAN RECOGNISE. FOR THE REST, WE SET THE FORM FACTOR AS "OTHER".     
  9279                                  ;									  
  9280                                  CHANGELINE_DONE:							  
  9281                                  ; 40 CYLINDERS AND 9 OR LESS SEC/TRK, TREAT AS 48 TPI MEDIUM.		  
  9282 00002CF5 803E[412A]28            		CMP	byte [NUM_CYLN],40						  
  9283 00002CFA 750B                    		JNZ	short TRY_80							  
  9284 00002CFC 803E[402A]09            		CMP	byte [SEC_TRK],9						  
  9285                                  		;JBE	short GOT_FF
  9286 00002D01 7653                    		jbe	short NEXTDRIVE ; 03/06/2018							  
  9287                                  GOTOTHER:								  
  9288 00002D03 B607                    		MOV	DH,ffOther	; WE HAVE A "STRANGE" MEDIUM     
  9289                                  		;JMP	SHORT GOT_FF
  9290 00002D05 EB4F                    		jmp	short NEXTDRIVE	; 03/06/2018				  
  9291                                  
  9292                                  ;									  
  9293                                  ; 80 CYLINDERS AND 9 SECTORS/TRACK => 720 KB DEVICE			  
  9294                                  ; 80 CYLINDERS AND 15 SEC/TRK => 96 TPI MEDIUM				  
  9295                                  ;									  
  9296                                  TRY_80: 
  9297                                  	; 03/06/2018 - Retro DOS v3.0 - MSDOS 6.0 (MSINIT.ASM, 1991) modifications
  9298                                  	
  9299 00002D07 803E[412A]50            		CMP	byte [NUM_CYLN],80						
  9300 00002D0C 75F5                    		JNZ	short GOTOTHER
  9301                                  
  9302                                  		; 03/06/2018 (MSDOS 6.0, MSINIT.ASM, 1991)
  9303 00002D0E B609                    		mov	dh,ff288	   ; assume 2.88 MB drive m037
  9304 00002D10 803E[402A]24            		cmp	byte [SEC_TRK],36  ; is it ?		  m037
  9305 00002D15 743F                    		je	short NEXTDRIVE	   ; yeah, go update	  m037
  9306                                  
  9307 00002D17 803E[402A]0F            		CMP	byte [SEC_TRK],15						
  9308 00002D1C 740B                    		JZ	short GOT96							
  9309 00002D1E 803E[402A]09            		CMP	byte [SEC_TRK],9						
  9310 00002D23 75DE                    		JNZ	short GOTOTHER	 ; (1.44MB, 3.5" diskette drive)
  9311 00002D25 B602                    		MOV	DH,ffSmall
  9312                                  		;JMP	SHORT GOT_FF
  9313 00002D27 EB2D                    		jmp	short NEXTDRIVE
  9314                                  GOT96:	
  9315 00002D29 B601                    		MOV	DH,ff96tpi
  9316                                  ;GOT_FF: 
  9317 00002D2B EB29                    		JMP	SHORT NEXTDRIVE 
  9318                                  
  9319                                  ; WE HAVE AN OLD ROM, SO WE EITHER HAVE A 48TPI OR 96TPI DRIVE. IF THE DRIVE
  9320                                  ; HAS CHANGELINE, WE ASSUME IT IS A 96TPI, OTHERWISE IT IS A 48TPI.
  9321                                  
  9322                                  NOPARMSFROMROM:
  9323 00002D2D 07                      		POP	ES ; ; ((*))
  9324 00002D2E 59                      		POP	CX
  9325 00002D2F 5A                      		POP	DX
  9326 00002D30 5F                      		POP	DI
  9327                                  		;POP	DS
  9328                                  
  9329 00002D31 B415                    		MOV	AH,15h		; SET COMMAND TO GET DASD TYPE
  9330 00002D33 CD13                    		INT	13h		; CALL ROM-BIOS
  9331 00002D35 721F                    		JC	short NEXTDRIVE
  9332 00002D37 80FC02                  		CMP	AH,2		; IS THERE CHANGELINE?
  9333 00002D3A 751A                    		JNZ	short NEXTDRIVE
  9334 00002D3C 80C902                  		OR	CL,fChangeline
  9335 00002D3F C606[C301]01            		MOV	byte [fHave96],1 ; REMEMBER WE HAVE 96TPI DRIVES
  9336 00002D44 C606[412A]50            		MOV	byte [NUM_CYLN],80
  9337 00002D49 B601                    		MOV	DH,ff96tpi
  9338 00002D4B B00F                    		MOV	AL,15		; SET EOT IF NECESSARY
  9339 00002D4D 3A06[6002]              		CMP	AL,[EOT]
  9340 00002D51 7603                    		JBE	short EOT_OK2
  9341 00002D53 A2[6002]                		MOV	[EOT],AL
  9342                                  EOT_OK2:
  9343                                  NEXTDRIVE:
  9344 00002D56 80C920                  		or	cl,fI_Own_Physical ; set this true for all drives
  9345 00002D59 88D7                    		mov	bh,dl	 	;save Int13 drive number
  9346                                  
  9347                                  ; we need to do special things if we have a single drive system and are setting
  9348                                  ; up a logical drive. it needs to have the same int13 drive number as its
  9349                                  ; counterpart, but the next drive letter. also reset ownership flag.
  9350                                  ; we detect the presence of this situation by examining the flag single for the
  9351                                  ; value 2.
  9352                                  
  9353 00002D5B 803E[C501]02            		cmp	byte [Single],2
  9354 00002D60 7505                    		jnz	short NOT_SPECIAL
  9355 00002D62 FECF                    		dec	bh	; int13 drive number same for logical drive
  9356                                  	 			; reset ownership flag for logical drive
  9357 00002D64 80F120                  		xor	cl,fI_Own_Physical
  9358                                  NOT_SPECIAL:
  9359                                  ; The values that we put in for RHdlim and RSeclim will only remain if the
  9360                                  ; form factor is of type "ffOther".
  9361                                  		
  9362 00002D67 31C0                    		xor	ax,ax			; fill BDS for drive
  9363 00002D69 A0[3F2A]                		mov	al,[NUM_HEADS]
  9364 00002D6C 89453C                  		mov	[di+BDS.RHDLIM],ax
  9365 00002D6F A0[402A]                		mov	al,[SEC_TRK]
  9366 00002D72 89453A                  		mov	[di+BDS.RSECLIM],ax
  9367 00002D75 894D29                  		mov	[di+BDS.Flags],cx
  9368 00002D78 887528                  		mov	[di+BDS.FormFactor],dh
  9369 00002D7B 885505                  		mov	[di+BDS.DriveLet],dl
  9370 00002D7E 887D04                  		mov	[di+BDS.DriveNum],bh
  9371 00002D81 8A1E[412A]              		mov	bl,[NUM_CYLN]
  9372 00002D85 885D2B                  		mov	[di+BDS.cCyln],bl	; only the l.s. byte is set here
  9373 00002D88 803E[C501]01            		cmp	byte [Single],1		; Special case for single drive system
  9374 00002D8D 7511                    		jnz	short NO_SINGLE
  9375                                  						; Don't forget we have
  9376 00002D8F C606[C501]02            		mov	byte [Single],2		;   single drive system
  9377 00002D94 83C910                  		or	cx,fI_Am_Mult		; set that this is one of
  9378                                  						;   several drives
  9379 00002D97 094D29                  		or	[di+BDS.Flags],cx	; save flags
  9380                                  		;mov	di,[di+BDS.Link]	; move to next BDS in list
  9381 00002D9A 8B3D                    		mov	di,[di] ; 05/07/2019
  9382 00002D9C FEC2                    		inc	dl			; add a number
  9383 00002D9E EBB6                    		jmp	short NEXTDRIVE		; Use same info for BDS as previous
  9384                                  NO_SINGLE:
  9385 00002DA0 FEC2                    		inc	dl
  9386 00002DA2 E9F3FE                  		jmp	LOOP_DRIVE	
  9387                                  
  9388                                  DONE_DRIVES:
  9389                                  		;mov	ax,-1			; Signify end of list by
  9390                                  		;mov	[di+BDS.Link],ax	;    setting pointer to -1
  9391                                  		;mov	word [di+BDS.Link],-1 ; 03/07/2018
  9392 00002DA5 C705FFFF                		mov	word [di],-1 ; 05/07/2019
  9393                                  ;
  9394                                  ; Set up all the hard drives in the system
  9395                                  ;
  9396                                  		; 03/06/2018	
  9397                                  DoHard:
  9398 00002DA9 803E[B41B]00            		cmp	byte [HNUM], 0		; IF (No_Hard_files)
  9399 00002DAE 7E4F                    		jle	short STATIC_CONFIGURE 	;    THEN EXIT TO CONFIGURE
  9400 00002DB0 B280                    		mov	DL,80h			; set first hard file number
  9401 00002DB2 BF[B61B]                		mov	di,BDSH		    	; Set up first hard file.
  9402 00002DB5 8A1E[5A02]              		mov	bl,[HARDNUM]
  9403 00002DB9 E8A301                  		call	SETHARD
  9404 00002DBC 730D                    		jnc	short HardFile1_OK
  9405 00002DBE FE0E[B41B]              		dec	byte [HNUM]		; First hard file is bad.
  9406 00002DC2 803E[B41B]00            		cmp	byte [HNUM],0		; IF (Second_Hard_File)
  9407 00002DC7 7F15                    		jg	short Second_Hard	;   THEN Set up second hard file
  9408 00002DC9 EB34                    		JMP	SHORT STATIC_CONFIGURE	
  9409                                  	
  9410                                  HardFile1_OK:
  9411 00002DCB E8E2EC                  		call	INSTALL_BDS	    	; install BDS into linked list
  9412 00002DCE 803E[B41B]02            		cmp	byte [HNUM],2		; IF (Only_one_hardfile)
  9413 00002DD3 7219                    		jb	short SetIt	    	;    THEN SetIt "in place"
  9414                                  
  9415 00002DD5 8A1E[5A02]              		mov	bl,[HARDNUM]
  9416 00002DD9 FEC3                    		inc	BL			; next drive letter
  9417 00002DDB BF[081C]                		mov	di,BDSX
  9418                                  Second_Hard:					; SETUP Second Hard FILE
  9419 00002DDE B281                    		mov	DL,81h			; set second hard file number
  9420 00002DE0 E87C01                  		call	SETHARD
  9421 00002DE3 7306                    		jnc	short HardFile2_OK
  9422 00002DE5 FE0E[B41B]              		dec	byte [HNUM]
  9423 00002DE9 EB03                    		jmp	short SetIt
  9424                                  
  9425                                  HardFile2_OK:
  9426 00002DEB E8C2EC                  		call	INSTALL_BDS
  9427                                  SetIt:
  9428 00002DEE A0[B41B]                		mov	al,[HNUM]
  9429 00002DF1 08C0                    		or	al,al
  9430 00002DF3 740A                    		jz	short STATIC_CONFIGURE
  9431 00002DF5 0206[5A02]              		add	al,[HARDNUM]
  9432 00002DF9 A2[C001]                		mov	[DRVMAX],al
  9433                                  
  9434                                  ; End of physical drive initialization.	
  9435                                  ; *** Do not change the position of the following statement.
  9436                                  ; *** DoMini routine will use [DRVMAX] value for the start of the logical
  9437                                  ; *** drive number of Mini disk(s).
  9438                                  
  9439 00002DFC E8C803                  		call    DoMini		;For setting up mini disks, if found
  9440                                  
  9441                                  ; End of drive initialization.
  9442                                  
  9443                                  ; 03/06/2018 - Retro DOS v3.0
  9444                                  
  9445                                  ;9/24/86 We now decide, based on the configurations available so far,
  9446                                  ;what code or data we need to keep as a stay resident code. The following
  9447                                  ;table shows the configurations under consideration. They are listed in  
  9448                                  ;the order of their current position memory.				  
  9449                                  ;Configuration will be done in two ways:				  
  9450                                  ;First, we are going to set "Static configuration".  Static configuration 
  9451                                  ;will consider from basic configuration to ENDOF96TPI configuration.	  
  9452                                  ;The result of static configuration will be the address the Dynamic	  
  9453                                  ;configuration will use to start with.					  
  9454                                  ;Secondly, "Dynamic cofiguration" will be performed. Dynamic configuration
  9455                                  ;involves possible relocation of CODE/DATA. Dynamic configuration routine 
  9456                                  ;will take care of BDSM tables and AT ROM Fix module thru K09 suspend/res 
  9457                                  ;code individually. After these operation, FINAL_DOS_LOCATION will be set.
  9458                                  ;This will be the place SYSINIT routine will relocate MSDOS module.	  
  9459                                  ;									  
  9460                                  ;   1.	 BASIC CONFIGURATION FOR MSBIO (EndFloppy, EndSwap)		  
  9461                                  ;   2.	 ENDONEHARD							  
  9462                                  ;   3.	 ENDTWOHARD							  
  9463                                  ;   4.	 END96TPI	;a system that supports "Change Line Error"       
  9464                                  ;   5.	 End of BDSM	;BDSM tables for mini disks.			  
  9465                                  ;   6.	 ENDATROM	;Some of AT ROM fix module.			  
  9466                                  ;   7.	 ENDCMOSCLOCKSET;Supporting program for CMOS clock write.	  
  9467                                  ;   8.	 ENDK09 	;K09 CMOS Clock module to handle SUSPEND/RESUME   
  9468                                  ;									  
  9469                                  ;9/24/86.								  
  9470                                  									  
  9471                                  ; *** For mini disk configuration. 4/7/86	 			  
  9472                                  ; *** END_OF_BDSM will contain the ending address(off) of BDSM table for  
  9473                                  ; *** mini disks which is located right after the label END96TPI.	  
  9474                                  ; *** The variable NUM_MINI_DSK will indicate the existance. 4/7/86	  
  9475                                  									  
  9476                                  STATIC_CONFIGURE:							  
  9477                                  		; 05/07/2019						  
  9478                                  		;PUSH	AX ; !@	
  9479                                  							  
  9480 00002DFF B8[0B1F]                		mov	ax,End96tpi		;let's start with the biggest one.
  9481 00002E02 803E[C301]00            		cmp	byte [fHave96],0	;Is change line support there?	  
  9482 00002E07 7518                    		jnz	short Config96		;Yes.				 
  9483                                  									  
  9484 00002E09 B8[591C]                		mov	ax,EndTwoHard					
  9485 00002E0C 803E[B41B]01            		cmp	byte [HNUM],1 		;1 hard file?			
  9486 00002E11 7602                    		jbe	short No_Two_HRD						 
  9487 00002E13 EB2C                    		jmp	short ConfigTwoHard						
  9488                                  No_Two_HRD:								
  9489 00002E15 B8[071C]                		mov	ax,EndOneHard					
  9490 00002E18 7502                    		jnz	short Basic_Floppy						
  9491 00002E1A EB25                    		jmp	short ConfigOneHard						
  9492                                  Basic_Floppy:								
  9493 00002E1C B8[B41B]                		mov	ax,EndFloppy					 
  9494 00002E1F EB30                    		jmp	short DYNAMIC_CONFIGURE	;static configuration is done!	
  9495                                  ;
  9496                                  ; Keep the 96tpi code
  9497                                  ;
  9498                                  Config96:
  9499                                  ;
  9500                                  ; Save old INT 13 vector
  9501                                  ;
  9502 00002E21 50                      		PUSH	AX
  9503 00002E22 1E                      		PUSH	DS
  9504 00002E23 31C0                    		XOR	AX,AX
  9505 00002E25 8ED8                    		MOV	DS,AX
  9506 00002E27 A14C00                  		MOV	AX,[4*13h]
  9507 00002E2A 2EA3[711D]              		MOV	[CS:REAL13],AX
  9508 00002E2E A14E00                  		MOV	AX,[4*13h+2]
  9509 00002E31 2EA3[731D]              		MOV	[CS:REAL13+2],AX
  9510                                  ;
  9511                                  ; Insert new vector
  9512                                  ;
  9513 00002E35 C7064C00[7B1D]          		MOV	word [4*13h],INT13
  9514 00002E3B 8C0E4E00                		MOV	[4*13h+2],CS
  9515 00002E3F 1F                      		POP	DS
  9516 00002E40 58                      		POP	AX
  9517                                  ;
  9518                                  ; Keep two hard disk BPBs
  9519                                  ;
  9520                                  ConfigTwoHard:
  9521                                  ;
  9522                                  ; Keep one hard disk BPB
  9523                                  ;
  9524                                  ConfigOneHard:
  9525                                  ;
  9526                                  ; Adjust the number of drives to include the hard disks.
  9527                                  ;
  9528 00002E41 50                      		PUSH	AX
  9529 00002E42 A0[5A02]                		MOV	AL,[HARDNUM]
  9530 00002E45 0206[B41B]              		ADD	AL,[HNUM]
  9531 00002E49 0206[802A]              		add	al,[num_mini_dsk] ;4/7/86 for mini disks installed	
  9532                                  				;if not installed, then num_mini_dsk = 0.
  9533 00002E4D A2[C001]                		MOV	[DRVMAX],AL
  9534 00002E50 58                      		POP	AX
  9535                                  
  9536                                  DYNAMIC_CONFIGURE:
  9537 00002E51 E8D800                  		call	Get_Para_Offset ;For dynamic allocation, we are
  9538                                  					;going to use offset address that
  9539                                  					;is in paragraph boundary.
  9540                                  		; 17/06/2018 (es=cs=ds)
  9541                                  		;push	cs
  9542                                  		;pop	es		;es -> code
  9543                                  		
  9544 00002E54 FC                      		cld			;clear direction
  9545                                  
  9546 00002E55 803E[802A]00            		cmp	byte [num_mini_dsk], 0	;Mini disk(s) installed ?
  9547 00002E5A 7406                    		jz	short CheckATROM	;No.
  9548                                  		; 03/07/2018
  9549 00002E5C A1[7C2A]                		mov	ax,[End_Of_BDSM]	;set the new ending address
  9550 00002E5F E8CA00                  		call	Get_Para_Offset 	
  9551                                  CheckATROM:				
  9552 00002E62 803E[422A]FC            		cmp	byte [MODEL_BYTE],0FCh	;AT ?
  9553 00002E67 7535                    		jnz	short CheckCMOSClock				
  9554 00002E69 803E[B41B]00            		cmp	byte [HNUM],0 		;No hard file?	
  9555 00002E6E 742E                    		jz	short CheckCMOSClock			
  9556 00002E70 BE00F0                  		mov	si,0F000h					
  9557 00002E73 8EC6                    		mov	es,si			;ES -> BIOS segment
  9558 00002E75 BE[882A]                		mov	si,Bios_Date			
  9559 00002E78 BFF5FF                  		mov	di,0FFF5H	;ROM BIOS string is at F000:FFF5
  9560                                  Cmpbyte:				;Only patch ROM for bios 01/10/84
  9561 00002E7B A6                      		cmpsb							
  9562 00002E7C 7520                    		jnz	short CheckCMOSClock					
  9563 00002E7E 807CFF00                		cmp	byte [si-1],0				
  9564 00002E82 75F7                    		jnz	short Cmpbyte 					
  9565                                  SetRomCode:				;Now we have to install ROM fix
  9566                                  					;AX is the address to move.
  9567 00002E84 0E                      		push	cs						
  9568 00002E85 07                      		pop	es		;set ES to CODE seg	
  9569 00002E86 A3[B400]                		mov	[ORIG13],ax				
  9570 00002E89 8C0E[B600]              		mov	[ORIG13+2],cs	;set new ROM bios int 13 vector
  9571 00002E8D B9[8E27]                		mov	cx,ENDATROM				
  9572 00002E90 BE[6226]                		mov	si,IBM_DISK_IO				
  9573 00002E93 29F1                    		sub	cx,si		;size of AT ROM FIX module
  9574 00002E95 89C7                    		mov	di,ax		;destination	
  9575 00002E97 F3A4                    		rep	movsb		;relocate it		
  9576 00002E99 89F8                    		mov	ax,di		;new ending address
  9577 00002E9B E88E00                  		call	Get_Para_Offset ;in AX			
  9578                                  CheckCMOSClock: 						
  9579 00002E9E 0E                      		push	cs						
  9580 00002E9F 07                      		pop	es		 ;set ES to CODE seg	
  9581 00002EA0 803E[A408]01            		cmp	byte [HaveCMOSClock],1 ;CMOS Clock exists?	
  9582 00002EA5 7528                    		jne	short CheckK09					
  9583 00002EA7 A3[B508]                		mov	[DaycntToDay],ax ;set the address for MSCLOCK
  9584 00002EAA B9[6028]                		mov	cx,EndDaycntToDay			
  9585 00002EAD BE[8E27]                		mov	si,Daycnt_To_Day				 
  9586 00002EB0 29F1                    		sub	cx,si		;size of CMOS clock sub routine  
  9587 00002EB2 89C7                    		mov	di,ax							  
  9588 00002EB4 F3A4                    		rep	movsb							
  9589 00002EB6 89F8                    		mov	ax,di						
  9590 00002EB8 E87100                  		call	Get_Para_Offset 					 
  9591 00002EBB A3[B308]                		mov	[BinToBCD],ax	;set the address for MSCLOCK
  9592 00002EBE B9[6F28]                		mov	cx,EndCMOSClockSet				
  9593 00002EC1 BE[6028]                		mov	si,Bin_To_BCD				
  9594 00002EC4 29F1                    		sub	cx,si							
  9595 00002EC6 89C7                    		mov	di,ax							
  9596 00002EC8 F3A4                    		rep	movsb							
  9597 00002ECA 89F8                    		mov	ax,di							
  9598 00002ECC E85D00                  		call	Get_Para_Offset 					
  9599                                  CheckK09:								
  9600 00002ECF 50                      		push	ax		;save ax	     		
  9601 00002ED0 B80041                  		mov	ax,4100h	;Q: is it a K09 	     
  9602 00002ED3 B300                    		mov	bl,0		;
  9603                                  		;xor	bl,bl			  
  9604 00002ED5 CD15                    		int	15h		;			   
  9605 00002ED7 58                      		pop	ax						
  9606 00002ED8 7228                    		jc	short ConfigDone					
  9607                                  								
  9608 00002EDA BE[7028]                		mov	si,INT6C				
  9609 00002EDD B9[3B2A]                		mov	cx,ENDK09					
  9610 00002EE0 29F1                    		sub	cx,si		;size of K09 routine	
  9611 00002EE2 89C7                    		mov	di,ax							
  9612 00002EE4 57                      		push	di		;save destination		
  9613 00002EE5 F3A4                    		rep	movsb							
  9614 00002EE7 89F8                    		mov	ax,di					
  9615 00002EE9 E84000                  		call	Get_Para_Offset ;AX = new ending address	
  9616 00002EEC 5F                      		pop	di							
  9617                                  								
  9618 00002EED 50                      		push	ax							 
  9619 00002EEE 1E                      		push	ds							
  9620 00002EEF C606[C401]01            		mov	byte [fHaveK09],1 ;remember we have a K09 type	
  9621 00002EF4 31C0                    		xor	ax,ax							
  9622 00002EF6 8ED8                    		mov	ds,ax							
  9623 00002EF8 893EB001                		mov	[4*6Ch],di	;new INT 6Ch handler	
  9624 00002EFC 8C0EB201                		mov	[4*6Ch+2],cs					
  9625 00002F00 1F                      		pop	ds							
  9626 00002F01 58                      		pop	ax		;restore the ending address	
  9627                                  ;
  9628                                  ; Set up config stuff for SYSINIT
  9629                                  ;
  9630                                  ConfigDone:
  9631                                  		; 03/06/2018 - Retro DOS v3.0	
  9632                                  		;; 07/04/2018
  9633                                  		;MOV	AX,END_OF_HD2P_TBL
  9634                                  		; 06/04/2018
  9635                                  		;MOV	AX,INIT
  9636 00002F02 83C00F                  		ADD	AX,15
  9637                                  		;SHR	AX,1
  9638 00002F05 D1D8                    		RCR	AX,1
  9639 00002F07 D1E8                    		SHR	AX,1
  9640 00002F09 D1E8                    		SHR	AX,1
  9641 00002F0B D1E8                    		SHR	AX,1
  9642 00002F0D 83C070                  		ADD	AX,KERNEL_SEGMENT
  9643                                  		;MOV	[SYSINIT_START+FINAL_DOS_LOCATION],AX
  9644                                  		; 05/07/2018
  9645 00002F10 A3[CA3B]                		MOV	[SYSINIT+FINAL_DOS_LOCATION],AX
  9646                                  
  9647                                  		; 05/07/2019
  9648                                  		;POP	AX ; !@
  9649                                  
  9650                                  		; 03/06/2018
  9651                                  		; 19/03/2018
  9652 00002F13 B9B076                  		mov	cx,msdos_bin_size+1
  9653 00002F16 D1E9                    		shr	cx,1
  9654                                  		;mov	[SYSINIT_START+DOSSIZE],cx ; DOS size in words
  9655                                  		; 05/07/2018
  9656 00002F18 890E[D03B]              		mov	[SYSINIT+DOSSIZE],cx
  9657                                  
  9658                                  		; 03/06/2018
  9659 00002F1C 803E[C301]00            		CMP	BYTE [fHave96],0
  9660 00002F21 7503                    		JNZ	SHORT ReadDos
  9661 00002F23 E87F02                  		call	PURGE_96TPI	;mjb001 eliminate calls to 96tpi hoohah
  9662                                  
  9663                                  ReadDos:
  9664                                  		; 06/07/2019
  9665                                  
  9666                                  		; 19/03/2018 (*) No need to read remain clusters of
  9667                                  		; MSDOS kernel because of Retro DOS v2.0 boot sector
  9668                                  		; has loaded all of the kernel file before.
  9669                                  		; ;("MSINIT.ASM" contains kernel file reading code here...)  
  9670                                  
  9671                                  		; 30/03/2018
  9672                                  		;mov	ax,[DRVFAT]
  9673                                  		;call	SETDRIVE
  9674                                  		;call	GETBP
  9675                                  		
  9676                                  		; 24/02/2018 - Retro DOS 2.0 - MSDOS 3.3 ("MSINIT.ASM")
  9677                                  
  9678 00002F26 E8D201                  		CALL	SETDRVPARMS
  9679                                  		
  9680                                  		; 06/07/2018
  9681                                  		
  9682                                  		; 03/06/2018 - Retro DOS v3.0
  9683                                  		;JMP	SYSINIT
  9684                                  		; 05/07/2018
  9685 00002F29 E97104                  		jmp	_SYSINIT ; GOINIT
  9686                                  
  9687                                  ;-----------------------------------------------------------------------------
  9688                                  ; 03/06/2018 - Retro DOS v3.0
  9689                                  
  9690                                  Get_Para_Offset:
  9691                                  ;in:  AX - offset value
  9692                                  ;out: AX - offset value adjusted for the next paragraph boundary.
  9693 00002F2C 83C00F                  		add	ax, 15		;make a paragraph
  9694 00002F2F D1D8                    		rcr	ax, 1	
  9695 00002F31 D1E8                    		shr	ax, 1	
  9696 00002F33 D1E8                    		shr	ax, 1
  9697 00002F35 D1E8                    		shr	ax, 1
  9698 00002F37 D1E0                    		shl	ax, 1		;now, make it back to offset value
  9699 00002F39 D1E0                    		shl	ax, 1
  9700 00002F3B D1E0                    		shl	ax, 1
  9701 00002F3D D1E0                    		shl	ax, 1
  9702 00002F3F C3                      		retn
  9703                                  
  9704                                  ; 01/07/2018
  9705                                  ;;
  9706                                  ;;	READ A FAT SECTOR INTO fat location
  9707                                  ;;
  9708                                  ;GETFAT:
  9709                                  ;		XOR	DI,DI			; offset
  9710                                  ;		MOV	DX,1			; relative sector (1st sector of fat)
  9711                                  ;		MOV	CX,[FatLen]		; read entire fat.
  9712                                  ;		MOV	AX,[FatLoc]		;
  9713                                  ;		MOV	ES,AX			; location to read
  9714                                  ;		MOV	AX,[DRVFAT]		; AH FAT ID byte, AL drive
  9715                                  ;		JMP	DISKRD
  9716                                  
  9717                                  
  9718                                  ; 02/06/2018 - Retro DOS v3.0	
  9719                                  ; 19/03/2018 - Retro DOS v2.0
  9720                                  
  9721                                  ;	READ A BOOT RECORD INTO 7C0h:BootBias
  9722                                  ;  GetBoot reads the boot record into 7C0h:BootBias
  9723                                  ;  On Entry:
  9724                                  ;	DL contains ROM drive number (80h or 81h)
  9725                                  ;  On Exit:
  9726                                  ;	if carry set error
  9727                                  ;	if carry clear:
  9728                                  ;	   ES:BX piont to boot sector
  9729                                  ;	AX and CX are not preserved
  9730                                  ;	BX and ES are used to return values
  9731                                  ;
  9732                                  GETBOOT:
  9733                                  		; 08/04/2018
  9734                                  		; Retro DOS v2.0 (IBMBIO.COM, IBMDOS 2.1)
  9735                                  
  9736                                  		;mov	AX, 07C0h     ; prepare to load ES
  9737                                  		; 28/03/2018 - MSDOS 6.0 - MSINIT.ASM, 1991	
  9738                                  		;mov	ax, [cs:init_bootseg]
  9739 00002F40 A1[AF2A]                		mov	ax, [init_bootseg]
  9740 00002F43 8EC0                    		mov	ES, AX	      ; load ES segment register
  9741 00002F45 BB0002                  		mov	BX, BootBias  ; load BX,  ES:BX is where sector goes
  9742 00002F48 B80102                  		mov	AX, 0201h     ; command to read & num sec. to 1
  9743 00002F4B 30F6                    		xor	DH, DH	      ; head number zero
  9744 00002F4D B90100                  		mov	CX, 0001h     ; cylinder zero and sector one
  9745 00002F50 CD13                    		int	13h	      ; call rom bios
  9746 00002F52 720A                    		jc	short ERRET
  9747 00002F54 26813EFE0355AA          		cmp	WORD [ES:BootBias+1FEH],0AA55H	; DAVE LITTON MAGIC WORD?
  9748 00002F5B 7401                    		je	short Norm_Ret
  9749 00002F5D F9                      		stc
  9750                                  ERRET:
  9751                                  Norm_Ret:
  9752 00002F5E C3                      		RETN
  9753                                  
  9754                                  ;
  9755                                  ;   SetHard - generate BPB for a variable sized hard file.  IBM has a
  9756                                  ;   partitioned hard file; we must read physical sector 0 to determine where
  9757                                  ;   our own logical sectors start.  We also read in our boot sector to
  9758                                  ;   determine version number
  9759                                  ;
  9760                                  ;   Inputs:	DL is ROM drive number (80 OR 81)
  9761                                  ;		DS:DI points to BDS
  9762                                  ;   Outputs:	Carry clear -> BPB is filled in
  9763                                  ;		Carry set   -> BPB is left uninitialized due to error
  9764                                  ;
  9765                                  
  9766                                  SETHARD:
  9767                                  		; 03/06/2018 - Retro DOS v3.0
  9768                                  		; (20/03/2018 - Retro DOS v2.0)
  9769                                  
  9770 00002F5F 57                      		push	di
  9771 00002F60 53                      		push	bx
  9772 00002F61 1E                      		push	ds
  9773 00002F62 885D05                  		mov	byte [di+BDS.DriveLet],bl
  9774 00002F65 885504                  		mov	byte [di+BDS.DriveNum],dl
  9775 00002F68 31C0                    		xor	ax,ax
  9776 00002F6A 0C01                    		or	al,fNon_Removable
  9777 00002F6C 094529                  		or	[di+BDS.Flags],ax
  9778 00002F6F C6452805                		mov	byte [di+BDS.FormFactor],ffHardFile
  9779 00002F73 C606[3E2A]00            		mov	byte [fBigFAT],0	; Assume 12 bit FAT
  9780 00002F78 52                      		PUSH	DX
  9781                                  
  9782 00002F79 B408                    		mov	AH,8		; set command to get drive parameters
  9783 00002F7B CD13                    		int	13h		; call rom-bios disk routine
  9784                                  
  9785                                  				; DH is number of heads-1
  9786                                  				; DL is number of hard disks attached
  9787                                  				; Low 6 bits of CL is sectors/track
  9788                                  				; High 2 bits of CL with CH are max # of cylinders
  9789 00002F7D FEC6                    		INC	DH		; get number of heads
  9790 00002F7F 887515                  		MOV	[DI+BDS.HDLIM],DH
  9791 00002F82 5A                      		POP	DX
  9792 00002F83 7223                    		JC	short SETRET	; carry here means no hard disk
  9793 00002F85 80E13F                  		AND	CL,3FH		; extract number of sectors/track
  9794 00002F88 884D13                  		MOV	[DI+BDS.SECLIM],CL
  9795 00002F8B E8B2FF                  		CALL	GETBOOT		;   if (getBoot ())
  9796 00002F8E 7218                    		JC	short SETRET	;	return -1;
  9797 00002F90 BBC203                  		MOV	BX,1C2H+BootBias ;   p = &boot[0x1C2];
  9798                                  SET1:
  9799 00002F93 26803F01                		CMP	BYTE [ES:BX],1	;   while (p->PartitionType != 1 &&
  9800 00002F97 7418                    		JZ	short SET2
  9801 00002F99 26803F04                		CMP	Byte [ES:BX],4	;	p->PartitionType != 4) {
  9802 00002F9D 7412                    		JZ	short SET2
  9803 00002F9F 83C310                  		ADD	BX,16		;	p += sizeof Partition;
  9804 00002FA2 81FB0204                		CMP	BX,202H+BootBias ;	if (p == &boot[0x202h])
  9805 00002FA6 75EB                    		JNZ	short SET1	;	    return -1;
  9806                                  SETRET:
  9807 00002FA8 F9                      		STC			;	}
  9808 00002FA9 E94B01                  		jmp	Ret_Hard
  9809                                  
  9810                                  ; --- install a mini disk. BX value saved ---
  9811                                  
  9812                                  SetMini:								 
  9813 00002FAC 57                      		push	di							 
  9814 00002FAD 53                      		push	bx							 
  9815 00002FAE 1E                      		push	ds							 
  9816 00002FAF EBE2                    		jmp	short SET1	;will be returned to Find mini partition routine.
  9817                                  					;Some logic has been added to SET1 to 
  9818                                  					;deal with Mini disks.
  9819                                  SET2:
  9820 00002FB1 52                      		PUSH	DX
  9821 00002FB2 268B4704                		MOV	AX,[ES:BX+4]
  9822 00002FB6 268B5706                		MOV	DX,[ES:BX+6]
  9823                                  
  9824                                  ;Decrement the sector count by 1 to make it zero based. Exactly 64k
  9825                                  ;sectors should be allowed	 
  9826                                  ;				 
  9827 00002FBA 83E801                  		SUB	AX,1		; PTM 901    12/12/86 MT
  9828 00002FBD 83DA00                  		SBB	DX,0		; PTM 901    12/12/86 MT
  9829                                  
  9830 00002FC0 26034708                		ADD	AX,[ES:BX+8]
  9831 00002FC4 2613570A                		ADC	DX,[ES:BX+10]
  9832 00002FC8 7405                    		JZ	short OKDrive
  9833 00002FCA 800E[3E2A]80            		OR	byte [fBigFAT],fTOOBIG
  9834                                  OKDrive:
  9835 00002FCF 5A                      		POP	DX
  9836 00002FD0 268B4704                		MOV	AX,[ES:BX+4]
  9837 00002FD4 894517                  		MOV	[DI+BDS.HIDSEC],AX	; BPB->HidSecCt = p->PartitionBegin;
  9838 00002FD7 268B4708                		MOV	AX,[ES:BX+8]
  9839 00002FDB 83F840                  		CMP	AX,64		;  if (p->PartitionLength < 64)
  9840 00002FDE 72C8                    		JB	short SETRET	;	return -1;
  9841                                  
  9842 00002FE0 89450E                  		MOV	[DI+BDS.DRVLIM],AX ; BPB->MaxSec = p->PartitionLength;
  9843 00002FE3 50                      		PUSH	AX
  9844                                  
  9845 00002FE4 52                      		PUSH	DX
  9846 00002FE5 8B4517                  		MOV	AX,[DI+BDS.HIDSEC]	; boot sector number
  9847 00002FE8 31D2                    		XOR	DX,DX
  9848 00002FEA 88F7                    		MOV	BH,DH
  9849 00002FEC 8A5D13                  		MOV	BL,[DI+BDS.SECLIM]
  9850 00002FEF F7F3                    		DIV	BX
  9851 00002FF1 88D1                    		MOV	CL,DL			; CL is sector number
  9852 00002FF3 FEC1                    		INC	CL			; sectors are 1 based
  9853 00002FF5 99                      		CWD
  9854 00002FF6 8A5D15                  		MOV	BL,[DI+BDS.HDLIM]
  9855 00002FF9 F7F3                    		DIV	BX			; DL is head, AX is cylinder
  9856                                  ;
  9857                                  ; DL is head.
  9858                                  ; AX is cylinder
  9859                                  ; CL is sector number
  9860                                  ; TOS is drive
  9861                                  ;
  9862                                  ;
  9863                                  		; 20/03/2018
  9864                                  ;*** For Mini Disks ***  4/7/86 
  9865 00002FFB 837D4D01                		cmp	word [di+BDSM.isMini], 1 ;check for mini disk - 4/7/86
  9866 00002FFF 7503                    		jnz	short OKnotMini		;not mini disk. - 4/7/86
  9867 00003001 03454F                  		add	ax, [di+BDSM.Hidden_Trks] ;set phy track num - 4/7/86
  9868                                  OKnotMini:				; 4/7/86
  9869                                  ;*** End of added logic for mini disk 
  9870                                  
  9871 00003004 D0CC                    		ROR	AH,1			; move high two bits of cyl to high
  9872 00003006 D0CC                    		ROR	AH,1			; two bits of upper byte
  9873 00003008 80E4C0                  		AND	AH,0C0h 		; turn off remainder of bits
  9874 0000300B 08E1                    		OR	CL,AH			; move two bits to correct spot
  9875 0000300D 88C5                    		MOV	CH,AL			; CH is Cylinder
  9876                                  ;
  9877                                  ; CL is sector + 2 high bits of cylinder
  9878                                  ; CH is low 8 bits of cylinder
  9879                                  ; DL is head
  9880                                  ; TOS is drive
  9881                                  ;
  9882 0000300F 58                      		POP	AX			; AL is drive
  9883 00003010 88D6                    		MOV	DH,DL			; DH is head
  9884 00003012 88C2                    		MOV	DL,AL			; DL is drive
  9885                                  ;
  9886                                  ; CL is sector + 2 high bits of cylinder
  9887                                  ; CH is low 8 bits of cylinder
  9888                                  ; DH is head
  9889                                  ; DL is drive
  9890                                  ;
  9891 00003014 31DB                    		xor	BX, BX			; clear BX -- ES:BX points to buffer
  9892 00003016 B80102                  		mov	ax, 0201h		; set command to read one sector
  9893 00003019 CD13                    		int	13h			; call rom-bios to read sector
  9894 0000301B 58                      		pop	AX
  9895                                  
  9896                                  ;
  9897                                  ; ES:[0] points to the boot sector.  In theory, (ha ha) the BPB in this thing
  9898                                  ; is correct.  We can, therefore, pull out all the relevant statistics on the
  9899                                  ; media if we recognize the version number.
  9900                                  ;
  9901 0000301C 26813E03004942          		CMP	WORD [ES:3], "IB"  ; "B" SHL 8 + "I"
  9902 00003023 751C                    		JNZ	short unknownj
  9903 00003025 26813E05004D20          		CMP	WORD [ES:5], "M "  ; " " SHL 8 + "M"
  9904 0000302C 7513                    		JNZ	short unknownj
  9905 0000302E 26813E0800322E          		CMP	WORD [ES:8], "2."  ; "." SHL 8 + "2"
  9906 00003035 750C                    		JNZ	short Try5
  9907 00003037 26803E0A0030            		CMP	BYTE [ES:10], "0"
  9908 0000303D 7504                    		JNZ	short Try5
  9909 0000303F EB13                    		JMP	SHORT CopyBPB
  9910                                  unknownj:
  9911 00003041 EB4A                    		jmp	short unknown
  9912                                  Try5:
  9913 00003043 26813E0800332E          		CMP	WORD [ES:8],"3."  ; "." SHL 8 + "3"
  9914 0000304A 75F5                    		JNZ	short unknownj
  9915 0000304C 26803E0A0031            		cmp	byte [es:10],"1"    ;do not trust 3.0 boot record.  4/15/86
  9916 00003052 72ED                    		jb	short unknownj	    ;if version >= 3.1, then O.K.  4/15/86
  9917                                  
  9918                                  CopyBPB:
  9919                                  ; We have a valid Boot sector. Use the BPB in it to build the
  9920                                  ; BPB in BIOS. It is assumed that ONLY SecPerClus, cDIR, and
  9921                                  ; cSecFat need to be set (all other values in already). fBigFat
  9922                                  ; is also set.
  9923 00003054 26A11300                		MOV	AX,[ES:11+BDS.DRVLIM-BDS.BytePerSec] ; Total sectors
  9924 00003058 48                      		DEC	AX			; Subtract # reserved (always 1)
  9925 00003059 268B161600              		MOV	DX,[ES:11+BDS.cSecFat-BDS.BytePerSec] ; Sectors for 1 fat
  9926 0000305E 895511                  		MOV	[DI+BDS.cSecFat],DX 	; Set in BIOS BPB
  9927 00003061 D1E2                    		SHL	DX,1			; Always 2 FATs
  9928 00003063 29D0                    		SUB	AX,DX			; Sub # FAT sectors
  9929 00003065 268B161100              		MOV	DX,[ES:11+BDS.cDir-BDS.BytePerSec] ; # root entries
  9930 0000306A 89550C                  		MOV	[DI+BDS.cDir],DX	; Set in BIOS BPB
  9931 0000306D B104                    		MOV	CL,4
  9932 0000306F D3EA                    		SHR	DX,CL			; Div by 16 ents/sector
  9933 00003071 29D0                    		SUB	AX,DX			; Sub # dir sectors
  9934                                  		; AX now contains the # of data sectors.
  9935 00003073 268A0E0D00              		MOV	CL,[ES:11+BDS.SecPerClus-BDS.BytePerSec] ; Sectors per cluster
  9936 00003078 884D08                  		MOV	[DI+BDS.SecPerClus],CL	; Set in BIOS BPB
  9937 0000307B 31D2                    		XOR	DX,DX
  9938 0000307D 88F5                    		MOV	CH,DH
  9939 0000307F F7F1                    		DIV	CX
  9940                                  		; AX now contains the # clusters.
  9941 00003081 3DF60F                  		CMP	AX,4096-10		; is this 16-bit fat?
  9942 00003084 7205                    		JB	short GoodRetj		; No
  9943 00003086 800E[3E2A]40            		OR	byte [fBigFAT],fBIG	; 16 bit FAT
  9944                                  GoodRetj:
  9945 0000308B EB62                    		JMP	short GoodRet
  9946                                  
  9947                                  unknown:
  9948 0000308D BE[6C2A]                		MOV	SI,DiskTable2
  9949                                  Scan:
  9950 00003090 3B04                    		CMP	AX,[SI]
  9951 00003092 7605                    		JBE	short GotParm
  9952 00003094 83C608                  		ADD	SI,4*2
  9953 00003097 EBF7                    		JMP	short Scan
  9954                                  GotParm:
  9955 00003099 8A4C06                  		MOV	CL,[SI+6]
  9956 0000309C 080E[3E2A]              		OR	[fBigFAT],CL
  9957 000030A0 8B4C02                  		MOV	CX,[SI+2]
  9958 000030A3 8B5404                  		MOV	DX,[SI+4]
  9959                                  ;
  9960                                  ;	AX = number of sectors on disk drive
  9961                                  ;	DX = number of dir entries,
  9962                                  ;	CH = number of sectors per cluster
  9963                                  ;	CL = log base 2 of ch
  9964                                  ;
  9965                                  ;	NOW CALCULATE SIZE OF FAT TABLE
  9966                                  ;
  9967 000030A6 89550C                  		MOV	[DI+BDS.cDir],DX	;SAVE NUMBER OF DIR ENTRIES
  9968 000030A9 886D08                  		MOV	[DI+BDS.SecPerClus],CH  ;SAVE SECTORS PER CLUSTER
  9969 000030AC F606[3E2A]40            		TEST	byte [fBigFAT],fBIG	;   if (fBigFat)
  9970 000030B1 751E                    		JNZ	short DoBig	;	goto DoBig;
  9971 000030B3 31DB                    		XOR	BX,BX
  9972 000030B5 88EB                    		MOV	BL,CH
  9973 000030B7 4B                      		DEC	BX
  9974 000030B8 01C3                    		ADD	BX,AX
  9975 000030BA D3EB                    		SHR	BX,CL			;   BX = 1+(BPB->MaxSec+SecPerClus-1)/
  9976 000030BC 43                      		INC	BX			;	    SecPerClus
  9977 000030BD 80E3FE                  		AND	BL,11111110b		;   BX &= ~1; (=number of clusters)
  9978 000030C0 89DE                    		MOV	SI,BX
  9979 000030C2 D1EB                    		SHR	BX,1
  9980 000030C4 01F3                    		ADD	BX,SI
  9981 000030C6 81C3FF01                		ADD	BX,511			;   BX += 511 + BX/2
  9982 000030CA D0EF                    		SHR	BH,1			;   BH >>= 1; (=BX/512)
  9983 000030CC 887D11                  		MOV	BYTE [DI+BDS.cSecFat],BH ;SAVE NUMBER OF FAT SECTORS
  9984 000030CF EB1E                    		JMP	SHORT GoodRet	 
  9985                                  DoBig:
  9986 000030D1 B104                    		MOV	CL,4			; 16 (2^4) directory entries per sector
  9987 000030D3 D3EA                    		SHR	DX,CL			; cSecDir = cDir / 16;
  9988 000030D5 29D0                    		SUB	AX,DX			; AX -= cSecDir; AX -= cSecReserved;
  9989 000030D7 48                      		DEC	AX			; ax = t - r - d
  9990 000030D8 B302                    		MOV	BL,2
  9991 000030DA 8A7D08                  		MOV	BH,[DI+BDS.SecPerClus]	; bx = 256 * secperclus + 2
  9992 000030DD 31D2                    		XOR	DX,DX
  9993 000030DF 01D8                    		ADD	AX,BX			; ax = t-r-d+256*spc+2
  9994 000030E1 83D200                  		ADC	DX,0
  9995 000030E4 83E801                  		SUB	AX,1			; ax = t-r-d+256*spc+1
  9996 000030E7 83DA00                  		SBB	DX,0
  9997 000030EA F7F3                    		DIV	BX			; cSecFat = ceil((total-dir-res)/
  9998                                  						;		 (256*secperclus+2));
  9999 000030EC 894511                  		MOV	[DI+BDS.cSecFat],AX	; number of fat sectors
 10000                                  GoodRet:
 10001 000030EF 8A1E[3E2A]              		MOV	BL,[fBigFAT]
 10002 000030F3 885D19                  		MOV	[DI+BDS.FatSiz],BL	; set size of fat on media
 10003 000030F6 F8                      		CLC
 10004                                  Ret_Hard:
 10005 000030F7 1F                      		pop	ds
 10006 000030F8 5B                      		pop	bx
 10007 000030F9 5F                      		pop	di
 10008 000030FA C3                      		RETN	
 10009                                  
 10010                                  ; 03/08/2019
 10011                                  ; (Note: Following offset may change when SYSINIT code will be changed.)
 10012                                  ;BPB_Table equ SYSINIT_START + 1D46h  ; (BPBTable offset in sysinit2.s)
 10013                                  ;BPBSIZ	  equ 25  ; Retro DOS v3.0 (02/06/2018)	
 10014                                  
 10015                                  ; 22/11/2022
 10016                                  BPB_Table equ SYSINIT_START + 1D3Eh  ; (BPBTable offset in sysinit2.s -2022-)
 10017                                  BPBSIZ	  equ 25  ; Retro DOS v3.0 (02/06/2018)	
 10018                                  
 10019                                  ;
 10020                                  ; SetDrvParms sets up the recommended BPB in each BDS in the system based on
 10021                                  ; the form factor. It is assumed that the BPBs for the various form factors
 10022                                  ; are present in the BPBTable. For hard files, the Recommended BPB is the same
 10023                                  ; as the BPB on the drive.
 10024                                  ; No attempt is made to preserve registers since we are going to jump to
 10025                                  ; SYSINIT straight after this routine.
 10026                                  ;
 10027                                  
 10028                                  SETDRVPARMS:
 10029 000030FB 31DB                    		xor	bx,bx
 10030                                  		;les	di,dword ptr [cs:START_BDS] ; get first BDS in list
 10031 000030FD 2EC43E[4C02]            		les	di,[cs:START_BDS] ; 03/07/2018
 10032                                  NextBDS:
 10033 00003102 83FFFF                  		cmp	di,-1
 10034 00003105 7501                    		jnz	short Do_SetP
 10035                                  Done_SetParms:
 10036 00003107 C3                      		RETN
 10037                                  Do_SetP:
 10038 00003108 06                      		push	es
 10039 00003109 57                      		push	di			; preserve pointer to BDS
 10040                                  		;mov	bl,es:[di].FormFactor
 10041 0000310A 268A5D28                		mov	bl,[es:di+BDS.FormFactor]
 10042 0000310E 80FB05                  		cmp	bl,ffHardFile
 10043 00003111 7524                    		jnz	short NotHardFF
 10044                                  		;mov	ax,es:[di].DrvLim
 10045 00003113 268B450E                		mov	ax,[es:di+BDS.DRVLIM]
 10046 00003117 50                      		push	ax
 10047                                  		;mov	ax,wo"rd ptr es:[di].hdlim
 10048 00003118 268B4515                		mov	ax,[es:di+BDS.HDLIM]
 10049                                  		;mul	word ptr es:[di].seclim
 10050 0000311C 26F76513                		mul	word [es:di+BDS.SECLIM]
 10051 00003120 89C1                    		mov	cx,ax			; cx has # sectors per cylinder
 10052 00003122 58                      		pop	ax
 10053 00003123 31D2                    		xor	dx,dx			; set up for div
 10054 00003125 F7F1                    		div	cx			; div #sec by sec/cyl to get # cyl
 10055 00003127 09D2                    		or	dx,dx
 10056 00003129 7401                    		jz	short No_Cyl_Rnd	; came out even
 10057 0000312B 40                      		inc	ax			; round up
 10058                                  No_Cyl_Rnd:
 10059                                  		;mov	es:[di].cCyln,ax
 10060 0000312C 2689452B                		mov	[es:di+BDS.cCyln],ax
 10061 00003130 06                      		push	es
 10062 00003131 1F                      		pop	ds
 10063                                  		;lea	si,[di].BytePerSec	; ds:si -> BPB for hard file
 10064 00003132 8D7506                  		lea	si,[di+BDS.BytePerSec]
 10065                                  
 10066 00003135 EB3C                    		jmp	short Set_RecBPB
 10067                                  NotHardFF:
 10068 00003137 0E                      		push	cs
 10069 00003138 1F                      		pop	ds
 10070 00003139 80FB07                  		cmp	bl,ffOther		; Special case "other" type of medium
 10071 0000313C 752A                    		JNZ	short NOT_PROCESS_OTHER
 10072                                  Process_Other:
 10073 0000313E 31D2                    		xor	dx,dx
 10074                                  		;mov	ax,[di].cCyln
 10075                                  		;mov	bx,[di].RHdlim
 10076 00003140 8B452B                  		mov	ax,[di+BDS.cCyln]
 10077 00003143 8B5D3C                  		mov	bx,[di+BDS.RHDLIM]
 10078 00003146 F7E3                    		mul	bx
 10079                                  		;mov	bx,[di].RSeclim
 10080 00003148 8B5D3A                  		mov	bx,[di+BDS.RSECLIM]
 10081 0000314B F7E3                    		mul	bx
 10082                                  		;mov	[di].RDrvlim,ax 	; Have the total number of sectors
 10083 0000314D 894535                  		mov	[di+BDS.RDRVLIM],ax
 10084 00003150 48                      		dec	ax
 10085                                  
 10086                                  ; New logic to get the sectors/fat area.				  
 10087                                  						;Fat entry assumed to be 1.5 bytes
 10088 00003151 BB0300                  		mov	bx,3
 10089 00003154 F7E3                    		mul	bx
 10090 00003156 BB0200                  		mov	bx,2
 10091 00003159 F7F3                    		div	bx
 10092 0000315B 31D2                    		xor	dx,dx
 10093 0000315D BB0002                  		mov	bx,512
 10094 00003160 F7F3                    		div	bx
 10095 00003162 40                      		inc	ax
 10096                                  No_Round_Up:
 10097                                  		;mov	[di].RcSecFat,ax
 10098 00003163 894538                  		mov	[di+BDS.RcSecFat],ax
 10099 00003166 EB13                    		jmp	short Go_To_Next_BDS
 10100                                  NOT_PROCESS_OTHER:
 10101 00003168 D1E3                    		shl	bx,1			; bx is word index into table of BPBs
 10102                                  		;mov	si,offset BPBTable
 10103                                  		; 06/07/2018
 10104 0000316A BE[0E51]                		mov	si,BPB_Table  ; Retro DOS v3.0 modification (06/07/2018)
 10105                                  				      ; (FD BPB Tables are in SYINIT section)
 10106                                  		;mov	si,word ptr [si+bx]	; get address of BPB
 10107 0000316D 8B30                    		mov	si,[si+bx]
 10108                                  
 10109                                  		; 28/08/2023 (BugFix)
 10110 0000316F 81C6[D033]              		add	si,SYSINIT_START
 10111                                  Set_RecBPB:
 10112                                  		;lea	di,[di].RBytePerSec	; es:di -> RecBPB
 10113 00003173 8D7D2D                  		lea	di,[di+BDS.RBytePerSec]
 10114 00003176 B91900                  		mov	cx,BPBSIZ
 10115 00003179 F3A4                    		REP	MOVSB			; MOVE BPBSIZ BYTES
 10116                                  Go_To_Next_BDS:
 10117 0000317B 5F                      		pop	di
 10118 0000317C 07                      		pop	es			; restore pointer to BDS
 10119                                  		;mov	bx,word ptr es:[di].link+2
 10120                                  		;mov	di,word ptr es:[di].link
 10121 0000317D 268B5D02                		mov	bx,[es:di+BDS.Link+2]
 10122                                  		;mov	di,[es:di+BDS.Link]
 10123 00003181 268B3D                  		mov	di,[es:di] ; 05/07/2019
 10124 00003184 8EC3                    		mov	es,bx
 10125 00003186 E979FF                  		jmp	NextBDS
 10126                                  
 10127                                  ; ----------------------------------------------------------------------------
 10128                                  ; 03/06/2018 - Retro DOS v3.0
 10129                                  
 10130                                  
 10131                                  ; SI POINTS TO DEVICE HEADER
 10132                                  ;
 10133                                  ;  4/22/86 - print_init, aux_init is modified to eliminate the
 10134                                  ;  self-modifying code.
 10135                                  
 10136                                  PRINT_INIT:
 10137 00003189 E80F00                  		call	GET_DEVICE_NUMBER
 10138 0000318C B401                    		mov	ah,1		;initalize printer port
 10139 0000318E CD17                    		int	17h		;call ROM-Bios routine
 10140 00003190 C3                      		retn
 10141                                  
 10142                                  AUX_INIT:
 10143 00003191 E80700                  		call	GET_DEVICE_NUMBER
 10144 00003194 B0A3                    		mov	al,RSINIT	;2400,N,1,8 (MSEQU.INC)
 10145 00003196 B400                    		mov	ah,0		;initalize AUX port
 10146 00003198 CD14                    		int	14h		;call ROM-Bios routine
 10147 0000319A C3                      		retn
 10148                                  
 10149                                  GET_DEVICE_NUMBER:
 10150                                  ;SI -> device header
 10151                                  		; 16/06/2018
 10152 0000319B 2E8A440D                		MOV	AL,[CS:SI+13]	;GET DEVICE NUMBER FROM THE NAME
 10153                                  		;MOV	AL,[SI+13]
 10154 0000319F 2C31                    		SUB	AL,"1"
 10155 000031A1 98                      		CBW
 10156 000031A2 89C2                    		MOV	DX,AX
 10157 000031A4 C3                      		RETN
 10158                                  
 10159                                  ; ----------------------------------------------------------------------------
 10160                                  
 10161                                  ;
 10162                                  ;   purge_96tpi NOP's calls to 96tpi support.
 10163                                  ;
 10164                                  PURGE_96TPI:
 10165 000031A5 1E                      		PUSH	DS
 10166 000031A6 06                      		PUSH	ES
 10167                                  
 10168 000031A7 0E                      		push	cs			;mjb001
 10169 000031A8 07                      		pop	es			;mjb001
 10170 000031A9 0E                      		push	cs			;mjb001
 10171 000031AA 1F                      		pop	ds			;mjb001
 10172                                  		
 10173 000031AB BE[912A]                		MOV	SI,PatchTable
 10174                                  PatchLoop:
 10175 000031AE AD                      		LODSW
 10176 000031AF 89C1                    		MOV	CX,AX
 10177 000031B1 E309                    		JCXZ	PatchDone
 10178 000031B3 AD                      		LODSW
 10179 000031B4 89C7                    		MOV	DI,AX
 10180 000031B6 B090                    		MOV	AL,90h
 10181 000031B8 F3AA                    		REP	STOSB
 10182 000031BA EBF2                    		JMP	short PatchLoop
 10183                                  
 10184                                  PatchDone:
 10185 000031BC BF[1E00]                		mov	di,TABLE_PATCH		;ARR 2.42
 10186 000031BF B8[8806]                		MOV	AX,EXIT
 10187 000031C2 AB                      		STOSW
 10188 000031C3 AB                      		STOSW
 10189                                  
 10190 000031C4 07                      		POP	ES
 10191 000031C5 1F                      		POP	DS
 10192 000031C6 C3                      		retn				;mjb001
 10193                                  
 10194                                  ; ----------------------------------------------------------------------------
 10195                                  ; 03/06/2018 - Retro DOS v3.0
 10196                                  ; (19/03/2018 - Retro DOS v2.0)
 10197                                  
 10198                                  ;Mini disk initialization routine. Called right after DoHard - 4/7/86
 10199                                  ; DoMini **************************************************************** 
 10200                                  ; **CS=DS=ES=code							
 10201                                  ; **DoMini will search for every extended partition in the system, and
 10202                                  ;   initialize it.							
 10203                                  ; **BDSM stands for BDS table for Mini disk and located right after the
 10204                                  ;   label End96Tpi. End_Of_BDSM will have the offset value of the ending
 10205                                  ;   address of BDSM table.						 
 10206                                  ; **BDSM is the same as usual BDS except that TIM_LO, TIM_HI entries are
 10207                                  ;   overlapped and used to id mini disk and the number of Hidden_trks.
 10208                                  ;   Right now, they are called as IsMini, Hidden_Trks respectively.
 10209                                  ; **DoMini will use the same routine in SETHARD routine after label SET1
 10210                                  ;   to save coding.							
 10211                                  ; **DRVMAX determined in DoHard routine will be used for the next
 10212                                  ;   available logical mini disk drive number.	
 10213                                  ;								
 10214                                  ; Input: DRVMAX, DSKDRVS					
 10215                                  ;								
 10216                                  ; Output: MiniDisk installed. BDSM table established and installed to BDS.
 10217                                  ;	  num_mini_dsk - number of mini disks installed in the system.
 10218                                  ;	  End_Of_BDSM - ending offset address of BDSM.		
 10219                                  ;								
 10220                                  ;									
 10221                                  ; Called modules:						
 10222                                  ;		  GetBoot, WRMSG, int 13h (AH=8, Rom)		
 10223                                  ;		  FIND_MINI_PARTITION (new), Install_BDSM (new),
 10224                                  ;		  SetMini (new, it will use SET1 routine)	
 10225                                  ; Variables used: End_Of_BDSM, numh, mininum, num_mini_dsk,	
 10226                                  ;		  Rom_Minidsk_num, Mini_HDLIM, Mini_SECLIM		
 10227                                  ;		  BDSMs, BDSM_type (struc), START_BDS			
 10228                                  ;***********************************************************************
 10229                                  ;
 10230                                  
 10231                                  DoMini:
 10232                                  		;push	ax			;Do I need to do this?
 10233                                  
 10234 000031C7 BF[0B1F]                		mov	di,BDSMs		;from now on, DI points to BDSM
 10235 000031CA B280                    		mov	dl,80h 			;look at first hard drive
 10236 000031CC B408                    		mov	ah,08h			;get drive parameters
 10237 000031CE CD13                    		int	13h			;call ROM-Bios
 10238 000031D0 80FA00                  		cmp	dl, 0
 10239 000031D3 7451                    		jz	short DoMiniRet		;no hard file? Then exit.
 10240 000031D5 8816[7E2A]              		mov	[numh],dl		;save the number of hard files.
 10241 000031D9 31C0                    		xor	ax,ax
 10242 000031DB A0[C001]                		mov	al,[DRVMAX]
 10243 000031DE A2[7F2A]                		mov	[mininum],al		;this will be logical drive letter
 10244                                  						;for mini disk to start with.
 10245                                  
 10246 000031E1 D1E0                    		shl	ax,1			;ax=number of devices. word bndry
 10247 000031E3 53                      		push	bx
 10248 000031E4 BB[B018]                		mov	bx,DSKDRVS
 10249 000031E7 01C3                    		add	bx,ax
 10250 000031E9 891E[862A]              		mov	[Mini_BPB_ptr], BX	;Mini_BPB_ptr points to first avlb
 10251                                  						;spot in DskDrvs for Mini disk
 10252                                  						;which points to BPB area of BDSM.
 10253 000031ED 5B                      		pop	bx
 10254                                  
 10255 000031EE C606[812A]80            		mov	byte [Rom_Minidsk_num],80h
 10256                                  DoMiniBegin:
 10257 000031F3 FEC6                    		inc	dh			;Get # of heads (conv to 1 based)
 10258 000031F5 31C0                    		xor	ax,ax
 10259 000031F7 88F0                    		mov	al,dh
 10260 000031F9 A3[822A]                		mov	[Mini_HDLIM],ax		;save it.
 10261 000031FC 31C0                    		xor	ax,ax
 10262 000031FE 80E13F                  		and	cl,3Fh	 		;Get # of sectors/track
 10263 00003201 88C8                    		mov	al,cl
 10264 00003203 A3[842A]                		mov	[Mini_SECLIM],ax 	;and save it.
 10265                                  
 10266 00003206 8A16[812A]              		mov	dl,[Rom_Minidsk_num]	;drive number <DL>
 10267 0000320A E833FD                  		call	GETBOOT 		;rd master boot rec 7c0:BootBias
 10268 0000320D 7203                    		jc	short DoMiniNext
 10269 0000320F E81500                  		call	FIND_MINI_PARTITION
 10270                                  DoMiniNext:
 10271 00003212 FE0E[7E2A]              		dec	byte [numh]
 10272 00003216 740E                    		jz	short DoMiniRet
 10273 00003218 FE06[812A]              		inc	byte [Rom_Minidsk_num] 	;Next hard file
 10274 0000321C 8A16[812A]              		mov	dl,[Rom_Minidsk_num]	;look at next hard drive
 10275 00003220 B408                    		mov	ah,08h			;get drive parameters
 10276 00003222 CD13                    		int	13h			;call ROM-Bios
 10277 00003224 EBCD                    		jmp	short DoMiniBegin
 10278                                  
 10279                                  DoMiniRet:
 10280                                  		;pop	ax
 10281                                  FmpRet: 			; 19/03/2018 -  Retro DOS v2.0
 10282 00003226 C3                      		retn
 10283                                  
 10284                                  ;Find_Mini_Partition tries to find every Extended partition on a disk.
 10285                                  ;At entry:	DI -> BDSM entry
 10286                                  ;		ES:BX -> 07C0:BootBias - Master Boot Record
 10287                                  ;		Rom_Minidsk_num - ROM drive number
 10288                                  ;		MiniNum - Logical drive number
 10289                                  ;		Mini_HDLIM, Mini_SECLIM 
 10290                                  ;
 10291                                  ;Called routine: SETMINI which uses SET1 (in SETHARD routine)
 10292                                  ;Variables & equates used from orig BIOS - flags, fNon_Removable, fBigfat
 10293                                  ;
 10294                                  
 10295                                  FIND_MINI_PARTITION:
 10296                                  
 10297 00003227 81C3C201                		add	bx,1C2h			;BX -> system id.
 10298                                  FmpNext:
 10299                                  		; 05/07/2019 - BugFix
 10300 0000322B 26803F05                		cmp	byte [ES:BX],5		; 5 = extended partition ID.
 10301 0000322F 740A                    		je	short FmpGot
 10302 00003231 83C310                  		add	bx,16			; for next entry
 10303 00003234 81FB0204                		cmp	bx,202h+BootBias ; 402h
 10304 00003238 75F1                    		jnz	short FmpNext
 10305                                  		;jmp	short FmpRet		;not found extended partition
 10306 0000323A C3                      		retn
 10307                                  FmpGot:
 10308 0000323B 31C0                    		xor	ax,ax
 10309 0000323D 0C01                    		or	al,fNon_Removable
 10310 0000323F 094529                  		or	[DI+BDS.Flags],ax
 10311 00003242 C6452805                		mov	byte [DI+BDS.FormFactor],ffHardFile
 10312 00003246 C606[3E2A]00            		mov	byte [fBigFAT],0	;assume 12 bit Fat.
 10313 0000324B A1[822A]                		mov	ax,[Mini_HDLIM]
 10314 0000324E 894515                  		mov	[DI+BDS.HDLIM],ax
 10315 00003251 A1[842A]                		mov	ax,[Mini_SECLIM]
 10316 00003254 894513                  		mov	[DI+BDS.SECLIM],ax
 10317 00003257 A0[812A]                		mov	al,[Rom_Minidsk_num]
 10318 0000325A 884504                  		mov	[DI+BDS.DriveNum],al	;set physical number
 10319 0000325D A0[7F2A]                		mov	al,[mininum]
 10320 00003260 884505                  		mov	[DI+BDS.DriveLet],al	;set logical number
 10321                                  
 10322 00003263 26837F0840              		cmp	word [ES:BX+8],64 ;**With current BPB, only lower word	
 10323                                  					; is meaningful.			
 10324 00003268 74BC                    		je	short FmpRet	;should be bigger than 64 sectors at least
 10325 0000326A 83EB04                  		sub	bx,4		;let BX point to the start of the entry 
 10326 0000326D 268A7702                		mov	dh,[ES:BX+2]						
 10327 00003271 80E6C0                  		and	dh,11000000b		;get higher bits of cyl 
 10328 00003274 D0C6                    		rol	dh,1
 10329 00003276 D0C6                    		rol	dh,1	
 10330 00003278 268A5703                		mov	dl,[ES:BX+3]		;cyl byte
 10331 0000327C 89554F                  		mov	[DI+BDSM.Hidden_Trks],dx ;set hidden trks
 10332                                  ;** Now, read the volume boot record into BootBias.
 10333 0000327F 268B4F02                		mov	cx,[ES:BX+2]		;cylinder,cylinder/sector
 10334 00003283 268A7701                		mov	dh,[ES:BX+1]		;head
 10335 00003287 8A16[812A]              		mov	dl,[Rom_Minidsk_num]	;drive
 10336                                  		; 03/07/2018
 10337                                  		;mov	ax,7C0h 		;
 10338 0000328B A1[AF2A]                		mov	ax,[init_bootseg]
 10339 0000328E 8EC0                    		mov	es,ax			;buffer segment
 10340 00003290 BB0002                  		mov	bx,BootBias		;buffer offset
 10341 00003293 B80102                  		mov	ax,0201h		;read,1 sector
 10342 00003296 CD13                    		int	13h			;call ROM-Bios routine
 10343 00003298 728C                    		jc	short FmpRet		;cannot continue.
 10344 0000329A BBC203                  		mov	bx,1c2h+BootBias
 10345                                  
 10346 0000329D E80CFD                  		call	SetMini 		;install a mini disk. BX value saved.
 10347 000032A0 7225                    		jc	short FmpnextChain
 10348                                  
 10349 000032A2 E82500                  		call	INSTALL_BDSM		;install the BDSM into the BDS table
 10350 000032A5 FE06[7F2A]              		inc	byte [mininum] 		;increase the logical drive number for next
 10351 000032A9 FE06[802A]              		inc	byte [num_mini_dsk]	;increase the number of mini disk installed.
 10352                                  
 10353 000032AD 53                      		push	bx			;now, set the DskDrvs pointer to BPB info.
 10354 000032AE 8B1E[862A]              		mov	bx,[Mini_BPB_ptr]
 10355                                  		;lea	si,[di].BytePerSec	;points to BPB of BDSM
 10356 000032B2 8D7506                  		lea	si,[di+BDSM.mBytePerSec]
 10357 000032B5 8937                    		mov	[bx],si
 10358 000032B7 FF06[862A]              		inc	word [Mini_BPB_ptr]	;advance to the next address
 10359 000032BB FF06[862A]              		inc	word [Mini_BPB_ptr]
 10360 000032BF 5B                      		pop	bx							 
 10361                                  								 
 10362                                  		;add	DI,type BDSM_type	;adjust to the next BDSM table entry. 
 10363 000032C0 83C751                  		add	DI,BDSM.size
 10364 000032C3 893E[7C2A]              		mov	[End_Of_BDSM],DI	;set the ending address of BDSM table to this. 
 10365                                  
 10366                                  FmpnextChain:
 10367 000032C7 E961FF                  		jmp	FmpNext		;let's find out if we have any chained partition
 10368                                  ;FmpRet: 								 
 10369                                  ;		retn
 10370                                  
 10371                                  ;SetMini:								 
 10372                                  ;		push	di							 
 10373                                  ;		push	bx							 
 10374                                  ;		push	ds							 
 10375                                  ;		jmp	short SET1	;will be returned to Find mini partition routine.
 10376                                  ;					;Some logic has been added to SET1 to 
 10377                                  ;					;deal with Mini disks.				  ;3.30
 10378                                  														  ;3.30
 10379                                  ;									 
 10380                                  ;Install BDSM installs a BDSM (pointed by DS:DI) into the end of the current 
 10381                                  ;linked list of BDS.							 
 10382                                  ;Also, set the current BDSM pointer segment to DS.			 
 10383                                  ;At entry: DS:DI -> BDSM						 
 10384                                  ;
 10385                                  									 
 10386                                  INSTALL_BDSM:								 
 10387 000032CA 50                      		push	ax							 
 10388 000032CB 56                      		push	si							 
 10389 000032CC 06                      		push	es							 
 10390                                  									 
 10391                                  		;les	si, dword ptr cs:START_BDS	;start of the beginning of list
 10392 000032CD C436[4C02]              		les	si, [START_BDS]
 10393                                  I_BDSM_Next:								 
 10394 000032D1 26833CFF                		cmp	word [es:si], -1		;end of the list?	 
 10395 000032D5 740B                    		jz	short I_BDSM_New						 
 10396                                  		;mov	si, [es:si+BDSM.mLink]
 10397 000032D7 268B34                  		mov	si, [es:si] ; 05/07/2019				 
 10398 000032DA 268B4402                		mov	ax, [es:si+BDSM.mLink+2]	;next pointer		 
 10399 000032DE 8EC0                    		mov	es, ax							 
 10400 000032E0 EBEF                    		jmp	short I_BDSM_Next					 
 10401                                  I_BDSM_New:								 
 10402 000032E2 8CD8                    		mov	ax, ds							 
 10403 000032E4 894502                  		mov	[di+BDSM.mLink+2], ax	;BDSM segment had not been initialized.
 10404 000032E7 26894402                		mov	[es:si+BDSM.mLink+2], ax				 
 10405                                  		;mov	[es:si+BDSM.mLink], di
 10406 000032EB 26893C                  		mov	[es:si], di ; 05/07/2019			 
 10407                                  		;mov	word [di+BDSM.mLink], -1	;make sure it is a null ptr.
 10408 000032EE C705FFFF                		mov	word [di], -1 ; 05/07/2019 
 10409                                  I_BDSM_ret:								 
 10410 000032F2 07                      		pop	es							 
 10411 000032F3 5E                      		pop	si							 
 10412 000032F4 58                      		pop	ax							 
 10413 000032F5 C3                      		retn								 
 10414                                  									 
 10415                                  ;**End of mini disk initialization**	; 4/7/86
 10416                                  
 10417                                  ; ----------------------------------------------------------------------------
 10418                                  ; 03/06/2018 - Retro DOS v3.0
 10419                                  
 10420                                  CMOS_CLOCK_READ:
 10421                                  														  ;3.30
 10422                                  ; IN ORDER TO DETERMINE IF THERE IS A CLOCK PRESENT IN THE SYSTEM, THE FOLLOWING 
 10423                                  ; NEEDS TO BE DONE.							 
 10424 000032F6 50                      		PUSH	AX							 
 10425 000032F7 51                      		PUSH	CX							 
 10426 000032F8 52                      		PUSH	DX							 
 10427 000032F9 55                      		PUSH	BP							 
 10428                                  									 
 10429 000032FA 31ED                    		XOR	BP,BP							 
 10430                                  LOOP_CLOCK:								 
 10431 000032FC 31C9                    		XOR	CX,CX							 
 10432 000032FE 31D2                    		XOR	DX,DX							 
 10433 00003300 B402                    		MOV	AH,2			;READ REAL TIME CLOCK
 10434 00003302 CD1A                    		INT	1Ah			;CALL ROM-BIOS ROUTINE
 10435 00003304 83F900                  		CMP	CX,0							 
 10436 00003307 7512                    		JNZ	short CLOCK_PRESENT						 
 10437                                  									 
 10438 00003309 83FA00                  		CMP	DX,0							 
 10439 0000330C 750D                    		JNZ	short CLOCK_PRESENT						 
 10440                                  									 
 10441 0000330E 83FD01                  		CMP	BP,1			; READ AGAIN AFTER A SLIGHT DELAY, IN CASE CLOCK
 10442 00003311 741B                    		JZ	short NO_READDATE	; WAS AT ZERO SETTING.		 
 10443                                  									 
 10444 00003313 45                      		INC	BP			; ONLY PERFORM DELAY ONCE.	 
 10445 00003314 B90040                  		MOV	CX,4000H						 
 10446                                  DELAY:									 
 10447 00003317 E2FE                    		LOOP	DELAY							 
 10448 00003319 EBE1                    		JMP	LOOP_CLOCK						 
 10449                                  									 
 10450                                  CLOCK_PRESENT:								 
 10451                                  		;mov	byte [cs:HaveCMOSClock], 1 ; Set the flag for cmos clock 
 10452 0000331B C606[A408]01            		mov	byte [HaveCMOSClock], 1
 10453                                  									 
 10454 00003320 E81000                  		call	CMOSCK			; Reset CMOS clock rate that may be  
 10455                                  						; possibly destroyed by CP DOS and 
 10456                                  						; POST routine did not restore that.			 
 10457 00003323 56                       		PUSH	SI							 
 10458 00003324 E86AF5                  		CALL	READ_REAL_DATE		;READ REAL-TIME CLOCK FOR DATE 
 10459                                  									 
 10460 00003327 FA                      		CLI			 
 10461 00003328 8936[DA05]              		MOV	[DAYCNT],SI		;SET SYSTEM DATE		 
 10462 0000332C FB                      		STI			 
 10463 0000332D 5E                      		POP	SI			 
 10464                                  NO_READDATE:								 
 10465 0000332E 5D                      		POP	BP							 
 10466 0000332F 5A                      		POP	DX							 
 10467 00003330 59                      		POP	CX							 
 10468 00003331 58                      		POP	AX							 
 10469 00003332 C3                      		RETN								 
 10470                                  				 
 10471                                  ;									 
 10472                                  ; 10/28/86								 
 10473                                  ; THE FOLLOWING CODE IS WRITTEN BY JACK GULLEY IN ENGINEERING GROUP. 
 10474                                  ; CP DOS IS CHANGING CMOS CLOCK RATE FOR ITS OWN PURPOSES AND IF THE 
 10475                                  ; USE COLD BOOT THE SYSTEM TO USE PC DOS WHILE RUNNING CP DOS, THE CMOS 
 10476                                  ; CLOCK RATE ARE STILL SLOW WHICH SLOW DOWN DISK OPERATIONS OF PC DOS 
 10477                                  ; WHICH USES CMOS CLOCK. PC DOS IS PUT THIS CODE IN MSINIT TO FIX THIS 
 10478                                  ; PROBLEM AT THE REQUEST OF CP DOS. 				 
 10479                                  ; THE PROGRAM IS MODIFIED TO BE RUN ON MSINIT. Equates are defined in CMOSEQU.INC. 
 10480                                  ; This program will be called by CMOS_Clock_Read procedure. 	 
 10481                                  ;									 
 10482                                  ;  The following code CMOSCK is used to insure that the CMOS has not	 
 10483                                  ;	had its rate controls left in an invalid state on older AT's.
 10484                                  ;									 
 10485                                  ;	It checks for an AT model byte "FC" with a submodel type of
 10486                                  ;	00, 01, 02, 03 or 06 and resets the periodic interrupt rate	 
 10487                                  ;	bits incase POST has not done it.  This initilization routine	 
 10488                                  ;	is only needed once when DOS loads.  It should be ran as soon	 
 10489                                  ;	as possible to prevent slow diskette access.			 
 10490                                  ;									 
 10491                                  ;	This code exposes one to DOS clearing CMOS setup done by a	 
 10492                                  ;	resident program that hides and re-boots the system.		 
 10493                                  ;									 
 10494                                  CMOSCK:					; CHECK AND RESET RTC RATE BITS 
 10495                                  									 
 10496                                  ;Model byte and Submodel byte were already determined in MSINIT.	 
 10497 00003333 50                      		push	ax
 10498                                  
 10499                                  	; 16/06/2018 - Retro DOS v3.0
 10500                                  
 10501                                  	; 19/03/2018 (Model: 0FCh, Sub Model: 01h, REF: AMIBIOS Prog. Guide)							 
 10502                                  
 10503                                  	;cmp	cs:Model_byte, 0FCh ;check for PC-AT model byte	 
 10504 00003334 803E[422A]FC            		cmp	byte [MODEL_BYTE],0FCh	
 10505                                  	;			 	; EXIT IF NOT "FC" FOR A PC-AT
 10506 00003339 7523                    		JNE	short CMOSCK9	; Exit if not an AT model	 
 10507                                  									 
 10508                                  	;CMP	cs:Secondary_Model_Byte,06H  ; Is it 06 for the industral AT 
 10509 0000333B 803E[432A]06            		CMP	byte [Secondary_Model_Byte],06h
 10510 00003340 7407                    		JE	short CMOSCK4 	; Go reset CMOS periodic rate if 06 
 10511                                  	;CMP	cs:Secondary_Model_Byte,04H  ; Is it 00, 01, 02, or 03	 
 10512 00003342 803E[432A]04            		cmp	byte [Secondary_Model_Byte],04h
 10513 00003347 7315                    		JNB	short CMOSCK9 	; EXIT if problem fixed by POST  
 10514                                  					; Also,Secondary_model_byte = 0 
 10515                                  					;   when AH=0c0h, int 15h failed.
 10516                                  CMOSCK4:				;	RESET THE CMOS PERIODIC RATE 
 10517                                  					;  Model=FC submodel=00,01,02,03 or 06 
 10518                                  
 10519                                  		;mov	al,CMOS_REG_A or NMI	;NMI disabled on return
 10520 00003349 B08A                    		mov	al,CMOS_REG_A + NMI	
 10521 0000334B B426                    		mov	ah,00100110b		;Set divider & rate selection
 10522 0000334D E83000                  		call	CMOS_WRITE
 10523                                  
 10524                                  		;mov	al,CMOS_REG_B or NMI	;NMI disabled on return
 10525 00003350 B08B                    		mov	al,CMOS_REG_B + NMI	
 10526 00003352 E80B00                  		call	CMOS_READ
 10527 00003355 2407                    		and	al,00000111b		;clear SET,PIE,AIE,UIE,SQWE
 10528 00003357 88C4                    		mov	ah,al
 10529 00003359 B00B                    		mov	al,CMOS_REG_B		;NMI enabled on return
 10530 0000335B E82200                  		call	CMOS_WRITE
 10531                                  
 10532                                  CMOSCK9:					; EXIT ROUTINE		 
 10533 0000335E 58                      		pop	ax							 
 10534 0000335F C3                      		RETN				; RETurn to caller		 
 10535                                  						;  Flags modifyied		 
 10536                                  							 
 10537                                  ;--- CMOS_READ ----------------------------------------------------------------- 
 10538                                  ;		READ BYTE FROM CMOS SYSTEM CLOCK CONFIGURATION TABLE	       :
 10539                                  ;									       :
 10540                                  ; INPUT: (AL)=	CMOS TABLE ADDRESS TO BE READ				       :
 10541                                  ;		BIT    7 = 0 FOR NMI ENABLED AND 1 FOR NMI DISABLED ON EXIT    :
 10542                                  ;		BITS 6-0 = ADDRESS OF TABLE LOCATION TO READ		       :
 10543                                  ;									       :
 10544                                  ; OUTPUT: (AL)	VALUE AT LOCATION (AL) MOVED INTO (AL).  IF BIT 7 OF (AL) WAS  :
 10545                                  ;		ON THEN NMI LEFT DISABLED.  DURING THE CMOS READ BOTH NMI AND  :
 10546                                  ;		NORMAL INTERRUPTS ARE DISABLED TO PROTECT CMOS DATA INTEGRITY. :
 10547                                  ;		THE CMOS ADDRESS REGISTER IS POINTED TO A DEFAULT VALUE AND    :
 10548                                  ;		THE INTERRUPT FLAG RESTORED TO THE ENTRY STATE ON RETURN.      :
 10549                                  ;		ONLY THE (AL) REGISTER AND THE NMI STATE IS CHANGED.	       :
 10550                                  ;------------------------------------------------------------------------------- 
 10551                                  									 
 10552                                  CMOS_READ:				; READ LOCATION (AL) INTO (AL) 
 10553 00003360 9C                      		PUSHF			; SAVE INTERRUPT ENABLE STATUS AND FLAGS 
 10554                                  
 10555 00003361 FA                      		cli
 10556 00003362 53                      		push	bx
 10557 00003363 50                      		push	ax		;save user NMI state
 10558 00003364 0C80                    		or	al,NMI		;disable NMI for us
 10559 00003366 E670                    		out	CMOS_PORT,al
 10560 00003368 90                      		nop			;undocumented delay needed
 10561 00003369 E471                    		in	al,CMOS_DATA	;get data value
 10562                                  
 10563                                  		 ;set NMI state to user specified 
 10564 0000336B 89C3                    		mov	bx,ax		;save data value
 10565 0000336D 58                      		pop	ax		;get user NMI
 10566 0000336E 2480                    		and	al,NMI
 10567 00003370 0C0F                    		or	al,CMOS_SHUT_DOWN
 10568 00003372 E670                    		out	CMOS_PORT,al
 10569 00003374 90                      		nop
 10570 00003375 E471                    		in	al,CMOS_DATA
 10571                                  
 10572 00003377 89D8                    		mov	ax,bx		;data value
 10573 00003379 5B                      		pop	bx
 10574                                  
 10575 0000337A 0E                      		PUSH	CS		; *PLACE CODE SEGMENT IN STACK AND 
 10576 0000337B E80100                  		CALL	CMOS_POPF	; *HANDLE POPF FOR B- LEVEL 80286 
 10577 0000337E C3                      		RETN			; RETURN WITH FLAGS RESTORED	 
 10578                                  									 
 10579                                  CMOS_POPF:				; POPF FOR LEVEL B- PARTS  
 10580 0000337F CF                      		IRET			; RETURN FAR AND RESTORE FLAGS	 
 10581                                  									 
 10582                                  							 
 10583                                  ;--- CMOS_WRITE ----------------------------------------------------------------
 10584                                  ;		WRITE BYTE TO CMOS SYSTEM CLOCK CONFIGURATION TABLE	       :
 10585                                  ;									       :
 10586                                  ; INPUT: (AL)=	CMOS TABLE ADDRESS TO BE WRITTEN TO			       :
 10587                                  ;		BIT    7 = 0 FOR NMI ENABLED AND 1 FOR NMI DISABLED ON EXIT    :
 10588                                  ;		BITS 6-0 = ADDRESS OF TABLE LOCATION TO WRITE		       :
 10589                                  ;	 (AH)=	NEW VALUE TO BE PLACED IN THE ADDRESSED TABLE LOCATION	       :
 10590                                  ;									       :
 10591                                  ; OUTPUT:	VALUE IN (AH) PLACED IN LOCATION (AL) WITH NMI LEFT DISABLED   :
 10592                                  ;		IF BIT 7 OF (AL) IS ON.  DURING THE CMOS UPDATE BOTH NMI AND   :
 10593                                  ;		NORMAL INTERRUPTS ARE DISABLED TO PROTECT CMOS DATA INTEGRITY. :
 10594                                  ;		THE CMOS ADDRESS REGISTER IS POINTED TO A DEFAULT VALUE AND    :
 10595                                  ;		THE INTERRUPT FLAG RESTORED TO THE ENTRY STATE ON RETURN.      :
 10596                                  ;		ONLY THE CMOS LOCATION AND THE NMI STATE IS CHANGED.	       :
 10597                                  ;-------------------------------------------------------------------------------
 10598                                  									 
 10599                                  CMOS_WRITE:				; WRITE (AH) TO LOCATION (AL) 
 10600 00003380 9C                      		PUSHF			; SAVE INTERRUPT ENABLE STATUS AND FLAGS 
 10601 00003381 50                      		PUSH	AX		; SAVE WORK REGISTER VALUES	 
 10602                                  
 10603 00003382 FA                      		cli
 10604 00003383 50                      		push	ax		;save user NMI state
 10605 00003384 0C80                    		or	al,NMI		;disable NMI for us
 10606 00003386 E670                    		out	CMOS_PORT,al
 10607 00003388 90                      		nop
 10608 00003389 88E0                    		mov	al,ah
 10609 0000338B E671                    		out	CMOS_DATA,al	;write data
 10610                                  
 10611                                  		 ;set NMI state to user specified 
 10612 0000338D 58                      		pop	ax 		;get user NMI
 10613 0000338E 2480                    		and	al,NMI
 10614 00003390 0C0F                    		or	al,CMOS_SHUT_DOWN
 10615 00003392 E670                    		out	CMOS_PORT,al
 10616 00003394 90                      		nop
 10617 00003395 E471                    		in	al,CMOS_DATA
 10618                                  
 10619 00003397 58                      		POP	AX		; RESTORE WORK REGISTERS	 
 10620 00003398 0E                      		PUSH	CS		; *PLACE CODE SEGMENT IN STACK AND 
 10621 00003399 E8E3FF                  		CALL	CMOS_POPF	; *HANDLE POPF FOR B- LEVEL 80286 
 10622 0000339C C3                      		RETN
 10623                                  
 10624                                  ;-----------------------------------------------------------------------------
 10625                                  ; 03/06/2018 - Retro DOS v3.0 
 10626                                  	
 10627                                  		; 07/04/2018 - Retro DOS v2.0
 10628                                  
 10629                                  ; *** SYSINIT1.ASM ***
 10630                                  ; ----------------------------------------------------------------------------
 10631                                  ; START OF MSDOS 3.3 SYSINIT CODE - SYSINIT1.ASM - 24/07/1987
 10632                                  ; ----------------------------------------------------------------------------
 10633                                  ; 02/06/2018 - Retro DOS v3.0	
 10634                                  ; 25/03/2018 - Retro DOS v2.0
 10635                                  
 10636                                  _SYSINIT: 	; 05/07/2018
 10637                                  		;JMP	GOINIT
 10638                                  
 10639                                  ; ..SYSINIT DATA .............................................................
 10640                                  
 10641                                  GOINIT:
 10642                                  		; 03/07/2018
 10643                                  Move_Myself:
 10644                                  		; 03/05/2018
 10645                                  		; 25/02/2018 - Retro DOS 2.0 - MSDOS 2.0 "SYSINIT.ASM"
 10646                                  		; (Modified for Retro DOS 2.0, for NASM 'incbin' method)
 10647                                  
 10648                                  		SYSINITSIZE	EQU  sysinit_code_end - sysinit_code_start
 10649                                  
 10650                                  		; 28/03/2018
 10651                                          	;CLD
 10652 0000339D BE[D033]                        	MOV     SI,SYSINIT_START   ; MSSTACK (05/07/2018)
 10653 000033A0 31FF                            	XOR     DI,DI
 10654                                  		; 19/03/2018
 10655                                  	       	;mov	CX,[SYSINIT_START+MEMORY_SIZE]
 10656                                  		; 05/07/2018
 10657 000033A2 8B0E[DE3B]              	       	mov	CX,[SYSINIT+MEMORY_SIZE]
 10658                                  
 10659 000033A6 B8A61E                  		MOV	AX,SYSINITSIZE + 15 ; 03/05/2018
 10660 000033A9 D1E8                    		SHR     AX,1                    ; Divide by 16 for paras
 10661 000033AB D1E8                    		SHR     AX,1
 10662 000033AD D1E8                    		SHR     AX,1
 10663 000033AF D1E8                    		SHR     AX,1
 10664 000033B1 29C1                    		SUB     CX,AX
 10665 000033B3 8EC1                    		MOV     ES,CX ; SYSINITSEG = [MEMORY_SIZE] - (SYSIZE+15)/16
 10666 000033B5 B9981E                  		MOV     CX,SYSINITSIZE + 1
 10667 000033B8 D1E9                    		SHR     CX,1                    ; Divide by 2 to get words
 10668 000033BA F3A5                    		REP     MOVSW                   ; RELOCATE SYSINIT
 10669                                  
 10670 000033BC 06                      		PUSH    ES
 10671                                  		;XOR	AX,AX ; 0
 10672                                  		;PUSH	AX
 10673                                  
 10674                                  		; 03/07/2018
 10675                                  		;PUSH	CX ; 0
 10676                                  		; 05/07/2018
 10677 000033BD B8F007                  		mov	ax,07F0h ; ((**))
 10678 000033C0 50                      		push	ax
 10679                                  
 10680 000033C1 CB                      		RETF	; far jump to final location of SYSINIT code
 10681                                  
 10682 000033C2 90<rep Eh>              align 16
 10683                                  
 10684                                  ; ----------------------------------------------------------------------------
 10685                                  ; MSDOS 3.3 -IBMBIO.COM- SYSINIT CODE -will be relocated-
 10686                                  ; ----------------------------------------------------------------------------
 10687                                  ; 11/06/2018 - Retro DOS v3.0 
 10688                                  
 10689                                  SYSINIT_START equ $
 10690                                  
 10691                                  ; 05/07/2018 - Retro DOS v3.0
 10692                                  ; (NOTE: Following address is sysinit code start address after msstack code
 10693                                  ;  in 'sysinit2.s', it is 07F0h for current SYSINIT, 05/07/2018)	
 10694                                  SYSINIT	equ SYSINIT_START + 07F0h ; ((**))
 10695                                  
 10696                                  sysinit_code_start:
 10697                                  		; 22/11/2022
 10698                                  		; 06/07/2019
 10699                                  		; 06/07/2018 ('sysinit2.s' last modification)
 10700 000033D0 <bin 1E97h>             		incbin	'SYSINIT2.BIN' ; Retro DOS 3.0 - MSDOS 3.3 'SYSINIT'
 10701                                  sysinit_code_end:
 10702 00005267 90                      		db 90h
 10703                                  
 10704 00005268 90<rep 8h>              align 16 ; Paragraph alignment is necessary here for MSDOS kernel relocation
 10705                                  
 10706                                  ; ----------------------------------------------------------------------------
 10707                                  ; START OF MSDOS 3.3 -IBMDOS.COM- KERNEL CODE (MSDOS.SYS) -will be relocated-
 10708                                  ; ----------------------------------------------------------------------------
 10709                                  ; 11/06/2018 - Retro DOS v3.0 
 10710                                  
 10711                                  MSDOS_BIN_OFFSET:  ; this offset must be paragraph aligned
 10712                                  		; 22/01/2024 (BugFix)
 10713                                  		; 16/01/2024 (BugFix)
 10714                                  		; 22/11/2022 (BugFix)
 10715                                  		; 22/07/2019 ('msdos3.s' last modification)
 10716                                  		; 20/05/2019 (BugFixed MSDOS3.BIN)
 10717                                  		; 10/09/2018 ('msdos3.s') 
 10718 00005270 <bin 76AFh>             		incbin	'MSDOS3.BIN' ; 05/07/2019
 10719                                  msdos_bin_size	equ $ - MSDOS_BIN_OFFSET
 10720                                  
 10721 0000C91F 90                      align 2
 10722                                  END_OF_KERNEL equ $
