     1                                  ; ****************************************************************************
     2                                  ; SYSINIT.BIN (MSDOS 3.3 Kernel) - RETRO DOS v3.0 by ERDOGAN TAN
     3                                  ; ----------------------------------------------------------------------------
     4                                  ; Last Update: 22/11/2022 (Previous: 03/08/2019)
     5                                  ; ----------------------------------------------------------------------------
     6                                  ; Beginning: 24/02/2018 (Retro DOS 2.0), 03/06/2018 (Retro DOS 3.0)
     7                                  ; ----------------------------------------------------------------------------
     8                                  ; Assembler: NASM version 2.11  
     9                                  ; ----------------------------------------------------------------------------
    10                                  ;	    ((nasm sysinit.s -l sysinit.lst -o SYSINIT.BIN)) 	
    11                                  ; ----------------------------------------------------------------------------
    12                                  ; Derived from 'SYSINIT1.ASM' and 'SYSINIT2.ASM' files of MSDOS 3.3
    13                                  ; source code by Microsoft, 24/07/1987
    14                                  ; ----------------------------------------------------------------------------
    15                                  ; Derived from 'SYSINIT.ASM' file of MSDOS 2.0 (IBM PCDOS v2.0) source code
    16                                  ; by Microsoft, 12/10/1983
    17                                  ; ****************************************************************************
    18                                  ; main file: 'retrodos.s'
    19                                  ; incbin 'SYSINIT.BIN' ; (SYINITSEG)
    20                                  
    21                                  ;--------------------------------------------------------------
    22                                  ; SYSINIT.TXT (27/01/1983)
    23                                  ;--------------------------------------------------------------
    24                                  ;    SYSINIT is  a module linked behind the OEM bios.  It takes
    25                                  ;over  the  system  initialization  after  the  OEM  bios   has
    26                                  ;performed any  initialization  it  needs  to  do.   Control is
    27                                  ;transfered with a long jump to the external  variable  SYSINIT
    28                                  ;
    29                                  ;
    30                                  ;   The OEM  has  the  following  variables declared external:
    31                                  ;
    32                                  ;   CURRENT_DOS_LOCATION    WORD
    33                                  ;
    34                                  ;This word  contains  the  segment  number of the DOS before it
    35                                  ;is relocated.  The OEM bios must set this value.
    36                                  ;
    37                                  ;   FINAL_DOS_LOCATION      WORD
    38                                  ;
    39                                  ;This word contains the segment number of the DOS after SYSINIT
    40                                  ;moves it.  The OEM bios must set this value.
    41                                  ;
    42                                  ;   DEVICE_LIST             DWORD
    43                                  ;
    44                                  ;This  double  word  pointer  points  to  the  linked  list  of
    45                                  ;character and block device drivers.  The  OEM  must  set  this
    46                                  ;value.
    47                                  ;
    48                                  ;   MEMORY_SIZE             WORD
    49                                  ;
    50                                  ;This word  contains  the  number  of  RAM  paragraphs.  If the
    51                                  ;bios doesn't set  this  variable  SYSINIT  will  automatically
    52                                  ;calculate it.   NOTE:  systems with PARITY checked memory must
    53                                  ;size memory in the BIOS.  SYSINITs method is to  write  memory
    54                                  ;and read it back until it gets a mismatch.
    55                                  ;
    56                                  ;   DEFAULT_DRIVE           BYTE
    57                                  ;
    58                                  ;This is  the initial default drive when the system first comes
    59                                  ;up.  drive a=0, drive b=1,  etc.   If  the  bios  doesn't  set
    60                                  ;it then drive a is assumed.
    61                                  ;
    62                                  ;   BUFFERS                 BYTE
    63                                  ;
    64                                  ;This is  the  default  number of buffers for the system.  This
    65                                  ;value may be overridden by the user in  the  CONFIG.SYS  file.
    66                                  ;It is DBed to 2 in SYSINIT it should be greater than 1.
    67                                  ;
    68                                  ;   FILES                   BYTE
    69                                  ;
    70                                  ;This is  the  default  number  of  files for the system.  This
    71                                  ;value may be overridden by the user in  the  CONFIG.SYS  file.
    72                                  ;It is  DBed  to  8 in SYSINIT, values less than 5 are ignored.
    73                                  ;
    74                                  ;   SYSINIT                 FAR
    75                                  ;
    76                                  ;The entry  point  of  the  SYSINIT  module.  OEM BIOS jumps to
    77                                  ;this label at the end of its INIT code.
    78                                  ;
    79                                  ;   The OEM  has  the  following  variables declared public:
    80                                  ;
    81                                  ;   RE_INIT                 FAR
    82                                  ;
    83                                  ;This is an entry point which allows the BIOS to do some INIT
    84                                  ;work  after  the  DOS is initialized.  ALL REGISTERS MUST BE
    85                                  ;PRESERVED.  On entry DS points to the first available memory
    86                                  ;(after  the DOS).  DS:0 points to a 100H byte program header
    87                                  ;prefix which represents  the  "program"  currently  running.
    88                                  ;This  program  should  be  thought  of  as  the OEM BIOS and
    89                                  ;SYSINIT taken together.  This is not  a  normal  program  in
    90                                  ;that  no  memory  is  allocated to it, it is running in free
    91                                  ;memory.
    92                                  ;NOTES:
    93                                  ;     At the time this routine is called SYSINIT occupies the
    94                                  ;highest 10K of memory ("highest" is determined by the  value
    95                                  ;of the MEMORY_SIZE variable), DO NOT DO WRITES THERE.
    96                                  ;     Since this is called AFTER DOS is initialized, you can
    97                                  ;make system calls.  This also implies that the code for this
    98                                  ;routine    CANNOT   be   thrown   away   by   use   of   the
    99                                  ;FINAL_DOS_LOCATION since the DOS has already been moved.
   100                                  ;     If you don't want  anything done just set this to point
   101                                  ;at a FAR RET instruction.
   102                                  
   103                                  ; ----------------------------------------------------------------------------
   104                                  ; TITLE   BIOS SYSTEM INITIALIZATION
   105                                  ; ----------------------------------------------------------------------------
   106                                  
   107                                  FALSE   EQU     0
   108                                  TRUE    EQU     0FFFFh
   109                                  
   110                                  ;IBMVER     EQU     TRUE
   111                                  ;IBM        EQU     IBMVER
   112                                  ;STACKSW    EQU	    TRUE		;Include Switchable Hardware Stacks
   113                                  ;IBMJAPVER  EQU     FALSE		; If TRUE set KANJI true also
   114                                  ;MSVER      EQU     FALSE
   115                                  ;ALTVECT    EQU     FALSE		; Switch to build ALTVECT version
   116                                  ;KANJI      EQU     FALSE
   117                                  
   118                                  ;include version.inc
   119                                  
   120                                  ;	IF	IBMJAPVER
   121                                  ;NOEXEC	EQU	TRUE
   122                                  ;       ELSE
   123                                  ;NOEXEC	EQU	FALSE
   124                                  ;       ENDIF
   125                                  
   126                                  MAJOR_VERSION   EQU     3
   127                                  MINOR_VERSION   EQU     30	;3.30
   128                                  
   129                                  ;DOSSIZE EQU	0A000H
   130                                  
   131                                  ;; (MSDOS 2.0) SYSINITVAR table offsets
   132                                  ;; ----------------------------------------------------------------------
   133                                  
   134                                  ;DPBHEAD  EQU	0  ; dd ; Pointer to head of DPB-FAT list	
   135                                  ;SFT_ADDR EQU	4  ; dd ; Pointer to first FCB table
   136                                  ;BCLOCK	  EQU	8  ; dd ; Pointer to the CLOCK device	
   137                                  ;BCON	  EQU	12 ; dd ; Console device entry points
   138                                  ;NUMIO	  EQU	16 ; db ; Number of disk tables
   139                                  ;MAXSEC   EQU	17 ; dw ; Maximum allowed sector size
   140                                  ;BUFFHEAD EQU	19 ; dd	; Pointer to head of buffer queue
   141                                  ;DEVHEAD  EQU	23 ; dd ; Set to list start passed by BIOS at DOS Init
   142                                  ;NUL_DEV  EQU	23 ; dd	; NUL device header, first 4 bytes of dev header
   143                                  ;			; (4+14 bytes)
   144                                  ;			; Points to the next device in device chain 
   145                                  ;DEVTYPE  EQU   27 ; dw ; = ISNULL
   146                                  ;SNULDEV  EQU 	29 ; dw
   147                                  ;INULDEV  EQU	31 ; dw
   148                                  ;DEVNAME  EQU	33 ; 8 BYTES ; "NUL     "
   149                                  
   150                                  ;; ----------------------------------------------------------------------
   151                                  ;; Internal DOS data returned by DOSINIT
   152                                  ;;
   153                                  ;struc	SYSINITVAR
   154                                  ;.DPBHEAD:	resd 1			; Pointer to head of DPB-FAT list
   155                                  ;.SFT_ADDR:	resd 1			; Pointer to first FCB table
   156                                  ;; The following address points to the CLOCK device
   157                                  ;.BCLOCK:	resd 1
   158                                  ;; The following address is used by DISKSTATCHK it is always
   159                                  ;; points to the console input device header
   160                                  ;.BCON:		resd 1			; Console device entry points
   161                                  ;.NUMIO:	resb 1			; Number of disk tables
   162                                  ;.MAXSEC:	resw 1			; Maximum allowed sector size
   163                                  ;.BUFFHEAD:	resd 1			; Head of buffer queue
   164                                  ;.DEVHEAD:	resd 1			; NUL dev head points to next dev
   165                                  ;.size:
   166                                  ;endstruc
   167                                  
   168                                  ; ----------------------------------------------------------------------
   169                                  ; device definitions
   170                                  
   171                                  ;Attribute bit masks
   172                                  DEVTYP  EQU     8000H           ;Bit 15 - 1  if Char, 0 if block
   173                                  DEVIOCTL EQU    4000H           ;Bit 14 - CONTROL mode bit
   174                                  ISFATBYDEV EQU  2000H           ;Bit 13 - Device uses FAT ID bytes, comp media.
   175                                  ISCIN   EQU     0001H           ;Bit 0 - This device is the console input.
   176                                  ISCOUT  EQU     0002H           ;Bit 1 - This device is the console output.
   177                                  ISNULL  EQU     0004H           ;Bit 2 - This device is the null device.
   178                                  ISCLOCK EQU     0008H           ;Bit 3 - This device is the clock device.
   179                                  ISIBM   EQU     0010H           ;Bit 4 - This device is special
   180                                  
   181                                  ; The device table list has the form:
   182                                  struc	SYSDEV
   183 00000000 ????????                .NEXT:		resd 1		;Pointer to next device header
   184 00000004 ????                    .ATT:		resw 1		;Attributes of the device
   185 00000006 ????                    .STRAT:		resw 1		;Strategy entry point
   186 00000008 ????                    .INT:		resw 1		;Interrupt entry point
   187 0000000A ????????????????        .NAME:		resb 8		;Name of device (only first byte used for block)
   188                                  .size:
   189                                  endstruc
   190                                  
   191                                  ;Static Reguest Header
   192                                  struc	SRHEAD
   193 00000000 ??                      .REQLEN:	resb 1		;Length in bytes of request block
   194 00000001 ??                      .REQUNIT:	resb 1		;Device unit number
   195 00000002 ??                      .REQFUNC:	resb 1		;Type of request
   196 00000003 ????                    .REQSTAT:	resw 1		;Status Word
   197 00000005 ????????????????                	resb 8		;Reserved for queue links
   198                                  .size:
   199                                  endstruc
   200                                  
   201                                  ;Status word masks
   202                                  STERR   EQU     8000H           ;Bit 15 - Error
   203                                  STBUI   EQU     0200H           ;Bit 9 - Buisy
   204                                  STDON   EQU     0100H           ;Bit 8 - Done
   205                                  STECODE EQU     00FFH           ;Error code
   206                                  WRECODE EQU     0
   207                                  
   208                                  ;Function codes
   209                                  DEVINIT EQU     0               ;Initialization
   210                                  DINITHL EQU     26              ;Size of init header
   211                                  DEVMDCH EQU     1               ;Media check
   212                                  DMEDHL  EQU     15              ;Size of media check header
   213                                  DEVBPB  EQU     2               ;Get BPB
   214                                  DEVRDIOCTL EQU  3               ;IOCTL read
   215                                  DBPBHL  EQU     22              ;Size of Get BPB header
   216                                  DEVRD   EQU     4               ;Read
   217                                  DRDWRHL EQU     22              ;Size of RD/WR header
   218                                  DEVRDND EQU     5               ;Non destructive read no wait (character devs)
   219                                  DRDNDHL EQU     14              ;Size of non destructive read header
   220                                  DEVIST  EQU     6               ;Input status
   221                                  DSTATHL EQU     13              ;Size of status header
   222                                  DEVIFL  EQU     7               ;Input flush
   223                                  DFLSHL  EQU     15              ;Size of flush header
   224                                  DEVWRT  EQU     8               ;Write
   225                                  DEVWRTV EQU     9               ;Write with verify
   226                                  DEVOST  EQU     10              ;Output status
   227                                  DEVOFL  EQU     11              ;Output flush
   228                                  DEVWRIOCTL EQU  12              ;IOCTL write
   229                                  
   230                                  ; ----------------------------------------------------------------------
   231                                  struc	SYS_FCB
   232 00000000 ??                      .fcb_drive:	resb 1
   233 00000001 ????????????????        .fcb_name:	resb 8
   234 00000009 ??????                  .fcb_ext:	resb 3
   235 0000000C ????                    .fcb_EXTENT:	resw 1
   236 0000000E ????                    .fcb_RECSIZ:	resw 1	; Size of record (user settable)
   237 00000010 ????                    .fcb_FILSIZ:	resw 1	; Size of file in bytes; used with the following
   238                                                          ; word
   239 00000012 ????                    .fcb_DRVBP:	resw 1	; BP for SEARCH FIRST and SEARCH NEXT
   240 00000014 ????                    .fcb_FDATE:	resw 1	; Date of last writing
   241 00000016 ????                    .fcb_FTIME:	resw 1	; Time of last writing
   242 00000018 ??                      .fcb_DEVID:	resb 1	; Device ID number, bits 0-5 if file.
   243                                                          ; bit 7=0 for file, bit 7=1 for I/O device
   244                                                          ; If file, bit 6=0 if dirty
   245                                                          ; If I/O device, bit 6=0 if EOF (input)
   246                                                          ;               Bit 5=1 if Raw mode
   247                                                          ;               Bit 0=1 if console input device
   248                                                          ;               Bit 1=1 if console output device
   249                                                          ;               Bit 2=1 if null device
   250                                                          ;               Bit 3=1 if clock device
   251 00000019 ????                    .fcb_FIRCLUS:	resw 1	; First cluster of file
   252 0000001B ????                    .fcb_CLUSPOS:	resw 1	; Position of last cluster accessed
   253 0000001D ????                    .fcb_LSTCLUS:	resw 1	; Last cluster accessed and directory
   254 0000001F ??                                   	resb 1	; pack 2 12 bit numbers into 24 bits...
   255 00000020 ??                      .fcb_NR:	resb 1	; Next record
   256 00000021 ????????                .fcb_RR:	resb 4	; Random record
   257                                  .size:
   258                                  endstruc
   259                                  
   260                                  ; ----------------------------------------------------------------------
   261                                  ; Field definition for I/O buffer information
   262                                  
   263                                  ; 10/06/2018 - Retro DOS v3.0 (MSDOS 3.3, BUFFER.INC, 24/07/1987)
   264                                  
   265                                  struc	BUFFINFO
   266 00000000 ????????                .buf_link:	resd 1	; Pointer to next buffer in list
   267 00000004 ??                      .buf_ID:	resb 1	; Drive of buffer (bit 7 = 0)
   268                                  			; SFT table index (bit 7 = 1)
   269                                  			; = FFH if buffer free
   270 00000005 ??                      .buf_flags:	resb 1	; Bit 7 = 1 if Remote file buffer
   271                                  			;	= 0 if Local device buffer
   272                                  			; Bit 6 = 1 if buffer dirty
   273                                  			; Bit 5 = Reserved
   274                                  			; Bit 4 = Search bit (bit 7 = 1)
   275                                  			; Bit 3 = 1 if buffer is DATA
   276                                  			; Bit 2 = 1 if buffer is DIR
   277                                  			; Bit 1 = 1 if buffer is FAT
   278                                  			; Bit 0 = Reserved
   279 00000006 ????                    .buf_sector:	resw 1	; Sector number of buffer (bit 7 = 0)
   280                                  ; The next two items are often refed as a word (bit 7 = 0)
   281 00000008 ??                      .buf_wrtcnt:	resb 1	; For FAT sectors, # times sector written out
   282 00000009 ??                      .buf_wrtcntinc:	resb 1	; "   "     "   , # sectors between each write
   283 0000000A ????????                .buf_DPB :	resd 1	; Pointer to drive parameters
   284 0000000E ????                    .buf_fill:	resw 1	; How full buffer is (bit 7 = 1)
   285                                  .size:
   286                                  endstruc
   287                                  
   288                                  %define buf_offset	dword [buf_sector]
   289                                  			;For bit 7 = 1, this is the byte
   290                                  			;offset of the start of the buffer in
   291                                  			;the file pointed to by buf_ID.  Thus
   292                                  			;the buffer starts at location
   293                                  			;buf_offset in the file and contains
   294                                  			;buf_fill bytes.
   295                                  
   296                                  BUFINSIZ        EQU     BUFFINFO.size ; ; Size of structure in bytes
   297                                  
   298                                  
   299                                  buf_Free	EQU	0FFh		; buf_id of free buffer
   300                                  
   301                                  ;Flag byte masks
   302                                  buf_isnet	EQU	10000000B
   303                                  buf_dirty	EQU	01000000B
   304                                  ;***
   305                                  buf_visit	EQU	00100000B
   306                                  ;***
   307                                  buf_snbuf	EQU	00010000B
   308                                  
   309                                  buf_isDATA	EQU	00001000B
   310                                  buf_isDIR	EQU	00000100B
   311                                  buf_isFAT	EQU	00000010B
   312                                  buf_type_0	EQU	11110001B	; AND sets type to "none"
   313                                  
   314                                  buf_NetID	EQU	BUFINSIZ
   315                                  
   316                                  
   317                                  ; ----------------------------------------------------------------------
   318                                  ; DPB structure
   319                                  
   320                                  ; 08/06/2018 - Retro DOS v3.0 (MSDOS 3.3, DPB.INC, 24/07/1987)
   321                                  
   322                                  struc	DPB
   323 00000000 ??                      .DRIVE:		resb 1		; Logical drive # assoc with DPB (A=0,B=1,...)
   324 00000001 ??                      .UNIT:		resb 1		; Driver unit number of DPB
   325 00000002 ????                    .SECTOR_SIZE:	resw 1		; Size of physical sector in bytes
   326 00000004 ??                      .CLUSTER_MASK:	resb 1		; Sectors/cluster - 1
   327 00000005 ??                      .CLUSTER_SHIFT:	resb 1		; Log2 of sectors/cluster
   328 00000006 ????                    .FIRST_FAT:	resw 1		; Starting record of FATs
   329 00000008 ??                      .FAT_COUNT:	resb 1		; Number of FATs for this drive
   330 00000009 ????                    .ROOT_ENTRIES:	resw 1		; Number of directory entries
   331 0000000B ????                    .FIRST_SECTOR:	resw 1		; First sector of first cluster
   332 0000000D ????                    .MAX_CLUSTER:	resw 1		; Number of clusters on drive + 1
   333 0000000F ??                      .FAT_SIZE:	resb 1		; Number of records occupied by FAT
   334 00000010 ????                    .DIR_SECTOR:	resw 1		; Starting record of directory
   335 00000012 ????????                .DRIVER_ADDR:	resd 1		; Pointer to driver
   336 00000016 ??                      .MEDIA:		resb 1		; Media byte
   337 00000017 ??                      .FIRST_ACCESS:	resb 1		; This is initialized to -1 to force a media
   338                                  				; check the first time this DPB is used
   339 00000018 ????????                .NEXT_DPB:	resd 1		; Pointer to next Drive parameter block
   340 0000001C ????                    .NEXT_FREE:	resw 1		; Cluster # of last allocated cluster
   341 0000001E ????                    .FREE_CNT:	resw 1		; Count of free clusters, -1 if unknown
   342                                  .size:
   343                                  endstruc
   344                                  
   345                                  DPBSIZ  EQU     DPB.size	; Size of the structure in bytes
   346                                  
   347                                  DSKSIZ  EQU	DPB.MAX_CLUSTER	; Size of disk (temp used during init only)
   348                                  
   349                                  ; ----------------------------------------------------------------------
   350                                  ; 26/03/2018
   351                                  
   352                                  ; IOCTL SUB-FUNCTIONS
   353                                  IOCTL_GET_DEVICE_INFO	EQU	0
   354                                  IOCTL_SET_DEVICE_INFO	EQU	1
   355                                  IOCTL_READ_HANDLE	EQU	2
   356                                  IOCTL_WRITE_HANDLE	EQU	3
   357                                  IOCTL_READ_DRIVE	EQU	4
   358                                  IOCTL_WRITE_DRIVE	EQU	5
   359                                  IOCTL_GET_INPUT_STATUS	EQU	6
   360                                  IOCTL_GET_OUTPUT_STATUS EQU	7
   361                                  IOCTL_CHANGEABLE?	EQU	8
   362                                  IOCTL_SHARING_RETRY	EQU	11
   363                                  GENERIC_IOCTL_HANDLE	EQU	12
   364                                  GENERIC_IOCTL		EQU	13
   365                                  
   366                                  ; GENERIC IOCTL SUB-FUNCTIONS
   367                                  RAWIO			EQU	8
   368                                  
   369                                  ; RAWIO SUB-FUNCTIONS
   370                                  GET_DEVICE_PARAMETERS	EQU	60H
   371                                  SET_DEVICE_PARAMETERS	EQU	40H
   372                                  READ_TRACK		EQU	61H
   373                                  WRITE_TRACK		EQU	41H
   374                                  VERIFY_TRACK		EQU	62H
   375                                  FORMAT_TRACK		EQU	42H
   376                                  
   377                                  ; DEVICETYPE VALUES
   378                                  MAX_SECTORS_IN_TRACK	EQU	63
   379                                  DEV_5INCH		EQU	0
   380                                  DEV_5INCH96TPI		EQU	1
   381                                  DEV_3INCH720KB		EQU	2
   382                                  DEV_8INCHSS		EQU	3
   383                                  DEV_8INCHDS		EQU	4
   384                                  DEV_HARDDISK		EQU	5
   385                                  DEV_OTHER		EQU	7
   386                                  ;DEV_3INCH1440KB	EQU	7
   387                                  DEV_3INCH2880KB		EQU	9
   388                                  ; Retro DOS v2.0 - 26/03/2018
   389                                  ;;DEV_TAPE		EQU	6
   390                                  ;;DEV_ERIMO		EQU	8
   391                                  ;DEV_3INCH2880KB	EQU	9
   392                                  DEV_3INCH1440KB		EQU	10
   393                                  
   394                                  ;MAX_DEV_TYPE		EQU	9	; MAXIMUM DEVICE TYPE THAT WE
   395                                  					; CURRENTLY SUPPORT.
   396                                  MAX_DEV_TYPE		EQU	10
   397                                  
   398                                  struc A_SECTORTABLE
   399 00000000 ????                    .ST_SECTORNUMBER:	resw	1
   400 00000002 ????                    .ST_SECTORSIZE:		resw	1
   401                                  .size:
   402                                  endstruc
   403                                  
   404                                  struc A_BPB
   405 00000000 ????                    .BPB_BYTESPERSECTOR:	resw	1
   406 00000002 ??                      .BPB_SECTORSPERCLUSTER:	resb	1
   407 00000003 ????                    .BPB_RESERVEDSECTORS:	resw	1
   408 00000005 ??                      .BPB_NUMBEROFFATS:	resb	1
   409 00000006 ????                    .BPB_ROOTENTRIES: 	resw	1
   410 00000008 ????                    .BPB_TOTALSECTORS:	resw	1
   411 0000000A ??                      .BPB_MEDIADESCRIPTOR:	resb	1
   412 0000000B ????                    .BPB_SECTORSPERFAT:	resw	1
   413 0000000D ????                    .BPB_SECTORSPERTRACK:	resw	1
   414 0000000F ????                    .BPB_HEADS:		resw	1
   415 00000011 ????                    .BPB_HIDDENSECTORS:	resw	1
   416 00000013 ????                    			resw	1
   417 00000015 ????                    .BPB_BIGTOTALSECTORS:	resw	1
   418 00000017 ????                    			resw	1
   419 00000019 ????????????            			resb	6	; NOTE:  many times these
   420                                  ;					; 	 6 bytes are omitted
   421                                  ;					;	 when BPB manipulations
   422                                  ;					;	 are performed!
   423                                  .size:
   424                                  endstruc
   425                                  
   426                                  struc A_DEVICEPARAMETERS
   427 00000000 ??                      .DP_SPECIALFUNCTIONS:	resb	1
   428 00000001 ??                      .DP_DEVICETYPE:		resb	1
   429 00000002 ????                    .DP_DEVICEATTRIBUTES:	resw	1
   430 00000004 ????                    .DP_CYLINDERS:		resw	1
   431 00000006 ??                      .DP_MEDIATYPE:		resb	1
   432 00000007 <res 1Fh>               .DP_BPB:		resb	A_BPB.size
   433 00000026 ????                    .DP_TRACKTABLEENTRIES:	resw	1
   434 00000028 <res FCh>               .DP_SECTORTABLE:	resb	MAX_SECTORS_IN_TRACK * A_SECTORTABLE.size
   435                                  endstruc
   436                                  
   437                                  ; ----------------------------------------------------------------------
   438                                  ; Memory arena structure
   439                                  struc ARENA
   440 00000000 ??                      .SIGNATURE:	resb 1		; 4D for valid item, 5A for last item
   441 00000001 ????                    .OWNER:		resw 1		; owner of arena item
   442 00000003 ????                    .SIZE:		resw 1		; size in paragraphs of item
   443                                  endstruc
   444                                  
   445                                  ; ----------------------------------------------------------------------
   446                                  ;
   447                                  ; Process data block (otherwise known as program header)
   448                                  ;
   449                                  
   450                                  FILPERPROC	EQU     20
   451                                  
   452                                  struc PDB	; Process_data_block
   453 00000000 ????                    .EXIT_CALL:	resw 1   	; INT int_abort system terminate
   454 00000002 ????                    .BLOCK_LEN:	resw 1		; size of execution block
   455 00000004 ??                                      resb 1
   456 00000005 ??????????              .CPM_CALL:	resb 5		; ancient call to system
   457 0000000A ????????                .EXIT:		resd 1		; pointer to exit routine
   458 0000000E ????????                .CTRL_C:	resd 1		; pointer to ^C routine
   459 00000012 ????????                .FATAL_ABORT:	resd 1		; pointer to fatal error
   460 00000016 ????                    .PARENT_PID:	resw 1		; PID of parent (terminate PID)
   461 00000018 <res 14h>               .JFN_TABLE:     resb FILPERPROC ; indices into system table
   462 0000002C ????                    .ENVIRON:	resw 1		; seg addr of environment
   463 0000002E ????????                .USER_STACK:	resd 1		; stack of self during system calls
   464 00000032 ????                    .JFN_LENGTH:	resw 1 ; 25/03/18 ; number of handles allowed
   465 00000034 ????????                .JFN_POINTER:	resd 1 ; 25/03/18 ; pointer to JFN table
   466 00000038 ????????                .NEXT_PDB:	resd 1 ; 25/03/18 ; pointer to nested PDB's
   467 0000003C <res 14h>               .PAD1:		resb 20 ; 25/03/2018
   468 00000050 ??????????              .CALL_SYSTEM:	resb 5		; portable method of system call
   469 00000055 ??????????????          .PAD2:		resb 7 ; 25/03/2018
   470                                  endstruc
   471                                  
   472                                  ; ----------------------------------------------------------------------
   473                                  ; <system call definitions>
   474                                  
   475                                  ABORT                           EQU 0   ;  0      0
   476                                  STD_CON_INPUT                   EQU 1   ;  1      1
   477                                  STD_CON_OUTPUT                  EQU 2   ;  2      2
   478                                  STD_AUX_INPUT                   EQU 3   ;  3      3
   479                                  STD_AUX_OUTPUT                  EQU 4   ;  4      4
   480                                  STD_PRINTER_OUTPUT              EQU 5   ;  5      5
   481                                  RAW_CON_IO                      EQU 6   ;  6      6
   482                                  RAW_CON_INPUT                   EQU 7   ;  7      7
   483                                  STD_CON_INPUT_NO_ECHO           EQU 8   ;  8      8
   484                                  STD_CON_STRING_OUTPUT           EQU 9   ;  9      9
   485                                  STD_CON_STRING_INPUT            EQU 10  ; 10      A
   486                                  STD_CON_INPUT_STATUS            EQU 11  ; 11      B
   487                                  STD_CON_INPUT_FLUSH             EQU 12  ; 12      C
   488                                  DISK_RESET                      EQU 13  ; 13      D
   489                                  SET_DEFAULT_DRIVE               EQU 14  ; 14      E
   490                                  FCB_OPEN                        EQU 15  ; 15      F
   491                                  FCB_CLOSE                       EQU 16  ; 16     10
   492                                  DIR_SEARCH_FIRST                EQU 17  ; 17     11
   493                                  DIR_SEARCH_NEXT                 EQU 18  ; 18     12
   494                                  FCB_DELETE                      EQU 19  ; 19     13
   495                                  FCB_SEQ_READ                    EQU 20  ; 20     14
   496                                  FCB_SEQ_WRITE                   EQU 21  ; 21     15
   497                                  FCB_CREATE                      EQU 22  ; 22     16
   498                                  FCB_RENAME                      EQU 23  ; 23     17
   499                                  GET_DEFAULT_DRIVE               EQU 25  ; 25     19
   500                                  SET_DMA                         EQU 26  ; 26     1A
   501                                  GET_DEFAULT_DPB                 EQU 31  ; 31     1F
   502                                  FCB_RANDOM_READ                 EQU 33  ; 33     21
   503                                  FCB_RANDOM_WRITE                EQU 34  ; 34     22
   504                                  GET_FCB_FILE_LENGTH             EQU 35  ; 35     23
   505                                  GET_FCB_POSITION                EQU 36  ; 36     24
   506                                  SET_INTERRUPT_VECTOR            EQU 37  ; 37     25
   507                                  CREATE_PROCESS_DATA_BLOCK       EQU 38  ; 38     26
   508                                  FCB_RANDOM_READ_BLOCK           EQU 39  ; 39     27
   509                                  FCB_RANDOM_WRITE_BLOCK          EQU 40  ; 40     28
   510                                  PARSE_FILE_DESCRIPTOR           EQU 41  ; 41     29
   511                                  GET_DATE                        EQU 42  ; 42     2A
   512                                  SET_DATE                        EQU 43  ; 43     2B
   513                                  GET_TIME                        EQU 44  ; 44     2C
   514                                  SET_TIME                        EQU 45  ; 45     2D
   515                                  SET_VERIFY_ON_WRITE             EQU 46  ; 46     2E
   516                                  ; Extended functionality group
   517                                  GET_DMA                         EQU 47  ; 47     2F
   518                                  GET_VERSION                     EQU 48  ; 48     30
   519                                  KEEP_PROCESS                    EQU 49  ; 49     31
   520                                  GET_DPB                         EQU 50  ; 50     32
   521                                  SET_CTRL_C_TRAPPING             EQU 51  ; 51     33
   522                                  GET_INDOS_FLAG                  EQU 52  ; 52     34
   523                                  GET_INTERRUPT_VECTOR            EQU 53  ; 53     35
   524                                  GET_DRIVE_FREESPACE             EQU 54  ; 54     36
   525                                  CHAR_OPER                       EQU 55  ; 55     37
   526                                  INTERNATIONAL                   EQU 56  ; 56     38
   527                                  ; XENIX CALLS
   528                                  ;   Directory Group
   529                                  MKDIR                           EQU 57  ; 57     39
   530                                  RMDIR                           EQU 58  ; 58     3A
   531                                  CHDIR                           EQU 59  ; 59     3B
   532                                  ;   File Group
   533                                  CREAT                           EQU 60  ; 60     3C
   534                                  OPEN                            EQU 61  ; 61     3D
   535                                  CLOSE                           EQU 62  ; 62     3E
   536                                  READ                            EQU 63  ; 63     3F
   537                                  WRITE                           EQU 64  ; 64     40
   538                                  UNLINK                          EQU 65  ; 65     41
   539                                  LSEEK                           EQU 66  ; 66     42
   540                                  CHMOD                           EQU 67  ; 67     43
   541                                  IOCTL                           EQU 68  ; 68     44
   542                                  XDUP                            EQU 69  ; 69     45
   543                                  XDUP2                           EQU 70  ; 70     46
   544                                  CURRENT_DIR                     EQU 71  ; 71     47
   545                                  ;    Memory Group
   546                                  ALLOC                           EQU 72  ; 72     48
   547                                  DEALLOC                         EQU 73  ; 73     49
   548                                  SETBLOCK                        EQU 74  ; 74     4A
   549                                  ;    Process Group
   550                                  EXEC                            EQU 75  ; 75     4B
   551                                  EXIT                            EQU 76  ; 76     4C
   552                                  _WAIT				EQU 77  ; 77     4D
   553                                  FIND_FIRST                      EQU 78  ; 78     4E
   554                                  ;   Special Group
   555                                  FIND_NEXT                       EQU 79  ; 79     4F
   556                                  ; SPECIAL SYSTEM GROUP
   557                                  SET_CURRENT_PDB                 EQU 80  ; 80     50
   558                                  GET_CURRENT_PDB                 EQU 81  ; 81     51
   559                                  GET_IN_VARS                     EQU 82  ; 82     52
   560                                  SETDPB                          EQU 83  ; 83     53
   561                                  GET_VERIFY_ON_WRITE             EQU 84  ; 84     54
   562                                  DUP_PDB                         EQU 85  ; 85     55
   563                                  RENAME                          EQU 86  ; 86     56
   564                                  FILE_TIMES                      EQU 87  ; 87     57
   565                                  
   566                                  ; ----------------------------------------------------------------------
   567                                  ; SYSCONF.ASM (MSDOS 3.3 - 24/07/1987) 	
   568                                  ; ----------------------------------------------------------------------
   569                                  
   570                                  ;;	IF	STACKSW
   571                                  
   572                                  ;;
   573                                  ;; Internal Stack Parameters
   574                                  ;EntrySize		equ	8
   575                                  ;
   576                                  ;MinCount		equ	8
   577                                  ;DefaultCount		equ	9
   578                                  ;MaxCount		equ	64
   579                                  ;
   580                                  ;MinSize 		equ	32
   581                                  ;DefaultSize		equ	128
   582                                  ;MaxSize 		equ	512
   583                                  
   584                                  ;;	ENDIF
   585                                  
   586                                  
   587                                  ; ----------------------------------------------------------------------
   588                                  ; BIOSTRUC.INC (MSDOS 3.3 - 24/07/1987) 	
   589                                  ; ----------------------------------------------------------------------
   590                                  					  ;;Rev 3.30 Modification
   591                                  ; ROM BIOS CALL PACKET STRUCTURES					  
   592                                  									  
   593                                  ;*******************************					  
   594                                  ;System Service call ( Int 15h )					  
   595                                  ;*******************************					  
   596                                  ;Function AH = 0C0h, Return system configuration			  
   597                                  ;For PC and PCJR on return:						  
   598                                  ;	(AH)	= 80h							  
   599                                  ;	(CY)	= 1							  
   600                                  ;For PCXT, PC PORTABLE and PCAT on return:				  
   601                                  ;	(AH)	= 86h							  
   602                                  ;	(CY)	= 1							  
   603                                  ;For all others:							  
   604                                  ;	(AH)	= 0							  
   605                                  ;	(CY)	= 0							  
   606                                  ;	(ES:BX) = pointer to system descriptor vector in ROS		  
   607                                  ; System descriptor :							  
   608                                  ;	DW	xxxx		length of descriptor in bytes,		  
   609                                  ;				minimum length = 8			  
   610                                  ;	DB	xx		model byte				  
   611                                  ;				0FFh	= PC				  
   612                                  ;				0FEh	= PC/XT, Portable		  
   613                                  ;				0FDh	= PC/JR 			  
   614                                  ;				0FCh	= PC/AT				  
   615                                  ;				0F9h	= Convertable			  
   616                                  ;				0F8h	= Model 80			  
   617                                  ;				0E0 thru 0EFh = reserved		  
   618                                  ;									  
   619                                  ;	DB	xx		secondary model byte			  
   620                                  ;				000h	= PC1				  
   621                                  ;				000h	= PC/XT, Portable		  
   622                                  ;				000h	= PC/JR 			  
   623                                  ;				000h	= PC/AT 			  
   624                                  ;				001h	= PC/AT Model 339		  
   625                                  ;				003h	= PC/RT				  
   626                                  ;				000h	= Convertable			  
   627                                  ;									  
   628                                  ;	DB	xx		bios revision level			  
   629                                  ;				00 for first release, subsequent release  
   630                                  ;				of code with same model byte and	  
   631                                  ;				secondary model byte require revison level
   632                                  ;				to increase by one.			  
   633                                  ;									  
   634                                  ;	DB	xx		feature information byte 1		  
   635                                  ;				X0000000 = 1, bios use DMA channel 3	  
   636                                  ;					 = 0, DMA channel 3 not used	  
   637                                  ;									  
   638                                  ;				0X000000 = 1, 2nd Interrupt chip present  
   639                                  ;					 = 0, 2nd Interrupt chip not present
   640                                  ;									  
   641                                  ;				00X00000 = 1, Real Time Clock present	  
   642                                  ;					 = 0, Real Time Clock not present 
   643                                  ;									  
   644                                  ;				000X0000 = 1, Keyboard escape sequence(INT 15h)
   645                                  ;						called in keyboard interrupt
   646                                  ;						(Int 09h).		  
   647                                  ;					 = 0, Keyboard escape sequence not
   648                                  ;						called. 		  
   649                                  ;				0000XXXX reserved			  
   650                                  ;									  
   651                                  ;	DB	xx		feature information byte 2 - reserved	  
   652                                  ;									  
   653                                  ;	DB	xx		feature information byte 2 - reserved	  
   654                                  ;									  
   655                                  ;	DB	xx		feature information byte 2 - reserved	  
   656                                  ;									  
   657                                  ;	DB	xx		feature information byte 2 - reserved	  
   658                                  ;									  
   659                                  									  
   660                                  struc ROMBIOS_DESC		; BIOS_SYSTEM_DESCRIPTOR						  
   661 00000000 ????                    .bios_SD_leng:		resw 1				  
   662 00000002 ??                      .bios_SD_modelbyte:	resb 1					  
   663                                  .bios_SD_scnd_modelbyte: 
   664 00000003 ??                      			resb 1					  
   665 00000004 ??                      			resb 1					  
   666 00000005 ??                      .bios_SD_featurebyte1:	resb 1					  
   667 00000006 ????????                			resb 4					  
   668                                  endstruc					  
   669                                  									  
   670                                  ;FeatureByte1	bit map equates 					  
   671                                  DMAchannel3		equ 10000000b					  
   672                                  ScndIntController	equ 01000000b					  
   673                                  RealTimeClock		equ 00100000b					  
   674                                  KeyEscapeSeq		equ 00010000b					  
   675                                  					;;End of Modification
   676                                  
   677                                  ; ----------------------------------------------------------------------
   678                                  ; SYSVAR.INC (MSDOS 3.3 - 24/07/1987) 	
   679                                  ; ----------------------------------------------------------------------
   680                                  ; 05/06/2018 - Retro DOS v3.0
   681                                  
   682                                  ;	SCCSID = @(#)sysvar.asm 1.1 85/04/10
   683                                  struc SysInitVars
   684 00000000 ????????                .SYSI_DPB:    resd 1			; DPB chain
   685 00000004 ????????                .SYSI_SFT:    resd 1			; SFT chain
   686 00000008 ????????                .SYSI_CLOCK:  resd 1			; CLOCK device
   687 0000000C ????????                .SYSI_CON:    resd 1			; CON device
   688 00000010 ????                    .SYSI_MAXSEC: resw 1			; maximum sector size
   689 00000012 ????????                .SYSI_BUF:    resd 1			; buffer chain
   690 00000016 ????????                .SYSI_CDS:    resd 1			; CDS list
   691 0000001A ????????                .SYSI_FCB:    resd 1			; FCB chain
   692 0000001E ????                    .SYSI_KEEP:   resw 1			; keep count
   693 00000020 ??                      .SYSI_NUMIO:  resb 1			; Number of block devices
   694 00000021 ??                      .SYSI_NCDS:   resb 1			; number of CDS's
   695 00000022 ????????                .SYSI_DEV:    resd 1			; device list
   696                                  .size:
   697                                  endstruc
   698                                  
   699                                  ;This is added for more information exchage between DOS, BIOS.
   700                                  ;DOS will give the pointer to SysInitTable in ES:DI. - J.K. 5/29/86
   701                                  struc SysInitVars_Ext
   702 00000000 ????????                .SYSI_InitVars:	   resd 1	; Points to the above structure.
   703 00000004 ????????                .SYSI_Country_Tab: resd 1	; DOS_Country_cdpg_info
   704                                  endstruc
   705                                  
   706                                  ; 09/06/2018
   707                                  ; 08/06/2018 - Retro DOS v3.0 (MSDOS 3.3)
   708                                  SYSI_DPB    equ	0
   709                                  SYSI_SFT    equ 4
   710                                  SYSI_CLOCK  equ 8
   711                                  SYSI_CON    equ 12
   712                                  SYSI_MAXSEC equ 16
   713                                  SYSI_BUF    equ 18 		
   714                                  SYSI_CDS    equ 22
   715                                  SYSI_FCB    equ 26
   716                                  SYSI_KEEP   equ 30
   717                                  SYSI_NUMIO  equ	32
   718                                  SYSI_NCDS   equ	33
   719                                  SYSI_DEV    equ 34
   720                                  
   721                                  ; ----------------------------------------------------------------------
   722                                  ; CURDIR.INC (MSDOS 3.3 - 24/07/1987) 	
   723                                  ; ----------------------------------------------------------------------
   724                                  ; 08/06/2018 - Retro DOS v3.0
   725                                  
   726                                  ;	SCCSID = @(#)curdir.asm	1.1 85/04/10
   727                                  ;BREAK <Current directory list structure>
   728                                  									  
   729                                  ; CDS items are used by the internal routines to store cluster numbers and
   730                                  ; network identifiers for each logical name.  The ID field is used dually,
   731                                  ; both as net ID and for a cluster number for local devices.  In the case
   732                                  ; of local devices, the cluster number will be -1 if there is a potential
   733                                  ; of the disk being changed or if the path must be recracked.  The END
   734                                  ; field is the location of the end of the definition.  No .. is allowed
   735                                  ; past this point							
   736                                  
   737                                  DIRSTRLEN	EQU	64+3		; Max length in bytes of directory strings
   738                                  TEMPLEN 	EQU	DIRSTRLEN*2
   739                                  
   740                                  struc 		curdir_list
   741 00000000 <res 43h>               .cdir_text	resb	DIRSTRLEN	; text of assignment and curdir
   742 00000043 ????                    .cdir_flags	resw	1		; various flags
   743 00000045 ????????                .cdir_devptr	resd	1		; local pointer to DPB or net device
   744 00000049 ????                    .cdir_ID	resw	1		; cluster of current dir (net ID)
   745 0000004B ????                    		resw	1
   746 0000004D ????                    .cdir_usr_word	resw	1
   747 0000004F ????                    .cdir_end	resw	1		; end of assignment
   748                                  .size:
   749                                  endstruc
   750                                  
   751                                  curdirLen	EQU	curdir_list.size	; Needed for screwed up
   752                                  						; ASM87 which doesn't allow
   753                                  						; Size directive as a macro
   754                                  						; argument
   755                                  %define curdir_netID	dword [curdir_list.cdir_ID]
   756                                  
   757                                  ;Flag word masks
   758                                  curdir_isnet	EQU	1000000000000000B
   759                                  curdir_inuse	EQU	0100000000000000B
   760                                  curdir_splice	EQU	0010000000000000B
   761                                  curdir_local	EQU	0001000000000000B
   762                                  
   763                                  ; ----------------------------------------------------------------------
   764                                  ; SF.INC (MSDOS 3.3 - 24/07/1987) 	
   765                                  ; ----------------------------------------------------------------------
   766                                  ; 09/06/2018 - Retro DOS v3.0
   767                                  
   768                                  ;
   769                                  ; system file table
   770                                  ;
   771                                  
   772                                  struc	SF
   773 00000000 ????????                .SFLink:	resd	1
   774 00000004 ????                    .SFCount:	resw	1		; number of entries
   775 00000006 ????                    .SFTable:	resw	1		; beginning of array of the following
   776                                  .size:
   777                                  endstruc
   778                                  
   779                                  ;
   780                                  ; system file table entry
   781                                  ;
   782                                  
   783                                  struc	SF_ENTRY
   784 00000000 ????                    .sf_ref_count:	resw	1		; number of processes sharing entry
   785                                  					;   if FCB then ref count
   786 00000002 ????                    .sf_mode: 	resw	1		; mode of access or high bit on if FCB
   787 00000004 ??                      .sf_attr: 	resb	1		; attribute of file
   788 00000005 ????                    .sf_flags:	resw	1		;Bits 8-15
   789                                  					; Bit 15 = 1 if remote file
   790                                  					;	 = 0 if local file or device
   791                                  					; Bit 14 = 1 if date/time is not to be
   792                                  					;   set from clock at CLOSE.  Set by
   793                                  					;   FILETIMES and FCB_CLOSE.  Reset by
   794                                  					;   other reseters of the dirty bit
   795                                  					;   (WRITE)
   796                                  					; Bit 13 = Pipe bit (reserved)
   797                                  					;
   798                                  					; Bits 0-7 (old FCB_devid bits)
   799                                  					; If remote file or local file, bit
   800                                  					; 6=0 if dirty Device ID number, bits
   801                                  					; 0-5 if local file.
   802                                  					; bit 7=0 for local file, bit 7
   803                                  					;      =1 for local I/O device
   804                                  					; If local I/O device, bit 6=0 if EOF (input)
   805                                  					;		Bit 5=1 if Raw mode
   806                                  					;		Bit 0=1 if console input device
   807                                  					;		Bit 1=1 if console output device
   808                                  					;		Bit 2=1 if null device
   809                                  					;		Bit 3=1 if clock device
   810 00000007 ????????                .sf_devptr:	resd	1		; Points to DPB if local file, points
   811                                  					; to device header if local device,
   812                                  					; points to net device header if
   813                                  					; remote
   814 0000000B ????                    .sf_firclus:	resw	1		; First cluster of file (bit 15 = 0)
   815 0000000D ????                    .sf_time: 	resw	1		; Time associated with file
   816 0000000F ????                    .sf_date: 	resw	1		; Date associated with file
   817 00000011 ????????                .sf_size: 	resd	1		; Size associated with file
   818 00000015 ????????                .sf_position:	resd	1		; Read/Write pointer or LRU count for FCBs
   819                                  ;
   820                                  ; Starting here, the next 7 bytes may be used by the file system to store an
   821                                  ; ID
   822                                  ;
   823 00000019 ????                    .sf_cluspos:	resw	1		; Position of last cluster accessed
   824 0000001B ????                    .sf_lstclus:	resw	1		; Last cluster accessed
   825 0000001D ????                    .sf_dirsec:	resw	1		; Sector number of directory sector for this file
   826 0000001F ??                      .sf_dirpos:	resb	1		; Offset of this entry in the above
   827                                  ;
   828                                  ; End of 7 bytes of file-system specific info.
   829                                  ;
   830 00000020 <res Bh>                .sf_name:	resb	11		; 11 character name that is in the
   831                                  					; directory entry.  This is used by
   832                                  					; close to detect file deleted and
   833                                  					; disk changed errors.
   834                                  ; SHARING INFO
   835 0000002B ????????                .sf_chain:	resd	1		; link to next SF
   836 0000002F ????                    .sf_UID:	resw	1
   837 00000031 ????                    .sf_PID:	resw	1
   838 00000033 ????                    .sf_MFT:	resw	1
   839                                  .size:
   840                                  endstruc
   841                                  
   842                                  ; ----------------------------------------------------------------------
   843                                  ; DOSCNTRY.INC (MSDOS 3.3 - 24/07/1987) 	
   844                                  ; ----------------------------------------------------------------------
   845                                  ; 11/06/2018 - Retro DOS v3.0
   846                                  
   847                                  ;Equates for COUNTRY INFORMATION.
   848                                  SetCountryInfo		EQU	1	;country info
   849                                  SetUcase		EQU	2	;uppercase table
   850                                  SetLcase		EQU	3	;lowercase table (Reserved)
   851                                  SetUcaseFile		EQU	4	;uppercase file spec table
   852                                  SetFileList		EQU	5	;valid file character list
   853                                  SetCollate		EQU	6	;collating sequence
   854                                  SetDBCS 		EQU	7	;double byte character set
   855                                  SetALL			EQU	-1	;all the entries
   856                                  
   857                                  ;DOS country and code page information table structure.
   858                                  ;Internally, IBMDOS gives a pointer to this table.
   859                                  ;IBMBIO, MODE and NLSFUNC modules communicate with IBMDOS through
   860                                  ;this structure.
   861                                  
   862                                  struc country_cdpg_info ; DOS_country_cdpg_info
   863 00000000 ????????????????        .ccInfo_reserved :	resb	8	;reserved for internal use
   864 00000008 <res 40h>               .ccPath_CountrySys:	resb	64	;path and filename for country info
   865 00000048 ????                    .ccSysCodePage:		resw	1	;system code page id
   866 0000004A ????                    .ccNumber_of_entries:	resw	1 ; dw 5
   867 0000004C ??                      .ccSetUcase:		resb	1 ; db SetUcase ; = 2
   868 0000004D ????????                .ccUcase_ptr:		resd	1	;pointer to Ucase table
   869                                  
   870 00000051 ??                      .ccSetUcaseFile:	resb	1 ; db SetUcaseFile ; = 4
   871 00000052 ????????                .ccFileUcase_ptr: 	resd	1	;pointer to File Ucase table
   872                                  
   873 00000056 ??                      .ccSetFileList:		resb	1 ; db SetFileList ; = 5
   874 00000057 ????????                .ccFileChar_ptr:	resd	1	;pointer to File char list table
   875                                  
   876 0000005B ??                      .ccSetCollate:		resb	1 ; db SetCollate ; = 6
   877 0000005C ????????                .ccCollate_ptr:		resd	1	;pointer to collate table
   878                                  
   879 00000060 ??                      .ccSetCountryInfo:	resb	1 ; db SetCountryInfo ; = 1
   880 00000061 ????                    .ccCountryInfoLen:	resw	1	;length of country info
   881 00000063 ????                    .ccDosCountry:		resw	1	;system country code id
   882 00000065 ????                    .ccDosCodePage:		resw	1	;system code page id
   883 00000067 ????                    .ccDFormat:		resw	1	;date format
   884 00000069 ??????????              .ccCurSymbol:		resb	5 ; db "    ",0
   885                                  					;5 byte of (currency symbol+0)
   886 0000006E ????                    .cc1000Sep:		resb	2 ; db " ",0 ;2 byte of (1000 sep. + 0)
   887 00000070 ????                    .ccDecSep:		resb	2 ; db " ",0 ;2 byte of (Decimal sep. + 0)
   888 00000072 ????                    .ccDateSep:		resb	2 ; db " ",0 ;2 byte of (date sep. + 0)
   889 00000074 ????                    .ccTimeSep:		resb 	2 ; db " ",0 ;2 byte of (time sep. + 0)
   890 00000076 ??                      .ccCFormat:		resb	1 	;currency format flags
   891 00000077 ??                      .ccCSigDigits:		resb	1	;# of digits in currency
   892 00000078 ??                      .ccTFormat:		resb	1	;time format
   893 00000079 ????????                .ccMono_Ptr:		resd	1	;monocase routine entry point
   894 0000007D ????                    .ccListSep:		resb	2 ; db " ",0 ;data list separator
   895 0000007F <res Ah>                .ccReserved_area: 	resw	5 ; dw 5 dup(?) ;reserved
   896                                  .size:
   897                                  endstruc
   898                                  
   899                                  NEW_COUNTRY_SIZE    equ  country_cdpg_info.size - country_cdpg_info.ccDosCountry
   900                                  
   901                                  ; ----------------------------------------------------------------------
   902                                  
   903                                          ;INCLUDE DOSSYM.ASM
   904                                          ;INCLUDE DEVSYM.ASM
   905                                  
   906                                          ;IF      NOT IBM
   907                                          ;IF      NOT IBMJAPVER
   908                                          ;EXTRN   RE_INIT:FAR
   909                                          ;ENDIF
   910                                          ;ENDIF
   911                                  
   912                                  ;SYSINITSEG      SEGMENT PUBLIC 'SYSTEM_INIT'
   913                                  
   914                                  	;ASSUME  CS:SYSINITSEG,DS:NOTHING,ES:NOTHING,SS:NOTHING
   915                                  
   916                                  SYSINITSEG:
   917                                  
   918                                  	[org 0]
   919                                  
   920                                  	; 04/06/2018 - Retro DOS v3.0 (MSDOS 3.3)
   921                                  
   922                                  	;EXTRN	BADCOM:BYTE					
   923                                  	;EXTRN	SYSSIZE:BYTE					
   924                                  	;EXTRN	CONDEV:BYTE,AUXDEV:BYTE,PRNDEV:BYTE,COMMND:BYTE
   925                                  	;EXTRN	DeviceParameters:byte
   926                                  				
   927                                  	;EXTRN	INT24:NEAR,MEM_ERR:NEAR
   928                                  	;EXTRN	DOCONF:NEAR
   929                                  
   930                                          ;PUBLIC  CURRENT_DOS_LOCATION
   931                                          ;PUBLIC  FINAL_DOS_LOCATION
   932                                          ;PUBLIC  DEVICE_LIST
   933                                          ;PUBLIC  MEMORY_SIZE
   934                                          ;PUBLIC  DEFAULT_DRIVE
   935                                          ;PUBLIC  BUFFERS
   936                                          ;PUBLIC  FILES
   937                                          ;PUBLIC  SYSINIT
   938                                  	;PUBLIC	 CNTRYFILEHANDLE
   939                                  	;PUBLIC	 COMMAND_LINE
   940                                  
   941                                  ; 05/07/2018
   942                                  
   943                                  ; ----------------------------------------------------------------------
   944                                  ; SYSINIT1.ASM (MSDOS 3.3 - 24/07/1987) 	
   945                                  ; ----------------------------------------------------------------------
   946                                  
   947                                  ;Equates for Main stack and stack Initialization program
   948                                  	;IF	STACKSW
   949                                  cr			equ	0Dh
   950                                  lf			equ	0Ah
   951                                  
   952                                  EntrySize		equ	8
   953                                  
   954                                  MinCount		equ	8
   955                                  DefaultCount		equ	9
   956                                  MaxCount		equ	64
   957                                  
   958                                  MinSize 		equ	32
   959                                  DefaultSize		equ	128
   960                                  MaxSize 		equ	512
   961                                  
   962                                  ;%define AllocByte	byte [es:bp+0]
   963                                  %define	AllocByte	byte [es:bp] ; 05/07/2019
   964                                  %define IntLevel	byte [es:bp+1]
   965                                  %define SavedSP 	word [es:bp+2]
   966                                  %define SavedSS 	word [es:bp+4]
   967                                  %define NewSP		word [es:bp+6]
   968                                  
   969                                  Free			equ	0
   970                                  Allocated		equ	1
   971                                  Overflowed		equ	2
   972                                  Clobbered		equ	3
   973                                  	;END IF
   974                                  
   975                                  ; SYSINITSEG	SEGMENT PUBLIC 'SYSTEM_INIT'
   976                                  
   977                                  SYSINIT$:
   978                                  	;IF	STACKSW 
   979                                  	; include MSSTACK.INC	;Main stack program and data definitions
   980                                  	; include STKMES.INC	;Fatal stack error message
   981                                  	;   public Endstackcode
   982                                  ;Endstackcode	label byte
   983                                  	;ENDIF
   984                                  
   985                                  ; 05/07/2018
   986                                  ; ----------------------------------------------------------------------
   987                                  ; MSSTACK.INC - MSDOS 3.3 (02/02/1988)
   988                                  ; ----------------------------------------------------------------------
   989                                  ; 04/06/2018 - Retro DOS v3.0
   990                                  
   991                                  ;	MSStack.inc
   992                                  ;
   993                                  ;	Interrupt level 2, 3, 4, 5, 6, 7,(10, 11, 12, 14, 15 - AT level)
   994                                  ;	should follow the standard Interrupt Sharing Scheme which has
   995                                  ;	a standard header structure.
   996                                  ;	Fyi, the following shows the relations between
   997                                  ;	the interrupt vector and interrupt level.
   998                                  ; VEC(Hex)    2  8  9  A  B  C	D  E  70  72  73  74  76  77
   999                                  ; LVL(Deci)   9  0  1  2  3  4	5  6   8  10  11  12  14  15
  1000                                  ;	MSSTACK module modifies the following interrupt vectors
  1001                                  ;	to meet the standard Interrupt Sharing standard;
  1002                                  ;	  A, B, C, D, E, 72, 73, 74, 76, 77.
  1003                                  ;	Also, for interrupt level 7 and 15, the FirstFlag in a standard header
  1004                                  ;	should be initialized to indicat whether this interrupt handler is
  1005                                  ;	the first (= 80h) or not.  The FirstFlag entry of INT77h's
  1006                                  ;	program header is initialized in STKINIT.INC module.
  1007                                  ;	FirstFlag is only meaningful for interrupt level 7 and 15.
  1008                                  ;
  1009                                  
  1010                                  ;  User specifies the number of stack elements - default = 9
  1011                                  ;						 minimum = 8
  1012                                  ;						 maximum = 64
  1013                                  ;
  1014                                  ;  Intercepts Asynchronous Hardware Interrupts only
  1015                                  ;
  1016                                  ;  Picks a stack from pool of stacks and switches to it
  1017                                  ;
  1018                                  ;  Calls the previously saved interrupt vector after pushing flags
  1019                                  ;
  1020                                  ;  On return, returns the stack to the stack pool
  1021                                  ;
  1022                                  
  1023                                  ; This is a modification of STACKS:
  1024                                  ; 1. To fix a bug which was causing the program to take up too much space.
  1025                                  ; 2. To dispense stack space from hi-mem first rather than low-mem first.
  1026                                  ;    . Clobbers the stack that got too big instead of innocent stack
  1027                                  ;    . Allows system to work if the only stack that got too big was the most
  1028                                  ;      deeply nested one
  1029                                  ; 3. Disables NMI interrupts while setting the NMI vector.
  1030                                  ; 4. Does not intercept any interupts on a PCjr.
  1031                                  ; 5. Double checks that a nested interrupt didn't get the same stack.
  1032                                  ; 6. Intercepts Ints 70, 72-77 for PC-ATs and other future products
  1033                                  
  1034                                  ;The following variables are for MSSTACK.inc
  1035                                  		;EVEN
  1036                                  ;align 2
  1037 00000000 0000                    		dw	0	; SPARE FIELD BUT LEAVE THESE IN ORDER
  1038 00000002 0000                    StackCount:	dw	0
  1039 00000004 0000                    StackAt: 	dw	0
  1040 00000006 0000                    StackSize:	dw	0
  1041 00000008 0000                    Stacks:		dw	0
  1042 0000000A 0000                    		dw	0
  1043                                  
  1044 0000000C [0800]                  FirstEntry:	dw	Stacks
  1045 0000000E [4800]                  LastEntry:	dw	Stacks+(DefaultCount*EntrySize)-EntrySize
  1046 00000010 [4800]                  NextEntry:	dw	Stacks+(DefaultCount*EntrySize)-EntrySize
  1047                                  
  1048                                  ;End of variables defined for MSSTACK.
  1049                                  
  1050                                  ;********************************************************************
  1051                                  ; THESE ARE THE INDIVIDUAL INTERRUPT HANDLERS
  1052                                  
  1053                                  	;IRP	A,<02,08,09,70>
  1054                                  	;IntSharingFlag=0
  1055                                  	;Stack_Main &A
  1056                                  	;ENDM
  1057                                  
  1058                                  ; 04/06/2018 - Retro DOS v3.0 ("Stack_Main" macro -> normal code)
  1059                                  
  1060                                  ;*******************************************************************
  1061                                  ;Macro Interrupt handler for the ordinary interrupt vectors and
  1062                                  ;the shared interrupt vectors.
  1063                                  ;*****************************
  1064                                  ;Stack_Main	MACRO	AA
  1065                                  ;	ASSUME	DS:NOTHING
  1066                                  ;	ASSUME	ES:NOTHING
  1067                                  ;	ASSUME	SS:NOTHING
  1068                                  ;PUBLIC	Int&AA
  1069                                  ;PUBLIC	Old&AA
  1070                                  ;;-----------------------------
  1071                                  ;	ife	IntSharingFlag		;if not IntSharingFlag
  1072                                  ;;-----------------------------
  1073                                  
  1074 00000012 00000000                Old02:	DD	0
  1075                                  
  1076                                  Int02:
  1077                                  
  1078                                  ; This patches INTERRUPT 75h to be "unhooked".  We do this Wierdness,
  1079                                  ; rather than never hooking INT 75h, to maintain maximum compat. with IBMs
  1080                                  ; post production patch.
  1081                                  
  1082 00000016 50                      	push	ax
  1083                                  
  1084                                  ; *********************************************************************
  1085                                  ;
  1086                                  ; This is special support for the P12 / NMI handler
  1087                                  ;
  1088                                  ;	On the P12, there is a situation where an NMI can be caused by
  1089                                  ;	using the "OUT" instructions to certain ports.  When this
  1090                                  ;	occurs, the P12 hardware *GUARANTEES* that **NOTHING** can stop
  1091                                  ;	the NMI or interfere with getting to the NMI handler.  This
  1092                                  ;	includes other type of interrupts (hardware and software), and
  1093                                  ;	also includes other type of NMI's.  When any NMI has occured,
  1094                                  ;	no other interrtupt (hardware, software or NMI) can occur until
  1095                                  ;	the software takes specific steps to allow further interrupting.
  1096                                  ;
  1097                                  ;	For P12, the situation where the NMI is generated by the "OUT"
  1098                                  ;	to a control port requires "fixing-up" and re-attempting.  In
  1099                                  ;	otherwords, it is actually a "restartable exception".  In this
  1100                                  ;	case, the software handler must be able to get to the stack in
  1101                                  ;	order to figure out what instruction caused the problem, where
  1102                                  ;	it was "OUT"ing to and what value it was "OUT"ing.  Therefore,
  1103                                  ;	we will not switch stacks in this situation.  This situation is
  1104                                  ;	detected by interrogating port 62h, and checking for a bit value
  1105                                  ;	of 80h.  If set, *****DO NOT SWITCH STACKS*****.
  1106                                  ;
  1107                                  ; *********************************************************************
  1108                                  
  1109 00000017 1E                      	push	ds
  1110 00000018 B800F0                  	mov	ax,0F000h
  1111 0000001B 8ED8                    	mov	ds,ax
  1112 0000001D 803EFEFFF9              	cmp	byte [0FFFEh],0F9h	;check if P12
  1113 00000022 1F                      	pop	ds
  1114 00000023 750C                    	jne	short Normal02
  1115                                  
  1116 00000025 E462                    	in	al,62h
  1117 00000027 A880                    	test	al,80h
  1118 00000029 7406                    	jz	short Normal02
  1119                                  
  1120                                  Special02:
  1121 0000002B 58                      	pop	ax
  1122                                  	; 17/06/2018
  1123 0000002C 2EFF2E[1200]            	jmp	far [cs:Old02]
  1124                                  
  1125                                  Normal02:
  1126                                  
  1127                                  ; *********************************************************************
  1128                                  
  1129 00000031 55                      	push	bp
  1130 00000032 06                      	push	es
  1131 00000033 2E8E06[0A00]            	mov	es, [cs:Stacks+2]	; Get segment of stacks
  1132                                  
  1133 00000038 2E8B2E[1000]            	mov	bp,[cs:NextEntry]	; get most likely candidate
  1134 0000003D B001                    	mov	al,Allocated
  1135 0000003F 26864600                	xchg	AllocByte,al		; grab the entry
  1136 00000043 3C00                    	cmp	al,Free 		; still avail?
  1137 00000045 7542                    	jne	short NotFree02
  1138                                  
  1139 00000047 2E832E[1000]08          	sub	word [cs:NextEntry],EntrySize ; set for next interrupt
  1140                                  
  1141                                  Found02:
  1142 0000004D 26896602                	mov	SavedSP,sp		; save sp value
  1143 00000051 268C5604                	mov	SavedSS,ss		; save ss also
  1144                                  ;	mov	IntLevel,02h		; save the int level
  1145                                  
  1146 00000055 89E8                    	mov	ax,bp			; temp save of table offset
  1147                                  
  1148 00000057 268B6E06                	mov	bp,NewSP		; get new SP value
  1149 0000005B 26394600                	cmp	[es:bp],ax		; check for offset into table
  1150 0000005F 7535                    	jne	short FoundBad02
  1151                                  
  1152 00000061 8CC0                    	mov	ax,es			; point ss,sp to the new stack
  1153 00000063 8ED0                    	mov	ss,ax
  1154 00000065 89EC                    	mov	sp,bp
  1155                                  
  1156 00000067 9C                      	pushf				; go execute the real interrupt handler
  1157                                  	; 17/06/2018
  1158 00000068 2EFF1E[1200]            	call	far [cs:Old02]		;  which will iret back to here
  1159                                  
  1160 0000006D 89E5                    	mov	bp,sp			; retrieve the table offset for us
  1161 0000006F 268B6E00                	mov	bp,[es:bp]		;  but leave it on the stack
  1162 00000073 268E5604                	mov	ss,SavedSS		; get old stack back
  1163 00000077 268B6602                	mov	sp,SavedSP
  1164                                  
  1165                                  ;	cmp	AllocByte,Allocated	; If an error occured,
  1166                                  ;	jne	short NewError02	;  do not free us
  1167                                  
  1168 0000007B 26C6460000              	mov	AllocByte,Free		; free the entry
  1169 00000080 2E892E[1000]            	mov	[cs:NextEntry],bp		; setup to use next time
  1170                                  
  1171                                  NewError02:
  1172 00000085 07                      	pop	es
  1173 00000086 5D                      	pop	bp			; saved on entry
  1174 00000087 58                      	pop	ax			; saved on entry
  1175                                  
  1176                                  IntRet_02:
  1177 00000088 CF                      	iret				; done with this interrupt
  1178                                  
  1179                                  NotFree02:
  1180 00000089 3C01                    	cmp	al,Allocated		; error flag
  1181 0000008B 7404                    	je	short FindNext02	;  no, continue
  1182 0000008D 26864600                	xchg	AllocByte,al		;  yes, restore error value
  1183                                  
  1184                                  FindNext02:
  1185 00000091 E8D406                  	call	LongPath
  1186 00000094 EBB7                    	jmp	short Found02
  1187                                  
  1188                                  FoundBad02:
  1189 00000096 2E3B2E[0C00]            	cmp	bp,[cs:FirstEntry]
  1190 0000009B 72F4                    	jc	short FindNext02
  1191 0000009D 89C5                    	mov	bp,ax			; flag this entry
  1192 0000009F 26C6460003              	mov	AllocByte,Clobbered
  1193                                  ;	add	bp,EntrySize		;  and previous entry
  1194                                  ;	mov	AllocByte,Overflowed
  1195                                  ;	sub	bp,EntrySize
  1196 000000A4 EBEB                    	jmp	short FindNext02	; keep looking
  1197                                  
  1198 000000A6 00000000                Old08:	DD	0
  1199                                  
  1200                                  Int08:	
  1201 000000AA 50                      	push	ax
  1202 000000AB 55                      	push	bp
  1203 000000AC 06                      	push	es
  1204 000000AD 2E8E06[0A00]            	mov	es,[cs:Stacks+2]	; Get segment of stacks
  1205 000000B2 2E8B2E[1000]            	mov	bp,[cs:NextEntry]	; get most likely candidate
  1206 000000B7 B001                    	mov	al,Allocated
  1207 000000B9 26864600                	xchg	AllocByte,al		; grab the entry
  1208 000000BD 3C00                    	cmp	al,Free 		; still avail?
  1209 000000BF 7542                    	jne	short NotFree08
  1210                                  
  1211 000000C1 2E832E[1000]08          	sub	word [cs:NextEntry],EntrySize ; set for next interrupt
  1212                                  
  1213                                  Found08:
  1214 000000C7 26896602                	mov	SavedSP,sp		; save sp value
  1215 000000CB 268C5604                	mov	SavedSS,ss		; save ss also
  1216                                  ;	mov	IntLevel,08h		; save the int level
  1217                                  
  1218 000000CF 89E8                    	mov	ax,bp			; temp save of table offset
  1219                                  
  1220 000000D1 268B6E06                	mov	bp,NewSP		; get new SP value
  1221 000000D5 26394600                	cmp	[es:bp],ax		; check for offset into table
  1222 000000D9 7535                    	jne	short FoundBad08
  1223                                  
  1224 000000DB 8CC0                    	mov	ax,es			; point ss,sp to the new stack
  1225 000000DD 8ED0                    	mov	ss,ax
  1226 000000DF 89EC                    	mov	sp,bp
  1227                                  
  1228 000000E1 9C                      	pushf				; go execute the real interrupt handler
  1229                                  	; 17/06/2018
  1230 000000E2 2EFF1E[A600]            	call	far [cs:Old08]		;  which will iret back to here
  1231                                  
  1232 000000E7 89E5                    	mov	bp,sp			; retrieve the table offset for us
  1233 000000E9 268B6E00                	mov	bp,[es:bp]		;  but leave it on the stack
  1234 000000ED 268E5604                	mov	ss,SavedSS		; get old stack back
  1235 000000F1 268B6602                	mov	sp,SavedSP
  1236                                  
  1237                                  ;	cmp	AllocByte,Allocated	; If an error occured,
  1238                                  ;	jne	short NewError08	;  do not free us
  1239                                  
  1240 000000F5 26C6460000              	mov	AllocByte,Free		; free the entry
  1241 000000FA 2E892E[1000]            	mov	[cs:NextEntry],bp	; setup to use next time
  1242                                  
  1243                                  NewError08:
  1244 000000FF 07                      	pop	es
  1245 00000100 5D                      	pop	bp			; saved on entry
  1246 00000101 58                      	pop	ax			; saved on entry
  1247                                  
  1248                                  IntRet_08:
  1249 00000102 CF                      	iret				; done with this interrupt
  1250                                  
  1251                                  NotFree08:
  1252 00000103 3C01                    	cmp	al,Allocated		; error flag
  1253 00000105 7404                    	je	short FindNext08	;  no, continue
  1254 00000107 26864600                	xchg	AllocByte,al		;  yes, restore error value
  1255                                  
  1256                                  FindNext08:
  1257 0000010B E85A06                  	call	LongPath
  1258 0000010E EBB7                    	jmp	short Found08
  1259                                  
  1260                                  FoundBad08:
  1261 00000110 2E3B2E[0C00]            	cmp	bp,[cs:FirstEntry]
  1262 00000115 72F4                    	jc	short FindNext08
  1263 00000117 89C5                    	mov	bp,ax			; flag this entry
  1264 00000119 26C6460003              	mov	AllocByte,Clobbered
  1265                                  ;	add	bp,EntrySize		;  and previous entry
  1266                                  ;	mov	AllocByte,Overflowed
  1267                                  ;	sub	bp,EntrySize
  1268 0000011E EBEB                    	jmp	short FindNext08	; keep looking
  1269                                  
  1270 00000120 00000000                Old09:	DD	0
  1271                                  
  1272                                  Int09:
  1273                                  ;
  1274                                  ; Keyboard interrupt must have a three byte jump, a NOP and a zero byte
  1275                                  ; as its first instruction for compatibility reasons
  1276                                  
  1277 00000124 EB02                    	jmp	short Keyboard_lbl
  1278 00000126 90                      	nop
  1279 00000127 00                      	db	0
  1280                                  
  1281                                  Keyboard_lbl:
  1282 00000128 50                      	push	ax
  1283 00000129 55                      	push	bp
  1284 0000012A 06                      	push	es
  1285 0000012B 2E8E06[0A00]            	mov	es,[cs:Stacks+2]	; Get segment of stacks
  1286                                  
  1287 00000130 2E8B2E[1000]            	mov	bp,[cs:NextEntry]	; get most likely candidate
  1288 00000135 B001                    	mov	al,Allocated
  1289 00000137 26864600                	xchg	AllocByte,al		; grab the entry
  1290 0000013B 3C00                    	cmp	al,Free 		; still avail?
  1291 0000013D 7542                    	jne	short NotFree09
  1292                                  
  1293 0000013F 2E832E[1000]08          	sub	word [cs:NextEntry],EntrySize ; set for next interrupt
  1294                                  
  1295                                  Found09:
  1296 00000145 26896602                	mov	SavedSP,sp		; save sp value
  1297 00000149 268C5604                	mov	SavedSS,ss		; save ss also
  1298                                  ;	mov	IntLevel,09h		; save the int level
  1299                                  
  1300 0000014D 89E8                    	mov	ax,bp			; temp save of table offset
  1301                                  
  1302 0000014F 268B6E06                	mov	bp,NewSP		; get new SP value
  1303 00000153 26394600                	cmp	[es:bp],ax		; check for offset into table
  1304 00000157 7535                    	jne	short FoundBad09
  1305                                  
  1306 00000159 8CC0                    	mov	ax,es			; point ss,sp to the new stack
  1307 0000015B 8ED0                    	mov	ss,ax
  1308 0000015D 89EC                    	mov	sp,bp
  1309                                  
  1310 0000015F 9C                      	pushf				; go execute the real interrupt handler
  1311                                  	; 17/06/2018
  1312 00000160 2EFF1E[2001]            	call	far [cs:Old09]		;  which will iret back to here
  1313                                  
  1314 00000165 89E5                    	mov	bp,sp			; retrieve the table offset for us
  1315 00000167 268B6E00                	mov	bp,[es:bp]		;  but leave it on the stack
  1316 0000016B 268E5604                	mov	ss,SavedSS	     	; get old stack back
  1317 0000016F 268B6602                	mov	sp,SavedSP
  1318                                  
  1319                                  ;	cmp	AllocByte,Allocated	; If an error occured,
  1320                                  ;	jne	short NewError09	;  do not free us
  1321                                  
  1322 00000173 26C6460000              	mov	AllocByte,Free		; free the entry
  1323 00000178 2E892E[1000]            	mov	[cs:NextEntry],bp	; setup to use next time
  1324                                  
  1325                                  NewError09:
  1326 0000017D 07                      	pop	es
  1327 0000017E 5D                      	pop	bp			; saved on entry
  1328 0000017F 58                      	pop	ax			; saved on entry
  1329                                  
  1330                                  IntRet_09:
  1331 00000180 CF                      	iret				; done with this interrupt
  1332                                  
  1333                                  NotFree09:
  1334 00000181 3C01                    	cmp	al,Allocated		; error flag
  1335 00000183 7404                    	je	short FindNext09	;  no, continue
  1336 00000185 26864600                	xchg	AllocByte,al		;  yes, restore error value
  1337                                  
  1338                                  FindNext09:
  1339 00000189 E8DC05                  	call	LongPath
  1340 0000018C EBB7                    	jmp	short Found09
  1341                                  
  1342                                  FoundBad09:
  1343 0000018E 2E3B2E[0C00]            	cmp	bp,[cs:FirstEntry]
  1344 00000193 72F4                    	jc	short FindNext09
  1345 00000195 89C5                    	mov	bp,ax			; flag this entry
  1346 00000197 26C6460003              	mov	AllocByte,Clobbered
  1347                                  ;	add	bp,EntrySize		;  and previous entry
  1348                                  ;	mov	AllocByte,Overflowed
  1349                                  ;	sub	bp,EntrySize
  1350 0000019C EBEB                    	jmp	short FindNext09	; keep looking
  1351                                  
  1352 0000019E 00000000                Old70:	DD	0
  1353                                  
  1354                                  Int70:
  1355 000001A2 50                      	push	ax
  1356 000001A3 55                      	push	bp
  1357 000001A4 06                      	push	es
  1358 000001A5 2E8E06[0A00]            	mov	es,[cs:Stacks+2]	; Get segment of stacks
  1359                                  
  1360 000001AA 2E8B2E[1000]            	mov	bp,[cs:NextEntry]	; get most likely candidate
  1361 000001AF B001                    	mov	al,Allocated
  1362 000001B1 26864600                	xchg	AllocByte,al		; grab the entry
  1363 000001B5 3C00                    	cmp	al,Free 		; still avail?
  1364 000001B7 7542                    	jne	short NotFree70
  1365                                  
  1366 000001B9 2E832E[1000]08          	sub	word [cs:NextEntry],EntrySize ; set for next interrupt
  1367                                  
  1368                                  Found70:
  1369 000001BF 26896602                	mov	SavedSP,sp		; save sp value
  1370 000001C3 268C5604                	mov	SavedSS,ss		; save ss also
  1371                                  ;	mov	IntLevel,70h		; save the int level
  1372                                  
  1373 000001C7 89E8                    	mov	ax,bp			; temp save of table offset
  1374                                  
  1375 000001C9 268B6E06                	mov	bp,NewSP		; get new SP value
  1376 000001CD 26394600                	cmp	[es:bp],ax		; check for offset into table
  1377 000001D1 7535                    	jne	short FoundBad70
  1378                                  
  1379 000001D3 8CC0                    	mov	ax,es			; point ss,sp to the new stack
  1380 000001D5 8ED0                    	mov	ss,ax
  1381 000001D7 89EC                    	mov	sp,bp
  1382                                  
  1383 000001D9 9C                      	pushf				; go execute the real interrupt handler
  1384                                  	; 17/06/2018
  1385 000001DA 2EFF1E[9E01]            	call	far [cs:Old70]		;  which will iret back to here
  1386                                  
  1387 000001DF 89E5                    	mov	bp,sp			; retrieve the table offset for us
  1388 000001E1 268B6E00                	mov	bp,[es:bp]		;  but leave it on the stack
  1389 000001E5 268E5604                	mov	ss,SavedSS		; get old stack back
  1390 000001E9 268B6602                	mov	sp,SavedSP
  1391                                  
  1392                                  ;	cmp	AllocByte,Allocated	; If an error occured,
  1393                                  ;	jne	short NewError70	;  do not free us
  1394                                  
  1395 000001ED 26C6460000              	mov	AllocByte,Free		; free the entry
  1396 000001F2 2E892E[1000]            	mov	[cs:NextEntry],bp	; setup to use next time
  1397                                  
  1398                                  NewError70:
  1399 000001F7 07                      	pop	es
  1400 000001F8 5D                      	pop	bp			; saved on entry
  1401 000001F9 58                      	pop	ax			; saved on entry
  1402                                  
  1403                                  IntRet_70:
  1404 000001FA CF                      	iret				; done with this interrupt
  1405                                  
  1406                                  NotFree70:
  1407 000001FB 3C01                    	cmp	al,Allocated		; error flag
  1408 000001FD 7404                    	je	short FindNext70	;  no, continue
  1409 000001FF 26864600                	xchg	AllocByte,al		;  yes, restore error value
  1410                                  
  1411                                  FindNext70:
  1412 00000203 E86205                  	call	LongPath
  1413 00000206 EBB7                    	jmp	short Found70
  1414                                  
  1415                                  FoundBad70:
  1416 00000208 2E3B2E[0C00]            	cmp	bp,[cs:FirstEntry]
  1417 0000020D 72F4                    	jc	short FindNext70
  1418 0000020F 89C5                    	mov	bp,ax			; flag this entry
  1419 00000211 26C6460003              	mov	AllocByte,Clobbered
  1420                                  ;	add	bp,EntrySize		;  and previous entry
  1421                                  ;	mov	AllocByte,Overflowed
  1422                                  ;	sub	bp,EntrySize
  1423 00000216 EBEB                    	jmp	short FindNext70	; keep looking
  1424                                  
  1425                                  ;********************************************************************
  1426                                  
  1427                                  	;IRP	A,<0A,0B,0C,0D,0E,72,73,74,76,77>
  1428                                  	;IntSharingFlag=1
  1429                                  	;Stack_Main &A
  1430                                  	;ENDM
  1431                                  
  1432                                  ;********************************************************************
  1433                                  
  1434                                  ;Stack_Main	MACRO	AA
  1435                                  ;	ASSUME	DS:NOTHING
  1436                                  ;	ASSUME	ES:NOTHING
  1437                                  ;	ASSUME	SS:NOTHING
  1438                                  ;PUBLIC	Int&AA
  1439                                  ;PUBLIC	Old&AA
  1440                                  ;-----------------------------
  1441                                  ;	ife	IntSharingFlag		;if not IntSharingFlag
  1442                                  ;;-----------------------------
  1443                                  ;	Old&AA	DD	0
  1444                                  ;Int&AA	PROC	FAR
  1445                                  ;;-----------------------------
  1446                                  ;    else				;for shared interrupt. A Header exists.
  1447                                  
  1448                                  ;PUBLIC	FirstFlag&AA
  1449                                  ;Int&AA	PROC	FAR
  1450                                  ;	jmp	short	  Entry_Int&AA&_Stk
  1451                                  ;	Old&AA	dd	  0		;Forward pointer
  1452                                  ;		dw	  424Bh 	;compatible signature for Int. Sharing
  1453                                  ;	FirstFlag&AA db   0		;the firstly hooked.
  1454                                  ;	jmp	short	IntRet_&AA	;Reset routine. We don't care this.
  1455                                  ;		db	  7 dup (0)	;Reserved for future.
  1456                                  ;Entry_Int&AA&_Stk:
  1457                                  ;;-----------------------------
  1458                                  ;	endif
  1459                                  ;;-----------------------------
  1460                                  
  1461                                  Int0A:
  1462 00000218 EB10                    	jmp	short Entry_Int0A_Stk
  1463 0000021A 00000000                Old0A:	dd	0	
  1464 0000021E 4B42                    	dw	424Bh
  1465                                  FirstFlag0A:
  1466 00000220 00                      	db	0
  1467 00000221 EB5F                    	jmp	short IntRet_0A
  1468 00000223 00<rep 7h>              	times	7 db 0
  1469                                  
  1470                                  Entry_Int0A_Stk:
  1471 0000022A 50                      	push	ax
  1472 0000022B 55                      	push	bp
  1473 0000022C 06                      	push	es
  1474 0000022D 2E8E06[0A00]            	mov	es,[cs:Stacks+2]	; Get segment of stacks
  1475 00000232 2E8B2E[1000]            	mov	bp,[cs:NextEntry]	; get most likely candidate
  1476 00000237 B001                    	mov	al,Allocated
  1477 00000239 26864600                	xchg	AllocByte,al		; grab the entry
  1478 0000023D 3C00                    	cmp	al,Free 		; still avail?
  1479 0000023F 7542                    	jne	short NotFree0A
  1480                                  
  1481 00000241 2E832E[1000]08          	sub	word [cs:NextEntry],EntrySize ; set for next interrupt
  1482                                  
  1483                                  Found0A:
  1484 00000247 26896602                	mov	SavedSP,sp		; save sp value
  1485 0000024B 268C5604                	mov	SavedSS,ss		; save ss also
  1486                                  ;	mov	IntLevel,0Ah		; save the int level
  1487                                  
  1488 0000024F 89E8                    	mov	ax,bp			; temp save of table offset
  1489                                  
  1490 00000251 268B6E06                	mov	bp,NewSP		; get new SP value
  1491 00000255 26394600                	cmp	[es:bp],ax		; check for offset into table
  1492 00000259 7535                    	jne	short FoundBad0A
  1493                                  
  1494 0000025B 8CC0                    	mov	ax,es			; point ss,sp to the new stack
  1495 0000025D 8ED0                    	mov	ss,ax
  1496 0000025F 89EC                    	mov	sp,bp
  1497                                  
  1498 00000261 9C                      	pushf				; go execute the real interrupt handler
  1499                                  	; 17/06/2018
  1500 00000262 2EFF1E[1A02]            	call	far [cs:Old0A]		;  which will iret back to here
  1501                                  
  1502 00000267 89E5                    	mov	bp,sp			; retrieve the table offset for us
  1503 00000269 268B6E00                	mov	bp,[es:bp]		;  but leave it on the stack
  1504 0000026D 268E5604                	mov	ss,SavedSS		; get old stack back
  1505 00000271 268B6602                	mov	sp,SavedSP
  1506                                  
  1507                                  ;	cmp	AllocByte,Allocated	; If an error occured,
  1508                                  ;	jne	short NewError0A	;  do not free us
  1509                                  
  1510 00000275 26C6460000              	mov	AllocByte,Free		; free the entry
  1511 0000027A 2E892E[1000]            	mov	[cs:NextEntry],bp	; setup to use next time
  1512                                  
  1513                                  NewError0A:
  1514 0000027F 07                      	pop	es
  1515 00000280 5D                      	pop	bp			; saved on entry
  1516 00000281 58                      	pop	ax			; saved on entry
  1517                                  
  1518                                  IntRet_0A:
  1519 00000282 CF                      	iret				; done with this interrupt
  1520                                  
  1521                                  NotFree0A:
  1522 00000283 3C01                    	cmp	al,Allocated		; error flag
  1523 00000285 7404                    	je	short FindNext0A	;  no, continue
  1524 00000287 26864600                	xchg	AllocByte,al		;  yes, restore error value
  1525                                  
  1526                                  FindNext0A:
  1527 0000028B E8DA04                  	call	LongPath
  1528 0000028E EBB7                    	jmp	short Found0A
  1529                                  
  1530                                  FoundBad0A:
  1531 00000290 2E3B2E[0C00]            	cmp	bp,[cs:FirstEntry]
  1532 00000295 72F4                    	jc	short FindNext0A
  1533 00000297 89C5                    	mov	bp,ax			; flag this entry
  1534 00000299 26C6460003              	mov	AllocByte,Clobbered
  1535                                  ;	add	bp,EntrySize		;  and previous entry
  1536                                  ;	mov	AllocByte,Overflowed
  1537                                  ;	sub	bp,EntrySize
  1538 0000029E EBEB                    	jmp	short FindNext0A	; keep looking
  1539                                  
  1540                                  Int0B:
  1541 000002A0 EB10                    	jmp	short Entry_Int0B_Stk
  1542 000002A2 00000000                Old0B:	dd	0	
  1543 000002A6 4B42                    	dw	424Bh
  1544                                  FirstFlag0B:
  1545 000002A8 00                      	db	0
  1546 000002A9 EB5F                    	jmp	short IntRet_0B
  1547 000002AB 00<rep 7h>              	times	7 db 0
  1548                                  
  1549                                  Entry_Int0B_Stk:
  1550 000002B2 50                      	push	ax
  1551 000002B3 55                      	push	bp
  1552 000002B4 06                      	push	es
  1553 000002B5 2E8E06[0A00]            	mov	es,[cs:Stacks+2]	; Get segment of stacks
  1554 000002BA 2E8B2E[1000]            	mov	bp,[cs:NextEntry]	; get most likely candidate
  1555 000002BF B001                    	mov	al,Allocated
  1556 000002C1 26864600                	xchg	AllocByte,al		; grab the entry
  1557 000002C5 3C00                    	cmp	al,Free 		; still avail?
  1558 000002C7 7542                    	jne	short NotFree0B
  1559                                  
  1560 000002C9 2E832E[1000]08          	sub	word [cs:NextEntry],EntrySize ; set for next interrupt
  1561                                  
  1562                                  Found0B:
  1563 000002CF 26896602                	mov	SavedSP,sp		; save sp value
  1564 000002D3 268C5604                	mov	SavedSS,ss		; save ss also
  1565                                  ;	mov	IntLevel,0Bh		; save the int level
  1566                                  
  1567 000002D7 89E8                    	mov	ax,bp			; temp save of table offset
  1568                                  
  1569 000002D9 268B6E06                	mov	bp,NewSP		; get new SP value
  1570 000002DD 26394600                	cmp	[es:bp],ax		; check for offset into table
  1571 000002E1 7535                    	jne	short FoundBad0B
  1572                                  
  1573 000002E3 8CC0                    	mov	ax,es			; point ss,sp to the new stack
  1574 000002E5 8ED0                    	mov	ss,ax
  1575 000002E7 89EC                    	mov	sp,bp
  1576                                  
  1577 000002E9 9C                      	pushf				; go execute the real interrupt handler
  1578                                  	; 17/06/2018
  1579 000002EA 2EFF1E[A202]            	call	far [cs:Old0B]		;  which will iret back to here
  1580                                  
  1581 000002EF 89E5                    	mov	bp,sp			; retrieve the table offset for us
  1582 000002F1 268B6E00                	mov	bp,[es:bp]		;  but leave it on the stack
  1583 000002F5 268E5604                	mov	ss,SavedSS		; get old stack back
  1584 000002F9 268B6602                	mov	sp,SavedSP
  1585                                  
  1586                                  ;	cmp	AllocByte,Allocated	; If an error occured,
  1587                                  ;	jne	short NewError0B	;  do not free us
  1588                                  
  1589 000002FD 26C6460000              	mov	AllocByte,Free		; free the entry
  1590 00000302 2E892E[1000]            	mov	[cs:NextEntry],bp	; setup to use next time
  1591                                  
  1592                                  NewError0B:
  1593 00000307 07                      	pop	es
  1594 00000308 5D                      	pop	bp			; saved on entry
  1595 00000309 58                      	pop	ax			; saved on entry
  1596                                  
  1597                                  IntRet_0B:
  1598 0000030A CF                      	iret				; done with this interrupt
  1599                                  
  1600                                  NotFree0B:
  1601 0000030B 3C01                    	cmp	al,Allocated		; error flag
  1602 0000030D 7404                    	je	short FindNext0B	;  no, continue
  1603 0000030F 26864600                	xchg	AllocByte,al		;  yes, restore error value
  1604                                  
  1605                                  FindNext0B:
  1606 00000313 E85204                  	call	LongPath
  1607 00000316 EBB7                    	jmp	short Found0B
  1608                                  
  1609                                  FoundBad0B:
  1610 00000318 2E3B2E[0C00]            	cmp	bp,[cs:FirstEntry]
  1611 0000031D 72F4                    	jc	short FindNext0B
  1612 0000031F 89C5                    	mov	bp,ax			; flag this entry
  1613 00000321 26C6460003              	mov	AllocByte,Clobbered
  1614                                  ;	add	bp,EntrySize		;  and previous entry
  1615                                  ;	mov	AllocByte,Overflowed
  1616                                  ;	sub	bp,EntrySize
  1617 00000326 EBEB                    	jmp	short FindNext0B	; keep looking
  1618                                  
  1619                                  Int0C:
  1620 00000328 EB10                    	jmp	short Entry_Int0C_Stk
  1621 0000032A 00000000                Old0C:	dd	0	
  1622 0000032E 4B42                    	dw	424Bh
  1623                                  FirstFlag0C:
  1624 00000330 00                      	db	0
  1625 00000331 EB5F                    	jmp	short IntRet_0C
  1626 00000333 00<rep 7h>              	times	7 db 0
  1627                                  
  1628                                  Entry_Int0C_Stk:
  1629 0000033A 50                      	push	ax
  1630 0000033B 55                      	push	bp
  1631 0000033C 06                      	push	es
  1632 0000033D 2E8E06[0A00]            	mov	es,[cs:Stacks+2]	; Get segment of stacks
  1633 00000342 2E8B2E[1000]            	mov	bp,[cs:NextEntry]	; get most likely candidate
  1634 00000347 B001                    	mov	al,Allocated
  1635 00000349 26864600                	xchg	AllocByte,al		; grab the entry
  1636 0000034D 3C00                    	cmp	al,Free 		; still avail?
  1637 0000034F 7542                    	jne	short NotFree0C
  1638                                  
  1639 00000351 2E832E[1000]08          	sub	word [cs:NextEntry],EntrySize ; set for next interrupt
  1640                                  
  1641                                  Found0C:
  1642 00000357 26896602                	mov	SavedSP,sp		; save sp value
  1643 0000035B 268C5604                	mov	SavedSS,ss		; save ss also
  1644                                  ;	mov	IntLevel,0Ch		; save the int level
  1645                                  
  1646 0000035F 89E8                    	mov	ax,bp			; temp save of table offset
  1647                                  
  1648 00000361 268B6E06                	mov	bp,NewSP		; get new SP value
  1649 00000365 26394600                	cmp	[es:bp],ax		; check for offset into table
  1650 00000369 7535                    	jne	short FoundBad0C
  1651                                  
  1652 0000036B 8CC0                    	mov	ax,es			; point ss,sp to the new stack
  1653 0000036D 8ED0                    	mov	ss,ax
  1654 0000036F 89EC                    	mov	sp,bp
  1655                                  
  1656 00000371 9C                      	pushf				; go execute the real interrupt handler
  1657                                  	; 17/06/2018
  1658 00000372 2EFF1E[2A03]            	call	far [cs:Old0C]		;  which will iret back to here
  1659                                  
  1660 00000377 89E5                    	mov	bp,sp			; retrieve the table offset for us
  1661 00000379 268B6E00                	mov	bp,[es:bp]		;  but leave it on the stack
  1662 0000037D 268E5604                	mov	ss,SavedSS		; get old stack back
  1663 00000381 268B6602                	mov	sp,SavedSP
  1664                                  
  1665                                  ;	cmp	AllocByte,Allocated	; If an error occured,
  1666                                  ;	jne	short NewError0C	;  do not free us
  1667                                  
  1668 00000385 26C6460000              	mov	AllocByte,Free		; free the entry
  1669 0000038A 2E892E[1000]            	mov	[cs:NextEntry],bp	; setup to use next time
  1670                                  
  1671                                  NewError0C:
  1672 0000038F 07                      	pop	es
  1673 00000390 5D                      	pop	bp			; saved on entry
  1674 00000391 58                      	pop	ax			; saved on entry
  1675                                  
  1676                                  IntRet_0C:
  1677 00000392 CF                      	iret				; done with this interrupt
  1678                                  
  1679                                  NotFree0C:
  1680 00000393 3C01                    	cmp	al,Allocated		; error flag
  1681 00000395 7404                    	je	short FindNext0C	;  no, continue
  1682 00000397 26864600                	xchg	AllocByte,al		;  yes, restore error value
  1683                                  
  1684                                  FindNext0C:
  1685 0000039B E8CA03                  	call	LongPath
  1686 0000039E EBB7                    	jmp	short Found0C
  1687                                  
  1688                                  FoundBad0C:
  1689 000003A0 2E3B2E[0C00]            	cmp	bp,[cs:FirstEntry]
  1690 000003A5 72F4                    	jc	short FindNext0C
  1691 000003A7 89C5                    	mov	bp,ax			; flag this entry
  1692 000003A9 26C6460003              	mov	AllocByte,Clobbered
  1693                                  ;	add	bp,EntrySize		;  and previous entry
  1694                                  ;	mov	AllocByte,Overflowed
  1695                                  ;	sub	bp,EntrySize
  1696 000003AE EBEB                    	jmp	short FindNext0C	; keep looking
  1697                                  
  1698                                  Int0D:
  1699 000003B0 EB10                    	jmp	short Entry_Int0D_Stk
  1700 000003B2 00000000                Old0D:	dd	0	
  1701 000003B6 4B42                    	dw	424Bh
  1702                                  FirstFlag0D:
  1703 000003B8 00                      	db	0
  1704 000003B9 EB5F                    	jmp	short IntRet_0D
  1705 000003BB 00<rep 7h>              	times	7 db 0
  1706                                  
  1707                                  Entry_Int0D_Stk:
  1708 000003C2 50                      	push	ax
  1709 000003C3 55                      	push	bp
  1710 000003C4 06                      	push	es
  1711 000003C5 2E8E06[0A00]            	mov	es,[cs:Stacks+2]	; Get segment of stacks
  1712 000003CA 2E8B2E[1000]            	mov	bp,[cs:NextEntry]	; get most likely candidate
  1713 000003CF B001                    	mov	al,Allocated
  1714 000003D1 26864600                	xchg	AllocByte,al		; grab the entry
  1715 000003D5 3C00                    	cmp	al,Free 		; still avail?
  1716 000003D7 7542                    	jne	short NotFree0D
  1717                                  
  1718 000003D9 2E832E[1000]08          	sub	word [cs:NextEntry],EntrySize ; set for next interrupt
  1719                                  
  1720                                  Found0D:
  1721 000003DF 26896602                	mov	SavedSP,sp		; save sp value
  1722 000003E3 268C5604                	mov	SavedSS,ss		; save ss also
  1723                                  ;	mov	IntLevel,0Dh		; save the int level
  1724                                  
  1725 000003E7 89E8                    	mov	ax,bp			; temp save of table offset
  1726                                  
  1727 000003E9 268B6E06                	mov	bp,NewSP		; get new SP value
  1728 000003ED 26394600                	cmp	[es:bp],ax		; check for offset into table
  1729 000003F1 7535                    	jne	short FoundBad0D
  1730                                  
  1731 000003F3 8CC0                    	mov	ax,es			; point ss,sp to the new stack
  1732 000003F5 8ED0                    	mov	ss,ax
  1733 000003F7 89EC                    	mov	sp,bp
  1734                                  
  1735 000003F9 9C                      	pushf				; go execute the real interrupt handler
  1736                                  	; 17/06/2018
  1737 000003FA 2EFF1E[B203]            	call	far [cs:Old0D]		;  which will iret back to here
  1738                                  
  1739 000003FF 89E5                    	mov	bp,sp			; retrieve the table offset for us
  1740 00000401 268B6E00                	mov	bp,[es:bp]		;  but leave it on the stack
  1741 00000405 268E5604                	mov	ss,SavedSS		; get old stack back
  1742 00000409 268B6602                	mov	sp,SavedSP
  1743                                  
  1744                                  ;	cmp	AllocByte,Allocated	; If an error occured,
  1745                                  ;	jne	short NewError0D	;  do not free us
  1746                                  
  1747 0000040D 26C6460000              	mov	AllocByte,Free		; free the entry
  1748 00000412 2E892E[1000]            	mov	[cs:NextEntry],bp	; setup to use next time
  1749                                  
  1750                                  NewError0D:
  1751 00000417 07                      	pop	es
  1752 00000418 5D                      	pop	bp			; saved on entry
  1753 00000419 58                      	pop	ax			; saved on entry
  1754                                  
  1755                                  IntRet_0D:
  1756 0000041A CF                      	iret				; done with this interrupt
  1757                                  
  1758                                  NotFree0D:
  1759 0000041B 3C01                    	cmp	al,Allocated		; error flag
  1760 0000041D 7404                    	je	short FindNext0D	;  no, continue
  1761 0000041F 26864600                	xchg	AllocByte,al		;  yes, restore error value
  1762                                  
  1763                                  FindNext0D:
  1764 00000423 E84203                  	call	LongPath
  1765 00000426 EBB7                    	jmp	short Found0D
  1766                                  
  1767                                  FoundBad0D:
  1768 00000428 2E3B2E[0C00]            	cmp	bp,[cs:FirstEntry]
  1769 0000042D 72F4                    	jc	short FindNext0D
  1770 0000042F 89C5                    	mov	bp,ax			; flag this entry
  1771 00000431 26C6460003              	mov	AllocByte,Clobbered
  1772                                  ;	add	bp,EntrySize		;  and previous entry
  1773                                  ;	mov	AllocByte,Overflowed
  1774                                  ;	sub	bp,EntrySize
  1775 00000436 EBEB                    	jmp	short FindNext0D	; keep looking
  1776                                  
  1777                                  Int0E:
  1778 00000438 EB10                    	jmp	short Entry_Int0E_Stk
  1779 0000043A 00000000                Old0E:	dd	0	
  1780 0000043E 4B42                    	dw	424Bh
  1781                                  FirstFlag0E:
  1782 00000440 00                      	db	0
  1783 00000441 EB5F                    	jmp	short IntRet_0E
  1784 00000443 00<rep 7h>              	times	7 db 0
  1785                                  
  1786                                  Entry_Int0E_Stk:
  1787 0000044A 50                      	push	ax
  1788 0000044B 55                      	push	bp
  1789 0000044C 06                      	push	es
  1790 0000044D 2E8E06[0A00]            	mov	es,[cs:Stacks+2]	; Get segment of stacks
  1791 00000452 2E8B2E[1000]            	mov	bp,[cs:NextEntry]	; get most likely candidate
  1792 00000457 B001                    	mov	al,Allocated
  1793 00000459 26864600                	xchg	AllocByte,al		; grab the entry
  1794 0000045D 3C00                    	cmp	al,Free 		; still avail?
  1795 0000045F 7542                    	jne	short NotFree0E
  1796                                  
  1797 00000461 2E832E[1000]08          	sub	word [cs:NextEntry],EntrySize ; set for next interrupt
  1798                                  
  1799                                  Found0E:
  1800 00000467 26896602                	mov	SavedSP,sp		; save sp value
  1801 0000046B 268C5604                	mov	SavedSS,ss		; save ss also
  1802                                  ;	mov	IntLevel,0Eh		; save the int level
  1803                                  
  1804 0000046F 89E8                    	mov	ax,bp			; temp save of table offset
  1805                                  
  1806 00000471 268B6E06                	mov	bp,NewSP		; get new SP value
  1807 00000475 26394600                	cmp	[es:bp],ax		; check for offset into table
  1808 00000479 7535                    	jne	short FoundBad0E
  1809                                  
  1810 0000047B 8CC0                    	mov	ax,es			; point ss,sp to the new stack
  1811 0000047D 8ED0                    	mov	ss,ax
  1812 0000047F 89EC                    	mov	sp,bp
  1813                                  
  1814 00000481 9C                      	pushf				; go execute the real interrupt handler
  1815                                  	; 17/06/2018
  1816 00000482 2EFF1E[3A04]            	call	far [cs:Old0E]		;  which will iret back to here
  1817                                  
  1818 00000487 89E5                    	mov	bp,sp			; retrieve the table offset for us
  1819 00000489 268B6E00                	mov	bp,[es:bp]		;  but leave it on the stack
  1820 0000048D 268E5604                	mov	ss,SavedSS		; get old stack back
  1821 00000491 268B6602                	mov	sp,SavedSP
  1822                                  
  1823                                  ;	cmp	AllocByte,Allocated	; If an error occured,
  1824                                  ;	jne	short NewError0E	;  do not free us
  1825                                  
  1826 00000495 26C6460000              	mov	AllocByte,Free		; free the entry
  1827 0000049A 2E892E[1000]            	mov	[cs:NextEntry],bp	; setup to use next time
  1828                                  
  1829                                  NewError0E:
  1830 0000049F 07                      	pop	es
  1831 000004A0 5D                      	pop	bp			; saved on entry
  1832 000004A1 58                      	pop	ax			; saved on entry
  1833                                  
  1834                                  IntRet_0E:
  1835 000004A2 CF                      	iret				; done with this interrupt
  1836                                  
  1837                                  NotFree0E:
  1838 000004A3 3C01                    	cmp	al,Allocated		; error flag
  1839 000004A5 7404                    	je	short FindNext0E	;  no, continue
  1840 000004A7 26864600                	xchg	AllocByte,al		;  yes, restore error value
  1841                                  
  1842                                  FindNext0E:
  1843 000004AB E8BA02                  	call	LongPath
  1844 000004AE EBB7                    	jmp	short Found0E
  1845                                  
  1846                                  FoundBad0E:
  1847 000004B0 2E3B2E[0C00]            	cmp	bp,[cs:FirstEntry]
  1848 000004B5 72F4                    	jc	short FindNext0E
  1849 000004B7 89C5                    	mov	bp,ax			; flag this entry
  1850 000004B9 26C6460003              	mov	AllocByte,Clobbered
  1851                                  ;	add	bp,EntrySize		;  and previous entry
  1852                                  ;	mov	AllocByte,Overflowed
  1853                                  ;	sub	bp,EntrySize
  1854 000004BE EBEB                    	jmp	short FindNext0E	; keep looking
  1855                                  
  1856                                  Int72:
  1857 000004C0 EB10                    	jmp	short Entry_Int72_Stk
  1858 000004C2 00000000                Old72:	dd	0	
  1859 000004C6 4B42                    	dw	424Bh
  1860                                  FirstFlag72:
  1861 000004C8 00                      	db	0
  1862 000004C9 EB5F                    	jmp	short IntRet_72
  1863 000004CB 00<rep 7h>              	times	7 db 0
  1864                                  
  1865                                  Entry_Int72_Stk:
  1866 000004D2 50                      	push	ax
  1867 000004D3 55                      	push	bp
  1868 000004D4 06                      	push	es
  1869 000004D5 2E8E06[0A00]            	mov	es,[cs:Stacks+2]	; Get segment of stacks
  1870 000004DA 2E8B2E[1000]            	mov	bp,[cs:NextEntry]	; get most likely candidate
  1871 000004DF B001                    	mov	al,Allocated
  1872 000004E1 26864600                	xchg	AllocByte,al		; grab the entry
  1873 000004E5 3C00                    	cmp	al,Free 		; still avail?
  1874 000004E7 7542                    	jne	short NotFree72
  1875                                  
  1876 000004E9 2E832E[1000]08          	sub	word [cs:NextEntry],EntrySize ; set for next interrupt
  1877                                  
  1878                                  Found72:
  1879 000004EF 26896602                	mov	SavedSP,sp		; save sp value
  1880 000004F3 268C5604                	mov	SavedSS,ss		; save ss also
  1881                                  ;	mov	IntLevel,72h		; save the int level
  1882                                  
  1883 000004F7 89E8                    	mov	ax,bp			; temp save of table offset
  1884                                  
  1885 000004F9 268B6E06                	mov	bp,NewSP		; get new SP value
  1886 000004FD 26394600                	cmp	[es:bp],ax		; check for offset into table
  1887 00000501 7535                    	jne	short FoundBad72
  1888                                  
  1889 00000503 8CC0                    	mov	ax,es			; point ss,sp to the new stack
  1890 00000505 8ED0                    	mov	ss,ax
  1891 00000507 89EC                    	mov	sp,bp
  1892                                  
  1893 00000509 9C                      	pushf				; go execute the real interrupt handler
  1894                                  	; 17/06/2018
  1895 0000050A 2EFF1E[C204]            	call	far [cs:Old72]		;  which will iret back to here
  1896                                  
  1897 0000050F 89E5                    	mov	bp,sp			; retrieve the table offset for us
  1898 00000511 268B6E00                	mov	bp,[es:bp]		;  but leave it on the stack
  1899 00000515 268E5604                	mov	ss,SavedSS		; get old stack back
  1900 00000519 268B6602                	mov	sp,SavedSP
  1901                                  
  1902                                  ;	cmp	AllocByte,Allocated	; If an error occured,
  1903                                  ;	jne	short NewError72	;  do not free us
  1904                                  
  1905 0000051D 26C6460000              	mov	AllocByte,Free		; free the entry
  1906 00000522 2E892E[1000]            	mov	[cs:NextEntry],bp	; setup to use next time
  1907                                  
  1908                                  NewError72:
  1909 00000527 07                      	pop	es
  1910 00000528 5D                      	pop	bp			; saved on entry
  1911 00000529 58                      	pop	ax			; saved on entry
  1912                                  
  1913                                  IntRet_72:
  1914 0000052A CF                      	iret				; done with this interrupt
  1915                                  
  1916                                  NotFree72:
  1917 0000052B 3C01                    	cmp	al,Allocated		; error flag
  1918 0000052D 7404                    	je	short FindNext72	;  no, continue
  1919 0000052F 26864600                	xchg	AllocByte,al		;  yes, restore error value
  1920                                  
  1921                                  FindNext72:
  1922 00000533 E83202                  	call	LongPath
  1923 00000536 EBB7                    	jmp	short Found72
  1924                                  
  1925                                  FoundBad72:
  1926 00000538 2E3B2E[0C00]            	cmp	bp,[cs:FirstEntry]
  1927 0000053D 72F4                    	jc	short FindNext72
  1928 0000053F 89C5                    	mov	bp,ax			; flag this entry
  1929 00000541 26C6460003              	mov	AllocByte,Clobbered
  1930                                  ;	add	bp,EntrySize		;  and previous entry
  1931                                  ;	mov	AllocByte,Overflowed
  1932                                  ;	sub	bp,EntrySize
  1933 00000546 EBEB                    	jmp	short FindNext72	; keep looking
  1934                                  
  1935                                  Int73:
  1936 00000548 EB10                    	jmp	short Entry_Int73_Stk
  1937 0000054A 00000000                Old73:	dd	0	
  1938 0000054E 4B42                    	dw	424Bh
  1939                                  FirstFlag73:
  1940 00000550 00                      	db	0
  1941 00000551 EB5F                    	jmp	short IntRet_73
  1942 00000553 00<rep 7h>              	times	7 db 0
  1943                                  
  1944                                  Entry_Int73_Stk:
  1945 0000055A 50                      	push	ax
  1946 0000055B 55                      	push	bp
  1947 0000055C 06                      	push	es
  1948 0000055D 2E8E06[0A00]            	mov	es,[cs:Stacks+2]	; Get segment of stacks
  1949 00000562 2E8B2E[1000]            	mov	bp,[cs:NextEntry]	; get most likely candidate
  1950 00000567 B001                    	mov	al,Allocated
  1951 00000569 26864600                	xchg	AllocByte,al		; grab the entry
  1952 0000056D 3C00                    	cmp	al,Free 		; still avail?
  1953 0000056F 7542                    	jne	short NotFree73
  1954                                  
  1955 00000571 2E832E[1000]08          	sub	word [cs:NextEntry],EntrySize ; set for next interrupt
  1956                                  
  1957                                  Found73:
  1958 00000577 26896602                	mov	SavedSP,sp		; save sp value
  1959 0000057B 268C5604                	mov	SavedSS,ss		; save ss also
  1960                                  ;	mov	IntLevel,73h		; save the int level
  1961                                  
  1962 0000057F 89E8                    	mov	ax,bp			; temp save of table offset
  1963                                  
  1964 00000581 268B6E06                	mov	bp,NewSP		; get new SP value
  1965 00000585 26394600                	cmp	[es:bp],ax		; check for offset into table
  1966 00000589 7535                    	jne	short FoundBad73
  1967                                  
  1968 0000058B 8CC0                    	mov	ax,es			; point ss,sp to the new stack
  1969 0000058D 8ED0                    	mov	ss,ax
  1970 0000058F 89EC                    	mov	sp,bp
  1971                                  
  1972 00000591 9C                      	pushf				; go execute the real interrupt handler
  1973                                  	; 17/06/2018
  1974 00000592 2EFF1E[4A05]            	call	far [cs:Old73]		;  which will iret back to here
  1975                                  
  1976 00000597 89E5                    	mov	bp,sp			; retrieve the table offset for us
  1977 00000599 268B6E00                	mov	bp,[es:bp]		;  but leave it on the stack
  1978 0000059D 268E5604                	mov	ss,SavedSS		; get old stack back
  1979 000005A1 268B6602                	mov	sp,SavedSP
  1980                                  
  1981                                  ;	cmp	AllocByte,Allocated	; If an error occured,
  1982                                  ;	jne	short NewError73	;  do not free us
  1983                                  
  1984 000005A5 26C6460000              	mov	AllocByte,Free		; free the entry
  1985 000005AA 2E892E[1000]            	mov	[cs:NextEntry],bp	; setup to use next time
  1986                                  
  1987                                  NewError73:
  1988 000005AF 07                      	pop	es
  1989 000005B0 5D                      	pop	bp			; saved on entry
  1990 000005B1 58                      	pop	ax			; saved on entry
  1991                                  
  1992                                  IntRet_73:
  1993 000005B2 CF                      	iret				; done with this interrupt
  1994                                  
  1995                                  NotFree73:
  1996 000005B3 3C01                    	cmp	al,Allocated		; error flag
  1997 000005B5 7404                    	je	short FindNext73	;  no, continue
  1998 000005B7 26864600                	xchg	AllocByte,al		;  yes, restore error value
  1999                                  
  2000                                  FindNext73:
  2001 000005BB E8AA01                  	call	LongPath
  2002 000005BE EBB7                    	jmp	short Found73
  2003                                  
  2004                                  FoundBad73:
  2005 000005C0 2E3B2E[0C00]            	cmp	bp,[cs:FirstEntry]
  2006 000005C5 72F4                    	jc	short FindNext73
  2007 000005C7 89C5                    	mov	bp,ax			; flag this entry
  2008 000005C9 26C6460003              	mov	AllocByte,Clobbered
  2009                                  ;	add	bp,EntrySize		;  and previous entry
  2010                                  ;	mov	AllocByte,Overflowed
  2011                                  ;	sub	bp,EntrySize
  2012 000005CE EBEB                    	jmp	short FindNext73	; keep looking
  2013                                  
  2014                                  Int74:
  2015 000005D0 EB10                    	jmp	short Entry_Int74_Stk
  2016 000005D2 00000000                Old74:	dd	0	
  2017 000005D6 4B42                    	dw	424Bh
  2018                                  FirstFlag74:
  2019 000005D8 00                      	db	0
  2020 000005D9 EB5F                    	jmp	short IntRet_74
  2021 000005DB 00<rep 7h>              	times	7 db 0
  2022                                  
  2023                                  Entry_Int74_Stk:
  2024 000005E2 50                      	push	ax
  2025                                  
  2026 000005E3 55                      	push	bp
  2027 000005E4 06                      	push	es
  2028 000005E5 2E8E06[0A00]            	mov	es,[cs:Stacks+2]	; Get segment of stacks
  2029 000005EA 2E8B2E[1000]            	mov	bp,[cs:NextEntry]	; get most likely candidate
  2030 000005EF B001                    	mov	al,Allocated
  2031 000005F1 26864600                	xchg	AllocByte,al		; grab the entry
  2032 000005F5 3C00                    	cmp	al,Free 		; still avail?
  2033 000005F7 7542                    	jne	short NotFree74
  2034                                  
  2035 000005F9 2E832E[1000]08          	sub	word [cs:NextEntry],EntrySize ; set for next interrupt
  2036                                  
  2037                                  Found74:
  2038 000005FF 26896602                	mov	SavedSP,sp		; save sp value
  2039 00000603 268C5604                	mov	SavedSS,ss		; save ss also
  2040                                  ;	mov	IntLevel,74h		; save the int level
  2041                                  
  2042 00000607 89E8                    	mov	ax,bp			; temp save of table offset
  2043                                  
  2044 00000609 268B6E06                	mov	bp,NewSP		; get new SP value
  2045 0000060D 26394600                	cmp	[es:bp],ax		; check for offset into table
  2046 00000611 7535                    	jne	short FoundBad74
  2047                                  
  2048 00000613 8CC0                    	mov	ax,es			; point ss,sp to the new stack
  2049 00000615 8ED0                    	mov	ss,ax
  2050 00000617 89EC                    	mov	sp,bp
  2051                                  
  2052 00000619 9C                      	pushf				; go execute the real interrupt handler
  2053                                  	; 17/06/2018
  2054 0000061A 2EFF1E[D205]            	call	far [cs:Old74]		;  which will iret back to here
  2055                                  
  2056 0000061F 89E5                    	mov	bp,sp			; retrieve the table offset for us
  2057 00000621 268B6E00                	mov	bp,[es:bp]		;  but leave it on the stack
  2058 00000625 268E5604                	mov	ss,SavedSS		; get old stack back
  2059 00000629 268B6602                	mov	sp,SavedSP
  2060                                  
  2061                                  ;	cmp	AllocByte,Allocated	; If an error occured,
  2062                                  ;	jne	short NewError74	;  do not free us
  2063                                  
  2064 0000062D 26C6460000              	mov	AllocByte,Free		; free the entry
  2065 00000632 2E892E[1000]            	mov	[cs:NextEntry],bp	; setup to use next time
  2066                                  
  2067                                  NewError74:
  2068 00000637 07                      	pop	es
  2069 00000638 5D                      	pop	bp			; saved on entry
  2070 00000639 58                      	pop	ax			; saved on entry
  2071                                  
  2072                                  IntRet_74:
  2073 0000063A CF                      	iret				; done with this interrupt
  2074                                  
  2075                                  NotFree74:
  2076 0000063B 3C01                    	cmp	al,Allocated		; error flag
  2077 0000063D 7404                    	je	short FindNext74	;  no, continue
  2078 0000063F 26864600                	xchg	AllocByte,al		;  yes, restore error value
  2079                                  
  2080                                  FindNext74:
  2081 00000643 E82201                  	call	LongPath
  2082 00000646 EBB7                    	jmp	short Found74
  2083                                  
  2084                                  FoundBad74:
  2085 00000648 2E3B2E[0C00]            	cmp	bp,[cs:FirstEntry]
  2086 0000064D 72F4                    	jc	short FindNext74
  2087 0000064F 89C5                    	mov	bp,ax			; flag this entry
  2088 00000651 26C6460003              	mov	AllocByte,Clobbered
  2089                                  ;	add	bp,EntrySize		;  and previous entry
  2090                                  ;	mov	AllocByte,Overflowed
  2091                                  ;	sub	bp,EntrySize
  2092 00000656 EBEB                    	jmp	short FindNext74	; keep looking
  2093                                  
  2094                                  Int76:
  2095 00000658 EB10                    	jmp	short Entry_Int76_Stk
  2096 0000065A 00000000                Old76:	dd	0	
  2097 0000065E 4B42                    	dw	424Bh
  2098                                  FirstFlag76:
  2099 00000660 00                      	db	0
  2100 00000661 EB5F                    	jmp	short IntRet_76
  2101 00000663 00<rep 7h>              	times	7 db 0
  2102                                  
  2103                                  Entry_Int76_Stk:
  2104 0000066A 50                      	push	ax
  2105 0000066B 55                      	push	bp
  2106 0000066C 06                      	push	es
  2107 0000066D 2E8E06[0A00]            	mov	es,[cs:Stacks+2]	; Get segment of stacks
  2108 00000672 2E8B2E[1000]            	mov	bp,[cs:NextEntry]	; get most likely candidate
  2109 00000677 B001                    	mov	al,Allocated
  2110 00000679 26864600                	xchg	AllocByte,al		; grab the entry
  2111 0000067D 3C00                    	cmp	al,Free 		; still avail?
  2112 0000067F 7542                    	jne	short NotFree76
  2113                                  
  2114 00000681 2E832E[1000]08          	sub	word [cs:NextEntry],EntrySize ; set for next interrupt
  2115                                  
  2116                                  Found76:
  2117 00000687 26896602                	mov	SavedSP,sp		; save sp value
  2118 0000068B 268C5604                	mov	SavedSS,ss		; save ss also
  2119                                  ;	mov	IntLevel,76h		; save the int level
  2120                                  
  2121 0000068F 89E8                    	mov	ax,bp			; temp save of table offset
  2122                                  
  2123 00000691 268B6E06                	mov	bp,NewSP		; get new SP value
  2124 00000695 26394600                	cmp	[es:bp],ax		; check for offset into table
  2125 00000699 7535                    	jne	short FoundBad76
  2126                                  
  2127 0000069B 8CC0                    	mov	ax,es			; point ss,sp to the new stack
  2128 0000069D 8ED0                    	mov	ss,ax
  2129 0000069F 89EC                    	mov	sp,bp
  2130                                  
  2131 000006A1 9C                      	pushf				; go execute the real interrupt handler
  2132                                  	; 17/06/2018
  2133 000006A2 2EFF1E[5A06]            	call	far [cs:Old76]		;  which will iret back to here
  2134                                  
  2135 000006A7 89E5                    	mov	bp,sp			; retrieve the table offset for us
  2136 000006A9 268B6E00                	mov	bp,[es:bp]		;  but leave it on the stack
  2137 000006AD 268E5604                	mov	ss,SavedSS		; get old stack back
  2138 000006B1 268B6602                	mov	sp,SavedSP
  2139                                  
  2140                                  ;	cmp	AllocByte,Allocated	; If an error occured,
  2141                                  ;	jne	short NewError76	;  do not free us
  2142                                  
  2143 000006B5 26C6460000              	mov	AllocByte,Free		; free the entry
  2144 000006BA 2E892E[1000]            	mov	[cs:NextEntry],bp	; setup to use next time
  2145                                  
  2146                                  NewError76:
  2147 000006BF 07                      	pop	es
  2148 000006C0 5D                      	pop	bp			; saved on entry
  2149 000006C1 58                      	pop	ax			; saved on entry
  2150                                  
  2151                                  IntRet_76:
  2152 000006C2 CF                      	iret				; done with this interrupt
  2153                                  
  2154                                  NotFree76:
  2155 000006C3 3C01                    	cmp	al,Allocated		; error flag
  2156 000006C5 7404                    	je	short FindNext76	;  no, continue
  2157 000006C7 26864600                	xchg	AllocByte,al		;  yes, restore error value
  2158                                  
  2159                                  FindNext76:
  2160 000006CB E89A00                  	call	LongPath
  2161 000006CE EBB7                    	jmp	short Found76
  2162                                  
  2163                                  FoundBad76:
  2164 000006D0 2E3B2E[0C00]            	cmp	bp,[cs:FirstEntry]
  2165 000006D5 72F4                    	jc	short FindNext76
  2166 000006D7 89C5                    	mov	bp,ax			; flag this entry
  2167 000006D9 26C6460003              	mov	AllocByte,Clobbered
  2168                                  ;	add	bp,EntrySize		;  and previous entry
  2169                                  ;	mov	AllocByte,Overflowed
  2170                                  ;	sub	bp,EntrySize
  2171 000006DE EBEB                    	jmp	short FindNext76	; keep looking
  2172                                  
  2173                                  Int77:
  2174 000006E0 EB10                    	jmp	short Entry_Int77_Stk
  2175 000006E2 00000000                Old77:	dd	0	
  2176 000006E6 4B42                    	dw	424Bh
  2177                                  FirstFlag77:
  2178 000006E8 00                      	db	0
  2179 000006E9 EB5F                    	jmp	short IntRet_77
  2180 000006EB 00<rep 7h>              	times	7 db 0
  2181                                  
  2182                                  Entry_Int77_Stk:
  2183 000006F2 50                      	push	ax
  2184 000006F3 55                      	push	bp
  2185 000006F4 06                      	push	es
  2186 000006F5 2E8E06[0A00]            	mov	es,[cs:Stacks+2]	; Get segment of stacks
  2187 000006FA 2E8B2E[1000]            	mov	bp,[cs:NextEntry]	; get most likely candidate
  2188 000006FF B001                    	mov	al,Allocated
  2189 00000701 26864600                	xchg	AllocByte,al		; grab the entry
  2190 00000705 3C00                    	cmp	al,Free 		; still avail?
  2191 00000707 7542                    	jne	short NotFree77
  2192                                  
  2193 00000709 2E832E[1000]08          	sub	word [cs:NextEntry],EntrySize ; set for next interrupt
  2194                                  
  2195                                  Found77:
  2196 0000070F 26896602                	mov	SavedSP,sp		; save sp value
  2197 00000713 268C5604                	mov	SavedSS,ss		; save ss also
  2198                                  ;	mov	IntLevel,77h		; save the int level
  2199                                  
  2200 00000717 89E8                    	mov	ax,bp			; temp save of table offset
  2201                                  
  2202 00000719 268B6E06                	mov	bp,NewSP		; get new SP value
  2203 0000071D 26394600                	cmp	[es:bp],ax		; check for offset into table
  2204 00000721 7535                    	jne	short FoundBad77
  2205                                  
  2206 00000723 8CC0                    	mov	ax,es			; point ss,sp to the new stack
  2207 00000725 8ED0                    	mov	ss,ax
  2208 00000727 89EC                    	mov	sp,bp
  2209                                  
  2210 00000729 9C                      	pushf				; go execute the real interrupt handler
  2211                                  	; 17/06/2018
  2212 0000072A 2EFF1E[E206]            	call	far [cs:Old77]		;  which will iret back to here
  2213                                  
  2214 0000072F 89E5                    	mov	bp,sp			; retrieve the table offset for us
  2215 00000731 268B6E00                	mov	bp,[es:bp]		;  but leave it on the stack
  2216 00000735 268E5604                	mov	ss,SavedSS		; get old stack back
  2217 00000739 268B6602                	mov	sp,SavedSP
  2218                                  
  2219                                  ;	cmp	AllocByte,Allocated	; If an error occured,
  2220                                  ;	jne	short NewError77	;  do not free us
  2221                                  
  2222 0000073D 26C6460000              	mov	AllocByte,Free		; free the entry
  2223 00000742 2E892E[1000]            	mov	[cs:NextEntry],bp	; setup to use next time
  2224                                  
  2225                                  NewError77:
  2226 00000747 07                      	pop	es
  2227 00000748 5D                      	pop	bp			; saved on entry
  2228 00000749 58                      	pop	ax			; saved on entry
  2229                                  
  2230                                  IntRet_77:
  2231 0000074A CF                      	iret				; done with this interrupt
  2232                                  
  2233                                  NotFree77:
  2234 0000074B 3C01                    	cmp	al,Allocated		; error flag
  2235 0000074D 7404                    	je	short FindNext77	;  no, continue
  2236 0000074F 26864600                	xchg	AllocByte,al		;  yes, restore error value
  2237                                  
  2238                                  FindNext77:
  2239 00000753 E81200                  	call	LongPath
  2240 00000756 EBB7                    	jmp	short Found77
  2241                                  
  2242                                  FoundBad77:
  2243 00000758 2E3B2E[0C00]            	cmp	bp,[cs:FirstEntry]
  2244 0000075D 72F4                    	jc	short FindNext77
  2245 0000075F 89C5                    	mov	bp,ax			; flag this entry
  2246 00000761 26C6460003              	mov	AllocByte,Clobbered
  2247                                  ;	add	bp,EntrySize		;  and previous entry
  2248                                  ;	mov	AllocByte,Overflowed
  2249                                  ;	sub	bp,EntrySize
  2250 00000766 EBEB                    	jmp	short FindNext77	; keep looking
  2251                                  
  2252                                  ;********************************************************************
  2253                                  
  2254                                  ;Common routines
  2255                                  
  2256                                  LongPath:
  2257                                  	; 17/06/2018
  2258 00000768 2E8B2E[0E00]            	mov	bp,[cs:LastEntry]	; start with last entry in table
  2259                                  
  2260                                  LPLOOPP:
  2261 0000076D 26807E0000              	cmp	AllocByte,Free		; is entry free?
  2262 00000772 7512                    	jne	short inuse		;  no, try next one
  2263                                  
  2264 00000774 B001                    	mov	al,Allocated
  2265 00000776 26864600                	xchg	AllocByte,al		; allocate entry
  2266 0000077A 3C00                    	cmp	al,Free 		; is it still free?
  2267 0000077C 7414                    	je	short found		;  yes, go use it
  2268                                  
  2269 0000077E 3C01                    	cmp	al,Allocated		; is it other than Allocated or Free?
  2270 00000780 7404                    	je	short inuse		;  no, check the next one
  2271                                  
  2272 00000782 26884600                	mov	AllocByte,al		;  yes, put back the error state
  2273                                  inuse:
  2274 00000786 2E3B2E[0C00]            	cmp	bp,[cs:FirstEntry]
  2275 0000078B 7406                    	je	short Fatal
  2276 0000078D 83ED08                  	sub	bp,EntrySize
  2277 00000790 EBDB                    	JMP	short LPLOOPP
  2278                                  found:
  2279 00000792 C3                      	retn
  2280                                  
  2281                                  Fatal:
  2282 00000793 1E                      	push	ds
  2283 00000794 B800F0                  	mov	ax, 0F000h		;look at the model byte
  2284 00000797 8ED8                    	mov	ds, ax
  2285 00000799 803EFEFFF9              	cmp	byte [0FFFEh],0F9h	;convertible
  2286 0000079E 1F                      	pop	ds
  2287 0000079F 7504                    	jne	short Skip_NMIS
  2288                                  
  2289 000007A1 B007                    	mov	al,07h			; disable p12 NMIs
  2290 000007A3 E672                    	out	72h,al
  2291                                  
  2292                                  Skip_NMIS:
  2293 000007A5 FA                      	cli				; disable and mask
  2294 000007A6 B0FF                    	mov	al,0FFh			;   all other ints
  2295 000007A8 E621                    	out	021h,al
  2296 000007AA E6A1                    	out	0A1h,al
  2297                                  
  2298 000007AC 8CCE                    	mov	si,cs
  2299 000007AE 8EDE                    	mov	ds,si
  2300 000007B0 BE[C207]                	mov	si,FATAL_MSG
  2301                                  
  2302                                  fatal_loop:
  2303 000007B3 AC                      	lodsb
  2304 000007B4 3C24                    	cmp	al,'$'
  2305 000007B6 7408                    	je	short fatal_done
  2306                                  
  2307 000007B8 B307                    	mov	bl,7
  2308 000007BA B40E                    	mov	ah,14
  2309 000007BC CD10                    	int	010h			; whoops, this enables ints
  2310 000007BE EBF3                    	jmp	short fatal_loop
  2311                                  
  2312                                  fatal_done:
  2313 000007C0 EBFE                    	jmp	short fatal_done
  2314                                  
  2315                                  ; ----------------------------------------------------------------------
  2316                                  ; STKMES.INC - MSDOS 3.3 (24/07/1987)
  2317                                  ; ----------------------------------------------------------------------
  2318                                  ; 04/06/2018 - Retro DOS v3.0
  2319                                  
  2320                                  FATAL_MSG:
  2321 000007C2 0D0A                    	DB	0DH,0AH
  2322 000007C4 070D0A                  	DB	7,0DH,0AH
  2323 000007C7 496E7465726E616C20-     	DB	"Internal stack overflow",0DH,0AH
  2323 000007D0 737461636B206F7665-
  2323 000007D9 72666C6F770D0A     
  2324 000007E0 53797374656D206861-     	DB	"System halted",0DH,0AH,"$" 
  2324 000007E9 6C7465640D0A24     
  2325                                  
  2326                                  Endstackcode:
  2327                                  
  2328                                  ; ----------------------------------------------------------------------
  2329                                  ; SYINIT1.ASM (MSDOS 3.3) - SYSINIT.ASM (MSDOS 2.0)
  2330                                  ; ----------------------------------------------------------------------
  2331                                  ; 04/06/2018 - Retro DOS v3.0 (MSDOS 3.3, SYSINIT1.ASM, 24/07/1987)
  2332                                  
  2333                                  SYSINIT:
  2334 000007F0 E90501                          JMP	GOINIT
  2335                                  	;JMP	SYSIN ; 25/02/2018 - Retro DOS 2.0 modification
  2336 000007F3 90                      align 4
  2337                                  DOSINFO: 
  2338 000007F4 0000                    	dw	0
  2339                                  CURRENT_DOS_LOCATION: 
  2340 000007F6 0000                    	dw	0
  2341                                  MSDOS:	
  2342                                  ENTRY_POINT:
  2343 000007F8 0000                    	dw	0
  2344                                  FINAL_DOS_LOCATION:
  2345 000007FA 0000                    	dw	0
  2346                                  DEVICE_LIST:
  2347 000007FC 00000000                	dd	0
  2348                                  DOSSIZE: ; Retro DOS 2.0 feature - 25/02/2018
  2349 00000800 0000                    	dw	0   ; 'MSDOS.BIN' kernel size in words
  2350                                  
  2351                                  ; 04/06/2018 - Retro DOS v3.0
  2352                                  ; 28/03/2018
  2353                                  ;; MSDOS 3.3 - SYSINIT1.ASM - 24/07/1987
  2354                                  ;
  2355                                  SYSI_Country:	
  2356 00000802 0000                    	dw	0 ; 5/29/86 Pointer to
  2357 00000804 0000                    	dw	0 ;country table in DOS
  2358                                  
  2359                                  ;; STACKSW   EQU   TRUE ;Include Switchable Hardware Stacks
  2360                                  ;; (SYSCONF.ASM, 1987)
  2361                                  ;; Internal Stack Parameters
  2362                                  ;EntrySize	equ	8
  2363                                  ;MinCount	equ	8
  2364                                  ;DefaultCount	equ	9
  2365                                  ;MaxCount	equ	64
  2366                                  ;MinSize 	equ	32
  2367                                  ;DefaultSize	equ	128
  2368                                  ;MaxSize 	equ	512
  2369                                  
  2370                                  	;IF	STACKSW    ; STACKSW TRUE
  2371                                  ;
  2372                                  ; Internal Stack Parameters
  2373                                  
  2374 00000806 0900                    STACK_COUNT:	DW	DefaultCount
  2375 00000808 8000                    STACK_SIZE:	DW	DefaultSize
  2376 0000080A 00000000                STACK_ADDR:	DD	0
  2377                                  	;ENDIF
  2378                                  
  2379                                  ; 05/06/2018 - Retro DOS v3.0
  2380                                  
  2381                                  ; various default values
  2382                                  
  2383                                  MEMORY_SIZE:
  2384 0000080E 0100                    	dw	1
  2385                                  DEFAULT_DRIVE:
  2386 00000810 00                      	db	0
  2387                                  BUFFERS:
  2388 00000811 FFFF                    	DW	-1	; initialized during buffer allocation
  2389                                  ;BUFFERS: 
  2390                                  ;	DW	2	; two buffers
  2391                                  FILES:
  2392 00000813 08                      	db	8	; enough files for pipe
  2393                                  FCBS:
  2394 00000814 04                      	db	4	; performance for recycling
  2395                                  KEEP:
  2396 00000815 00                      	db	0	; keep original set
  2397                                  NUM_CDS:
  2398 00000816 05                      	db	5	; 5 net drives
  2399                                  CONFBOT:
  2400 00000817 0000                    	dw	0
  2401                                  ALLOCLIM:
  2402 00000819 0000                    	dw	0
  2403                                  FOOSTRNG:
  2404 0000081B 413A5C00                	db	"A:\",0
  2405                                  COMMAND_LINE:
  2406 0000081F 020050                  	db	2,0,"P" ; Default Command.com Args
  2407                                          
  2408 00000822 00<rep 1Dh>             	times	29 db 0
  2409                                  ZERO:
  2410 0000083F 00                      	db	0
  2411                                  SEPCHR:
  2412 00000840 00                      	db	0
  2413                                  
  2414                                  ; 10/06/2018
  2415                                  Sys_Model_Byte:
  2416 00000841 FF                      	db	0FFh	;model byte used in SYSINIT
  2417                                  Sys_Scnd_Model_Byte:
  2418 00000842 00                      	db	0	;secondary model byte used in SYSINIT
  2419                                  
  2420                                          ;IF      NOT NOEXEC
  2421                                  ;COMEXE EXEC0 <0,COMMAND_LINE,DEFAULT_DRIVE,ZERO>
  2422                                          ;ENDIF
  2423                                  
  2424                                  ; 01/05/2018
  2425                                  COMEXE:
  2426 00000843 0000                    EXEC0.ENVIRON:	DW	0	; seg addr of environment
  2427 00000845 [1F08]                  EXEC0.COM_LINE:	DW	COMMAND_LINE ; pointer to asciz command line
  2428 00000847 0000                    		DW	0
  2429 00000849 [1008]                  EXEC0.5C_FCB:	DW	DEFAULT_DRIVE ; default fcb at 5C
  2430 0000084B 0000                    		DW	0
  2431 0000084D [3F08]                  EXEC0.6C_FCB:	DW	ZERO	; default fcb at 6C
  2432 0000084F 0000                    		DW	0
  2433                                  
  2434                                  COUNT:
  2435 00000851 0000                    	dw	0
  2436                                  CHRPTR:
  2437 00000853 0000                    	dw	0
  2438                                  
  2439                                  ; 04/06/2018
  2440                                  CntryFileHandle:
  2441 00000855 0000                    	DW 	0 
  2442                                  
  2443 00000857 90                      align 4
  2444                                  
  2445                                  BUFPTR:
  2446                                  	; LEAVE THIS STUFF IN ORDER!
  2447                                  MEMLO:
  2448 00000858 0000                    	dw	0
  2449                                  PRMBLK:
  2450                                  MEMHI:
  2451 0000085A 0000                    	dw	0
  2452                                  LDOFF:
  2453 0000085C 0000                    	dw	0
  2454                                  AREA:
  2455 0000085E 0000                    	dw	0
  2456                                  
  2457                                  PACKET:
  2458 00000860 16                      	db	22
  2459 00000861 00                      	db	0
  2460 00000862 00                      	db	0	; INITIALIZE CODE
  2461 00000863 0000                    	dw	0
  2462 00000865 00<rep 8h>              	times	8 db 0
  2463                                  UNITCOUNT:
  2464 0000086D 00                      	db	0
  2465                                  BREAK_ADDR:
  2466 0000086E 00000000                	dd	0
  2467                                  BPB_ADDR:
  2468 00000872 00000000                	dd	0
  2469                                  DriveNumber:
  2470 00000876 00                      	db	0
  2471                                  
  2472 00000877 90                      align 2
  2473                                  
  2474                                  TempStack:
  2475 00000878 00<rep 80h>             	times	128 db 0
  2476                                  
  2477                                  GOINIT:
  2478                                  	; 06/07/2018
  2479                                  	; 04/06/2018 - Retro DOS v3.0
  2480                                  ; before doing anything else, let's set the model byte
  2481 000008F8 B4C0                    	mov	ah,0C0h 		;get system configuration
  2482 000008FA CD15                    	int	15h			; *
  2483 000008FC 7217                    	jc	short No_ROM_Config
  2484 000008FE 80FC00                  	cmp	ah,0			; double check
  2485 00000901 7512                    	jne	short No_ROM_Config
  2486 00000903 268A4702                	mov	al,[ES:BX+ROMBIOS_DESC.bios_SD_modelbyte]
  2487 00000907 2EA2[4108]              	mov	[cs:Sys_Model_Byte],al 
  2488 0000090B 268A4703                	mov	al,[ES:BX+ROMBIOS_DESC.bios_SD_scnd_modelbyte]
  2489 0000090F 2EA2[4208]              	mov	[cs:Sys_Scnd_Model_Byte],al
  2490                                  	;jmp	short Move_Myself
  2491 00000913 EB0C                    	jmp	short SYSIN
  2492                                  No_ROM_Config:				; Old ROM
  2493 00000915 B800F0                  	mov	ax,0F000h
  2494 00000918 8ED8                    	mov	ds,ax
  2495 0000091A A0FEFF                  	mov	al,[0FFFEh]
  2496 0000091D 2EA2[4108]              	mov	[cs:Sys_Model_Byte],al	;set the model byte.
  2497                                  
  2498                                  ;Move_Myself:
  2499                                  ;	; 25/02/2018 - Retro DOS 2.0 - MSDOS 2.0 "SYSINIT.ASM"
  2500                                  ;	; (Modified for Retro DOS 2.0, for NASM 'incbin' method)
  2501                                  ;
  2502                                  ;	SYSINITSIZE	EQU  sysinit_code_end - sysinit_code_start
  2503                                  ;
  2504                                  ;      	;CLD
  2505                                  ;      	XOR     SI,SI
  2506                                  ;      	MOV     DI,SI
  2507                                  ;	; 19/03/2018
  2508                                  ;      	mov	CX,[SYSINIT_START+MEMORY_SIZE]
  2509                                  ;;	CMP     CX,1
  2510                                  ;;      JNZ     short NOSCAN
  2511                                  ;;	MOV     CX,2048		; START SCANNING AT 32K BOUNDARY
  2512                                  ;;	XOR     BX,BX
  2513                                  ;;MEMSCAN:
  2514                                  ;;	INC     CX
  2515                                  ;;    	JZ	short SETEND
  2516                                  ;;     	MOV     DS,CX
  2517                                  ;;     	MOV     AL,[BX]
  2518                                  ;;     	NOT     AL
  2519                                  ;;     	MOV     [BX],AL
  2520                                  ;;     	CMP     AL,[BX]
  2521                                  ;;     	NOT     AL
  2522                                  ;;     	MOV     [BX],AL
  2523                                  ;;     	JZ      short MEMSCAN
  2524                                  ;;SETEND:
  2525                                  ;;	MOV     AX,CS
  2526                                  ;;      MOV     DS,AX   
  2527                                  ;;	MOV	[SYSINIT_START+MEMORY_SIZE],CX 
  2528                                  ;;NOSCAN:
  2529                                  ;	MOV     AX,SYSINITSIZE + 15
  2530                                  ;	SHR     AX,1                    ; Divide by 16 for paras
  2531                                  ;	SHR     AX,1
  2532                                  ;	SHR     AX,1
  2533                                  ;	SHR     AX,1
  2534                                  ;
  2535                                  ;	SUB     CX,AX
  2536                                  ;	MOV     ES,CX ; SYSINITSEG = [MEMORY_SIZE] - (SYSIZE+15)/16
  2537                                  ;	MOV     CX,SYSINITSIZE + 1
  2538                                  ;	SHR     CX,1                    ; Divide by 2 to get words
  2539                                  ;	REP     MOVSW                   ; RELOCATE SYSINIT
  2540                                  ;
  2541                                  ;	PUSH    ES
  2542                                  ;	MOV	AX,SYSIN  ; 05/06/2018 (MSDOS 3.3, SYSINIT1.ASM)
  2543                                  ;	PUSH    AX
  2544                                  ;	
  2545                                  ;	RETF	; far jump to final location of SYSINIT code
  2546                                  ;
  2547                                  
  2548                                  ;
  2549                                  ;       MOVE THE DOS TO ITS PROPER LOCATION
  2550                                  ;
  2551                                  
  2552                                  	;nop	; 30/03/2018
  2553                                  SYSIN:
  2554                                  	; Retro DOS 2.0 - 25/02/2018 
  2555                                  
  2556 00000921 0E                      	PUSH	CS
  2557 00000922 1F                      	POP	DS
  2558                                  
  2559 00000923 8B0E[0008]                      MOV     CX,[DOSSIZE] ; words (not bytes!)
  2560                                  	        
  2561 00000927 A1[FA07]                	MOV	AX,[FINAL_DOS_LOCATION]
  2562 0000092A 8EC0                    	MOV     ES,AX
  2563 0000092C A1[F607]                        MOV     AX,[CURRENT_DOS_LOCATION]
  2564 0000092F 8ED8                            MOV     DS,AX
  2565                                  
  2566 00000931 31F6                            XOR     SI,SI
  2567 00000933 89F7                            MOV     DI,SI
  2568                                  	;INC	CX
  2569                                  	;SHR	CX, 1
  2570 00000935 F3A5                            REP     MOVSW
  2571                                  
  2572 00000937 8CC8                    	MOV	AX,CS
  2573 00000939 8ED8                    	MOV	DS,AX
  2574 0000093B 8B16[0E08]                      MOV	DX,[MEMORY_SIZE]
  2575 0000093F C536[FC07]              	LDS     SI,[DEVICE_LIST]
  2576                                  
  2577 00000943 FA                              CLI
  2578 00000944 8ED0                            MOV     SS,AX
  2579 00000946 BC[4A09]                        MOV     SP,LOCSTACK	
  2580 00000949 FB                      	STI
  2581                                  align 2
  2582                                  	; 30/03/2018
  2583                                  LOCSTACK:
  2584 0000094A 2EFF1E[F807]                    CALL	FAR [CS:MSDOS]	; FINAL_DOS_LOCATION:0 
  2585                                  		       		;('jmp DOSINIT' in 'MSHEAD.ASM')
  2586                                  		       		;('DOSINIT:' is in 'MSINIT.ASM')
  2587                                  
  2588                                  	; DS = PSP address for default process
  2589                                  	; ES:DI = Address of SYSINITVAR (MSDOS 2.0/2.11, Retro DOS 2.0)
  2590                                  
  2591                                  	;MOV     [CS:DOSINFO+2],ES ; SAVE POINTER TO DOS INFO
  2592                                  	;MOV     [CS:DOSINFO],DI
  2593                                  
  2594                                  	; 17/06/2018
  2595 0000094F 1E                      	PUSH	DS			; Save as input to RE_INIT
  2596                                  	
  2597 00000950 0E                      	PUSH	CS
  2598 00000951 1F                      	POP	DS
  2599                                  
  2600                                  	; 05/06/2018 - Retro DOS v3.0
  2601                                  	; ES:DI = Address of pointer to SYSINITVARS structure (MSDOS 3.3)
  2602                                  
  2603                                  	;mov	ax,[es:di+SysInitVars_Ext.SYSI_InitVars] ; 5/29/86
  2604 00000952 268B05                  	mov	ax,[es:di] ; 05/07/2019 
  2605                                  	;mov	[CS:DOSINFO],ax
  2606 00000955 A3[F407]                	mov	[DOSINFO],ax
  2607 00000958 268B4502                	mov	ax,[es:di+SysInitVars_Ext.SYSI_InitVars+2]
  2608                                  	;mov	[CS:DOSINFO+2],ax
  2609 0000095C A3[F607]                	mov	[DOSINFO+2],ax ;set the sysvar pointer
  2610                                  
  2611 0000095F 268B4504                	mov	ax,[es:di+SysInitVars_Ext.SYSI_Country_Tab]
  2612                                  	;mov	[CS:SYSI_Country],ax
  2613 00000963 A3[0208]                	mov	[SYSI_Country],ax
  2614 00000966 268B4506                	mov	ax,[es:di+SysInitVars_Ext.SYSI_Country_Tab+2]
  2615                                  	;mov	[CS:SYSI_Country+2],ax
  2616 0000096A A3[0408]                	mov	[SYSI_Country+2],ax	;set the SYSI_Country pointer
  2617                                  
  2618 0000096D C43E[F407]              	les	di,[DOSINFO]	;es:di -> dosinfo
  2619                                  
  2620                                  	; 09/06/2018
  2621                                  	; 08/06/2018 - Retro DOS v3.0 (MSDOS 3.3)
  2622                                  	;SYSI_NUMIO equ	32
  2623                                   	
  2624                                  	; 25/03/2018 - Retro DOS v2.0 (MSDOS 2.0 <-> 3.3)
  2625                                  	;SYSI_NUMIO equ	16 ; SYSINITVAR NUMIO offset for MSDOS 2.0
  2626                                  
  2627                                  	; MSDOS 3.3 - SYSINIT1.ASM
  2628 00000971 268A4520                	MOV	AL,[ES:DI+SYSI_NUMIO] ; SYSINITVAR.NUMIO
  2629 00000975 A2[7608]                	MOV	[DriveNumber],AL ; Save start of installable block drvs
  2630                                  
  2631 00000978 8CC8                    	MOV	AX,CS
  2632 0000097A 83E811                  	SUB	AX,11H			; room for header we will copy shortly
  2633 0000097D A3[1708]                	MOV	[CONFBOT],AX		; Temp "unsafe" location
  2634                                  
  2635                                  	; 08/06/2018
  2636                                  	;PUSH	DS			; Save as input to RE_INIT
  2637                                  	;PUSH	CS
  2638                                  	;POP	DS
  2639 00000980 E87401                  	CALL	TEMPCDS 		; Set up CDSs so RE_INIT and SYSINIT
  2640                                  					;   can make DISK system calls
  2641                                  
  2642 00000983 1F                      	POP	DS			; Recover DS input to RE_INIT
  2643                                  
  2644                                  	; 06/07/2019
  2645                                  
  2646                                          ;IF	NOT IBMJAPVER
  2647                                  	
  2648 00000984 9A031B7000              	CALL	KERNEL_SEGMENT:RE_INIT ; Re-call the BIOS
  2649                                          
  2650                                  	;ENDIF
  2651                                  
  2652 00000989 FB                              STI
  2653 0000098A FC                              CLD
  2654                                  
  2655                                  ; DOSINIT has set up a default "process" (PHP) at DS:0. We will move it out
  2656                                  ; of the way by putting it just below SYSINIT at end of memory.
  2657                                  
  2658 0000098B 8CCB                            MOV     BX,CS
  2659 0000098D 83EB10                          SUB     BX,10H
  2660 00000990 8EC3                            MOV     ES,BX
  2661 00000992 31F6                            XOR     SI,SI
  2662 00000994 89F7                            MOV     DI,SI
  2663 00000996 B98000                          MOV     CX,80H
  2664 00000999 F3A5                            REP     MOVSW
  2665                                  
  2666 0000099B 268C063600              	MOV	[ES:PDB.JFN_POINTER+2],ES ; Relocate
  2667                                  
  2668                                   	; Set Process Data Block - Program Segment Prefix address
  2669                                  	; BX = PDB/PSP segment
  2670 000009A0 B450                            MOV     AH,SET_CURRENT_PDB
  2671 000009A2 CD21                            INT     21H			; Tell DOS we moved it
  2672                                  
  2673 000009A4 1E                              PUSH	DS
  2674 000009A5 0E                              PUSH    CS
  2675 000009A6 1F                              POP     DS
  2676 000009A7 BA[6D1B]                        MOV     DX,INT24	; SET UP INT 24 HANDLER
  2677 000009AA B82425                          MOV     AX,(SET_INTERRUPT_VECTOR*256)+24H
  2678 000009AD CD21                            INT     21H
  2679                                  
  2680                                  	; 25/03/2018 - MSDOS 3.3 - SYSINIT1.ASM
  2681 000009AF BBFFFF                  	MOV	BX,0FFFFH
  2682 000009B2 B448                    	MOV	AH,ALLOC
  2683 000009B4 CD21                    	INT	21H			;FIRST TIME FAILS
  2684 000009B6 B448                    	MOV	AH,ALLOC
  2685 000009B8 CD21                    	INT	21H			;SECOND TIME GETS IT
  2686 000009BA A3[5E08]                	MOV	[AREA],AX
  2687 000009BD A3[5A08]                	MOV	[MEMHI],AX		; MEMHI:MEMLO now points to
  2688                                  					; start of free memory
  2689                                          ;IF	ALTVECT
  2690                                  	; 27/06/2018
  2691 000009C0 BA[801B]                	MOV	DX,BOOTMES
  2692 000009C3 E87D11                          CALL	PRINT		; Print message DOSINIT couldn't
  2693                                          ;ENDIF
  2694                                  
  2695 000009C6 1F                      	POP	DS 
  2696                                  
  2697                                  	; 17/06/2018
  2698 000009C7 2E8A16[1008]                    MOV     DL,[CS:DEFAULT_DRIVE]
  2699                                  
  2700 000009CC 08D2                    	OR      DL,DL
  2701 000009CE 7406                            JZ      SHORT NODRVSET
  2702                                          
  2703 000009D0 FECA                    	DEC     DL                      ; A = 0
  2704 000009D2 B40E                            MOV     AH,SET_DEFAULT_DRIVE
  2705 000009D4 CD21                            INT     21H                     ; SELECT THE DISK
  2706                                  NODRVSET:
  2707 000009D6 E82607                  	CALL	DOCONF                  ; DO THE CONFIG STUFF
  2708                                  
  2709 000009D9 E89301                  	CALL	ENDFILE	; 25/03/2018 - MSDOS 3.3 - SYSINIT1.ASM
  2710                                  
  2711                                  	; 01/05/2018 (NOEXEC = FALSE)
  2712                                  	;IF	NOEXEC
  2713                                  
  2714                                  	;MOV	BP,DS                   ; SAVE COMMAND.COM SEGMENT
  2715                                  
  2716                                  	;;PUSH	DS
  2717                                  	;;POP	ES
  2718                                  
  2719                                  	;; 13/04/2018
  2720                                  	;MOV	ES, BP	
  2721                                  
  2722                                          ;MOV	BX,CS
  2723                                          ;SUB	BX,10H
  2724                                          ;MOV	DS,BX
  2725                                          ;XOR	SI,SI
  2726                                          ;MOV	DI,SI
  2727                                          ;MOV	CX,80H
  2728                                          ;REP	MOVSW
  2729                                  	;MOV	[ES:PDB.JFN_POINTER+2],ES ; Relocate ; 25/03/2018
  2730                                          ;MOV	BX,ES
  2731                                  
  2732                                          ;MOV	AH,SET_CURRENT_PDB
  2733                                          ;INT	21H
  2734                                  
  2735                                          ;MOV	[ES:PDB.PARENT_PID],ES  ; WE ARE THE ROOT
  2736                                          ;ENDIF
  2737                                  
  2738                                  ; We must now close all handles and reopen STDIN,STDOUT,STDERR in order
  2739                                  ; to get a possibly NEW device driver for CON. STDAUX and STDPRN must
  2740                                  ; also be openned.
  2741                                  
  2742 000009DC 0E                              PUSH    CS
  2743 000009DD 1F                              POP     DS
  2744                                  
  2745 000009DE A0[1308]                        MOV     AL,[FILES]
  2746                                  	;CBW
  2747 000009E1 30E4                    	XOR	AH,AH			; DO NOT USE CBW INSTRUCTION!!!!!
  2748                                  					;  IT DOES SIGN EXTEND.
  2749 000009E3 89C1                            MOV     CX,AX
  2750 000009E5 31DB                            XOR     BX,BX                   ; Close standard input
  2751 000009E7 B43E                            MOV     AH,CLOSE
  2752 000009E9 CD21                            INT     21H
  2753                                  
  2754 000009EB BB0200                          MOV     BX,2
  2755                                  RCCLLOOP: 				; Close everybody but standard output
  2756 000009EE B43E                            MOV     AH,CLOSE
  2757 000009F0 CD21                            INT     21H
  2758 000009F2 43                              INC     BX
  2759 000009F3 E2F9                            LOOP    RCCLLOOP
  2760                                  
  2761 000009F5 BA[B71B]                        MOV     DX,CONDEV
  2762 000009F8 B002                            MOV     AL,2
  2763 000009FA B43D                            MOV     AH,OPEN                 ; OPEN CON FOR READ/WRITE
  2764 000009FC F9                              STC
  2765 000009FD CD21                            INT     21H
  2766 000009FF 7305                            JNC     SHORT GOAUX
  2767 00000A01 E82111                          CALL    BADFIL
  2768 00000A04 EB13                            JMP     SHORT GOAUX2
  2769                                  
  2770 00000A06 50                      GOAUX:  PUSH    AX
  2771 00000A07 BB0100                          MOV     BX,1                    ; close standard output
  2772 00000A0A B43E                            MOV     AH,CLOSE
  2773 00000A0C CD21                            INT     21H
  2774 00000A0E 58                              POP     AX
  2775                                  
  2776 00000A0F 89C3                            MOV     BX,AX                   ; New device handle
  2777 00000A11 B445                            MOV     AH,XDUP
  2778 00000A13 CD21                            INT     21H                     ; Dup to 1, STDOUT
  2779 00000A15 B445                            MOV     AH,XDUP
  2780 00000A17 CD21                            INT     21H                     ; Dup to 2, STDERR
  2781                                  
  2782 00000A19 BA[BB1B]                GOAUX2: MOV     DX,AUXDEV
  2783 00000A1C B002                            MOV     AL,2                    ; READ/WRITE ACCESS
  2784 00000A1E E82711                          CALL    OPEN_DEV
  2785                                  
  2786 00000A21 BA[BF1B]                        MOV     DX,PRNDEV
  2787 00000A24 B001                            MOV     AL,1                    ; WRITE ONLY
  2788 00000A26 E81F11                          CALL    OPEN_DEV
  2789                                  
  2790                                  	; 08/06/2018 - Retro DOS v3.0
  2791                                  
  2792                                  ;Global Rearm command for Shared Interrupt devices attached in the system;
  2793                                  ;Shared interrupt attachment has some problem when it issues interrupt
  2794                                  ;during a warm reboot.	Once the interrupt is presented by the attachment,
  2795                                  ;no further interrupts on that level will be presented until a global rearm
  2796                                  ;is issued. BIOS will issue a global rearm after each device driver is loaded.
  2797                                  ;To issue a global rearm:	;For PC1, XT, Palace
  2798                                  ;			  OUT 02F2h, XX  ; Interrupt level 2
  2799                                  ;			  OUT 02F3h, XX  ; Interrupt level 3
  2800                                  ;			  OUT 02F4h, XX  ; Interrupt level 4
  2801                                  ;			  OUT 02F5h, XX  ; Interrupt level 5
  2802                                  ;			  OUT 02F6h, XX  ; Interrupt level 6
  2803                                  ;			  OUT 02F7h, XX  ; Interrupt level 7
  2804                                  ;
  2805                                  ;				;For PC AT, in addition to the above commands,
  2806                                  ;				;need to handle the secondary interrupt handler
  2807                                  ;			  OUT 06F2h, XX  ; Interrupt level 10
  2808                                  ;			  OUT 06F3h, XX  ; Interrupt level 11
  2809                                  ;			  OUT 06F4h, XX  ; Interrupt level 12
  2810                                  ;			  OUT 06F6h, XX  ; Interrupt level 14
  2811                                  ;			  OUT 06F7h, XX  ; Interrupt level 15
  2812                                  ;
  2813                                  ;				;For All others machine
  2814                                  ;			  None.
  2815                                  ;
  2816                                  ; where XX stands for any value.
  2817                                  
  2818                                  ; 05/07/2019
  2819                                  
  2820                                  ; MSDOS 6.0 - SYSINIT1.ASM (IBMDOS 3.3, IBMBIO.COM SYSINIT:0A4Ah)
  2821                                  
  2822                                  ; where xx stands for any value.
  2823                                  ;
  2824                                  ; for your information,after naples level machine,the system service bios
  2825                                  ; call (int 15h),function ah=0c0h returns the system configuration parameters
  2826                                  
  2827                                  	;PUSH	AX			;Save register
  2828                                  	;PUSH	BX			;Save register
  2829                                  	;PUSH	DX			;Save register
  2830                                  	;PUSH	ES			;Save register
  2831                                  
  2832 00000A29 B0FF                    	MOV	AL,0FFH 		;reset h/w by writing to port
  2833 00000A2B BAF202                  	MOV	DX,02F2H		;get starting address
  2834 00000A2E EE                      	OUT	DX,AL			;OUT 02F2H,0FFH
  2835 00000A2F 42                      	INC	DX			;
  2836 00000A30 EE                      	OUT	DX,AL			;OUT 02F3H,0FFH
  2837 00000A31 42                      	INC	DX			;
  2838 00000A32 EE                      	OUT	DX,AL			;OUT 02F4H,0FFH
  2839 00000A33 42                      	INC	DX			;
  2840 00000A34 EE                      	OUT	DX,AL			;OUT 02F5H,0FFH
  2841 00000A35 42                      	INC	DX			;
  2842 00000A36 EE                      	OUT	DX,AL			;OUT 02F6H,0FFH
  2843 00000A37 42                      	INC	DX			;
  2844 00000A38 EE                      	OUT	DX,AL			;OUT 02F7H,0FFH
  2845                                  
  2846                                  ;sb secondary global rearm
  2847                                  
  2848 00000A39 B800F0                  	MOV	AX,0F000H		;Get machine type
  2849 00000A3C 8EC0                    	MOV	ES,AX			;
  2850                                  
  2851                                  	;CMP	BYTE [ES:0FFFEH],0FCH	;Q: Is it an AT type machine?
  2852                                  	;JNE	short REARMDONE		;  N: Skip next rearm
  2853                                  
  2854                                  	; 05/07/2019
  2855 00000A3E 26803EFEFFFC            	cmp	byte [es:0FFFEh],0FCh	;q:is it a at type machine
  2856 00000A44 740D                    	je	short startrearm	; *if at no need to check
  2857                                  
  2858 00000A46 B4C0                    	MOV	AH,0C0H 		;Get system configuration
  2859 00000A48 CD15                    	INT	15H			;Q: Is it an old ROM?
  2860 00000A4A 7216                    	JC	short REARMDONE		;  Y: Skip next rearm
  2861                                  
  2862                                  ; test feature byte for secondary interrupt controller
  2863                                  
  2864 00000A4C 26F6470540              	TEST	byte [ES:BX+ROMBIOS_DESC.bios_SD_featurebyte1],ScndIntController
  2865                                  					; Q: Present?
  2866 00000A51 740F                    	JE	short REARMDONE		;  N: Skip next rearm
  2867                                  
  2868                                  startrearm:
  2869 00000A53 B0FF                    	MOV	AL,0FFH 		;write any pattern to port
  2870 00000A55 BAF206                  	MOV	DX,06F2H		;get starting address
  2871 00000A58 EE                      	OUT	DX,AL			;OUT 06F2H,0FFH
  2872 00000A59 42                      	INC	DX			;
  2873 00000A5A EE                      	OUT	DX,AL			;OUT 06F3H,0FFH
  2874 00000A5B 42                      	INC	DX			;
  2875 00000A5C EE                      	OUT	DX,AL			;OUT 06F4H,0FFH
  2876 00000A5D 42                      	INC	DX			;
  2877 00000A5E 42                      	INC	DX			;
  2878 00000A5F EE                      	OUT	DX,AL			;OUT 02F6H,0FFH
  2879 00000A60 42                      	INC	DX			;
  2880 00000A61 EE                      	OUT	DX,AL			;OUT 02F7H,0FFH
  2881                                  
  2882                                  REARMDONE:
  2883                                  	;POP	ES			;Restore register
  2884                                  	;POP	DX			;Restore register
  2885                                  	;POP	BX			;Restore register
  2886                                  	;POP	AX			;Restore register
  2887                                  
  2888                                  ;Global Rearm end *******************
  2889                                  
  2890                                  ;
  2891                                  ; SET UP THE PARAMETERS FOR COMMAND
  2892                                  ;
  2893                                  GOSET:
  2894 00000A62 BE[2008]                        MOV     SI,COMMAND_LINE+1
  2895                                  
  2896                                  	; 01/05/2018 (NOEXEC = FALSE)
  2897                                          ;IF	NOEXEC
  2898                                          ;MOV	DI,81H
  2899                                          ;ELSE
  2900 00000A65 1E                              PUSH	DS
  2901 00000A66 07                              POP	ES
  2902 00000A67 89F7                            MOV	DI,SI
  2903                                          ;ENDIF
  2904                                  
  2905 00000A69 B1FF                            MOV     CL,-1
  2906                                  COMTRANLP:                              ; FIND LENGTH OF COMMAND LINE
  2907 00000A6B FEC1                            INC     CL
  2908 00000A6D AC                              LODSB
  2909 00000A6E AA                              STOSB                           ; COPY COMMAND LINE IN
  2910 00000A6F 08C0                            OR      AL,AL
  2911 00000A71 75F8                            JNZ     SHORT COMTRANLP
  2912 00000A73 4F                              DEC     DI
  2913 00000A74 B00D                            MOV     AL,0DH
  2914 00000A76 AA                              STOSB
  2915                                  
  2916                                  	; 01/05/2018 (NOEXEC = FALSE)
  2917                                          ;IF	NOEXEC
  2918                                          ;MOV	[ES:80H],CL
  2919                                          ;MOV	AL,[DEFAULT_DRIVE]
  2920                                          ;MOV	[ES:5CH],AL
  2921                                          ;ELSE
  2922 00000A77 880E[1F08]                      MOV	[COMMAND_LINE],CL       ; Count
  2923                                          ;ENDIF
  2924                                  
  2925                                          ;PUSH    CS
  2926                                          ;POP     ES
  2927                                  
  2928 00000A7B BA[1C1C]                        MOV     DX,COMMND		; NOW POINTING TO FILE DESCRIPTION
  2929                                  
  2930                                  	; 01/05/2018 (NOEXEC = FALSE)
  2931                                          ;IF	NOEXEC
  2932                                          ;MOV     ES,BP			; SET LOAD ADDRESS
  2933                                          ;MOV     BX,100H
  2934                                          ;CALL    LDFIL			; READ IN COMMAND
  2935                                          ;JC      SHORT COMERR
  2936                                          ;MOV     DS,BP
  2937                                          ;MOV     DX,80H
  2938                                          ;MOV     AH,SET_DMA		; SET DISK TRANSFER ADDRESS
  2939                                          ;INT     21H
  2940                                          ;CLI
  2941                                          ;MOV     SS,BP
  2942                                          ;MOV     SP,DX
  2943                                          ;STI
  2944                                          ;XOR     AX,AX			; PUSH A WORD OF ZEROS
  2945                                          ;PUSH    AX
  2946                                          ;PUSH    BP			; SET HIGH PART OF JUMP ADDRESS
  2947                                          ;MOV     AX,100H
  2948                                          ;PUSH    AX			; SET LOW PART OF JUMP ADDRESS
  2949                                          ;RETF				; CRANK UP COMMAND!
  2950                                  
  2951                                          ;ELSE
  2952                                  
  2953                                  	; 08/06/2018 - Retro DOS v3.0  (MSDOS 3.3, SYSINIT1.ASM, 1987)
  2954                                  
  2955                                  ; We are going to open the command interpreter and size it as is done in
  2956                                  ; LDFIL.  The reason we must do this is that SYSINIT is in free memory.  If
  2957                                  ; there is not enough room for the command interpreter, EXEC will probably
  2958                                  ; overlay our stack and code so when it returns with an error SYSINIT won't be
  2959                                  ; here to catch it.  This code is not perfect (for instance .EXE command
  2960                                  ; interpreters are possible) because it does its sizing based on the
  2961                                  ; assumption that the file being loaded is a .COM file.  It is close enough to
  2962                                  ; correctness to be usable.
  2963                                  
  2964 00000A7E 52                      	PUSH	DX			; Save pointer to name
  2965                                  
  2966                                  ; First, find out where the command interpreter is going to go.
  2967 00000A7F BBFFFF                  	MOV	BX,0FFFFH
  2968 00000A82 B448                    	MOV	AH,ALLOC
  2969 00000A84 CD21                    	INT	21H			;Get biggest piece
  2970 00000A86 B448                    	MOV	AH,ALLOC
  2971 00000A88 CD21                    	INT	21H			;SECOND TIME GETS IT
  2972 00000A8A 7244                    	JC	short MEMERRJX		; Oooops
  2973 00000A8C 8EC0                    	MOV	ES,AX
  2974 00000A8E B449                    	MOV	AH,DEALLOC
  2975 00000A90 CD21                    	INT	21H			; Give it right back
  2976 00000A92 89DD                    	MOV	BP,BX
  2977                                  ; ES:0 points to Block, and BP is the size of the block
  2978                                  ;   in para.
  2979                                  
  2980                                  ; We will now adjust the size in BP DOWN by the size of SYSINIT. We
  2981                                  ;   need to do this because EXEC might get upset if some of the EXEC
  2982                                  ;   data in SYSINIT is overlayed during the EXEC.
  2983 00000A94 8B1E[0E08]              	MOV	BX,[MEMORY_SIZE]
  2984 00000A98 8CC8                    	MOV	AX,CS
  2985 00000A9A 29C3                    	SUB	BX,AX			; BX is size of SYSINIT in Para
  2986 00000A9C 83C311                  	ADD	BX,11H			; Add the SYSINIT PHP
  2987 00000A9F 29DD                    	SUB	BP,BX			; BAIS down
  2988 00000AA1 722D                    	JC	short MEMERRJX		; No Way.
  2989                                  
  2990 00000AA3 B8003D                  	MOV	AX,OPEN*256	 	;OPEN THE FILE being EXECED
  2991 00000AA6 F9                      	STC				;IN CASE OF INT 24
  2992 00000AA7 CD21                    	INT	21H
  2993 00000AA9 7244                    	JC	short COMERR		; Ooops
  2994 00000AAB 89C3                    	MOV	BX,AX			;Handle in BX
  2995 00000AAD 31C9                    	XOR	CX,CX
  2996 00000AAF 31D2                    	XOR	DX,DX
  2997 00000AB1 B80242                  	MOV	AX,(LSEEK*256)|2
  2998 00000AB4 F9                      	STC				;IN CASE OF INT 24
  2999 00000AB5 CD21                    	INT	21H			; Get file size in DX:AX
  3000 00000AB7 7236                    	JC	short COMERR
  3001                                      ; Convert size in DX:AX to para in AX
  3002 00000AB9 83C00F                  	ADD	AX,15			; Round up size for conversion to para
  3003 00000ABC 83D200                  	ADC	DX,0
  3004 00000ABF B104                    	MOV	CL,4
  3005 00000AC1 D3E8                    	SHR	AX,CL
  3006 00000AC3 B10C                    	MOV	CL,12
  3007 00000AC5 D3E2                    	SHL	DX,CL			; Low nibble of DX to high nibble
  3008 00000AC7 09D0                    	OR	AX,DX			; AX is now # of para for file
  3009 00000AC9 83C010                  	ADD	AX,10H			; 100H byte PHP
  3010 00000ACC 39E8                    	CMP	AX,BP			; Will it fit?
  3011 00000ACE 7203                    	JB	short OKLD		; Jump if yes.
  3012                                  MEMERRJX:
  3013 00000AD0 E9230E                  	JMP	MEM_ERR
  3014                                  
  3015                                  OKLD:
  3016 00000AD3 B43E                    	MOV	AH,CLOSE
  3017 00000AD5 CD21                    	INT	21H			; Close file
  3018                                  
  3019 00000AD7 5A                      	POP	DX			; Recover pointer to name
  3020                                  
  3021 00000AD8 0E                      	PUSH	CS
  3022 00000AD9 07                      	POP	ES
  3023                                  
  3024 00000ADA BB[4308]                	MOV	BX,COMEXE
  3025                                          ;MOV	[BX+EXEC0.COM_LINE+2],CS
  3026                                          ;MOV	[BX+EXEC0.5C_FCB+2],CS
  3027                                          ;MOV	[BX+EXEC0.6C_FCB+2],CS
  3028 00000ADD 8C0E[4708]              	MOV	[EXEC0.COM_LINE+2],CS
  3029 00000AE1 8C0E[4B08]                      MOV	[EXEC0.5C_FCB+2],CS
  3030 00000AE5 8C0E[4F08]                      MOV	[EXEC0.6C_FCB+2],CS
  3031                                  
  3032                                          ;XOR	AX,AX
  3033                                          ;MOV	AH,EXEC
  3034 00000AE9 B8004B                          MOV	AX,EXEC*256
  3035 00000AEC F9                      	STC				; IN CASE OF INT 24
  3036 00000AED CD21                            INT	21H			; GO START UP COMMAND
  3037                                          ;ENDIF
  3038                                  
  3039                                  COMERR:
  3040 00000AEF BA[B41D]                        MOV     DX,BADCOM		; WANT TO PRINT COMMAND ERROR
  3041 00000AF2 E83010                          CALL    BADFIL
  3042                                  STALL:  
  3043 00000AF5 EBFE                    	JMP     SHORT STALL
  3044                                  
  3045                                  	; 08/06/2018 - Retro DOS v3.0
  3046                                  
  3047                                  TEMPCDS:
  3048 00000AF7 C43E[F407]              	LES	DI,[DOSINFO]
  3049                                  
  3050 00000AFB 268A4D20                	MOV	CL,[ES:DI+SYSI_NUMIO]
  3051 00000AFF 30ED                    	XOR	CH,CH
  3052 00000B01 26884D21                	MOV	[ES:DI+SYSI_NCDS],CL
  3053 00000B05 88C8                    	MOV	AL,CL
  3054 00000B07 B451                    	MOV	AH,curdir_list.size
  3055 00000B09 F6E4                    	MUL	AH
  3056 00000B0B E8AF02                  	call	ParaRound
  3057 00000B0E 8B36[1708]              	MOV	SI,[CONFBOT]
  3058 00000B12 29C6                    	SUB	SI,AX
  3059 00000B14 8936[1908]              	MOV	[ALLOCLIM],SI		; Can't alloc past here!
  3060 00000B18 26897518                	MOV	[ES:DI+SYSI_CDS+2],SI
  3061 00000B1C 89F0                    	MOV	AX,SI
  3062 00000B1E 26C745160000            	MOV	WORD [ES:DI+SYSI_CDS],0
  3063                                  	;LDS	SI,[ES:DI+SYSI_DPB]
  3064 00000B24 26C535                  	lds	si,[es:di]  ; 05/07/2019
  3065 00000B27 8EC0                    	MOV	ES,AX
  3066 00000B29 31FF                    	XOR	DI,DI
  3067                                  FOOSET: 				; Init CDSs
  3068                                  	; 18/06/2018
  3069 00000B2B 2EA1[1B08]              	MOV	AX,[CS:FOOSTRNG]
  3070 00000B2F AB                      	STOSW
  3071 00000B30 2EA1[1D08]              	MOV	AX,[CS:FOOSTRNG+2]
  3072 00000B34 AB                      	STOSW
  3073 00000B35 2EFE06[1B08]            	INC	BYTE [CS:FOOSTRNG]
  3074 00000B3A 31C0                    	XOR	AX,AX
  3075 00000B3C 51                      	PUSH	CX
  3076 00000B3D B93F00                  	MOV	CX,curdir_list.cdir_flags - 4
  3077 00000B40 F3AA                    	REP	STOSB
  3078 00000B42 83FEFF                  	CMP	SI,-1
  3079 00000B45 7507                    	JNZ	short NORMCDS
  3080                                  	;XOR	AX,AX ; 06/07/2019
  3081 00000B47 B103                    	MOV	CL,3
  3082 00000B49 F3AB                    	REP	STOSW
  3083 00000B4B 59                      	POP	CX
  3084 00000B4C EB0E                    	JMP	SHORT FINCDS
  3085                                  
  3086                                  NORMCDS:
  3087 00000B4E 59                      	POP	CX
  3088 00000B4F B80040                  	MOV	AX,curdir_inuse
  3089 00000B52 AB                      	STOSW				; curdir_flags
  3090 00000B53 89F0                    	MOV	AX,SI
  3091 00000B55 AB                      	STOSW				; curdir_devptr
  3092 00000B56 8CD8                    	MOV	AX,DS
  3093 00000B58 AB                      	STOSW
  3094 00000B59 C57418                  	LDS	SI,[SI+DPB.NEXT_DPB]
  3095                                  FINCDS:
  3096 00000B5C B8FFFF                  	MOV	AX,-1
  3097 00000B5F AB                      	STOSW				; curdir_ID
  3098 00000B60 AB                      	STOSW				; curdir_ID
  3099 00000B61 AB                      	STOSW				; curdir_user_word
  3100 00000B62 B80200                  	mov	ax,2
  3101 00000B65 AB                      	stosw				; curdir_end
  3102 00000B66 E2C3                    	LOOP	FOOSET
  3103 00000B68 2EC606[1B08]41          	MOV	BYTE [CS:FOOSTRNG],"A"
  3104 00000B6E C3                      	retn
  3105                                  
  3106                                  ; 09/06/2018 - Retro DOS v3.0  (MSDOS 3.3, SYSINIT1.ASM, 1987)
  3107                                  
  3108                                  ; Allocate FILEs
  3109                                  ;------------------------------------------------------------------------------
  3110                                  ENDFILE:
  3111                                  ; WE ARE NOW SETTING UP FINAL CDSs, BUFFERS, FILES, FCSs STRINGs etc.  We no
  3112                                  ; longer need the space taken by The TEMP stuff below CONFBOT, so set ALLOCLIM
  3113                                  ; to CONFBOT.
  3114                                  
  3115                                  	; 18/06/2018
  3116                                  	;MOV	AX,[CS:CONFBOT]
  3117                                  	;MOV	[CS:ALLOCLIM],AX
  3118 00000B6F 0E                      	PUSH	CS
  3119 00000B70 1F                      	POP	DS
  3120 00000B71 A1[1708]                	MOV	AX,[CONFBOT]
  3121 00000B74 A3[1908]                	MOV	[ALLOCLIM],AX
  3122 00000B77 E85A0D                  	call	ROUND
  3123 00000B7A A0[1308]                	MOV	AL,[FILES]
  3124 00000B7D 2C05                    	SUB	AL,5
  3125 00000B7F 763F                    	JBE	short DOFCBS
  3126 00000B81 30E4                    	XOR	AH,AH			; DO NOT USE CBW INSTRUCTION!!!!!
  3127                                  					;  IT DOES SIGN EXTEND.
  3128 00000B83 8B1E[5808]              	MOV	BX,[MEMLO]
  3129 00000B87 8B16[5A08]              	MOV	DX,[MEMHI]
  3130 00000B8B C53E[F407]              	LDS	DI,[DOSINFO]		;GET POINTER TO DOS DATA
  3131 00000B8F C57D04                  	LDS	DI,[DI+SYSI_SFT]	;DS:BP POINTS TO SFT
  3132                                  	;MOV	[DI+SF.SFLink],BX
  3133 00000B92 891D                    	mov	[di],bx ; 05/07/2019
  3134 00000B94 895502                  	MOV	[DI+SF.SFLink+2],DX	;SET POINTER TO NEW SFT
  3135 00000B97 0E                      	PUSH	CS
  3136 00000B98 1F                      	POP	DS
  3137 00000B99 C43E[5808]              	LES	DI,[MEMLO]		;POINT TO NEW SFT
  3138                                  	;MOV	WORD [ES:DI+SF.SFLink],-1
  3139 00000B9D 26C705FFFF              	mov	word [es:di],-1	 ; 05/07/2019	
  3140 00000BA2 26894504                	MOV	[ES:DI+SF.SFCount],AX
  3141 00000BA6 B335                    	MOV	BL,SF_ENTRY.size
  3142 00000BA8 F6E3                    	MUL	BL			;AX = NUMBER OF BYTES TO CLEAR
  3143 00000BAA 89C1                    	MOV	CX,AX
  3144 00000BAC 0106[5808]              	ADD	[MEMLO],AX		;ALLOCATE MEMORY
  3145 00000BB0 B80600                  	MOV	AX,6
  3146 00000BB3 0106[5808]              	ADD	[MEMLO],AX		;REMEMBER THE HEADER TOO
  3147 00000BB7 E81A0D                  	call	ROUND			; Check for mem error before the STOSB
  3148 00000BBA 01C7                    	ADD	DI,AX
  3149 00000BBC 31C0                    	XOR	AX,AX
  3150 00000BBE F3AA                    	REP	STOSB			;CLEAN OUT THE STUFF
  3151                                  
  3152                                  ; Allocate FCBs
  3153                                  ;------------------------------------------------------------------------------
  3154                                  DOFCBS:
  3155                                  	; 24/06/2018
  3156                                  	;PUSH	CS
  3157                                  	;POP	DS
  3158 00000BC0 E8110D                  	call	ROUND
  3159 00000BC3 A0[1408]                	MOV	AL,[FCBS]
  3160 00000BC6 30E4                    	XOR	AH,AH			; DO NOT USE CBW INSTRUCTION!!!!!
  3161                                  					;  IT DOES SIGN EXTEND.
  3162 00000BC8 8B1E[5808]              	MOV	BX,[MEMLO]
  3163 00000BCC 8B16[5A08]              	MOV	DX,[MEMHI]
  3164 00000BD0 C53E[F407]              	LDS	DI,[DOSINFO]		;GET POINTER TO DOS DATA
  3165                                  
  3166 00000BD4 895D1A                  	MOV	WORD [DI+SYSI_FCB],BX
  3167 00000BD7 89551C                  	MOV	WORD [DI+SYSI_FCB+2],DX ;SET POINTER TO NEW Table
  3168                                  
  3169 00000BDA 2E8A1E[1508]            	MOV	BL,[CS:KEEP]
  3170 00000BDF 30FF                    	XOR	BH,BH
  3171 00000BE1 895D1E                  	MOV	[DI+SYSI_KEEP],BX
  3172 00000BE4 0E                      	PUSH	CS
  3173 00000BE5 1F                      	POP	DS
  3174 00000BE6 C43E[5808]              	LES	DI,[MEMLO]		;POINT TO NEW Table
  3175                                  	;MOV	WORD [ES:DI+SF.SFLink],-1
  3176 00000BEA 26C705FFFF              	mov	word [es:di],-1 ; 05/07/2019
  3177 00000BEF 26894504                	MOV	[ES:DI+SF.SFCount],AX
  3178 00000BF3 B335                    	MOV	BL,SF_ENTRY.size
  3179 00000BF5 89C1                    	MOV	CX,AX
  3180 00000BF7 F6E3                    	MUL	BL			;AX = NUMBER OF BYTES TO CLEAR
  3181 00000BF9 0106[5808]              	ADD	[MEMLO],AX		;ALLOCATE MEMORY
  3182 00000BFD B80600                  	MOV	AX,SF.size-2
  3183 00000C00 0106[5808]              	ADD	[MEMLO],AX		;REMEMBER THE HEADER TOO
  3184 00000C04 E8CD0C                  	call	ROUND			; Check for mem error before the STOSB
  3185 00000C07 01C7                    	ADD	DI,AX			;Skip over header
  3186 00000C09 B041                    	MOV	AL,"A"
  3187                                  FillLoop:
  3188 00000C0B 51                      	PUSH	CX			; save count
  3189 00000C0C B93500                  	MOV	CX,SF_ENTRY.size	; number of bytes to fill
  3190 00000C0F FC                      	cld
  3191 00000C10 F3AA                    	REP	STOSB			; filled
  3192 00000C12 26C745CB0000            	MOV	WORD [ES:DI-SF_ENTRY.size+SF_ENTRY.sf_ref_count],0
  3193 00000C18 26C745E00000            	MOV	WORD [ES:DI-SF_ENTRY.size+SF_ENTRY.sf_position],0
  3194 00000C1E 26C745E20000            	MOV	WORD [ES:DI-SF_ENTRY.size+SF_ENTRY.sf_position+2],0
  3195 00000C24 59                      	POP	CX
  3196 00000C25 E2E4                    	LOOP	FillLoop
  3197                                  
  3198                                  ; Allocate Buffers
  3199                                  ;------------------------------------------------------------------------------
  3200                                  
  3201                                  ; Search through the list of media supported and allocate 3 buffers if the
  3202                                  ; capacity of the drive is > 360KB
  3203                                  
  3204 00000C27 803E[1108]FF            	CMP	byte [BUFFERS], -1	; Has buffers been already set?
  3205 00000C2C 7403                    	je	short DoDefaultBuff
  3206 00000C2E E98500                  	jmp	DOBUFF			; the user entered the buffers=.
  3207                                  
  3208                                  DoDefaultBuff:
  3209 00000C31 C606[1108]02            	MOV	byte [BUFFERS], 2	; Default to 2 buffers
  3210                                  	; 24/06/2018
  3211                                  	;PUSH	AX
  3212                                  	;PUSH	DS
  3213                                  	;
  3214                                  	;LES	BP,[CS:DOSINFO] 	; Search through the DPB's
  3215                                  	;LES	BP,[ES:BP+SYSI_DPB]	; Get first DPB
  3216                                  
  3217                                  	; 24/06/2018
  3218                                  	;PUSH	CS
  3219                                  	;POP	DS
  3220                                  	; 18/06/2018
  3221 00000C36 C42E[F407]              	LES	BP,[DOSINFO] 		; Search through the DPB's
  3222                                  	;LES	BP,[ES:BP+SYSI_DPB]	; Get first DPB
  3223 00000C3A 26C46E00                	les	bp,[es:bp] ; 05/07/2019
  3224                                  
  3225                                  NEXTDPB:
  3226                                  	; Test if the drive supports removeable media
  3227                                  	;MOV	BL,[ES:BP+DPB.DRIVE]
  3228 00000C3E 268A5E00                	mov	bl,[es:bp] ; 05/07/2019
  3229 00000C42 FEC3                    	INC	BL
  3230 00000C44 B80844                  	MOV	AX,(IOCTL*256)|8
  3231 00000C47 CD21                    	INT	21H
  3232                                  
  3233                                  ; Ignore fixed disks
  3234 00000C49 09C0                    	OR	AX, AX			; AX is nonzero if disk is nonremoveable
  3235 00000C4B 7535                    	JNZ	short NOSETBUF
  3236                                  
  3237                                  ; Get parameters of drive
  3238 00000C4D 31DB                    	XOR	BX,BX
  3239                                  	;MOV	BL,[ES:BP+DPB.DRIVE]
  3240 00000C4F 268A5E00                	mov	bl,[es:bp] ; 05/07/2019
  3241 00000C53 FEC3                    	INC	BL
  3242 00000C55 BA[901C]                	MOV	DX,DEVICEPARAMETERS
  3243 00000C58 B80D44                  	MOV	AX,(IOCTL*256)|GENERIC_IOCTL
  3244 00000C5B B96008                  	MOV	CX,(RAWIO*256)|GET_DEVICE_PARAMETERS
  3245 00000C5E CD21                    	INT	21H
  3246 00000C60 7220                    	JC	short NOSETBUF		; Get next DPB if driver doesn't support
  3247                                  					; Generic IOCTL
  3248                                  ; Determine capacity of drive
  3249                                  ; Media Capacity = #Sectors * Bytes/Sector
  3250 00000C62 8B1E[9F1C]              	MOV	BX,[DEVICEPARAMETERS+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_TOTALSECTORS]
  3251                                  
  3252                                  ; To keep the magnitude of the media capacity within a word,
  3253                                  ; scale the sector size
  3254                                  ; (ie. 1 -> 512 bytes, 2 -> 1024 bytes, ...)
  3255 00000C66 A1[971C]                	MOV	AX,[DEVICEPARAMETERS+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_BYTESPERSECTOR]
  3256 00000C69 31D2                    	XOR	DX,DX
  3257 00000C6B B90002                  	MOV	CX,512
  3258 00000C6E F7F1                    	DIV	CX				; Scale sector size in factor of
  3259                                  						; 512 bytes
  3260                                  
  3261 00000C70 F7E3                    	MUL	BX				; AX = #sectors * size factor
  3262 00000C72 09D2                    	OR	DX,DX				; Just in case of LARGE floppies
  3263 00000C74 7505                    	JNZ	short SETBUF
  3264 00000C76 3DD002                  	CMP	AX,720				; 720 Sectors * size factor of 1
  3265 00000C79 7607                    	JBE	short NOSETBUF
  3266                                  SETBUF:
  3267 00000C7B C606[1108]03            	MOV	byte [BUFFERS], 3
  3268 00000C80 EB0D                    	jmp	short Chk_Memsize_for_Buffers 	; Now check the mem size for default buff count
  3269                                  NOSETBUF:
  3270 00000C82 26837E18FF              	CMP	WORD [ES:BP+DPB.NEXT_DPB],-1
  3271 00000C87 7406                    	jz	short Chk_Memsize_for_Buffers
  3272 00000C89 26C46E18                	LES	BP,[ES:BP+DPB.NEXT_DPB]
  3273 00000C8D EBAF                    	JMP	short NEXTDPB
  3274                                  
  3275                                  ;From DOS 3.3, the default number of buffers will be changed according to the
  3276                                  ;memory size too.
  3277                                  ; Default buffers = 2
  3278                                  ; If diskette Media > 360 kb, then default buffers = 3
  3279                                  ; If memory size > 128 kb (2000H para), then default buffers = 5
  3280                                  ; If memory size > 256 kb (4000H para), then default buffers = 10
  3281                                  ; If memory size > 512 kb (8000H para), then default buffers = 15.
  3282                                  
  3283                                  Chk_Memsize_for_Buffers:
  3284 00000C8F 813E[0E08]0020          	cmp	word [MEMORY_SIZE], 2000h
  3285 00000C95 761F                    	jbe	short BUFSET
  3286                                  	;mov	byte [BUFFERS], 5
  3287                                  	;cmp	word [MEMORY_SIZE], 4000h
  3288                                  	;jbe	short BUFSET
  3289                                  	;mov	byte [BUFFERS], 10
  3290                                  	;cmp	word [MEMORY_SIZE], 8000h
  3291                                  	;jbe	short BUFSET
  3292 00000C97 C606[1108]0F            	mov	byte [BUFFERS], 15
  3293                                  
  3294 00000C9C 813E[0E08]0080          	cmp	word [MEMORY_SIZE], 8000h
  3295 00000CA2 7312                    	jnb	short BUFSET
  3296 00000CA4 C606[1108]0A            	mov	byte [BUFFERS], 10
  3297 00000CA9 813E[0E08]0040          	cmp	word [MEMORY_SIZE], 4000h
  3298 00000CAF 7305                    	jnb	short BUFSET
  3299 00000CB1 C606[1108]05            	mov	byte [BUFFERS], 5
  3300                                  	;cmp	word [MEMORY_SIZE], 8000h
  3301                                  	;jbe	short BUFSET
  3302                                  	;mov	byte [BUFFERS], 15
  3303                                  
  3304                                  BUFSET:
  3305                                  	; 24/06/2018
  3306                                  	;POP	DS
  3307                                  	;POP	AX
  3308                                  DOBUFF:
  3309 00000CB6 E81B0C                  	call	ROUND
  3310 00000CB9 FE0E[1108]              	DEC	byte [BUFFERS]		; FIRST DEC acounts for buffer already
  3311                                  					;    in system.
  3312 00000CBD 742F                    	JZ	short BUF1		; All done
  3313 00000CBF 1E                      	PUSH	DS
  3314 00000CC0 C43E[5808]              	LES	DI,[BUFPTR]
  3315 00000CC4 C51E[F407]              	LDS	BX,[DOSINFO]
  3316 00000CC8 8B4712                  	MOV	AX,[BX+SYSI_BUF]	; Link in new buffer
  3317                                  	;MOV	[ES:DI+BUFFINFO.buf_link],AX
  3318 00000CCB 268905                  	mov	[es:di],ax; 05/07/2019
  3319 00000CCE 8B4714                  	MOV	AX,[BX+SYSI_BUF+2]
  3320 00000CD1 26894502                	MOV	[ES:DI+BUFFINFO.buf_link+2],AX
  3321 00000CD5 897F12                  	MOV	[BX+SYSI_BUF],DI
  3322 00000CD8 8C4714                  	MOV	[BX+SYSI_BUF+2],ES
  3323 00000CDB 26C74504FF00            	MOV	word [ES:DI+BUFFINFO.buf_ID],00FFH ;NEW BUFFER FREE
  3324 00000CE1 8B5F10                  	MOV	BX,[BX+SYSI_MAXSEC]
  3325 00000CE4 1F                      	POP	DS
  3326 00000CE5 83C310                  	ADD	BX,BUFINSIZ
  3327 00000CE8 011E[5808]              	ADD	[MEMLO],BX
  3328 00000CEC EBC8                    	JMP	short DOBUFF
  3329                                  
  3330                                  ; 10/06/2018 - Retro DOS v3.0
  3331                                  
  3332                                  ; Allocate CDSs
  3333                                  ;------------------------------------------------------------------------------
  3334                                  BUF1:
  3335 00000CEE E8E30B                  	call	ROUND
  3336 00000CF1 C43E[F407]              	LES	DI,[DOSINFO]
  3337 00000CF5 268A4D20                	MOV	CL,[ES:DI+SYSI_NUMIO]
  3338 00000CF9 3A0E[1608]              	CMP	CL,[NUM_CDS]
  3339 00000CFD 7304                    	JAE	short GOTNCDS		; User setting must be at least NUMIO
  3340 00000CFF 8A0E[1608]              	MOV	CL,[NUM_CDS]
  3341                                  GOTNCDS:
  3342 00000D03 30ED                    	XOR	CH,CH
  3343 00000D05 26884D21                	MOV	[ES:DI+SYSI_NCDS],CL
  3344 00000D09 A1[5A08]                	MOV	AX,[MEMHI]
  3345 00000D0C 26894518                	MOV	[ES:DI+SYSI_CDS+2],AX
  3346 00000D10 A1[5808]                	MOV	AX,[MEMLO]
  3347 00000D13 26894516                	MOV	[ES:DI+SYSI_CDS],AX
  3348 00000D17 88C8                    	MOV	AL,CL
  3349 00000D19 B451                    	MOV	AH,curdir_list.size
  3350 00000D1B F6E4                    	MUL	AH
  3351 00000D1D E89D00                  	call	ParaRound
  3352 00000D20 0106[5A08]              	ADD	[MEMHI],AX
  3353 00000D24 E8AD0B                  	call	ROUND			; Check for mem error before initializing
  3354                                  	;LDS	SI,[ES:DI+SYSI_DPB]
  3355 00000D27 26C535                  	lds	si,[es:di] ; 05/07/2019
  3356 00000D2A 26C47D16                	LES	DI,[ES:DI+SYSI_CDS]
  3357 00000D2E E8FAFD                  	CALL	FOOSET
  3358                                  
  3359                                  ; Allocate Space for Internal Stack
  3360                                  ;------------------------------------------------------------------------------
  3361                                  
  3362                                  	;IF	STACKSW
  3363 00000D31 0E                      	PUSH	CS
  3364 00000D32 1F                      	POP	DS
  3365                                  	;ASSUME	DS:SYSINITSEG
  3366                                  
  3367                                  	;IF	IBM
  3368                                  ;Don't install the system stack on the PCjr. Ignore STACKS=command too.
  3369 00000D33 803E[4108]FD            	CMP	byte [Sys_Model_Byte],0FDh	; PCjr = 0FDh
  3370 00000D38 7462                    	JE	short SkipStack
  3371                                  	;ENDIF
  3372                                  
  3373                                  ;If the user does not entered STACKS= command, as a default, do not install
  3374                                  ;sytem stacks for PC1, PC XT, PC Portable cases.
  3375                                  ;Otherwise, install it to the user specified value or to the default
  3376                                  ;value of 9, 128 for the rest of the system.
  3377                                  
  3378 00000D3A 833E[0A08]FF            	cmp	word [STACK_ADDR],-1		;Has the user entered "stacks=" command?
  3379 00000D3F 7415                    	je	short DoInstallStack		;Then install as specified by the user
  3380 00000D41 803E[4208]00            	cmp	byte [Sys_Scnd_Model_Byte],0	;PC1, XT has the secondary model byte = 0
  3381 00000D46 750E                    	jne	short DoInstallStack		;Other model should have def. stack of 9, 128
  3382 00000D48 803E[4108]FF            	cmp	byte [Sys_Model_Byte],0FFh	;PC1 ?
  3383 00000D4D 744D                    	je	short SkipStack
  3384 00000D4F 803E[4108]FE            	cmp	byte [Sys_Model_Byte],0FEh	;PC/XT or PC Portable ?	
  3385 00000D54 7446                    	je	short SkipStack
  3386                                  
  3387                                  DoInstallStack:
  3388 00000D56 A1[0608]                	mov	ax,[STACK_COUNT]		; Stack_count = 0?
  3389 00000D59 83F800                  	cmp	ax,0				;then, stack size must be 0 too.
  3390 00000D5C 743E                    	jz	short SkipStack			;Don't install stack.
  3391                                  ; 10/21/86 Dynamic Relocation of Stack code.			
  3392 00000D5E E8730B                  	call	ROUND				;[memhi] = Seg. for stack code
  3393                                  						;[memlo] = 0
  3394 00000D61 A1[5A08]                	mov	ax,[MEMHI]
  3395 00000D64 8EC0                    	mov	es,ax				;ES -> Seg. the stack code is going to move.
  3396                                  	;assume	es:nothing
  3397                                  	; 18/06/2018
  3398                                  	;push	cs
  3399                                  	;pop	ds
  3400                                  	; 05/07/2018
  3401 00000D66 31F6                    	xor	si,si			;!!We know that Stack code is at the beginning of SYSINIT.
  3402 00000D68 31FF                    	xor	di,di
  3403 00000D6A B9[F007]                	mov	cx,Endstackcode
  3404 00000D6D 890E[5808]              	mov	[MEMLO],cx
  3405 00000D71 E8600B                  	call	ROUND				;Have enough space for relocation?
  3406 00000D74 F3A4                    	rep	movsb
  3407                                  
  3408 00000D76 A1[5808]                	MOV	AX,[MEMLO]			; Set address of stacks
  3409 00000D79 A3[0A08]                	MOV	[STACK_ADDR],AX
  3410 00000D7C A1[5A08]                	MOV	AX,[MEMHI]
  3411 00000D7F A3[0C08]                	MOV	[STACK_ADDR+2],AX
  3412                                  
  3413                                  ;	Space for Internal Stack = STACK_COUNT(ENTRYSIZE + STACK_SIZE)
  3414 00000D82 B80800                  	MOV	AX,EntrySize
  3415 00000D85 0306[0808]              	ADD	AX,[STACK_SIZE]
  3416 00000D89 8B0E[0608]              	MOV	CX,[STACK_COUNT]
  3417 00000D8D F7E1                    	MUL	CX
  3418 00000D8F E82B00                  	call	ParaRound		; Convert size to paragraphs
  3419 00000D92 0106[5A08]              	ADD	[MEMHI],AX
  3420 00000D96 E83B0B                  	call	ROUND			; Check for memory error before
  3421                                  					; continuing
  3422 00000D99 E82D00                  	CALL	StackInit		; Initialize hardware stack
  3423                                  
  3424                                  SkipStack:
  3425                                  	;ENDIF
  3426                                  
  3427                                  	; 18/06/2018
  3428                                  	;PUSH	CS
  3429                                  	;POP	DS
  3430                                  	;ASSUME	DS:SYSINITSEG
  3431                                  
  3432                                  ; Allocate rest of memory to system
  3433                                  ;------------------------------------------------------------------------------
  3434 00000D9C E8350B                  	call	ROUND
  3435 00000D9F 8B1E[5A08]              	MOV	BX,[MEMHI]
  3436 00000DA3 A1[5E08]                	MOV	AX,[AREA]
  3437 00000DA6 8EC0                    	MOV	ES,AX			;CALC WHAT WE NEEDED
  3438 00000DA8 29C3                    	SUB	BX,AX
  3439 00000DAA B44A                    	MOV	AH,SETBLOCK
  3440 00000DAC CD21                    	INT	21H			;GIVE THE REST BACK
  3441 00000DAE 06                      	PUSH	ES
  3442 00000DAF 8CC0                    	MOV	AX,ES
  3443 00000DB1 48                      	DEC	AX
  3444 00000DB2 8EC0                    	MOV	ES,AX			;Point to arena
  3445 00000DB4 26C70601000800          	MOV	word [ES:ARENA.OWNER],8	;Set impossible owner
  3446 00000DBB 07                      	POP	ES
  3447                                  
  3448                                  	;IF	NOEXEC   ; (NOEXEC = FALSE)
  3449                                  	;MOV	BX,0FFFFH		;ALLOCATE THE REST OF MEM FOR COMMAND
  3450                                  	;MOV	AH,ALLOC
  3451                                  	;INT	21H
  3452                                  	;MOV	AH,ALLOC
  3453                                  	;INT	21H
  3454                                  	;MOV	DS,AX
  3455                                  	;ENDIF
  3456                                  
  3457 00000DBC C3                      	retn
  3458                                  
  3459                                  ParaRound:
  3460 00000DBD 83C00F                  	ADD	AX,15
  3461 00000DC0 D1D8                    	RCR	AX,1
  3462 00000DC2 D1E8                    	SHR	AX,1
  3463 00000DC4 D1E8                    	SHR	AX,1
  3464 00000DC6 D1E8                    	SHR	AX,1
  3465 00000DC8 C3                      	retn
  3466                                  
  3467                                  ;-------------------------------------------------------------------------
  3468                                  ; 5/6/86. MSSTACK initialization routine.
  3469                                  	;IF	STACKSW 
  3470                                  
  3471                                  ;INCLUDE STKINIT.INC
  3472                                  
  3473                                  	;ENDIF
  3474                                  ;--------------------------------------------------------------------------
  3475                                  
  3476                                  ; 05/07/2018
  3477                                  
  3478                                  ; ----------------------------------------------------------------------
  3479                                  ; STKINIT.INC - MSDOS 3.3 - 24/07/1987
  3480                                  ; ----------------------------------------------------------------------
  3481                                  ; 10/06/2018 - Retro DOS v3.0
  3482                                  
  3483                                  KERNEL_SEGMENT	equ 0070h
  3484                                  
  3485                                  ; retrodos3.s (offset addresses in MSDOS.SYS or RETRODOS.SYS)
  3486                                  ; -----------------------------------------------------------
  3487                                  ; Note: These offset addressses must be chanqed when the code 
  3488                                  ; 	in retrodos3.s (MSDOS.SYS) file will be changed.
  3489                                  INT19SEM equ 1870h ; 05/07/2019 - retrodos3.lst
  3490                                  ORIG19	 equ 1874h ; 17/06/2018 - retrodos3.lst
  3491                                  INT19OLD02 equ ORIG19+4
  3492                                  INT19OLD08 equ ORIG19+8
  3493                                  INT19OLD09 equ ORIG19+12
  3494                                  INT19OLD0A equ ORIG19+16
  3495                                  INT19OLD0B equ ORIG19+20
  3496                                  INT19OLD0C equ ORIG19+24
  3497                                  INT19OLD0D equ ORIG19+28
  3498                                  INT19OLD0E equ ORIG19+32
  3499                                  INT19OLD70 equ ORIG19+36
  3500                                  INT19OLD72 equ ORIG19+40
  3501                                  INT19OLD73 equ ORIG19+44
  3502                                  INT19OLD74 equ ORIG19+48
  3503                                  INT19OLD76 equ ORIG19+52
  3504                                  INT19OLD77 equ ORIG19+56
  3505                                  
  3506                                  ; 06/07/2019
  3507                                  RE_INIT	equ 1B03h ; 1AA6h for MSDOS 3.3 IBMBIO.COM
  3508                                  		
  3509                                  ;	To follow the standard interrupt sharing scheme, MSSTACK.ASM
  3510                                  ;	has been modified. This initialization routine also has to
  3511                                  ;	be modified because for the interrupt level 7 and 15, FirstFlag
  3512                                  ;	should be set to signal that this interrupt handler is the
  3513                                  ;	first handler hooked to this interrupt vector.		
  3514                                  ;	We determine this by looking at the instruction pointed by
  3515                                  ;	this vector. If it is IRET, then this handler should be the
  3516                                  ;	first one. In our case, only the interrupt vector 77h is the
  3517                                  ;	interrupt level 15. (We don't hook interrupt level 7.)
  3518                                  ; 9/10/1986
  3519                                  ;	The followings are mainly due to M.R.Turner; PTM fix of P886 12/3/86
  3520                                  ;	Some design changes are needed to the above interrupt sharing
  3521                                  ;	method.  The above sharing scheme assumes that 1). Interrupt
  3522                                  ;	sharing is NEVER done on levels that have BIOS support. 2). "Phantom"
  3523                                  ;	interrupts would only be generated on levels 7 and 15.	
  3524                                  ;	These assumptions are not true any more. We have to use the FirstFlag
  3525                                  ;	for EVERY level of interrupt.  We will set the firstFlag on the following
  3526                                  ;	conditions:						
  3527                                  ;	 a.	 if the CS portion of the vector is 0000, then "first" 
  3528                                  ;	 b. else if CS:IP points to valid shared header, then NOT "first"
  3529                                  ;	 c. else if CS:IP points to an IRET, then "first"     
  3530                                  ;	 d. else if CS:IP points to DUMMY, then "first"       
  3531                                  ;	where DUMMY is - the CS portion must be F000, and the IP portion must
  3532                                  ;	be equal to the value at F000:FF01. This location is the initial value
  3533                                  ;	from VECTOR_TABLE for interrupt 7, one of the preserved addresses in all
  3534                                  ;	the BIOSes for all of the machines.			
  3535                                  ;								
  3536                                  ;	System design group requests BIOS to handle the phantom interrupts.
  3537                                  ;								
  3538                                  ;	The "Phantom" interrupt is an illegal interrupt such as an interrupt
  3539                                  ;	produced by the bogus adapter card even without interrupt request is
  3540                                  ;	set.  More specifically, 1). The 8259 has a feature when running in
  3541                                  ;	edge triggered mode to latch a pulse and present the interrupt when
  3542                                  ;	the processor indicates interrupt acknowledge (INTA).  The interrupt
  3543                                  ;	pulse was exist at the time of INTA to get a "phantom" interrupt.
  3544                                  ;	2). or, this is caused by adapter cards placing a glitch on the
  3545                                  ;	interrupt line. 					
  3546                                  ;								
  3547                                  ;	To handle those "phantom" interrupts, the main stack code will check
  3548                                  ;	the own FirstFlag, and if it is not "first" (which means the forward
  3549                                  ;	pointer points to the legal shared interrupt handler), then pass the
  3550                                  ;	control.  If it is the first, then the following action should be
  3551                                  ;	taken.	We don't have to implement skack logic in this case.   
  3552                                  ;								
  3553                                  ;	To implement this logic, we rather choose a simple method.
  3554                                  ;	If ont of the above "FirstFlag" conditions is met, we are not  
  3555                                  ;	going to hook this interrupt vector.  The reason is if the original
  3556                                  ;	vector points to "IRET" and do nothing, we don't need 
  3557                                  ;	to implement the stack logic for it.  This will simplify implementation
  3558                                  ;	while maintaining compatibility with the old version of DOS.
  3559                                  ;	This implies that in the main stack code, there might be a stack code
  3560                                  ;	that will never be used, a dead code.			
  3561                                  ;								
  3562                                  ; 12/3/86							
  3563                                  								
  3564                                  ;In - CS, DS -> sysinitseg, ES -> relocated stack code & data.	
  3565                                  
  3566                                  							
  3567                                  StackInit:
  3568                                  	; 04/07/2018				
  3569                                  								
  3570                                  	;PUSH	AX				;SAVE ALL	
  3571                                  	;PUSH	DS						
  3572                                  	;PUSH	ES						
  3573                                  	;PUSH	BX						
  3574                                  	;PUSH	CX						
  3575                                  	;PUSH	DX						
  3576                                  	;PUSH	DI						
  3577                                  	;PUSH	SI						
  3578                                  	;PUSH	BP						
  3579                                  								
  3580                                  ;Currently ES -> stack code area
  3581                                  	; 19/06/2018				
  3582                                  	;MOV	AX,[cs:STACK_COUNT]		;defined in CS
  3583 00000DC9 A1[0608]                	MOV	AX,[STACK_COUNT]
  3584 00000DCC 26A3[0200]              	MOV	[es:StackCount],AX		;defined in STACK CODE AREA
  3585                                  	;MOV	AX,[cs:STACK_SIZE]		;in CS		
  3586 00000DD0 A1[0808]                	MOV	AX,[STACK_SIZE]
  3587 00000DD3 26A3[0600]              	MOV	[es:StackSize],AX		;		
  3588                                  	;MOV	AX,[cs:STACK_ADDR]		; OFFSET
  3589 00000DD7 A1[0A08]                	MOV	AX,[STACK_ADDR]
  3590 00000DDA 89C5                    	mov	bp,ax	
  3591 00000DDC 26A3[0800]              	MOV	[es:Stacks],AX			
  3592                                  	;MOV	AX,[cs:STACK_ADDR+2]		; SEGMENT	
  3593 00000DE0 A1[0C08]                	MOV	AX,[STACK_ADDR+2]
  3594 00000DE3 26A3[0A00]              	MOV	[es:Stacks+2],AX			
  3595                                  								
  3596                                  ; INITIALIZE THE DATA FIELDS WITH THE PARAMETERS		
  3597                                  								
  3598                                  ; "FIRSTENTRY" WILL ALWAYS BE AT STACKS                       
  3599                                  								
  3600                                  	;MOV	BP,[es:Stacks]			; GET OFFSET OF STACK
  3601 00000DE7 26892E[0C00]            	MOV	[es:FirstEntry],BP				
  3602                                  								
  3603                                  ; THE STACKS WILL ALWAYS IMMEDIATELY FOLLOW THE TABLE ENTRIES	
  3604                                  								
  3605 00000DEC B80800                  	MOV	AX,EntrySize					
  3606 00000DEF 268B0E[0200]            	MOV	CX,[es:StackCount]		
  3607 00000DF4 F7E1                    	MUL	CX					
  3608 00000DF6 01E8                    	ADD	AX,BP						
  3609 00000DF8 26A3[0400]              	MOV	[es:StackAt],AX					
  3610 00000DFC 89C3                    	MOV	BX,AX						
  3611 00000DFE 83EB02                  	SUB	BX,2						
  3612                                  								
  3613                                  ; ZERO THE ENTIRE STACK AREA TO START WITH			
  3614                                  								
  3615 00000E01 268B3E[0400]            	MOV	DI,[es:StackAt]					
  3616 00000E06 26A1[0600]              	MOV	AX,[es:StackSize] 				
  3617 00000E0A F7E1                    	MUL	CX						
  3618 00000E0C 89C1                    	MOV	CX,AX						
  3619 00000E0E 31C0                    	xor	ax,ax						
  3620 00000E10 06                      	push	es						
  3621 00000E11 1F                      	pop	ds				;ds = Relocated stack code seg.
  3622                                  	;assume	ds:nothing					
  3623                                  ;Now, DS -> stack code area					
  3624 00000E12 8E06[0A00]              	MOV	ES,[Stacks+2]			; GET SEGMENT OF STACK AREA.
  3625 00000E16 FC                      	CLD							
  3626 00000E17 F3AA                    	REP	STOSB						
  3627                                  								
  3628 00000E19 8B0E[0200]              	MOV	CX,[StackCount]				
  3629                                  								
  3630                                  ; LOOP FOR "COUNT" TIMES, BUILDING A TABLE ENTRY              
  3631                                  ;  cs = sysinitseg, ds = Relocated stack code seg, es = segment of stack space
  3632                                  ;  CX = NUMBER OF ENTRIES					
  3633                                  ;  ES:BP => BASE OF STACKS - 2					
  3634                                  ;  ES:BX => FIRST TABLE ENTRY					
  3635                                  								
  3636                                  BUILDLOOP:							
  3637 00000E1D 26C6460000              	MOV	AllocByte,Free					
  3638 00000E22 26884601                	MOV	IntLevel,AL			;AX = 0 	
  3639 00000E26 26894602                	MOV	SavedSP,AX					
  3640 00000E2A 26894604                	MOV	SavedSS,AX					
  3641 00000E2E 031E[0600]              	ADD	BX,[StackSize] 				
  3642 00000E32 26895E06                	MOV	NewSP,BX					
  3643 00000E36 26892F                  	MOV	[ES:BX],BP					
  3644 00000E39 83C508                  	ADD	BP,EntrySize					
  3645                                  								
  3646 00000E3C E2DF                    	LOOP	BUILDLOOP					
  3647                                  								
  3648 00000E3E 83ED08                  	SUB	BP,EntrySize					
  3649 00000E41 892E[0E00]              	MOV	[LastEntry],BP 				
  3650 00000E45 892E[1000]              	MOV	[NextEntry],BP 				
  3651                                  								
  3652 00000E49 1E                      	push	ds ; (((*)))
  3653                                  						
  3654 00000E4A B800F0                  	mov	ax, 0F000h			;loook at the model byte
  3655 00000E4D 8ED8                    	mov	ds, ax						
  3656 00000E4F 803EFEFFF9              	cmp	byte [0FFFEh],0F9h		;convertible?(P12)
  3657 00000E54 1F                      	pop	ds						
  3658 00000E55 7504                    	jne	short Skip_DisableNMIS				
  3659                                  								
  3660 00000E57 B007                    	MOV	AL,07H				; DISABLE P12 NMIS
  3661 00000E59 E672                    	OUT	72H,AL						
  3662                                  								
  3663                                  Skip_DisableNMIS:						
  3664 00000E5B 31C0                    	XOR	AX,AX						
  3665 00000E5D 8EC0                    	MOV	ES,AX				;es - SEGID OF VECTOR TABLE AT 0
  3666                                  	;ASSUME	ES:NOTHING			;ds - Relocated Stack code segment
  3667                                  								
  3668 00000E5F FA                      	CLI							
  3669                                  								
  3670                                  	;IRP	AA,<02,08,09,70>				
  3671                                  	;						
  3672                                  	;MOV	SI,AA&H*4		;PASS WHERE VECTOR IS TO BE ADJUSTED
  3673                                  	;mov	di,offset Int19OLD&AA	;we have to set OLD&AA for Int19 handler too.
  3674                                  	;MOV	BX,OFFSET OLD&AA	;PASS WHERE TO SAVE ORIGINAL OWNER POINTER
  3675                                  	;MOV	DX,OFFSET INT&AA	;PASS WHERE NEW HANDLER IS
  3676                                  	;CALL	NEW_INIT_LOOP		;ADJUST THE VECTOR TO NEW HANDLER,
  3677                                  	;				;  SAVING POINTER TO ORIGINAL OWNER
  3678                                  	;ENDM
  3679                                  
  3680                                          ; ***
  3681 00000E60 BE0800                  	mov	si,02h*4
  3682 00000E63 BF7818                  	mov	di,INT19OLD02 
  3683 00000E66 BB[1200]                	MOV	BX,Old02		;PASS WHERE TO SAVE ORIGINAL OWNER POINTER
  3684 00000E69 BA[1600]                	MOV	DX,Int02		;PASS WHERE NEW HANDLER IS
  3685 00000E6C E86902                  	CALL	NEW_INIT_LOOP
  3686                                  						
  3687 00000E6F BE2000                  	mov	si,08h*4
  3688 00000E72 BF7C18                  	mov	di,INT19OLD08 
  3689 00000E75 BB[A600]                	MOV	BX,Old08
  3690 00000E78 BA[AA00]                	MOV	DX,Int08
  3691 00000E7B E85A02                  	CALL	NEW_INIT_LOOP
  3692                                  
  3693 00000E7E BE2400                  	mov	si,09h*4
  3694 00000E81 BF8018                  	mov	di,INT19OLD09
  3695 00000E84 BB[2001]                	MOV	BX,Old09
  3696 00000E87 BA[2401]                	MOV	DX,Int09
  3697 00000E8A E84B02                  	CALL	NEW_INIT_LOOP
  3698                                  
  3699 00000E8D BEC001                  	mov	si,70h*4
  3700 00000E90 BF9818                  	mov	di,INT19OLD70
  3701 00000E93 BB[9E01]                	MOV	BX,Old70
  3702 00000E96 BA[A201]                	MOV	DX,Int70
  3703 00000E99 E83C02                  	CALL	NEW_INIT_LOOP
  3704                                  
  3705                                  	; ***
  3706                                  								
  3707                                  	;IRP	AA,<0A,0B,0C,0D,0E,72,73,74,76,77>	;shared interrupts
  3708                                  								
  3709                                  	;MOV	SI,AA&H*4		;PASS WHERE VECTOR IS TO BE ADJUSTED
  3710                                  	;push	ds			;save relocated stack code segment
  3711                                  	;lds	bx, es:[si]		;ds:bx -> original interrupt handler
  3712                                  	;push	ds						
  3713                                  	;pop	dx			;dx = segment value	
  3714                                  
  3715                                  	;cmp	dx,0
  3716                                  	;jz	int&AA&_first
  3717                                  
  3718                                  	;cmp	byte ptr ds:[bx],0cfh	;Does vector point to an IRET?
  3719                                  	;jz	int&AA&_first
  3720                                  
  3721                                  	;cmp	word ptr ds:[bx.6],424Bh ;Magic offset (see INT&AA, msstack.inc)
  3722                                  	;jz	int&AA&_Not_first
  3723                                  
  3724                                  	;cmp	dx,0f000h		;ROM BIOS segment
  3725                                  	;jnz	int&AA&_Not_first
  3726                                  
  3727                                  	;push	es
  3728                                  	;push	dx
  3729                                  	;mov	dx,0f000h
  3730                                  	;mov	es,dx
  3731                                  	;cmp	bx,word ptr es:0ff01h
  3732                                         	;pop	dx
  3733                                  	;pop	es
  3734                                  	;jz	int&AA&_first
  3735                                  
  3736                                  ;int&AA&_Not_first:			;Not the first. We are going to hook vector.
  3737                                  	;pop	ds						
  3738                                  	;mov	di, offset Int19OLD&AA	;we have to set OLD&AA for Int19 handler too.
  3739                                  	;mov	BX, OFFSET OLD&AA	;PASS WHERE TO SAVE ORIGINAL OWNER POINTER
  3740                                  	;MOV	DX, OFFSET INT&AA	;PASS WHERE NEW HANDLER IS
  3741                                  	;CALL	NEW_INIT_LOOP		;ADJUST THE VECTOR TO NEW HANDLER, SAVING
  3742                                  					;POINTER TO ORIGINAL OWNER.
  3743                                  	;jmp	short int&AA&_end				
  3744                                  ;int&AA&_first:				;the first. Don't have to hook stack code.
  3745                                  	;pop	ds						
  3746                                  ;int&AA&_end:							
  3747                                  								
  3748                                  	;ENDM	
  3749                                  
  3750                                  	; ****
  3751                                  
  3752                                  	; 19/06/2018 - Retro DOS v3.0 (IBMDOS 3.3, IBMBIO.COM, SYSINIT)
  3753                                  							
  3754 00000E9C BE2800                  	MOV	SI,0AH*4		;PASS WHERE VECTOR IS TO BE ADJUSTED
  3755 00000E9F 1E                      	push	ds			;save relocated stack code segment
  3756 00000EA0 26C51C                  	lds	bx,[es:si]		;ds:bx -> original interrupt handler
  3757 00000EA3 1E                      	push	ds						
  3758 00000EA4 5A                      	pop	dx			;dx = segment value	
  3759                                  
  3760 00000EA5 83FA00                  	cmp	dx,0
  3761 00000EA8 7427                    	jz	short int0A_first
  3762                                  
  3763 00000EAA 803FCF                  	cmp	byte [bx],0CFh		;Does vector point to an IRET?
  3764 00000EAD 7422                    	jz	short int0A_first
  3765                                  
  3766 00000EAF 817F064B42              	cmp	word [bx+6],424Bh	;Magic offset (see INT&AA, msstack.inc)
  3767 00000EB4 740C                    	jz	short int0A_Not_first
  3768                                  
  3769 00000EB6 81FA00F0                	cmp	dx,0F000h		;ROM BIOS segment
  3770 00000EBA 7506                    	jnz	short int0A_Not_first
  3771                                  
  3772 00000EBC 3B1E01FF                	cmp	bx,[0FF01h]
  3773 00000EC0 740F                    	jz	short int0A_first
  3774                                  
  3775                                  int0A_Not_first:			;Not the first. We are going to hook vector.
  3776 00000EC2 1F                      	pop	ds ; (((*)))						
  3777 00000EC3 BF8418                  	mov	di,INT19OLD0A		;we have to set OLD&AA for Int19 handler too.
  3778 00000EC6 BB[1A02]                	MOV	BX,Old0A		;PASS WHERE TO SAVE ORIGINAL OWNER POINTER
  3779 00000EC9 BA[1802]                	MOV	DX,Int0A		;PASS WHERE NEW HANDLER IS
  3780 00000ECC E80902                  	CALL	NEW_INIT_LOOP		;ADJUST THE VECTOR TO NEW HANDLER, SAVING
  3781                                  					;POINTER TO ORIGINAL OWNER.
  3782 00000ECF EB01                    	jmp	short int0A_end				
  3783                                  int0A_first:				;the first. Don't have to hook stack code.
  3784 00000ED1 1F                      	pop	ds ; (((*)))						
  3785                                  int0A_end:							
  3786 00000ED2 BE2C00                  	MOV	SI,0BH*4
  3787 00000ED5 1E                      	push	ds
  3788 00000ED6 26C51C                  	lds	bx,[es:si]
  3789 00000ED9 1E                      	push	ds						
  3790 00000EDA 5A                      	pop	dx
  3791                                  
  3792 00000EDB 83FA00                  	cmp	dx,0
  3793 00000EDE 7427                    	jz	short int0B_first
  3794                                  
  3795 00000EE0 803FCF                  	cmp	byte [bx],0CFh
  3796 00000EE3 7422                    	jz	short int0B_first
  3797                                  
  3798 00000EE5 817F064B42              	cmp	word [bx+6],424Bh
  3799 00000EEA 740C                    	jz	short int0B_Not_first
  3800                                  
  3801 00000EEC 81FA00F0                	cmp	dx,0F000h
  3802 00000EF0 7506                    	jnz	short int0B_Not_first
  3803                                  
  3804 00000EF2 3B1E01FF                	cmp	bx,[0FF01h]
  3805 00000EF6 740F                    	jz	short int0B_first
  3806                                  
  3807                                  int0B_Not_first:
  3808 00000EF8 1F                      	pop	ds						
  3809 00000EF9 BF8818                  	mov	di,INT19OLD0B
  3810 00000EFC BB[A202]                	MOV	BX,Old0B
  3811 00000EFF BA[A002]                	MOV	DX,Int0B
  3812 00000F02 E8D301                  	CALL	NEW_INIT_LOOP
  3813 00000F05 EB01                    	jmp	short int0B_end				
  3814                                  int0B_first:
  3815 00000F07 1F                      	pop	ds						
  3816                                  int0B_end:															
  3817 00000F08 BE3000                  	MOV	SI,0CH*4
  3818 00000F0B 1E                      	push	ds
  3819 00000F0C 26C51C                  	lds	bx,[es:si]
  3820 00000F0F 1E                      	push	ds						
  3821 00000F10 5A                      	pop	dx
  3822                                  
  3823 00000F11 83FA00                  	cmp	dx,0
  3824 00000F14 7427                    	jz	short int0C_first
  3825                                  
  3826 00000F16 803FCF                  	cmp	byte [bx],0CFh
  3827 00000F19 7422                    	jz	short int0C_first
  3828                                  
  3829 00000F1B 817F064B42              	cmp	word [bx+6],424Bh
  3830 00000F20 740C                    	jz	short int0C_Not_first
  3831                                  
  3832 00000F22 81FA00F0                	cmp	dx,0F000h
  3833 00000F26 7506                    	jnz	short int0C_Not_first
  3834                                  
  3835 00000F28 3B1E01FF                	cmp	bx,[0FF01h]
  3836 00000F2C 740F                    	jz	short int0C_first
  3837                                  
  3838                                  int0C_Not_first:
  3839 00000F2E 1F                      	pop	ds						
  3840 00000F2F BF8C18                  	mov	di,INT19OLD0C
  3841 00000F32 BB[2A03]                	MOV	BX,Old0C
  3842 00000F35 BA[2803]                	MOV	DX,Int0C
  3843 00000F38 E89D01                  	CALL	NEW_INIT_LOOP
  3844 00000F3B EB01                    	jmp	short int0C_end				
  3845                                  int0C_first:
  3846 00000F3D 1F                      	pop	ds						
  3847                                  int0C_end:		
  3848 00000F3E BE3400                  	MOV	SI,0DH*4
  3849 00000F41 1E                      	push	ds
  3850 00000F42 26C51C                  	lds	bx,[es:si]
  3851 00000F45 1E                      	push	ds						
  3852 00000F46 5A                      	pop	dx
  3853                                  
  3854 00000F47 83FA00                  	cmp	dx,0
  3855 00000F4A 7427                    	jz	short int0D_first
  3856                                  
  3857 00000F4C 803FCF                  	cmp	byte [bx],0CFh
  3858 00000F4F 7422                    	jz	short int0D_first
  3859                                  
  3860 00000F51 817F064B42              	cmp	word [bx+6],424Bh
  3861 00000F56 740C                    	jz	short int0D_Not_first 	
  3862                                  
  3863 00000F58 81FA00F0                	cmp	dx,0F000h
  3864 00000F5C 7506                    	jnz	short int0D_Not_first
  3865                                  
  3866 00000F5E 3B1E01FF                	cmp	bx,[0FF01h]
  3867 00000F62 740F                    	jz	short int0D_first
  3868                                  
  3869                                  int0D_Not_first:
  3870 00000F64 1F                      	pop	ds						
  3871 00000F65 BF9018                  	mov	di,INT19OLD0D
  3872 00000F68 BB[B203]                	MOV	BX,Old0D
  3873 00000F6B BA[B003]                	MOV	DX,Int0D
  3874 00000F6E E86701                  	CALL	NEW_INIT_LOOP
  3875 00000F71 EB01                    	jmp	short int0D_end				
  3876                                  int0D_first:
  3877 00000F73 1F                      	pop	ds						
  3878                                  int0D_end:
  3879 00000F74 BE3800                  	MOV	SI,0EH*4
  3880 00000F77 1E                      	push	ds
  3881 00000F78 26C51C                  	lds	bx,[es:si]
  3882 00000F7B 1E                      	push	ds						
  3883 00000F7C 5A                      	pop	dx
  3884                                  
  3885 00000F7D 83FA00                  	cmp	dx,0
  3886 00000F80 7427                    	jz	short int0E_first
  3887                                  
  3888 00000F82 803FCF                  	cmp	byte [bx],0CFh
  3889 00000F85 7422                    	jz	short int0E_first
  3890                                  
  3891 00000F87 817F064B42              	cmp	word [bx+6],424Bh
  3892 00000F8C 740C                    	jz	short int0E_Not_first
  3893                                  
  3894 00000F8E 81FA00F0                	cmp	dx,0F000h
  3895 00000F92 7506                    	jnz	short int0E_Not_first
  3896                                  
  3897 00000F94 3B1E01FF                	cmp	bx,[0FF01h]
  3898 00000F98 740F                    	jz	short int0E_first
  3899                                  
  3900                                  int0E_Not_first:
  3901 00000F9A 1F                      	pop	ds						
  3902 00000F9B BF9418                  	mov	di,INT19OLD0E
  3903 00000F9E BB[3A04]                	MOV	BX,Old0E
  3904 00000FA1 BA[3804]                	MOV	DX,Int0E
  3905 00000FA4 E83101                  	CALL	NEW_INIT_LOOP
  3906 00000FA7 EB01                    	jmp	short int0E_end				
  3907                                  int0E_first:
  3908 00000FA9 1F                      	pop	ds						
  3909                                  int0E_end:
  3910 00000FAA BEC801                  	MOV	SI,72H*4		;PASS WHERE VECTOR IS TO BE ADJUSTED
  3911 00000FAD 1E                      	push	ds			;save relocated stack code segment
  3912 00000FAE 26C51C                  	lds	bx,[es:si]		;ds:bx -> original interrupt handler
  3913 00000FB1 1E                      	push	ds						
  3914 00000FB2 5A                      	pop	dx			;dx = segment value	
  3915                                  
  3916 00000FB3 83FA00                  	cmp	dx,0
  3917 00000FB6 7427                    	jz	short int72_first
  3918                                  
  3919 00000FB8 803FCF                  	cmp	byte [bx],0CFh		;Does vector point to an IRET?
  3920 00000FBB 7422                    	jz	short int72_first
  3921                                  
  3922 00000FBD 817F064B42              	cmp	word [bx+6],424Bh	;Magic offset (see INT&AA, msstack.inc)
  3923 00000FC2 740C                    	jz	short int72_Not_first
  3924                                  
  3925 00000FC4 81FA00F0                	cmp	dx,0F000h		;ROM BIOS segment
  3926 00000FC8 7506                    	jnz	short int72_Not_first
  3927                                  
  3928 00000FCA 3B1E01FF                	cmp	bx,[0FF01h]
  3929 00000FCE 740F                    	jz	short int72_first
  3930                                  
  3931                                  int72_Not_first:			;Not the first. We are going to hook vector.
  3932 00000FD0 1F                      	pop	ds						
  3933 00000FD1 BF9C18                  	mov	di,INT19OLD72		;we have to set OLD&AA for Int19 handler too.
  3934 00000FD4 BB[C204]                	MOV	BX,Old72		;PASS WHERE TO SAVE ORIGINAL OWNER POINTER
  3935 00000FD7 BA[C004]                	MOV	DX,Int72		;PASS WHERE NEW HANDLER IS
  3936 00000FDA E8FB00                  	CALL	NEW_INIT_LOOP		;ADJUST THE VECTOR TO NEW HANDLER, SAVING
  3937                                  					;POINTER TO ORIGINAL OWNER.
  3938 00000FDD EB01                    	jmp	short int72_end				
  3939                                  int72_first:				;the first. Don't have to hook stack code.
  3940 00000FDF 1F                      	pop	ds						
  3941                                  int72_end:							
  3942 00000FE0 BECC01                  	MOV	SI,73H*4
  3943 00000FE3 1E                      	push	ds
  3944 00000FE4 26C51C                  	lds	bx,[es:si]
  3945 00000FE7 1E                      	push	ds						
  3946 00000FE8 5A                      	pop	dx
  3947                                  
  3948 00000FE9 83FA00                  	cmp	dx,0
  3949 00000FEC 7427                    	jz	short int73_first
  3950                                  
  3951 00000FEE 803FCF                  	cmp	byte [bx],0CFh
  3952 00000FF1 7422                    	jz	short int73_first
  3953                                  
  3954 00000FF3 817F064B42              	cmp	word [bx+6],424Bh
  3955 00000FF8 740C                    	jz	short int73_Not_first
  3956                                  
  3957 00000FFA 81FA00F0                	cmp	dx,0F000h
  3958 00000FFE 7506                    	jnz	short int73_Not_first
  3959                                  
  3960 00001000 3B1E01FF                	cmp	bx,[0FF01h]
  3961 00001004 740F                    	jz	short int73_first
  3962                                  
  3963                                  int73_Not_first:
  3964 00001006 1F                      	pop	ds						
  3965 00001007 BFA018                  	mov	di,INT19OLD73
  3966 0000100A BB[4A05]                	MOV	BX,Old73
  3967 0000100D BA[4805]                	MOV	DX,Int73
  3968 00001010 E8C500                  	CALL	NEW_INIT_LOOP
  3969 00001013 EB01                    	jmp	short int73_end				
  3970                                  int73_first:
  3971 00001015 1F                      	pop	ds						
  3972                                  int73_end:															
  3973 00001016 BED001                  	MOV	SI,74H*4
  3974 00001019 1E                      	push	ds
  3975 0000101A 26C51C                  	lds	bx,[es:si]
  3976 0000101D 1E                      	push	ds						
  3977 0000101E 5A                      	pop	dx
  3978                                  
  3979 0000101F 83FA00                  	cmp	dx,0
  3980 00001022 7427                    	jz	short int74_first
  3981                                  
  3982 00001024 803FCF                  	cmp	byte [bx],0CFh
  3983 00001027 7422                    	jz	short int74_first
  3984                                  
  3985 00001029 817F064B42              	cmp	word [bx+6],424Bh
  3986 0000102E 740C                    	jz	short int74_Not_first
  3987                                  
  3988 00001030 81FA00F0                	cmp	dx,0F000h
  3989 00001034 7506                    	jnz	short int74_Not_first
  3990                                  
  3991 00001036 3B1E01FF                	cmp	bx,[0FF01h]
  3992 0000103A 740F                    	jz	short int74_first
  3993                                  
  3994                                  int74_Not_first:
  3995 0000103C 1F                      	pop	ds						
  3996 0000103D BFA418                  	mov	di,INT19OLD74
  3997 00001040 BB[D205]                	MOV	BX,Old74
  3998 00001043 BA[D005]                	MOV	DX,Int74
  3999 00001046 E88F00                  	CALL	NEW_INIT_LOOP
  4000 00001049 EB01                    	jmp	short int74_end				
  4001                                  int74_first:
  4002 0000104B 1F                      	pop	ds						
  4003                                  int74_end:		
  4004 0000104C BED801                  	MOV	SI,76H*4
  4005 0000104F 1E                      	push	ds
  4006 00001050 26C51C                  	lds	bx,[es:si]
  4007 00001053 1E                      	push	ds						
  4008 00001054 5A                      	pop	dx
  4009                                  
  4010 00001055 83FA00                  	cmp	dx,0
  4011 00001058 7427                    	jz	short int76_first
  4012                                  
  4013 0000105A 803FCF                  	cmp	byte [bx],0CFh
  4014 0000105D 7422                    	jz	short int76_first
  4015                                  
  4016 0000105F 817F064B42              	cmp	word [bx+6],424Bh
  4017 00001064 740C                    	jz	short int76_Not_first
  4018                                  
  4019 00001066 81FA00F0                	cmp	dx,0F000h
  4020 0000106A 7506                    	jnz	short int76_Not_first
  4021                                  
  4022 0000106C 3B1E01FF                	cmp	bx,[0FF01h]
  4023 00001070 740F                    	jz	short int76_first
  4024                                  
  4025                                  int76_Not_first:
  4026 00001072 1F                      	pop	ds						
  4027 00001073 BFA818                  	mov	di,INT19OLD76
  4028 00001076 BB[5A06]                	MOV	BX,Old76
  4029 00001079 BA[5806]                	MOV	DX,Int76
  4030 0000107C E85900                  	CALL	NEW_INIT_LOOP
  4031 0000107F EB01                    	jmp	short int76_end				
  4032                                  int76_first:
  4033 00001081 1F                      	pop	ds						
  4034                                  int76_end:
  4035 00001082 BEDC01                  	MOV	SI,77H*4
  4036 00001085 1E                      	push	ds
  4037 00001086 26C51C                  	lds	bx,[es:si]
  4038 00001089 1E                      	push	ds						
  4039 0000108A 5A                      	pop	dx
  4040                                  
  4041 0000108B 83FA00                  	cmp	dx,0
  4042 0000108E 7427                    	jz	short int77_first
  4043                                  
  4044 00001090 803FCF                  	cmp	byte [bx],0CFh
  4045 00001093 7422                    	jz	short int77_first
  4046                                  
  4047 00001095 817F064B42              	cmp	word [bx+6],424Bh
  4048 0000109A 740C                    	jz	short int77_Not_first
  4049                                  
  4050 0000109C 81FA00F0                	cmp	dx,0F000h
  4051 000010A0 7506                    	jnz	short int77_Not_first
  4052                                  
  4053 000010A2 3B1E01FF                	cmp	bx,[0FF01h]
  4054 000010A6 740F                    	jz	short int77_first
  4055                                  
  4056                                  int77_Not_first:
  4057 000010A8 1F                      	pop	ds						
  4058 000010A9 BFAC18                  	mov	di,INT19OLD77
  4059 000010AC BB[E206]                	MOV	BX,Old77
  4060 000010AF BA[E006]                	MOV	DX,Int77
  4061 000010B2 E82300                  	CALL	NEW_INIT_LOOP
  4062 000010B5 EB01                    	jmp	short int77_end				
  4063                                  int77_first:
  4064 000010B7 1F                      	pop	ds						
  4065                                  int77_end:
  4066                                  
  4067                                  	; ****					
  4068                                  								
  4069 000010B8 1E                      	push	ds						
  4070 000010B9 B800F0                  	mov	ax,0F000h		;loook at the model byte
  4071 000010BC 8ED8                    	mov	ds,ax						
  4072 000010BE 803EFEFFF9              	cmp	byte [0FFFEh],0F9h	;convertible?(P12)
  4073 000010C3 1F                      	pop	ds						
  4074 000010C4 7504                    	jne	short Skip_EnableNMIS 				
  4075                                  								
  4076 000010C6 B027                    	MOV	AL,27H			; ENABLE P12 NMIS
  4077 000010C8 E672                    	OUT	72H,AL						
  4078                                  								
  4079                                  Skip_EnableNMIS:						
  4080 000010CA FB                      	STI							
  4081                                  	;MOV	AX,code 					
  4082 000010CB B87000                  	mov	ax,KERNEL_SEGMENT
  4083 000010CE 8ED8                    	MOV	DS,AX						
  4084                                  	;ASSUME	DS:CODE 					
  4085                                  								
  4086                                  ;	MOV	SI,OFFSET STKMSG1				
  4087                                  ;	CALL	WRMSG						
  4088                                  								
  4089 000010D0 C606701801              	mov	byte [INT19SEM],1	; INDICATE THAT INT 19	
  4090                                  					; INITIALIZATION IS COMPLETE
  4091                                  
  4092                                  	; 04/07/2018
  4093 000010D5 0E                      	push	cs
  4094 000010D6 1F                      	pop	ds
  4095                                  								
  4096                                  	;POP	BP			; RESTORE ALL		
  4097                                  	;POP	SI						
  4098                                  	;POP	DI						
  4099                                  	;POP	DX						
  4100                                  	;POP	CX						
  4101                                  	;POP	BX						
  4102                                  	;POP	ES						
  4103                                  	;POP	DS						
  4104                                  	;assume	ds:sysinitseg					
  4105                                  	;POP	AX						
  4106 000010D7 C3                      	RETN							
  4107                                  ;								
  4108                                  								
  4109                                  NEW_INIT_LOOP:				
  4110                                  ;INPUT: SI=OFSET INTO VECTOR TABLE OF THE PARTICULAR INT VECTOR BEING ADJUSTED
  4111                                  ;	BX=ds:OFFSET OF OLDxx, WHERE WILL BE SAVED THE POINTER TO ORIGINAL OWNER
  4112                                  ;	DX=ds:OFFSET OF INTxx, THE NEW INTERRUPT HANDLER	
  4113                                  ;	di=offset value of Int19OLD&AA variable in BIOS.	
  4114                                  ;	es=ZERO, SEGID OF VECTOR TABLE				
  4115                                  ;	ds=Relocated Stack code segment 			
  4116                                  								
  4117                                  	;MOV	AX,[ES:SI+0]	   	;REMEMBER OFFSET IN VECTOR
  4118 000010D8 268B04                  	mov	ax,[ES:SI]
  4119 000010DB 8907                    	MOV	[BX],AX			; TO ORIGINAL OWNER in DS
  4120 000010DD 268B4402                	MOV	AX,[es:SI+2]		;REMEMBER SEGID IN VECTOR
  4121 000010E1 894702                  	MOV	[BX+2],AX		; TO ORIGINAL OWNER in DS
  4122 000010E4 1E                      	push	ds						
  4123                                  	;mov	ax,code
  4124 000010E5 B87000                  	mov	ax,KERNEL_SEGMENT					
  4125 000010E8 8ED8                    	mov	ds,ax			;Set Int19OLDxx value in BIOS for
  4126                                  	;mov	ax,[es:si+0]		;Int 19 handler 
  4127 000010EA 268B04                  	mov	ax,[es:si]	
  4128 000010ED 8905                    	mov	[di],ax				
  4129 000010EF 268B4402                	mov	ax,[es:si+2]					
  4130 000010F3 894502                  	mov	[di+2],ax				
  4131 000010F6 1F                      	pop	ds						
  4132                                  								
  4133                                  	;MOV	[es:SI+0],DX		;SET VECTOR TO POINT TO NEW INT HANDLER
  4134 000010F7 268914                  	mov	[es:si],dx
  4135 000010FA 268C5C02                	MOV	[es:SI+2],ds					
  4136 000010FE C3                      	RETN							
  4137                                  
  4138                                  ;SYSINITSEG	ENDS
  4139                                  ;	END
  4140                                  
  4141                                  ;align 16 ; 19/06/2018
  4142                                  
  4143                                  ; ----------------------------------------------------------------------
  4144                                  ; SYSCONF.ASM - MSDOS 3.3 - 24/07/1987
  4145                                  ; ----------------------------------------------------------------------
  4146                                  ; 10/06/2018 - Retro DOS v3.0
  4147                                  ; 25/03/2018 - Retro DOS v2.0
  4148                                  
  4149                                  ;	IF	STACKSW
  4150                                  ;;
  4151                                  ;; Internal Stack Parameters
  4152                                  ;EntrySize		equ	8
  4153                                  ;
  4154                                  ;MinCount		equ	8
  4155                                  ;DefaultCount		equ	9
  4156                                  ;MaxCount		equ	64
  4157                                  ;
  4158                                  ;MinSize 		equ	32
  4159                                  ;DefaultSize		equ	128
  4160                                  ;MaxSize 		equ	512
  4161                                  ;
  4162                                  ;	extrn  stack_count:word
  4163                                  ;	extrn  stack_size:word
  4164                                  ;	extrn  stack_addr:dword
  4165                                  ;
  4166                                  ;	ENDIF
  4167                                  
  4168                                  DOCONF: 		;Take care of Config.sys file.
  4169                                  	
  4170                                  	; 10/06/2018 - Retro DOS v3.0	
  4171                                  	
  4172 000010FF 0E                      	PUSH    CS
  4173 00001100 1F                              POP     DS
  4174                                  
  4175                                  	; 13/04/2018 - Retro DOS v2.0
  4176                                  	
  4177 00001101 B80037                  	MOV     AX,(CHAR_OPER*256)	; GET SWITCH CHARACTER
  4178 00001104 CD21                    	INT     21H
  4179 00001106 8816[2008]              	MOV     [COMMAND_LINE+1],DL
  4180                                  
  4181 0000110A BA[C31B]                        MOV     DX,CONFIG		; NOW POINTING TO FILE DESCRIPTION
  4182 0000110D B8003D                          MOV     AX,(OPEN*256)		; OPEN FILE "CONFIG.SYS"
  4183 00001110 F9                              STC				; IN CASE OF INT 24
  4184 00001111 CD21                            INT     21H                     ; FUNCTION REQUEST
  4185                                          ;JC     SHORT ENDCONF
  4186                                          ;JMP    NOPROB			; PROBLEM WITH OPEN
  4187 00001113 730A                    	JNC	short NOPROB
  4188                                  
  4189                                  ENDCONF:
  4190 00001115 C3                      	RETN
  4191                                  
  4192                                  BADOP:  
  4193 00001116 BA[5A1D]                	MOV     DX,BADOPM		; WANT TO PRINT COMMAND ERROR
  4194 00001119 E8270A                          CALL    PRINT
  4195 0000111C E98500                          JMP     COFF
  4196                                  
  4197                                  NOPROB:
  4198                                  					; GET FILE SIZE (NOTE < 64K!!)
  4199 0000111F 89C3                    	MOV     BX,AX
  4200 00001121 31C9                            XOR     CX,CX
  4201 00001123 31D2                            XOR     DX,DX
  4202 00001125 B80242                          MOV     AX,(LSEEK*256)+2
  4203 00001128 CD21                            INT     21H
  4204 0000112A A3[5108]                        MOV     [COUNT],AX
  4205 0000112D 31D2                            XOR     DX,DX
  4206 0000112F B80042                          MOV     AX,(LSEEK*256)		; Reset pointer to beginning of file
  4207 00001132 CD21                            INT     21H
  4208                                          
  4209 00001134 8CCA                    	MOV     DX,CS
  4210 00001136 A1[5108]                        MOV     AX,[COUNT]
  4211 00001139 E881FC                          call	ParaRound
  4212 0000113C 29C2                            SUB     DX,AX
  4213 0000113E 83EA11                          SUB     DX,11H                  ; ROOM FOR HEADER
  4214 00001141 8916[1708]              	MOV	[CONFBOT],DX		; Config starts here
  4215 00001145 E8AFF9                  	CALL	TEMPCDS 		; Finally get CDS to "safe" location
  4216                                  
  4217 00001148 2E8B16[1708]                    MOV	DX,[CS:CONFBOT] ; 19/06/2018
  4218 0000114D 8EDA                            MOV     DS,DX
  4219 0000114F 8EC2                            MOV     ES,DX
  4220 00001151 31D2                            XOR     DX,DX
  4221 00001153 2E8B0E[5108]            	MOV	CX,[CS:COUNT] ; 19/06/2018
  4222 00001158 B43F                            MOV     AH,READ
  4223 0000115A F9                              STC                             ; IN CASE OF INT 24
  4224 0000115B CD21                            INT     21H                     ; Function request
  4225 0000115D 9C                              PUSHF
  4226                                  ;
  4227                                  ; Find the EOF mark in the file. If present, then trim length.
  4228                                  ;	
  4229 0000115E 50                      	PUSH	AX
  4230 0000115F 57                      	PUSH	DI
  4231 00001160 51                      	PUSH	CX
  4232 00001161 B01A                    	MOV	AL,1Ah			; eof mark
  4233 00001163 89D7                    	MOV	DI,DX			; point ro buffer
  4234 00001165 E305                    	JCXZ	PUTEOL			; no chars
  4235 00001167 F2AE                    	REPNZ	SCASB			; find end
  4236 00001169 7501                    	JNZ	SHORT PUTEOL		; none found and count exahusted
  4237                                  ;
  4238                                  ; We found a 1A.  Back up
  4239                                  ;
  4240 0000116B 4F                      	DEC	DI			; backup past 1A
  4241                                  ;
  4242                                  ;  Just for the halibut, stick in an extra EOL
  4243                                  ;
  4244                                  PUTEOL:
  4245 0000116C B00D                    	MOV	AL,13
  4246 0000116E AA                      	STOSB				; CR
  4247 0000116F B00A                    	MOV	AL,10
  4248 00001171 AA                      	STOSB				; LF
  4249 00001172 29D7                    	SUB	DI,DX			; difference moved
  4250                                  	; 19/06/2018
  4251 00001174 2E893E[5108]            	MOV	[CS:COUNT],DI		; new count
  4252                                  ;
  4253                                  ; Restore registers
  4254                                  ;
  4255 00001179 59                      	POP	CX
  4256 0000117A 5F                      	POP	DI
  4257 0000117B 58                      	POP	AX
  4258                                  
  4259 0000117C 0E                              PUSH	CS
  4260 0000117D 1F                              POP	DS
  4261                                  
  4262 0000117E 50                              PUSH    AX
  4263 0000117F B43E                            MOV     AH,CLOSE
  4264 00001181 CD21                            INT     21H
  4265 00001183 58                              POP     AX
  4266 00001184 9D                              POPF
  4267 00001185 7204                            JC      SHORT CONFERR		; IF NOT WE'VE GOT A PROBLEM
  4268 00001187 39C1                            CMP     CX,AX
  4269 00001189 7407                            JZ      SHORT GETCOM		; COULDN'T READ THE FILE
  4270                                  CONFERR:
  4271 0000118B BA[C31B]                        MOV     DX,CONFIG		; WANT TO PRINT CONFIG ERROR
  4272 0000118E E89409                          CALL    BADFIL
  4273                                  ENDCONV:
  4274                                  	;JMP	ENDCONF
  4275 00001191 C3                      	RETN
  4276                                  
  4277                                  GETCOM:
  4278 00001192 E84006                          CALL    ORGANIZE                ; ORGANIZE THE FILE
  4279 00001195 E88404                          CALL    GETCHR
  4280                                  
  4281 00001198 72F7                    CONFLP: JC      SHORT ENDCONV
  4282 0000119A 88C4                            MOV     AH,AL
  4283 0000119C E87D04                          CALL    GETCHR
  4284 0000119F 730A                    	JNC	SHORT TRYB
  4285 000011A1 E972FF                  	JMP	BADOP
  4286                                  
  4287                                  COFF:   
  4288 000011A4 0E                      	PUSH    CS
  4289 000011A5 1F                              POP     DS
  4290 000011A6 E8DF06                          CALL    NEWLINE
  4291 000011A9 EBED                            JMP     SHORT CONFLP
  4292                                  
  4293                                  ;------------------------------------------------------------------------------
  4294                                  ; Buffer command
  4295                                  ;------------------------------------------------------------------------------
  4296                                  TRYB:	
  4297 000011AB 80FC42                  	CMP     AH,'B'                  ; BUFFER COMMAND?
  4298 000011AE 7512                            JNZ     SHORT TRYC
  4299 000011B0 E88807                          CALL    GETNUM
  4300 000011B3 7405                            JZ      SHORT TRYBBAD
  4301 000011B5 83F864                          CMP     AX,100
  4302 000011B8 7203                            JB	SHORT SAVEBUF
  4303                                  TRYBBAD:
  4304 000011BA E959FF                  	JMP	BADOP
  4305                                  SAVEBUF:
  4306 000011BD A2[1108]                        MOV     [BUFFERS],AL
  4307                                  COFFJ1:
  4308 000011C0 EBE2                            JMP     SHORT COFF
  4309                                  
  4310                                  ;------------------------------------------------------------------------------
  4311                                  ; Break command
  4312                                  ;------------------------------------------------------------------------------
  4313                                  TRYC:   
  4314 000011C2 80FC43                  	CMP     AH,'C'
  4315                                          ;JZ	SHORT GOTC
  4316                                          ;JMP	SHORT TRYD
  4317 000011C5 7527                    	JNZ	SHORT TRYD
  4318                                  GOTC:
  4319 000011C7 3C4F                            CMP     AL,'O'                  ; FIRST LETTER OF "ON" OR "OFF"
  4320 000011C9 7520                            JNZ     SHORT TRYCBAD
  4321 000011CB E84E04                          CALL    GETCHR
  4322 000011CE 721B                            JC      SHORT TRYCBAD
  4323 000011D0 3C4E                            CMP     AL,'N'                  ; SECOND LETTER OF "ON"
  4324 000011D2 750A                            JNZ     SHORT TRYCOFF
  4325 000011D4 B433                            MOV     AH,SET_CTRL_C_TRAPPING  ; TURN ON CONTROL-C CHECK
  4326 000011D6 B001                            MOV     AL,1
  4327 000011D8 88C2                            MOV     DL,AL
  4328 000011DA CD21                            INT     21H
  4329                                  COFFJ2:
  4330 000011DC EBC6                    	JMP	SHORT COFF
  4331                                  TRYCOFF: 
  4332 000011DE 3C46                    	CMP	AL,'F'
  4333 000011E0 7509                    	JNZ	SHORT TRYCBAD		; Check for "OFF"
  4334 000011E2 E83704                  	CALL	GETCHR
  4335 000011E5 7204                    	JC	SHORT TRYCBAD
  4336 000011E7 3C46                    	CMP	AL,'F'
  4337 000011E9 74F1                    	JZ	SHORT COFFJ2
  4338                                  TRYCBAD:
  4339 000011EB E928FF                  	JMP	BADOP
  4340                                  
  4341                                  ;------------------------------------------------------------------------------
  4342                                  ; Device command
  4343                                  ;------------------------------------------------------------------------------
  4344                                  
  4345                                  ; 10/06/2018 - Retro DOS v3.0 (MSDOS 3.3)
  4346                                  
  4347                                  TRYD:   
  4348 000011EE 80FC44                  	CMP     AH,'D'
  4349 000011F1 7403                            JZ      SHORT GOTD
  4350 000011F3 E9E501                          JMP     TRYQ
  4351                                  GOTD:   
  4352 000011F6 8CCB                    	MOV     BX,CS
  4353 000011F8 8EDB                            MOV     DS,BX
  4354                                  
  4355 000011FA 8936[7208]                      MOV     [BPB_ADDR],SI
  4356 000011FE 8C06[7408]                      MOV     [BPB_ADDR+2],ES
  4357                                  
  4358 00001202 E8CF06                          CALL    ROUND
  4359                                  
  4360 00001205 31C0                    	XOR     AX,AX
  4361 00001207 A3[F807]                        MOV     [ENTRY_POINT],AX
  4362 0000120A A1[5A08]                        MOV     AX,[MEMHI]
  4363 0000120D A3[FA07]                        MOV     [ENTRY_POINT+2],AX	; SET ENTRY POINT
  4364                                  
  4365                                  	; 01/05/2018 (NOEXEC = FALSE)
  4366                                          ;IF     NOT NOEXEC
  4367 00001210 A3[5C08]                        MOV	[LDOFF],AX		; SET LOAD OFFSET
  4368                                          ;ENDIF
  4369                                  
  4370 00001213 06                              PUSH    ES
  4371 00001214 1F                              POP     DS
  4372 00001215 89F2                            MOV     DX,SI                   ; DS:DX POINTS TO FILE NAME
  4373                                  
  4374                                          ;IF	NOEXEC
  4375                                          ;LES     BX,[CS:MEMLO]
  4376                                          ;CALL    LDFIL			; LOAD IN THE DEVICE DRIVER
  4377                                          ;ELSE
  4378                                  
  4379                                  ; We are going to open the cdevice driver and size it as is done
  4380                                  ;  in LDFIL. The reason we must do this is that EXEC does NO checking
  4381                                  ;  for us. We must make sure there is room to load the device without
  4382                                  ;  trashing SYSINIT. This code is not
  4383                                  ;  perfect (for instance .EXE device drivers are possible) because
  4384                                  ;  it does its sizing based on the assumption that the file being loaded
  4385                                  ;  is a .COM file. It is close enough to correctness to be usable.
  4386                                  
  4387 00001217 8EC0                    	MOV	ES,AX			;ES:0 is LOAD addr
  4388 00001219 B8003D                  	MOV	AX,OPEN*256		;OPEN THE FILE
  4389 0000121C F9                      	STC				;IN CASE OF INT 24
  4390 0000121D CD21                    	INT	21H
  4391 0000121F 724A                    	JC	short BADLDRESET
  4392 00001221 89C3                    	MOV	BX,AX			;Handle in BX
  4393 00001223 52                      	PUSH	DX			; Save pointer to name
  4394 00001224 31C9                    	XOR	CX,CX
  4395 00001226 31D2                    	XOR	DX,DX
  4396 00001228 B80242                  	MOV	AX,(LSEEK*256)+2
  4397 0000122B F9                      	STC				;IN CASE OF INT 24
  4398 0000122C CD21                    	INT	21H			; Get file size in DX:AX
  4399 0000122E 7308                    	JNC	short GO_AHEAD_LOAD
  4400 00001230 B43E                    	MOV	AH,CLOSE		; Close file
  4401 00001232 CD21                    	INT	21H
  4402 00001234 5A                      	POP	DX			; Clean stack
  4403 00001235 F9                      	STC				; Close may clear carry
  4404 00001236 EB33                    	JMP	SHORT BADLDRESET
  4405                                  
  4406                                  GO_AHEAD_LOAD:
  4407                                      ; Convert size in DX:AX to para in AX
  4408 00001238 83C00F                  	ADD	AX,15			; Round up size for conversion to para
  4409 0000123B 83D200                  	ADC	DX,0
  4410 0000123E B104                    	MOV	CL,4
  4411 00001240 D3E8                    	SHR	AX,CL
  4412 00001242 B10C                    	MOV	CL,12
  4413 00001244 D3E2                    	SHL	DX,CL			; Low nibble of DX to high nibble
  4414 00001246 09D0                    	OR	AX,DX			; AX is now # of para for file
  4415                                  
  4416 00001248 8CC1                    	MOV	CX,ES			; CX:0 is xaddr
  4417 0000124A 01C1                    	ADD	CX,AX			; New device will take up to here
  4418 0000124C 7207                    	JC	short MEM_ERRJY		; WOW!!!!
  4419 0000124E 2E3B0E[1908]            	CMP	CX,[CS:ALLOCLIM]
  4420 00001253 7203                    	JB	short OKLDX
  4421                                  MEM_ERRJY:
  4422 00001255 E99E06                  	JMP	MEM_ERR
  4423                                  OKLDX:
  4424 00001258 5A                      	POP	DX			; Recover name pointer
  4425 00001259 B43E                    	MOV	AH,CLOSE		; Close file
  4426 0000125B CD21                    	INT	21H
  4427 0000125D 8CCB                    	MOV	BX,CS
  4428 0000125F 8EC3                            MOV	ES,BX
  4429 00001261 BB[5A08]                        MOV	BX,PRMBLK		; ES:BX POINTS TO PARAMETERS
  4430 00001264 B003                            MOV	AL,3
  4431 00001266 B44B                            MOV	AH,EXEC
  4432 00001268 F9                              STC				; IN CASE OF INT 24
  4433 00001269 CD21                            INT	21H                     ; LOAD IN THE DEVICE DRIVER
  4434                                          ;ENDIF
  4435                                  
  4436                                  BADLDRESET:
  4437 0000126B 1E                              PUSH    DS
  4438 0000126C 07                              POP     ES                      ; ES:SI BACK TO CONFIG.SYS
  4439 0000126D 0E                              PUSH    CS
  4440 0000126E 1F                              POP     DS                      ; DS BACK TO SYSINIT
  4441 0000126F 730F                            JNC     SHORT GOODLD
  4442                                  BADBRK: 
  4443 00001271 26803C0D                	cmp	BYTE [ES:SI], 13	; file name is CR?
  4444 00001275 7503                    	jne	SHORT BADBRK_1		;(entered "device=" without filename)
  4445 00001277 E99CFE                  	jmp	BADOP			;"Unrecognized command in CONFIG.SYS"
  4446                                  BADBRK_1:
  4447 0000127A E8AC08                  	CALL    BADLOAD
  4448 0000127D E924FF                          JMP     COFF
  4449                                  GOODLD: 
  4450 00001280 06                      	PUSH    ES                      ; INITIALIZE THE DEVICE
  4451 00001281 56                              PUSH    SI
  4452                                  RESTORE:
  4453 00001282 268A1C                  	MOV	BL,[ES:SI]		;   while ((c=*p) != 0)
  4454 00001285 08DB                    	OR	BL,BL
  4455 00001287 7403                    	JZ	SHORT GOT
  4456 00001289 46                      	INC	SI			;	p++;
  4457 0000128A EBF6                    	JMP	SHORT RESTORE
  4458                                  GOT:	
  4459 0000128C 26C60420                	MOV	BYTE [ES:SI], ' '	;   *p = ' ';
  4460                                  
  4461 00001290 06                      	PUSH    ES
  4462 00001291 56                              PUSH    SI        
  4463 00001292 0E                      	PUSH    CS
  4464 00001293 07                              POP     ES
  4465 00001294 BB0600                          MOV     BX,SYSDEV.STRAT
  4466 00001297 E86706                          CALL    CALLDEV			;   CallDev (SDevStrat);
  4467 0000129A BB0800                          MOV     BX,SYSDEV.INT
  4468 0000129D E86106                          CALL    CALLDEV			;   CallDev (SDevInt);
  4469 000012A0 5E                      	POP	SI
  4470 000012A1 1F                      	POP	DS
  4471 000012A2 C60400                  	MOV	BYTE [SI],0		;   *p = 0;
  4472                                  		
  4473 000012A5 0E                              PUSH    CS
  4474 000012A6 1F                              POP     DS
  4475 000012A7 A1[7008]                	MOV     AX,[BREAK_ADDR+2]	; REMOVE THE INIT CODE
  4476 000012AA 3B06[0E08]                      CMP     AX,[MEMORY_SIZE]
  4477 000012AE 7204                            JB      SHORT BREAKOK
  4478 000012B0 5E                              POP     SI
  4479 000012B1 07                              POP     ES
  4480 000012B2 EBBD                            JMP     SHORT BADBRK
  4481                                  BREAKOK:
  4482 000012B4 C516[F807]                      LDS     DX,[ENTRY_POINT]        ; SET DS:DX TO HEADER
  4483 000012B8 89D6                            MOV     SI,DX
  4484 000012BA 83C604                          ADD     SI,SYSDEV.ATT		; DS:SI POINTS TO ATTRIBUTES
  4485 000012BD 2EC43E[F407]                    LES     DI,[CS:DOSINFO]         ; ES:DI POINT TO DOS INFO
  4486 000012C2 8B04                            MOV     AX,[SI]			; GET ATTRIBUTES
  4487 000012C4 A90080                          TEST    AX,DEVTYP               ; TEST IF BLOCK DEV
  4488 000012C7 7422                            JZ      SHORT ISBLOCK
  4489 000012C9 E8E705                  	CALL	SET_BREAK		; Go ahead and alloc mem for device
  4490 000012CC 7225                    	JC	SHORT ERASE_DEV
  4491 000012CE A90100                          TEST    AX,ISCIN                ; IS IT A CONSOLE IN?
  4492 000012D1 7408                            JZ      SHORT TRYCLK
  4493 000012D3 2689550C                        MOV     [ES:DI+SYSI_CON],DX
  4494 000012D7 268C5D0E                        MOV     [ES:DI+SYSI_CON+2],DS
  4495                                  
  4496                                  TRYCLK: 
  4497 000012DB A90800                  	TEST    AX,ISCLOCK              ; IS IT A CLOCK DEVICE?
  4498 000012DE 7408                            JZ      SHORT GOLINK
  4499 000012E0 26895508                        MOV     [ES:DI+SYSI_CLOCK],DX
  4500 000012E4 268C5D0A                        MOV     [ES:DI+SYSI_CLOCK+2],DS
  4501                                  GOLINK: 
  4502 000012E8 E9C000                  	JMP	LINKIT
  4503                                  
  4504                                  ISBLOCK:
  4505 000012EB 2EA0[6D08]                      MOV     AL,[CS:UNITCOUNT]	; IF NO UNITS FOUND, ERASE THE DEVICE
  4506 000012EF 08C0                            OR      AL,AL
  4507 000012F1 7506                            JNZ     SHORT PERDRV
  4508                                  ERASE_DEV:					
  4509 000012F3 B8FFFF                          MOV     AX,-1			; No call to SET_BREAK yet, so no alloc
  4510 000012F6 E9D700                  	JMP	ENDDEV
  4511                                  
  4512                                  PERDRV:
  4513 000012F9 98                              CBW
  4514 000012FA 89C1                            MOV     CX,AX
  4515 000012FC 88E6                            MOV     DH,AH
  4516 000012FE 268A5520                        MOV     DL,[ES:DI+SYSI_NUMIO]	; GET NUMBER OF DEVICES
  4517 00001302 88D4                    	MOV	AH,DL
  4518 00001304 00C4                    	ADD	AH,AL			; Check for too many devices
  4519 00001306 80FC1A                  	CMP	AH,26			; 'A' - 'Z' is 26 devices
  4520 00001309 760A                    	JBE	SHORT OK_BLOCK
  4521 0000130B 0E                      	PUSH	CS
  4522 0000130C 1F                      	POP	DS
  4523 0000130D BA[5F1E]                	MOV	DX,BADBLOCK
  4524 00001310 E83008                  	CALL	PRINT
  4525 00001313 EBDE                    	JMP	SHORT ERASE_DEV
  4526                                  
  4527                                  OK_BLOCK:
  4528 00001315 E89B05                  	CALL	SET_BREAK		; Alloc the device
  4529 00001318 26004520                	ADD	[ES:DI+SYSI_NUMIO],AL	; UPDATE THE AMOUNT
  4530 0000131C 2E0006[7608]            	ADD	[CS:DriveNumber],AL	; remember amount for next device
  4531 00001321 2EC51E[7208]                    LDS     BX,[CS:BPB_ADDR]        ; POINT TO BPB ARRAY
  4532                                  PERUNIT:
  4533 00001326 2EC42E[F407]                    LES     BP,[CS:DOSINFO]
  4534                                  	;LES	BP,[ES:BP+SYSI_DPB]	; GET FIRST DPB
  4535 0000132B 26C46E00                	les	bp,[es:bp] ; 05/07/2019
  4536                                  SCANDPB:
  4537 0000132F 26837E18FF              	CMP     WORD [ES:BP+DPB.NEXT_DPB],-1
  4538 00001334 7406                            JZ      SHORT FOUNDPB
  4539 00001336 26C46E18                        LES     BP,[ES:BP+DPB.NEXT_DPB]
  4540 0000133A EBF3                            JMP     SHORT SCANDPB
  4541                                  FOUNDPB:
  4542 0000133C 2EA1[5808]                      MOV     AX,[CS:MEMLO]
  4543 00001340 26894618                        MOV     [ES:BP+DPB.NEXT_DPB],AX
  4544 00001344 2EA1[5A08]                      MOV     AX,[CS:MEMHI]
  4545 00001348 2689461A                        MOV     [ES:BP+DPB.NEXT_DPB+2],AX
  4546 0000134C 2EC42E[5808]                    LES     BP,[CS:MEMLO]
  4547 00001351 2E8306[5808]20                  ADD     WORD [CS:MEMLO],DPBSIZ
  4548 00001357 E87A05                  	CALL	ROUND			;Check for alloc error
  4549 0000135A 26C74618FFFF                    MOV     WORD [ES:BP+DPB.NEXT_DPB],-1
  4550 00001360 26C64617FF                      MOV     BYTE [ES:BP+DPB.FIRST_ACCESS],-1
  4551                                  
  4552 00001365 8B37                            MOV     SI,[BX]                 ; DS:SI POINTS TO BPB
  4553 00001367 43                              INC     BX
  4554 00001368 43                              INC     BX                      ; POINT TO NEXT GUY
  4555                                  	;MOV	[ES:BP+DPB.DRIVE],DX
  4556 00001369 26895600                	mov	[es:bp],dx ; 05/07/2019
  4557 0000136D B453                            MOV     AH,SETDPB               ; HIDDEN SYSTEM CALL
  4558 0000136F CD21                            INT     21H
  4559 00001371 268B4602                        MOV     AX,[ES:BP+DPB.SECTOR_SIZE]
  4560 00001375 06                              PUSH    ES
  4561 00001376 2EC43E[F407]                    LES     DI,[CS:DOSINFO]		; ES:DI POINT TO DOS INFO
  4562 0000137B 263B4510                        CMP     AX,[ES:DI+SYSI_MAXSEC]
  4563 0000137F 07                              POP     ES
  4564 00001380 760E                            JBE     SHORT NOTMAX
  4565 00001382 5E                              POP     SI
  4566 00001383 07                              POP     ES
  4567 00001384 BA[811D]                        MOV     DX,BADSIZ_PRE
  4568 00001387 BB[7E1D]                        MOV     BX,BADSIZ_POST
  4569 0000138A E89F07                          CALL    PRNERR
  4570 0000138D E914FE                          JMP	COFF
  4571                                  
  4572                                  NOTMAX: 
  4573 00001390 1E                      	PUSH    DS
  4574 00001391 52                              PUSH    DX
  4575 00001392 2EC516[F807]                    LDS     DX,[CS:ENTRY_POINT]
  4576 00001397 26895612                        MOV     [ES:BP+DPB.DRIVER_ADDR],DX
  4577 0000139B 268C5E14                        MOV     [ES:BP+DPB.DRIVER_ADDR+2],DS
  4578 0000139F 5A                              POP     DX
  4579 000013A0 1F                              POP     DS
  4580 000013A1 42                              INC     DX
  4581 000013A2 FEC6                            INC     DH
  4582 000013A4 E280                            LOOP    PERUNIT
  4583 000013A6 0E                      	PUSH	CS
  4584 000013A7 1F                      	POP	DS
  4585 000013A8 E84CF7                  	CALL	TEMPCDS 		; Set CDS for new drives
  4586                                  
  4587                                  LINKIT:
  4588 000013AB 2EC43E[F407]                    LES     DI,[CS:DOSINFO]         ; ES:DI = DOS TABLE
  4589 000013B0 268B4D22                        MOV     CX,[ES:DI+SYSI_DEV] 	; DX:CX = HEAD OF LIST
  4590 000013B4 268B5524                        MOV     DX,[ES:DI+SYSI_DEV+2]
  4591                                  
  4592 000013B8 2EC536[F807]                    LDS     SI,[CS:ENTRY_POINT]     ; DS:SI = DEVICE LOCATION
  4593 000013BD 26897522                        MOV     [ES:DI+SYSI_DEV],SI 	; SET HEAD OF LIST IN DOS
  4594 000013C1 268C5D24                        MOV     [ES:DI+SYSI_DEV+2],DS
  4595 000013C5 8B04                            MOV     AX,[SI]			; GET POINTER TO NEXT DEVICE
  4596 000013C7 2EA3[F807]                      MOV     [CS:ENTRY_POINT],AX	; AND SAVE IT
  4597                                  
  4598 000013CB 890C                            MOV    [SI],CX			; LINK IN THE DRIVER
  4599 000013CD 895402                          MOV    [SI+2],DX
  4600                                  ENDDEV:
  4601 000013D0 5E                              POP     SI
  4602 000013D1 07                              POP     ES
  4603 000013D2 40                              INC     AX                      ;AX = FFFF (no more devs if YES)?
  4604 000013D3 7403                            JZ      SHORT COFFJ3
  4605 000013D5 E9A8FE                          JMP	GOODLD			; OTHERWISE PRETEND WE LOADED IT IN
  4606                                  COFFJ3:
  4607                                  COFFV:  
  4608 000013D8 E9C9FD                  	JMP	COFF
  4609                                  
  4610                                  ;------------------------------------------------------------------------------
  4611                                  ; Country command
  4612                                  ;  The syntax is:							  ;3.30
  4613                                  ;	COUNTRY=country id {,codepage {,path}}				  ;3.30
  4614                                  ;	COUNTRY=country id {,,path}	:Default CODEPAGE ID in DOS	  ;3.30
  4615                                  ;------------------------------------------------------------------------------
  4616                                  ; SYSCONF.ASM, MSDOS 3.3, 24/07/1987
  4617                                  
  4618                                  TRYQ:
  4619                                  	; 10/06/2018 - Retro DOS v3.0
  4620                                   
  4621 000013DB 80FC51                          CMP     AH,'Q'
  4622                                          ;JNZ	SHORT TRYF
  4623 000013DE 7403                    	JZ	short TRYQ_CONT
  4624 000013E0 E91C01                  	JMP	TRYF
  4625                                  TRYQ_CONT:
  4626 000013E3 E85505                          CALL    GETNUM
  4627 000013E6 744F                            JZ	short TryQBad		; 0 is never a valid code, or number is
  4628                                  					; bad
  4629 000013E8 89C3                    	MOV	BX,AX			; Country code in BX
  4630                                  					; 5/26/86
  4631 000013EA BA0000                  	MOV	DX,0			; assume no code page id
  4632 000013ED E89B05                  	call	SKIP_DELIM		;skip the delimeters after the first num
  4633 000013F0 7239                    	jc	short TryQ_Def_File	;no more characters left? then use default file
  4634 000013F2 3C0D                    	cmp	al,13			;
  4635 000013F4 7435                    	je	short TryQ_Def_File
  4636 000013F6 3C0A                    	cmp	al,10
  4637 000013F8 750A                    	jne	short TRYQ_YES_EXTENDED
  4638 000013FA FF06[5108]              	inc	word [COUNT] 		;This is for NEWLINE routine in COFF.
  4639 000013FE FF0E[5308]              	dec	word [CHRPTR]
  4640                                  COFFJ41:
  4641 00001402 EB27                    	JMP	short TryQ_Def_File	;O.K. no code page, 
  4642                                  					; no path specified.Use default path.    
  4643                                  TRYQ_YES_EXTENDED:
  4644 00001404 3C2C                    	cmp	al,','			;was the second comma?
  4645 00001406 7505                    	jne	short TRYQ_GETNUM
  4646 00001408 E88005                  	call	SKIP_DELIM		;Yes, skip ',' and other possible delim
  4647 0000140B EB38                    	jmp	short TRYQ_PATH 	;and No code page id entered.
  4648                                  TRYQ_GETNUM:
  4649 0000140D E82B05                  	call	GETNUM
  4650 00001410 722C                    	jc	short TryQBadCOM	;"Country=xxx,path" will not be accepted.
  4651                                  ;	jc	short TRYQ_PATH		;Codepage is not specified. No code page.
  4652                                  ;					;At this point, AL already contain the
  4653                                  ;					;first char of the PATH.
  4654 00001412 7423                    	jz	short TryQBad 		;codepage=0 entered. Error
  4655 00001414 89C2                    	mov	DX,AX			;save code page in DX
  4656 00001416 E87205                  	call	SKIP_DELIM		;move CHRPTR to the path string
  4657 00001419 7210                    	jc	short TryQ_Def_File	;no more char? then use default filename
  4658 0000141B 3C0D                    	cmp	al, 13
  4659 0000141D 740C                    	je	short TryQ_Def_File
  4660 0000141F 3C0A                    	cmp	al, 10	
  4661 00001421 7522                    	jne	short TRYQ_PATH		;path entered.
  4662 00001423 FF06[5108]              	inc	word [COUNT]
  4663 00001427 FF0E[5308]              	dec	word [CHRPTR]
  4664                                  TryQ_Def_File:
  4665 0000142B 52                      	push	dx			;save code page
  4666 0000142C 2EC606[CF1B]00          	mov	byte [cs:CNTRY_DRV],0 	;flag that the default path has been used!!!
  4667 00001432 BA[D11B]                	mov	dx,CNTRY_ROOT		;the default path
  4668 00001435 EB3C                    	jmp	short TRYQ_OPEN
  4669                                  
  4670                                  TryQBad:				;"Invalid country code or code page"
  4671 00001437 F9                      	STC
  4672 00001438 BA[C81D]                	MOV	DX,BADCOUNTRY
  4673 0000143B E9A800                  	jmp	TryQChkErr
  4674                                  
  4675                                  TryQBadCOM:				;Error in COUNTRY command
  4676 0000143E F9                      	STC
  4677 0000143F BA[EE1D]                	MOV	DX,BADCOUNTRYCOM
  4678 00001442 E9A100                  	jmp	TryQChkErr
  4679                                  
  4680                                  TRYQ_PATH:				;DS - sysinitseg, ES - CONFBOT,
  4681 00001445 8B0E[5108]              	mov	CX,[COUNT]		;AL - the first char of path
  4682 00001449 41                      	inc	CX			;BX - country id, DX - codepage id, 0 = No code page
  4683 0000144A 89F7                    	mov	DI,SI
  4684                                  TRYQ_PATH_LOOP: 			;find the end of path to put 0 after that.
  4685 0000144C 268A05                  	mov	AL,[ES:DI]
  4686 0000144F E80F04                  	call	DELIM
  4687 00001452 7409                    	jz	short TRYQ_PATH_END
  4688 00001454 3C0D                    	cmp	al, 13
  4689 00001456 7405                    	jz	short TRYQ_PATH_END
  4690 00001458 47                      	inc	DI
  4691 00001459 EBF1                    	jmp	short TRYQ_PATH_LOOP
  4692                                  TryQBad_Brg:
  4693 0000145B EBDA                    	jmp	short TryQBad
  4694                                  TRYQ_PATH_END:
  4695 0000145D 26C60500                	mov	byte [es:di],0		;make it a ASCIIZ string. 
  4696                                  					; (Organize did not handle this string)
  4697 00001461 1E                      	push	ds			;switch ds,es
  4698 00001462 06                      	push	es
  4699 00001463 1F                      	pop	ds
  4700 00001464 07                      	pop	es
  4701                                  
  4702 00001465 BF[CF1B]                	mov	di,CNTRY_DRV	;move the user specified path to CNTRY_DRV
  4703 00001468 E8B206                  	call	MOVE_ASCIIZ
  4704                                  
  4705 0000146B 1E                      	push	ds			;restore ds,es
  4706 0000146C 06                      	push	es
  4707 0000146D 1F                      	pop	ds
  4708 0000146E 07                      	pop	es
  4709                                  
  4710                                  ;	call	 Set_Country_Path	;set CNTRY_DRV
  4711                                  
  4712 0000146F 52                      	push	dx			;save DX
  4713 00001470 BA[CF1B]                	mov	dx,CNTRY_DRV		;Now DS:DX -> CNTRY_DRV
  4714                                  TRYQ_OPEN:
  4715 00001473 B8003D                  	mov	ax,3D00h		;open a file
  4716 00001476 F9                      	stc
  4717 00001477 CD21                    	int	21h
  4718 00001479 5A                      	pop	dx			;restore codepage id
  4719 0000147A 723F                    	jc	short TryQFileBad	;open failure
  4720                                  
  4721 0000147C 2EA3[5508]              	mov	[cs:CntryFileHandle],ax ;save file handle
  4722 00001480 93                      	xchg	ax,bx			;now, AX = country id, BX = file handle
  4723 00001481 2E8B0E[5A08]            	mov	cx,[cs:MEMHI]
  4724 00001486 81C18000                	add	cx,128			;I need 2K buffer to handle COUNTRY.SYS
  4725 0000148A 2E3B0E[1908]            	cmp	cx,[cs:ALLOCLIM]
  4726 0000148F 7752                    	ja	short TryQMemory	;cannot allocate the buffer for country.sys
  4727                                  
  4728 00001491 BE[CF1B]                	mov	si,CNTRY_DRV		;DS:SI -> CNTRY_DRV
  4729 00001494 803C00                  	cmp	byte [si],0 		;default path?
  4730 00001497 7502                    	jne	short TRYQ_Set_for_DOS
  4731 00001499 46                      	inc	si
  4732 0000149A 46                      	inc	si			;DS:SI -> CNTRY_ROOT
  4733                                  TRYQ_Set_for_DOS:
  4734 0000149B 2EC43E[0208]            	les	di,[cs:SYSI_Country]	;ES:DI -> country info tab in DOS
  4735 000014A0 57                      	push	di			;save di
  4736 000014A1 83C708                  	add	di,country_cdpg_info.ccPath_CountrySys
  4737 000014A4 E87606                  	call	MOVE_ASCIIZ		;Set the path to COUNTRY.SYS in DOS.
  4738 000014A7 5F                      	pop	di			;ES:DI -> country info tab again.
  4739 000014A8 2E8B0E[5A08]            	mov	cx,[cs:MEMHI]
  4740 000014AD 8ED9                    	mov	ds, cx
  4741 000014AF 31F6                    	xor	si, si			;DS:SI -> 2K buffer to be used.
  4742 000014B1 E8F504                  	call	SetDOSCountryInfo	;now do the job!!!
  4743 000014B4 7330                    	jnc	short TryQChkErr	;read error or could not find country,
  4744                                  					;	code page combination
  4745 000014B6 83F9FF                  	cmp	cx, -1			;Could not find matching country_id,code page?
  4746 000014B9 74A0                    	je	short TryQBad_Brg	;then "Invalid country code or code page"
  4747                                  TryQFileBad:
  4748 000014BB 2E803E[CF1B]00          	cmp	byte [cs:CNTRY_DRV],0	;Is the default file used?
  4749 000014C1 740F                    	je	short TryQDefBad
  4750 000014C3 2E8B36[1708]            	mov	si,[cs:CONFBOT]
  4751 000014C8 8EC6                    	mov	es,si
  4752 000014CA 2E8B36[5308]            	mov	si,[cs:CHRPTR]
  4753 000014CF 4E                      	dec	si			;ES:SI -> path in CONFBOT
  4754 000014D0 EB05                    	jmp	short TryQBADLOAD
  4755                                  TryQDefBad:				;Default file has been used.
  4756 000014D2 0E                      	push	cs
  4757 000014D3 07                      	pop	es
  4758 000014D4 BE[D11B]                	mov	si,CNTRY_ROOT		;ES:SI -> \COUNTRY.SYS in SYSINIT_SEG
  4759                                  TryQBADLOAD:
  4760 000014D7 E84F06                  	call	BADLOAD 		;DS will be restored to SYSINIT_SEG
  4761 000014DA 2E8B0E[1708]            	mov	cx,[cs:CONFBOT]
  4762 000014DF 8EC1                    	mov	es, cx			;Restore ES -> CONFBOT.
  4763 000014E1 EB11                    	jmp	short CoffJ4
  4764                                  TryQMemory:
  4765 000014E3 BA[0B1E]                	MOV	DX,INSUFMEMORY
  4766                                  TryQChkErr:
  4767 000014E6 2E8B0E[1708]            	mov	cx,[cs:CONFBOT]
  4768 000014EB 8EC1                    	mov	es,cx			;restore ES -> CONFBOT seg
  4769 000014ED 0E                      	push	cs
  4770 000014EE 1F                      	pop	ds			;restore DS to SYSINIT_SEG
  4771 000014EF 7303                    	jnc	short CoffJ4		;if no error, then exit
  4772 000014F1 E84F06                  	call	PRINT			;else show error message
  4773                                  CoffJ4:
  4774 000014F4 8B1E[5508]              	mov	bx,[CntryFileHandle]
  4775 000014F8 B43E                    	mov	ah,3Eh
  4776 000014FA CD21                    	int	21h			;close a file. Don't care even if it fails.
  4777 000014FC E9A5FC                  	JMP	COFF
  4778                                  
  4779                                  ;------------------------------------------------------------------------------
  4780                                  ; Files command
  4781                                  ;------------------------------------------------------------------------------
  4782                                  ; SYSCONF.ASM, MSDOS 3.3, 24/07/1987
  4783                                  
  4784                                  TRYF:
  4785 000014FF 80FC46                          CMP     AH,'F'
  4786 00001502 7516                    	JNZ	SHORT TRYL
  4787 00001504 E83404                  	CALL    GETNUM
  4788 00001507 83F805                  	CMP	AX,5
  4789 0000150A 720B                    	JB	SHORT TRYFBAD		; Gotta have at least 5
  4790 0000150C 3D0001                  	CMP	AX,256
  4791 0000150F 7306                    	JAE	SHORT TRYFBAD		; Has to be a byte
  4792 00001511 A2[1308]                	MOV	[FILES],AL
  4793                                  COFFJ5: 
  4794 00001514 E98DFC                  	JMP	COFF
  4795                                  TRYFBAD:
  4796 00001517 E9FCFB                  	JMP	BADOP
  4797                                  
  4798                                  ;------------------------------------------------------------------------------
  4799                                  ; LastDrive command
  4800                                  ;------------------------------------------------------------------------------
  4801                                  ; SYSCONF.ASM, MSDOS 3.3, 24/07/1987
  4802                                  
  4803                                  TRYL:
  4804 0000151A 80FC4C                  	CMP	AH,'L'
  4805 0000151D 7515                    	JNZ	SHORT TRYP
  4806 0000151F 0C20                    	OR	AL,020h
  4807 00001521 2C61                    	SUB	AL,'a'
  4808 00001523 720C                    	JB	SHORT TRYLBAD
  4809 00001525 FEC0                    	INC	AL
  4810 00001527 3C1A                    	CMP	AL,26			; a-z are allowed
  4811 00001529 7706                    	JA	SHORT TRYLBAD
  4812 0000152B A2[1608]                	MOV	[NUM_CDS],AL
  4813                                  COFFJ6: 
  4814 0000152E E973FC                  	JMP	COFF
  4815                                  TRYLBAD:
  4816 00001531 E9E2FB                  	JMP	BADOP
  4817                                  
  4818                                  ;-------------------------------------------------------------------------------
  4819                                  ; Setting Drive Parameters
  4820                                  ;-------------------------------------------------------------------------------
  4821                                  ; SYSCONF.ASM, MSDOS 3.3, 24/07/1987
  4822                                  
  4823                                  TRYP:
  4824 00001534 80FC50                  	CMP	AH,'P'
  4825 00001537 7510                    	JNZ	SHORT TRYK
  4826 00001539 E83601                  	CALL	PARSELINE
  4827 0000153C 72F3                    	JC	SHORT TRYLBAD
  4828 0000153E E8F700                  	CALL	SETPARMS
  4829 00001541 E81601                  	CALL	DIDDLEBACK
  4830 00001544 72EB                    	JC	SHORT TRYLBAD
  4831 00001546 E95BFC                  	JMP	COFF
  4832                                  
  4833                                  ;-------------------------------------------------------------------------------
  4834                                  ; Setting Internal Stack Parameters
  4835                                  ; STACK=M,N where
  4836                                  ;	M is the number of stacks (range 8 to 64, default 9)
  4837                                  ;	N is the stack size (range 32 to 512 bytes, default 128)
  4838                                  ;  5/5/86: STACKS=0,0 implies no stack installation.			  ;3.30
  4839                                  ;	Any combinations that are not within the specified limits will	  ;3.30
  4840                                  ;	result in "Unrecognized command" error.                    
  4841                                  ;-------------------------------------------------------------------------------
  4842                                  ; SYSCONF.ASM, MSDOS 3.3, 24/07/1987
  4843                                  
  4844                                  TRYK:
  4845 00001549 80FC4B                  	CMP	AH,'K'
  4846                                  	;JNZ	short TRYW
  4847 0000154C 7559                    	JNZ	short TRYS ; 03/08/2019
  4848                                  
  4849                                  	;IF	STACKSW
  4850                                  
  4851 0000154E C606[4008]2C            	MOV	byte [SEPCHR],','
  4852 00001553 E8E503                  	call	GETNUM			; Get number of stacks
  4853 00001556 C606[4008]00            	MOV	byte [SEPCHR],0
  4854 0000155B 83F800                  	cmp	ax, 0			; 5/5/86
  4855 0000155E 740A                    	je	short TRYK_0		; Let's accept 0.
  4856 00001560 83F808                  	CMP	AX,MinCount		; 8 <= Number of Stacks <= 64
  4857 00001563 7239                    	JB	short TryKBad
  4858 00001565 83F840                  	CMP	AX,MaxCount
  4859 00001568 7734                    	JA	short TryKBad
  4860                                  TRYK_0:
  4861 0000156A A3[0608]                	MOV	[STACK_COUNT],AX
  4862                                  ;
  4863                                  ; Skip delimiters after the ,
  4864                                  ;
  4865 0000156D E81B04                  	call	SKIP_DELIM
  4866 00001570 722C                    	JC	short TryKBad
  4867                                  
  4868 00001572 E8C603                  	call	GETNUM			; Get size of individual stack
  4869 00001575 7227                    	JC	short TryKBad 		; Number bad
  4870                                  
  4871 00001577 83F800                  	cmp	ax, 0			; 5/5/86
  4872 0000157A 740A                    	je	short TRYK_SIZE0	; 5/5/86. Accept 0
  4873                                  
  4874 0000157C 83F820                  	CMP	AX,MinSize		; 32 <= Stack Size <= 512
  4875 0000157F 721D                    	JB	short TryKBad
  4876 00001581 3D0002                  	CMP	AX,MaxSize
  4877 00001584 7718                    	JA	short TryKBad
  4878                                  TRYK_SIZE0:
  4879 00001586 A3[0808]                	MOV	[STACK_SIZE],AX
  4880 00001589 83F800                  	cmp	ax,0
  4881 0000158C 7409                    	je	short TRYK_BOTH0
  4882                                  TRYK_OK:
  4883 0000158E C706[0A08]FFFF          	mov	word [STACK_ADDR], -1	;set flag. user entered stacks=
  4884 00001594 E90DFC                  	JMP	COFF
  4885                                  TRYK_BOTH0:
  4886 00001597 833E[0608]00            	cmp	word [STACK_COUNT],0 	;stack_size=0. Stack_Count=0 too?
  4887 0000159C 74F0                    	je	short TRYK_OK 		;yes. accepted.
  4888                                  TryKBad:
  4889 0000159E BA[7A1E]                	MOV	DX,BADSTACK		; 5/26/86 "Invalid stack parameter"
  4890 000015A1 E89F05                  	call	PRINT
  4891 000015A4 E9FDFB                  	JMP	COFF
  4892                                  
  4893                                  	;ENDIF
  4894                                  
  4895                                  ;------------------------------------------------------------------------------
  4896                                  ; Switch command
  4897                                  ;------------------------------------------------------------------------------
  4898                                  
  4899                                  	; 03/08/2019
  4900                                  ;TRYW:
  4901                                  ;       CMP     AH,'W'
  4902                                  ;       JNZ     SHORT TRYA
  4903                                  ;	; 10/06/2018 - Retro DOS 3.0
  4904                                  ;	JMP	BADOP			; no longer implemented (MSDOS 3.3)
  4905                                  
  4906                                  	; 01/04/2018 - Retro DOS 2.0
  4907                                  ;	MOV     DL,AL
  4908                                  ;	MOV     AX,(CHAR_OPER*256)+1	; SET SWITCH CHARACTER
  4909                                  ;	MOV     [COMMAND_LINE+1],DL
  4910                                  ;	INT     21H
  4911                                  ;	JMP     COFF
  4912                                  
  4913                                  ;------------------------------------------------------------------------------
  4914                                  ; Availdev command
  4915                                  ;------------------------------------------------------------------------------
  4916                                  
  4917                                  	; 03/08/2019
  4918                                  ;TRYA:
  4919                                  ;       CMP     AH,'A'
  4920                                  ;       JNZ     SHORT TRYS
  4921                                  ;	JMP	BADOP			; no longer implemented (MSDOS 3.3)
  4922                                  
  4923                                  ;	CMP     AL,'F'			; FIRST LETTER OF "FALSE"
  4924                                  ;	JNZ     SHORT COFFJ
  4925                                  ;	MOV     AX,(CHAR_OPER*256)+3	; TURN ON "/DEV" PREFIX
  4926                                  ;	XOR     DL,DL
  4927                                  ;	INT     21H
  4928                                  ;COFFJ7:  
  4929                                  ;	JMP     COFF
  4930                                  
  4931                                  ;------------------------------------------------------------------------------
  4932                                  ; shell command
  4933                                  ;------------------------------------------------------------------------------
  4934                                  
  4935                                  TRYS:
  4936 000015A7 80FC53                          CMP     AH,'S'
  4937 000015AA 752B                            JNZ     SHORT TRYX
  4938 000015AC C606[2008]00                    MOV     BYTE [COMMAND_LINE+1],0
  4939 000015B1 BF[1D1C]                        MOV     DI,COMMND + 1
  4940 000015B4 8845FF                          MOV     [DI-1],AL
  4941                                  STORESHELL:
  4942 000015B7 E86200                          CALL    GETCHR
  4943 000015BA 08C0                            OR      AL,AL
  4944 000015BC 744C                            JZ      SHORT GETSHPARMS
  4945 000015BE 3C20                            CMP     AL," "
  4946 000015C0 7205                            JB      SHORT ENDSH
  4947 000015C2 8805                            MOV     [DI],AL
  4948 000015C4 47                              INC     DI
  4949 000015C5 EBF0                            JMP     SHORT STORESHELL
  4950                                  
  4951                                  ENDSH:
  4952 000015C7 C60500                          MOV     BYTE [DI],0
  4953 000015CA E84F00                          CALL    GETCHR
  4954 000015CD 3C0A                            CMP     AL,10
  4955 000015CF 7503                            JNZ     SHORT CONV
  4956 000015D1 E84800                          CALL    GETCHR
  4957                                  CONV:   
  4958 000015D4 E9C1FB                  	JMP     CONFLP
  4959                                  
  4960                                  ;------------------------------------------------------------------------------
  4961                                  ; FCBS Command
  4962                                  ;------------------------------------------------------------------------------
  4963                                  ; SYSCONF.ASM, MSDOS 3.3, 24/07/1987
  4964                                  
  4965                                  TRYX:
  4966                                  	; 10/06/2018 -  Retro DOS v3.0
  4967                                   
  4968                                  	;JMP	BADOP	; 25/03/2018 - Retro DOS v2.0 
  4969                                  
  4970 000015D7 80FC58                  	CMP	AH,'X'
  4971 000015DA 752B                    	JNZ	SHORT TRYZ
  4972 000015DC E85C03                  	CALL	GETNUM
  4973 000015DF 7423                    	JZ	SHORT TRYXBAD 		; gotta have at least one
  4974 000015E1 3D0001                  	CMP	AX,256
  4975 000015E4 731E                    	JAE	SHORT TRYXBAD 		; Can't be more than 8 bits worth
  4976 000015E6 A2[1408]                	MOV	[FCBS],AL
  4977                                  ;
  4978                                  ; Skip delimiters after the ,
  4979                                  ;
  4980 000015E9 E89F03                  	CALL	SKIP_DELIM
  4981 000015EC 7216                    	JC	SHORT TRYXBAD
  4982 000015EE E84A03                  	CALL	GETNUM
  4983 000015F1 7211                    	JC	SHORT TRYXBAD		; Number bad (Zero is OK here)
  4984 000015F3 3D0001                  	CMP	AX,256
  4985 000015F6 730C                    	JAE	SHORT TRYXBAD
  4986 000015F8 3A06[1408]              	CMP	AL,[FCBS]
  4987 000015FC 7706                    	JA	SHORT TRYXBAD
  4988 000015FE A2[1508]                	MOV	[KEEP],AL
  4989 00001601 E9A0FB                  	JMP	COFF
  4990                                  TRYXBAD:
  4991 00001604 E90FFB                  	JMP	BADOP
  4992                                  
  4993                                  ;------------------------------------------------------------------------------
  4994                                  ; Bogus command
  4995                                  ;------------------------------------------------------------------------------
  4996                                  
  4997                                  TRYZ:
  4998 00001607 E90CFB                  	JMP	BADOP
  4999                                  
  5000                                  GETSHPARMS:
  5001 0000160A C60500                  	MOV     BYTE [DI],0
  5002 0000160D BF[2008]                	MOV     DI,COMMAND_LINE+1
  5003                                  PARMLOOP:
  5004 00001610 E80900                          CALL    GETCHR
  5005 00001613 3C20                            CMP     AL," "
  5006 00001615 72B0                            JB      SHORT ENDSH
  5007 00001617 8805                            MOV     [DI],AL
  5008 00001619 47                              INC     DI
  5009 0000161A EBF4                            JMP     SHORT PARMLOOP
  5010                                  
  5011                                  GETCHR: 
  5012 0000161C 51                      	PUSH	CX
  5013 0000161D 8B0E[5108]              	MOV     CX,[COUNT] ; 05/07/2018
  5014 00001621 E312                            JCXZ    NOCHAR
  5015 00001623 8B36[5308]                      MOV     SI,[CHRPTR]
  5016 00001627 268A04                          MOV     AL,[ES:SI]
  5017 0000162A FF0E[5108]                      DEC     WORD [COUNT]
  5018 0000162E FF06[5308]                      INC     WORD [CHRPTR]
  5019 00001632 F8                              CLC
  5020                                  GET_RET:
  5021 00001633 59                      	POP	CX
  5022 00001634 C3                              RETN
  5023                                  NOCHAR: 
  5024 00001635 F9                      	STC
  5025 00001636 EBFB                            JMP	SHORT GET_RET
  5026                                  
  5027                                  ; ----------------------------------------------------------------------
  5028                                  ; SYINIT2.ASM (MSDOS 3.3, 02/02/1988)
  5029                                  ; ----------------------------------------------------------------------
  5030                                  ; 10/06/2018 - Retro DOS v3.0
  5031                                  
  5032                                  ;
  5033                                  ; The following set of routines is used to parse the DRIVPARM = command in
  5034                                  ; the CONFIG.SYS file to change the default drive parameters.
  5035                                  ;
  5036                                  SETPARMS:
  5037 00001638 1E                      	push	ds
  5038 00001639 50                      	push	ax
  5039 0000163A 53                      	push	bx
  5040 0000163B 51                      	push	cx
  5041 0000163C 52                      	push	dx
  5042 0000163D 31DB                    	xor	bx,bx
  5043 0000163F 8A1E[BD1C]              	mov	bl,[DRIVE]
  5044 00001643 FEC3                    	inc	bl		; get it correct for IOCTL call (1=A,2=B...)
  5045 00001645 0E                      	push	cs
  5046 00001646 1F                      	pop	ds
  5047 00001647 BA[901C]                	mov	dx,DEVICEPARAMETERS
  5048 0000164A B444                    	mov	ah,IOCTL
  5049 0000164C B00D                    	mov	al,GENERIC_IOCTL
  5050 0000164E B508                    	mov	ch,RAWIO
  5051 00001650 B140                    	mov	cl,SET_DEVICE_PARAMETERS
  5052 00001652 CD21                    	int	21H
  5053 00001654 5A                      	pop	dx
  5054 00001655 59                      	pop	cx
  5055 00001656 5B                      	pop	bx
  5056 00001657 58                      	pop	ax
  5057 00001658 1F                      	pop	ds
  5058 00001659 C3                      	retn
  5059                                  
  5060                                  ;
  5061                                  ; Replace default values for further DRIVPARM commands
  5062                                  ;
  5063                                  DIDDLEBACK:
  5064 0000165A C706[941C]5000          	mov	word [DEVICEPARAMETERS+A_DEVICEPARAMETERS.DP_CYLINDERS],80
  5065 00001660 C606[911C]02            	mov	byte [DEVICEPARAMETERS+A_DEVICEPARAMETERS.DP_DEVICETYPE],DEV_3INCH720KB
  5066 00001665 C706[921C]0000          	mov	word [DEVICEPARAMETERS+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES],0
  5067 0000166B C706[BE1C]0000          	mov	word [SWITCHES],0	    ; zero all switches
  5068 00001671 C3                      	retn
  5069                                  
  5070                                  ;
  5071                                  ; Entry point is ParseLine. AL contains the first character in command line.
  5072                                  ;
  5073                                  PARSELINE:			; don't get character first time
  5074 00001672 1E                      	push	ds
  5075 00001673 0E                      	push	cs
  5076 00001674 1F                      	pop	ds
  5077                                  NextSwtch:
  5078 00001675 3C0D                    	cmp	al,13			; carriage return?
  5079 00001677 7421                    	jz	short done_line
  5080 00001679 3C0A                    	cmp	al,10			; linefeed?
  5081 0000167B 743D                    	jz	short put_back		; put it back and done
  5082                                  ; Anything less or equal to a space is ignored.
  5083 0000167D 3C20                    	cmp	al,' '                  ; space?
  5084 0000167F 7610                    	jbe	short get_next		; skip over space
  5085 00001681 3C2F                    	cmp	al,'/'
  5086 00001683 7403                    	jz	short getparm
  5087 00001685 F9                      	stc				; mark error invalid-character-in-input
  5088 00001686 EB30                    	jmp	short exitpl
  5089                                  
  5090                                  getparm:
  5091 00001688 E83900                  	call	Check_Switch
  5092 0000168B 891E[BE1C]              	mov	[SWITCHES],BX		; save switches read so far
  5093 0000168F 7207                    	jc	short swterr
  5094                                  get_next:
  5095 00001691 E888FF                  	call	GETCHR
  5096 00001694 7204                    	jc	short done_line
  5097 00001696 EBDD                    	jmp	short NextSwtch
  5098                                  swterr:
  5099 00001698 EB1E                    	jmp	short exitpl		; exit if error
  5100                                  
  5101                                  done_line:
  5102 0000169A F706[BE1C]0400          	test	word [SWITCHES],flagdrive  ; see if drive specified
  5103 000016A0 7503                    	jnz	short okay
  5104 000016A2 F9                      	stc				; mark error no-drive-specified
  5105 000016A3 EB13                    	jmp	short exitpl
  5106                                  
  5107                                  okay:
  5108 000016A5 A1[BE1C]                	mov	ax,[SWITCHES]
  5109 000016A8 83E003                  	and	ax,0003H	    ; get flag bits for changeline and non-rem
  5110 000016AB A3[921C]                	mov	word [DEVICEPARAMETERS+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES],ax
  5111 000016AE C706[B61C]0000          	mov	word [DEVICEPARAMETERS+A_DEVICEPARAMETERS.DP_TRACKTABLEENTRIES],0
  5112 000016B4 F8                      	clc			    ; everything is fine
  5113 000016B5 E89F00                  	call	SetDeviceParameters
  5114                                  exitpl:
  5115 000016B8 1F                      	pop	ds
  5116 000016B9 C3                      	retn
  5117                                  
  5118                                  put_back:
  5119 000016BA FF06[5108]              	inc	word [COUNT]		; one more char to scan
  5120 000016BE FF0E[5308]              	dec	word [CHRPTR]		; back up over linefeed
  5121 000016C2 EBD6                    	jmp	short done_line
  5122                                  
  5123                                  ;
  5124                                  ; Processes a switch in the input. It ensures that the switch is valid, and
  5125                                  ; gets the number, if any required, following the switch. The switch and the
  5126                                  ; number *must* be separated by a colon. Carry is set if there is any kind of
  5127                                  ; error.
  5128                                  ;
  5129                                  Check_Switch:
  5130 000016C4 E855FF                  	call	GETCHR
  5131 000016C7 7251                    	jc	short err_check
  5132 000016C9 24DF                    	and	al,0DFH			; convert it to upper case
  5133 000016CB 3C41                    	cmp	al,'A'
  5134 000016CD 724B                    	jb	short err_check
  5135 000016CF 3C5A                    	cmp	al,'Z'
  5136 000016D1 7747                    	ja	short err_check
  5137 000016D3 06                      	push	es
  5138 000016D4 0E                      	push	cs
  5139 000016D5 07                      	pop	es
  5140 000016D6 8A0E[521D]              	mov	cl,[switchlist]		; get number of valid switches
  5141 000016DA B500                    	mov	ch,0
  5142 000016DC BF[531D]                	mov	di,1+switchlist		; point to string of valid switches
  5143 000016DF F2AE                    	repne	scasb
  5144 000016E1 07                      	pop	es
  5145 000016E2 7536                    	jnz	short err_check
  5146 000016E4 B80100                  	mov	ax,1
  5147 000016E7 D3E0                    	shl	ax,cl		; set bit to indicate switch
  5148 000016E9 8B1E[BE1C]              	mov	bx,[SWITCHES]	 ; get switches so far
  5149 000016ED 09C3                    	or	bx,ax		; save this with other switches
  5150 000016EF 89C1                    	mov	cx,ax
  5151 000016F1 A97C00                  	test	ax,7CH		; test against switches that require number to follow
  5152 000016F4 7420                    	jz	short done_swtch
  5153 000016F6 E823FF                  	call	GETCHR
  5154 000016F9 721D                    	jc	short err_swtch
  5155 000016FB 3C3A                    	cmp	al,':'
  5156 000016FD 7519                    	jnz	short err_swtch
  5157 000016FF E81AFF                  	call	GETCHR
  5158 00001702 53                      	push	bx			; preserve switches
  5159 00001703 2EC606[4008]20          	mov	byte [cs:SEPCHR],' '	; allow space separators
  5160 00001709 E82F02                  	call	GETNUM
  5161 0000170C 2EC606[4008]00          	mov	byte [cs:SEPCHR],0
  5162 00001712 5B                      	pop	bx			; restore switches
  5163                                  ; Because GetNum does not consider carriage-return or line-feed as OK, we do
  5164                                  ; not check for carry set here. If there is an error, it will be detected
  5165                                  ; further on (hopefully).
  5166 00001713 E80600                  	call	Process_Num
  5167                                  
  5168                                  done_swtch:
  5169 00001716 F8                      	clc
  5170 00001717 C3                      	retn
  5171                                  
  5172                                  err_swtch:
  5173 00001718 31CB                    	xor	bx,cx			; remove this switch from the records
  5174                                  err_check:
  5175 0000171A F9                      	stc
  5176 0000171B C3                      	retn
  5177                                  
  5178                                  ;
  5179                                  ; This routine takes the switch just input, and the number following (if any),
  5180                                  ; and sets the value in the appropriate variable. If the number input is zero
  5181                                  ; then it does nothing - it assumes the default value that is present in the
  5182                                  ; variable at the beginning. Zero is OK for form factor and drive, however.
  5183                                  ;
  5184                                  Process_Num:
  5185 0000171C 850E[BE1C]              	test	[SWITCHES],cx		; if this switch has been done before,
  5186 00001720 7533                    	jnz	short done_ret		; ignore this one.
  5187 00001722 F7C10400                	test	cx,flagdrive
  5188 00001726 7405                    	jz	short try_f
  5189 00001728 A2[BD1C]                	mov	[DRIVE],al
  5190 0000172B EB28                    	jmp	short done_ret
  5191                                  
  5192                                  try_f:
  5193 0000172D F7C14000                	test	cx,flagff
  5194 00001731 7405                    	jz	short try_t
  5195                                  ; Ensure that we do not get bogus form factors that are not supported
  5196                                  	;cmp	al,Max_Dev_Type
  5197                                  	;ja	short done_ret
  5198 00001733 A2[911C]                	mov	byte [DEVICEPARAMETERS+A_DEVICEPARAMETERS.DP_DEVICETYPE],al
  5199 00001736 EB1D                    	jmp	short done_ret
  5200                                  
  5201                                  try_t:
  5202 00001738 09C0                    	or	ax,ax
  5203 0000173A 7419                    	jz	short done_ret	 ; if number entered was 0, assume default value
  5204 0000173C F7C10800                	test	cx,flagcyln
  5205 00001740 7405                    	jz	short try_s
  5206 00001742 A3[941C]                	mov	word [DEVICEPARAMETERS+A_DEVICEPARAMETERS.DP_CYLINDERS],ax
  5207 00001745 EB0E                    	jmp	short done_ret
  5208                                  
  5209                                  try_s:
  5210 00001747 F7C11000                	test	cx,flagseclim
  5211 0000174B 7405                    	jz	short try_h
  5212 0000174D A3[BB1C]                	mov	[SLIM],ax
  5213 00001750 EB03                    	jmp	short done_ret
  5214                                  ;
  5215                                  ; Must be for number of heads
  5216                                  try_h:
  5217 00001752 A3[B91C]                	mov	[HLIM],ax
  5218                                  
  5219                                  done_ret:
  5220 00001755 F8                      	clc
  5221 00001756 C3                      	retn
  5222                                  
  5223                                  ; 05/07/2018 - Retro DOS v3.0
  5224                                  
  5225                                  ;
  5226                                  ; SetDeviceParameters sets up the recommended BPB in each BDS in the
  5227                                  ; system based on the form factor. It is assumed that the BPBs for the
  5228                                  ; various form factors are present in the BPBTable. For hard files,
  5229                                  ; the Recommended BPB is the same as the BPB on the drive.
  5230                                  ; No attempt is made to preserve registers since we are going to jump to
  5231                                  ; SYSINIT straight after this routine.
  5232                                  ;
  5233                                  SetDeviceParameters:
  5234                                  	; 06/07/2018 - Retro DOS v3.0
  5235 00001757 06                      	push	es
  5236 00001758 0E                      	push	cs
  5237 00001759 07                      	pop	es
  5238                                  ;ASSUME ES:SYSINITSEG
  5239 0000175A 31DB                    	xor	bx,bx
  5240 0000175C 8A1E[911C]              	mov	bl,[DEVICEPARAMETERS+A_DEVICEPARAMETERS.DP_DEVICETYPE]
  5241 00001760 80FB00                  	cmp	bl,DEV_5INCH
  5242 00001763 7507                    	jnz	short Got_80
  5243 00001765 B92800                  	mov	cx,40			; 48tpi has 40 cylinders
  5244 00001768 890E[941C]              	mov	[DEVICEPARAMETERS+A_DEVICEPARAMETERS.DP_CYLINDERS],cx
  5245                                  Got_80:
  5246 0000176C D1E3                    	shl	bx,1			; get index into BPB table
  5247                                  	; 06/07/2018
  5248                                  	;mov	si,BPBTable
  5249 0000176E 81C3[3E1D]              	add	bx,BPBTable
  5250                                  	;mov	si,[si+bx]		; get address of BPB
  5251 00001772 8B37                    	mov	si,[bx]
  5252                                  Set_RecBPB:
  5253 00001774 BF[971C]                	mov	di,DEVICEPARAMETERS+A_DEVICEPARAMETERS.DP_BPB ; es:di -> BPB
  5254                                  	; 06/07/2018
  5255                                  	;mov	cx,A_BPB.size ; = 31
  5256 00001777 B91900                  	mov	cx,BPBSIZ ; = 25 
  5257 0000177A FC                      	cld
  5258 0000177B F3A4                    	repe	movsb
  5259 0000177D 07                      	pop	es
  5260                                  ;ASSUME ES:NOTHING
  5261 0000177E F706[BE1C]1000          	test	word [SWITCHES],flagseclim
  5262 00001784 7406                    	jz	short see_heads
  5263 00001786 A1[BB1C]                	mov	ax,[SLIM]
  5264 00001789 A3[A41C]                	mov	word [DEVICEPARAMETERS+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERTRACK],ax
  5265                                  see_heads:
  5266 0000178C F706[BE1C]2000          	test	word [SWITCHES],flagheads
  5267 00001792 743E                    	jz	short Set_All_Done
  5268 00001794 A1[B91C]                	mov	ax,[HLIM]
  5269 00001797 A3[A61C]                	mov	word [DEVICEPARAMETERS+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_HEADS],ax
  5270                                  ;
  5271                                  ; We need to set the media byte and the total number of sectors to reflect the
  5272                                  ; number of heads. We do this by multiplying the number of heads by the number
  5273                                  ; of 'sectors per head'. This is not a fool-proof scheme!!
  5274                                  ;
  5275 0000179A 89C1                    	mov	cx,ax			; cx has number of heads
  5276 0000179C FEC9                    	dec	cl			; get it 0-based
  5277 0000179E A1[9F1C]                	mov	ax,[DEVICEPARAMETERS+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_TOTALSECTORS]
  5278                                  					; this is OK for two heads
  5279 000017A1 D1F8                    	sar	ax,1			; ax contains # of sectors/head
  5280 000017A3 D3E0                    	sal	ax,cl
  5281 000017A5 722B                    	jc	short Set_All_Done	; We have too many sectors - overflow!!
  5282 000017A7 A3[9F1C]                	mov	[DEVICEPARAMETERS+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_TOTALSECTORS],ax
  5283                                  ; Set up correct Media Descriptor Byte
  5284 000017AA 80F901                  	cmp	cl,1
  5285 000017AD B3F0                    	mov	bl,0F0H
  5286 000017AF B002                    	mov	al,2			; AL contains sectors/cluster
  5287 000017B1 7717                    	ja	short Got_Correct_Mediad
  5288 000017B3 8A1E[A11C]              	mov	bl,[DEVICEPARAMETERS+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_MEDIADESCRIPTOR]
  5289 000017B7 7411                    	je	short Got_Correct_Mediad
  5290                                  ; We have one head - OK for 48tpi medium
  5291 000017B9 B001                    	mov	al,1			; AL contains sectors/cluster
  5292 000017BB 8A2E[911C]              	mov	ch,[DEVICEPARAMETERS+A_DEVICEPARAMETERS.DP_DEVICETYPE]
  5293 000017BF 80FD00                  	cmp	ch,DEV_5INCH
  5294 000017C2 7404                    	jz	short Dec_Mediad
  5295 000017C4 B3F0                    	mov	bl,0F0H
  5296 000017C6 EB02                    	jmp	short Got_Correct_Mediad
  5297                                  Dec_Mediad:
  5298 000017C8 FECB                    	dec	bl			; adjust for one head
  5299                                  Got_Correct_Mediad:
  5300 000017CA 881E[A11C]              	mov	[DEVICEPARAMETERS+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_MEDIADESCRIPTOR],bl
  5301 000017CE A2[991C]                	mov	[DEVICEPARAMETERS+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERCLUSTER],al
  5302 000017D1 F8                      	clc
  5303                                  Set_All_Done:
  5304 000017D2 C3                      	RETN
  5305                                  
  5306                                  ;ASSUME DS:NOTHING, ES:NOTHING
  5307                                  
  5308 000017D3 F9                      NOCHAR1: STC
  5309 000017D4 C3                      	 retn
  5310                                  
  5311                                  ; ---------------------------------------
  5312                                  
  5313                                  ORGANIZE:
  5314                                  	;mov	cx,[cs:COUNT] ; 05/07/2018
  5315 000017D5 8B0E[5108]                      MOV     CX,[COUNT]
  5316 000017D9 E3F8                            JCXZ    NOCHAR1
  5317 000017DB E8B700                          CALL    MAPCASE
  5318 000017DE 31F6                            XOR     SI,SI
  5319 000017E0 89F7                            MOV     DI,SI
  5320                                  
  5321                                  ORG1:   
  5322 000017E2 E86F00                  	CALL    GET                     ; SKIP LEADING CONTROL CHARACTERS
  5323 000017E5 3C20                            CMP     AL,' '
  5324 000017E7 72F9                            JB      SHORT ORG1
  5325                                  
  5326 000017E9 51                              PUSH    CX
  5327 000017EA 56                              PUSH    SI
  5328 000017EB 57                              PUSH    DI
  5329 000017EC 89F5                            MOV     BP,SI
  5330 000017EE 4D                              DEC     BP
  5331 000017EF BE[3D1C]                        MOV     SI,COMTAB		; Prepare to search command table
  5332 000017F2 B500                            MOV     CH,0
  5333                                  FINDCOM:
  5334 000017F4 89EF                            MOV     DI,BP
  5335 000017F6 8A0C                            MOV     CL,[SI]
  5336 000017F8 46                              INC     SI
  5337 000017F9 E30E                            JCXZ    NOCOM
  5338 000017FB F3A6                            REPE    CMPSB
  5339 000017FD 9F                              LAHF
  5340 000017FE 01CE                            ADD     SI,CX                   ; Bump to next position without affecting flags
  5341 00001800 9E                              SAHF
  5342 00001801 AC                              LODSB                           ; Get indicator letter
  5343 00001802 75F0                            JNZ     SHORT FINDCOM
  5344 00001804 5F                              POP     DI
  5345 00001805 5E                              POP     SI
  5346 00001806 59                              POP     CX
  5347 00001807 EB05                            JMP     SHORT GOTCOM
  5348                                  
  5349                                  NOCOM:
  5350 00001809 5F                              POP     DI
  5351 0000180A 5E                              POP     SI
  5352 0000180B 59                              POP     CX
  5353 0000180C B05A                            MOV     AL,'Z'
  5354                                  GOTCOM: 
  5355 0000180E AA                      	STOSB                           ; SAVE INDICATOR CHAR IN BUFFER
  5356                                  
  5357                                  ORG2:   
  5358 0000180F E83A00                  	CALL    GET2                    ; SKIP NAME UNTIL DELIMETER
  5359 00001812 E84C00                          CALL    DELIM                   ;
  5360 00001815 75F8                            JNZ     SHORT ORG2
  5361                                  
  5362                                  ; 10/06/2018 - Retro DOS v3.0 (MSDOS 3.3, SYSINIT2.ASM, 02/02/2018)
  5363                                  ;--------------------------------------------------------------bug330a03
  5364                                  ; - isp
  5365                                  ;* the following two lines in the parsing caused the drivparm line to break
  5366                                  ;* we cannot let the "/" character be counted as a delimiter here. 
  5367                                  ;	CALL	GET			;GET CHARS TO RIGHT OF EQUALS SIGN
  5368                                  ;	STOSB
  5369                                  ;--------------------------------------------------------------bug330a03
  5370                                  
  5371                                  ;--------------------------------------------------------------bug330a03
  5372                                  ; - isp
  5373                                  ;* the following lines replaced the lines taken out
  5374 00001817 E83200                  ORG3:	CALL	GET2
  5375 0000181A E84800                  	call	DELIM1
  5376 0000181D 74F8                    	jz	short ORG3
  5377 0000181F 3C2F                    	cmp	al,'/'
  5378 00001821 7421                    	jz	short ORG_EXT
  5379 00001823 AA                      	stosb
  5380                                  ;--------------------------------------------------------------bug330a03
  5381                                  
  5382                                  ORG4:   
  5383 00001824 E82500                  	CALL    GET2
  5384 00001827 E83700                  	CALL	DELIM ; 26/03/2018
  5385 0000182A 7418                    	JZ	SHORT ORG_EXT
  5386 0000182C AA                              STOSB
  5387 0000182D 3C20                            CMP     AL,' '
  5388 0000182F 77F3                            JA      SHORT ORG4
  5389 00001831 3C0A                            CMP     AL,10
  5390 00001833 74AD                            JZ      SHORT ORG1
  5391                                  
  5392 00001835 26C645FF00                      MOV     BYTE [ES:DI-1],0
  5393                                  ORG5:   
  5394 0000183A E80F00                  	CALL    GET2
  5395 0000183D AA                              STOSB
  5396 0000183E 3C0A                            CMP     AL,10
  5397 00001840 75F8                            JNZ     SHORT ORG5
  5398 00001842 EB9E                            JMP     SHORT ORG1
  5399                                  
  5400                                  ORG_EXT: ; 26/03/2018
  5401 00001844 26C60500                	MOV	BYTE [ES:DI], 0		;put 0 at DI to make it an ASCIIZ
  5402 00001848 47                      	INC	DI
  5403 00001849 AA                      	STOSB				;and copy the delimeter char.
  5404 0000184A EBEE                    	JMP	SHORT ORG5		;and continue as usual.
  5405                                  
  5406                                  GET2:
  5407 0000184C E32E                            JCXZ    NOGET
  5408 0000184E 268A04                          MOV     AL,[ES:SI]
  5409 00001851 46                              INC     SI
  5410 00001852 49                              DEC     CX
  5411 00001853 C3                              RETN
  5412                                  
  5413                                  GET:    
  5414 00001854 E326                    	JCXZ    NOGET
  5415 00001856 268A04                          MOV     AL,[ES:SI]
  5416 00001859 46                              INC     SI
  5417 0000185A 49                              DEC     CX
  5418 0000185B E80300                          CALL    DELIM
  5419 0000185E 74F4                            JZ      SHORT GET
  5420                                  GRET:   
  5421 00001860 C3                      	RETN
  5422                                  
  5423                                  ; 10/06/2018 - Retro DOS v3.0 (MSDOS 3.3, SYSINIT2.ASM, 02/02/2018)
  5424                                  ;--------------------------------------------------------------bug330a03
  5425                                  ; isp - small changes here, new entry point into routine
  5426                                  DELIM:	
  5427 00001861 3C2F                    	CMP	AL,'/'          ; 5/30/86. IBM will assume "/" delim  ;3.30
  5428 00001863 74FB                    	jz	short GRET					      ;3.30
  5429                                  DELIM1:
  5430 00001865 3C20                    	CMP	AL,' '
  5431 00001867 74F7                    	jz	short GRET
  5432 00001869 3C09                    	CMP	AL,9
  5433 0000186B 74F3                    	jz	short GRET
  5434 0000186D 3C3D                    	CMP	AL,'='
  5435 0000186F 74EF                    	jz	short GRET
  5436 00001871 3C2C                    	CMP	AL,','
  5437 00001873 74EB                    	jz	short GRET
  5438 00001875 3C3B                    	CMP	AL,';'
  5439 00001877 74E7                    	jz	short GRET	; 5/23/86			      ;3.30
  5440 00001879 3C00                    	cmp	al, 0		; 5/23/86 Special case for sysinit!!! ;3.30
  5441 0000187B C3                      	retn
  5442                                  
  5443                                  ;--------------------------------------------------------------bug330a03
  5444                                  
  5445                                  NOGET:  
  5446 0000187C 59                      	POP     CX
  5447                                  	; 20/06/2018
  5448                                          ;MOV	[cs:COUNT],DI
  5449 0000187D 893E[5108]                      MOV     [COUNT],DI ; 05/07/2018
  5450 00001881 31F6                            XOR     SI,SI
  5451                                          ;MOV	[cs:CHRPTR],SI
  5452 00001883 8936[5308]                      MOV	[CHRPTR],SI ; 05/07/2018
  5453 00001887 C3                              RETN
  5454                                  
  5455                                  ;
  5456                                  ;  NEWLINE RETURNS WITH FIRST CHARACTER OF NEXT LINE
  5457                                  ;
  5458                                  NEWLINE:
  5459 00001888 E891FD                  	CALL    GETCHR                  ; SKIP NON-CONTROL CHARACTERS
  5460 0000188B 7207                            JC      SHORT NONEW
  5461 0000188D 3C0A                            CMP     AL,10                   ; LOOK FOR LINE FEED
  5462 0000188F 75F7                            JNZ     SHORT NEWLINE
  5463 00001891 E888FD                          CALL    GETCHR
  5464                                  NONEW:  
  5465 00001894 C3                      	RETN
  5466                                  
  5467                                  MAPCASE:
  5468 00001895 51                              PUSH    CX
  5469 00001896 56                              PUSH    SI
  5470 00001897 1E                              PUSH    DS
  5471 00001898 06                              PUSH    ES
  5472 00001899 1F                              POP     DS
  5473 0000189A 31F6                            XOR     SI,SI
  5474                                  CONVLOOP:
  5475 0000189C AC                              LODSB
  5476                                  
  5477                                          ;IF      KANJI
  5478                                          ;CALL    TESTKANJ
  5479                                          ;JZ      SHORT NORMCONV
  5480                                          ;INC     SI			; Skip next char
  5481                                          ;DEC     CX
  5482                                          ;JCXZ    CONVDONE		; Just ignore 1/2 kanji error
  5483                                  ; Fall through, know AL is not in 'a'-'z' range
  5484                                  ;NORMCONV:
  5485                                          ;ENDIF
  5486                                  
  5487 0000189D 3C61                            CMP     AL,'a'
  5488 0000189F 7209                            JB      SHORT NOCONV
  5489 000018A1 3C7A                            CMP     AL,'z'
  5490 000018A3 7705                            JA      SHORT NOCONV
  5491 000018A5 2C20                            SUB     AL,20H
  5492 000018A7 8844FF                          MOV     [SI-1],AL
  5493                                  NOCONV:
  5494 000018AA E2F0                            LOOP    CONVLOOP
  5495                                  CONVDONE:
  5496 000018AC 1F                              POP     DS
  5497 000018AD 5E                              POP     SI
  5498 000018AE 59                              POP     CX
  5499 000018AF C3                              RETN
  5500                                  
  5501                                          ;IF      KANJI
  5502                                  ;TESTKANJ:
  5503                                          ;CMP     AL,81H
  5504                                          ;JB      SHORT NOTLEAD
  5505                                          ;CMP     AL,9FH
  5506                                          ;JBE     SHORT ISLEAD
  5507                                          ;CMP     AL,0E0H
  5508                                          ;JB      SHORT NOTLEAD
  5509                                          ;CMP     AL,0FCH
  5510                                          ;JBE    SHORT  ISLEAD
  5511                                  ;NOTLEAD:
  5512                                          ;PUSH    AX
  5513                                          ;XOR     AX,AX			; Set zero
  5514                                          ;POP     AX
  5515                                          ;RETN
  5516                                  ;ISLEAD:
  5517                                          ;PUSH    AX
  5518                                          ;XOR     AX,AX			; Set zero
  5519                                          ;INC     AX			; Reset zero
  5520                                          ;POP     AX
  5521                                          ;RETN
  5522                                          ;ENDIF
  5523                                  
  5524                                  Yes_Break_Failed:			;dev drv Init failed and aborted.
  5525 000018B0 F9                      	stc
  5526 000018B1 58                      	pop	ax
  5527 000018B2 C3                      	retn
  5528                                  
  5529                                  SET_BREAK:
  5530                                  	; 22/06/2018
  5531                                  	; 10/06/2018 - Retro DOS v3.0
  5532                                  
  5533                                  ; 8/14/86  For DOS 3.3, this routine is modified to take care of the
  5534                                  ;Device driver's initialization error and abort.
  5535                                  ;If [break_addr+2] == [memhi] && [break_addr] = 0 then assume
  5536                                  ;that the device driver's initialization has an error and wanted to
  5537                                  ;abort the device driver.  In this case, this routine will set carry
  5538                                  ;and return to the caller.
  5539                                  ;
  5540 000018B3 50                      	PUSH	AX
  5541 000018B4 2EA1[7008]              	MOV	AX,[CS:BREAK_ADDR+2]	;REMOVE THE INIT CODE
  5542 000018B8 2E3B06[5A08]            	cmp	ax,[CS:MEMHI]
  5543 000018BD 7508                    	jne	short Set_Break_Continue  ;if not same, then O.K.
  5544                                  
  5545 000018BF 2E833E[6E08]00          	cmp	word [CS:BREAK_ADDR],0 
  5546 000018C5 74E9                    	je	SHORT Yes_Break_Failed	;[Break_addr+2]=[MEMHI] & [Break_addr]=0 
  5547                                  
  5548                                  Set_Break_Continue:
  5549 000018C7 2EA3[5A08]              	MOV	[CS:MEMHI],AX
  5550 000018CB 2EA1[6E08]              	MOV	AX,[CS:BREAK_ADDR]
  5551 000018CF 2EA3[5808]              	MOV	[CS:MEMLO],AX
  5552 000018D3 58                      	POP	AX			    ; NOTE FALL THROUGH
  5553                                  
  5554                                  ;
  5555                                  ; Round the values in MEMLO and MEMHI to paragraph boundary.
  5556                                  ; Perform bounds check.
  5557                                  ;
  5558                                  
  5559                                  ROUND: 
  5560                                  	; 22/06/2018 
  5561                                  	; 10/06/2018 - Retro DOS v3.0
  5562                                  	; 26/03/2018
  5563 000018D4 50                      	PUSH	AX
  5564 000018D5 2EA1[5808]              	MOV     AX,[CS:MEMLO]
  5565 000018D9 E8E1F4                  	CALL	ParaRound
  5566 000018DC 2E0106[5A08]                    ADD     [CS:MEMHI],AX
  5567                                          ;XOR     AX,AX
  5568                                          ;MOV     [CS:MEMLO],AX
  5569                                  	; 06/07/2018
  5570 000018E1 2EC706[5808]0000        	mov	word [CS:MEMLO], 0
  5571 000018E8 2EA1[5A08]              	MOV	AX,[CS:MEMHI]		; ax = new memhi
  5572 000018EC 2E3B06[1908]            	CMP	AX,[CS:ALLOCLIM]	; if new memhi >= alloclim, error
  5573 000018F1 7303                    	JAE	SHORT MEM_ERR
  5574 000018F3 58                      	POP	AX
  5575 000018F4 F8                      	CLC
  5576 000018F5 C3                              RETN
  5577                                  
  5578                                  MEM_ERR:
  5579 000018F6 BA[381E]                	MOV	DX,BADMEM
  5580 000018F9 0E                      	PUSH	CS
  5581 000018FA 1F                      	POP	DS
  5582 000018FB E84502                  	CALL	PRINT
  5583 000018FE E9F4F1                  	JMP	STALL
  5584                                  
  5585                                  CALLDEV:
  5586 00001901 2E8E1E[FA07]            	MOV     DS,[CS:ENTRY_POINT+2]
  5587 00001906 2E031E[F807]                    ADD     BX,[CS:ENTRY_POINT]	; Do a little relocation
  5588 0000190B 8B07                            MOV     AX,[BX]
  5589 0000190D 2EFF36[F807]                    PUSH    WORD [CS:ENTRY_POINT]
  5590 00001912 2EA3[F807]                      MOV     [CS:ENTRY_POINT],AX
  5591 00001916 BB[6008]                        MOV     BX,PACKET
  5592 00001919 2EFF1E[F807]                    CALL    FAR [CS:ENTRY_POINT]	; 10/06/2018
  5593 0000191E 2E8F06[F807]                    POP     WORD [CS:ENTRY_POINT]
  5594 00001923 C3                              RETN
  5595                                  
  5596                                  BADNUM:
  5597                                  	; 10/06/2018 - Retro DOS v3.0
  5598 00001924 2EC606[4008]00          	mov	byte [CS:SEPCHR],0 ; 06/07/2018
  5599 0000192A 31C0                    	XOR	AX,AX		; Set Zero flag, and AX = 0
  5600 0000192C 5B                      	pop	bx
  5601 0000192D F9                      	stc			; AND carry set
  5602 0000192E C3                      	retn
  5603                                  
  5604                                  TODIGIT:
  5605 0000192F 2C30                            SUB     AL,'0'
  5606 00001931 7206                            JB      SHORT NOTDIG
  5607 00001933 3C09                            CMP     AL,9
  5608 00001935 7702                            JA      SHORT NOTDIG
  5609 00001937 F8                              CLC
  5610 00001938 C3                              RETN
  5611                                  NOTDIG: 
  5612 00001939 F9                      	STC
  5613 0000193A C3                              RETN
  5614                                  
  5615                                  ; GetNum parses a decimal number.
  5616                                  ; Returns it in AX, sets zero flag if AX = 0 (MAY BE considered an
  5617                                  ; error), if number is BAD carry is set, zero is set, AX=0.
  5618                                  
  5619                                  GETNUM: 
  5620 0000193B 53                      	push	bx	; 10/06/2018 (Retro DOS 3.0, MSDOS 3.3)
  5621 0000193C 31DB                    	XOR     BX,BX                   ; running count is zero
  5622                                  B2:     
  5623 0000193E E8EEFF                  	CALL    TODIGIT                 ; do we have a digit
  5624 00001941 72E1                            JC      SHORT BADNUM		; no, bomb
  5625 00001943 93                              XCHG    AX,BX                   ; put total in AX
  5626 00001944 53                              PUSH    BX                      ; save digit
  5627 00001945 BB0A00                          MOV     BX,10                   ; base of arithmetic
  5628 00001948 F7E3                            MUL     BX                      ; shift by one decimal digit
  5629 0000194A 5B                              POP     BX                      ; get back digit
  5630 0000194B 00D8                            ADD     AL,BL                   ; get total
  5631 0000194D 80D400                          ADC     AH,0                    ; make that 16 bits
  5632 00001950 72D2                            JC      SHORT BADNUM		; too big a number
  5633 00001952 93                              XCHG    AX,BX                   ; stash total
  5634 00001953 E8C6FC                          CALL    GETCHR                  ; GET NEXT DIGIT
  5635 00001956 722D                            JC      SHORT B1		; no more characters
  5636                                  
  5637                                  	; 10/06/2018
  5638 00001958 3C20                    	cmp	al,' '			; 5/23/86 space? 
  5639 0000195A 741F                    	jz	short B15		; 5/23/86 then end of digits
  5640 0000195C 3C2C                    	cmp	al,','			; 5/23/86 ',' is a seperator!
  5641 0000195E 741B                    	jz	short B15		; 5/23/86 then end of digits.
  5642 00001960 3C09                    	cmp	al,9			; 5/23/86 TAB
  5643 00001962 7417                    	jz	short B15		;
  5644                                  	; 22/06/2018
  5645 00001964 2E3A06[4008]            	CMP	AL,[CS:SEPCHR]		; allow , separators
  5646 00001969 7410                    	JZ	short B15
  5647 0000196B 3C2F                    	cmp	al,SWTCHR		; See if another switch follows
  5648 0000196D 740C                    	JZ	short B15
  5649 0000196F 3C0A                    	cmp	al,10			; Line-feed?
  5650 00001971 7408                    	jz	short B15
  5651 00001973 3C0D                    	cmp	al,13			; Carriage return?
  5652 00001975 7404                    	jz	short B15
  5653                                  	
  5654 00001977 08C0                    	OR      AL,AL                   ; end of line separator?
  5655 00001979 75C3                            JNZ     SHORT B2		; no, try as a valid character
  5656                                  B15:        
  5657 0000197B 2EFF06[5108]            	INC     WORD [CS:COUNT]		; one more character to scan
  5658 00001980 2EFF0E[5308]                    DEC     WORD [CS:CHRPTR]	; back up over separator
  5659                                  B1:     
  5660 00001985 89D8                    	MOV     AX,BX                   ; get proper count
  5661 00001987 09C0                            OR      AX,AX
  5662 00001989 5B                      	pop	bx	; 10/06/2018
  5663 0000198A C3                              RETN
  5664                                  
  5665                                  SKIP_DELIM:
  5666                                  ;Skip the delimeters pointed by CHRPTR. AL will contain the first non delimeter
  5667                                  ;character encountered and CHRPTR will point to the next character.
  5668                                  ;This routine will assume the second "," found as a non delimiter character.
  5669                                  ;So, in case if the string is " , , ", this routine will stop at the second ",".
  5670                                  ;At this time, Zero flag is set.
  5671                                  ;If COUNT is exhausted, then carry will be set.
  5672                                  Skip_delim_char:
  5673 0000198B E88EFC                  	call	GETCHR
  5674 0000198E 7218                    	jc	short Skip_delim_exit
  5675 00001990 3C2C                    	cmp	al,','			;the first comma?
  5676 00001992 7406                    	je	short Skip_delim_next
  5677 00001994 E8CAFE                  	call	DELIM			;check the charater in AL.
  5678 00001997 74F2                    	jz	short Skip_delim_char
  5679                                  	; 06/07/2018
  5680                                  	;jmp	short Skip_delim_exit	;found a non delim char
  5681 00001999 C3                      	retn
  5682                                  Skip_delim_next:
  5683 0000199A E87FFC                  	call	GETCHR
  5684 0000199D 7209                    	jc	short Skip_delim_exit
  5685 0000199F 3C2C                    	cmp	al,','			;the second comma?
  5686 000019A1 7405                    	je	short Skip_delim_exit 	;done
  5687 000019A3 E8BBFE                  	call	DELIM
  5688 000019A6 74F2                    	jz	short Skip_delim_next
  5689                                  Skip_delim_exit:
  5690 000019A8 C3                      	retn
  5691                                  
  5692                                  ; 10/06/2018 (Retro DOS 3.0, MSDOS 3.3)
  5693                                  
  5694                                  ; 5/26/86 *****************************************************************
  5695                                  SetDOSCountryInfo:
  5696                                  ;Input: ES:DI -> pointer to DOS_COUNTRY_CDPG_INFO			 
  5697                                  ;	DS:0  -> buffer.						 
  5698                                  ;	SI = 0								 
  5699                                  ;	AX = country id 						 
  5700                                  ;	DX = code page id. (If 0, then use ccSysCodePage as a default.) 
  5701                                  ;	BX = file handle						 
  5702                                  ;	This routine can handle maxium 72 COUNTRY_DATA entries. 	 
  5703                                  ;Output: DOS_country_cdpg_info set.					 
  5704                                  ;	 Carry set if any file read failure or wrong information in the file.
  5705                                  ;	 Carry set and CX = -1 if cannot find the matching COUNTRY_id, CODEPAGE
  5706                                  ;	 _id in the file.						 
  5707                                  									 
  5708 000019A9 57                      	push	di							 
  5709 000019AA 50                      	push	ax							 
  5710 000019AB 52                      	push	dx							 
  5711                                  									 
  5712 000019AC 31C9                    	xor	cx,cx							 
  5713 000019AE 31D2                    	xor	dx,dx							 
  5714 000019B0 B80002                  	mov	ax,512			;read 512 bytes 		 
  5715 000019B3 E80701                  	call	ReadInControlBuffer	;Read the file header		 
  5716 000019B6 724C                    	jc	short SetDOSData_fail 					 
  5717 000019B8 06                      	push	es							 
  5718 000019B9 56                      	push	si							 
  5719 000019BA 0E                      	push	cs							 
  5720 000019BB 07                      	pop	es							 
  5721 000019BC BF[121C]                	mov	di,COUNTRY_FILE_SIGNATURE			 
  5722 000019BF B90800                  	mov	cx,8			;length of the signature	 
  5723 000019C2 F3A6                    	repz	cmpsb							 
  5724 000019C4 5E                      	pop	si							 
  5725 000019C5 07                      	pop	es							 
  5726 000019C6 753C                    	jnz	short SetDOSData_fail 	;signature mismatch		 
  5727                                  									 
  5728 000019C8 83C612                  	add	si,18			;SI -> county info type 	 
  5729 000019CB 803C01                  	cmp	byte [si],1		;Only accept type 1 (Currently only 1 header type)
  5730 000019CE 7534                    	jne	short SetDOSData_fail 	;cannot proceed. error return	 
  5731 000019D0 46                      	inc	si			;SI -> file offset		 
  5732 000019D1 8B14                    	mov	dx,[si]			;Get the INFO file offset.	 
  5733 000019D3 8B4C02                  	mov	cx,[si+2]					 
  5734 000019D6 B80004                  	mov	ax,1024			;read 1024 bytes.		 
  5735 000019D9 E8E100                  	call	ReadInControlBuffer	;Read INFO			 
  5736 000019DC 7226                    	jc	short SetDOSData_fail 					 
  5737 000019DE 8B0C                    	mov	cx,[si]			;get the # of country, codepage combination entries
  5738 000019E0 83F948                  	cmp	cx,72			;cannot handle more than 72 entries.
  5739 000019E3 771F                    	ja	short SetDOSData_fail 					 
  5740 000019E5 46                      	inc	si							 
  5741 000019E6 46                      	inc	si			;SI -> entry information packet 
  5742 000019E7 5A                      	pop	dx			;restore code page id		 
  5743 000019E8 58                      	pop	ax			;restore country id		 
  5744 000019E9 5F                      	pop	di							 
  5745                                  									 
  5746                                  SetDOSCntry_find:			;Search for desired country_id,codepage_id.
  5747 000019EA 3B4402                  	cmp	ax,[si+2]		;compare country_id		 
  5748 000019ED 750A                    	jne	short SetDOSCntry_next					 
  5749 000019EF 83FA00                  	cmp	dx,0			;No user specified code page ?	 
  5750 000019F2 7415                    	je	short SetDOSCntry_any_CodePage ;then no need to match code page id.
  5751 000019F4 3B5404                  	cmp	dx,[si+4]		;compare code page id		 
  5752 000019F7 7413                    	je	short SetDOSCntry_got_it					 
  5753                                  SetDOSCntry_next:							 
  5754 000019F9 0334                    	add	si,[si]			;next entry			 
  5755 000019FB 46                      	inc	si							 
  5756 000019FC 46                      	inc	si			;take a word for size of entry itself
  5757 000019FD E2EB                    	loop	SetDOSCntry_find					 
  5758 000019FF B9FFFF                  	mov	cx, -1			;signals that bad country id entered.
  5759                                  SetDOSCntry_fail:							 
  5760 00001A02 F9                      	stc								 
  5761 00001A03 C3                      	retn								 
  5762                                  									 
  5763                                  SetDOSData_fail:							 
  5764 00001A04 5E                      	pop	si							 
  5765 00001A05 59                      	pop	cx							 
  5766 00001A06 5F                      	pop	di							 
  5767 00001A07 EBF9                    	jmp	short SetDOSCntry_fail				 
  5768                                  									 
  5769                                  SetDOSCntry_any_CodePage:		;use the code_page_id of the country_id found.
  5770 00001A09 8B5404                  	mov	dx,[si+4]					 
  5771                                  SetDOSCntry_got_it:			;found the matching entry	 
  5772 00001A0C 2E8916[1A1C]            	mov	[cs:CntryCodePage_Id],dx ;save code page ID for this country.
  5773 00001A11 8B540A                  	mov	dx,[si+10]		;get the file offset of country data
  5774 00001A14 8B4C0C                  	mov	cx,[si+12] 				 
  5775 00001A17 B80002                  	mov	ax,512			;read 512 bytes 		 
  5776 00001A1A E8A000                  	call	ReadInControlBuffer					 
  5777 00001A1D 72E3                    	jc	short SetDOSCntry_fail					 
  5778 00001A1F 8B0C                    	mov	cx,[si]			;get the number of entries to handle.
  5779 00001A21 46                      	inc	si							 
  5780 00001A22 46                      	inc	si			;SI -> first entry		 
  5781                                  									 
  5782                                  SetDOSCntry_data:							 
  5783 00001A23 57                      	push	di			;ES:DI -> DOS_COUNTRY_CDPG_INFO 
  5784 00001A24 51                      	push	cx			;save # of entry left		 
  5785 00001A25 56                      	push	si			;si -> current entry in Control buffer
  5786                                  									 
  5787 00001A26 8A4402                  	mov	al,[si+2]		;get data entry id		 
  5788 00001A29 E86300                  	call	GetCountryDestination	;get the address of destination in ES:DI
  5789 00001A2C 7257                    	jc	short SetDOSCntry_data_next ;No matching data entry id in DOS 
  5790                                  									 
  5791 00001A2E 8B5404                  	mov	dx,[si+4]		;get offset of data		 
  5792 00001A31 8B4C06                  	mov	cx,[si+6]					 
  5793 00001A34 B80042                  	mov	ax,4200h						 
  5794 00001A37 F9                      	stc								 
  5795 00001A38 CD21                    	int	21h			;move pointer			 
  5796 00001A3A 72C8                    	jc	short SetDOSData_fail 					 
  5797 00001A3C BA0002                  	mov	dx,512			;start of data buffer		 
  5798 00001A3F 268B0D                  	mov	cx,[es:di]		;length of the corresponding data in DOS.
  5799 00001A42 83C10A                  	add	cx,10			;Signature + A word for the length itself
  5800 00001A45 B43F                    	mov	ah,3Fh 						 
  5801 00001A47 F9                      	stc								 
  5802 00001A48 CD21                    	int	21h			;read the country.sys data	 
  5803 00001A4A 72B8                    	jc	short SetDOSData_fail 	;read failure			 
  5804 00001A4C 39C8                    	cmp	ax, cx							 
  5805 00001A4E 75B4                    	jne	short SetDOSData_fail 					 
  5806                                  									 
  5807 00001A50 8A4402                  	mov	al,[si+2]		;save Data id for future use.	 
  5808 00001A53 BE0802                  	mov	si,(512+8)		;SI-> data buffer + id tag field 
  5809 00001A56 8B0C                    	mov	cx,[si]			;get the length of the file	 
  5810 00001A58 41                      	inc	cx			;Take care of a word for lenght of tab
  5811 00001A59 41                      	inc	cx			;itself.			 
  5812 00001A5A 81F9F805                	cmp	cx,(2048-512-8)		;Fit into the buffer?		 
  5813 00001A5E 77A4                    	ja	short SetDOSData_fail 					 
  5814 00001A60 3C01                    	cmp	al,SetCountryInfo	;is the data for SetCountryInfo table?
  5815 00001A62 7512                    	jne	short SetDOSCntry_Mov 	;no, don't worry                
  5816 00001A64 26FF7518                	push	word [es:di+24]		;Cannot destroy ccMono_ptr address. Save them.
  5817 00001A68 26FF751A                	push	word [es:di+26]					 
  5818 00001A6C 57                      	push	di			;save DI			 
  5819                                  									 
  5820 00001A6D 50                      	push	ax							 
  5821 00001A6E 2EA1[1A1C]              	mov	ax,[cs:CntryCodePage_Id] ;Do not use the Code Page info in Country_Info
  5822 00001A72 894404                  	mov	[si+4], ax		;Use the saved one for this !!!! 
  5823 00001A75 58                      	pop	ax							 
  5824                                  									 
  5825                                  SetDOSCntry_Mov:							 
  5826 00001A76 F3A4                    	rep	movsb			;copy the table into DOS	 
  5827 00001A78 3C01                    	cmp	al,SetCountryInfo	;was the ccMono_ptr saved?	 
  5828 00001A7A 7509                    	jne	short SetDOSCntry_data_next					 
  5829 00001A7C 5F                      	pop	di			;restore DI			 
  5830 00001A7D 268F451A                	pop	word [es:di+26]		;restore ccMono_ptr in DOS.	 
  5831 00001A81 268F4518                	pop	word [es:di+24]					 
  5832                                  									 
  5833                                  SetDOSCntry_data_next:							 
  5834 00001A85 5E                      	pop	si			;restore control buffer pointer 
  5835 00001A86 59                      	pop	cx			;restore # of entries left	 
  5836 00001A87 5F                      	pop	di			;restore pointer to DSO_COUNTRY_CDPG
  5837 00001A88 0334                    	add	si,[si]			;try to get the next entry	 
  5838 00001A8A 46                      	inc	si							 
  5839 00001A8B 46                      	inc	si			;take a word of entry length itself
  5840 00001A8C E295                    	loop	SetDOSCntry_data					 
  5841 00001A8E C3                      	retn								 
  5842                                  					 
  5843                                  GetCountryDestination:				 
  5844                                  ;Get the destination address in the DOS country info table.		 
  5845                                  ;Input: AL - Data ID							 
  5846                                  ;	ES:DI -> DOS_COUNTRY_CDPG_INFO					 
  5847                                  ;On return:								 
  5848                                  ;	ES:DI -> Destination address of the matching data id		 
  5849                                  ;	carry set if no matching data id found in DOS.			 
  5850                                  									 
  5851 00001A8F 51                      	push	cx							 
  5852 00001A90 83C74A                  	add	di,country_cdpg_info.ccNumber_of_entries
  5853                                  					;skip the reserved area, syscodepage etc.
  5854 00001A93 268B0D                  	mov	cx,[es:di]		;get the number of entries	 
  5855 00001A96 47                      	inc	di							 
  5856 00001A97 47                      	inc	di			;SI -> the first start entry id 
  5857                                  GetCntryDest:								 
  5858 00001A98 263805                  	cmp	[es:di],al					 
  5859 00001A9B 7413                    	je	short GetCntryDest_OK 					 
  5860 00001A9D 26803D01                	cmp	byte [es:di],SetCountryInfo ;was it SetCountryInfo entry?
  5861 00001AA1 7405                    	je	short GetCntryDest_1						 
  5862 00001AA3 83C705                  	add	di,5			;next data id			 
  5863 00001AA6 EB03                    	jmp	short GetCntryDest_loop 				 
  5864                                  GetCntryDest_1: 							 
  5865 00001AA8 83C729                  	add	di,NEW_COUNTRY_SIZE+3	;next data id			 
  5866                                  GetCntryDest_loop:							 
  5867 00001AAB E2EB                    	loop	GetCntryDest						 
  5868 00001AAD F9                      	stc								 
  5869 00001AAE EB0B                    	jmp	short GetCntryDest_Exit				 
  5870                                  GetCntryDest_OK:							 
  5871 00001AB0 3C01                    	cmp	al,SetCountryInfo	;select country info?		 
  5872 00001AB2 7503                    	jne	short GetCntryDest_OK1					 
  5873 00001AB4 47                      	inc	di			;now DI -> ccCountryInfoLen	 
  5874 00001AB5 EB04                    	jmp	short GetCntryDest_Exit				 
  5875                                  GetCntryDest_OK1:							 
  5876 00001AB7 26C47D01                	les	di,[es:di+1]		;get the destination in ES:DI	 
  5877                                  GetCntryDest_Exit:							 
  5878 00001ABB 59                      	pop	cx							 
  5879 00001ABC C3                      	retn								 
  5880                                  								 
  5881                                  ReadInControlBuffer:				 
  5882                                  ;Move file pointer to CX:DX						 
  5883                                  ;Read AX bytes into the control buffer. (Should be less than 2 Kb)	 
  5884                                  ;SI will be set to 0 hence DS:SI points to the control buffer.		 
  5885                                  ;Entry:  CX,DX offset from the start of the file where the read/write pointer
  5886                                  ;	 be moved.							 
  5887                                  ;	 AX - # of bytes to read					 
  5888                                  ;	 BX - file handle						 
  5889                                  ;	 DS - buffer seg.						 
  5890                                  ;Return: The control data information is read into DS:0 - DS:0200.	 
  5891                                  ;	 CX,DX value destroyed. 					 
  5892                                  ;	 Carry set if error in Reading file.				 
  5893                                  ;									 
  5894 00001ABD 50                      	push	ax			;# of bytes to read		 
  5895 00001ABE B80042                  	mov	ax, 4200h						 
  5896 00001AC1 F9                      	stc								 
  5897 00001AC2 CD21                    	int	21h			;move pointer			 
  5898 00001AC4 59                      	pop	cx			;# of bytes to read		 
  5899 00001AC5 7209                    	jc	short RICB_exit						 
  5900 00001AC7 31D2                    	xor	dx,dx			;ds:dx -> control buffer	 
  5901 00001AC9 31F6                    	xor	si,si							 
  5902 00001ACB B43F                    	mov	ah,3Fh			;read into the buffer		 
  5903 00001ACD F9                      	stc								 
  5904 00001ACE CD21                    	int	21h			;should be less than 1024 bytes. 
  5905                                  RICB_exit:								 
  5906 00001AD0 C3                      	retn								 
  5907                                  									 
  5908                                  SET_COUNTRY_PATH:					 
  5909                                  ;In:  DS - SYSINITSEG, ES - CONFBOT, SI -> start of the asciiz path string
  5910                                  ;     DOSINFO_EXT, CNTRY_DRV, CNTRY_ROOT, CNTRY_PATH			 
  5911                                  ;     Assumes current directory is the ROOT directory.			 
  5912                                  ;Out: DS:DI -> full path (CNTRY_DRV).					 
  5913                                  ;     Set the CNTRY_DRV string from the COUNTRY=,,path command. 	 
  5914                                  ;     DS, ES, SI value saved.						 
  5915                                  									 
  5916 00001AD1 56                      	push	si							 
  5917 00001AD2 1E                      	push	ds			;switch ds, es			 
  5918 00001AD3 06                      	push	es							 
  5919 00001AD4 1F                      	pop	ds							 
  5920 00001AD5 07                      	pop	es			;now DS -> CONFBOT, ES -> SYSINITSEG
  5921                                  									 
  5922 00001AD6 E82E00                  	call	CHK_DRIVE_LETTER	;current DS:[SI] is a drive letter? 
  5923 00001AD9 7206                    	jc	short SCP_Default_drv 	;no, use current default drive. 
  5924 00001ADB 8A04                    	mov	al,[SI]					 
  5925 00001ADD 46                      	inc	si							 
  5926 00001ADE 46                      	inc	si			;SI -> next char after ":"      
  5927 00001ADF EB06                    	jmp	short SCP_SetDrv					 
  5928                                  SCP_Default_drv:							 
  5929 00001AE1 B419                    	mov	ah,19h 						 
  5930 00001AE3 CD21                    	int	21h							 
  5931 00001AE5 0441                    	add	al,"A"			;convert it to a character.     
  5932                                  SCP_SetDrv:								 
  5933 00001AE7 2EA2[CF1B]              	mov	[cs:CNTRY_DRV],al	;set the drive letter.		 
  5934 00001AEB BF[D21B]                	mov	di,CNTRY_PATH					 
  5935 00001AEE 8A04                    	mov	al,[SI]	
  5936 00001AF0 3C5C                    	cmp	al, "\"                                                 
  5937 00001AF2 7406                    	je	short SCP_Root_Dir						 
  5938                                  	; 23/06/2018 - Retro DOS v3.0
  5939                                  	;cmp	al,[cs:SWTCHR]	!!!	;let's accept "/" as an directory delim
  5940 00001AF4 3C2F                    	cmp	al,SWTCHR 
  5941 00001AF6 7402                    	je	short SCP_Root_Dir						 
  5942 00001AF8 EB01                    	jmp	short SCP_Path						 
  5943                                  SCP_Root_Dir:								 
  5944 00001AFA 4F                      	dec	di			;DI -> CNTRY_ROOT		 
  5945                                  SCP_Path:								 
  5946 00001AFB E81F00                  	call	MOVE_ASCIIZ		;copy it			 
  5947 00001AFE BF[CF1B]                	mov	di,CNTRY_DRV					 
  5948                                  SCPath_Exit:								 
  5949 00001B01 1E                      	push	ds			;switch ds, es			 
  5950 00001B02 06                      	push	es							 
  5951 00001B03 1F                      	pop	ds							 
  5952 00001B04 07                      	pop	es			;DS, ES value restored		 
  5953 00001B05 5E                      	pop	si							 
  5954 00001B06 C3                      	RETN
  5955                                  								 
  5956                                  CHK_DRIVE_LETTER:				 
  5957                                  ;Check if DS:[SI] is a drive letter followed by ":".                    
  5958                                  ;Assume that every alpha charater is already converted to UPPER CASE.	 
  5959                                  ;Carry set if not.							 
  5960                                  ;									 
  5961 00001B07 50                      	push	ax							 
  5962 00001B08 803C41                  	cmp	byte [si], "A"                                   
  5963 00001B0B 720D                    	jb	short CDLetter_NO						 
  5964 00001B0D 803C5A                  	cmp	byte [si], "Z"                                   
  5965 00001B10 7708                    	ja	short CDLetter_NO						 
  5966 00001B12 807C013A                	cmp	byte [si+1], ":"                                 
  5967 00001B16 7502                    	jne	short CDLetter_NO						 
  5968 00001B18 EB01                    	jmp	short CDLetter_exit					 
  5969                                  CDLetter_NO:								 
  5970 00001B1A F9                      	stc								 
  5971                                  CDLetter_exit:								 
  5972 00001B1B 58                      	pop	ax							 
  5973 00001B1C C3                      	retn								 
  5974                                  									 
  5975                                  MOVE_ASCIIZ:				 
  5976                                  ;In: DS:SI -> source ES:DI -> target					 
  5977                                  ;Out: copy the string until 0.						 
  5978                                  ;Assumes there exists a 0.						 
  5979                                  MASCIIZ_loop:								 
  5980 00001B1D A4                      	movsb								 
  5981 00001B1E 807CFF00                	cmp	byte [SI-1], 0	;Was it 0?			 
  5982 00001B22 75F9                    	jne	short MASCIIZ_loop						 
  5983 00001B24 C3                      	retn
  5984                                  
  5985                                  ; 10/06/2018 - Retro DOS v3.0
  5986                                  								 
  5987                                  ;
  5988                                  ;	DS:DX POINTS TO STRING TO OUTPUT (ASCIZ)
  5989                                  ;
  5990                                  ;	PRINTS <BADLD_PRE> <STRING> <BADLD_POST>
  5991                                  ;
  5992                                  
  5993                                  BADFIL:
  5994 00001B25 0E                              PUSH    CS
  5995 00001B26 07                              POP     ES
  5996 00001B27 89D6                            MOV     SI,DX
  5997                                  BADLOAD:
  5998 00001B29 BA[A21D]                        MOV     DX,BADLD_PRE		; WANT TO PRINT CONFIG ERROR
  5999                                          ;MOV	BX,BADLD_POST
  6000                                  PRNERR:
  6001 00001B2C 0E                              PUSH    CS
  6002 00001B2D 1F                              POP     DS
  6003 00001B2E B409                            MOV     AH,STD_CON_STRING_OUTPUT
  6004 00001B30 CD21                            INT     21H
  6005                                  PRN1:   
  6006 00001B32 268A14                  	MOV     DL,[ES:SI]
  6007 00001B35 08D2                            OR      DL,DL
  6008 00001B37 7407                            JZ      SHORT PRN2
  6009 00001B39 B402                            MOV     AH,STD_CON_OUTPUT
  6010 00001B3B CD21                            INT     21H
  6011 00001B3D 46                              INC     SI
  6012 00001B3E EBF2                            JMP     SHORT PRN1
  6013                                  PRN2:   
  6014                                  	;MOV	DX,BX
  6015 00001B40 BA[7E1D]                	MOV	DX,BADLD_POST ; 10/04/2018
  6016                                  PRINT:  
  6017 00001B43 B409                    	MOV     AH,STD_CON_STRING_OUTPUT
  6018 00001B45 CD21                            INT     21H
  6019 00001B47 C3                              RETN
  6020                                  
  6021                                  	;IF	NOEXEC  ; (NOEXEC = FALSE)
  6022                                  ;;
  6023                                  ;; LOAD FILE CALLED [DS:DX] AT MEMORY LOCATION ES:BX
  6024                                  ;;
  6025                                  ;LDFIL:
  6026                                  ;	PUSH    AX
  6027                                  ;	PUSH    BX
  6028                                  ;	PUSH    CX
  6029                                  ;	PUSH    DX
  6030                                  ;	PUSH    SI
  6031                                  ;	PUSH    DS
  6032                                  ;	PUSH    BX
  6033                                  ;
  6034                                  ;	XOR     AX,AX                   ; OPEN THE FILE
  6035                                  ;	MOV     AH,OPEN
  6036                                  ;	STC                             ; IN CASE OF INT 24
  6037                                  ;	INT     21H
  6038                                  ;	POP     DX                      ; Trans addr is DS:DX
  6039                                  ;	JC      SHORT LDRET
  6040                                  ;
  6041                                  ;	; 10/06/2018
  6042                                  ;	PUSH	DX
  6043                                  ;	MOV     BX,AX                   ; Handle in BX
  6044                                  ;	XOR	CX,CX
  6045                                  ;	XOR	DX,DX
  6046                                  ;	MOV	AX,(LSEEK*256)+2
  6047                                  ;	STC				;IN CASE OF INT 24
  6048                                  ;	INT	21H			; Get file size in DX:AX
  6049                                  ;	JC	short LDCLSP
  6050                                  ;	POP	DX
  6051                                  ;	PUSH	DX
  6052                                  ;	MOV	CX,ES			; CX:DX is xaddr
  6053                                  ;	ADD	DX,AX			; Add file size to Xaddr
  6054                                  ;	JNC	short DOSIZE
  6055                                  ;	ADD	CX,1000H		; ripple carry
  6056                                  ;DOSIZE:
  6057                                  ;	mov	ax,dx
  6058                                  ;	call	ParaRound
  6059                                  ;	mov	dx,ax
  6060                                  ;
  6061                                  ;	ADD	CX,DX
  6062                                  ;	CMP	CX,[ALLOCLIM]
  6063                                  ;	JB	short OKLD
  6064                                  ;	JMP	short MEM_ERR
  6065                                  ;
  6066                                  ;OKLD:
  6067                                  ;	XOR	CX,CX
  6068                                  ;	XOR	DX,DX
  6069                                  ;	MOV	AX,LSEEK SHL 8		;Reset pointer to beginning of file
  6070                                  ;	STC				;IN CASE OF INT 24
  6071                                  ;	INT	21H
  6072                                  ;	JC	LDCLSP
  6073                                  ;	POP	DX
  6074                                  ;	PUSH	ES			;READ THE FILE IN
  6075                                  ;	POP	DS			;Trans addr is DS:DX
  6076                                  ;	MOV	CX,0FF00H		; .COM files arn't any bigger than
  6077                                  ;					; 64k-100H
  6078                                  ;	MOV	AH,READ
  6079                                  ;	STC				;IN CASE OF INT 24
  6080                                  ;	INT	21H
  6081                                  ;	JC	short LDCLS
  6082                                  ;	MOV	SI,DX			;CHECK FOR EXE FILE
  6083                                  ;	CMP	WORD [SI],"MZ"
  6084                                  ;	CLC				; Assume OK
  6085                                  ;	JNZ	short LDCLS		; Only know how to do .COM files
  6086                                  ;	STC
  6087                                  ;	JMP	SHORT LDCLS
  6088                                  ;
  6089                                  ;LDERRP:  
  6090                                  ;	STC
  6091                                  ;LDCLSP:
  6092                                  ;	POP	DX
  6093                                  ;LDCLS:  
  6094                                  ;	PUSHF
  6095                                  ;	MOV     AH,CLOSE                ; CLOSE THE FILE
  6096                                  ;       STC
  6097                                  ;       INT     21H
  6098                                  ;	POPF
  6099                                  ;
  6100                                  ;LDRET:  
  6101                                  ;	POP     DS
  6102                                  ;	POP     SI
  6103                                  ;	POP     DX
  6104                                  ;	POP     CX
  6105                                  ;	POP     BX
  6106                                  ;	POP     AX
  6107                                  ;	RETN
  6108                                  
  6109                                  	;ENDIF
  6110                                  ;
  6111                                  ;  OPEN DEVICE POINTED TO BY DX, AL HAS ACCESS CODE
  6112                                  ;   IF UNABLE TO OPEN DO A DEVICE OPEN NULL DEVICE INSTEAD
  6113                                  ;
  6114                                  OPEN_DEV:
  6115 00001B48 E81C00                          CALL    OPEN_FILE
  6116 00001B4B 7307                            JNC     SHORT OPEN_DEV3
  6117                                  OPEN_DEV1:
  6118 00001B4D BA[B31B]                        MOV     DX,NULDEV
  6119 00001B50 E81400                          CALL    OPEN_FILE
  6120                                  OPEN_DEV2:
  6121 00001B53 C3                              RETN
  6122                                  OPEN_DEV3:
  6123                                  	; 05/07/2018
  6124 00001B54 89C3                    	MOV	BX,AX			; Handle from open to BX
  6125 00001B56 31C0                            XOR     AX,AX                   ; GET DEVICE INFO
  6126 00001B58 B444                            MOV     AH,IOCTL
  6127 00001B5A CD21                            INT     21H
  6128 00001B5C F6C280                          TEST    DL,10000000B
  6129 00001B5F 75F2                            JNZ     SHORT OPEN_DEV2
  6130 00001B61 B43E                            MOV     AH,CLOSE
  6131 00001B63 CD21                            INT     21H
  6132 00001B65 EBE6                            JMP     SHORT OPEN_DEV1
  6133                                  
  6134                                  OPEN_FILE:
  6135 00001B67 B43D                            MOV     AH,OPEN
  6136 00001B69 F9                              STC
  6137 00001B6A CD21                            INT     21H
  6138 00001B6C C3                              RETN
  6139                                  
  6140                                  INT24:  
  6141 00001B6D 83C406                  	ADD     SP,6                    ; RESTORE MACHINE STATE
  6142 00001B70 58                              POP     AX
  6143 00001B71 5B                              POP     BX
  6144 00001B72 59                              POP     CX
  6145 00001B73 5A                              POP     DX
  6146 00001B74 5E                              POP     SI
  6147 00001B75 5F                              POP     DI
  6148 00001B76 5D                              POP     BP
  6149 00001B77 1F                              POP     DS
  6150 00001B78 07                              POP     ES
  6151 00001B79 50                              PUSH    AX
  6152 00001B7A B419                            MOV     AH,GET_DEFAULT_DRIVE    ; INITIALIZE DOS
  6153 00001B7C CD21                            INT     21H
  6154 00001B7E 58                              POP     AX
  6155 00001B7F CF                              IRET                            ; BACK TO USER
  6156                                  
  6157                                          ;IF	ALTVECT
  6158                                  BOOTMES:
  6159 00001B80 0D                      	DB	13
  6160 00001B81 0A                      TEN:	DB	10
  6161                                  	; 22/11/2022
  6162                                  	;DB	"MS-DOS version "
  6163                                  	;DB	MAJOR_VERSION + "0"
  6164                                  	;DB	"."
  6165                                  	;DB	(MINOR_VERSION / 10) + "0"
  6166                                  	;DB	(MINOR_VERSION % 10) + "0"
  6167                                  	;DB	13,10
  6168                                  	;;DB	"Copyright 1981,82 Microsoft Corp.",13,10,"$"
  6169                                  	;; 27/06/2018
  6170                                  	;DB	"Copyright 1981,87 Microsoft Corp.",13,10,"$"
  6171                                  	;ENDIF
  6172                                  	; 22/11/2022
  6173 00001B82 526574726F20444F53-     	db 	"Retro DOS v3.0"
  6173 00001B8B 2076332E30         
  6174 00001B90 2028323031382D3230-     	db	" (2018-2022) "
  6174 00001B99 32322920           
  6175 00001B9D 0D0A                    	db	13,10
  6176 00001B9F 6279204572646F6761-     	db	"by Erdogan Tan "
  6176 00001BA8 6E2054616E20       
  6177 00001BAE 0D0A                    	db	13,10
  6178 00001BB0 0D0A24                  	db	13,10,"$"	
  6179                                  
  6180                                  	; 10/06/2018 - Retro DOS v3.0
  6181                                  NULDEV: 
  6182 00001BB3 4E554C00                	DB      "NUL",0
  6183                                  CONDEV: 
  6184 00001BB7 434F4E00                	DB      "CON",0
  6185                                  AUXDEV: 
  6186 00001BBB 41555800                	DB      "AUX",0
  6187                                  PRNDEV: 
  6188 00001BBF 50524E00                	DB      "PRN",0
  6189                                  
  6190                                  CONFIG:
  6191 00001BC3 5C434F4E4649472E53-     	DB      "\CONFIG.SYS",0
  6191 00001BCC 595300             
  6192                                  
  6193                                  CNTRY_DRV:
  6194 00001BCF 413A                    	DB	"A:"
  6195                                  CNTRY_ROOT:
  6196 00001BD1 5C                      	DB	"\"
  6197                                  CNTRY_PATH:
  6198 00001BD2 434F554E5452592E53-     	DB	"COUNTRY.SYS",0
  6198 00001BDB 595300             
  6199 00001BDE 00<rep 34h>             	times	52 db 0
  6200                                  
  6201                                  COUNTRY_FILE_SIGNATURE:
  6202 00001C12 FF434F554E545259        	db	0FFh,'COUNTRY' 	 
  6203                                  
  6204                                  CntryCodePage_Id:
  6205 00001C1A 0000                    	DW	0	
  6206                                  
  6207                                  COMMND:
  6208 00001C1C 5C434F4D4D414E442E-     	DB      "\COMMAND.COM",0
  6208 00001C25 434F4D00           
  6209 00001C29 00<rep 14h>             	times	20 db 0
  6210                                  
  6211                                  COMTAB:
  6212                                          ;DB	8,"AVAILDEV",'A'	; NO LONGER SUPPORTED
  6213 00001C3D 074255464645525342      	DB	7,"BUFFERS",  'B'
  6214 00001C46 05425245414B43          	DB	5,"BREAK",    'C'
  6215 00001C4D 0644455649434544        	DB	6,"DEVICE",   'D'
  6216 00001C55 0546494C455346          	DB	5,"FILES",    'F'
  6217 00001C5C 044643425358            	DB	4,"FCBS",     'X'
  6218 00001C62 094C41535444524956-     	DB	9,"LASTDRIVE",'L'
  6218 00001C6B 454C               
  6219 00001C6D 08445249565041524D-     	DB	8,"DRIVPARM", 'P'       ; RS for DOS 3.2
  6219 00001C76 50                 
  6220                                  		;IF	STACKSW					; 3.30
  6221 00001C77 06535441434B534B        	DB	6,"STACKS",   'K'       ; BAS for DOS 3.2	; 3.30
  6222                                  		;ENDIF						; 3.30
  6223 00001C7F 07434F554E54525951      	DB	7,"COUNTRY",  'Q'
  6224 00001C88 055348454C4C53          	DB	5,"SHELL",    'S'
  6225                                  	;DB	8,"SWITCHAR",'W'	; NO LONGER SUPPORTED
  6226                                  
  6227 00001C8F 00                              DB      0
  6228                                  
  6229                                  DEVICEPARAMETERS:  ; STRUC A_DEVICEPARAMETERS
  6230                                  ;DeviceParameters a_DeviceParameters <0,DEV_3INCH720KB,0,80>
  6231 00001C90 00                      DEVP.SPECIALFUNC:	DB 0
  6232 00001C91 02                      DEVP.DEVICETYPE:	DB DEV_3INCH720KB
  6233 00001C92 0000                    DEVP.ATTRIBUTES:	DW 0
  6234 00001C94 5000                    DEVP.CYLINDERS:		DW 80
  6235 00001C96 00                      DEVP.MEDIATYPE:		DB 0
  6236 00001C97 00<rep 1Fh>             DEVP.DP_BPB:		TIMES A_BPB.size DB 0
  6237 00001CB6 0000                    DEVP.TRACKTBLENTS:	DW 0
  6238 00001CB8 FC                      DEVP.SECTORTABLE:	DB MAX_SECTORS_IN_TRACK * A_SECTORTABLE.size
  6239                                  
  6240 00001CB9 0200                    HLIM: DW 2
  6241 00001CBB 0900                    SLIM: DW 9
  6242                                  
  6243 00001CBD 00                      DRIVE: DB 0
  6244 00001CBE 0000                    SWITCHES: DW 0
  6245                                  
  6246                                  ; 06/07/2018
  6247                                  
  6248                                  ;-----------------------------------------------------------------------------
  6249                                  ; BOOT DISK PARAMETERS
  6250                                  ;-----------------------------------------------------------------------------
  6251                                  ; 02/06/2018 - Retro DOS v3.0
  6252                                  ; 07/04/2018 - Retro DOS V2.0
  6253                                  
  6254                                  ;BOOT_DRV_PARMS:
  6255                                  ;		; 1.44MB
  6256                                  ;		dw 512
  6257                                  ;               db 1
  6258                                  ;               dw 1	
  6259                                  ;               db 2
  6260                                  ;               dw 224
  6261                                  ;		dw 2880
  6262                                  ;		; Retro DOS v1.0 - 10/02/2018
  6263                                  ;		db 0F0h		; Media descriptor
  6264                                  ;		dw 9		; FAT size in sectors
  6265                                  ;		dw 18		; Sectors per track
  6266                                  ;		dw 2		; Number of heads
  6267                                  ;		; 02/06/2018 - Retro DOS v3.0
  6268                                  ;		;dw 0		
  6269                                  ;		dd 0		; Hidden sectors
  6270                                  ;		dd 0		; Big total sectors		
  6271                                  ;
  6272                                  ;; Note: These (fd&hd) parameters table sizes are  
  6273                                  ;;						 31 bytes for MSDOS 3.3		
  6274                                  ;;						 19 bytes for MSDOS 2.11
  6275                                  
  6276                                  ;-----------------------------------------------------------------------------
  6277                                  ; FLOPPY DISK PARAMETERS
  6278                                  ;-----------------------------------------------------------------------------
  6279                                  ; 02/06/2018 - Retro DOS v3.0
  6280                                  ; 07/04/2018 - Retro DOS V2.0
  6281                                  
  6282                                  
  6283                                  ; 02/06/2018 - Retro DOS v3.0 - 25 bytes of DOS disk paramaters
  6284                                  
  6285                                  
  6286                                  ;
  6287                                  ; The following are the recommended BPBs for the media that we know of so
  6288                                  ; far.
  6289                                  
  6290                                  ; 48 tpi diskettes
  6291                                  	;EVENB
  6292                                  ;align 2
  6293                                  ;BPB48T:
  6294                                  ;	DW	512
  6295                                  ;	DB	2
  6296                                  ;	DW	1
  6297                                  ;	DB	2
  6298                                  ;	DW	112
  6299                                  ;	DW	2*9*40
  6300                                  ;	DB	0FDH
  6301                                  ;	DW	2
  6302                                  ;	DW	9
  6303                                  ;	DW	2
  6304                                  ;	DD	0		;hidden sectors - sp
  6305                                  ;	DD	0		;big total sectors - sp
  6306                                  ;	;DB	6 DUP(?)	;reserved
  6307                                  ;	;times	6 db 0
  6308                                  
  6309                                  ; 96tpi diskettes
  6310                                  	;EVENB
  6311                                  ;align 2
  6312                                  ;BPB96T:	
  6313                                  ;	DW	512
  6314                                  ;	DB	1
  6315                                  ;	DW	1
  6316                                  ;	DB	2
  6317                                  ;	DW	224
  6318                                  ;	DW	2*15*80
  6319                                  ;	DB	0f9H
  6320                                  ;	DW	7
  6321                                  ;	DW	15
  6322                                  ;	DW	2
  6323                                  ;	DD	0		;hidden sectors - sp
  6324                                  ;	DD	0		;big total sectors - sp
  6325                                  ;	;DB	6 DUP(?)	;reserved
  6326                                  ;	;times	6 db 0
  6327                                  
  6328                                  ;BPBSIZ	equ	$-BPB96T
  6329                                  BPBSIZ	equ	25  ; 02/06/2018
  6330                                  
  6331                                  
  6332                                  ; 3 1/2 inch diskette BPB
  6333                                  	;EVENB
  6334                                  ;align 2
  6335                                  ;BPB35:	
  6336                                  ;	DW	512
  6337                                  ;	DB	2
  6338                                  ;	DW	1		; Double sided with 9 sec/trk
  6339                                  ;	DB	2
  6340                                  ;	DW	70h
  6341                                  ;	DW	2*9*80
  6342                                  ;	DB	0f9H
  6343                                  ;	DW	3
  6344                                  ;	DW	9
  6345                                  ;	DW	2
  6346                                  ;	DD	0		;hidden sectors - sp
  6347                                  ;	DD	0		;big total sectors - sp
  6348                                  ;	;DB	6 DUP(?)	;reserved
  6349                                  ;	;times	6 db 0
  6350                                  
  6351                                  	;EVENB
  6352                                  align 2
  6353                                  		; Retro DOS v3.0 - 25 bytes disk parameters (02/06/2018)
  6354                                  		; Retro DOS v2.0 - 19 bytes disk parameters (07/04/2018)
  6355                                  _FD_parameters:
  6356                                  		; Retro DOS v1.0 - 10/02/2018
  6357                                  		; 17 bytes of DOS disk parameters
  6358                                  
  6359                                  ; 48 tpi diskettes
  6360                                  BPB48T: 	; 02/06/2018 - Retro DOS v3.0
  6361                                  _360K_parameters:
  6362                                  		; 360KB
  6363 00001CC0 0002                    		dw 512		; Sector size in bytes.
  6364 00001CC2 02                      		db 2		; Sector per allocation unit.
  6365 00001CC3 0100                    		dw 1		; Reserved sectors.
  6366 00001CC5 02                      		db 2		; Number of allocation tables.
  6367 00001CC6 7000                    		dw 112		; Number of directory entrys.
  6368 00001CC8 D002                    		dw 720		; Number of sectors on the disk.
  6369                                  		; Retro Dos v1.0 - 10/02/2018
  6370 00001CCA FD                      		db 0FDh		; Media descriptor
  6371 00001CCB 0200                    		dw 2		; FAT size in sectors
  6372 00001CCD 0900                    		dw 9		; Sectors per track
  6373 00001CCF 0200                    		dw 2		; Number of heads
  6374                                  		; Retro DOS v2.0 - 07/04/2018
  6375                                  		;dw 0		; Hidden sectors
  6376                                  		; Retro DOS v3.0 - 02/06/2018
  6377 00001CD1 00000000                		dd 0		; Hidden sectors
  6378 00001CD5 00000000                		dd 0		; Big Total sectors
  6379                                  ; 96tpi diskettes
  6380                                  BPB96T:		; 02/06/2018 - Retro DOS v3.0
  6381                                  _1200K_parameters:
  6382                                  		; 1.2MB
  6383 00001CD9 0002                    		dw 512
  6384 00001CDB 01                                      db 1
  6385 00001CDC 0100                                    dw 1	
  6386 00001CDE 02                                      db 2
  6387 00001CDF E000                                    dw 224
  6388 00001CE1 6009                    		dw 2400
  6389                                  		; Retro DOS v1.0 - 10/02/2018
  6390 00001CE3 F9                      		db 0F9h		; Media Descriptor
  6391 00001CE4 0700                    		dw 7		; FAT size in sectors
  6392 00001CE6 0F00                    		dw 15		; Sectors per track
  6393 00001CE8 0200                    		dw 2		; Number of heads
  6394                                  		; Retro DOS v2.0 - 07/04/2018
  6395                                  		;dw 0		; Hidden sectors
  6396                                  		; Retro DOS v3.0 - 02/06/2018
  6397 00001CEA 00000000                		dd 0		; Hidden sectors
  6398 00001CEE 00000000                		dd 0		; Big Total sectors
  6399                                  ; 3 1/2 inch diskette bpb
  6400                                  BPB35:		; 02/06/2018 - Retro DOS v3.0	
  6401                                  _720K_paramaters:
  6402                                  		; 720KB
  6403 00001CF2 0002                    		dw 512		; Sector size in bytes.
  6404 00001CF4 02                      		db 2		; Sector per allocation unit.
  6405 00001CF5 0100                    		dw 1		; Reserved sectors.
  6406 00001CF7 02                      		db 2		; Number of allocation tables.
  6407 00001CF8 7000                    		dw 112		; Number of directory entrys.
  6408 00001CFA A005                    		dw 1440		; Number of sectors on the disk.
  6409                                  		; Retro DOS v1.0 - 10/02/2018
  6410 00001CFC F9                      		db 0F9h		; Media descriptor
  6411 00001CFD 0300                    		dw 3		; FAT size in sectors
  6412 00001CFF 0900                    		dw 9		; Sectors per track
  6413 00001D01 0200                    		dw 2		; Number of heads
  6414                                  		; Retro DOS v2.0 - 07/04/2018
  6415                                  		;dw 0
  6416                                  		; Retro DOS v3.0 - 02/06/2018
  6417 00001D03 00000000                		dd 0		; Hidden sectors
  6418 00001D07 00000000                		dd 0		; Big Total sectors
  6419                                  BPB35H:		; 03/06/2018 - Retro DOS v3.0 (MSDOS 6.0, SYSINIT2.ASM, 1991)		
  6420                                  _1440K_parameters:
  6421                                  		; 1.44MB
  6422 00001D0B 0002                    		dw 512
  6423 00001D0D 01                                      db 1
  6424 00001D0E 0100                                    dw 1	
  6425 00001D10 02                                      db 2
  6426 00001D11 E000                                    dw 224
  6427 00001D13 400B                    		dw 2880
  6428                                  		; Retro DOS v1.0 - 10/02/2018
  6429 00001D15 F0                      		db 0F0h		; Media descriptor
  6430 00001D16 0900                    		dw 9		; FAT size in sectors
  6431 00001D18 1200                    		dw 18		; Sectors per track
  6432 00001D1A 0200                    		dw 2		; Number of heads
  6433                                  		; Retro DOS v2.0 - 07/04/2018
  6434                                  		;dw 0
  6435                                  		; Retro DOS v3.0 - 02/06/2018
  6436 00001D1C 00000000                		dd 0		; Hidden sectors
  6437 00001D20 00000000                		dd 0		; Big Total sectors
  6438                                  BPB288:		; 03/06/2018 - Retro DOS v3.0 (MSDOS 6.0, SYSINIT2.ASM, 1991)
  6439                                  _2880K_parameters:
  6440                                  		; 2.88MB
  6441 00001D24 0002                    		dw 512
  6442 00001D26 02                                      db 2
  6443 00001D27 0100                                    dw 1	
  6444 00001D29 02                                      db 2
  6445 00001D2A F000                                    dw 240
  6446 00001D2C 8016                    		dw 5760
  6447                                  		; Retro DOS v1.0 - 10/02/2018
  6448 00001D2E F0                      		db 0F0h		; Media descriptor
  6449 00001D2F 0900                    		dw 9		; FAT size in sectors
  6450 00001D31 2400                    		dw 36		; Sectors per track
  6451 00001D33 0200                    		dw 2		; Number of heads
  6452                                  		; Retro DOS v2.0 - 07/04/2018
  6453                                  		;dw 0
  6454                                  		; Retro DOS v3.0 - 02/06/2018
  6455 00001D35 00000000                		dd 0		; Hidden sectors
  6456 00001D39 00000000                		dd 0		; Big Total sectors
  6457                                  
  6458                                  ; 06/07/2018
  6459                                  
  6460 00001D3D 90                      align 2
  6461                                  
  6462                                  BPBTable:
  6463                                  	; Retro DOS v3.0 - 03/06/2018  (MSDOS 6.0, SYSINIT2.ASM, 1991)
  6464 00001D3E [C01C]                  		dw	BPB48T	; 48tpi drives
  6465 00001D40 [D91C]                  		dw	BPB96T	; 96tpi drives
  6466 00001D42 [F21C]                  		dw	BPB35	; 3.5" drives
  6467                                  ; the following are not supported, so default to 3.5" media layout
  6468 00001D44 [F21C]                  		dw	BPB35	; not used - 8" drives
  6469 00001D46 [F21C]                  		dw	BPB35	; not used - 8" drives
  6470 00001D48 [F21C]                  		dw	BPB35	; not used - hard files
  6471 00001D4A [F21C]                  		dw	BPB35	; not used - tape drives
  6472 00001D4C [0B1D]                  		dw	BPB35H	; 3 1/2" 1.44mb drive
  6473 00001D4E [F21C]                  		dw	BPB35	; ERIMO
  6474 00001D50 [241D]                  		dw	BPB288	; 2.88 MB diskette drives
  6475                                  		;dw	BPB35H	; 3 1/2" 1.44mb drive
  6476                                  
  6477                                  END_OF_FDP_TBLS:
  6478                                  
  6479                                  ; ----------------------------------------------------------------------------
  6480                                  
  6481                                  ; 10/06/2018
  6482                                  
  6483                                  switchlist:
  6484 00001D52 074648535444434E        	 db	7,"FHSTDCN"         ; Preserve the positions of N and C.
  6485                                  
  6486                                  ; The following depend on the positions of the various letters in SwitchList
  6487                                  
  6488                                  flagdrive   equ     0004H
  6489                                  flagcyln    equ     0008H
  6490                                  flagseclim  equ     0010H
  6491                                  flagheads   equ     0020H
  6492                                  flagff	    equ     0040H
  6493                                  
  6494                                  SWTCHR	EQU "/"	
  6495                                  
  6496                                  ;SYSINITSEG      ENDS
  6497                                  ;       END
  6498                                  
  6499                                  ; ----------------------------------------------------------------------------
  6500                                  ; SYSIMES.ASM, 22/09/1983, -- SYSIMES.INC, 24/07/1987 (MSDOS 3.3) --
  6501                                  ; ----------------------------------------------------------------------------
  6502                                  
  6503                                  ;SYSINITSEG      SEGMENT PUBLIC BYTE 'SYSTEM_INIT'
  6504                                  
  6505                                          ;PUBLIC  BADOPM,CRLFM,BADSIZ,BADLD,BADCOM,SYSSIZE
  6506                                  
  6507                                  BADOPM: 
  6508 00001D5A 0D0A556E7265636F67-     	DB      13,10,"Unrecognized command in CONFIG.SYS"
  6508 00001D63 6E697A656420636F6D-
  6508 00001D6C 6D616E6420696E2043-
  6508 00001D75 4F4E4649472E535953 
  6509                                  BADSIZ_POST:
  6510                                  BADLD_POST:
  6511 00001D7E 0D0A24                  CRLFM:  DB      13,10,'$'
  6512                                  
  6513                                  ;
  6514                                  ;PRINTED when installed device specifies too large a sector size.'$' terminated.
  6515                                  ; FORM: 	<BADSIZ_PRE>device name<BADSIZ_POST>
  6516                                  ;
  6517                                  
  6518                                  BADSIZ_PRE:
  6519 00001D81 0D0A536563746F7220-     	DB      13,10,"Sector size too large in file $"
  6519 00001D8A 73697A6520746F6F20-
  6519 00001D93 6C6172676520696E20-
  6519 00001D9C 66696C652024       
  6520                                  
  6521                                  ;
  6522                                  ;PRINTED when installed device cannot be found. '$' terminated.
  6523                                  ; FORM: 	<BADLD_PRE>device name<BADLD_POST>
  6524                                  ;
  6525                                  
  6526                                  BADLD_PRE:
  6527 00001DA2 0D0A426164206F7220-     	DB      13,10,"Bad or missing $"
  6527 00001DAB 6D697373696E672024 
  6528                                  
  6529                                  ;
  6530                                  ;PRINTED when command interpreter is not found. NUL terminated.
  6531                                  ; FORM: 	<BADLD_PRE><BADCOM><BADLD_POST>
  6532                                  ;
  6533                                  
  6534 00001DB4 436F6D6D616E642049-     BADCOM: DB      "Command Interpreter",0
  6534 00001DBD 6E7465727072657465-
  6534 00001DC6 7200               
  6535                                  
  6536                                  ;PRINTED when country code, code page combination was not found ;3.30
  6537                                  ;  in country.sys file. '$' terminated.				;3.30
  6538                                  ; FORM: 	<BADCOUNTRY>					; 3.30		
  6539                                  
  6540                                  BADCOUNTRY:
  6541 00001DC8 0D0A496E76616C6964-     	DB	13,10,"Invalid country code or code page",13,10,"$" ; 3.30
  6541 00001DD1 20636F756E74727920-
  6541 00001DDA 636F6465206F722063-
  6541 00001DE3 6F646520706167650D-
  6541 00001DEC 0A24               
  6542                                  
  6543                                  ; 10/06/2018
  6544                                  
  6545                                  ;PRINTED when code page id is missing or wrong syntax. - J.K.	;3.30
  6546                                  ; FORM: 	<BADCOUNTRYCOM> 				;3.30
  6547                                  BADCOUNTRYCOM:
  6548 00001DEE 0D0A4572726F722069-     	DB	13,10,"Error in COUNTRY command",13,10,"$"	;3.30
  6548 00001DF7 6E20434F554E545259-
  6548 00001E00 20636F6D6D616E640D-
  6548 00001E09 0A24               
  6549                                  
  6550                                  ;PRINTED when the memory left is not sufficient to handle COUTRY.SYS file ;3.30
  6551                                  ; FORM: 	<INSUFMEMORY>						  ;3.30
  6552                                  INSUFMEMORY:
  6553 00001E0B 0D0A496E7375666669-     	DB	13,10,"Insufficient memory for COUNTRY.SYS file",13,10,"$" ;3.30
  6553 00001E14 6369656E74206D656D-
  6553 00001E1D 6F727920666F722043-
  6553 00001E26 4F554E5452592E5359-
  6553 00001E2F 532066696C650D0A24 
  6554                                  
  6555                                  ; PRINTED when there is insufficient memory. '$' TERMINATED, note
  6556                                  ;   that this message includes crlfm!
  6557                                  ;
  6558                                  BADMEM:
  6559 00001E38 0D0A436F6E66696775-     	DB	13,10,"Configuration too large for memory",13,10,"$"
  6559 00001E41 726174696F6E20746F-
  6559 00001E4A 6F206C617267652066-
  6559 00001E53 6F72206D656D6F7279-
  6559 00001E5C 0D0A24             
  6560                                  
  6561                                  ; 26/03/2018
  6562                                  ; PRINTED when the attempt is made to install a block device which would
  6563                                  ;   have a drive letter > 'Z'
  6564                                  ;
  6565                                  
  6566                                  BADBLOCK:
  6567 00001E5F 0D0A546F6F206D616E-     	DB	13,10,"Too many Block Devices",13,10,"$"
  6567 00001E68 7920426C6F636B2044-
  6567 00001E71 6576696365730D0A24 
  6568                                  
  6569                                  ; 10/06/2018
  6570                                  ; PRINTED when the attempt is made to install a stack with invalid	;3.30
  6571                                  ;   combinations of # of stacks, stack size.	- J.K. 5/23/86		;3.30
  6572                                  BADSTACK:
  6573 00001E7A 0D0A496E76616C6964-     	DB	13,10,"Invalid STACK parameters",13,10,"$" 		;3.30
  6573 00001E83 20535441434B207061-
  6573 00001E8C 72616D65746572730D-
  6573 00001E95 0A24               
  6574                                  
  6575                                  ;SYSSIZE LABEL   BYTE
  6576                                  
  6577                                  ;SYSINITSEG      ENDS
  6578                                  ;       END
