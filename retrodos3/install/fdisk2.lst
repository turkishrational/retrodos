     1                                  ; ****************************************************************************
     2                                  ; FDISK2.ASM (FDISK2.COM) //// MSDOS 5.0-6.22 Hard Disk Partitioning Utility
     3                                  ; 	     by Erdogan Tan				  (for MSDOS/WINDOWS)
     4                                  ; ****************************************************************************
     5                                  ; Last Update: 28/01/2019
     6                                  ; ----------------------------------------------------------------------------
     7                                  ; Beginning: 06/11/2018
     8                                  ; ----------------------------------------------------------------------------
     9                                  ; Assembler: NASM version 2.11
    10                                  ; ----------------------------------------------------------------------------
    11                                  ; Source Code Reference: MSDOS 6.0 FDISK.EXE source code (in C language).
    12                                  ; ----------------------------------------------------------------------------
    13                                  ; This FDISK (Version 2) source code has been written by using disassembled
    14                                  ;      FDISK.COM source code of IBM PC-DOS 7.0 (1996).
    15                                  ; ****************************************************************************
    16                                  ; nasm fdisk2.s -l fdisk2.txt -o FDISK2.COM
    17                                  ; ============================================================================
    18                                  ;
    19                                  ; ... Retro DOS v3.0 (and Retro DOS v4.0) FDISK utility ... by Erdogan Tan ...
    20                                  
    21                                  ; ---------------------------------------------------------------------------
    22                                  ; -	This file is generated by The Interactive Disassembler (IDA)	    -
    23                                  ; -	Copyright (c) 2010 by Hex-Rays SA, <support@hex-rays.com>	    -
    24                                  ; -			 Licensed to: Freeware version			    -
    25                                  ; ---------------------------------------------------------------------------
    26                                  ;
    27                                  ; Input	MD5   :	60ADAF7E26AAC0C3FD48E6F4E2774E73
    28                                  
    29                                  ; File Name   :	D:\Documents and Settings\Erdoðan Tan\Desktop\FDISK70.COM
    30                                  ; Format      :	MS-DOS executable (EXE)
    31                                  ; Base Address:	0h Range: 0h-11CE0h Loaded length: E210h
    32                                  ; Entry	Point :	0:6CAA
    33                                  
    34                                  ; Input	MD5   :	B4080FCD526BEB3060C00FCC3FF4E9CC
    35                                  
    36                                  ; File Name   :	D:\Documents and Settings\Erdoðan Tan\Desktop\FDISK.COM
    37                                  ; Format      :	MS-DOS COM-file
    38                                  ; Base Address:	0h Range: 100h-1702h Loaded length: 1602h
    39                                  
    40                                  ; ============================================================================
    41                                  
    42                                  ; (IBM PC-DOS) FDISK.COM (1996) has been unpacked by using UNP.EXE (1997)
    43                                  ; (unpacking program); then, FDISK70.COM (EXE file) has been disassembled
    44                                  ; by using IDA Pro Free (2010) program.
    45                                  
    46                                  ; ============================================================================
    47                                  
    48                                  	[BITS 16]
    49                                  	[ORG 100h]
    50                                  
    51                                  start:
    52 00000000 EB2D                    	jmp	short _astart
    53                                  
    54 00000002 E207                    	dw	2018
    55 00000004 A101                    	dw	01A1h
    56                                  
    57 00000006 00                      	db	0
    58                                  ; ----------------------------------------------------------------------------
    59                                  
    60                                  ;db '<R>                           PC DOS Version 7.0 '
    61                                  ;db 6,'0104',6
    62                                  ;db '<R>                         Fixed Disk Setup Program '
    63                                  ;db 6,'0104',6
    64                                  ;db '<R>                Copyright (c) IBM Corporation 1983 - 1994',0
    65                                  
    66                                  ; ----------------------------------------------------------------------------
    67                                  
    68                                  ;MBR_ADDR:	dw	MBR
    69 00000007 [18D0]                  buffer:		dw	end_of_file+2
    70                                  
    71                                  current_partition:
    72 00000009 00                      p_status:	db	0
    73 0000000A 00                      start_head:	db	0
    74 0000000B 0000                    start_cyl_sec:	dw	0
    75 0000000D 00                      partition_type:	db	0
    76 0000000E 00                      end_head:	db	0
    77 0000000F 0000                    end_cyl_sec:	dw	0
    78 00000011 0000                    start_lba_lw:	dw	0
    79 00000013 0000                    start_lba_hw:	dw	0
    80 00000015 0000                    sectors_lba_lw:	dw	0
    81 00000017 0000                    sectors_lba_hw:	dw	0
    82                                  
    83 00000019 0000                    pt_start_cyl:	dw	0
    84 0000001B 0000                    pt_end_cyl:	dw	0
    85 0000001D 0000                    pt_cylinders:	dw	0
    86 0000001F 01                      file_system:	db	1
    87                                  cpartition_number:
    88 00000020 00                      		db	0
    89 00000021 00                      partition:	db	0
    90 00000022 80                      drive:		db	80h ; 0
    91 00000023 31                      disk_number:	db	'1' ; 0
    92 00000024 00                      wait_for_input:	db	0
    93                                  max_avl_cylinders: 
    94 00000025 0000                    		dw	0
    95                                  next_start_cylinder: 
    96 00000027 0000                    		dw	0
    97 00000029 0000                    cylinders:	dw	0
    98 0000002B 0000                    start_cyl:	dw	0
    99                                  active_part_input:
   100 0000002D 00                      		db	0
   101                                  active_partition:
   102 0000002E 00                      		db	0
   103                                  
   104                                  ; ----------------------------------------------------------------------------
   105                                  ; CRT0 - Modified and simplified for Assembly language
   106                                  ; ----------------------------------------------------------------------------
   107                                  ; 						  (by Erdogan Tan, 06/11/2018)
   108                                  
   109                                  _astart:
   110 0000002F B430                    		mov	ah,30h
   111 00000031 CD21                    		int	21h   ; DOS - GET DOS VERSION
   112                                  			      ; Return: AL = major ver. num. (00h for DOS 1.x)
   113                                  
   114                                  		;mov	word [_dosvermajor],ax	
   115                                  
   116                                  		;cmp	al,5	; MSDOS 5.0 or next versions are needed
   117                                  				; for (correct) running this program. 
   118                                  		;jnb	short setup
   119                                  
   120                                  		; 14/11/2018
   121 00000033 3C03                    		cmp	al,3	; MSDOS 3.3 check
   122 00000035 7714                    		ja	short setup_2
   123 00000037 740B                    		je	short setup_1
   124                                  
   125                                  _wrong_version:
   126                                  		; 'Incorrect dos version!' msg writing code may be put here.
   127 00000039 BE[965C]                		mov	si,incorrect_dos_version ; ('Incorrect DOS version!')
   128 0000003C E8445C                  		call	print_msg 
   129                                  
   130 0000003F 31C0                    		xor	ax,ax
   131 00000041 06                      		push	es
   132 00000042 50                      		push	ax
   133 00000043 CB                      		retf		; DOS 1.0 exit program (int 20h at psp:0)	
   134                                  setup_1:
   135                                  		; 14/11/2018
   136 00000044 80FC1E                  		cmp	ah,30	; MSDOS 3.30 (3.3) ? (at least) 
   137 00000047 72F0                       		jb	short _wrong_version
   138 00000049 740B                    		je	short _correct_version ; Proper version for now...
   139                                  					 ; .. but, 'Incorrect DOS version' msg
   140                                  					 ; is waiting at next stage!
   141                                  					 ; (in 'preload_messages' procedure)
   142                                  ;setup:
   143                                  setup_2:
   144 0000004B 3C07                    		cmp	al,7	; MS-DOS/PC-DOS version 5.0 to 7.1 is proper
   145 0000004D 7207                    		jb	short _correct_version
   146 0000004F 77E8                    		ja	short _wrong_version
   147 00000051 80FC0A                  		cmp	ah,10
   148 00000054 77E3                    		ja	short _wrong_version  
   149                                  
   150                                  _correct_version:
   151                                  
   152                                  		; 14/12/2018
   153                                  		; (clear bss)	
   154 00000056 B9[06D0]                		mov	cx,dataoffset_end_2
   155 00000059 BF[6AA0]                		mov	di,bss_start
   156 0000005C 29F9                    		sub	cx,di
   157 0000005E 41                      		inc	cx
   158 0000005F D1E9                    		shr	cx,1
   159 00000061 31C0                    		xor	ax, ax		
   160 00000063 F3AB                    		rep	stosw
   161                                  		
   162                                  		;call	clear_screen
   163                                  
   164                                  		; process command line (and environment)
   165                                  		;call	_setenvp
   166                                  		;call	_setargv ; crack command line
   167                                  
   168                                  		;;push	word [environ]				
   169                                  		;push	word [_argv]
   170                                  		;push	word [_argc]
   171                                  
   172 00000065 E80500                  		call	_main
   173                                  		;push	ax
   174                                  		;call	_exit
   175                                  
   176                                  		;int	20h
   177                                  _exit:
   178                                  _exit_:		; 10/12/2018
   179                                  DOSEXIT:	; 19/11/2018	
   180                                  		;pop	ax
   181 00000068 B44C                    		mov	ah,4Ch
   182 0000006A CD21                    		int	21h	; DOS -	2+ - QUIT WITH EXIT CODE (EXIT)
   183                                  				; AL = exit code
   184                                  
   185                                  ; ----------------------------------------------------------------------------
   186                                  
   187                                  int23h:		; 14/11/2018
   188                                  
   189 0000006C CF                      		iret
   190                                  
   191                                  ; ----------------------------------------------------------------------------
   192                                  
   193                                  ; ----------------------------------------------------------------------------
   194                                  ; main.c (FDISK, MSDOS 6.0, 1991)	
   195                                  ; ----------------------------------------------------------------------------
   196                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 06/11/2018)
   197                                  
   198                                  ;/******************* START OF SPECIFICATIONS *******************/
   199                                  ;/*                                                             */
   200                                  ;/* SOURCE FILE NAME: FDISK                                     */
   201                                  ;/*                                                             */
   202                                  ;/* DESCRIPTIVE NAME: FIXED DISK PARTITIONING UTILITY           */
   203                                  ;/*                                                             */
   204                                  ;/* FUNCTION:                                                   */
   205                                  ;/*     Allows creation and deletion of DOS related partitions  */
   206                                  ;/*     on fixed disk devices 80-86h (int 13h BIOS defined,     */
   207                                  ;/*     DOS). Also allows display of all partitions, and will   */
   208                                  ;/*     allow a partition to be marked active (bootable). The   */
   209                                  ;/*     user will be prompted for action thru a full screen     */
   210                                  ;/*     interface. The user can also create, delete and display */
   211                                  ;/*     logical DOS drives within a EXTENDED DOS Partition. If a*/
   212                                  ;/*     regular DOS partition is created, the beginning of the  */
   213                                  ;/*     partition will be scanned to insure a contiguous area of*/
   214                                  ;/*     good sectors on the disk large enough to satisfy the    */
   215                                  ;/*     DOS system requirements. If a bad spot is found, the    */
   216                                  ;/*     start of the partition will be moved out until a good   */
   217                                  ;/*     area is located                                         */
   218                                  ;/*                                                             */
   219                                  ;/* NOTES: The program will work by setting up a logical image  */
   220                                  ;/*        of all relevant disk information at initilization    */
   221                                  ;/*        time. All operations will be performed on this       */
   222                                  ;/*        logical image, thus reducing disk accesses to only   */
   223                                  ;/*        those required to initially set up the logical image,*/
   224                                  ;/*        and to write the changed information at the end. The */
   225                                  ;/*        user will be informed if there is a problem writing  */
   226                                  ;/*        the logical image back to the disk.                  */
   227                                  ;/*                                                             */
   228                                  ;/*        FDISK will interface with the partition table in the */
   229                                  ;/*        master boot record as defined in the PC-DOS technical*/
   230                                  ;/*        reference manual. It will also create and manage the */
   231                                  ;/*        EXTENDED DOS partition architecture as defined in the*/
   232                                  ;/*        PC-DOS 3.30 functional spec (CP/DOS spec dcr pending)*/
   233                                  ;/*                                                             */
   234                                  ;/* ENTRY POINTS: MAIN                                          */
   235                                  ;/*    LINKAGE: [d:] [path] FDISK                               */
   236                                  ;/*                                                             */
   237                                  ;/* EXTERNAL REFERENCES:                                        */
   238                                  ;/*              Fixed Disk Master Boot Record                  */
   239                                  ;/*              EXTENDED Partition Volume Boot Records         */
   240                                  ;/*   Note: Both of the above are physical data structures on   */
   241                                  ;/*         the surface of the disk                             */
   242                                  ;/*                                                             */
   243                                  ;/* P.S. - To whoever winds up maintaining this, I will         */
   244                                  ;/*        apoligize in advance. I had just learned 'C' when    */
   245                                  ;/*        writing this, so out of ignorance of the finer points*/
   246                                  ;/*        of the langauge I did a lot of things by brute force.*/
   247                                  ;/*        Hope this doesn't mess you up too much - MT 5/20/86  */
   248                                  ;/******************** END OF SPECIFICATIONS ********************/
   249                                  
   250                                  ;/*  */
   251                                  ;/******************* START OF SPECIFICATIONS *******************/
   252                                  ;/*                                                             */
   253                                  ;/* SUBROUTINE NAME: MAIN                                       */
   254                                  ;/*                                                             */
   255                                  ;/* DESCRIPTIVE NAME: Main control routine                      */
   256                                  ;/*                                                             */
   257                                  ;/* FUNCTION: Main will handle call routines to handle the      */
   258                                  ;/*           setup of the video for the full screen interface, */
   259                                  ;/*           get physical data on the drive characteristics,   */
   260                                  ;/*           initilize all data fields with the current status */
   261                                  ;/*           of the disk partitioning information. Before the  */
   262                                  ;/*           program is terminated, the video is reset to the  */
   263                                  ;/*           mode it was in previous to the routine entry. It  */
   264                                  ;/*           will also handle the case of an improper setup    */
   265                                  ;/*                                                             */
   266                                  ;/* NOTES: FDISK requires at least 1 hardfile to operate        */
   267                                  ;/*                                                             */
   268                                  ;/* ENTRY POINTS: main();                                       */
   269                                  ;/*      LINKAGE:                                               */
   270                                  ;/*                                                             */
   271                                  ;/* INPUT: None                                                 */
   272                                  ;/*                                                             */
   273                                  ;/* EXIT-NORMAL: Return Code = 0                                */
   274                                  ;/*                                                             */
   275                                  ;/* EXIT-ERROR: Return Code =  1                                */
   276                                  ;/*                                                             */
   277                                  ;/* EFFECTS: Sets up status variables, sets up video for full   */
   278                                  ;/*          screen interface, and then restores the video mode */
   279                                  ;/*          before exiting program                             */
   280                                  ;/*                                                             */
   281                                  ;/* INTERNAL REFERENCES:                                        */
   282                                  ;/*   ROUTINES:                                                 */
   283                                  ;/*      init_video_information                                 */
   284                                  ;/*      get_disk_information                                   */
   285                                  ;/*      check_valid_environment                                */
   286                                  ;/*      do_main_menu                                           */
   287                                  ;/*      init_partition_tables                                  */
   288                                  ;/*      reset_video_information                                */
   289                                  ;/*                                                             */
   290                                  ;/* EXTERNAL REFERENCES:                                        */
   291                                  ;/*   ROUTINES:                                                 */
   292                                  ;/*       DosExit                                               */
   293                                  ;/*                                                             */
   294                                  ;/******************** END OF SPECIFICATIONS ********************/
   295                                  
   296                                  
   297                                  ;/*  */
   298                                  ;/**************************************************************************/
   299                                  ;/*                                                                        */
   300                                  ;/*   UTILITY NAME:         FDISK.com                                      */
   301                                  ;/*   SOURCE FILE NAME:     FDISK.c                                        */
   302                                  ;/*   STATUS:               FDISK utility, DOS 3.3			   */
   303                                  ;/*   CHANGE HISTORY:       UPDATED        5-29-87     DOS4.0       DRM    */
   304                                  ;/*   SYNTAX (Command line)                                                */
   305                                  ;/*                                                                        */
   306                                  ;/*     [d:][path]FDISK                                                    */
   307                                  ;/*                                                                        */
   308                                  ;/*     or                                                                 */
   309                                  ;/*                                                                        */
   310                                  ;/*     [d:][path]FDISK d [/PRI:m | /EXT:n | /LOG:o | /Q | /STATUS | /MBR] */
   311                                  ;/*                                                                        */
   312                                  ;/*         d:      Drive to load FDISK utility from                       */
   313                                  ;/*                                                                        */
   314                                  ;/*         path    path to the directory on specified drive to            */
   315                                  ;/*                 load FDISK from                                        */
   316                                  ;/*                                                                        */
   317                                  ;/*         d       Drive (1 or 2) that FDISK should operate on            */
   318                                  ;/*                                                                        */
   319                                  ;/*         /PRI:m  Size of Primary DOS partition to create in K           */
   320                                  ;/*                                                                        */
   321                                  ;/*         /EXT:n  Size of Extended DOS partition to create in K          */
   322                                  ;/*                                                                        */
   323                                  ;/*         /LOG:o  Size of Logical drive to create in K in the            */
   324                                  ;/*                 extended partition                                     */
   325                                  ;/*                                                                        */
   326                                  ;/*         /Q      This suppresses the reboot screen and returns          */
   327                                  ;/*                 FDISK to DOS even if partitions have changed.          */
   328                                  ;/*                                                                        */
   329                                  ;/*         /STATUS This gives a display of the data portion of the        */
   330                                  ;/*                 Change Current Fixed Disk Drive menu.                  */
   331                                  ;/*                                                                        */
   332                                  ;/*   UTILITY FUNCTION:                                                    */
   333                                  ;/*     Allows you to create, set up, display, afnd delete the             */
   334                                  ;/*     DOS partitions on a fixed disk.                                    */
   335                                  ;/*                                                                        */
   336                                  ;/* PSEUDOCODE:                                                            */
   337                                  ;/*                                                                        */
   338                                  ;/*      Disable CTRL-break                                                */
   339                                  ;/*      IF Preload_messages and get_yes_no_values                         */
   340                                  ;/*          IF Parse Command Line                                         */
   341                                  ;/*              IF no switches set                                        */
   342                                  ;/*                  IF Valid Environment                                  */
   343                                  ;/*                      Change video information                          */
   344                                  ;/*                      IF Get disk information                           */
   345                                  ;/*                          Initialize tables                             */
   346                                  ;/*                          IF status_flag == TRUE                        */
   347                                  ;/*                              display current drive information         */
   348                                  ;/*                          else                                          */
   349                                  ;/*                              display main menu                         */
   350                                  ;/*                              write information to disk                 */
   351                                  ;/*                              IF reboot_flag == TRUE                    */
   352                                  ;/*                                  reboot                                */
   353                                  ;/*                              else                                      */
   354                                  ;/*                                  reset video mode                      */
   355                                  ;/*                              ENDIF  reboot flag                        */
   356                                  ;/*                          ENDIF  status flag                            */
   357                                  ;/*                      ENDIF  get disk info                              */
   358                                  ;/*                  ENDIF  valid environment                              */
   359                                  ;/*              else                                                      */
   360                                  ;/*                  IF all flags == FALSE                                 */
   361                                  ;/*                      display error message                             */
   362                                  ;/*                  else                                                  */
   363                                  ;/*                      IF get_disk_info                                  */
   364                                  ;/*                          IF drive number not valid                     */
   365                                  ;/*                              display error message                     */
   366                                  ;/*                          else                                          */
   367                                  ;/*                              init_partition_tables                     */
   368                                  ;/*                              IF PRIMARY flag == true                   */
   369                                  ;/*                                  find available free space             */
   370                                  ;/*                                  IF asking for too much                */
   371                                  ;/*                                      reset ask to available space      */
   372                                  ;/*                                  else                                  */
   373                                  ;/*                                      change request to cylinders       */
   374                                  ;/*                                  ENDIF                                 */
   375                                  ;/*                                  make the partition                    */
   376                                  ;/*                              ENDIF                                     */
   377                                  ;/*                              IF EXTENDED flag == true                  */
   378                                  ;/*                                  find available free space             */
   379                                  ;/*                                  IF asking for too much                */
   380                                  ;/*                                      reset ask to available space      */
   381                                  ;/*                                  else                                  */
   382                                  ;/*                                      change request to cylinders       */
   383                                  ;/*                                  ENDIF                                 */
   384                                  ;/*                                  make the partition                    */
   385                                  ;/*                              ENDIF                                     */
   386                                  ;/*                              IF LOGICAL flag == true                   */
   387                                  ;/*                                  find available free space in extended */
   388                                  ;/*                                  IF asking for too much                */
   389                                  ;/*                                      reset ask to available space      */
   390                                  ;/*                                  else                                  */
   391                                  ;/*                                      change request to cylinders       */
   392                                  ;/*                                  ENDIF                                 */
   393                                  ;/*                                  make the partition                    */
   394                                  ;/*                              ENDIF                                     */
   395                                  ;/*                              Write information to disk                 */
   396                                  ;/*                          ENDIF                                         */
   397                                  ;/*                      ENDIF                                             */
   398                                  ;/*                  ENDIF                                                 */
   399                                  ;/*              ENDIF                                                     */
   400                                  ;/*          ENDIF                                                         */
   401                                  ;/*      ENDIF                                                             */
   402                                  ;/*      IF no PRIMARY on disk 1 and /Q switch                             */
   403                                  ;/*          exit errorlevel 1                                             */
   404                                  ;/*      else                                                              */
   405                                  ;/*          IF no switches set and /Q option                              */
   406                                  ;/*              exit errorlevel 2                                         */
   407                                  ;/*          else                                                          */
   408                                  ;/*              exit errorlevel 0                                         */
   409                                  ;/*          ENDIF                                                         */
   410                                  ;/*      ENDIF                                                             */
   411                                  ;/*                                                                        */
   412                                  ;/**************************************************************************/
   413                                  ;/*  */
   414                                  
   415                                  ; 24/11/2018
   416                                  
   417                                  ; void main(argc,argv)
   418                                  
   419                                  	; int	argc;
   420                                  	; char	*argv[];  
   421                                  
   422                                  _main:
   423                                  		;push	bp
   424                                  		;mov	bp,sp
   425                                  
   426                                  		;argv	equ 6 		; [bp+6]
   427                                  		;argc	equ 4		; [bp+4]
   428                                  
   429                                  		       ; Return Address = [bp+2]
   430                                  
   431                                  	      ;	unsigned   i;  		; [bp-6] 
   432                                  	      ;	char       temp; 	; [bp-4]
   433                                  	      ;	unsigned   input;	; [bp-2]
   434                                  
   435                                  ;	;/* DISABLE CNTL-BREAK HERE */
   436                                  ;	;/* Gets defines from signal.h */
   437                                  ;
   438                                  ;		signal( (int) SIGINT, SIG_IGN ); /* AN000 */
   439                                  
   440 0000006D BA[6C00]                		mov	dx,int23h
   441 00000070 B82325                  		mov	ax,2523h
   442                                  				; DOS -	SET INTERRUPT VECTOR
   443 00000073 CD21                    		int	21h	; AL = interrupt number
   444                                  			; DS:DX	= new vector to	be used	for specified interrupt
   445                                  
   446                                  ;	no_fatal_error = TRUE;
   447                                  
   448 00000075 C606[05C4]01            		mov	byte [no_fatal_error],1
   449                                  
   450                                  		; 13/11/2018
   451 0000007A E8A70B                  		call	preload_messages
   452                                  
   453                                  		;or	al,al
   454                                  		;jz	_main_33
   455                                  
   456 0000007D 0F824602                		jc	_main_33
   457                                  
   458 00000081 E8B60C                  		call	get_yes_no_values
   459                                  
   460                                  		;or	al,al
   461                                  		;jnz	_main_01
   462                                  
   463                                  		; 14/11/2018
   464                                  		;;jnc	_main_01
   465                                  		;;jmp	short _main_33
   466                                  		;jmp	short _main_01
   467                                  
   468                                  ; ----------------------------------------------------------------------------
   469                                  
   470                                  ;int23h:
   471                                  ;		iret
   472                                  
   473                                  ; ----------------------------------------------------------------------------
   474                                  
   475                                  _main_01:
   476                                  ;	;/* Parse the command line for syntax and switches */
   477                                  
   478                                  	; if(parse_command_line(argc,argv))     
   479                                  
   480                                  		;push	word [bp+argv]
   481                                  		;push	word [bp+argc]
   482                                  
   483 00000084 E88302                  		call 	parse_command_line
   484                                  
   485                                  		;pop	bx
   486                                  		;pop	bx
   487                                  
   488                                  		;or	al,al
   489                                  		;jz	_main_33	; [parse_good] = 0
   490                                  
   491 00000087 0F823C02                		jc	_main_33
   492                                  
   493                                  ;	;/* check to see if switches were set */
   494                                  
   495                                  ;	if ((primary_flag == FALSE) && (extended_flag == FALSE) &&
   496                                  ;           (logical_flag == FALSE) && (disk_flag == FALSE) && (mbr_flag == FALSE))
   497                                  
   498 0000008B 803E[00A1]00            		cmp	byte [primary_flag],0
   499 00000090 7557                    		jne	short _main_04 ; _main_11
   500 00000092 803E[D6C3]00            		cmp	byte [extended_flag],0
   501 00000097 7550                    		jne	short _main_04 ; _main_11
   502 00000099 803E[D3C3]00            		cmp	byte [logical_flag],0
   503 0000009E 7549                    		jne	short _main_04 ; _main_11
   504 000000A0 803E[96A0]00            		cmp	byte [disk_flag],0
   505 000000A5 7544                    		jne	short _main_05 ; _main_14
   506 000000A7 803E[2EA1]00            		cmp	byte [mbr_flag],0
   507 000000AC 753D                    		jne	short _main_05 ; _main_14
   508                                  
   509 000000AE C606[6AA0]00            		mov	byte [reboot_flag],0
   510                                  
   511                                  ;	;/* See if running evironment is ok (Got hardfile, no network)
   512                                  
   513 000000B3 E82713                  		call	check_valid_environment
   514                                  
   515                                  		;or	al,al
   516                                  		;jnz	short _main_02
   517                                  		;jmp	_main_33
   518                                  
   519 000000B6 7303                    		jnc	short _main_02
   520 000000B8 E90C02                  		jmp	_main_33
   521                                  _main_02:
   522                                  ;	;/* Get and save screen mode information */
   523                                  
   524 000000BB E84713                  		call	init_video_information
   525                                  
   526                                  		;mov	ax,79
   527                                  		;push	ax	 ; Bottom Rigth Column (79)  
   528                                  		;mov	ax,24
   529                                  		;push	ax	 ; Bottom Row (24)
   530                                  		;sub	ax,ax ; 0
   531                                  		;push	ax	 ; Top Left Column (0)	
   532                                  		;push	ax	 ; Top Row (0)
   533                                  		;
   534                                  		;call	clear_screen
   535                                  		;
   536                                  		;add	sp,8	; 15/11/2018
   537                                  
   538                                  		; Clear screen (clear whole video page)
   539 000000BE E89D13                  		call	CLS	; 16/11/2018
   540                                  
   541                                  ;	;/* Get disk size information */
   542                                  
   543                                  		; for (i=0; i < u(MAX_HDISK); i++)
   544                                                  ;     good_disk[i] = TRUE;
   545                                  
   546                                  		;mov	word [_i],0
   547 000000C1 31DB                    		xor	bx,bx
   548                                  _main_03:
   549                                  		;mov	bx,[_i]
   550 000000C3 C687[42A1]01            		mov	byte [good_disk+bx],1 ; TRUE
   551                                  		;inc	word [_i]
   552                                  		;inc	bx
   553 000000C8 FEC3                    		inc	bl
   554                                  		;cmp	word [_i],8
   555 000000CA 80FB08                  		cmp	bl,8
   556 000000CD 72F4                    		jb	short _main_03
   557                                  
   558                                  		; if (get_disk_info())
   559                                  
   560 000000CF E8E813                  		call	get_disk_info
   561                                  
   562                                  		;or	al,al
   563                                  		;jz	short _main_07
   564                                  
   565 000000D2 721F                    		jc	short _main_07
   566                                  
   567                                  ;	;/* build memory model of partitions */
   568                                  
   569 000000D4 E89B18                  		call	init_partition_tables
   570 000000D7 C606[D4CB]00            		mov	byte [cur_disk],0
   571                                  
   572                                  		;if (status_flag == TRUE)
   573 000000DC 803E[D4C3]01            		cmp	byte [status_flag],1 ; TRUE
   574 000000E1 750A                    		jne	short _main_06  ; else
   575                                  
   576 000000E3 E84E1F                  		call	change_current_drive
   577                                  		;jmp	short _main_07
   578                                  		; 19/11/2018
   579 000000E6 E9DE01                  		jmp	_main_33
   580                                  _main_04:
   581 000000E9 EB31                    		jmp	_main_11
   582                                  _main_05:
   583 000000EB EB58                    		jmp	_main_14	
   584                                  _main_06:
   585                                  
   586                                  ;	;/* Go do main screen */
   587 000000ED E88C2B                  		call	do_main_menu
   588 000000F0 E8CE35                  		call	write_info_to_disk
   589                                  _main_07:
   590                                  		; if (!status_flag)
   591 000000F3 803E[D4C3]00            		cmp	byte [status_flag],0 ; FALSE
   592 000000F8 7403                    		je	short _main_08
   593 000000FA E9CA01                  		jmp	_main_33
   594                                  _main_08:
   595 000000FD 803E[6AA0]00            		cmp	byte [reboot_flag],0
   596 00000102 7408                    		je	short _main_09
   597 00000104 E8D434                  		call	reboot_system
   598                                  
   599                                  		; DOSEXIT((unsigned) 0,(unsigned) 0); 
   600 00000107 29C0                    		sub	ax,ax
   601                                  		;push	ax
   602                                  		;push	ax
   603 00000109 E85CFF                  		call	DOSEXIT
   604                                  _main_09:
   605 0000010C 803E[05C4]00            		cmp	byte [no_fatal_error],0
   606 00000111 7503                    		jne	short _main_10
   607 00000113 E9B101                  		jmp	_main_33
   608                                  _main_10:
   609                                  ;	 ;/* Nearly done, go reset screen mode */
   610                                  
   611 00000116 E82813                  		call	reset_video_information
   612 00000119 E9AB01                  		jmp	_main_33
   613                                  ; else
   614                                  
   615                                  ; if ((((primary_flag == FALSE) && (extended_flag == FALSE) &&
   616                                  ;        (logical_flag == FALSE)) || (disk_flag == FALSE)) && (mbr_flag == FALSE))
   617                                  ; display_msg((int)8,(int)DosStdEr,(int)nosubcnt,(int)nosubptr,c(noinput),c(Utility_Msg_Class))	
   618                                  
   619                                  _main_11:
   620 0000011C 803E[96A0]00            		cmp	byte [disk_flag],0
   621 00000121 7522                    		jne	short _main_14
   622                                  
   623 00000123 803E[2EA1]00            		cmp	byte [mbr_flag],0
   624 00000128 751B                    		jne	short _main_14
   625                                  
   626                                  _main_12:	; 14/11/2018
   627                                  		;jmp	short_main_37		
   628                                  
   629 0000012A B0FF                    		mov	al,-1
   630 0000012C 50                      		push	ax
   631 0000012D 28C0                    		sub	al,al
   632 0000012F 50                      		push	ax
   633 00000130 29C0                    		sub	ax,ax
   634 00000132 50                      		push	ax
   635 00000133 50                      		push	ax
   636 00000134 B80200                  		mov	ax,2
   637 00000137 50                      		push	ax
   638 00000138 B80800                  		mov	ax,8
   639                                  _main_13:
   640 0000013B 50                      		push	ax
   641 0000013C E8DB0B                  		call	display_msg
   642 0000013F 83C40C                  		add	sp,12
   643 00000142 E98201                  		jmp	_main_33
   644                                  
   645                                  ;_main_37:
   646                                  		; Temporary - 10/11/2018
   647                                  		;mov	ax,10
   648                                  		;call	print_parse_error_msg
   649                                  		;jmp	_main_33
   650                                  
   651                                  ; ----------------------------------------------------------------------------
   652                                  
   653                                  _main_14:
   654 00000145 C606[6AA0]00            		mov	byte [reboot_flag],0  ; FALSE
   655                                  
   656                                  ;	;/* Get disk size information */
   657                                  
   658                                  		; for (i=0; i < u(MAX_HDISK); i++)
   659                                                  ;     good_disk[i] = TRUE;
   660                                  
   661                                  		;mov	word [_i],0
   662 0000014A 31DB                    		xor	bx,bx
   663                                  _main_15:
   664                                  		;mov	bx,[_i]
   665 0000014C C687[42A1]01            		mov	byte [good_disk+bx],1 ; TRUE
   666                                  		;inc	word [_i]
   667                                  		;inc	bx
   668 00000151 FEC3                    		inc	bl
   669                                  		;cmp	word [_i],8
   670 00000153 80FB08                  		cmp	bl,8
   671 00000156 72F4                    		jb	short _main_15
   672                                  
   673                                  		; if (get_disk_info())
   674                                  
   675 00000158 E85F13                  		call	get_disk_info
   676                                  
   677                                  		;or	al,al
   678                                  		;jz	short _main_33
   679                                  
   680                                  		;jc	short _main_33
   681 0000015B 0F826801                		jc	_main_33
   682                                  
   683                                  _main_16:
   684 0000015F A0[0FC4]                		mov	al,[cur_disk_buff]
   685 00000162 98                      		cbw	; ah = 0
   686 00000163 40                      		inc	ax
   687 00000164 8A0E[D5C3]              		mov	cl,[number_of_drives]
   688 00000168 28ED                    		sub	ch,ch
   689                                  
   690                                  ; if (number_of_drives < (cur_disk_buff+1))
   691                                  ; display_msg((int)8,(int)DosStdEr,(int)nosubcnt,(int)nosubptr,c(noinput),c(Utility_Msg_Class));
   692                                  
   693 0000016A 39C8                    		cmp	ax,cx
   694 0000016C 7FBC                    		jg	short _main_12
   695                                  
   696                                  ; else
   697                                  ;	if(mbr_flag == TRUE)  
   698                                  
   699 0000016E 803E[2EA1]01            		cmp	byte [mbr_flag],1
   700 00000173 754B                    		jne	short _main_22
   701                                  
   702                                  ; if(!read_boot_record(0,0,0,1))
   703                                  ; display_msg((int)11,(int)DosStdEr,(int)nosubcnt,(int)nosubptr,c(noinput),c(Utility_Msg_Class));
   704                                  
   705 00000175 B001                    		mov	al,1
   706                                  		; ah = 0
   707 00000177 50                      		push	ax
   708 00000178 28C0                    		sub	al,al ; al = 0
   709 0000017A 50                      		push	ax
   710 0000017B 50                      		push	ax
   711                                  		;sub	ax,ax ; ah = 0
   712 0000017C 50                      		push	ax
   713 0000017D E8721E                  		call	read_boot_record
   714                                  		;add	sp,8  ; 22/12/2018
   715                                  		
   716                                  		;or	al,al
   717                                  		;jnz	short _main_18
   718                                  		
   719 00000180 7311                    		jnc	short _main_18
   720                                  ; else  
   721                                  _main_17:
   722                                  		; 19/11/2018
   723                                  		;mov	al,-1
   724                                  		; 11/12/2018
   725 00000182 31C0                    		xor	ax,ax ; 0
   726 00000184 FEC8                    		dec	al ; -1
   727 00000186 50                      		push	ax
   728                                  		;sub	al,al
   729 00000187 FEC0                    		inc	al ; 0
   730 00000189 50                      		push	ax
   731                                  		;sub	ax,ax
   732 0000018A 50                      		push	ax
   733 0000018B 50                      		push	ax
   734                                  		;mov	ax,2
   735 0000018C B002                    		mov	al,2 ; 11/12/2018
   736 0000018E 50                      		push	ax
   737                                  		;mov	ax,11
   738 0000018F B00B                    		mov	al,11
   739 00000191 EBA8                    		jmp	short _main_13
   740                                  
   741                                  _main_18:
   742                                  ;	if((boot_record[0x1FE]==0x55) && (boot_record[0x1FF]==0xAA)) 
   743                                  
   744                                  		;cmp	byte [boot_record+1FEh],55h
   745                                  		;jne	short _main_19
   746                                  		;cmp	[boot_record+1FFh],0AAh
   747                                  		;jne	short _main_19
   748                                  
   749                                  		;mov	cx,1FFh ; 10/11/2018
   750 00000193 B9BD01                  		mov	cx,1BDh
   751                                   
   752 00000196 813E[D0CB]55AA          		cmp	word [boot_record+1FEh],0AA55h
   753                                  		;jne	short _main_19
   754 0000019C 7402                    		je	short _main_19 ; 10/11/2018
   755                                  
   756                                  		; for(i=0; i<=0x1BD; i++)
   757                                                  ;    boot_record[i] = master_boot_record[0][i]; 
   758                                  
   759                                  		;;mov	cx,1BDh
   760                                  		;mov	cl,0BDh ; 10/11/2018
   761 0000019E B1FF                    		mov	cl,0FFh
   762                                  _main_19:
   763                                  		;mov	word [_i],0
   764 000001A0 31DB                    		xor	bx,bx
   765                                  _main_20:
   766                                  		;mov	bx,[_i]
   767 000001A2 8A87[845F]              		mov     al,[master_boot_record+bx]
   768 000001A6 8887[D2C9]              		mov	[boot_record+bx],al
   769                                  		;inc	word [_i]
   770 000001AA 43                      		inc	bx
   771                                  		;cmp	word [_i],cx
   772 000001AB 39CB                    		cmp	bx,cx
   773 000001AD 76F3                    		jbe	short _main_20
   774                                  
   775                                  		; 15/12/2018
   776                                  		;sub	al,al ; disk 0
   777 000001AF 29C0                    		sub	ax,ax
   778 000001B1 50                      		push	ax 
   779                                  		;sub	ax,ax ; cylinder 0
   780 000001B2 50                      		push	ax
   781 000001B3 E8822A                  		call	write_boot_record
   782                                  		;pop	bx
   783                                  		;pop	bx ; 22/12/2018
   784                                  		
   785                                  		;or	al,al
   786                                  		;jz	short _main_17
   787                                  		
   788 000001B6 72CA                    		jc	short _main_17
   789                                  
   790 000001B8 E90C01                  		jmp	_main_33
   791                                  _main_21:
   792                                  ;	else
   793                                          	; for(i=0; i<=0x1FF; i++)
   794                                                  ;    boot_record[i] = master_boot_record[0][i];        
   795                                  
   796 000001BB B9FF01                  		mov	cx,1FFh
   797 000001BE EBE0                    		jmp	short _main_19
   798                                  
   799                                  _main_22:
   800                                  ;	;/* build memory model of partitions */
   801                                  
   802 000001C0 E8AF17                  		call	init_partition_tables
   803                                  
   804                                  ;	;/* set cur_disk to current disk */
   805                                  
   806 000001C3 A0[0FC4]                		mov	al,[cur_disk_buff]
   807 000001C6 A2[D4CB]                		mov	[cur_disk],al
   808                                  
   809                                  		DOS12	equ  1	; FAT12 PARTITION ID
   810                                  		DOS16	equ  4	; FAT16 PARTITION (<=32MB) ID
   811                                  		DOSNEW	equ  6	; FAT16 BIG PARTITION (<32MB) ID
   812                                  	
   813                                  		;DOS16BIG equ 6	; FAT16 BIG PARTITION (>32MB) ID
   814                                  
   815                                  		EXTENDED equ 5	; EXTENDED DOS PARTITION ID
   816                                  
   817                                  ;	;/* If /PRI: was specified, create primary partition */
   818                                  ;	;/* check to see if a primary partition already exists */
   819                                  
   820 000001C9 803E[00A1]01            		cmp	byte [primary_flag],1
   821 000001CE 7551                    		jne	short _main_25
   822                                  
   823                                  ;	if ( (primary_flag == TRUE)  && 
   824                                  ;          ( (!find_partition_type(uc(DOS12))) &&
   825                                  ;            (!find_partition_type(uc(DOS16))) &&
   826                                  ;            (!find_partition_type(uc(DOSNEW))) ) )
   827                                  
   828 000001D0 B001                    		mov	al,DOS12 ; 1
   829                                  		;push	ax
   830 000001D2 E8E51B                  		call	find_partition_type
   831                                  		;pop	bx
   832                                  		;or	al,al
   833                                  		;jnz	short _main_25
   834 000001D5 734A                    		jnc	short _main_25
   835                                  
   836 000001D7 B004                    		mov	al,DOS16 ; 4
   837                                  		;push	ax
   838 000001D9 E8DE1B                  		call	find_partition_type
   839                                  		;pop	bx
   840                                  		;or	al,al
   841                                  		;jnz	short _main_25
   842 000001DC 7343                    		jnc	short _main_25
   843                                  
   844 000001DE B006                    		mov	al,DOSNEW ; 6
   845                                  		;push	ax
   846 000001E0 E8D71B                  		call	find_partition_type
   847                                  		;pop	bx
   848                                  		;or	al,al
   849                                  		;jnz	short _main_25
   850 000001E3 733C                    		jnc	short _main_25
   851                                  
   852 000001E5 30C0                    		xor	al,al ; 14/01/2019
   853                                  		;push	ax
   854                                  		; AL = 0
   855 000001E7 E8AA4E                  		call	find_part_free_space
   856                                  		;pop	bx
   857                                  
   858                                  ;	temp = find_part_free_space((char) PRIMARY);
   859                                  ;	if (primary_buff >= free_space[temp].mbytes_unused)
   860                                  
   861 000001EA A2[0ED0]                		mov	[_temp],al
   862                                  		;mov	al,22
   863                                  		;imul	byte [_temp]
   864 000001ED B316                    		mov	bl,22
   865 000001EF F6E3                    		mul	bl
   866 000001F1 89C3                    		mov	bx,ax
   867 000001F3 A1[D0C3]                		mov	ax,[primary_buff]
   868                                  		; 13/01/2019
   869 000001F6 3987[E8CB]              		cmp	[free_space.mbytes_unused+bx],ax
   870 000001FA 7706                    		ja	short _main_23
   871 000001FC 8B87[E2CB]              		mov	ax,[free_space.space+bx]
   872 00000200 EB0B                    		jmp	short _main_24
   873                                  _main_23:
   874                                  ;else
   875                                  ;	input = (unsigned)mbytes_to_cylinders(primary_buff,cur_disk_buff);
   876                                  
   877 00000202 A0[0FC4]                		mov	al,[cur_disk_buff]
   878 00000205 50                      		push	ax
   879 00000206 FF36[D0C3]              		push	word [primary_buff]
   880 0000020A E8B254                  		call	mbytes_to_cylinders
   881                                  		;pop	bx
   882                                  		;pop	bx
   883                                  _main_24:
   884                                  ;	make_partition(input,temp,uc(ACTIVE),(char)PRIMARY);
   885                                  
   886 0000020D A3[10D0]                		mov	[_input],ax
   887 00000210 28C0                    		sub	al,al ; 0 	
   888 00000212 50                      		push	ax	      ; mp_type - PRIMARY -			
   889 00000213 B080                    		mov	al,80h
   890 00000215 50                      		push	ax	      ; mp_bootable - bootable, active -  	
   891 00000216 A0[0ED0]                		mov	al,[_temp]	
   892 00000219 50                      		push	ax	      ;	mp_free_ptr (byte)
   893 0000021A FF36[10D0]              		push	word [_input] ; mp_size (word)
   894 0000021E E82553                  		call	make_partition
   895                                  		;add	sp,8
   896                                  _main_25:
   897                                  
   898                                  ; /* If /EXT: was specified, create extended partition */
   899                                  ; /* Check and see if there is a primary partition before you create an extended */
   900                                  
   901 00000221 803E[D6C3]01            		cmp	byte [extended_flag],1
   902 00000226 755F                    		jne	short _main_29
   903                                  
   904                                  ;	if ( (extended_flag == TRUE) && 
   905                                  ;	   ( (cur_disk >= c(1)) ||
   906                                  ;	     (find_partition_type(uc(DOS12))) ||
   907                                  ;	     (find_partition_type(uc(DOS16))) ||
   908                                  ;	     (find_partition_type(uc(DOSNEW))) ) ) 
   909                                  
   910 00000228 803E[D4CB]01            		cmp	byte [cur_disk],1
   911 0000022D 7D15                    		jge	short _main_26
   912                                  
   913 0000022F B001                    		mov	al,DOS12 ; 1
   914                                  		;push	ax
   915 00000231 E8861B                  		call	find_partition_type
   916                                  		;pop	bx
   917                                  		;or	al,al
   918                                  		;jnz	short _main_26
   919 00000234 730E                    		jnc	short _main_26
   920                                  
   921 00000236 B004                    		mov	al,DOS16 ; 4
   922                                  		;push	ax
   923 00000238 E87F1B                  		call	find_partition_type
   924                                  		;pop	bx
   925                                  		;or	al,al
   926                                  		;jnz	short _main_26
   927 0000023B 7307                    		jnc	short _main_26
   928                                  
   929 0000023D B006                    		mov	al,DOSNEW ; 6
   930                                  		;push	ax
   931 0000023F E8781B                  		call	find_partition_type
   932                                  		;pop	bx
   933                                  		;or	al,al
   934                                  		;jz	short _main_29
   935 00000242 7243                    		jc	short _main_29
   936                                  
   937                                  _main_26:
   938                                  ;	;/* Make sure there isn't an extended already there */
   939                                  ;	if (!find_partition_type(uc(EXTENDED))) 
   940                                    
   941 00000244 B005                    		mov	al,EXTENDED ; 5
   942                                  		;push	ax
   943 00000246 E8711B                  		call	find_partition_type
   944                                  		;pop	bx
   945                                  		;or	al,al
   946                                  		;jnz	short _main_29
   947 00000249 733C                    		jnc	short _main_29
   948                                  
   949                                  	; temp = find_part_free_space((char) EXTENDED);
   950                                  	
   951 0000024B B005                    		mov	al,EXTENDED ; 5
   952                                  		;push	ax
   953 0000024D E8444E                  		call	find_part_free_space
   954                                  		;pop	bx
   955                                  		
   956 00000250 A2[0ED0]                		mov	[_temp],al
   957                                  		;mov	al,22
   958                                  		;imul	byte [_temp]
   959 00000253 B316                    		mov	bl,22
   960 00000255 F6E3                    		mul	bl
   961 00000257 89C3                    		mov	bx,ax
   962                                  ;
   963                                  ; if (extended_buff >= free_space[temp].mbytes_unused)
   964                                  ;	input = free_space[temp].space;
   965                                  ; else
   966                                  ; 	input = (unsigned)mbytes_to_cylinders(extended_buff,cur_disk_buff);
   967                                  ; 
   968 00000259 A1[CCC3]                		mov	ax,[extended_buff]
   969                                  		; 13/01/2019
   970 0000025C 3987[E8CB]              		cmp	[free_space.mbytes_unused+bx],ax
   971 00000260 7706                    		ja	short _main_27
   972 00000262 8B87[E2CB]              		mov	ax,[free_space.space+bx]
   973 00000266 EB0B                    		jmp	short _main_28
   974                                  _main_27:
   975 00000268 A0[0FC4]                		mov	al,[cur_disk_buff]
   976 0000026B 50                      		push	ax
   977 0000026C FF36[CCC3]              		push	word [extended_buff]
   978 00000270 E84C54                  		call	mbytes_to_cylinders
   979                                  		;pop	bx
   980                                  		;pop	bx
   981                                  _main_28:
   982                                  ;	make_partition(input,temp,(unsigned char) NUL,(char) EXTENDED)
   983                                  
   984 00000273 A3[10D0]                		mov	[_input],ax
   985 00000276 B005                    		mov	al,EXTENDED ; 5
   986 00000278 50                      		push	ax		; mp_type (byte) - EXTENDED -
   987 00000279 28C0                    		sub	al,al ; 0
   988 0000027B 50                      		push	ax		; mp_bootable (byte) - not bootable -
   989 0000027C A0[0ED0]                		mov	al,[_temp]
   990 0000027F 50                      		push	ax		; mp_free_ptr (byte)
   991 00000280 FF36[10D0]              		push	word [_input]	; mp_size (word)
   992 00000284 E8BF52                  		call	make_partition
   993                                  		;add	sp,8
   994                                  
   995                                  _main_29:
   996                                  ;	;/* If /LOG: was specified, create logical partition */
   997                                  ;
   998                                  ;	   if ( (logical_flag == TRUE) &&
   999                                  ;	        (find_partition_type(uc(EXTENDED))) )
  1000                                  
  1001 00000287 803E[D3C3]01            		cmp	byte [logical_flag],1 ; TRUE
  1002 0000028C 7536                    		jne	short _main_32
  1003 0000028E B005                    		mov	al,EXTENDED ; 5
  1004                                  		;push	ax
  1005 00000290 E8271B                  		call	find_partition_type
  1006                                  		;pop	bx
  1007                                  		;or	al, al
  1008                                  		;jz	short _main_32
  1009 00000293 722F                    		jc	short _main_32
  1010                                  
  1011                                  		; temp = find_ext_free_space();
  1012                                      		
  1013 00000295 E8B754                  		call	find_ext_free_space
  1014 00000298 A2[0ED0]                		mov	[_temp],al
  1015                                  		;mov	al,22
  1016                                  		;imul	byte [_temp]
  1017 0000029B B316                    		mov	bl,22
  1018 0000029D F6E3                    		mul	bl
  1019 0000029F 89C3                    		mov	bx,ax
  1020                                  ;
  1021                                  ; if (logical_buff >= free_space[temp].mbytes_unused)
  1022                                  ;	input = free_space[temp].space;
  1023                                  ; else
  1024                                  ;	input = (unsigned)mbytes_to_cylinders(logical_buff,cur_disk_buff);
  1025                                  ;
  1026 000002A1 A1[D2CB]                		mov	ax,[logical_buff]
  1027                                  		; 13/01/2019
  1028 000002A4 3987[E8CB]              		cmp	[free_space.mbytes_unused+bx],ax
  1029 000002A8 7706                    		ja	short _main_30
  1030 000002AA 8B87[E2CB]              		mov	ax,[free_space.space+bx]
  1031 000002AE EB0B                    		jmp	short _main_31
  1032                                  _main_30:
  1033 000002B0 A0[0FC4]                		mov	al,[cur_disk_buff]
  1034 000002B3 50                      		push	ax
  1035 000002B4 FF36[D2CB]              		push	word [logical_buff]
  1036 000002B8 E80454                  		call	mbytes_to_cylinders
  1037                                  		;pop	bx
  1038                                  		;pop	bx
  1039                                  _main_31:
  1040                                  		;mov	[_input],ax
  1041                                  
  1042                                  		; make_volume(input,temp);  
  1043                                  
  1044                                  		;mov	al,[_temp]
  1045                                  		;push	ax
  1046 000002BB 8A1E[0ED0]              		mov	bl,[_temp]
  1047 000002BF 53                      		push	bx
  1048                                  		;push	word [_input]
  1049 000002C0 50                      		push	ax
  1050 000002C1 E8F456                  		call	make_volume
  1051                                  		;pop	bx
  1052                                  		;pop	bx
  1053                                  _main_32:
  1054 000002C4 E8FA33                  		call	write_info_to_disk
  1055                                  _main_33:
  1056 000002C7 C606[D4CB]00            		mov	byte [cur_disk],0
  1057                                  
  1058                                  ;  if ( (quiet_flag == TRUE) &&
  1059                                  ;	(!find_partition_type(uc(DOS12))) &&
  1060                                  ;	(!find_partition_type(uc(DOS16))) &&
  1061                                  ;	(!find_partition_type(uc(DOSNEW))) )  
  1062                                  
  1063 000002CC 803E[40A1]01            		cmp	byte [quiet_flag],1
  1064                                  		;jne	short _main_34
  1065 000002D1 7534                    		jne	short _main_35
  1066                                  
  1067 000002D3 B001                    		mov	al,DOS12 ; 1
  1068                                  		;push	ax
  1069 000002D5 E8E21A                  		call	find_partition_type
  1070                                  		;pop	bx
  1071                                  		;or	al,al
  1072                                  		;jnz	short _main_34
  1073 000002D8 7313                    		jnc	short _main_34
  1074                                  		
  1075 000002DA B004                    		mov	al,DOS16 ; 4
  1076                                  		;push	ax
  1077 000002DC E8DB1A                  		call	find_partition_type
  1078                                  		;pop	bx
  1079                                  		;or	al,al
  1080                                  		;jnz	short _main_34
  1081 000002DF 730C                    		jnc	short _main_34
  1082                                  		
  1083 000002E1 B006                    		mov	al,DOSNEW ; 6
  1084                                  		;push	ax
  1085 000002E3 E8D41A                  		call	find_partition_type
  1086                                  		;pop	bx
  1087                                  		;or	al,al
  1088                                  		;jnz	short _main_34
  1089 000002E6 7305                    		jnc	short _main_34
  1090                                  
  1091                                  		; exit(ERR_LEVEL_1);
  1092 000002E8 B80100                  		mov	ax,1
  1093 000002EB EB1C                    		jmp	short _main_36
  1094                                  _main_34:
  1095                                  ;  else
  1096                                  	; if ((quiet_flag == TRUE) && 
  1097                                  	;     (primary_flag == FALSE) && 
  1098                                  	;     (extended_flag == FALSE) && 
  1099                                  	;     (logical_flag == FALSE))   
  1100                                  
  1101                                  		;cmp	byte [quiet_flag],1
  1102                                  		;jne	short _main_35
  1103                                  
  1104 000002ED 803E[00A1]00            		cmp	byte [primary_flag],0
  1105 000002F2 7513                    		jne	short _main_35
  1106 000002F4 803E[D6C3]00            		cmp	byte [extended_flag],0
  1107 000002F9 750C                    		jne	short _main_35
  1108 000002FB 803E[D3C3]00            		cmp	byte [logical_flag],0
  1109 00000300 7505                    		jne	short _main_35
  1110                                  
  1111                                  		; exit(ERR_LEVEL_2);
  1112 00000302 B80200                  		mov	ax,2
  1113 00000305 EB02                    		jmp	short _main_36
  1114                                  _main_35:
  1115                                  	; else	
  1116                                  		; exit(ERR_LEVEL_0);
  1117 00000307 29C0                    		sub	ax,ax
  1118                                  _main_36:
  1119                                  		;push	ax
  1120                                  		;call	_exit
  1121                                  		;pop	bx
  1122                                  		
  1123                                  		;mov	sp,bp
  1124                                  		;pop	bp
  1125                                  
  1126 00000309 C3                      		retn	; Return to '_astart:', '_exit:' address.
  1127                                  
  1128                                  ; ----------------------------------------------------------------------------
  1129                                  ; Microsoft (Optimizing) C 6.0 - STDARGV.ASM
  1130                                  ; ----------------------------------------------------------------------------
  1131                                  ; Modified for NASM syntax & single C/D/S segment (by Erdogan Tan, 07/11/2018)
  1132                                  
  1133                                  ;*****************************************************************************
  1134                                  ;stdargv.asm - standard & wildcard _setargv routine
  1135                                  ;
  1136                                  ;	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
  1137                                  ;
  1138                                  ;Purpose:
  1139                                  ;	processes program command line, with or without wildcard expansion
  1140                                  ;
  1141                                  ;*****************************************************************************
  1142                                  
  1143                                  ;_setargv, __setargv - set up "argc" and "argv" for C programs
  1144                                  ;
  1145                                  ;Purpose:
  1146                                  ;	Gets the command line from the PSP and moves the information
  1147                                  ;	to its place on the stack.
  1148                                  ;
  1149                                  ;	SIDE EFFECTS:
  1150                                  ;		Allocates space on the stack for the argument strings
  1151                                  ;		and a list of pointers to them.
  1152                                  ;	ASSUMPTIONS:
  1153                                  ;		Under DOS 2, there is no argv[0] string, so we store a null
  1154                                  ;		char ('\0').
  1155                                  ;
  1156                                  ;		Under DOS 3 and later, the argv[0] string is found in the
  1157                                  ;		environment segment, after the double null that terminates
  1158                                  ;		that segment and after a word of value 1.  The rest of the
  1159                                  ;		command line is found in the Program Segment Prefix at
  1160                                  ;		offset 81H, and is terminated by a 0DH.  This command "tail"
  1161                                  ;		cannot be greater than 126 bytes in length.
  1162                                  ;
  1163                                  ;		Quote marks and backslashes are treated specially.  A quoted
  1164                                  ;		string is passed as a single argument, not including the
  1165                                  ;		opening and closing quote characters.  A quote may be imbedded
  1166                                  ;		in a string by placing an odd number of backslashes (`\')
  1167                                  ;		before it.  Each pair of backslashes which precedes a quote
  1168                                  ;		results in a single backslash in the resultant string.
  1169                                  ;		An even number of backslashes followed by a quote results in
  1170                                  ;		half that many backslashes, and the quote begins or ends the
  1171                                  ;		quoted part of the string as is appropriate.  Backslashes not
  1172                                  ;		followed by a quote are treated normally.
  1173                                  ;
  1174                                  ;		[""] ==> []
  1175                                  ;		[\"] ==> ["]
  1176                                  ;		[" \" "] == [ " ]
  1177                                  ;		[" \\"] == [ \]
  1178                                  ;		[" \\ "] == [ \\ ]
  1179                                  ;		[" \\\" "] == [ \" ]
  1180                                  ;		etc.
  1181                                  ;		["one two three"] ==> [one two three]
  1182                                  ;		[one" two "three] ==> [one two three]
  1183                                  ;		[o"ne two t"hree] ==> [one two three]
  1184                                  ;		["one \"two\" three"] ==> [one "two" three]
  1185                                  ;		["x\\\"x"] ==> [x\"x]
  1186                                  ;
  1187                                  ;Entry:
  1188                                  ;
  1189                                  ;Exit:
  1190                                  ;	"argv" points to a null-terminated list of pointers to ASCIZ
  1191                                  ;	strings, each of which is an argument from the command line.
  1192                                  ;	"argc" is the number of arguments.  The strings are copied from
  1193                                  ;	the Program Segment Prefix into space allocated on the stack.
  1194                                  ;	The list of pointers is also located on the stack.
  1195                                  ;
  1196                                  ;Uses:
  1197                                  ;	All registers except DS, SS, and BP are modified
  1198                                  ;	Note especially that SI and DI are NOT preserved!
  1199                                  ;
  1200                                  ;Exceptions:
  1201                                  ;
  1202                                  ;*****************************************************************************
  1203                                  
  1204                                  ;_setargv:
  1205                                  ;		DOS_envp equ 2Ch	
  1206                                  ;
  1207                                  ;		pop	word [retadr]	; get return address (offset)
  1208                                  ;
  1209                                  ;; Check and store DOS version. This is done here because it cannot be done
  1210                                  ;; in CRT0.ASM (Windows replaces CRT0.ASM with their own code) and _setargv()
  1211                                  ;; is the only other place in the startup code where the DOS version number
  1212                                  ;; needed.
  1213                                  ;
  1214                                  ;		;mov	ah,30h
  1215                                  ;		;int	21h ; DOS - GET DOS VERSION
  1216                                  ;			 ; Return: AL = major version number (00h for DOS 1.x)
  1217                                  ;		;mov	word [_dosvermajor],ax	
  1218                                  ;		;mov	dx,1	 ; dx = number of bytes in argv[0] if DOS 2.x
  1219                                  ;		;cmp	al,2
  1220                                  ;		;jz	short dos_two
  1221                                  ;
  1222                                  ;		;mov	es,[_psp]
  1223                                  ;	
  1224                                  ;		; get environment segment
  1225                                  ;		;mov	es,[es:DOS_envp] ; [es:2Ch]
  1226                                  ;		;mov	[_pgmptr+2],es	; set global variable "_pgmptr"
  1227                                  ;
  1228                                  ;		mov	ax,[DOS_envp]	; [2Ch] 
  1229                                  ;		mov	[_pgmptr+2],ax
  1230                                  ;
  1231                                  ;		; Erdogan Tan - 07/11/2018
  1232                                  ;		mov	bx,ds ; *
  1233                                  ;		mov	es,ax
  1234                                  ;
  1235                                  ;		xor	ax,ax
  1236                                  ;		cwd
  1237                                  ;		mov	cx,8000h
  1238                                  ;		xor	di,di;		; scan from beginning of environment
  1239                                  ;find_env_end:
  1240                                  ;		repne scasb
  1241                                  ;		scasb
  1242                                  ;		jnz	short find_env_end
  1243                                  ;		inc	di;		; skip count word (always 0x0001)
  1244                                  ;		inc	di
  1245                                  ;		mov	[_pgmptr], di	; set global variable "_pgmptr"
  1246                                  ;		mov	cx,0FFFFh
  1247                                  ;		repne scasb
  1248                                  ;		not	cx
  1249                                  ;		mov	dx,cx;		; DX=number of bytes in argv[0]
  1250                                  ;dos_two:
  1251                                  ;		mov	di,1;		; always start with one argument
  1252                                  ;		mov	si,81h
  1253                                  ;
  1254                                  ;		;mov	ds,[_psp]
  1255                                  ;arg100:
  1256                                  ;
  1257                                  ;;*	Count the command tail arguments
  1258                                  ;;*
  1259                                  ;;
  1260                                  ;;	DI will count the number of arguments
  1261                                  ;;	DX will count the number of bytes needed for the arguments
  1262                                  ;;		(not including the null terminators)
  1263                                  ;
  1264                                  ;arg110:
  1265                                  ;		lodsb
  1266                                  ;		cmp	al,' '	; 20h	; C_BLANK  ; space chr
  1267                                  ;		jz	short arg110
  1268                                  ;		cmp	al,9	; TAB	; C_TAB
  1269                                  ;		jz	short arg110	
  1270                                  ;
  1271                                  ;		;DELIM	arg400;		
  1272                                  ;
  1273                                  ;		cmp	al,0Dh	;  CR	; ENTER
  1274                                  ;		jz	short arg400
  1275                                  ;		or	al,al	; 0 = ASCIIZ string terminator (ZERO chr)
  1276                                  ;		jz	short arg400
  1277                                  ;
  1278                                  ; ----------------------------------------------------------------------------
  1279                                  ; psdata.inc (FDISK, MSDOS 6.0, 1991)	
  1280                                  ; ----------------------------------------------------------------------------
  1281                                  ; 10/11/2018
  1282                                  
  1283                                  ;*******************************************************************
  1284                                  ; Parser include file
  1285                                  ;*******************************************************************
  1286                                  
  1287                                  ;**** Equation field
  1288                                  ;-------- Character code definition
  1289                                  
  1290                                  ; version.inc (	ifndef DBCS)
  1291                                  DB_SPACE EQU 2020h
  1292                                  DB_SP_HI EQU 20h
  1293                                  DB_SP_LO EQU 20h
  1294                                  
  1295                                  _$P_DBSP1	   equ	DB_SP_HI	; 1st byte of DBCS blank
  1296                                  _$P_DBSP2	   equ	DB_SP_LO	; 2nd byte of DBCS blank
  1297                                  _$P_Period	   equ	"."             ;
  1298                                  _$P_Slash	   equ	"/"             ;
  1299                                  _$P_Space	   equ	" "             ; SBCS blank
  1300                                  _$P_Comma	   equ	","             ;
  1301                                  _$P_Switch	   equ	"/"             ;
  1302                                  _$P_Keyword	   equ	"="             ;
  1303                                  _$P_Colon	   equ	":"             ;
  1304                                  _$P_Plus 	   equ	"+"             ;
  1305                                  _$P_Minus	   equ	"-"             ;
  1306                                  _$P_Rparen	   equ	")"             ;
  1307                                  _$P_Lparen	   equ	"("             ;
  1308                                  ;_$P_SQuote	   equ  "'"		; Deleted
  1309                                  _$P_DQuote	   equ	'"'             ;
  1310                                  _$P_NULL 	   equ	0		;
  1311                                  _$P_TAB		   equ	9		;
  1312                                  _$P_CR		   equ	0Dh		;
  1313                                  _$P_LF		   equ	0Ah		;
  1314                                  _$P_ASCII80	   equ	80h		; ASCII 80h character code
  1315                                  
  1316                                  ;-------- Masks
  1317                                  _$P_Make_Lower	   equ	20h		; make lower case character
  1318                                  _$P_Make_Upper	   equ	0FFh-_$P_Make_Lower ; make upper case character
  1319                                  
  1320                                  ;-------- DOS function call related equs
  1321                                  
  1322                                  _$P_DOS_Get_CDI	   equ	3800h		; get country dependent information
  1323                                  					; by this call, following information
  1324                                  struc _$P_CDI	; _$P_CDI		; is returned.
  1325 00000000 <res 00000002>          .DateF:	   resw 1			;
  1326 00000002 <res 00000005>          .Money:	   resb	5			;
  1327 00000007 <res 00000002>          .1000:	   resb	2			;
  1328 00000009 <res 00000002>          .Dec:	   resb 2			;
  1329 0000000B <res 00000002>          .DateS:	   resb 2			;
  1330 0000000D <res 00000002>          .TimeS:	   resb	2			;
  1331 0000000F <res 00000001>          	   resb 1			;
  1332 00000010 <res 00000001>          	   resb 1			;
  1333 00000011 <res 00000001>          .TimeF:	   resb 1			;
  1334 00000012 <res 00000004>          	   resw	2			;
  1335 00000016 <res 00000002>          	   resb 2			;
  1336 00000018 <res 00000005>          	   resb	5			;
  1337                                  .size:
  1338                                  endstruc
  1339                                  
  1340                                  _$P_Date_MDY	   equ	0		;
  1341                                  _$P_Date_DMY	   equ	1		;
  1342                                  _$P_Date_YMD	   equ	2		;
  1343                                  ;-------------
  1344                                  _$P_DOS_GetEV	   equ	6300h		; get DBCS EV call
  1345                                  					; DS:SI will points to DBCS EV
  1346                                  ;-------------
  1347                                  _$P_DOS_Get_TBL	   equ	65h		; get uppercase table call
  1348                                  					; following parameters are set
  1349                                  					; to get casemap table.
  1350                                  _$P_DOSTBL_Def	   equ	-1		; get default
  1351                                  _$P_DOSTBL_BL	   equ	5		; buffer length for Tbl pointer
  1352                                  _$P_DOSTBL_File	   equ	4		; get file uppercase table
  1353                                  _$P_DOSTBL_Char	   equ	2		; get character uppercase table
  1354                                  					; By this call following information
  1355                                  					; is returned.
  1356                                  struc _$P_DOS_TBL
  1357 00000000 <res 00000001>          .InfoID:   resb 1			; information id for the table
  1358 00000001 <res 00000002>          .Off:	   resw 1			; offset address of the table
  1359 00000003 <res 00000002>          .Seg:	   resw 1			; segment address of the table
  1360                                  .size:
  1361                                  endstruc
  1362                                  
  1363                                  ; ----------------------------------------------------------------------------------
  1364                                  ; PARMS 	LABEL	BYTE
  1365                                  ;		DW	PARMSX
  1366                                  ;		DB	2		; NUMBER OF STRINGS (0, 1, 2)
  1367                                  ;		DB	length		; LENGTH OF THE NEXT LIST, 0 IF NONE
  1368                                  ;		DB	" .. "		; EXTRA DELIMITER LIST,
  1369                                  ;					; TYPICAL ARE ";", "="
  1370                                  ;					; "," & WHITESPACE ALWAYS
  1371                                  ;		DB	length		; LENGTH OF THE NEXT LIST, 0 IF NONE
  1372                                  ;		DB	" .. "		; EXTRA END OF LINE LIST, CR, LF OR 0 ALWAYS
  1373                                  ; ----------------------------------------------------------------------------------
  1374                                  
  1375                                  ;-------------------------------- PARMS block structure
  1376                                  struc _$P_PARMS	; _$P_PARMS_Blk
  1377 00000000 <res 00000002>          .PARMSX_Address:  resw 1		; Address of PARMSX
  1378 00000002 <res 00000001>          .Num_Extra:	  resb 1		; Number of extra stuff
  1379 00000003 <res 00000001>          .Len_Extra_Delim: resb 1		; Length of extra delimiter
  1380                                  .size:
  1381                                  endstruc
  1382                                  
  1383                                  _$P_Len_PARMS	   equ	4		;
  1384                                  _$P_I_Use_Default   equ	0		; no extra stuff specified
  1385                                  _$P_I_Have_Delim    equ	1		; extra delimiter specified
  1386                                  _$P_I_Have_EOL	   equ	2		; extra EOL specified
  1387                                  
  1388                                  ; ----------------------------------------------------------------------------------
  1389                                  ; PARMSX	LABEL	BYTE
  1390                                  ;		DB	minp,maxp	; MIN, MAX POSITIONAL OPERANDS ALLOWED
  1391                                  ;		DW	CONTROL 	; DESCRIPTION OF POSITIONAL 1
  1392                                  ;		:			; REPEATS maxp-1 TIMES
  1393                                  ;		DB	maxs		; # OF SWITCHES
  1394                                  ;		DW	CONTROL 	; DESCRIPTION OF SWITCH 1
  1395                                  ;		:			; REPEATS maxs-1 TIMES
  1396                                  ;		DB	maxk		; # OF KEYWORD
  1397                                  ;		DW	CONTROL 	; DESCRIPTION OF KEYWORD 1
  1398                                  ;		:			; REPEATS maxk-1 TIMES
  1399                                  ; ----------------------------------------------------------------------------------
  1400                                  
  1401                                  ;-------------------------------- PARMSX block structure
  1402                                  struc _$P_PARMSX ; _$P_PARMSX_Blk		;
  1403 00000000 <res 00000001>          .MinP:	      resb 1			; Minimum positional number
  1404 00000001 <res 00000001>          .Maxp:	      resb 1			; Maximum positional number
  1405 00000002 <res 00000002>          .1st_Control: resw 1			; Address of the 1st CONTROL block
  1406                                  .size:
  1407                                  endstruc
  1408                                  
  1409                                  ;--------------------------------------------------------------------------------------------
  1410                                  ; << Control field definition  >>
  1411                                  ;
  1412                                  ;CONTROL   LABEL   BYTE
  1413                                  ;	   DW	   MATCH_FLAGS	   ; CONTROLS TYPE MATCHED
  1414                                  ;				   ; 8000H=NUMERIC VALUE, (VALUE LIST WILL BE CHECKED)
  1415                                  ;				   ; 4000H=SIGNED NUMERIC VALUE (VALUE LIST WILL BE CHECKED)
  1416                                  ;				   ; 2000H=SIMPLE STRING(VALUE LIST WILL BE CHECKED)
  1417                                  ;				   ; 1000H=DATE STRING (VALUE LIST WON'T BE CHECKED)
  1418                                  ;				   ; 0800H=TIME STRING (VALUE LIST WON'T BE CHECKED)
  1419                                  ;				   ; 0400H=COMPLEX LIST (VALUE LIST WON'T BE CHECKED)
  1420                                  ;				   ; 0200H=FILE SPEC (VALUE LIST WON'T BE CHECKED)
  1421                                  ;				   ; 0100H=DRIVE ONLY (VALUE LIST WON'T BE CHECKED)
  1422                                  ;				   ; 0080H=QUOTED STRING (VALUE LIST WON'T BE CHECKED)
  1423                                  ;				   ; 0010H=IGNORE ":" AT END IN MATCH
  1424                                  ;				   ; 0002H=REPEATS ALLOWED
  1425                                  ;				   ; 0001H=OPTIONAL
  1426                                  ;	   DW	   FUNCTION_FLAGS
  1427                                  ;				   ; 0001H=CAP RESULT BY FILE TABLE
  1428                                  ;				   ; 0002H=CAP RESULT BY CHAR TABLE
  1429                                  ;				   ; 0010H=REMOVE ":" AT END
  1430                                  ;				   ; 0020H=colon is not necessary for switch
  1431                                  ;	   DW	   RESULT	   ; RESULT BUFFER
  1432                                  ;	   DW	   VALUES	   ; VALUE LISTS
  1433                                  ;	   DB	   nid		   ; NUMBER OF KEYWORD/SWITCH SYNONYMS IN FOLLOWING LIST
  1434                                  ;	   DB	   "...",0         ; IF n >0, KEYWORD 1
  1435                                  ;	   :
  1436                                  ;
  1437                                  ;Note:
  1438                                  ;    - The MATCH_FLAG is bit significant. You can set, for example, TIME bit and
  1439                                  ;      DATE bit simalteniously.
  1440                                  ;
  1441                                  ;      The parser examins each bit along with the following priority.
  1442                                  ;
  1443                                  ;      COMPLEX -> DATE -> TIME -> NUMERIC VAL -> SIGNED NUMERIC VAL -> DRIVE ->
  1444                                  ;      FILE SPEC -> SIMPLE STRING.
  1445                                  ;
  1446                                  ;
  1447                                  ;    - When the FUNCTION_FLAG is 0001 or 0002, the STRING pointed to by a pointer
  1448                                  ;      in the result buffer is capitalized.
  1449                                  ;
  1450                                  ;    - Match_Flags 0001H and 0002H have meaning only for the positional.
  1451                                  ;
  1452                                  ;
  1453                                  ;    - The "...",0 (bottom most line) does require '=' or '/'. When you need a
  1454                                  ;      switch, for example, '/A', then STRING points to;
  1455                                  ;
  1456                                  ;			DB    1 	; number of following synonyms
  1457                                  ;			DB   '/A',0
  1458                                  ;
  1459                                  ;      When you need a keyword, for example, 'CODEPAGE=', then "...",0 will be;
  1460                                  ;
  1461                                  ;			DB    1 	; number of following synonyms
  1462                                  ;			DB   'CODEPAGE=',0
  1463                                  ;
  1464                                  ;
  1465                                  ;    - "..." must consist of upper case characters only because the parser
  1466                                  ;      performs pattern matching after converting input to upper case (by
  1467                                  ;      using the current country upper case table)
  1468                                  ;
  1469                                  ;
  1470                                  ;    - One "..." can contain only one switch or keyword. If you need, for
  1471                                  ;      example /A and /B, the format will be;
  1472                                  ;
  1473                                  ;			DB    2 	; number of following synonyms
  1474                                  ;			DB    '/A',0
  1475                                  ;			DB    '/B',0
  1476                                  ;--------------------------------------------------------------------------------------------
  1477                                  
  1478                                  ;**** Match_Flags
  1479                                  
  1480                                  _$P_Num_Val	   equ	8000h		; Numeric Value
  1481                                  _$P_SNum_Val	   equ	4000h		; Signed numeric value
  1482                                  _$P_Simple_S	   equ	2000h		; Simple string
  1483                                  _$P_Date_S	   equ	1000h		; Date string
  1484                                  _$P_Time_S	   equ	0800h		; Time string
  1485                                  _$P_Cmpx_S	   equ	0400h		; Complex string
  1486                                  _$P_File_Spc	   equ	0200h		; File Spec
  1487                                  _$P_Drv_Only	   equ	0100h		; Drive Only
  1488                                  _$P_Qu_String	   equ	0080h		; Quoted string
  1489                                  _$P_Ig_Colon	   equ	0010h		; Ignore colon at end in match
  1490                                  _$P_Repeat	   equ	0002h		; Repeat allowed
  1491                                  _$P_Optional	   equ	0001h		; Optional
  1492                                  
  1493                                  ;**** Function flags
  1494                                  
  1495                                  _$P_CAP_File	   equ	0001h		; CAP result by file table
  1496                                  _$P_CAP_Char	   equ	0002h		; CAP result by character table
  1497                                  _$P_Rm_Colon	   equ	0010h		; Remove ":" at the end
  1498                                  _$P_colon_is_not_necessary equ 0020h	; /+10 and /+:10
  1499                                  
  1500                                  ;-------------------------------- Control block structure
  1501                                  struc _$P_Control_Blk ; _$P_Control_Blk
  1502 00000000 <res 00000002>          .Match_Flag:	resw 1		; Controls type matched
  1503 00000002 <res 00000002>          .Function_Flag: resw 1		; Function should be taken
  1504 00000004 <res 00000002>          .Result_Buf:	resw 1		; Result buffer address
  1505 00000006 <res 00000002>          .Value_List:	resw 1		; Value list address
  1506 00000008 <res 00000001>          .nid:		resb 1		; # of keyword/SW synonyms
  1507 00000009 <res 00000001>          .KeyorSW:	resb 1		; keyword or sw
  1508                                  .size:
  1509                                  endstruc
  1510                                  
  1511                                  ; -------------------------------------------------------------------------------
  1512                                  ; << Value List Definition >>
  1513                                  ;
  1514                                  ;VALUES 	LABEL	BYTE
  1515                                  ;		DB	nval		; NUMBER OF VALUE DEFINITIONS (0 - 3)
  1516                                  ;	     +-
  1517                                  ;	     |	DB	nrng		; NUMBER OF RANGES
  1518                                  ;	     | +DB	ITEM_TAG	; RETURN VALUE IF RANGE MATCHED
  1519                                  ;	     | +DD	X,Y		; RANGE OF VALUES
  1520                                  ;	     |	:
  1521                                  ;	     |	DB	nnval		; NUMBER OF CHOICES
  1522                                  ;	     | +DB	ITEM_TAG	; RETURN VALUE IF NUMBER CHOICE MATCHED
  1523                                  ;	     | +DD	VALUE		; SPECIFIC CHOICE IF NUMBER
  1524                                  ;	     |	:
  1525                                  ;	     |	DB	nstrval 	; NUMBER OF CHOICES
  1526                                  ;	     | +DB	ITEM_TAG	; RETURN VALUE IF STRING CHOICE MATCHED
  1527                                  ;	     | +DW	STRING		; SPECIFIC CHOICE IF STING
  1528                                  ;	     +-	:
  1529                                  ;
  1530                                  ;STRING 	DB	"...",0		; ASCIIZ STRING IMAGE
  1531                                  ;
  1532                                  ;Note:
  1533                                  ;    - ITEM_TAG must not be 0FFH, which will be used in the result buffer
  1534                                  ;      when no choice lists are provided.
  1535                                  ;
  1536                                  ;    - STRING must consist of upper case characters only because the parser
  1537                                  ;      performs pattern matching after converting input to upper case (by
  1538                                  ;      using the current country upper case table)
  1539                                  ; -------------------------------------------------------------------------------
  1540                                  
  1541                                  _$P_nval_None	   equ	0		; no value list ID
  1542                                  _$P_nval_Range	   equ	1		; range list ID
  1543                                  _$P_nval_Value	   equ	2		; value list ID
  1544                                  _$P_nval_String	   equ	3		; string list ID
  1545                                  _$P_Len_Range	   equ	9		; Length of a range choice(two DD plus one DB)
  1546                                  _$P_Len_Value	   equ	5		; Length of a value choice(one DD plus one DB)
  1547                                  _$P_Len_String	   equ	3		; Length of a string choice(one DW plus one DB)
  1548                                  _$P_No_nrng	   equ	0		; (tm07) no nrng. nnval must not be 0.
  1549                                  
  1550                                  struc _$P_Val_List ; _$P_Val_List
  1551 00000000 <res 00000001>          .NumofList: resb 1		; number of following choice
  1552 00000001 <res 00000002>          .Val_XL:    resw 1		; lower word of value
  1553 00000003 <res 00000002>          .Val_XH:    resw 1		; higher word of value
  1554 00000005 <res 00000002>          .Val_YL:    resw 1		; lower word of another value
  1555 00000007 <res 00000002>          .Val_YH:    resw 1		; higher word of another value
  1556                                  .size:
  1557                                  endstruc
  1558                                  
  1559                                  ;----------------------------------------------------------------------------------------------------------------
  1560                                  ; << Result Buffer Definition  >>
  1561                                  ;
  1562                                  ;RESULT 	LABEL	BYTE			; BELOW FILLED IN FOR DEFAULTS
  1563                                  ;		DB	type			; TYPE RETURNED: 0=RESERVED,
  1564                                  ;						;	1=NUMBER, 2=LIST INDEX,
  1565                                  ;						;	3=STRING, 4=COMPLEX,
  1566                                  ;						;	5=FILESPEC, 6=DRIVE
  1567                                  ;						;	7=DATE, 8=TIME
  1568                                  ;						;	9=QUOTED STRING
  1569                                  ;		DB	ITEM_TAG		; MATCHED ITEM TAG
  1570                                  ;
  1571                                  ;		dw	synonym@		; es:@ points to found SYNONYM if provided.
  1572                                  ;
  1573                                  ;            +-
  1574                                  ;	    | DD	n			; VALUE IF NUMBER
  1575                                  ;	    | or
  1576                                  ;	    |	DW	i			; INDEX (OFFSET) INTO VALUE LIST
  1577                                  ;	    |					; (ES presents Segment address)
  1578                                  ;	    | or
  1579                                  ;	    |	DD	STRING			; OFFSET OF STRING VALUE
  1580                                  ;	    | or
  1581                                  ;	    |	DB	drv			; DRIVE NUMBER (1-A, 2-B,..., 26-Z)
  1582                                  ;	    | or
  1583                                  ;	    |	DW	YEAR	   ;(1980-2099)	IN CASE OF DATE
  1584                                  ;	    |	DB	MONTH	   ;(1-12)	Note: Range check is not performed.
  1585                                  ;	    |	DB	DATE	   ;(1-31)	      0 is filled when the corresponding field was not specified.
  1586                                  ;	    | or
  1587                                  ;	    |	DB	HOUR	   ;(0-23)	IN CASE OF TIME
  1588                                  ;	    |	DB	MINUTES    ;(0-59)	Note: Range check is not performed .
  1589                                  ;	    |	DB	SECONDS    ;(0-59)	      0 is filled when the corresponding field was not specified.
  1590                                  ;	    |	DB	HUNDREDTHS ;(0-99)
  1591                                  ;	    +-
  1592                                  ;
  1593                                  ;Note: ITEM_TAG is 0FFH when the caller does not specify the choice list.
  1594                                  ;
  1595                                  ;      YEAR: If the input value for the year is less than 100, parser
  1596                                  ;	     adds 1900 to it. For example, when 87 is input to parser for
  1597                                  ;	     the year value, he returns 1987.
  1598                                  ;----------------------------------------------------------------------------------------------------------------
  1599                                  
  1600                                  ;-------------------------------- Result block structure
  1601                                  struc _$P_Result ; _$P_Result_Blk
  1602 00000000 <res 00000001>          .Type:	      resb 1		; Type returned
  1603 00000001 <res 00000001>          .Item_Tag:    resb 1		; Matched item tag
  1604 00000002 <res 00000002>          .SYNONYM_Ptr: resw 1		; pointer to Synonym list returned
  1605 00000004 <res 00000004>          .Picked_Val:  resb 4		; value
  1606                                  .size:
  1607                                  endstruc
  1608                                  
  1609                                  ;--------------------------------
  1610                                  ;**** values for the type field in the result block
  1611                                  
  1612                                  _$P_EOL		   equ	0		; End of line
  1613                                  _$P_Number	   equ	1		; Number
  1614                                  _$P_List_Idx	   equ	2		; List Index
  1615                                  _$P_String	   equ	3		; String
  1616                                  _$P_Complex	   equ	4		; Complex
  1617                                  _$P_File_Spec	   equ	5		; File Spec
  1618                                  _$P_Drive	   equ	6		; Drive
  1619                                  _$P_Date_F	   equ	7		; Date
  1620                                  _$P_Time_F	   equ	8		; Time
  1621                                  _$P_Quoted_String   equ	9		; Quoted String
  1622                                  
  1623                                  _$P_No_Tag	   equ	0FFH		; No ITEM_TAG found
  1624                                  
  1625                                  ;**** Return code
  1626                                  ;
  1627                                  ; following return code will be returned in the AX register.
  1628                                  
  1629                                  _$P_No_Error	   equ	0		; No error
  1630                                  _$P_Too_Many	   equ	1		; Too many operands
  1631                                  _$P_Op_Missing	   equ	2		; Required operand missing
  1632                                  _$P_Not_In_SW	   equ	3		; Not in switch list provided
  1633                                  _$P_Not_In_Key	   equ	4		; Not in keyword list provided
  1634                                  _$P_Out_Of_Range   equ	6		; Out of range specified
  1635                                  _$P_Not_In_Val	   equ	7		; Not in value list provided
  1636                                  _$P_Not_In_Str	   equ	8		; Not in string list provided
  1637                                  _$P_Syntax	   equ	9		; Syntax error
  1638                                  _$P_RC_EOL	   equ	-1		; End of command line
  1639                                  
  1640                                  _$P_equ		   equ	01h		; "=" packed in string buffet
  1641                                  _$P_Neg		   equ	02h		; Negative value
  1642                                  _$P_Time12	   equ	04h		; set when PM is specified
  1643                                  _$P_Key_Cmp	   equ	08h		; set when keyword compare
  1644                                  _$P_SW_Cmp	   equ	10h		; set when switch compare
  1645                                  _$P_Extra	   equ	20h		; set when extra delimiter found
  1646                                  _$P_SW		   equ	40h		; set when switch found (tm08)
  1647                                  _$P_Signed	   equ	80h		; signed numeric specified
  1648                                  
  1649                                  _$P_NeedToBeRead    equ	0FFFFh		;
  1650                                  
  1651                                  ; delimiter parsing
  1652                                  _$P_colon_period    equ	01		; check for colon & period
  1653                                  _$P_period_only	   equ	02		; check only for period
  1654                                  
  1655                                  _$P_error_filespec  equ	01		; mask to set flag
  1656                                  
  1657                                  ;***********************************************************************
  1658                                  
  1659                                  ; ----------------------------------------------------------------------------
  1660                                  ; fdparse.c (FDISK, MSDOS 6.0, 1991)	
  1661                                  ; ----------------------------------------------------------------------------
  1662                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 07/11/2018)
  1663                                  
  1664                                  ;/*  */
  1665                                  ;/******************************************************************************/
  1666                                  ;/*Routine name:  PARSE_COMMAND_LINE                                           */
  1667                                  ;/******************************************************************************/
  1668                                  ;/*                                                                            */
  1669                                  ;/*Description:   Sets up flags, preloads messages, and parses the command     */
  1670                                  ;/*               line for switchs.                                            */
  1671                                  ;/*                                                                            */
  1672                                  ;/*Called Procedures:                                                          */
  1673                                  ;/*                                                                            */
  1674                                  ;/*Change History: Created        5/30/87         DRM                          */
  1675                                  ;/*                                                                            */
  1676                                  ;/*Input: None                                                                 */
  1677                                  ;/*                                                                            */
  1678                                  ;/*Output: None                                                                */
  1679                                  ;/*                                                                            */
  1680                                  ;/******************************************************************************/
  1681                                  
  1682                                  ;char parse_command_line(argc,argv)
  1683                                  
  1684                                  ;char *argv[];  ; [bp+6]                 ;/* array of pointer arguments */
  1685                                  ;int  argc;	; [bp+4]
  1686                                  
  1687                                  parse_command_line:
  1688                                  	
  1689                                  	;char	cmd_line[128];  ; [bp-86h]
  1690                                          ;char	finished;	; [bp-6]
  1691                                          ;int	i;		; [bp-4]
  1692                                          ;char	parse_good;	; [bp-2]
  1693                                          ;char	far *cmdline;	; [bp-8Ah]
  1694                                  
  1695                                  		;%define cmd_line   bp-134
  1696                                  		;%define finished   bp-6
  1697                                  		;%define i	    bp-4
  1698                                  		;%define parse_good bp-2
  1699                                  		;%define cmdlineptr bp-138
  1700                                  
  1701                                  		; 11/11/2018
  1702                                  		%define cmd_line   bp-128
  1703                                  
  1704                                  		;push	bp
  1705 0000030A 89E5                    		mov	bp,sp
  1706                                  		
  1707                                  		;sub	sp,138 ; 11/11/2018
  1708                                  
  1709 0000030C 81EC8000                		sub	sp,128 ; 11/11/2018		
  1710                                  		
  1711                                  		;push	si
  1712                                  
  1713 00000310 E85300                  		call	parse_init
  1714                                  		;mov	byte [parse_good],1 ; TRUE ; 11/11/2018
  1715                                  
  1716                                  		; Get PSP address
  1717                                  		;mov	ah,62h
  1718                                  		;int	21h
  1719                                  			; Return:
  1720                                  			; BX = segment address of current process
  1721                                  		;mov	word [cmdlineptr],81h
  1722                                  		;;mov	[cmdlineptr+2],bx
  1723                                  		;mov	[cmdlineptr+2],ds
  1724 00000313 BE8100                  		mov	si,81h	; command tail offset
  1725                                  
  1726                                  		;mov	word [i],0
  1727 00000316 8D7E80                  		lea	di,[cmd_line]
  1728 00000319 EB01                    		jmp	short pcmdl_2	
  1729                                  pcmdl_1:
  1730                                  		;mov	al,[es:bx]
  1731                                  		;mov	si,[i]
  1732                                  		;mov	byte [si+cmd_line],al
  1733                                  		;inc	word [cmdlineptr]
  1734                                  		;inc	byte [i]		
  1735 0000031B AA                      		stosb
  1736                                  pcmdl_2:
  1737                                  		;les	bx,[cmdlineptr]
  1738 0000031C AC                      		lodsb
  1739                                  		;cmp	byte [es:bx],0Dh
  1740 0000031D 3C0D                    		cmp	al,0Dh
  1741 0000031F 75FA                    		jne	short pcmdl_1
  1742                                  		;mov	si,[i]
  1743                                  		;mov	byte [si+cmd_line],0Dh
  1744 00000321 30E4                    		xor	ah,ah	
  1745                                  		;;inc	word [i]
  1746                                  		;inc	byte [i]
  1747                                  		;mov	si,[i]
  1748                                  		;mov	byte [si+cmd_line],0
  1749 00000323 AB                      		stosw
  1750                                  		
  1751                                  		;lea	ax,[si+1] ; ?
  1752                                  		;mov	[i],ax
  1753                                  
  1754                                  		;sub	di,cmd_line+1
  1755                                  
  1756 00000324 8D7680                  		lea	si,[cmd_line]
  1757 00000327 29C9                    		sub	cx,cx
  1758                                  		;sub	dx,dx
  1759 00000329 BF[97A0]                		mov	di,p_p
  1760                                  		;mov	[Parse_Ptr],si
  1761                                  		;mov	word [finished],0
  1762                                  		;mov	[finished],cx ; 0 ; 11/11/2018
  1763                                  pcmdl_3:
  1764 0000032C 8936[E0CB]              		mov	[Parse_Ptr],si
  1765 00000330 E89E01                  		call	parse
  1766                                  			; AX = Error Code (0 = No error) ; 14/11/2018
  1767                                  		;and	ax,ax
  1768                                  		;jnz	short pcmdl_5
  1769 00000333 7216                    		jc	short pcmdl_5
  1770                                  
  1771 00000335 81FA[D6CB]              		cmp	dx,p_buff
  1772 00000339 7505                    		jne	short pcmdl_4
  1773 0000033B E8320A                  		call	check_disk_validity
  1774                                  		;jmp	short pcmdl_7
  1775 0000033E EBEC                    		jmp	short pcmdl_3 ; 11/11/2018
  1776                                  pcmdl_4:
  1777 00000340 81FA[D4CC]              		cmp	dx,sp_buff
  1778                                  		;jne	short pcmdl_7
  1779 00000344 75E6                    		jne	short pcmdl_3 ; 11/11/2018
  1780 00000346 E8350A                  		call	process_switch
  1781                                  		;jmp	short pcmdl_7
  1782 00000349 EBE1                    		jmp	short pcmdl_3 ; 11/11/2018
  1783                                  pcmdl_5:
  1784 0000034B 83F8FF                  		cmp	ax,0FFFFh ; -1
  1785                                  		;je	short pcmdl_6	; Empty command tail (CR after file name). 
  1786 0000034E 740F                    		je	short pcmdl_8 ; 11/11/2018		
  1787                                  
  1788                                  		; 14/11/2018
  1789                                  		;jmp	short _pcmdl_10
  1790                                  
  1791                                  		;mov	al,2
  1792                                  		;push	ax
  1793                                  		;mov	ax,2
  1794                                  		;push	ax
  1795                                  		;push	word [regs_x_ax]  ; push word [_$P_RC]
  1796                                  
  1797                                  		;Parse_msg(regs.x.ax,STDERR,Parse_err_class); 
  1798 00000350 BA0200                  		mov	dx,2
  1799 00000353 52                      		push	dx	 ;Message_Type	; PARSE_ERR_CLASS = 2
  1800 00000354 52                      		push	dx	 ;Handle	; STDERR = 2
  1801 00000355 50                      		push	ax 	 ;Msg_Num       ; Error Number = [_$P_RC]
  1802 00000356 E83710                  		call	Parse_msg
  1803 00000359 83C406                  		add	sp,6
  1804                                  
  1805                                  ;_pcmdl_10:
  1806                                  		; TEMPORARY
  1807                                  		; Erdogan Tan - 10/11/2018
  1808                                  		;call	print_parse_error_msg ; (*)
  1809                                  
  1810                                  		;mov	byte [parse_good],0 ; FALSE ; 11/11/2018
  1811                                  
  1812                                  		;sub	al,al
  1813                                  		; AL = 0 (*)
  1814                                  		;jmp	short pcmdl_9 ; 11/11/2018
  1815                                  
  1816                                  		;sub	ah,ah
  1817 0000035C F9                      		stc
  1818 0000035D EB04                    		jmp	short pcmdl_9 ; 11/11/2018
  1819                                  		
  1820                                  pcmdl_6:
  1821                                  		;;mov	byte [finished],1
  1822                                  		;jmp	short pcmdl_8
  1823                                  pcmdl_7:
  1824                                  		;cmp	byte [finished],0
  1825                                  		;je	short pcmdl_3
  1826                                  pcmdl_8:
  1827                                  		;mov	al,[parse_good] ; 11/11/2018
  1828                                  
  1829                                  		;xor	ax,ax
  1830 0000035F 30C0                    		xor	al,al ; clc
  1831 00000361 FEC0                    		inc	al ; 1	; 11/11/2018
  1832                                  pcmdl_9:
  1833                                  		;cmp	al,1	; 11/11/2018
  1834                                  
  1835                                  		;pop	si
  1836                                  		
  1837 00000363 89EC                    		mov	sp,bp
  1838                                  		;pop	bp
  1839                                  		
  1840 00000365 C3                      		retn
  1841                                  
  1842                                  ;/*  */
  1843                                  ;/******************************************************************************/
  1844                                  ;/*Routine name:  INIT_PARSE                                                   */
  1845                                  ;/******************************************************************************/
  1846                                  ;/*                                                                            */
  1847                                  ;/*Description:   Sets up ALL VALUES AND STRUCTS FOR PARSER.                   */
  1848                                  ;/*                                                                            */
  1849                                  ;/*Called Procedures:                                                          */
  1850                                  ;/*                                                                            */
  1851                                  ;/*Change History: Created        6/15/87         DRM                          */
  1852                                  ;/*                                                                            */
  1853                                  ;/*Input: None                                                                 */
  1854                                  ;/*                                                                            */
  1855                                  ;/*Output: None                                                                */
  1856                                  ;/*                                                                            */
  1857                                  ;/******************************************************************************/
  1858                                  
  1859                                  ;void parse_init()
  1860                                  
  1861                                  parse_init:	; 10/11/2018
  1862                                  		;sub	al,al
  1863 00000366 29C0                    		sub	ax,ax
  1864 00000368 A2[00A1]                		mov	[primary_flag],al
  1865 0000036B A2[D6C3]                		mov	[extended_flag],al
  1866 0000036E A2[D3C3]                		mov	[logical_flag],al
  1867 00000371 A2[96A0]                		mov	[disk_flag],al
  1868 00000374 A2[40A1]                		mov	[quiet_flag],al
  1869 00000377 A2[D4C3]                		mov	[status_flag],al
  1870 0000037A A2[2EA1]                		mov	[mbr_flag],al
  1871 0000037D C706[97A0][86A0]        		mov	word [p_p_p_parmxs_ptr],p_px ; /* Address of extended parm list */
  1872 00000383 C606[9BA0]3B            		mov	byte [p_p_p_extra_delim],';'
  1873                                  		;mov	al,1
  1874 00000388 FEC0                    		inc	al
  1875 0000038A A2[99A0]                		mov	[p_p_p_num_extra],al
  1876 0000038D A2[9AA0]                		mov	[p_p_p_len_extra_delim],al
  1877 00000390 A2[87A0]                		mov	[p_px_p_maxp],al ; /* 1 maximum positionals */	
  1878 00000393 C706[88A0][06C4]        		mov	word [p_px_p_con1_ptr],p_con ; /* pointer to next control blk */
  1879 00000399 C606[8AA0]05            		mov	byte [p_px_p_maxs],5	; /* number of switches */
  1880 0000039E C706[8BA0][E8A0]        		mov	word [p_px_p_swi1_ptr],p_swi1 ; /* pointer to next control blk */
  1881 000003A4 C706[8DA0][02A1]        		mov	word [p_px_p_swi2_ptr],p_swi2 ; /* pointer to next control blk */
  1882 000003AA C706[8FA0][0EA1]        		mov	word [p_px_p_swi3_ptr],p_swi3
  1883 000003B0 C706[91A0][22A1]        		mov	word [p_px_p_swi4_ptr],p_swi4
  1884 000003B6 C706[93A0][30A1]        		mov	word [p_px_p_swi5_ptr],p_swi5
  1885                                  		;mov	al,[NOVAL]	 ; /* no keywords */
  1886                                  		;sub	al,al ; 0
  1887 000003BC FEC8                    		dec	al
  1888 000003BE A2[95A0]                		mov	[p_px_p_maxk],al
  1889                                  		;mov	word [p_con],8001h	; /* DRIVE NUMBER 1 OR 2 optional */
  1890 000003C1 C706[06C4]0180          		mov	word [p_con_p_match_flag],8001h
  1891 000003C7 C706[0AC4][D6CB]        		mov	word [p_con_p_buff1_ptr],p_buff
  1892 000003CD C706[0CC4][FAC3]        		mov	word [p_con_p_val1_ptr],p_val
  1893 000003D3 28C0                    		sub	al,al ; 0
  1894 000003D5 A2[86A0]                		mov	[p_px_p_minp],al	; /* 1 required positional */
  1895 000003D8 A2[0EC4]                		mov	[p_con_nid],al
  1896                                  		;mov	word [p_swi1],8000h	; /* Optional (switch) */
  1897 000003DB C706[E8A0]0080          		mov	word [p_swi1_sp_match_flag],8000h
  1898                                  		;sub	ax,ax
  1899 000003E1 A3[08C4]                		mov	[p_con_p_function_flag],ax ; /* DO NOTHING FOR FUNCTION FLAG */
  1900 000003E4 A3[EAA0]                		mov	[p_swi1_sp_function_flag],ax ; /* DO NOTHING FOR FUNCTION FLAG */
  1901 000003E7 C706[ECA0][D4CC]        		mov	word [p_swi1_sp_buff1_ptr],sp_buff
  1902 000003ED C706[EEA0][D7C3]        		mov	word [p_swi1_sp_val1_ptr],sp_val
  1903 000003F3 C606[F0A0]03            		mov	byte [p_swi1_sp_nid],3	; /* 3 switches allowed */
  1904                                  
  1905                                  		;mov	ax,PRI	; "/PRI"	; /* /a switch */
  1906                                  		;push	ax
  1907                                  		;mov	ax,p_swi1_sp_switch1
  1908                                  		;push	ax
  1909                                  		;call	strcpy
  1910                                  		;pop	bx
  1911                                  		;pop	bx
  1912 000003F8 BE[5970]                		mov	si,PRI
  1913 000003FB BF[F1A0]                		mov	di,p_swi1_sp_switch1
  1914                                  		;mov	cx,5  ; db '/PRI',0
  1915                                  		;rep	movsb		
  1916 000003FE A5                      		movsw
  1917 000003FF A5                      		movsw
  1918 00000400 A4                      		movsb
  1919                                  
  1920                                  		;mov	ax,EXT	; "/EXT"	; /* /a switch */
  1921                                  		;push	ax
  1922                                  		;mov	ax,p_swi1_sp_switch2
  1923                                  		;push	ax
  1924                                  		;call	strcpy
  1925                                  		;pop	bx
  1926                                  		;pop	bx
  1927 00000401 BE[5E70]                		mov	si,EXT
  1928 00000404 BF[F6A0]                		mov	di,p_swi1_sp_switch2
  1929                                  		;mov	cx,5  ; db '/EXT',0
  1930                                  		;mov	cl,5
  1931                                  		;rep	movsb	
  1932 00000407 A5                      		movsw
  1933 00000408 A5                      		movsw	
  1934 00000409 A4                      		movsb
  1935                                  
  1936                                  		;mov	ax,LOG	; "/LOG"	; /* /a switch */
  1937                                  		;push	ax
  1938                                  		;mov	ax,p_swi1_sp_switch3
  1939                                  		;push	ax
  1940                                  		;call	strcpy
  1941                                  		;pop	bx
  1942                                  		;pop	bx
  1943 0000040A BE[6370]                		mov	si,LOG
  1944 0000040D BF[FBA0]                		mov	di,p_swi1_sp_switch3
  1945                                  		;mov	cx,5  ; db '/LOG',0
  1946                                  		;mov	cl,5
  1947                                  		;rep	movsb	
  1948 00000410 A5                      		movsw
  1949 00000411 A5                      		movsw
  1950 00000412 A4                      		movsb
  1951                                  
  1952                                  		;mov	[p_swi2],1		; /* Optional (switch) */
  1953 00000413 C706[02A1]0100          		mov	word [p_swi2_sp_match_flag],1
  1954 00000419 C706[04A1]0000          		mov	word [p_swi2_sp_function_flag],0
  1955 0000041F C706[06A1][D4CC]        		mov	word [p_swi2_sp_buff1_ptr],sp_buff
  1956                                  		;mov	ax,[NOVAL]
  1957 00000425 31C0                    		xor	ax,ax ; 0
  1958 00000427 A3[08A1]                		mov	[p_swi2_sp_val1_ptr],ax
  1959 0000042A C606[0AA1]01            		mov	byte [p_swi2_sp_nid],1	; /* 1 switch allowed */
  1960                                  
  1961                                  		;mov	ax,QUIET ; "/Q"		; /* /a switch */
  1962                                  		;push	ax
  1963                                  		;mov	ax,p_swi2_sp_switch4
  1964                                  		;push	ax
  1965                                  		;call	strcpy
  1966                                  		;pop	bx
  1967                                  		;pop	bx
  1968 0000042F BE[6870]                		mov	si,QUIET
  1969 00000432 BF[0BA1]                		mov	di,p_swi2_sp_switch4
  1970                                  		;mov	cx,3  ; db '/Q',0
  1971                                  		;mov	cl,3
  1972                                  		;rep	movsb
  1973 00000435 A5                      		movsw
  1974 00000436 A4                      		movsb
  1975                                  
  1976 00000437 29C0                    		sub	ax,ax ; 0
  1977                                  		;mov	word [p_swi3],1
  1978 00000439 A3[0EA1]                		mov	[p_swi3_sp_match_flag],ax
  1979 0000043C A3[10A1]                		mov	[p_swi3_sp_function_flag],ax ; 0
  1980 0000043F C706[12A1][D4CC]        		mov	word [p_swi3_sp_buff1_ptr],sp_buff
  1981                                  		;mov	ax,[NOVAL]
  1982 00000445 A3[14A1]                		mov	[p_swi3_sp_val1_ptr],ax ; 0
  1983 00000448 C606[16A1]01            		mov	byte [p_swi3_sp_nid],1
  1984                                  
  1985                                  		;mov	ax,STATUS ; "/STATUS"
  1986                                  		;push	ax
  1987                                  		;mov	ax,p_swi3_sp_switch5
  1988                                  		;push	ax
  1989                                  		;call	strcpy
  1990                                  		;pop	bx
  1991                                  		;pop	bx
  1992 0000044D BE[6B70]                		mov	si,STATUS
  1993 00000450 BF[17A1]                		mov	di,p_swi3_sp_switch5
  1994                                  		;mov	cx,8  ; db '/STATUS',0
  1995                                  		;mov	cl,8
  1996                                  		;rep	movsb
  1997 00000453 B90400                  		mov	cx,4
  1998 00000456 F3A5                    		rep	movsw
  1999                                  
  2000 00000458 29C0                    		sub	ax,ax
  2001                                  		;mov	[p_swi4],ax
  2002 0000045A A3[22A1]                		mov	[p_swi4_sp_match_flag],ax
  2003 0000045D A3[24A1]                		mov	[p_swi4_sp_function_flag],ax
  2004 00000460 C706[26A1][D4CC]        		mov	word [p_swi4_sp_buff1_ptr],sp_buff
  2005                                  		;mov	ax,[NOVAL]
  2006 00000466 A3[28A1]                		mov	[p_swi4_sp_val1_ptr],ax
  2007 00000469 C606[2AA1]01            		mov	byte [p_swi4_sp_nid],1
  2008                                  		
  2009                                  		;mov	ax,OPTIONS ; "/?"
  2010                                  		;push	ax
  2011                                  		;mov	ax,p_swi4_sp_switch6
  2012                                  		;push	ax
  2013                                  		;call	strcpy
  2014                                  		;pop	bx
  2015                                  		;pop	bx
  2016 0000046E BE[7370]                		mov	si,OPTIONS
  2017 00000471 BF[2BA1]                		mov	di,p_swi4_sp_switch6
  2018                                  		;mov	cx,3  ; db '/?',0
  2019                                  		;mov	cl,3
  2020                                  		;rep	movsb
  2021 00000474 A5                      		movsw	
  2022 00000475 A4                      		movsb	
  2023                                  
  2024 00000476 B80100                  		mov	ax,1
  2025                                  		;mov	word [p_swi5],1
  2026                                  		;mov	[p_swi5],ax
  2027 00000479 A3[30A1]                		mov	[p_swi5_sp_match_flag],ax
  2028 0000047C FEC8                    		dec	al ; dec ax ; 0
  2029 0000047E A3[32A1]                		mov	[p_swi5_sp_function_flag],ax ; 0
  2030 00000481 C706[34A1][D4CC]        		mov	word [p_swi5_sp_buff1_ptr],sp_buff
  2031                                  		;mov	ax,[NOVAL]
  2032 00000487 A3[36A1]                		mov	[p_swi5_sp_val1_ptr],ax
  2033 0000048A C606[38A1]01            		mov	byte [p_swi5_sp_nid],1
  2034                                  
  2035                                  		;mov	ax,MBR	; "/MBR"
  2036                                  		;push	ax
  2037                                  		;mov	ax,p_swi5_sp_switch7
  2038                                  		;push	ax
  2039                                  		;call	strcpy
  2040                                  		;pop	bx
  2041                                  		;pop	bx
  2042 0000048F BE[7670]                		mov	si,MBR
  2043 00000492 BF[39A1]                		mov	di,p_swi5_sp_switch7
  2044                                  		;mov	cx,5  ; db '/MBR',0
  2045                                  		;mov	cl,5
  2046                                  		;rep	movsb	
  2047 00000495 A5                      		movsw
  2048 00000496 A5                      		movsw
  2049 00000497 A4                      		movsb
  2050                                  		
  2051 00000498 31C0                    		xor	ax,ax
  2052 0000049A C706[01C4]0800          		mov	word [p_val_p_high_range],8
  2053 000004A0 A3[03C4]                		mov	word [p_val_p_high_range+2],ax ; 0
  2054                                  		;mov	al,1
  2055 000004A3 FEC0                    		inc	al
  2056                                  		;mov	[p_val],al		; /* Number of values items returned */
  2057 000004A5 A2[FAC3]                		mov	[p_val_p_values],al
  2058 000004A8 A2[FBC3]                		mov	[p_val_p_range],al	; /* Number of ranges */
  2059 000004AB A2[FCC3]                		mov	[p_val_p_range_one],al	; /* range number one */
  2060                                  		;mov	[sp_val],al		
  2061 000004AE A2[D7C3]                		mov	[sp_val_p_values],al
  2062 000004B1 A2[D8C3]                		mov	[sp_val_p_range],al
  2063 000004B4 A2[D9C3]                		mov	[sp_val_p_range_one],al
  2064                                  		;mov	ax,1
  2065 000004B7 99                      		cwd
  2066 000004B8 A3[FDC3]                		mov	[p_val_p_low_range],ax	; /* low value for range */
  2067 000004BB 8916[FFC3]              		mov	[p_val_p_low_range+2],dx ; /* high value for range */
  2068 000004BF A3[DAC3]                		mov	[sp_val_p_low_range],ax	; /* low value for range */
  2069 000004C2 8916[DCC3]              		mov	[sp_val_p_low_range+2],dx ; /* high value for range */
  2070 000004C6 C706[DEC3]801F          		mov	word [sp_val_p_high_range],8064  ; /* max disk size=7.875GB=8064MB */
  2071 000004CC 8916[E0C3]              		mov	word [sp_val_p_high_range+2],dx ; 0
  2072 000004D0 C3                      		retn
  2073                                  
  2074                                  ; ----------------------------------------------------------------------------
  2075                                  ; strcpy - (c library function) Modified by Erdogan Tan for Assembly language
  2076                                  ; ----------------------------------------------------------------------------
  2077                                  ; 10/11/2018
  2078                                  
  2079                                  ;strcpy:
  2080                                  		;%define source	     bp+6  ; word	
  2081                                  		;%define destination bp+4  ; word
  2082                                  		;
  2083                                  		;push	bp
  2084                                  		;mov	bp,sp
  2085                                  		;mov	dx,di
  2086                                  		;mov	bx,si
  2087                                  		;mov	si,[source] ; [bp+6]
  2088                                  		;mov	di,si
  2089                                  		;mov	ax,ds
  2090                                  		;mov	es,ax
  2091                                  		;xor	ax,ax
  2092                                  		;mov	cx,0FFFFh ; 65535
  2093                                  		;repne scasb
  2094                                  		;not	cx
  2095                                  		;mov	di,[destination] ; [bp+4]
  2096                                  		;mov	ax,di
  2097                                  		;test	al,1
  2098                                  		;jz	short strcpy_0
  2099                                  		;movsb
  2100                                  		;dec	cx
  2101                                  ;strcpy_0:
  2102                                  		;shr	cx,1
  2103                                  		;rep movsw
  2104                                  		;adc	cx,cx
  2105                                  		;rep movsb
  2106                                  		;mov	si,bx
  2107                                  		;mov	di,dx
  2108                                  		;pop	bp
  2109                                  		;retn
  2110                                  
  2111                                  ; ----------------------------------------------------------------------------
  2112                                  ; PARSE - Modified by Erdogan Tan for Assembly language - 07/11/2018	
  2113                                  ; ----------------------------------------------------------------------------
  2114                                  
  2115                                  ; _parse.asm (MSDOS 6.0, 1991)
  2116                                  ;-------------------------------------------------------------------
  2117                                  ;
  2118                                  ;       MODULE:         _parse
  2119                                  ;
  2120                                  ;       PURPOSE:        Supplies an interface between C programs and
  2121                                  ;                       the DOS 3.30 parser
  2122                                  ;
  2123                                  ;       CALLING FORMAT:
  2124                                  ;                       parse(&inregs,&outregs);
  2125                                  ;
  2126                                  ;       DATE:           5-21-87
  2127                                  ;
  2128                                  ;-------------------------------------------------------------------
  2129                                  
  2130                                  parse:
  2131 000004D1 E80500                  		call	SysParse
  2132                                  	
  2133 000004D4 83F801                  		cmp	ax,1 ; Error Code (If > 0)
  2134 000004D7 F5                      		cmc	; cf = 1 if AX > 0
  2135 000004D8 C3                      		retn
  2136                                  
  2137                                  ; ----------------------------------------------------------------------------
  2138                                  ; parse.asm (MSDOS 6.0, 1991)	
  2139                                  ; ----------------------------------------------------------------------------
  2140                                  ; Modified for NASM and COM file (by Erdogan Tan, 08/11/2018)
  2141                                  
  2142                                  ;*****************************************************************************
  2143                                  ; SysParse;
  2144                                  ;
  2145                                  ;  Function : Parser Entry
  2146                                  ;
  2147                                  ;  Input: DS:SI -> command line
  2148                                  ;	  ES:DI -> parameter block
  2149                                  ;	  psdata_seg -> psdata.inc
  2150                                  ;	  CX = operand ordinal
  2151                                  ;
  2152                                  ;	  Note:  ES is the segment containing all the control blocks defined
  2153                                  ;		 by the caller, except for the DOS COMMAND line parms, which
  2154                                  ;		 is in DS.
  2155                                  ;
  2156                                  ;  Output: CY = 1   error of caller, means invalid parameter block or
  2157                                  ;		    invalid value list. But this parser does NOT implement
  2158                                  ;		    this feature. Therefore CY always zero.
  2159                                  ;
  2160                                  ;	   CY = 0   AX = return code
  2161                                  ;		    BL = terminated delimiter code
  2162                                  ;		    CX = new operand ordinal
  2163                                  ;		    SI = set past scaned operand
  2164                                  ;		    DX = selected result buffer
  2165                                  ;
  2166                                  ; Use:	_$P_Skip_Delim, _$P_Chk_EOL, _$P_Chk_Delim, _$P_Chk_DBCS
  2167                                  ;	_$P_Chk_Swtch, _$P_Chk_Pos_Control, _$P_Chk_Key_Control
  2168                                  ;	_$P_Chk_Sw_Control, _$P_Fill_Result
  2169                                  ;
  2170                                  ; Vars: _$P_Ordinal(RW), _$P_RC(RW), _$P_SI_Save(RW), _$P_DX(R), _$P_Terminator(R)
  2171                                  ;	_$P_SaveSI_Cmpx(W), _$P_Flags(RW), _$P_Found_SYNONYM(R), _$P_Save_EOB(W)
  2172                                  ;
  2173                                  ;*****************************************************************************
  2174                                  
  2175                                  SysParse:
  2176 000004D9 31D2                    		xor	dx,dx ; 09/11/2018
  2177                                  
  2178                                  		;mov	word [_$P_Flags],0	; Clear all internal flags
  2179 000004DB 8916[9D70]              		mov	[_$P_Flags],dx		
  2180                                  
  2181 000004DF FC                      		cld
  2182 000004E0 890E[9070]              		mov	[_$P_ordinal],cx	; save operand ordinal
  2183                                  		;mov	word [_$P_RC],0	;_$P_No_Error
  2184                                  		;mov	byte [_$P_RC],0		; Assume no error
  2185 000004E4 8916[9270]              		mov	[_$P_RC],dx	
  2186                                  		;mov	word [_$P_Found_SYNONYM],0 ; initalize synonym pointer
  2187 000004E8 8916[A570]              		mov	[_$P_Found_SYNONYM],dx
  2188                                  		;mov	word [_$P_DX],0
  2189 000004EC 8916[9670]              		mov	[_$P_DX],dx
  2190                                  
  2191 000004F0 E80B01                  		call	_$P_Skip_Delim		; Move si to 1st non white space
  2192 000004F3 7311                    		jnc	short _$P_Start		; If EOL is not encountered, do parse
  2193                                  
  2194 000004F5 B8FFFF                  		mov	ax,0FFFFh ; _$P_RC_EOL	; set exit code to -1
  2195 000004F8 53                      		push	bx
  2196                                  						; Get the PARMSX address to
  2197                                  		;mov	bx,[es:di] ; [es:di+_$P_PARMSX_Address]
  2198 000004F9 8B1D                    		mov	bx,[di]
  2199                                  						; check ORDINAL to see if the minimum
  2200                                  		;cmp	cl,[es:bx] ; [es:bx+_$P_MinP]
  2201 000004FB 3A0F                    		cmp	cl,[bx]
  2202 000004FD 7303                    		jnb	short _$P_Fin		; positional found.
  2203 000004FF B80200                  		mov	ax,2 ; _$P_Op_Missing ; If no, set exit code to missing operand
  2204                                  _$P_Fin:
  2205 00000502 5B                      		pop	bx
  2206 00000503 E9F600                  		jmp	_$P_Single_Exit		; return to the caller
  2207                                  
  2208                                  _$P_Start:			;  save ptr to command line for later use by complex,
  2209 00000506 8936[9F70]              		mov	[_$P_SaveSI_Cmpx],si 	; quoted string or file spec.
  2210 0000050A 53                      		push	bx
  2211 0000050B 57                      		push	di
  2212 0000050C 55                      		push	bp
  2213                                  		;lea	bx,[_$P_STRING_BUF]  ; set buffer to copy from command string
  2214 0000050D BB[A770]                		mov	bx,_$P_STRING_BUF
  2215                                  						; extra delimiter encountered ?
  2216 00000510 F606[9E70]20            		test	byte [_$P_Flags2],20h ;_$P_Extra
  2217 00000515 753E                    		jnz	short _$P_Pack_End	; if yes, no need to copy
  2218                                  _$P_Pack_Loop:
  2219 00000517 AC                      		lodsb				; Pick a operand from buffer
  2220 00000518 E88F01                  		call	_$P_Chk_Switch		; Check switch character
  2221 0000051B 7237                    		jc	short _$P_Pack_End_BY_EOL 
  2222                                  					    ; if carry set found delimiter type slash,
  2223                                  					    ; need backup si, else continue
  2224 0000051D E80201                  		call	_$P_Chk_EOL		; Check EOL character
  2225 00000520 7432                    		jz	short _$P_Pack_End_BY_EOL ; need backup si
  2226                                  
  2227 00000522 E82E01                  		call	_$P_Chk_Delim		; Check delimiter
  2228 00000525 7516                    		jnz	short _$P_PL01		; If no, process next byte
  2229                                  
  2230 00000527 F606[9E70]20            		test	byte [_$P_Flags2],20h ;_$P_Extra ; If yes and white spec,
  2231 0000052C 7505                    		jnz	short _$P_Pack_End_backup_si ; then
  2232                                  
  2233 0000052E E8CD00                  		call	_$P_Skip_Delim		; skip subsequent white space,too
  2234 00000531 EB22                    		jmp	short _$P_Pack_End	; finish copy by placing NUL at end
  2235                                  
  2236                                  _$P_Pack_End_backup_si:
  2237 00000533 F606[9E70]41            		test	byte [_$P_Flags2],41h ;_$P_SW+_$P_equ
  2238 00000538 741B                    		jz	short _$P_Pack_End
  2239 0000053A 4E                      		dec	si
  2240 0000053B EB18                    		jmp	short _$P_Pack_End
  2241                                  
  2242                                  _$P_PL01:
  2243 0000053D 8807                    		mov	[bx],al			; move byte to STRING_BUF
  2244 0000053F 3C3D                    		cmp	al,'='			; if it is equal character,
  2245 00000541 7505                    		jne	short _$P_PL00		; then
  2246 00000543 800E[9E70]01            		or	byte [_$P_Flags2],1 ;_$P_equ ; remember it in flag
  2247                                  _$P_PL00:
  2248 00000548 43                      		inc	bx			; ready to see next byte
  2249 00000549 E88701                  		call	_$P_Chk_DBCS		; was it 1st byte of DBCS ?
  2250 0000054C 73C9                    		jnc	short _$P_Pack_Loop	; if no, process to next byte
  2251 0000054E AC                      		lodsb				; if yes, store
  2252 0000054F 8807                    		mov	[bx],al			;    2nd byte of DBCS
  2253 00000551 43                      		inc	bx			; update pointer
  2254 00000552 EBC3                    		jmp	short _$P_Pack_Loop	; process to next byte
  2255                                  
  2256                                  _$P_Pack_End_BY_EOL:
  2257 00000554 4E                      		dec	si			; backup si pointer
  2258                                  _$P_Pack_End:
  2259 00000555 8936[9470]              		mov	[_$P_SI_Save],si	; save next pointer, SI	
  2260 00000559 C60700                  		mov	byte [bx],0 ; _$P_NULL	; put NULL at the end
  2261 0000055C 891E[A370]              		mov	[_$P_Save_EOB],bx ; keep the address for later use of complex	
  2262                                  		;mov	bx,[es:di] ; [es:di+_$P_PARMSX_Address] ; get PARMSX address
  2263 00000560 8B1D                    		mov	bx,[di]
  2264                                  		;lea	si,[_$P_STRING_BUF]
  2265 00000562 BE[A770]                		mov	si,_$P_STRING_BUF
  2266 00000565 803C2F                  		cmp	byte [si],'/' ;_$P_Switch ; the operand begins w/ switch char?
  2267 00000568 7439                    		je	short _$P_SW_Manager	; if yes, process as switch
  2268                                  
  2269 0000056A 803C22                  		cmp	byte [si],'"' ;_$P_DQuote ; is it a string?
  2270 0000056D 7407                    		je	short _$P_Positional_Manager ; if so, process as one!
  2271                                  						; the operand includes equal char?
  2272 0000056F F606[9E70]01            		test	byte [_$P_Flags2],1 ;_$P_equ 
  2273 00000574 754B                    		jnz	short _$P_Key_manager	; if yes, process as keyword	
  2274                                  
  2275                                  _$P_Positional_Manager:				; else process as positional
  2276                                  		;mov	al,[es:bx+1] ; es:[bx]._$P_MaxP ; get maxp
  2277 00000576 8A4701                  		mov	al,[bx+1]
  2278 00000579 30E4                    		xor	ah,ah			; ax = maxp
  2279 0000057B 3906[9070]              		cmp	[_$P_ordinal],ax	; too many positional?	
  2280 0000057F 7310                    		jnb	short _$P_Too_Many_Error ; if yes, set exit code to too many
  2281 00000581 A1[9070]                		mov	ax,[_$P_ordinal]	; see what the current ordinal
  2282 00000584 D1E0                    		shl	ax,1			; ax = ax*2
  2283 00000586 43                      		inc	bx			; add '2' to
  2284 00000587 43                      		inc	bx			;  BX reg
  2285                                  					; now bx points to 1st CONTROL
  2286 00000588 01C3                    		add	bx,ax		; now bx points to specified CONTROL address
  2287                                  		;mov	bx,[es:bx]	; now bx points to specified CONTROL itself
  2288 0000058A 8B1F                    		mov	bx,[bx]
  2289 0000058C E89101                  		call	_$P_Chk_Pos_Control	; Do process for positional
  2290 0000058F EB55                    		jmp	short _$P_Return_to_Caller ; and return to the caller
  2291                                  
  2292                                  _$P_Too_Many_Error:
  2293                                  		;mov	word [_$P_RC],1 ;_$P_Too_Many ; set exit code
  2294 00000591 C606[9270]01            		mov	byte [_$P_RC],1
  2295 00000596 EB4E                    		jmp	short _$P_Return_to_Caller ; and return to the caller
  2296                                  	
  2297                                  ; ----------------------------------------------------------------------------
  2298                                  
  2299                                  _$P_SW_Key_Mgr_sub:
  2300                                  		;mov	al,[es:bx+1] ; [es:bx+_$P_MaxP] ; get maxp
  2301 00000598 8A4701                  		mov	al,[bx+1]
  2302 0000059B 30E4                    		xor	ah,ah			; ax = maxp
  2303 0000059D 40                      		inc	ax
  2304 0000059E D1E0                    		shl	ax,1			; ax = (ax+1)*2
  2305 000005A0 01C3                    		add	bx,ax			; now bx points to maxs
  2306 000005A2 C3                      		retn
  2307                                  
  2308                                  ; ----------------------------------------------------------------------------
  2309                                  
  2310                                  _$P_SW_Manager:
  2311 000005A3 E8F2FF                  		call	_$P_SW_Key_Mgr_sub  ; repetitive portion as subroutine
  2312                                  		;mov	cl,[es:bx]
  2313 000005A6 8A0F                    		mov	cl,[bx]
  2314 000005A8 30ED                    		xor	ch,ch			; cx = maxs
  2315                                  		;or	cx,cx
  2316                                  		;jz	short _$P_SW_Not_Found 
  2317 000005AA E30E                    		jcxz	_$P_SW_Not_Found	; at least one switch?
  2318 000005AC 43                      		inc	bx		; now bx points to 1st CONTROL address
  2319                                  
  2320                                  _$P_SW_Mgr_Loop:
  2321 000005AD 53                      		push	bx
  2322                                  		;mov	bx,[es:bx]	   ; bx points to Switch CONTROL itself
  2323 000005AE 8B1F                    		mov	bx,[bx]
  2324 000005B0 E8C701                  		call	_$P_Chk_SW_Control	; do process for switch
  2325 000005B3 5B                      		pop	bx		; if the CONTROL is for the switch, exit
  2326 000005B4 7330                    		jnc	short _$P_Return_to_Caller
  2327 000005B6 43                      		inc	bx			;  add 2 to BX reg
  2328 000005B7 43                      		inc	bx		   ; else bx points to the next CONTROL
  2329 000005B8 E2F3                    		loop	_$P_SW_Mgr_Loop		; and loop
  2330                                  
  2331                                  _$P_SW_Not_Found:
  2332                                  		;mov	word [_$P_RC],3 ;_$P_Not_In_SW
  2333 000005BA C606[9270]03            		mov	byte [_$P_RC],3	    ; here no CONTROL for the switch has
  2334 000005BF EB25                    		jmp	short _$P_Return_to_Caller ; not been found, means error.
  2335                                  
  2336                                  _$P_Key_manager:
  2337 000005C1 E8D4FF                  		call	_$P_SW_Key_Mgr_sub  ; repetitive portion as subroutine	
  2338                                  		;mov	al,[es:bx]
  2339 000005C4 8A07                    		mov	al,[bx]
  2340 000005C6 30E4                    		xor	ah,ah			; ax = maxs
  2341 000005C8 D1E0                    		shl	ax,1
  2342 000005CA 40                      		inc	ax			; ax = ax*2+1
  2343 000005CB 01C3                    		add	bx,ax			; now bx points to maxk
  2344                                  		;mov	cl,[es:bx]
  2345 000005CD 8A0F                    		mov	cl,[bx]
  2346 000005CF 30ED                    		xor	ch,ch			; cx = maxk
  2347 000005D1 E30E                    		jcxz	_$P_Key_Not_Found	; at least one keyword?
  2348 000005D3 43                      		inc	bx			; now bx points to 1st CONTROL
  2349                                  
  2350                                  _$P_Key_Mgr_Loop:
  2351 000005D4 53                      		push	bx
  2352                                  		;mov	bx,[es:bx]	   ; bx points to keyword CONTROL itself
  2353 000005D5 8B1F                    		mov	bx,[bx]
  2354 000005D7 E87201                  		call	_$P_Chk_Key_Control	; do process for keyword
  2355 000005DA 5B                      		pop	bx		; if the CONTROL is for the keyword, exit
  2356 000005DB 7309                    		jnc	short _$P_Return_to_Caller
  2357 000005DD 43                      		inc	bx			; add '2' to BX reg
  2358 000005DE 43                      		inc	bx		; else bx points to the next CONTROL
  2359 000005DF E2F3                    		loop	_$P_Key_Mgr_Loop	; and loop
  2360                                  
  2361                                  _$P_Key_Not_Found:
  2362                                  		;mov	word [_$P_RC],4 ;_$P_Not_In_Key
  2363                                  					   ; here no CONTROL for the keyword has
  2364 000005E1 C606[9270]04            		mov	byte [_$P_RC],4	 	; not been found, means error.
  2365                                  
  2366                                  _$P_Return_to_Caller:
  2367 000005E6 5D                      		pop	bp
  2368 000005E7 5F                      		pop	di
  2369 000005E8 5B                      		pop	bx
  2370 000005E9 8B0E[9070]              		mov	cx,[_$P_ordinal]	; return next ordinal
  2371 000005ED A1[9270]                		mov	ax,[_$P_RC]		; return exit code
  2372 000005F0 8B36[9470]              		mov	si,[_$P_SI_Save]	; return next operand pointer	
  2373 000005F4 8B16[9670]              		mov	dx,[_$P_DX]		; return result buffer address
  2374 000005F8 8A1E[9870]              		mov	bl,[_$P_Terminator]	; return delimiter code found
  2375                                  
  2376                                  _$P_Single_Exit:
  2377 000005FC F8                      		clc
  2378 000005FD C3                      		retn
  2379                                  
  2380                                  ;***********************************************************************
  2381                                  ;
  2382                                  ; _$P_Skip_Delim;
  2383                                  ;
  2384                                  ; Function: Skip delimiters specified in the PARMS list, white space
  2385                                  ;	    and comma.
  2386                                  ;
  2387                                  ; Input:    DS:SI -> Command String
  2388                                  ;	    ES:DI -> Parameter List
  2389                                  ;
  2390                                  ; Output:   CY = 1 if the end of line encounterd
  2391                                  ;	    CY = 0 then SI move to 1st non-delimiter character
  2392                                  ;	    AL = Last examineed character
  2393                                  ;
  2394                                  ; Use:	    _$P_Chk_EOL, _$P_Chk_Delim,
  2395                                  ;
  2396                                  ; Vars:     _$P_Flags(R)
  2397                                  ;
  2398                                  ;***********************************************************************
  2399                                  
  2400                                  _$P_Skip_Delim:
  2401                                  _$P_Skip_Delim_Loop:
  2402 000005FE AC                      		lodsb
  2403 000005FF E82000                  		call	_$P_Chk_EOL	; is it EOL character?
  2404 00000602 7416                    		jz	short _$P_Skip_Delim_CY ; if yes, exit w/ CY on
  2405                                  
  2406 00000604 E84C00                  		call	_$P_Chk_Delim	; is it one of delimiters?
  2407 00000607 7514                    		jnz	short _$P_Skip_Delim_NCY ; if no, exit w/ CY off
  2408                                  					; extra delim or comma found? 
  2409 00000609 F606[9E70]20            		test	byte [_$P_Flags2],20h ;_$P_Extra
  2410 0000060E 74EE                    		jz	short _$P_Skip_Delim_Loop ; if no, loop
  2411                                  					
  2412 00000610 F606[9E70]41            		test	byte [_$P_Flags2],41h ;_$P_SW+_$P_equ ; /x or xxx=zzz
  2413 00000615 7409                    		jz	short _$P_Exit_At_Extra ; no switch, no keyword
  2414                                  
  2415 00000617 4E                      		dec	si		; backup si for next call
  2416 00000618 EB06                    		jmp	short _$P_Exit_At_Extra ; else exit w/ CY off
  2417                                  
  2418                                  _$P_Skip_Delim_CY:
  2419 0000061A F9                      		stc			; indicate EOL
  2420 0000061B EB01                    		jmp	short _$P_Skip_Delim_Exit
  2421                                  
  2422                                  _$P_Skip_Delim_NCY:
  2423 0000061D F8                      		clc			; indicate non delim
  2424                                  
  2425                                  _$P_Skip_Delim_Exit:			; in this case, need
  2426 0000061E 4E                      		dec	si		; backup index pointer
  2427 0000061F C3                      		retn
  2428                                  
  2429                                  _$P_Exit_At_Extra:
  2430 00000620 F8                      		clc			; indicate extra delim
  2431 00000621 C3                      		retn
  2432                                  
  2433                                  ;***********************************************************************
  2434                                  ;
  2435                                  ; _$P_Chk_EOL;
  2436                                  ;
  2437                                  ; Function: Check if AL is one of End of Line characters.
  2438                                  ;
  2439                                  ; Input:    AL = character code
  2440                                  ;	    ES:DI -> Parameter List
  2441                                  ;
  2442                                  ; Output:   ZF = 1 if one of End of Line characters
  2443                                  ;
  2444                                  ;***********************************************************************
  2445                                  
  2446                                  _$P_Chk_EOL:
  2447 00000622 53                      		push	bx
  2448 00000623 51                      		push	cx
  2449                                  
  2450 00000624 3C0D                    		cmp	al,0Dh ;_$P_CR	; Carriage return?
  2451 00000626 7428                    		je	short _$P_Chk_EOL_Exit
  2452                                  		
  2453 00000628 3C00                    		cmp	al,0 ;_$P_NULL	; zero?
  2454 0000062A 7424                    		je	short _$P_Chk_EOL_Exit
  2455                                  		
  2456 0000062C 3C0A                    		cmp	al,0Ah ;_$P_LF	; Line feed?
  2457 0000062E 7420                    		je	short _$P_Chk_EOL_Exit
  2458                                  		
  2459                                  		;cmp	byte [es:di+_$Pp_num_extra],_$P_I_Have_EOL
  2460                                  		;cmp	byte [es:di+2],2 ; EOL character specified?
  2461 00000630 807D0202                		cmp	byte [di+2],2 ; 09/11/2018
  2462 00000634 721A                    		jb	short _$P_Chk_EOL_Exit
  2463                                  		
  2464 00000636 31DB                    		xor	bx,bx
  2465                                  		;mov	bl,[es:di+_$P_p_len_extra_delim]
  2466                                  		;mov	bl,[es:di+3]	; get length of delimiter list
  2467 00000638 8A5D03                  		mov	bl,[di+3]
  2468 0000063B 83C304                  		add	bx,4 ;_$P_Len_PARMS ; skip it
  2469                                  					  ; No extra EOL character?
  2470                                  		;cmp	byte [es:bx+di],0 ;_$P_I_Use_Default
  2471 0000063E 803900                  		cmp	byte [bx+di],0
  2472 00000641 740B                    		je	short _$P_Chk_EOL_NZ
  2473 00000643 31C9                    		xor	cx,cx
  2474                                  		;mov	cl,[es:bx+di]	; Get number of extra character
  2475 00000645 8A09                    		mov	cl,[bx+di]
  2476                                  _$P_Chk_EOL_Loop:
  2477 00000647 43                      		inc	bx
  2478                                  		;cmp	al,[es:bx+di]	; Check extra EOL character
  2479 00000648 3A01                    		cmp	al,[bx+di]
  2480 0000064A 7404                    		je	short _$P_Chk_EOL_Exit
  2481 0000064C E2F9                    		loop	_$P_Chk_EOL_Loop
  2482                                  _$P_Chk_EOL_NZ:
  2483 0000064E 3C0D                    		cmp	al,0Dh ; _$P_CR	; reset ZF
  2484                                  _$P_Chk_EOL_Exit:
  2485 00000650 59                      		pop	cx
  2486 00000651 5B                      		pop	bx
  2487 00000652 C3                      		retn
  2488                                  
  2489                                  ;***********************************************************************
  2490                                  ;
  2491                                  ; _$P_Chk_Delim;
  2492                                  ;
  2493                                  ; Function: Check if AL is one of delimiter characters.
  2494                                  ;	    if AL+[si] is DBCS blank, it is replaced with two SBCS
  2495                                  ;	    blanks.
  2496                                  ;
  2497                                  ; Input:    AL = character code
  2498                                  ;	    DS:SI -> Next Character
  2499                                  ;	    ES:DI -> Parameter List
  2500                                  ;
  2501                                  ; Output:   ZF = 1 if one of delimiter characters
  2502                                  ;	    SI points to the next character
  2503                                  ; Vars:  _$P_Terminator(W), _$P_Flags(W)
  2504                                  ;
  2505                                  ;***********************************************************************
  2506                                  
  2507                                  _$P_Chk_Delim:
  2508 00000653 53                      		push	bx
  2509 00000654 51                      		push	cx
  2510                                  					; Assume terminated by space
  2511 00000655 C606[9870]20            		mov	byte [_$P_Terminator],' ' ;_$P_Space  
  2512 0000065A 8026[9E70]DF            		and	byte [_$P_Flags2],~20h ; not 20h ; 0FFh-_$P_Extra 
  2513 0000065F 3C20                    		cmp	al,' '	;_$P_Space	; Space?
  2514 00000661 7431                    		je	short _$P_Chk_Delim_Exit
  2515 00000663 3C09                    		cmp	al,9	;_$P_TAB		; TAB?
  2516 00000665 742D                    		je	short _$P_Chk_Delim_Exit
  2517 00000667 3C2C                    		cmp	al,','	;_$P_Comma	; Comma?
  2518 00000669 742C                    		je	short _$P_Chk_Delim_Exit0
  2519                                  _$P_Chk_Delim00:
  2520 0000066B 3C20                    		cmp	al,' '	;_$P_DBSP1	; 1st byte of DBCS Space?
  2521 0000066D 750C                    		jne	short _$P_Chk_Delim01
  2522 0000066F 803C20                  		cmp	byte [si],' ' ;_$P_DBSP2	; 2nd byte of DBCS Space?
  2523 00000672 7507                    		jne	short _$P_Chk_Delim01
  2524 00000674 B020                    		mov	al,' '
  2525 00000676 46                      		inc	si			; make si point to next character
  2526 00000677 38C0                    		cmp	al,al			; Set ZF
  2527 00000679 EB19                    		jmp	short _$P_Chk_Delim_Exit
  2528                                  
  2529                                  _$P_Chk_Delim01:
  2530                                  		;cmp	byte [es:di+_$Pp_num_extra],_$P_I_Have_Delim
  2531                                  		;cmp	byte [es:di+2],1	;delimiter character specified?
  2532 0000067B 807D0201                		cmp	byte [di+2],1 ; 09/11/2018
  2533 0000067F 7213                    		jb	short _$P_Chk_Delim_Exit
  2534 00000681 31C9                    		xor	cx,cx
  2535                                  		;mov	cl,[es:di+_$P_p_len_extra_delim]
  2536                                  		;mov	cl,[es:di+3]		; get length of delimiter list
  2537 00000683 8A4D03                  		mov	cl,[di+3]
  2538 00000686 E30A                    		jcxz	_$P_Chk_Delim_NZ
  2539 00000688 BB0300                  		mov	bx,3 ;_$P_Len_PARMS-1	; set bx to 1st extra delimiter
  2540                                  
  2541                                  _$P_Chk_Delim_Loop:
  2542 0000068B 43                      		inc	bx
  2543                                  		;cmp	al,[es:bx+di]		; Check extra Delim character
  2544 0000068C 3A01                    		cmp	al,[bx+di]
  2545 0000068E 7407                    		je	short _$P_Chk_Delim_Exit0
  2546 00000690 E2F9                    		loop	_$P_Chk_Delim_Loop	; examine all extra delimiter
  2547                                  
  2548                                  _$P_Chk_Delim_NZ:
  2549 00000692 3C20                    		cmp	al,' '	;_$P_Space	; reset ZF
  2550                                  
  2551                                  _$P_Chk_Delim_Exit:
  2552 00000694 59                      		pop	cx
  2553 00000695 5B                      		pop	bx
  2554 00000696 C3                      		retn
  2555                                  
  2556                                  _$P_Chk_Delim_Exit0:
  2557 00000697 A2[9870]                		mov	[_$P_Terminator],al	; keep terminated delimiter
  2558 0000069A F606[9E70]01            		test	byte [_$P_Flags2],1 ;_$P_Equ ; if terminating a key=
  2559 0000069F 7505                    		jnz	short _$P_No_Set_Extra	; then do not set the EXTRA bit
  2560                                  					; flag terminated extra delimiter or comma
  2561 000006A1 800E[9E70]20            		or	byte [_$P_Flags2],20h ;_$P_Extra
  2562                                  _$P_No_Set_Extra:
  2563 000006A6 38C0                    		cmp	al,al			; set ZF
  2564 000006A8 EBEA                    		jmp	short _$P_Chk_Delim_Exit
  2565                                  
  2566                                  ;***********************************************************************
  2567                                  ;
  2568                                  ; _$P_Chk_Switch;
  2569                                  ;
  2570                                  ; Function: Check if AL is the switch character not in first position of
  2571                                  ;	    _$P_STRING_BUF
  2572                                  ;
  2573                                  ; Input:    AL = character code
  2574                                  ;	    BX = current pointer within _$P_String_Buf
  2575                                  ;	    SI = next char on command line (following the one in AL)
  2576                                  ;
  2577                                  ; Output:   CF = 1 (set) if AL is switch character, and not in first
  2578                                  ;		 position, and has no chance of being part of a date string,
  2579                                  ;		 i.e. should be treated as a delimiter.
  2580                                  
  2581                                  ;	    CF = 0 (reset, cleared) if AL is not a switch char, is in the first
  2582                                  ;		 position, or is a slash but may be part of a date string, i.e.
  2583                                  ;		 should not be treated as a delimiter.
  2584                                  ;
  2585                                  ; Vars:  _$P_Terminator(W)
  2586                                  ;
  2587                                  ; Use:	 _$P_0099
  2588                                  ;
  2589                                  ;***********************************************************************
  2590                                  
  2591                                  _$P_Chk_Switch:
  2592                                  		;lea	bp,[_$P_STRING_BUF]
  2593                                  			; BP = OFFSET of _$P_String_Buf even in group addressing
  2594 000006AA BD[A770]                		mov	bp,_$P_STRING_BUF
  2595 000006AD 39EB                    		cmp	bx,bp			; if not first char
  2596 000006AF 7417                    		je	short _$P_STRUC_L2	; then
  2597 000006B1 3C2F                    		cmp	al,'/'	;_$P_Switch	; otherwise see if a slash
  2598 000006B3 7511                    		jne	short _$P_STRUC_L5	; not a switch char
  2599                                  						; not in first position and is slash, 
  2600 000006B5 F9                      		stc				; now see if might be in date string
  2601 000006B6 50                      		push	ax			; save input char
  2602 000006B7 8A47FF                  		mov	al,[bx-1]		; AL = char before the current char
  2603 000006BA E8A103                  		call	_$P_0099		; return carry set if not numeric
  2604 000006BD 7205                    		jc	short _$P_STRUC_L7
  2605 000006BF 8A04                    		mov	al,[si]			; AL = char after the current char
  2606 000006C1 E89A03                  		call	_$P_0099		; return carry set if not numeric
  2607                                  _$P_STRUC_L7:
  2608 000006C4 58                      		pop	ax			; restore AL to input char
  2609 000006C5 C3                      		retn				; DateSw
  2610                                  _$P_STRUC_L5:
  2611 000006C6 F8                      		clc				; not a slash
  2612 000006C7 C3                      		retn
  2613                                  _$P_STRUC_L2:
  2614 000006C8 3C2F                    		cmp	al,'/' ;_$P_Switch
  2615 000006CA 7505                    		jne	short _$P_STRUC_L12
  2616                                  					; could be valid switch, first char and is slash	
  2617 000006CC 800E[9E70]40            		or	byte [_$P_Flags2],40h ;_$P_Flags2,_$P_SW
  2618                                  _$P_STRUC_L12:
  2619 000006D1 F8                      		clc				; CF=0 indicating first char
  2620                                  _$P_STRUC_L1:					;is first char in the buffer, ZF=0
  2621 000006D2 C3                      		retn
  2622                                  
  2623                                  ;**************************************************************************
  2624                                  ;
  2625                                  ; _$P_Chk_DBCS:
  2626                                  ;
  2627                                  ;  Function: Check if a specified byte is in ranges of the DBCS lead bytes
  2628                                  ;
  2629                                  ;  Input:
  2630                                  ;	  AL	= Code to be examineed
  2631                                  ;
  2632                                  ;  Output:
  2633                                  ;	  If CF is on then a lead byte of DBCS
  2634                                  ;
  2635                                  ; Use: INT 21h w/AH=63
  2636                                  ;
  2637                                  ; Vars:  _$P_DBCSEV_Seg(RW), _$P_DBCSEV_Off(RW)
  2638                                  ;
  2639                                  ;***************************************************************************
  2640                                  
  2641                                  _$P_Chk_DBCS:
  2642 000006D3 1E                      		push	ds
  2643 000006D4 56                      		push	si
  2644 000006D5 53                      		push	bx
  2645                                  
  2646 000006D6 833E[9B70]00            		cmp	word [_$P_DBCSEV_SEG],0	; ALREADY SET ?
  2647 000006DB 7525                    		jne	short _$P_DBCS00
  2648                                  
  2649 000006DD 50                      		push	ax
  2650 000006DE 1E                      		push	ds
  2651 000006DF 51                      		push	cx
  2652 000006E0 52                      		push	dx
  2653 000006E1 57                      		push	di
  2654 000006E2 55                      		push	bp
  2655 000006E3 06                      		push	es
  2656 000006E4 31F6                    		xor	si,si
  2657 000006E6 8EDE                    		mov	ds,si
  2658 000006E8 B80063                  		mov	ax,6300h ; _$P_DOS_GetEV	; GET DBCS EV CALL
  2659 000006EB CD21                    		int	21h	; GET DOUBLE BYTE CHARACTER SET LEAD TABLE
  2660 000006ED 8CDB                    		mov	bx,ds
  2661 000006EF 09DB                    		or	bx,bx
  2662 000006F1 07                      		pop	es
  2663 000006F2 5D                      		pop	bp
  2664 000006F3 5F                      		pop	di
  2665 000006F4 5A                      		pop	dx
  2666 000006F5 59                      		pop	cx
  2667 000006F6 1F                      		pop	ds
  2668 000006F7 58                      		pop	ax
  2669 000006F8 7421                    		jz	short _$P_NON_DBCS
  2670                                  _$P_DBCS02:
  2671 000006FA 8936[9970]              		mov	[_$P_DBCSEV_OFF],si	; save EV offset
  2672 000006FE 891E[9B70]              		mov	[_$P_DBCSEV_SEG],bx	; save EV segment
  2673                                  _$P_DBCS00:
  2674                                  		;lds	si, dword ptr cs:_$P_DBCSEV_OFF
  2675 00000702 C536[9970]              		lds	si,[_$P_DBCSEV_OFF]	; load EV offset and segment
  2676                                  _$P_DBCS_LOOP:
  2677 00000706 833C00                  		cmp	word [si],0		; zero vector?
  2678 00000709 7410                    		je	short _$P_NON_DBCS	; then exit
  2679 0000070B 3A04                    		cmp	al,[si]			
  2680 0000070D 7208                    		jb	short _$P_DBCS01	; Check if AL is in
  2681 0000070F 3A4401                  		cmp	al,[si+1]		;   range of
  2682 00000712 7703                    		ja	short _$P_DBCS01	;      the vector
  2683 00000714 F9                      		stc				; if yes, indicate DBCS and exit
  2684 00000715 EB05                    		jmp	short _$P_DBCS_EXIT
  2685                                  _$P_DBCS01:
  2686 00000717 46                      		inc	si			; add '2' to
  2687 00000718 46                      		inc	si			;  SI reg
  2688 00000719 EBEB                    		jmp	short _$P_DBCS_LOOP	; loop until zero vector found
  2689                                  _$P_NON_DBCS:
  2690 0000071B F8                      		clc				; indicate SBCS
  2691                                  _$P_DBCS_EXIT:
  2692 0000071C 5B                      		pop	bx
  2693 0000071D 5E                      		pop	si
  2694 0000071E 1F                      		pop	ds
  2695 0000071F C3                      		retn
  2696                                  
  2697                                  ;***********************************************************************
  2698                                  ;
  2699                                  ; _$P_Chk_Pos_Control
  2700                                  ;
  2701                                  ; Function: Parse CONTROL block for a positional
  2702                                  ;
  2703                                  ; Input:     ES:BX -> CONTROL block
  2704                                  ;	     psdata_seg:SI -> _$P_STRING_BUF
  2705                                  ;
  2706                                  ; Output:    None
  2707                                  ;
  2708                                  ; Use:	 _$P_Fill_Result, _$P_Check_Match_Flags
  2709                                  ;
  2710                                  ; Vars: _$P_Ordinal(W), _$P_RC(W)
  2711                                  ;
  2712                                  ;***********************************************************************
  2713                                  
  2714                                  _$P_Chk_Pos_Control:
  2715 00000720 50                      		push	ax
  2716                                  		;mov	ax,[es:bx] ; [es:bx+_$P_Match_Flag]
  2717 00000721 8B07                    		mov	ax,[bx] ; 09/11/2018
  2718 00000723 A90200                  		test	ax,2 ;_$P_Repeat		; repeat allowed?
  2719 00000726 7504                    		jnz	short _$P_CPC00		; then do not increment ORDINAL
  2720                                  		;inc	word [_$P_ordinal]
  2721 00000728 FE06[9070]              		inc	byte [_$P_ordinal]	; update the ordinal
  2722                                  _$P_CPC00:
  2723 0000072C 803C00                  		cmp	byte [si],0 ;_$P_NULL	; no data?
  2724 0000072F 7516                    		jne	short _$P_CPC01
  2725 00000731 A90100                  		test	ax,1 ;_$P_Optional	; yes, then is it optional?
  2726 00000734 7507                    		jnz	short _$P_CPC02
  2727                                  		;mov	word [_$P_RC],2		; no, then error
  2728 00000736 C606[9270]02            		mov	byte [_$P_RC],2 ;_$P_Op_Missing
  2729 0000073B EB0D                    		jmp	short _$P_CPC_Exit
  2730                                  _$P_CPC02:
  2731 0000073D 50                      		push	ax
  2732                                  		;mov	al,_$P_String		;if it is optional return NULL
  2733                                  		;mov	ah,_$P_No_Tag
  2734 0000073E B803FF                  		mov	ax,0FF03h
  2735 00000741 E88A00                  		call	_$P_Fill_Result
  2736 00000744 58                      		pop	ax
  2737 00000745 EB03                    		jmp	short _$P_CPC_Exit
  2738                                  _$P_CPC01:
  2739 00000747 E8F400                  		call	_$P_Check_Match_Flags
  2740                                  _$P_CPC_Exit:
  2741 0000074A 58                      		pop	ax
  2742 0000074B C3                      		retn
  2743                                  
  2744                                  ;***********************************************************************
  2745                                  ;
  2746                                  ; _$P_Chk_Key_Control
  2747                                  ;
  2748                                  ; Function: Parse CONTROL block for a keyword
  2749                                  ;
  2750                                  ; Input:     ES:BX -> CONTROL block
  2751                                  ;	     psdata_seg:SI -> _$P_STRING_BUF
  2752                                  ;
  2753                                  ; Output:    CY = 1 : not match
  2754                                  ;
  2755                                  ; Use:	 _$P_Fill_Result, _$P_Search_KEYorSW, _$P_Check_Match_Flags
  2756                                  ;
  2757                                  ; Vars: _$P_RC(W), _$P_SaveSI_Cmpx(W), _$P_KEYorSW_Ptr(R), _$P_Flags(W)
  2758                                  ;
  2759                                  ;***********************************************************************
  2760                                  
  2761                                  _$P_Chk_Key_Control:
  2762                                  ;IF	KeySW					; (Check if keyword is supported)
  2763                                  ;		or	psdata_seg:_$P_Flags2,_$P_Key_Cmp 
  2764                                  ;					; Indicate keyword for later string comparison
  2765                                  ;		call	_$P_Search_KEYorSW 	; Search the keyword in the CONTROL block
  2766                                  ;		jc	_$P_Chk_Key_Err0   	;  not found, then try next CONTROL
  2767                                  ;
  2768                                  ;		and	psdata_seg:_$P_Flags2,0ffh-_$P_Key_Cmp ; reset the indicator previously set
  2769                                  ;
  2770                                  ;		push	ax			      ; keyword=
  2771                                  ;		mov	ax,psdata_seg:_$P_KEYorSW_Ptr ; ^       ^
  2772                                  ;		sub	ax,si			; SI	KEYorSW
  2773                                  ;		add	psdata_seg:_$P_SaveSI_Cmpx,ax ; update for complex, quoted or file spec.
  2774                                  ;		pop	ax
  2775                                  ;
  2776                                  ;		mov	si,psdata_seg:_$P_KEYorSW_Ptr ; set si just after equal char
  2777                                  ;		cmp	byte ptr psdata_seg:[si],_$P_NULL ; any data after equal?
  2778                                  ;		je	_$P_Chk_Key_Err1 	; if no, syntax error
  2779                                  ;
  2780                                  ;		call	_$P_Check_Match_Flags	; else, process match flags
  2781                                  ;		clc				
  2782                                  ;		jmp	short _$P_Chk_Key_Exit
  2783                                  ;
  2784                                  ;_$P_Chk_Key_Err0:
  2785                                  ;		stc				; not found in keyword synonym list
  2786                                  ;		jmp	short _$P_Chk_Key_Exit
  2787                                  ;
  2788                                  ;_$P_Chk_Key_Err1:
  2789                                  ;		mov	psdata_seg:_$P_RC,_$P_Syntax ; no parameter is not specified after "="
  2790                                  ;_$P_Chk_Key_ErrExit:
  2791                                  ;		push	ax
  2792                                  ;		mov	al,_$P_String		; set
  2793                                  ;		mov	ah,_$P_No_Tag		;    result
  2794                                  ;		call	_$P_Fill_Result		; 	 buffer
  2795                                  ;		pop	ax			
  2796                                  ;		clc
  2797                                  ;$_P_Chk_Key_Exit:
  2798                                  ;		retn
  2799                                  ;ELSE						; (of IF KeySW)
  2800 0000074C F9                      		stc				;   this logic works when the KeySW
  2801 0000074D C3                      		retn				;   is reset.
  2802                                  ;ENDIF						; (of KeySW)
  2803                                  
  2804                                  ;***********************************************************************
  2805                                  ;
  2806                                  ; _$P_Search_KEYorSW:
  2807                                  ;
  2808                                  ; Function: Seach specified keyword or switch from CONTROL
  2809                                  ;
  2810                                  ; Input:     ES:BX -> CONTROL block
  2811                                  ;	     psdata_seg:SI -> _$P_STRING_BUF
  2812                                  ;
  2813                                  ; Output:    CY = 1 : not match
  2814                                  ;
  2815                                  ; Use:	 _$P_String_Comp, _$P_MoveBP_NUL, _$P_Found_SYNONYM
  2816                                  ;
  2817                                  ;***********************************************************************
  2818                                  
  2819                                  _$P_Search_KEYorSW:
  2820 0000074E 55                      		push	bp
  2821 0000074F 51                      		push	cx
  2822                                  		;mov	cl,[es:bx+8] ; [es:bx+_$P_nid] ; Get synonym count
  2823 00000750 8A4F08                  		mov	cl,[bx+8] ; 09/11/2018
  2824 00000753 30ED                    		xor	ch,ch
  2825 00000755 E30D                    		jcxz	_$P_KEYorSW_Not_Found
  2826                                  		;lea	bp,es:[bx]._$P_KEYorSW	; BP points to the 1st synonym
  2827                                  		;lea	bp,[bx+_$P_KEYorSW]
  2828 00000757 8D6F09                  		lea	bp,[bx+9]
  2829                                  _$P_KEYorSW_Loop:
  2830 0000075A E83103                  		call	_$P_String_Comp
  2831 0000075D 7308                    		jnb	short _$P_KEYorSW_Found
  2832 0000075F E80D00                  		call	_$P_MoveBP_NUL
  2833 00000762 E2F6                    		loop	_$P_KEYorSW_Loop
  2834                                  _$P_KEYorSW_Not_Found:
  2835 00000764 F9                      		stc
  2836 00000765 EB05                    		jmp	short _$P_KEYorSW_Exit
  2837                                  _$P_KEYorSW_Found:
  2838 00000767 892E[A570]              		mov	[_$P_Found_SYNONYM],bp
  2839 0000076B F8                      		clc
  2840                                  _$P_KEYorSW_Exit:
  2841 0000076C 59                      		pop	cx
  2842 0000076D 5D                      		pop	bp
  2843 0000076E C3                      		retn
  2844                                  
  2845                                  ;***********************************************************************
  2846                                  ; _$P_MoveBP_NUL
  2847                                  ;***********************************************************************
  2848                                  
  2849                                  _$P_MoveBP_NUL:	; 09/11/2018
  2850                                  		;cmp	byte [es:bp],0 ;_$P_NULL ; Increment BP that points
  2851 0000076F 807E0000                		cmp	byte [bp],0  ; (SS = CS = DS = ES)		
  2852 00000773 7403                    		jz	short _$P_MBP_Exit	; to the synomym list
  2853 00000775 45                      		inc	bp			; until
  2854 00000776 EBF7                    		jmp	short _$P_MoveBP_NUL	; NULL encountered.
  2855                                  _$P_MBP_Exit:
  2856 00000778 45                      		inc	bp			; bp points to next to NULL
  2857 00000779 C3                      		retn
  2858                                  
  2859                                  ;***********************************************************************
  2860                                  ;
  2861                                  ; _$P_Chk_SW_Control
  2862                                  ;
  2863                                  ; Function: Parse CONTROL block for a switch
  2864                                  ;
  2865                                  ; Input:     ES:BX -> CONTROL block
  2866                                  ;	     psdata_seg:SI -> _$P_STRING_BUF
  2867                                  ;
  2868                                  ; Output:    CY = 1 : not match
  2869                                  ;
  2870                                  ; Use:	 _$P_Fill_Result, _$P_Search_KEYorSW, _$P_Check_Match_Flags
  2871                                  ;
  2872                                  ; Vars:  _$P_SaveSI_Cmpx(W), _$P_KEYorSW_Ptr(R), _$P_Flags(W)
  2873                                  ;
  2874                                  ;**********************************************************************
  2875                                  
  2876                                  _$P_Chk_SW_Control:
  2877                                  ;IF	SwSW					; (Check if switch is supported)
  2878 0000077A 800E[9E70]10            		or	byte [_$P_Flags2],10h	;_$P_Sw_Cmp
  2879                                  					; Indicate switch for later string comparison
  2880 0000077F E8CCFF                  		call	_$P_Search_KEYorSW ; Search the switch in the CONTROL block
  2881 00000782 723E                    		jc	short _$P_Chk_SW_Err0 ; not found, then try next CONTROL
  2882                                  					; reset the indicator previously set
  2883 00000784 8026[9E70]EF            		and	byte [_$P_Flags2],~10h ; not 10h  ; 0EFh ; 0FFh-_$P_Sw_Cmp
  2884                                  
  2885 00000789 50                      		push	ax			; /switch:
  2886 0000078A A1[A170]                		mov	ax,[_$P_KEYorSW_Ptr]	; ^       ^
  2887 0000078D 29F0                    		sub	ax,si			; SI  KEYorSW
  2888 0000078F 0106[9F70]              		add	[_$P_SaveSI_Cmpx],ax	; update for complex list
  2889 00000793 58                      		pop	ax
  2890 00000794 8B36[A170]              		mov	si,[_$P_KEYorSW_Ptr]	; set si at the end or colon
  2891 00000798 803C00                  		cmp	byte [si],0 ;_$P_NULL	; any data after colon
  2892 0000079B 751F                    		jne	short _$P_CSW00		; if yes, process match flags
  2893                                  						; if no, the switch terminated by colon?
  2894 0000079D 807CFF3A                		cmp	byte [si-1],':' ;_$P_Colon 
  2895 000007A1 7507                    		jne	short _$P_Chk_if_data_required ; if yes,
  2896                                  		;mov	word [_$P_RC],9 ; _$P_Syntax ; return syntax error
  2897 000007A3 C606[9270]09            		mov	byte [_$P_RC],9		
  2898 000007A8 EB1A                    		jmp	short _$P_Chk_SW_Exit
  2899                                  
  2900                                  _$P_Chk_if_data_required:			; no data, no colon
  2901                                  						; should have data? 
  2902                                  		;cmp	word [es:bx++_$P_Match_Flag],0 ; zero match flag means 
  2903 000007AA 833F00                  		cmp	word [bx],0		      ; switch followed by nothing is OK
  2904 000007AD 7415                    		je	short _$P_Chk_SW_Exit	; match flags not zero 
  2905                                  						;    so should have something 
  2906                                  						;       if optional bit is not on
  2907                                  		;test	es:[bx]._$P_Match_Flag,_$P_Optional
  2908                                  		;test	word [es:bx],1 ;_$P_Optional ; see if no value is valid
  2909 000007AF F7070100                		test	word [bx],1
  2910 000007B3 750F                    		jnz	short _$P_Chk_SW_Exit
  2911                                  
  2912                                  		;mov	word [_$P_RC],2	;_$P_Op_Missing ; return required operand missing
  2913 000007B5 C606[9270]02            		mov	byte [_$P_RC],2
  2914 000007BA EB08                    		jmp	short _$P_Chk_SW_Exit
  2915                                  _$P_CSW00:
  2916 000007BC E87F00                  		call	_$P_Check_Match_Flags	; process match flag
  2917 000007BF F8                      		clc				; indicate match
  2918 000007C0 EB0B                    		jmp	short _$P_Chk_SW_Single_Exit
  2919                                  _$P_Chk_SW_Err0:
  2920 000007C2 F9                      		stc				; not found in switch synonym list
  2921 000007C3 C3                      		retn
  2922                                  _$P_Chk_SW_Exit:
  2923 000007C4 50                      		push	ax
  2924                                  		;mov	al,_$P_String
  2925                                  		;mov	ah,_$P_No_Tag
  2926 000007C5 B803FF                  		mov	ax,0FF03h
  2927 000007C8 E80300                  		call	_$P_Fill_Result		; set result buffer
  2928 000007CB 58                      		pop	ax
  2929 000007CC F8                      		clc
  2930                                  _$P_Chk_SW_Single_Exit:
  2931 000007CD C3                      		retn
  2932                                  ;ELSE						;(of IF KeySW)
  2933                                  ;		stc				;  this logic works when the KeySW
  2934                                  ;		retn				;  is reset.
  2935                                  ;ENDIF						;(of KeySW)
  2936                                  
  2937                                  ;***********************************************************************
  2938                                  ;
  2939                                  ; _$P_Fill_Result
  2940                                  ;
  2941                                  ; Function: Fill the result buffer
  2942                                  ;
  2943                                  ; Input:    AH = Item tag
  2944                                  ;	    AL = type
  2945                                  ;		  AL = 1: CX,DX has 32bit number (CX = high)
  2946                                  ;		  AL = 2: DX has index(offset) into value list
  2947                                  ;		  AL = 6: DL has driver # (1-A, 2-B, ... , 26 - Z)
  2948                                  ;		  AL = 7: DX has year, CL has month and CH has date
  2949                                  ;		  AL = 8: DL has hours, DH has minutes, CL has seconds,
  2950                                  ;			  amd CH has hundredths
  2951                                  ;		  AL = else: psdata_seg:SI points to returned string buffer
  2952                                  ;	    ES:BX -> CONTROL block
  2953                                  ;
  2954                                  ; Output:   None
  2955                                  ;
  2956                                  ; Use:	_$P_Do_CAPS_String, _$P_Remove_Colon, _$P_Found_SYNONYM
  2957                                  ;
  2958                                  ; Vars: _$P_DX(W)
  2959                                  ;
  2960                                  ;***********************************************************************
  2961                                  
  2962                                  _$P_Fill_Result:		; 09/11/2018
  2963 000007CE 57                      		push	di
  2964                                  		;mov	di,[es:bx+_$P_Result_Buf] ; di points to result buffer
  2965                                  		;mov	di,[es:bx+4]
  2966 000007CF 8B7F04                  		mov	di,[bx+4]
  2967 000007D2 893E[9670]              		mov	[_$P_DX],di		; set returned result address
  2968                                  		;mov	[es:di],al ;[es:di+_$P_Type]	; store type
  2969                                  		;mov	[es:di+1],ah ;[es:di+_$P_Item_Tag] ; store item tag
  2970                                  		;mov	[es:di],ax
  2971 000007D6 8905                    		mov	[di],ax
  2972 000007D8 50                      		push	ax
  2973 000007D9 A1[A570]                		mov	ax,[_$P_Found_SYNONYM]	; if yes,
  2974                                  		;mov	[es:di+_$P_SYNONYM_Ptr],ax
  2975                                  		;mov	[es:di+2],ax		; then set it to the result
  2976 000007DC 894502                  		mov	[di+2],ax
  2977 000007DF 58                      		pop	ax
  2978                                  _$P_RLT04:
  2979 000007E0 3C01                    		cmp	al,1 ;_$P_Number		; if number
  2980 000007E2 7508                    		jne	short _$P_RLT00
  2981                                  _$P_RLT02:
  2982                                  		;mov	word ptr es:[di]._$P_Picked_Val,dx
  2983                                  		;mov	[es:di+4],dx		; then store 32bit number
  2984 000007E4 895504                  		mov	[di+4],dx
  2985                                  		;mov	word ptr es:[di+2]._$P_Picked_Val,cx
  2986                                  		;mov	[es:di+6],cx
  2987 000007E7 894D06                  		mov	[di+6],cx
  2988 000007EA EB50                    		jmp	short _$P_RLT_Exit
  2989                                  _$P_RLT00:
  2990 000007EC 3C02                    		cmp	al,2 ;_$P_List_Idx	; if list index
  2991 000007EE 7505                    		jne	short _$P_RLT01
  2992                                  		;mov	[es:di+4],dx		; then store list index
  2993 000007F0 895504                  		mov	[di+4],dx
  2994 000007F3 EB47                    		jmp	short _$P_RLT_Exit
  2995                                  _$P_RLT01:
  2996 000007F5 3C07                    		cmp	al,7 ;_$P_Date_F		; Date format?
  2997 000007F7 74EB                    		je	short _$P_RLT02
  2998 000007F9 3C08                    		cmp	al,8 ;_$P_Time_F		; Time format?
  2999 000007FB 74E7                    		je	short _$P_RLT02
  3000 000007FD 3C06                    		cmp	al,6 ;_$P_Drive		; drive format?
  3001 000007FF 7505                    		jne	short _$P_RLT03
  3002                                  		;mov	byte ptr es:[di]._$P_Picked_Val,dl
  3003                                  		;mov	[es:di+4],dl		; store drive number
  3004 00000801 885504                  		mov	[di+4],dl
  3005 00000804 EB36                    		jmp	short _$P_RLT_Exit
  3006                                  _$P_RLT03:
  3007 00000806 3C04                    		cmp	al,4 ;_$P_Complex	; complex format?
  3008 00000808 750C                    		jne	short _$P_RLT05
  3009 0000080A A1[9F70]                		mov	ax,[_$P_SaveSI_Cmpx]	; then get pointer in command buffer
  3010 0000080D 40                      		inc	ax			; skip left Parentheses
  3011                                  		;mov	[es:di+_$P_Picked_Val],ax
  3012 0000080E 894504                  		mov	[di+4],ax		; store offset
  3013                                  		;mov	[es:di+_$P_Picked_Val+2],ds
  3014 00000811 8C5D06                  		mov	[di+6],ds		; store segment
  3015 00000814 EB26                    		jmp	short _$P_RLT_Exit
  3016                                  _$P_RLT05:
  3017                                  		;mov	[es:di+_$P_Picked_Val],si
  3018 00000816 897504                  		mov	[di+4],si		; store offset of STRING_BUF
  3019                                  		;mov	word [es:di+_$P_Picked_Val+2],Psdata_Seg
  3020 00000819 8C4D06                  		mov	[di+6],cs		; store segment of STRING_BUF
  3021 0000081C 50                      		push	ax
  3022                                  		;test	byte [es:bx+_$P_Function_Flag],_$P_CAP_File
  3023 0000081D F6470201                		test	byte [bx+2],1		; need CAPS by file table?
  3024 00000821 7404                    		jz	short _$P_RLT_CAP00
  3025 00000823 B004                    		mov	al,4 ;_$P_DOSTBL_File	; use file upper case table
  3026 00000825 EB08                    		jmp	short _$P_RLT_CAP02
  3027                                  _$P_RLT_CAP00:
  3028                                  		;test	byte [es:bx+_$P_Function_Flag],_$P_CAP_Char
  3029 00000827 F6470202                		test	byte [bx+2],2		; need CAPS by char table?
  3030 0000082B 7405                    		jz	short _$P_RLT_CAP01
  3031 0000082D B002                    		mov	al,2 ;_$P_DOSTBL_Char	; use character upper case table
  3032                                  _$P_RLT_CAP02:
  3033 0000082F E8AE00                  		call	_$P_Do_CAPS_String	; process CAPS along the table
  3034                                  _$P_RLT_CAP01:
  3035 00000832 58                      		pop	ax
  3036                                  		;test	byte [es:bx+_$P_Function_Flag],_$P_Rm_Colon
  3037 00000833 F6470210                		test	byte [bx+2],10h		; removing colon at end?
  3038 00000837 7403                    		jz	short _$P_RLT_Exit
  3039 00000839 E88100                  		call	_$P_Remove_Colon	; then process it.	
  3040                                  _$P_RLT_Exit:
  3041 0000083C 5F                      		pop	di
  3042 0000083D C3                      		retn
  3043                                  
  3044                                  ;***********************************************************************
  3045                                  ;
  3046                                  ; _$P_Check_Match_Flags
  3047                                  ;
  3048                                  ; Function:  Check the match_flags and make the exit code and set the
  3049                                  ;	     result buffer
  3050                                  ;
  3051                                  ;	    Check for types in this order:
  3052                                  ;		Complex
  3053                                  ;		Date
  3054                                  ;		Time
  3055                                  ;		Drive
  3056                                  ;		Filespec
  3057                                  ;		Quoted String
  3058                                  ;		Simple String
  3059                                  ;
  3060                                  ; Input:     psdata_seg:SI -> _$P_STRING_BUF
  3061                                  ;	     ES:BX -> CONTROL block
  3062                                  ;
  3063                                  ; Output:    None
  3064                                  ;
  3065                                  ; Use:	     _$P_Value, P$_SValue, _$P_Simple_String, _$P_Date_Format
  3066                                  ;	     _$P_Time_Format, _$P_Complex_Format, _$P_File_Foemat
  3067                                  ;	     _$P_Drive_Format
  3068                                  ;
  3069                                  ;***********************************************************************
  3070                                  
  3071                                  _$P_Check_Match_Flags:
  3072 0000083E C606[5271]00            		mov	byte [_$P_err_flag],0 ;_$P_NULL	
  3073                                  						; clear filespec error flag.
  3074 00000843 50                      		push	ax
  3075                                  		;mov	ax,[es:bx] ; [es:bx+_$P_Match_Flag] 
  3076 00000844 8B07                    		mov	ax,[bx]			; load match flag(16bit) to ax
  3077 00000846 09C0                    		or	ax,ax			; test ax for zero
  3078 00000848 7515                    		jnz	short _$P_Mat
  3079 0000084A 50                      		push	ax
  3080 0000084B 53                      		push	bx
  3081 0000084C 52                      		push	dx
  3082 0000084D 57                      		push	di
  3083                                  		;mov	word [_$P_RC],9
  3084 0000084E C606[9270]09            		mov	byte [_$P_RC],9 ;_$P_Syntax
  3085                                  		;mov	ah,_$P_No_Tag ; 0FFh
  3086                                  		;mov	al,_$P_String ; 03h
  3087 00000853 B803FF                  		mov	ax,0FF03h
  3088 00000856 E875FF                  		call	_$P_Fill_Result
  3089 00000859 5F                      		pop	di
  3090 0000085A 5A                      		pop	dx
  3091 0000085B 5B                      		pop	bx
  3092 0000085C 58                      		pop	ax
  3093                                  		;jmp	short _$P_Bridge
  3094 0000085D EB49                    		jmp	short _$P_Match_Exit
  3095                                  _$P_Mat:
  3096 0000085F A90010                  		test	ax,1000h ;_$P_Date_S	; Date string	
  3097 00000862 740F                    		jz	short _$P_Match01
  3098                                  		;mov	word [_$P_RC],0
  3099 00000864 C606[9270]00            		mov	byte [_$P_RC],0 ;_$P_No_Error ; assume no error
  3100 00000869 E8B502                  		call	_$P_Date_Format
  3101                                  		;cmp	word [_$P_RC],9
  3102 0000086C 803E[9270]09            		cmp	byte [_$P_RC],9 ;_$P_Syntax ; if error, examine the next type
  3103                                  		;jne	short _$P_Bridge
  3104 00000871 7535                    		jne	short _$P_Match_Exit
  3105                                  _$P_Match01:
  3106                                  ;		jmp	short _$P_Match03		
  3107                                  ;_$P_Bridge:
  3108                                  ;		jmp	short _$P_Match_Exit
  3109                                  _$P_Match03:
  3110 00000873 A90080                  		test	ax,8000h ;_$P_Num_Val	; Numeric value
  3111 00000876 740F                    		jz	short _$P_Match04
  3112                                  		;mov	word [_$P_RC],0
  3113 00000878 C606[9270]00            		mov	byte [_$P_RC],0 ;_$P_No_Error ; assume no error
  3114 0000087D E8D600                  		call	_$P_Value		; do process
  3115                                  		;cmp	word [_$P_RC],9
  3116 00000880 803E[9270]09            		cmp	byte [_$P_RC],9		; if error, examine the next type
  3117 00000885 7521                    		jne	short _$P_Match_Exit
  3118                                  _$P_Match04:
  3119 00000887 A90040                  		test	ax,4000h ;_$P_SNum_Val	; Signed numeric value
  3120 0000088A 740F                    		jz	short _$P_Match05
  3121                                  		;mov	word [_$P_RC],0
  3122 0000088C C606[9270]00            		mov	byte [_$P_RC],0 ;_$P_No_Error ; assume no error
  3123 00000891 E8A200                  		call	_$P_SValue		; do process
  3124                                  		;cmp	word [_$P_RC],9
  3125 00000894 803E[9270]09            		cmp	byte [_$P_RC],9 ;_$P_Syntax ; if error, examine the next type
  3126 00000899 750D                    		jne	short _$P_Match_Exit
  3127                                  _$P_Match05:
  3128 0000089B A90020                  		test	ax,2000h ;_$P_Simple_S	; Signed numeric value
  3129 0000089E 7408                    		jz	short _$P_Match_Exit
  3130                                  		;mov	word [_$P_RC],0		; assume no error
  3131 000008A0 C606[9270]00            		mov	byte [_$P_RC],0 ;_$P_No_Error
  3132 000008A5 E8C401                  		call	_$P_Simple_String	; do process
  3133                                  _$P_Match_Exit:
  3134 000008A8 803E[5271]01            		cmp	byte [_$P_err_flag],1 ;_$P_error_filespec ; bad filespec?
  3135 000008AD 750C                    		jne	short _$P_Match2_Exit	; no, continue
  3136                                  		;cmp	word [_$P_RC],0
  3137 000008AF 803E[9270]00            		cmp	byte [_$P_RC],0 ;_$P_No_Error ; check for other errors?
  3138 000008B4 7505                    		jne	short _$P_Match2_Exit	; no, continue
  3139                                  		;mov	word [_$P_RC],9
  3140 000008B6 C606[9270]09            		mov	byte [_$P_RC],9 ;_$P_Syntax ; set error flag
  3141                                  _$P_Match2_Exit:
  3142 000008BB 58                      		pop	ax
  3143 000008BC C3                      		retn
  3144                                  
  3145                                  ;***********************************************************************
  3146                                  ;
  3147                                  ; _$P_Remove_Colon;
  3148                                  ;
  3149                                  ; Function: Remove colon at end
  3150                                  ;
  3151                                  ; Input:    psdata_seg:SI points to string buffer to be examined
  3152                                  ;
  3153                                  ; Output:   None
  3154                                  ;
  3155                                  ; Use:	_$P_Chk_DBCS
  3156                                  ;
  3157                                  ;***********************************************************************
  3158                                  
  3159                                  _$P_Remove_Colon:
  3160 000008BD 50                      		push	ax
  3161 000008BE 56                      		push	si
  3162                                  _$P_RCOL_Loop:
  3163 000008BF 8A04                    		mov	al,[si]			; get character
  3164 000008C1 08C0                    		or	al,al			; end of string?
  3165 000008C3 7418                    		jz	short _$P_RCOL_Exit	; if yes, just exit
  3166 000008C5 3C3A                    		cmp	al,':'			; is it colon?
  3167 000008C7 750B                    		jne	short _$P_RCOL00
  3168 000008C9 807C0100                		cmp	byte [si+1],0 ;_$P_NULL	; if so, next is NULL?
  3169 000008CD 7505                    		jne	short _$P_RCOL00	; no, then next char	
  3170 000008CF C60400                  		mov	byte [si],0		; yes, remove colon
  3171 000008D2 EB09                    		jmp	short _$P_RCOL_Exit	; and exit.
  3172                                  _$P_RCOL00:
  3173 000008D4 E8FCFD                  		call	_$P_Chk_DBCS		; if not colon, then check if
  3174 000008D7 7301                    		jnc	short _$P_RCOL01	; DBCS leading byte.
  3175 000008D9 46                      		inc	si			; if yes, skip trailing byte
  3176                                  _$P_RCOL01:
  3177 000008DA 46                      		inc	si			; si points to next byte
  3178 000008DB EBE2                    		jmp	short _$P_RCOL_Loop	; loop until NULL encountered
  3179                                  _$P_RCOL_Exit:
  3180 000008DD 5E                      		pop	si
  3181 000008DE 58                      		pop	ax
  3182 000008DF C3                      		retn
  3183                                  
  3184                                  ;***********************************************************************
  3185                                  ;
  3186                                  ; _$P_Do_CAPS_String;
  3187                                  ;
  3188                                  ; Function: Perform capitalization along with the file case map table
  3189                                  ;	    or character case map table.
  3190                                  ;
  3191                                  ; Input:    AL = 2 : Use character table
  3192                                  ;	    AL = 4 : Use file table
  3193                                  ;	    psdata_seg:SI points to string buffer to be capitalized
  3194                                  ;
  3195                                  ; Output:   None
  3196                                  ;
  3197                                  ; Use:	_$P_Do_CAPS_Char, _$P_Chk_DBCS
  3198                                  ;
  3199                                  ;***********************************************************************
  3200                                  
  3201                                  _$P_Do_CAPS_String:
  3202 000008E0 56                      		push	si
  3203 000008E1 52                      		push	dx
  3204 000008E2 88C2                    		mov	dl,al			; save info id
  3205                                  _$P_DCS_Loop:
  3206 000008E4 8A04                    		mov	al,[si]			; load character and
  3207 000008E6 E8EAFD                  		call	_$P_Chk_DBCS		; check if DBCS leading byte
  3208 000008E9 720B                    		jc	short _$P_DCS00		; if yes, do not need CAPS
  3209 000008EB 08C0                    		or	al,al			; end of string?
  3210 000008ED 740B                    		jz	short _$P_DCS_Exit	; then exit.
  3211 000008EF E80B00                  		call	_$P_Do_CAPS_Char	; Here a SBCS char need to be CAPS
  3212 000008F2 8804                    		mov	[si],al			; stored upper case char to buffer
  3213 000008F4 EB01                    		jmp	short _$P_DCS01		; process nexit
  3214                                  _$P_DCS00:
  3215 000008F6 46                      		inc	si			; skip DBCS leading and trailing byte
  3216                                  _$P_DCS01:
  3217 000008F7 46                      		inc	si			; si point to next byte
  3218 000008F8 EBEA                    		jmp	short _$P_DCS_Loop	; loop until NULL encountered
  3219                                  _$P_DCS_Exit:
  3220 000008FA 5A                      		pop	dx
  3221 000008FB 5E                      		pop	si
  3222 000008FC C3                      		retn
  3223                                  
  3224                                  ;***********************************************************************
  3225                                  ;
  3226                                  ; _$P_Do_CAPS_Char;
  3227                                  ;
  3228                                  ; Function: Perform capitalization along with the file case map table
  3229                                  ;	    or character case map table.
  3230                                  ;
  3231                                  ; Input:    DL = 2 : Use character table
  3232                                  ;	    DL = 4 : Use file table
  3233                                  ;	    AL = character to be capitalized
  3234                                  ;
  3235                                  ; Output:   None
  3236                                  ;
  3237                                  ; Use:	INT 21h /w AH=65h
  3238                                  ;
  3239                                  ;***********************************************************************
  3240                                  
  3241                                  _$P_Do_CAPS_Char:
  3242 000008FD 3C80                    		cmp	al,80h	;_$P_ASCII80 ; need upper case table?
  3243 000008FF 730B                    		jnb	short _$P_DCC_Go ; if no,
  3244 00000901 3C61                    		cmp	al,'a'		 ;   check if  "a" <= AL <= "z"
  3245 00000903 7230                    		jb	short _$P_CAPS_Ret
  3246 00000905 3C7A                    		cmp	al,'z'
  3247 00000907 772C                    		ja	short _$P_CAPS_Ret ;   if yes, make CAPS	
  3248 00000909 24DF                    		and	al,0DFh ;_$P_Make_Upper	;   else do nothing.
  3249 0000090B C3                      		retn
  3250                                  _$P_DCC_Go:
  3251 0000090C 53                      		push	bx
  3252 0000090D 06                      		push	es
  3253 0000090E 57                      		push	di
  3254                                  		;lea	di,[_$P_Char_CAP_Ptr]
  3255 0000090F BF[4D71]                		mov	di,_$P_Char_CAP_Ptr
  3256                                  _$P_DCC00:
  3257 00000912 3815                    		cmp	[di],dl		; already got table address?
  3258 00000914 7413                    		je	short _$P_DCC01	; if no,
  3259                                  
  3260                                  ;In this next section, ES will be used to pass a 5 byte workarea to INT 21h,
  3261                                  ; the GET COUNTYRY INFO call. 
  3262                                  
  3263 00000916 50                      		push	ax
  3264 00000917 51                      		push	cx
  3265 00000918 52                      		push	dx
  3266                                  		;push	cs
  3267                                  		;pop	es
  3268                                  				; ES:DI = pointer to output buffer
  3269 00000919 92                      		xchg	ax,dx
  3270 0000091A B465                    		mov	ah,65h ;_$P_DOS_Get_TBL
  3271                                  				; Get Extended Country Information
  3272 0000091C BBFFFF                  		mov	bx,-1 ; 0FFFFh ; _$P_DOSTBL_Def ; get active CON
  3273 0000091F B90500                  		mov	cx,5 ;_$P_DOSTBL_BL ; buffer length
  3274 00000922 89DA                    		mov	dx,bx ; -1 ; get for default code page
  3275 00000924 CD21                    		int	21h	; COUNTRY-DEPENDENT FILENAME CAPITALIZATION
  3276                                  				; AL = function	- (02h or 04h)
  3277 00000926 5A                      		pop	dx
  3278 00000927 59                      		pop	cx
  3279 00000928 58                      		pop	ax
  3280                                  _$P_DCC01:
  3281                                  				  ; [ES:DI] = country id (02h or 04h)
  3282 00000929 C45D01                  		les	bx,[di+1] ; [ES:DI+1] = pointer to uppercase table
  3283 0000092C 43                      		inc	bx	; add 2 to bx reg
  3284 0000092D 43                      		inc	bx	; to skip length field	
  3285 0000092E 2C80                    		sub	al,80h	; make char to index
  3286                                  		;xlat	byte ptr es:[bx]
  3287 00000930 26                      		es		; segment prefix (xlat byte ptr es:[bx])
  3288 00000931 D7                      		xlat		; perform case map
  3289 00000932 5F                      		pop	di
  3290 00000933 07                      		pop	es
  3291 00000934 5B                      		pop	bx
  3292                                  _$P_CAPS_Ret:
  3293 00000935 C3                      		retn
  3294                                  
  3295                                  ;***********************************************************************
  3296                                  ;
  3297                                  ; _$P_Value / _$P_SValue
  3298                                  ;
  3299                                  ; Function:  Make 32bit value from psdata_seg:SI and see value list
  3300                                  ;	     and make result buffer.
  3301                                  ;	     _$P_SValue is an entry point for the signed value
  3302                                  ;	     and this will simply call _$P_Value after the handling
  3303                                  ;	     of the sign character, "+" or "-"
  3304                                  ;
  3305                                  ; Input:     psdata_seg:SI -> _$P_STRING_BUF
  3306                                  ;	     ES:BX -> CONTROL block
  3307                                  ;
  3308                                  ; Output:    None
  3309                                  ;
  3310                                  ; Use:	_$P_Fill_Result, _$P_Check_OVF
  3311                                  ;
  3312                                  ; Vars: _$P_RC(W), _$P_Flags(RW)
  3313                                  ;
  3314                                  ;***********************************************************************
  3315                                  
  3316                                  _$P_SValue:				; when signed value here
  3317 00000936 50                      		push	ax
  3318 00000937 800E[9E70]80            		or	byte [_$P_Flags2],80h	; indicate a signed numeric
  3319                                  					; 0FFh - _$P_Neg
  3320 0000093C 8026[9E70]FD            		and	byte [_$P_Flags2],~2 ; not 2 ; assume positive value
  3321 00000941 8A04                    		mov	al,[si]		; get sign
  3322 00000943 3C2B                    		cmp	al,'+' ;_$P_Plus
  3323 00000945 7409                    		je	short _$P_SVal00
  3324 00000947 3C2D                    		cmp	al,'-'
  3325 00000949 7506                    		jne	short _$P_Sval01 ; else	
  3326 0000094B 800E[9E70]02            		or	byte [_$P_Flags2],2 ;_$P_Neg ; set this is negative value
  3327                                  _$P_SVal00:
  3328 00000950 46                      		inc	si		; skip sign char
  3329                                  _$P_Sval01:
  3330 00000951 E80200                  		call	_$P_Value	; and process value
  3331 00000954 58                      		pop	ax
  3332 00000955 C3                      		retn
  3333                                  
  3334                                  ; ----------------------------------------------------------------------------
  3335                                  
  3336                                  _$P_Value:
  3337 00000956 50                      		push	ax
  3338 00000957 51                      		push	cx
  3339 00000958 52                      		push	dx
  3340 00000959 56                      		push	si
  3341 0000095A 31C9                    		xor	cx,cx		; cx = higher 16 bits
  3342 0000095C 31D2                    		xor	dx,dx		; dx = lower 16 bits
  3343 0000095E 53                      		push	bx		; save control pointer
  3344                                  _$P_Value_Loop:
  3345 0000095F 8A04                    		mov	al,[si]		; get character
  3346 00000961 08C0                    		or	al,al		; end of line?
  3347 00000963 7438                    		jz	short _$P_Value00
  3348 00000965 E8F600                  		call	_$P_0099	; make asc(0..9) to bin(0..9)
  3349 00000968 722F                    		jc	short _$P_Value_Err0 ; error, exit
  3350 0000096A 30E4                    		xor	ah,ah
  3351 0000096C 89C5                    		mov	bp,ax		; save binary number
  3352 0000096E E81C00                  		call	_$P_Value_sub1	; 2*x
  3353 00000971 89D3                    		mov	bx,dx		; save low(2*x)
  3354 00000973 89C8                    		mov	ax,cx		; save high(2*x)
  3355 00000975 E81500                  		call	_$P_Value_sub1  ; 4*x
  3356 00000978 E81200                  		call	_$P_Value_sub1	; 8*x
  3357 0000097B 01DA                    		add	dx,bx		; 10*x
  3358 0000097D 11C1                    		adc	cx,ax		; 32bit ADD
  3359 0000097F E80F00                  		call	_$P_Value_sub2	; Overflow occurred?
  3360 00000982 01EA                    		add	dx,bp		; Add the current one degree decimal
  3361 00000984 83D100                  		adc	cx,0		; if carry, add 1 to high 16bit	
  3362 00000987 E80700                  		call	_$P_Value_sub2	; Overflow occurred?
  3363 0000098A 46                      		inc	si
  3364 0000098B EBD2                    		jmp	short _$P_Value_Loop
  3365                                  _$P_Value_sub1:
  3366 0000098D D1E2                    		shl	dx,1		; to have 2*x
  3367 0000098F D1D1                    		rcl	cx,1		; shift left w/ carry
  3368                                  _$P_Value_sub2:
  3369 00000991 E8B900                  		call	_$P_Check_OVF	; Overflow occurred?
  3370 00000994 7201                    		jc	short _$P_Value_sub2_err ; then error, exit
  3371 00000996 C3                      		retn
  3372                                  _$P_Value_sub2_err:
  3373 00000997 44                      		inc	sp		; skip return address on top of stack
  3374 00000998 44                      		inc	sp
  3375                                  _$P_Value_Err0:
  3376 00000999 5B                      		pop	bx		; retore control pointer
  3377 0000099A E9A000                  		jmp	_$P_Value_Err	; Bridge
  3378                                  _$P_Value00:
  3379 0000099D 5B                      		pop	bx
  3380 0000099E F606[9E70]02            		test	byte [_$P_Flags2],2 ;_$P_Neg ;   here cx,dx = 32bit value
  3381 000009A3 740A                    		jz	short _$P_Value01 ; was it negative?
  3382 000009A5 F7D1                    		not	cx		; +
  3383 000009A7 F7D2                    		not	dx		; |- Make 2's complemeny
  3384 000009A9 83C201                  		add	dx,1		; |
  3385 000009AC 83D100                  		adc	cx,0		; +
  3386                                  _$P_Value01:				; / nval = 0
  3387                                  		;mov	si,es:[bx]._$P_Value_List
  3388                                  		;mov	si,[es:bx+6]	; si points to value list
  3389 000009AF 8B7706                  		mov	si,[bx+6]
  3390                                  		;mov	al,[es:si]	; get nval
  3391 000009B2 8A04                    		mov	al,[si]
  3392 000009B4 3C00                    		cmp	al,0 ;_$P_nval_None ; no value list?
  3393 000009B6 7506                    		jne	short _$P_Value02
  3394                                  		;mov	al,_$P_Number	; Set type
  3395                                  		;mov	ah,_$P_No_Tag	; No ITEM_TAG set
  3396 000009B8 B801FF                  		mov	ax,0FF01h
  3397 000009BB E98700                  		jmp	_$P_Value_Exit
  3398                                  _$P_Value02:
  3399 000009BE 46                      		inc	si
  3400                                  		;mov	al,[es:si]	; al = number of range
  3401 000009BF 8A04                    		mov	al,[si]
  3402 000009C1 3C00                    		cmp	al,0 ;_$P_No_nrng
  3403 000009C3 7453                    		je	short _$P_Value03
  3404 000009C5 46                      		inc	si		; si points to 1st item_tag
  3405                                  _$P_Val02_Loop:
  3406 000009C6 F606[9E70]80            		test	byte [_$P_Flags2],80h ;_$P_Signed
  3407 000009CB 751A                    		jnz	short _$P_Val02_Sign
  3408                                  		;cmp	cx,[es:si+_$P_Val_XH]
  3409                                  		;cmp	cx,[es:si+3]	; comp cx with XH
  3410 000009CD 3B4C03                  		cmp	cx,[si+3]
  3411 000009D0 722F                    		jb	short _$P_Val02_Next
  3412 000009D2 7705                    		ja	short _$P_Val_In
  3413                                  		;cmp	dx,[es:si+_$P_Val_XL]
  3414                                  		;cmp	dx,[es:si+1]	; comp dx with XL
  3415 000009D4 3B5401                  		cmp	dx,[si+1]
  3416 000009D7 7228                    		jb	short _$P_Val02_Next
  3417                                  _$P_Val_In:
  3418                                  		;cmp	cx,[es:si+_$P_Val_YH]
  3419                                  		;cmp	cx,[es:si+7]	; comp cx with YH
  3420 000009D9 3B4C07                  		cmp	cx,[si+7]
  3421 000009DC 7723                    		ja	short _$P_Val02_Next
  3422 000009DE 7232                    		jb	short _$P_Val_Found
  3423                                  		;cmp	dx,[es:si+_$P_Val_YL]	
  3424                                  		;cmp	dx,[es:si+5]	; comp dx with YL
  3425 000009E0 3B5405                  		cmp	dx,[si+5]
  3426 000009E3 771C                    		ja	short _$P_Val02_Next
  3427 000009E5 EB2B                    		jmp	short _$P_Val_Found
  3428                                  _$P_Val02_Sign:
  3429                                  		;cmp	cx,[es:si+_$P_Val_XH]
  3430                                  		;cmp	cx,[es:si+3]	; comp cx with XH
  3431 000009E7 3B4C03                  		cmp	cx,[si+3]
  3432 000009EA 7C15                    		jl	short _$P_Val02_Next
  3433 000009EC 7F05                    		jg	short _$P_SVal_In
  3434                                  		;cmp	dx,[es:si+_$P_Val_XL]
  3435                                  		;cmp	dx,[es:si+1]	; comp dx with XL
  3436 000009EE 3B5401                  		cmp	dx,[si+1]
  3437 000009F1 7C0E                    		jl	short _$P_Val02_Next
  3438                                  _$P_SVal_In:
  3439                                  		;cmp	cx,[es:si+_$P_Val_YH]
  3440                                  		;cmp	cx,[es:si+7]	; comp cx with YH
  3441 000009F3 3B4C07                  		cmp	cx,[si+7]
  3442 000009F6 7F09                    		jg	short _$P_Val02_Next
  3443 000009F8 7C18                    		jl	short _$P_Val_Found
  3444                                  		;cmp	dx,[es:si+_$P_Val_YL]
  3445                                  		;cmp	dx,[es:si+5]	; comp dx with YL
  3446 000009FA 3B5405                  		cmp	dx,[si+5]
  3447 000009FD 7F02                    		jg	short _$P_Val02_Next
  3448 000009FF EB11                    		jmp	short _$P_Val_Found
  3449                                  _$P_Val02_Next:
  3450 00000A01 83C609                  		add	si,9 ;_$P_Len_Range 
  3451 00000A04 FEC8                    		dec	al		; loop nrng times in AL
  3452 00000A06 75BE                    		jnz	short _$P_Val02_Loop
  3453                                  				; / Not found
  3454                                  		;mov	word [_$P_RC],6	;_$P_Out_of_Range
  3455 00000A08 C606[9270]06            		mov	byte [_$P_RC],6
  3456                                  		;mov	al,_$P_Number	;
  3457                                  		;mov	ah,_$P_No_Tag	; No ITEM_TAG set
  3458 00000A0D B801FF                  		mov	ax,0FF01h
  3459 00000A10 EB33                    		jmp	short _$P_Value_Exit
  3460                                  _$P_Val_Found:
  3461 00000A12 B001                    		mov	al,1 ;_$P_Number
  3462                                  		;mov	ah,[es:si]	; found ITEM_TAG set
  3463 00000A14 8A24                    		mov	ah,[si]
  3464 00000A16 EB2D                    		jmp	short _$P_Value_Exit
  3465                                  _$P_Value03:				; / nval = 2
  3466 00000A18 B409                    		mov	ah,9 ;_$P_Len_Range 
  3467 00000A1A F6E4                    		mul	ah		; Skip nrng field
  3468 00000A1C 40                      		inc	ax
  3469 00000A1D 01C6                    		add	si,ax		; si points to nnval
  3470                                  		;mov	al,[es:si]	; get nnval
  3471 00000A1F 8A04                    		mov	al,[si]
  3472 00000A21 46                      		inc	si		; si points to 1st item_tag
  3473                                  _$P_Val03_Loop:
  3474                                  		;cmp	cx,[es:si+_$P_Val_XH]
  3475                                  		;cmp	cx,[es:si+3]	; comp cx with XH
  3476 00000A22 3B4C03                  		cmp	cx,[si+3]
  3477 00000A25 7505                    		jne	short _$P_Val03_Next
  3478                                  		;cmp	dx,[es:si+_$P_Val_XL]
  3479                                  		;cmp	dx,[es:si+1]	; comp dx with XL
  3480 00000A27 3B5401                  		cmp	dx,[si+1]
  3481 00000A2A 74E6                    		je	short _$P_Val_Found
  3482                                  _$P_Val03_Next:
  3483 00000A2C 83C605                  		add	si,5 ;_$P_Len_Value ; points to next value choice
  3484 00000A2F FEC8                    		dec	al		; loop nval times in AL
  3485 00000A31 75EF                    		jnz	short _$P_Val03_Loop ; / Not found
  3486                                  				; / Not found
  3487                                  		;mov	word [_$P_RC],7 ;_$P_Not_in_Val
  3488 00000A33 C606[9270]07            		mov	byte [_$P_RC],7
  3489                                  		;mov	al,_$P_Number	;
  3490                                  		;mov	ah,_$P_No_Tag	; No ITEM_TAG set
  3491 00000A38 B801FF                  		mov	ax,0FF01h
  3492 00000A3B EB08                    		jmp	short _$P_Value_Exit
  3493                                  _$P_Value_Err:				; / nval = 3 or else
  3494                                  		;mov	word [_$P_RC],9 ;_$P_Syntax
  3495 00000A3D C606[9270]09            		mov	byte [_$P_RC],9
  3496                                  		;mov	al,_$P_String	; Set type
  3497                                  		;mov	ah,_$P_No_Tag	; No ITEM_TAG set
  3498 00000A42 B803FF                  		mov	ax,0FF03h
  3499                                  _$P_Value_Exit:
  3500 00000A45 E886FD                  		call	_$P_Fill_Result
  3501 00000A48 5E                      		pop	si
  3502 00000A49 5A                      		pop	dx
  3503 00000A4A 59                      		pop	cx
  3504 00000A4B 58                      		pop	ax
  3505 00000A4C C3                      		retn
  3506                                  
  3507                                  ;***********************************************************************
  3508                                  ;
  3509                                  ; _$P_Check_OVF
  3510                                  ;
  3511                                  ; Function:  Check if overflow is occurred with consideration of
  3512                                  ;	     signed or un-signed numeric value
  3513                                  ;
  3514                                  ; Input:     Flag register
  3515                                  ;
  3516                                  ; Output:    CY = 1  :	Overflow
  3517                                  ;
  3518                                  ; Vars:     _$P_Flags(R)
  3519                                  ;
  3520                                  ;***********************************************************************
  3521                                  
  3522                                  _$P_Check_OVF:
  3523 00000A4D 9C                      		pushf
  3524 00000A4E F606[9E70]02            		test	byte [_$P_Flags2],2 ;_$P_Neg ; is it negative value ?
  3525 00000A53 7502                    		jnz	short _$P_COVF	; if no, check overflow
  3526 00000A55 9D                      		popf			; by the CY bit
  3527 00000A56 C3                      		retn
  3528                                  _$P_COVF:
  3529 00000A57 9D                      		popf			; else,
  3530 00000A58 7002                    		jo	short _$P_COVF00 ; check overflow by the OF
  3531 00000A5A F8                      		clc			; indicate it with CY bit
  3532 00000A5B C3                      		retn			; CY=0 means no overflow
  3533                                  _$P_COVF00:
  3534 00000A5C F9                      		stc			; and CY=1 means overflow
  3535 00000A5D C3                      		retn
  3536                                  
  3537                                  ;***********************************************************************
  3538                                  ;
  3539                                  ; _$P_0099;
  3540                                  ;
  3541                                  ; Function:  Make ASCII 0-9 to Binary 0-9
  3542                                  ;
  3543                                  ; Input:     AL = character code
  3544                                  ;
  3545                                  ; Output:    CY = 1 : AL is not number
  3546                                  ;	     CY = 0 : AL contains binary value
  3547                                  ;
  3548                                  ;***********************************************************************
  3549                                  
  3550                                  _$P_0099:
  3551 00000A5E 3C30                    		cmp	al, '0'
  3552 00000A60 7208                    		jb	short _$P_0099Err	; must be 0 =< al =< 9
  3553 00000A62 3C39                    		cmp	al, '9'
  3554 00000A64 7704                    		ja	short _$P_0099Err	; must be 0 =< al =< 9
  3555                                  
  3556 00000A66 2C30                    		sub	al, '0'			; make char -> bin
  3557 00000A68 F8                      		clc				; indicate no error
  3558 00000A69 C3                      		retn
  3559                                  _$P_0099Err:
  3560 00000A6A F9                      		stc				; indicate error
  3561 00000A6B C3                      		retn
  3562                                  
  3563                                  ; 10/11/2018
  3564                                  
  3565                                  ;***********************************************************************
  3566                                  ;
  3567                                  ; _$P_Simple_String
  3568                                  ;
  3569                                  ; Function:  See value list for the simple string
  3570                                  ;	     and make result buffer.
  3571                                  ;
  3572                                  ; Input:     psdata_seg:SI -> _$P_STRING_BUF
  3573                                  ;	     ES:BX -> CONTROL block
  3574                                  ;
  3575                                  ; Output:    None
  3576                                  ;
  3577                                  ; Use:	_$P_Fill_Result, _$P_String_Comp
  3578                                  ;
  3579                                  ; Vars: _$P_RC(W)
  3580                                  ;
  3581                                  ;***********************************************************************
  3582                                  
  3583                                  _$P_Simple_String:
  3584 00000A6C 50                      		push	ax
  3585 00000A6D 53                      		push	bx
  3586 00000A6E 52                      		push	dx
  3587 00000A6F 57                      		push	di
  3588                                  		;mov	di,es:[bx]._$P_Value_List
  3589                                  		;mov	di,[es:bx+6]	; di points to value list
  3590 00000A70 8B7F06                  		mov	di,[bx+6]
  3591                                  		;mov	al,[es:di]	; get nval
  3592 00000A73 8A05                    		mov	al,[di]
  3593 00000A75 08C0                    		or	al,al		; no value list?
  3594 00000A77 7504                    		jnz	short _$P_Sim01	; then
  3595 00000A79 B4FF                    		mov	ah,0FFh ;_$P_No_Tag ; No ITEM_TAG set
  3596 00000A7B EB07                    		jmp	short _$P_Sim_Exit ; and set result buffer
  3597                                  _$P_Sim01:
  3598                                  		;mov	word [_$P_RC],9	;_$P_Syntax
  3599 00000A7D C606[9270]09            		mov	byte [_$P_RC],9
  3600 00000A82 B4FF                    		mov	ah,0FFh		; No ITEM_TAG set
  3601                                  _$P_Sim_Exit:
  3602 00000A84 B003                    		mov	al,3 ;_$P_String	; Set type
  3603 00000A86 E845FD                  		call	_$P_Fill_Result
  3604 00000A89 5F                      		pop	di
  3605 00000A8A 5A                      		pop	dx
  3606 00000A8B 5B                      		pop	bx
  3607 00000A8C 58                      		pop	ax
  3608 00000A8D C3                      		retn
  3609                                  
  3610                                  ;***********************************************************************
  3611                                  ;
  3612                                  ; _$P_String_Comp:
  3613                                  ;
  3614                                  ; Function:  Compare two string
  3615                                  ;
  3616                                  ; Input:     psdata_seg:SI -> 1st string
  3617                                  ;	     ES:BP -> 2nd string  (Must be upper case)
  3618                                  ;	     ES:BX -> CONTROL block
  3619                                  ;
  3620                                  ; Output:    CY = 1 if not match
  3621                                  ;
  3622                                  ; Use:	_$P_Chk_DBCS, _$P_Do_CAPS_Char
  3623                                  ;
  3624                                  ; Vars: _$P_KEYor_SW_Ptr(W), _$P_Flags(R). _$P_KEYorSW_Ptr
  3625                                  ;
  3626                                  ;***********************************************************************
  3627                                  
  3628                                  _$P_String_Comp:
  3629 00000A8E 50                      		push	ax
  3630 00000A8F 55                      		push	bp
  3631 00000A90 52                      		push	dx
  3632 00000A91 56                      		push	si
  3633 00000A92 B202                    		mov	dl,2 ;_$P_DOSTBL_Char ; use character case map table
  3634                                  _$P_SCOM_Loop:
  3635 00000A94 8A04                    		mov	al,[si]		; get command character
  3636 00000A96 E83AFC                  		call	_$P_Chk_DBCS	; DBCS?
  3637 00000A99 7237                    		jc	short _$P_SCOM00 ; yes
  3638 00000A9B E85FFE                  		call	_$P_Do_CAPS_Char ; else, upper case map before comparison	
  3639 00000A9E F606[9E70]08            		test	byte [_$P_Flags2],8 ;_$P_Key_Cmp ; keyword search ?
  3640 00000AA3 740C                    		jz	short _$P_SCOM04
  3641 00000AA5 3C3D                    		cmp	al,'=' ;_$P_Keyword ; "=" is delimiter
  3642 00000AA7 751C                    		jne	short _$P_SCOM03 ;IF "=" on command line 
  3643                                  				 ; AND (bp+1=> char after the "=" in synonym list)
  3644                                  		;cmp	byte [es:bp+1],0 ;_$P_NULL ; at end of keyword string 
  3645 00000AA9 807E0100                		cmp	byte [bp+1],0		  ; in the control block THEN
  3646 00000AAD 7565                    		jne	short _$P_SCOM_Differ
  3647 00000AAF EB11                    		jmp	short _$P_SCOM05 ; keyword found in synonym list	
  3648                                  _$P_SCOM04:
  3649 00000AB1 F606[9E70]10            		test	byte [_$P_Flags2],10h ;_$P_SW_Cmp ; switch search ?
  3650 00000AB6 740D                    		jz	short _$P_SCOM03
  3651 00000AB8 3C3A                    		cmp	al,':' ;_$P_Colon ; ":" is delimiter, at end of switch on command line
  3652 00000ABA 7509                    		jne	short _$P_SCOM03 ; continue compares
  3653                                  		;cmp	byte [es:bp],0 ;_$P_NULL ; IF at end of switch on command AND
  3654 00000ABC 807E0000                		cmp	byte [bp],0	; at end of switch string in the control block THEN
  3655 00000AC0 7552                    		jne	short _$P_SCOM_Differ
  3656                                  _$P_SCOM05:				; found a match
  3657 00000AC2 46                      		inc	si		; si points to just after "=" or ":"
  3658 00000AC3 EB52                    		jmp	short _$P_SCOM_Same ; exit
  3659                                  _$P_SCOM03:
  3660                                  		;cmp	al,[es:bp]	; compare operand w/ a synonym
  3661 00000AC5 3A4600                  		cmp	al,[bp]	
  3662 00000AC8 751A                    		jne	short _$P_SCOM_Differ0 ; if different, check ignore colon option
  3663 00000ACA 08C0                    		or	al,al		; end of line
  3664 00000ACC 7449                    		jz	short _$P_SCOM_Same ; if so, exit
  3665 00000ACE 46                      		inc	si		; update operand pointer
  3666 00000ACF 45                      		inc	bp		; and synonym pointer
  3667 00000AD0 EB10                    		jmp	short _$P_SCOM01 ; loop until NULL or "=" or ":" found in case
  3668                                  _$P_SCOM00:
  3669                                  		;cmp	al,[es:bp]	; Here al is DBCS leading byte
  3670 00000AD2 3A4600                  		cmp	al,[bp]		; compare leading byte
  3671 00000AD5 753D                    		jne	short _$P_SCOM_Differ ; if not match, say different
  3672 00000AD7 46                      		inc	si		; else, load next byte
  3673 00000AD8 8A04                    		mov	al,[si]		; and
  3674 00000ADA 45                      		inc	bp
  3675                                  		;cmp	al,[es:bp+0]	; compare 2nd byte
  3676 00000ADB 3A4600                  		cmp	al,[bp]
  3677 00000ADE 7534                    		jnz	short _$P_SCOM_Differ ; if not match, say different, too
  3678 00000AE0 46                      		inc	si		; else update operand pointer
  3679 00000AE1 45                      		inc	bp		; and synonym pointer
  3680                                  _$P_SCOM01:
  3681 00000AE2 EBB0                    		jmp	short _$P_SCOM_Loop ; loop until NULL or "=" or "/" found in case
  3682                                  _$P_SCOM_Differ0:
  3683 00000AE4 F606[9E70]40            		test	byte [_$P_Flags2],40h ;_$P_SW
  3684 00000AE9 740D                    		jz	short _$P_not_applicable
  3685                                  		;test	es:[bx]._$P_Function_Flag,_$P_colon_is_not_necessary
  3686                                  		;test	word [es:bx+2],20h
  3687 00000AEB F747022000              		test	word [bx+2],20h
  3688 00000AF0 7406                    		jz	short _$P_not_applicable
  3689                                  		;cmp	byte [es:bp],0 ;_$P_NULL
  3690 00000AF2 807E0000                		cmp	byte [bp],0
  3691 00000AF6 741F                    		je	short _$P_SCOM_Same
  3692                                  _$P_not_applicable:
  3693                                  		;test	es:[bx]._$P_Match_Flag,_$P_Ig_Colon
  3694                                  		;test	word [es:bx],10h ; ignore colon option specified?	
  3695 00000AF8 F7071000                		test	word [bx],10h
  3696 00000AFC 7416                    		jz	short _$P_SCOM_Differ ; if no, say different.
  3697 00000AFE 3C3A                    		cmp	al,':' ;_$P_Colon ; End up with ":" and	
  3698 00000B00 7508                    		jne	short _$P_SCOM02 ; subseqently	
  3699                                  		;cmp	byte [es:bp+0],0 ; NULL?
  3700 00000B02 807E0000                		cmp	byte [bp],0
  3701 00000B06 750C                    		jne	short _$P_SCOM_Differ ; if no, say different
  3702 00000B08 EB0D                    		jmp	short _$P_SCOM_Same ; else, say same
  3703                                  _$P_SCOM02:
  3704 00000B0A 3C00                    		cmp	al,0 ;_$P_NULL	;end up NULL and :
  3705 00000B0C 7506                    		jne	short _$P_SCOM_Differ
  3706                                  		;cmp	byte [es:bp],':' ;_$P_Colon 
  3707 00000B0E 807E003A                		cmp	byte [bp],':'	; if no, say different
  3708 00000B12 7403                    		je	short _$P_SCOM_Same ; else, say same
  3709                                  _$P_SCOM_Differ:
  3710 00000B14 F9                      		stc			; indicate not found
  3711 00000B15 EB05                    		jmp	short _$P_SCOM_Exit
  3712                                  _$P_SCOM_Same:
  3713 00000B17 8936[A170]              		mov	[_$P_KEYorSW_Ptr],si ; for later use by keyword or switch
  3714 00000B1B F8                      		clc			; indicate found
  3715                                  _$P_SCOM_Exit:
  3716 00000B1C 5E                      		pop	si
  3717 00000B1D 5A                      		pop	dx
  3718 00000B1E 5D                      		pop	bp
  3719 00000B1F 58                      		pop	ax
  3720 00000B20 C3                      		retn
  3721                                  
  3722                                  ;***********************************************************************
  3723                                  ;
  3724                                  ; _$P_Date_Format
  3725                                  ;
  3726                                  ; Function:  Convert a date string to DOS date format for int 21h
  3727                                  ;	     with format validation.
  3728                                  ;
  3729                                  ; Input:     psdata_seg:SI -> _$P_STRING_BUF
  3730                                  ;	     ES:BX -> CONTROL block
  3731                                  ;
  3732                                  ; Output:    None
  3733                                  ;
  3734                                  ; Use:	_$P_Fill_Result, _$P_Set_CDI, _$P_Get_DecNum
  3735                                  ;
  3736                                  ; Vars: _$P_RC(W), _$P_1st_Val(RW), _$P_2nd_Val(RW), _$P_3rd_Val(RW)
  3737                                  ;
  3738                                  ;***********************************************************************
  3739                                  
  3740                                  _$P_Date_Format:
  3741 00000B21 50                      		push	ax
  3742 00000B22 51                      		push	cx
  3743 00000B23 52                      		push	dx
  3744 00000B24 56                      		push	si
  3745 00000B25 53                      		push	bx
  3746 00000B26 56                      		push	si
  3747 00000B27 E89200                  		call	_$P_Set_CDI ; set country dependent information before process
  3748 00000B2A 5E                      		pop	si
  3749 00000B2B 31C0                    		xor	ax, ax
  3750 00000B2D A3[4571]                		mov	[_$P_1st_Val],ax ; set initial value	
  3751 00000B30 A3[4771]                		mov	[_$P_2nd_Val],ax
  3752 00000B33 A3[4971]                		mov	[_$P_3rd_Val],ax
  3753 00000B36 E89900                  		call	_$P_Get_DecNum	; get 1st number
  3754                                  		;jc	short _$P_DateF_Err0
  3755 00000B39 7270                    		jc	short _$P_DateF_Error
  3756 00000B3B A3[4571]                		mov	[_$P_1st_Val],ax
  3757 00000B3E 08DB                    		or	bl,bl		; end of line?
  3758 00000B40 7418                    		jz	short _$P_DateF_YMD
  3759 00000B42 E88D00                  		call	_$P_Get_DecNum	; get 2nd number
  3760 00000B45 7264                    		jc	short _$P_DateF_Error
  3761 00000B47 A3[4771]                		mov	[_$P_2nd_Val],ax
  3762 00000B4A 08DB                    		or	bl,bl		; end of line ?
  3763 00000B4C 740C                    		jz	short _$P_DateF_YMD
  3764 00000B4E E88100                  		call	_$P_Get_DecNum	; get 3rd number	
  3765                                  _$P_DateF_Err0:				; Bridge	
  3766 00000B51 7258                    		jc	short _$P_DateF_Error
  3767 00000B53 A3[4971]                		mov	[_$P_3rd_Val],ax
  3768 00000B56 08DB                    		or	bl,bl
  3769 00000B58 7551                    		jnz	short _$P_DateF_Error
  3770                                  _$P_DateF_YMD:
  3771                                  		;mov	bx,[_$P_Country_Info+_$P_CDI_DateF]
  3772 00000B5A 8B1E[2871]              		mov	bx,[_$P_Country_Info] ; get date format
  3773 00000B5E 83FB02                  		cmp	bx,2	; _$P_Date_YMD
  3774 00000B61 741F                    		je	short _$P_DateF00
  3775 00000B63 A1[4571]                		mov	ax,[_$P_1st_Val]
  3776 00000B66 08E4                    		or	ah,ah
  3777 00000B68 7541                    		jnz	short _$P_DateF_Error
  3778 00000B6A 88C1                    		mov	cl,al		; set month
  3779 00000B6C A1[4771]                		mov	ax,[_$P_2nd_Val]
  3780 00000B6F 08E4                    		or	ah,ah		; if overflow, error.
  3781 00000B71 7538                    		jnz	short _$P_DateF_Error
  3782 00000B73 88C5                    		mov	ch,al		; set date
  3783 00000B75 8B16[4971]              		mov	dx,[_$P_3rd_Val] ; set year
  3784 00000B79 83FB01                  		cmp	bx,1 ;_$P_Date_DMY ; from here format = MDY
  3785 00000B7C 7502                    		jne	short _$P_DateF01 ; if it is DMY
  3786 00000B7E 86E9                    		xchg	ch,cl		;  then swap M <-> D
  3787                                  _$P_DateF01:
  3788 00000B80 EB16                    		jmp	short _$P_DateF02
  3789                                  _$P_DateF00:				; / here format = YMD
  3790 00000B82 8B16[4571]              		mov	dx,[_$P_1st_Val] ; set year	
  3791 00000B86 A1[4771]                		mov	ax,[_$P_2nd_Val]
  3792 00000B89 08E4                    		or	ah,ah		; if overflow, error
  3793 00000B8B 751E                    		jnz	short _$P_DateF_Error
  3794 00000B8D 88C1                    		mov	cl,al		; set month
  3795 00000B8F A1[4971]                		mov	ax,[_$P_3rd_Val]
  3796 00000B92 08E4                    		or	ah,ah		; if overflow, error
  3797 00000B94 7515                    		jnz	short _$P_DateF_Error
  3798 00000B96 88C5                    		mov	ch,al		; set date
  3799                                  _$P_DateF02:
  3800 00000B98 83FA64                  		cmp	dx,100		; year is less that 100?
  3801 00000B9B 7304                    		jnb	short _$P_DateF03
  3802 00000B9D 81C26C07                		add	dx,1900		; set year 19xx
  3803                                  _$P_DateF03:
  3804 00000BA1 5B                      		pop	bx
  3805 00000BA2 5E                      		pop	si
  3806                                  		;mov	ah,_$P_No_Tag
  3807                                  		;mov	al,_$P_Date_F
  3808 00000BA3 B807FF                  		mov	ax,0FF07h	; set results buffer to date
  3809 00000BA6 E825FC                  		call	_$P_Fill_Result
  3810 00000BA9 EB0D                    		jmp	short _$P_Date_Format_Exit
  3811                                  _$P_DateF_Error:
  3812 00000BAB 5B                      		pop	bx		; recover CONTROL block
  3813 00000BAC 5E                      		pop	si		; recover string pointer
  3814                                  		;mov	ah,_$P_No_Tag	
  3815                                  		;mov	al,_$P_Date_F
  3816 00000BAD B803FF                  		mov	ax,0FF03h	; set results buffer to string
  3817 00000BB0 E81BFC                  		call	_$P_Fill_Result
  3818                                  		;mov	word [_$P_RC],9 ;_$P_Syntax
  3819 00000BB3 C606[9270]09            		mov	byte [_$P_RC],9 ; indicate syntax error
  3820                                  _$P_Date_Format_Exit:
  3821 00000BB8 5A                      		pop	dx
  3822 00000BB9 59                      		pop	cx
  3823 00000BBA 58                      		pop	ax
  3824 00000BBB C3                      		retn
  3825                                  
  3826                                  ;***********************************************************************
  3827                                  ;
  3828                                  ; _$P_Set_CDI:
  3829                                  ;
  3830                                  ; Function: Read CDI from DOS if it has not been read yet
  3831                                  ;
  3832                                  ; Input:    None
  3833                                  ;
  3834                                  ; Output:   psdata_seg:SI -> CDI
  3835                                  ;
  3836                                  ; Use:	INT 21h w/ AH = 38h
  3837                                  ;
  3838                                  ;***********************************************************************
  3839                                  
  3840                                  _$P_Set_CDI:
  3841                                  		;lea	si,[_$P_Country_Info]
  3842 00000BBC BE[2871]                		mov	si,_$P_Country_Info
  3843                                  		;cmp	word [cs:si+_$P_CDI_DateF],_$P_NeedToBeRead
  3844 00000BBF 833CFF                  		cmp	word [si],0FFFFh ; -1 ; already read?
  3845 00000BC2 750D                    		jne	short _$P_Set_CDI_Exit ; then do nothing
  3846                                  					;else read CDI thru DOS
  3847 00000BC4 1E                      		push	ds
  3848 00000BC5 52                      		push	dx
  3849 00000BC6 50                      		push	ax
  3850                                  		;push	cs
  3851                                  		;pop	ds
  3852 00000BC7 B80038                  		mov	ax,3800h ; _$P_DOS_Get_CDI ; get country information
  3853 00000BCA 89F2                    		mov	dx,si ; set offset of CDI in local data area
  3854 00000BCC CD21                    		int	21h	; GET COUNTRY-DEPENDENT INFORMATION
  3855                                  				; get current-country info
  3856                                  				; DS:DX	-> buffer for returned info
  3857 00000BCE 58                      		pop	ax
  3858 00000BCF 5A                      		pop	dx
  3859 00000BD0 1F                      		pop	ds
  3860                                  _$P_Set_CDI_Exit:
  3861 00000BD1 C3                      		retn
  3862                                  
  3863                                  ;***********************************************************************
  3864                                  ;
  3865                                  ; _$P_Get_DecNum:
  3866                                  ;
  3867                                  ; Function:  Read a chracter code from psdata_seg:SI until specified delimiter
  3868                                  ;	     or NULL encountered. And make a decimal number.
  3869                                  ;
  3870                                  ; Input:     psdata_seg:SI -> _$P_STRING_BUF
  3871                                  ;
  3872                                  ; Output:    BL = delimiter code or NULL
  3873                                  ;	     AX = Decimal number
  3874                                  ;	     SI advanced to the next number
  3875                                  ;	     CY = 1 : Syntax error, AL = Latest examined number
  3876                                  ;
  3877                                  ; Use:	_$P_0099
  3878                                  ;
  3879                                  ;***********************************************************************
  3880                                  
  3881                                  _$P_Get_DecNum:
  3882 00000BD2 51                      		push	cx
  3883 00000BD3 52                      		push	dx
  3884 00000BD4 31C9                    		xor	cx,cx		; cx will have final value
  3885                                  _$P_GetNum_Loop:
  3886 00000BD6 8A04                    		mov	al,[si]		; load character
  3887 00000BD8 08C0                    		or	al,al		; end of line?
  3888 00000BDA 743B                    		jz	short _$P_GetNum00 ; if yes, exit
  3889 00000BDC 803E[2771]00            		cmp	byte [_$P_Got_Time],0   ; is this numeric in a time field?
  3890 00000BE1 740F                    		je	short _$P_Do_Date_Delims ; no, go check out Date delimiters
  3891                                  
  3892                                  ; Determine which delimiter(s) to check for. Colon & period or period only
  3893                                   
  3894 00000BE3 80FB01                  		cmp	bl,1 ;_$P_colon_period	; Time
  3895 00000BE6 7504                    		jne	short _$P_Do_Time_Delim1 ; only check for period
  3896 00000BE8 3C3A                    		cmp	al,':' ;_$P_Colon	; Is this a valid delimiter?
  3897 00000BEA 7430                    		je	short _$P_GetNum01	; yes, exit
  3898                                  _$P_Do_Time_Delim1:
  3899 00000BEC 3C2E                    		cmp	al,'.' ;_$P_Period	; Is this a valid delimiter?
  3900 00000BEE 742C                    		je	short _$P_GetNum01	; yes, exit
  3901 00000BF0 EB0C                    		jmp	short _$P_Neither_Delims
  3902                                  _$P_Do_Date_Delims:
  3903                                  ;Regardless of the date delimiter character specified in the country
  3904                                  ;dependent information, check for the presence of any one of these
  3905                                  ;three field delimiters: "-", "/", or ".".
  3906 00000BF2 3C2D                    		cmp	al,'-' ;_$P_Minus	; is this a date delimiter character?
  3907 00000BF4 7426                    		je	short _$P_GetNum01	; if yes, exit
  3908 00000BF6 3C2F                    		cmp	al,'/' ;_$P_Slash	; is this a date delimiter character?	
  3909 00000BF8 7422                    		je	short _$P_GetNum01	; if yes, exit
  3910 00000BFA 3C2E                    		cmp	al,'.' ;_$P_Period	; is this a date delimiter character?
  3911 00000BFC 741E                    		je	short _$P_GetNum01	; if yes, exit
  3912                                  _$P_Neither_Delims:
  3913 00000BFE E85DFE                  		call	_$P_0099		; convert it to binary
  3914 00000C01 721D                    		jc	short _$P_GetNum_Exit	; if error exit
  3915 00000C03 B400                    		mov	ah,0
  3916 00000C05 91                      		xchg	ax,cx
  3917 00000C06 BA0A00                  		mov	dx,10
  3918 00000C09 F7E2                    		mul	dx			; ax = ax*10
  3919 00000C0B 09D2                    		or	dx,dx			; overflow
  3920 00000C0D 7510                    		jnz	short _$P_GetNum02	; then exit
  3921 00000C0F 01C8                    		add	ax,cx
  3922 00000C11 720D                    		jc	short _$P_GetNum_Exit
  3923 00000C13 91                      		xchg	ax,cx
  3924 00000C14 46                      		inc	si
  3925 00000C15 EBBF                    		jmp	short _$P_GetNum_Loop
  3926                                  _$P_GetNum00:
  3927 00000C17 88C3                    		mov	bl,al		; set bl to NULL
  3928                                  _$P_GetNum03:
  3929 00000C19 F8                      		clc			; indicate no error
  3930 00000C1A EB04                    		jmp	short _$P_GetNum_Exit
  3931                                  _$P_GetNum01:
  3932 00000C1C 46                      		inc	si
  3933 00000C1D EBFA                    		jmp	short _$P_GetNum03
  3934                                  _$P_GetNum02:
  3935 00000C1F F9                      		stc			; indicate error
  3936                                  _$P_GetNum_Exit:
  3937 00000C20 91                      		xchg	ax,cx		; return value
  3938 00000C21 5A                      		pop	dx
  3939 00000C22 59                      		pop	cx
  3940 00000C23 C3                      		retn
  3941                                  
  3942                                  ; ----------------------------------------------------------------------------
  3943                                  ; messages.c (FDISK, MSDOS 6.0, 1991)	
  3944                                  ; ----------------------------------------------------------------------------
  3945                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 13/11/2018)
  3946                                  
  3947                                  ;/*  */
  3948                                  ;/******************************************************************************/
  3949                                  ;/*Routine name:  PRELOAD_MESSAGES                                             */
  3950                                  ;/******************************************************************************/
  3951                                  ;/*                                                                            */
  3952                                  ;/*Description:   Preloads messages for Display_Msg and returns error code     */
  3953                                  ;/*               if incorrect DOS version, insuffient memory, or unable to    */
  3954                                  ;/*               to find messages.                                            */
  3955                                  ;/*                                                                            */
  3956                                  ;/*Called Procedures:    sysloadmsg                                            */
  3957                                  ;/*                      display_msg                                           */
  3958                                  ;/*                                                                            */
  3959                                  ;/*Change History: Created        5/30/87         DRM                          */
  3960                                  ;/*                                                                            */
  3961                                  ;/*Input: None                                                                 */
  3962                                  ;/*                                                                            */
  3963                                  ;/*Output: None                                                                */
  3964                                  ;/*                                                                            */
  3965                                  ;/******************************************************************************/
  3966                                  
  3967                                  ;char preload_messages()
  3968                                  
  3969                                  ;BEGIN
  3970                                  ;
  3971                                  ;char message_flag;
  3972                                  ;
  3973                                  ;     /* load all messages for FDISK */
  3974                                  ;     message_flag = c(TRUE);
  3975                                  ;     sysloadmsg(&regs,&regs);  		     /* load the messages */
  3976                                  ;
  3977                                  ;     if ((regs.x.cflag & CARRY_FLAG) == CARRY_FLAG) /* If msg load problem */
  3978                                  ;       BEGIN
  3979                                  ;        sysdispmsg(&regs,&regs); 		     /* write the error message */
  3980                                  ;        message_flag = FALSE;
  3981                                  ;       END
  3982                                  ;     return(message_flag);
  3983                                  ;
  3984                                  ;END
  3985                                  
  3986                                  preload_messages:
  3987                                  
  3988                                  	;%define message_flag bp-2
  3989                                  
  3990                                  		;push	bp
  3991                                  		;mov	bp,sp
  3992                                  		;sub	sp,2
  3993                                  		;;mov	[bp-2],1
  3994                                  		;mov	[message_flag],1
  3995                                  		;mov	ax,regs ;regs_x_ax
  3996                                  		;push	ax
  3997                                  		;push	ax
  3998                                  		;call	sysloadmsg
  3999                                  		;pop	bx
  4000                                  		;pop	bx
  4001                                  
  4002 00000C24 E80800                  		call	SYSLOADMSG ; 14/11/2018
  4003                                  
  4004                                  		;mov	al,[regs_x_cflag]
  4005                                  		;and	al,1
  4006                                  		;cmp	al,1
  4007                                  		;jne	short preloadmsg_ret
  4008                                  		; 14/11/2018
  4009 00000C27 7304                    		jnc	short preloadmsg_1
  4010                                  
  4011                                  		;mov	ax,regs ;regs_x_ax
  4012                                  		;push	ax
  4013                                  		;push	ax
  4014                                  		;call	sysdispmsg
  4015                                  		;pop	bx
  4016                                  		;pop	bx
  4017                                  		;;mov	[bp-2],0
  4018                                  		;mov	[message_flag],0
  4019                                  
  4020                                  		; 14/11/2018
  4021 00000C29 E8E101                  		call	SYSDISPMSG 
  4022                                  
  4023                                  		;sub	ax,ax
  4024                                  		;jmp	short preloadmsg_2
  4025 00000C2C F9                      		stc	
  4026                                  preloadmsg_1:
  4027 00000C2D C3                      		retn
  4028                                  ;preloadmsg_1:
  4029                                  		; 14/11/2018
  4030                                  		;;mov	ax,1
  4031                                  		;xor	ax,ax
  4032                                  		;inc	al
  4033 00000C2E C3                      		retn
  4034                                  ;preloadmsg_2:
  4035                                  		;;;mov	al,[bp-2]
  4036                                  		;;mov	al,[message_flag]
  4037                                  		;;mov	sp,bp
  4038                                  		;;pop	bp
  4039                                  		;;retn
  4040                                  		
  4041                                  		; 13/11/2018
  4042                                  		;cmp	al,1	
  4043                                  		;retn
  4044                                  
  4045                                  ;sysloadmsg:
  4046                                  ;		call	_sysloadmsg
  4047                                  ;		retn
  4048                                  
  4049                                  ; _msgret.asm (MSDOS 6.0, 1991)
  4050                                  ; ----------------------------------------------------------------------------
  4051                                  ; 14/11/2018
  4052                                  
  4053                                  ;_sysloadmsg:
  4054                                  ;
  4055                                  ;	%define inregs  bp+8
  4056                                  ;	%define outregs bp+10
  4057                                  ;
  4058                                  ;		push	bp
  4059                                  ;		mov	bp,sp
  4060                                  ;		push	di
  4061                                  ;		push	si
  4062                                  ;		mov	di,[inregs] 
  4063                                  ;		mov	ax,[di+10] ; regs.x.di
  4064                                  ;		push	ax
  4065                                  ;		mov	ax,[di]	   ; regs.x.ax	
  4066                                  ;		mov	bx,[di+2]  ; regs.x.bx	
  4067                                  ;		mov	cx,[di+4]  ; regs.x.cx	
  4068                                  ;		mov	dx,[di+6]  ; regs.x.dx	
  4069                                  ;		mov	si,[di+8]  ; regs.x.si	
  4070                                  ;		pop	di
  4071                                  ;		push	bp
  4072                                  ;		call	SYSLOADMSG
  4073                                  ;		pop	bp
  4074                                  ;		push	di
  4075                                  ;		mov	di,[outregs]
  4076                                  ;		mov	[di],ax	   ; regs.x.ax	
  4077                                  ;		mov	[di+2],bx  ; regs.x.bx
  4078                                  ;		mov	[di+4],cx  ; regs.x.cx		
  4079                                  ;		mov	[di+6],dx  ; regs.x.dx	
  4080                                  ;		mov	[di+8],si  ; regs.x.si	
  4081                                  ;		lahf
  4082                                  ;		mov	al,ah
  4083                                  ;		mov	[di+12],ax ; regs.x_cflag
  4084                                  ;		pop	ax
  4085                                  ;		mov	[di+10],ax ; regs.x.di	
  4086                                  ;		pop	si
  4087                                  ;		pop	di
  4088                                  ;		mov	sp,bp
  4089                                  ;		pop	bp
  4090                                  ;		retf
  4091                                  
  4092                                  SYSLOADMSG:
  4093                                  
  4094                                  		;push	ax
  4095                                  		;push	bx
  4096                                  		;push	dx
  4097                                  		;push	es
  4098                                  		;push	di
  4099 00000C2F 31C9                    		xor	cx,cx
  4100 00000C31 8EC1                    		mov	es,cx
  4101 00000C33 31FF                    		xor	di,di
  4102 00000C35 B82E12                  		mov	ax,122Eh
  4103 00000C38 B200                    		mov	dl,0
  4104 00000C3A CD2F                    		int	2Fh	; Multiplex - DOS 3+ internal -	GET OR SET ERROR TABLE ADDRESSES
  4105                                  				; DL = subfunction - get standard DOS error table (errors 00h-12h,50h-5Bh)
  4106                                  				; Return: ES:DI	-> error table
  4107 00000C3C 8C06[EE5C]              		mov	[$M_EXT_COMMAND+2],es
  4108 00000C40 893E[EC5C]              		mov	[$M_EXT_COMMAND],di
  4109 00000C44 B82E12                  		mov	ax,122Eh
  4110 00000C47 B202                    		mov	dl,2
  4111 00000C49 CD2F                    		int	2Fh	; Multiplex - DOS 3+ internal -	GET OR SET ERROR TABLE ADDRESSES
  4112                                  				; DL = subfunction - get parameter error table (errors 00h-0Ah)
  4113                                  				; ES:DI	-> error table
  4114 00000C4B 8C06[F65C]              		mov	[$M_PARSE_COMMAND+2],es
  4115 00000C4F 893E[F45C]              		mov	[$M_PARSE_COMMAND],di
  4116 00000C53 B82E12                  		mov	ax,122Eh
  4117 00000C56 B204                    		mov	dl,4
  4118 00000C58 CD2F                    		int	2Fh	; Multiplex - DOS 3+ internal -	GET OR SET ERROR TABLE ADDRESSES
  4119                                  				; DL = subfunction - get critical/SHARE	error table (errors 13h-2Bh)
  4120                                  				; ES:DI	-> error table
  4121 00000C5A 8C06[065D]              		mov	[$M_CRIT_COMMAND+2],es
  4122 00000C5E 893E[045D]              		mov	[$M_CRIT_COMMAND],di
  4123 00000C62 B82E12                  		mov	ax,122Eh
  4124 00000C65 B206                    		mov	dl,6
  4125 00000C67 CD2F                    		int	2Fh	; Multiplex - DOS 3+ internal -	GET OR SET ERROR TABLE ADDRESSES
  4126                                  				; DL = subfunction - get ??? error table
  4127                                  				; ES:DI	-> error table
  4128 00000C69 8C06[EA5C]              		mov	[$M_EXT_FILE+2],es
  4129 00000C6D 893E[E85C]              		mov	[$M_EXT_FILE],di
  4130                                  		;call	_$M_CLS_1
  4131 00000C71 0E                      		push	cs ; *
  4132 00000C72 07                      		pop	es ; *
  4133 00000C73 BF[365F]                		mov	di,CLASS_1_msg_tbl ; 14/11/2018 ; *
  4134 00000C76 8C06[E65C]              		mov	[$M_EXT_ERR_ADDRS+2],es
  4135 00000C7A 893E[E45C]              		mov	[$M_EXT_ERR_ADDRS],di
  4136 00000C7E 8C06[025D]              		mov	[$M_CRIT_ADDRS+2],es
  4137 00000C82 893E[005D]              		mov	[$M_CRIT_ADDRS],di
  4138                                  		;call	_$M_CLS_2
  4139 00000C86 BF[505F]                		mov	di,CLASS_2_msg_tbl ; 14/11/2018
  4140 00000C89 8C06[FA5C]              		mov	[$M_PARSE_ADDRS+2],es
  4141 00000C8D 893E[F85C]              		mov	[$M_PARSE_ADDRS],di
  4142 00000C91 B82E12                  		mov	ax,122Eh
  4143 00000C94 B208                    		mov	dl,8
  4144 00000C96 CD2F                    		int	2Fh	; Multiplex - DOS 3+ internal -	GET OR SET ERROR TABLE ADDRESSES
  4145                                  				; DL = subfunction - get ??? error table
  4146                                  				; Return: ES:DI	-> error table
  4147 00000C98 8C06[0E5D]              		mov	[$M_DISK_PROC_ADDR+2],es
  4148 00000C9C 893E[0C5D]              		mov	[$M_DISK_PROC_ADDR],di
  4149                                  		;mov	word [$M_CRLF],0A0Dh
  4150                                  		;mov	byte [$M_BUF_TERM],'$'
  4151                                  		;mov	word [$M_MSG_NUM],0
  4152                                  		;mov	[$M_DIVISOR],10
  4153                                  		;call	_$M_CLS_A
  4154 00000CA0 1E                      		push	ds ; *
  4155 00000CA1 07                      		pop	es ; *
  4156 00000CA2 BF[6E5D]                		mov	di,CLASS_A_msg_tbl ; 14/11/2018 ; *
  4157 00000CA5 8C06[125D]              		mov	[$M_CLASS_A_ADDRS+2],es
  4158 00000CA9 893E[105D]              		mov	[$M_CLASS_A_ADDRS],di
  4159                                  		;call	_$M_CLS_B
  4160 00000CAD BF[7E5E]                		mov	di,CLASS_B_msg_tbl ; 14/11/2018
  4161 00000CB0 8C06[165D]              		mov	[$M_CLASS_B_ADDRS+2],es
  4162 00000CB4 893E[145D]              		mov	[$M_CLASS_B_ADDRS],di
  4163                                  
  4164 00000CB8 E82100                  		call	_$M_GET_DBCS_VEC
  4165 00000CBB E83100                  		call	_$M_CHECKSTDIN
  4166 00000CBE E84300                  		call	_$M_CHECKSTDOUT
  4167                                  
  4168                                  		;push	cx
  4169 00000CC1 E80100                  		call	_$M_VERSION_CHECK
  4170                                  		;jc	short $MIF20
  4171                                  		;pop	cx
  4172                                  		;pop	di
  4173                                  		;pop	es
  4174                                  		;pop	dx
  4175                                  		;pop	bx
  4176                                  		;pop	ax
  4177                                  		;;retf
  4178                                  
  4179 00000CC4 C3                      		retn	 
  4180                                  ;$MIF20:
  4181                                  		;add	sp,12
  4182                                  		;stc
  4183                                  		;;retf
  4184                                  		;retn
  4185                                  
  4186                                  ; msgserver.asm (MSDOS 6.0, 1991)
  4187                                  ; ----------------------------------------------------------------------------
  4188                                  ; 14/11/2018
  4189                                  
  4190                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  4191                                  ;;
  4192                                  ;;  Proc Name:	$M_VERSION_CHECK
  4193                                  ;;
  4194                                  ;;  Function:	Determine if DOS version is within allowable limits
  4195                                  ;;
  4196                                  ;;  Inputs:	None
  4197                                  ;;
  4198                                  ;;  Outputs:	CARRY_FLAG = 1 if Incorrect DOS version
  4199                                  ;;		Registers set for SYSDISPMSG
  4200                                  ;;		CARRY_FLAG = 0 if Correct DOS version
  4201                                  ;;
  4202                                  ;;  Regs Changed: AX
  4203                                  ;;
  4204                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  4205                                  
  4206                                  _$M_VERSION_CHECK:
  4207 00000CC5 B430                    		mov	ah,30h
  4208 00000CC7 CD21                    		int	21h ; DOS - GET DOS VERSION
  4209                                  			; Return: AL = major version number
  4210                                  			;		(00h for DOS 1.x)
  4211 00000CC9 3C05                    		cmp	al,5		; IF DOS_MAJOR is correct
  4212 00000CCB 7202                    		jb	short $MIF27
  4213 00000CCD F8                      		clc			; Clear the carry flag
  4214 00000CCE C3                      		retn
  4215                                  $MIF27:
  4216 00000CCF BB0200                  		mov	bx,2		; Standard Error			
  4217 00000CD2 B80100                  		mov	ax,1		; Set message # 1		
  4218                                  		;mov	cx,0 ; NO_REPLACE ; No replacable parms
  4219 00000CD5 31C9                    		xor	cx,cx
  4220                                  		;MOV	DL,NO_INPUT
  4221                                  	    	;MOV	DH,UTILITY_MSG_CLASS
  4222                                  					; No input	
  4223 00000CD7 BA00FF                  		mov	dx,0FF00h	; Utility class message
  4224 00000CDA F9                      		stc			; Set Carry Flag
  4225 00000CDB C3                      		retn			; Return
  4226                                  
  4227                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  4228                                  ;;
  4229                                  ;;  Proc Name:	$M_GET_DBCS_VEC
  4230                                  ;;
  4231                                  ;;  Function:	Get the DBCS vector and save it for later use
  4232                                  ;;
  4233                                  ;;  Inputs:	None
  4234                                  ;;
  4235                                  ;;  Outputs:	None
  4236                                  ;;
  4237                                  ;;  Regs Changed:
  4238                                  ;;
  4239                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  4240                                  
  4241                                  _$M_GET_DBCS_VEC:
  4242                                  		;push	ax	; Save registers
  4243                                  		;push	si
  4244 00000CDC 1E                      		push	ds ; *
  4245 00000CDD B80063                  		mov	ax,6300h ; DOS function to get DBSC environment	
  4246                                  				 ; Get environment pointer
  4247 00000CE0 CD21                    		int	21h	; DOS - 3.2+ only
  4248                                  			    	; GET DOUBLE BYTE CHARACTER SET LEAD TABLE
  4249                                  		;push	ds
  4250                                  		;pop	es
  4251 00000CE2 8CD8                    		mov	ax,ds
  4252 00000CE4 1F                      		pop	ds ; *
  4253 00000CE5 7207                    		jc	short $MIF23
  4254                                  
  4255 00000CE7 8936[1C5D]              		mov	[$M_DBCS_VEC],si    ; Save DBCS Vector
  4256                                  		;mov	[$M_DBCS_VEC+2],es
  4257 00000CEB A3[1E5D]                		mov	[$M_DBCS_VEC+2],ax
  4258                                  $MIF23:
  4259                                  		;pop	si	; restore registers
  4260                                  		;pop	ax
  4261 00000CEE C3                      		retn
  4262                                  
  4263                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  4264                                  ;;
  4265                                  ;;  Proc Name:	$M_CHECKSTDIN
  4266                                  ;;
  4267                                  ;;  Function:
  4268                                  ;;
  4269                                  ;;  Inputs:	None
  4270                                  ;;
  4271                                  ;;  Outputs:
  4272                                  ;;
  4273                                  ;;  Regs Changed:
  4274                                  ;;
  4275                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  4276                                  
  4277                                  _$M_CHECKSTDIN:
  4278 00000CEF B80044                  	mov	ax,4400h	; Get info using IOCTL
  4279                                  	;mov	bx,0  ; STDIN	 
  4280 00000CF2 29DB                    	sub	bx,bx ; STDIN = 0
  4281                                  	;cwd
  4282 00000CF4 31D2                    	xor	dx,dx ; 19/11/2018
  4283 00000CF6 CD21                    	int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
  4284                                  			; BX = file or device handle
  4285 00000CF8 80E601                  	and	dh,1		; clear top 7 bits
  4286 00000CFB 80CE01                  	or	dh,1 ; $M_CRIT_ERR_MASK	 ; Turn on bit
  4287 00000CFE B80144                  	mov	ax,4401h ; Set info using IOCTL
  4288 00000D01 CD21                    	int	21h	; DOS -	2+ - IOCTL - SET DEVICE	INFORMATION
  4289                                  			; BX = device handle, (DH = 0)
  4290                                  			; DL = device information to set 
  4291                                  			;	(bits 0-7 from	function 0)
  4292 00000D03 C3                      	retn
  4293                                  
  4294                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  4295                                  ;;
  4296                                  ;;  Proc Name:	$M_CHECKSTDOUT
  4297                                  ;;
  4298                                  ;;  Function:
  4299                                  ;;
  4300                                  ;;  Inputs:	None
  4301                                  ;;
  4302                                  ;;  Outputs:
  4303                                  ;;
  4304                                  ;;  Regs Changed:
  4305                                  ;;
  4306                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  4307                                  
  4308                                  _$M_CHECKSTDOUT:
  4309                                  
  4310 00000D04 B80044                  	mov	ax,4400h	; Get info using IOCTL
  4311 00000D07 BB0100                  	mov	bx,1  ; STDOUT	 
  4312                                  	;cwd
  4313 00000D0A 31D2                    	xor	dx,dx ; 19/11/2018
  4314 00000D0C CD21                    	int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
  4315                                  			; BX = file or device handle
  4316 00000D0E 80E601                  	and	dh,1		; clear top 7 bits
  4317 00000D11 80CE01                  	or	dh,1 ; $M_CRIT_ERR_MASK	 ; Turn on bit
  4318 00000D14 B80144                  	mov	ax,4401h ; Set info using IOCTL
  4319 00000D17 CD21                    	int	21h	; DOS -	2+ - IOCTL - SET DEVICE	INFORMATION
  4320                                  			; BX = device handle, (DH = 0)
  4321                                  			; DL = device information to set 
  4322                                  			;	(bits 0-7 from	function 0)
  4323 00000D19 C3                      	retn
  4324                                  		
  4325                                  ; messages.c (FDISK, MSDOS 6.0, 1991)
  4326                                  ; ----------------------------------------------------------------------------	
  4327                                  
  4328                                  ;/*  */
  4329                                  ;/*---------------------------------------------------------------------------*/
  4330                                  ;/*                                                                           */
  4331                                  ;/*    Subroutine Name: display_msg                                           */
  4332                                  ;/*                                                                           */
  4333                                  ;/*    Subroutine Function:                                                   */
  4334                                  ;/*       Display the requested message to the standard output device         */
  4335                                  ;/*                                                                           */
  4336                                  ;/*    Input:                                                                 */
  4337                                  ;/*        (1) Number of the message to be displayed (see FDISK.SKL)          */
  4338                                  ;/*        (2) Number of substitution parameters (%1,%2)                      */
  4339                                  ;/*        (3) Offset of sublist control block                                */
  4340                                  ;/*        (4) Message Class, 0=no input, 1=input via INT 21 AH=1             */
  4341                                  ;/*                                                                           */
  4342                                  ;/*    Output:                                                                */
  4343                                  ;/*        The message is written to the standard output device.  If input    */
  4344                                  ;/*        was requested, the character code of the key pressed is returned   */
  4345                                  ;/*        in regs.x.ax.                                                      */
  4346                                  ;/*                                                                           */
  4347                                  ;/*    Normal exit: Message written to handle                                 */
  4348                                  ;/*                                                                           */
  4349                                  ;/*    Error exit: None                                                       */
  4350                                  ;/*                                                                           */
  4351                                  ;/*    Internal References:                                                   */
  4352                                  ;/*              None                                                         */
  4353                                  ;/*                                                                           */
  4354                                  ;/*    External References:                                                   */
  4355                                  ;/*              Sysdispmsg (module _msgret.sal)                              */
  4356                                  ;/*                                                                           */
  4357                                  ;/*---------------------------------------------------------------------------*/
  4358                                  
  4359                                  ;void display_msg(msgnum,msghan,msgparms,msgsub,msginput,msgclass)
  4360                                  ;int   msgnum;                         /*;AN000; message number              */
  4361                                  ;int   msghan;                         /*;AN000; output device               */
  4362                                  ;int   msgparms;                       /*;AN000; number of substitution parms*/
  4363                                  ;int   *msgsub;                        /*;AN000; offset of sublist           */
  4364                                  ;char  msginput;                       /*;AN000; 0=no input, else input func */
  4365                                  ;char  msgclass;                       /*;AN014; 0=no input, else input func */
  4366                                  ;
  4367                                  ;BEGIN
  4368                                  ;	regs.x.ax = u(msgnum);             /*;AN000; set registers           */
  4369                                  ;	regs.x.bx = u(msghan);             /*;AN000;                         */
  4370                                  ;	regs.x.cx = u(msgparms);           /*;AN000;                         */
  4371                                  ;	regs.h.dh = uc(msgclass);          /*;AN014;                         */
  4372                                  ;	regs.h.dl = uc(msginput);          /*;AN000;                         */
  4373                                  ;	regs.x.si = u(msgsub);             /*;AN000;                         */
  4374                                  ;	sysdispmsg(&regs,&regs);           /*;AN000;  write the messages     */
  4375                                  ;
  4376                                  ;	return;                            /*;AN000;                         */
  4377                                  ;END
  4378                                  
  4379                                  display_msg:
  4380                                  
  4381                                  	%define msgnum	 bp+4
  4382                                  	%define	msghan	 bp+6
  4383                                  	%define	msgparms bp+8
  4384                                  	%define	msgsub	 bp+10
  4385                                  	%define	msginput bp+12
  4386                                  	%define	msgclass bp+14
  4387                                  
  4388 00000D1A 55                      		push	bp
  4389 00000D1B 89E5                    		mov	bp,sp
  4390                                  
  4391                                  		;mov	ax,[msgnum]
  4392                                  		;mov	[regs_x_ax],ax
  4393                                  		;mov	ax,[msghan]
  4394                                  		;mov	[regs_x_bx],ax
  4395                                  		;mov	ax,[msgparms]
  4396                                  		;mov	[regs_x_cx],ax
  4397                                  		;mov	al,[msgclass]
  4398                                  		;mov	[regs_x_dx+1],al
  4399                                  		;mov	al,[msginput]
  4400                                  		;mov	[regs_x_dx],al
  4401                                  		;mov	ax,[msgsub]
  4402                                  		;mov	[regs_x_si],ax
  4403                                  		;mov	ax,regs ; regs_x_ax
  4404                                  		;push	ax ; outregs
  4405                                  		;push	ax ; inregs
  4406                                  		;call	sysdispmsg
  4407                                  		;pop	bx
  4408                                  		;pop	bx
  4409                                  
  4410                                  		;mov	sp,bp
  4411                                  		;pop	bp
  4412                                  		;retn
  4413                                  
  4414 00000D1D 57                      		push	di ; *
  4415 00000D1E 56                      		push	si ; **
  4416                                  
  4417 00000D1F 8B4604                  		mov	ax,[msgnum] ; ***
  4418 00000D22 8B5E06                  		mov	bx,[msghan] ; ***	
  4419 00000D25 8B4E08                  		mov	cx,[msgparms] ; ***
  4420 00000D28 8A760E                  		mov	dh,[msgclass] ; ***
  4421 00000D2B 8A560C                  		mov	dl,[msginput] ; ***
  4422 00000D2E 8B760A                  		mov	si,[msgsub] ; ***
  4423                                  
  4424 00000D31 E8D900                  		call	SYSDISPMSG ; 13/11/2018 ; * ; ** ; ***
  4425                                  
  4426 00000D34 5E                      		pop	si ; **
  4427 00000D35 5F                      		pop	di ; *
  4428                                  		
  4429 00000D36 89EC                    		mov	sp,bp
  4430 00000D38 5D                      		pop	bp
  4431                                  		
  4432 00000D39 C3                      		retn
  4433                                  
  4434                                  ;sysdispmsg:
  4435                                  ;		call	_sysdispmsg
  4436                                  ;		retn
  4437                                  
  4438                                  ; _msgret.asm (MSDOS 6.0, 1991)
  4439                                  ; ----------------------------------------------------------------------------
  4440                                  
  4441                                  ;_sysdispmsg:
  4442                                  ;
  4443                                  ;	;%define inregs  bp+8
  4444                                  ;	;%define outregs bp+10
  4445                                  ;
  4446                                  ;		push	bp
  4447                                  ;		mov	bp,sp
  4448                                  ;		push	di
  4449                                  ;		push	si
  4450                                  ;		mov	di,[inregs]
  4451                                  ;		mov	ax,[di+10] ; regs.x.di
  4452                                  ;		push	ax
  4453                                  ;		mov	ax,[di]	   ; regs.x.ax	
  4454                                  ;		mov	bx,[di+2]  ; regs.x.bx	
  4455                                  ;		mov	cx,[di+4]  ; regs.x.cx	
  4456                                  ;		mov	dx,[di+6]  ; regs.x.dx	
  4457                                  ;		mov	si,[di+8]  ; regs.x.si	
  4458                                  ;		pop	di
  4459                                  ;		push	bp
  4460                                  ;		call	SYSDISPMSG ; far call -> near call
  4461                                  ;		pop	bp
  4462                                  ;		push	di
  4463                                  ;		mov	di,[outregs]
  4464                                  ;		mov	[di],ax	   ; regs.x.ax	
  4465                                  ;		mov	[di+2],bx  ; regs.x.bx
  4466                                  ;		mov	[di+4],cx  ; regs.x.cx		
  4467                                  ;		mov	[di+6],dx  ; regs.x.dx	
  4468                                  ;		mov	[di+8],si  ; regs.x.si		
  4469                                  ;		lahf
  4470                                  ;		mov	al,ah
  4471                                  ;		mov	[di+12],ax ; regs.x_cflag		
  4472                                  ;		pop	ax
  4473                                  ;		mov	[di+10],ax ; regs.x.di	
  4474                                  ;		pop	si
  4475                                  ;		pop	di
  4476                                  ;		mov	sp,bp
  4477                                  ;		pop	bp
  4478                                  ;		retf
  4479                                  
  4480                                  ;/*  */
  4481                                  ;/******************************************************************************/
  4482                                  ;/*Routine name:  GET_YES_NO_VALUES                                            */
  4483                                  ;/******************************************************************************/
  4484                                  ;/*                                                                            */
  4485                                  ;/*Description:   Uses SYSGETMSG to get the translated values for Y and N      */
  4486                                  ;/*               for display purposes.                                        */
  4487                                  ;/*                                                                            */
  4488                                  ;/*Called Procedures:    sysgetmsg                                             */
  4489                                  ;/*                      sysdispmsg                                            */
  4490                                  ;/*                                                                            */
  4491                                  ;/*Change History: Created        5/11/88         DRM                          */
  4492                                  ;/*                                                                            */
  4493                                  ;/*Input: None                                                                 */
  4494                                  ;/*                                                                            */
  4495                                  ;/*Output: None                                                                */
  4496                                  ;/*                                                                            */
  4497                                  ;/******************************************************************************/
  4498                                  
  4499                                  ;char get_yes_no_values()
  4500                                  
  4501                                  ;BEGIN
  4502                                  ;
  4503                                  ;char           message_flag;
  4504                                  ;char far       *msg_buff;
  4505                                  ;
  4506                                  ;     message_flag = c(TRUE);
  4507                                  ;
  4508                                  ;     /* do sysgetmsg for 'Y' */
  4509                                  ;     regs.x.ax = YesMsg;
  4510                                  ;     regs.h.dh = uc(utility_msg_class);
  4511                                  ;     sysgetmsg(&regs,&segregs,&regs);
  4512                                  ;
  4513                                  ;     FP_OFF(msg_buff) = regs.x.si;
  4514                                  ;     FP_SEG(msg_buff) = segregs.ds;
  4515                                  ;
  4516                                  ;     Yes = *msg_buff;
  4517                                  ;
  4518                                  ;     if ((regs.x.cflag & CARRY_FLAG) != CARRY_FLAG)  /* If msg load problem */
  4519                                  ;          BEGIN
  4520                                  ;          /* do sysgetmsg for 'N' */
  4521                                  ;          regs.x.ax = NoMsg;
  4522                                  ;          regs.h.dh = uc(utility_msg_class);
  4523                                  ;          sysgetmsg(&regs,&segregs,&regs);
  4524                                  ;
  4525                                  ;          FP_OFF(msg_buff) = regs.x.si;
  4526                                  ;          FP_SEG(msg_buff) = segregs.ds;
  4527                                  ;
  4528                                  ;          No = *msg_buff;
  4529                                  ;
  4530                                  ;          END
  4531                                  ;
  4532                                  ;     if ((regs.x.cflag & CARRY_FLAG) == CARRY_FLAG)  /* If msg load problem */
  4533                                  ;       BEGIN
  4534                                  ;        sysdispmsg(&regs,&regs);		/* write the error message */
  4535                                  ;        message_flag = FALSE;
  4536                                  ;       END
  4537                                  ;
  4538                                  ;     return(message_flag);
  4539                                  ;
  4540                                  ;END
  4541                                  
  4542                                  ;get_yes_no_values:
  4543                                  ;
  4544                                  ;		;YesMsg	equ 9
  4545                                  ;		;NoMsg	equ 10
  4546                                  ;
  4547                                  ;	%define message_flag bp-6 ; word
  4548                                  ;	%define _msg_buf     bp-4 ; dword
  4549                                  ;
  4550                                  ;		push	bp
  4551                                  ;		mov	bp,sp
  4552                                  ;		sub	sp,6
  4553                                  ;		mov	byte [message_flag],1
  4554                                  ;		mov	[regs_x_ax],9 ; YesMsg
  4555                                  ;		mov	byte [regs_x_dx+1],0FFh ; 255 ; UTILITY_MSG_CLASS
  4556                                  ;		mov	ax,regs ; regs_x_ax
  4557                                  ;		push	ax
  4558                                  ;		mov	cx,segregs ; segregs_es
  4559                                  ;		push	cx
  4560                                  ;		push	ax
  4561                                  ;		call	sysgetmsg
  4562                                  ;		add	sp,6
  4563                                  ;		mov	ax,[regs_x_si]
  4564                                  ;		mov	[_msg_buf],ax
  4565                                  ;		mov	ax,[segregs_ds]
  4566                                  ;		mov	[_msg_buf+2],ax
  4567                                  ;		les	bx,[_msg_buf]
  4568                                  ;		mov	al,[es:bx]
  4569                                  ;		mov	[Yes],al
  4570                                  ;		mov	al,[regs_x_cflag]
  4571                                  ;		and	al,1
  4572                                  ;		cmp	al,1
  4573                                  ;		je	short gynv_1 ; *
  4574                                  ;		mov	[regs_x_ax],10 ; NoMsg
  4575                                  ;		mov	byte [regs_x_dx+1],0FFh ; 255 ; UTILITY_MSG_CLASS
  4576                                  ;		mov	ax,regs ; regs_x_ax
  4577                                  ;		push	ax ; outregs
  4578                                  ;		mov	cx,segregs ; segregs_es
  4579                                  ;		push	cx
  4580                                  ;		push	ax ; inregs
  4581                                  ;		call	sysgetmsg
  4582                                  ;		add	sp,6
  4583                                  ;		mov	ax,[regs_x_si]
  4584                                  ;		mov	[_msg_buf],ax
  4585                                  ;		mov	ax,[segregs_ds]
  4586                                  ;		mov	[_msg_buf+2],ax
  4587                                  ;		les	bx,[_msg_buf]
  4588                                  ;		mov	al,[es:bx]
  4589                                  ;		mov	[No],al
  4590                                  ;;gynv_1:
  4591                                  ;		mov	al,[regs_x_cflag]
  4592                                  ;		and	al,1
  4593                                  ;		cmp	al,1
  4594                                  ;		jne	short gynv_2
  4595                                  ;gynv_1: ; 13/11/2018 ; *				
  4596                                  ;		mov	ax,regs ; regs_x_ax
  4597                                  ;		push	ax ; outregs
  4598                                  ;		push	ax ; inregs
  4599                                  ;		call	sysdispmsg
  4600                                  ;		pop	bx
  4601                                  ;		pop	bx
  4602                                  ;		mov	byte [message_flag],0
  4603                                  ;gynv_2:
  4604                                  ;		mov	al,[message_flag]
  4605                                  ;		mov	sp,bp
  4606                                  ;		pop	bp
  4607                                  ;		retn
  4608                                  
  4609                                  get_yes_no_values:
  4610                                  
  4611                                  		;YesMsg	equ 9
  4612                                  		;NoMsg	equ 10
  4613                                  
  4614                                  	;%define message_flag bp-6 ; word
  4615                                  	;%define _msg_buf     bp-4 ; dword
  4616                                  
  4617                                  		;push	bp
  4618                                  		;mov	bp,sp
  4619                                  		;sub	sp,6
  4620                                  		;mov	byte [message_flag],1
  4621                                  
  4622 00000D3A B80900                  		mov	ax,9 ; YesMsg
  4623 00000D3D B6FF                    		mov	dh,0FFh ; 255 ; UTILITY_MSG_CLASS
  4624 00000D3F E82500                  		call	SYSGETMSG
  4625 00000D42 7218                    		jc	short gynv_1
  4626                                  		
  4627                                  		;or	cx,cx
  4628                                  		;jz	short gynv_1
  4629                                  
  4630                                  		;; DS:SI = Message address
  4631                                  		;mov	al,[SI]
  4632                                  		;; ES:DI = Message address
  4633 00000D44 268A05                  		mov	al,[ES:DI]		
  4634 00000D47 A2[CBC3]                		mov	[Yes],al
  4635                                  
  4636 00000D4A B80A00                  		mov	ax,10 ; NoMsg
  4637 00000D4D B6FF                    		mov	dh,0FFh ; 255 ; UTILITY_MSG_CLASS
  4638 00000D4F E81500                  		call	SYSGETMSG
  4639 00000D52 7208                    		jc	short gynv_1
  4640                                  
  4641                                  		;or	cx,cx
  4642                                  		;jz	short gynv_1
  4643                                  
  4644                                  		;; DS:SI = Message address
  4645                                  		;mov	al,[SI]
  4646                                  		;; ES:DI = Message address
  4647 00000D54 268A05                  		mov	al,[ES:DI]		
  4648 00000D57 A2[9EA0]                		mov	[No],al
  4649 00000D5A EB0A                    		jmp	short gynv_2
  4650                                  gynv_1:
  4651                                  		; 14/11/2018
  4652 00000D5C C606[CBC3]59            		mov	byte [Yes],'Y'
  4653 00000D61 C606[9EA0]4E            		mov	byte [No],'N'
  4654                                  		
  4655                                  		;call	SYSDISPMSG
  4656                                  		;mov	byte [message_flag],0
  4657                                  gynv_2:
  4658                                  		;mov	al,[message_flag]
  4659                                  		;mov	sp,bp
  4660                                  		;pop	bp
  4661                                  
  4662 00000D66 C3                      		retn
  4663                                  
  4664                                  ;sysgetmsg:
  4665                                  ;		call	_sysgetmsg
  4666                                  ;		retn
  4667                                  
  4668                                  ; _msgret.asm (MSDOS 6.0, 1991)
  4669                                  ; ----------------------------------------------------------------------------
  4670                                  
  4671                                  ;_sysgetmsg:
  4672                                  ;
  4673                                  ;	%define inregs  bp+8
  4674                                  ;	%define _seg_	bp+10
  4675                                  ;	%define outregs bp+12
  4676                                  ;
  4677                                  ;		push	bp
  4678                                  ;		mov	bp,sp
  4679                                  ;		push	di
  4680                                  ;		push	si
  4681                                  ;		mov	di,[inregs] 
  4682                                  ;		mov	ax,[di+10] ; regs.x.di
  4683                                  ;		push	ax
  4684                                  ;		mov	ax,[di]	   ; regs.x.ax	
  4685                                  ;		mov	bx,[di+2]  ; regs.x.bx	
  4686                                  ;		mov	cx,[di+4]  ; regs.x.cx	
  4687                                  ;		mov	dx,[di+6]  ; regs.x.dx	
  4688                                  ;		mov	si,[di+8]  ; regs.x.si	
  4689                                  ;		pop	di
  4690                                  ;		push	bp
  4691                                  ;		call	SYSGETMSG  ; far call -> near call
  4692                                  ;		pop	bp
  4693                                  ;		push	di
  4694                                  ;		mov	di,[_seg_] ; segregs
  4695                                  ;		;push	ax
  4696                                  ;		mov	[di],es	   ; segregs_es	
  4697                                  ;		mov	[di+6],ds  ; segregs_ds	
  4698                                  ;		;pop	ax
  4699                                  ;		pop	di
  4700                                  ;		push	di
  4701                                  ;		mov	di,[outregs]
  4702                                  ;		mov	[di],ax	   ; regs.x.ax	
  4703                                  ;		mov	[di+2],bx  ; regs.x.bx
  4704                                  ;		mov	[di+4],cx  ; regs.x.cx		
  4705                                  ;		mov	[di+6],dx  ; regs.x.dx	
  4706                                  ;		mov	[di+8],si  ; regs.x.si	
  4707                                  ;		lahf
  4708                                  ;		mov	al,ah
  4709                                  ;		mov	[di+12],ax ; regs.x_cflag
  4710                                  ;		pop	ax
  4711                                  ;		mov	[di+10],ax ; regs.x.di	
  4712                                  ;		pop	si
  4713                                  ;		pop	di
  4714                                  ;		mov	sp,bp
  4715                                  ;		pop	bp
  4716                                  ;		retf
  4717                                  
  4718                                  ; msgserv.asm (MSDOS 6.0, 1991)	
  4719                                  ; ----------------------------------------------------------------------------
  4720                                  
  4721                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  4722                                  ;;
  4723                                  ;;  Proc Name:	SYSGETMSG
  4724                                  ;;
  4725                                  ;;  Function:	The GET service returns the segment, offset and size of the
  4726                                  ;;		message text to the caller based on a message number.
  4727                                  ;;		The GET function will not display the message thus assumes
  4728                                  ;;		caller will handle replaceable parameters.
  4729                                  ;;
  4730                                  ;;  Inputs:
  4731                                  ;;
  4732                                  ;;  Outputs:
  4733                                  ;;
  4734                                  ;;  Psuedocode:
  4735                                  ;;		Call $M_GET_MSG_ADDRESS
  4736                                  ;;		IF MSG_NUM exists THEN
  4737                                  ;;		   Set DS:SI = MSG_TXT_PTR + 1
  4738                                  ;;		   CARRY_FLAG = 0
  4739                                  ;;		ELSE
  4740                                  ;;		   CARRY_FLAG = 1
  4741                                  ;;		ENDIF
  4742                                  ;;
  4743                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  4744                                  
  4745                                  SYSGETMSG:
  4746                                  		;push	ax		; Save changed regs
  4747                                  		;push	es
  4748                                  		;push	di
  4749                                  
  4750 00000D67 55                      		push	bp
  4751                                  
  4752 00000D68 E8CE00                  		call	_$M_GET_MSG_ADDRESS ; Scan thru classes to find message
  4753                                  		;jc	short $MIF31
  4754                                  
  4755 00000D6B 83F901                  		cmp	cx,1 ; 13/11/2018
  4756                                  					; Return message in ES:DI
  4757                                  		;;cmp	dh,0FFh ; UTILITY_MSG_CLASS
  4758                                  		;;clc
  4759                                  		;;je	short $MIF32
  4760                                  		;;push	es
  4761                                  		;;pop	ds
  4762                                  		;;jmp	short $MEN32
  4763                                  $MIF32:
  4764                                  		;push	es
  4765                                  		;pop	ds
  4766                                  $MEN32:
  4767                                  		;mov	si,di		; Return message in DS:SI	
  4768                                  $MIF31:
  4769 00000D6E 5D                      		pop	bp		; Restore changed regs
  4770                                  
  4771                                  		;pop	di
  4772                                  		;pop	es
  4773                                  		;pop	ax
  4774                                  		;retf
  4775                                  
  4776 00000D6F C3                      		retn ; 13/11/2018
  4777                                  
  4778                                  ; ----------------------------------------------------------------------------
  4779                                  ; fdparse.c (FDISK, MSDOS 6.0, 1991)	
  4780                                  ; ----------------------------------------------------------------------------
  4781                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 11/11/2018)
  4782                                  
  4783                                  ;/*  */
  4784                                  ;/******************************************************************************/
  4785                                  ;/*Routine name:  CHECK_DISK_VALIDITY                                          */
  4786                                  ;/******************************************************************************/
  4787                                  ;/*                                                                            */
  4788                                  ;/*Description:   Checks the return buffer from parse for the positional       */
  4789                                  ;/*               value to be equal to 0 or 1.                                 */
  4790                                  ;/*                                                                            */
  4791                                  ;/*Called Procedures:                                                          */
  4792                                  ;/*                                                                            */
  4793                                  ;/*Change History: Created        6/18/87         DRM                          */
  4794                                  ;/*                                                                            */
  4795                                  ;/*Input: None                                                                 */
  4796                                  ;/*                                                                            */
  4797                                  ;/*Output: None                                                                */
  4798                                  ;/*                                                                            */
  4799                                  ;/******************************************************************************/
  4800                                  
  4801                                  ;void check_disk_validity()
  4802                                  
  4803                                  ;BEGIN
  4804                                  ;	disk_flag = (FLAG)TRUE;
  4805                                  ;       cur_disk_buff = ((char)p_buff.p_value - 1);
  4806                                  ;       return;
  4807                                  ;END    
  4808                                  
  4809                                  check_disk_validity:
  4810 00000D70 C606[96A0]01            		mov	byte [disk_flag],1
  4811 00000D75 A0[DACB]                		mov	al,[p_buff_p_value]
  4812 00000D78 FEC8                    		dec	al
  4813 00000D7A A2[0FC4]                		mov	[cur_disk_buff],al
  4814 00000D7D C3                      		retn
  4815                                  
  4816                                  ;/*  */
  4817                                  ;/******************************************************************************/
  4818                                  ;/*Routine name:  PROCESS_SWITCH                                               */
  4819                                  ;/******************************************************************************/
  4820                                  ;/*                                                                            */
  4821                                  ;/*Description:   This function looks at the return buffer of the parse and    */
  4822                                  ;/*               determins the switch, places value in buffer, and sets       */
  4823                                  ;/*               flag for specific switch.                                    */
  4824                                  ;/*                                                                            */
  4825                                  ;/*Called Procedures:                                                          */
  4826                                  ;/*                                                                            */
  4827                                  ;/*Change History: Created        6/18/87         DRM                          */
  4828                                  ;/*                                                                            */
  4829                                  ;/*Input: None                                                                 */
  4830                                  ;/*                                                                            */
  4831                                  ;/*Output: None                                                                */
  4832                                  ;/*                                                                            */
  4833                                  ;/******************************************************************************/
  4834                                  
  4835                                  ;void process_switch()
  4836                                  
  4837                                  process_switch:
  4838 00000D7E A1[D6CC]                		mov	ax,[sp_buff_p_synonym] ; 11/11/2018
  4839 00000D81 B101                    		mov	cl,1 ; TRUE
  4840                                  
  4841                                  	; if (sp_buff.p_synonym == (unsigned)p_swi1.sp_switch1)
  4842                                          ;    BEGIN
  4843                                          ;     primary_flag = (FLAG)TRUE;
  4844                                          ;     primary_buff = (unsigned)sp_buff.p_value;
  4845                                          ;    END
  4846                                  
  4847                                  		;cmp	word [sp_buff_p_synonym],p_swi1_sp_switch1
  4848 00000D83 3D[F1A0]                		cmp	ax,p_swi1_sp_switch1
  4849 00000D86 750A                    		jne	short psw1
  4850                                  		;mov	byte [primary_flag],1
  4851 00000D88 880E[00A1]              		mov	[primary_flag],cl
  4852 00000D8C A1[D8CC]                		mov	ax,[sp_buff_p_value]
  4853 00000D8F A3[D0C3]                		mov	[primary_buff],ax
  4854                                  psw1:
  4855                                  
  4856                                  	; if (sp_buff.p_synonym == (unsigned)p_swi1.sp_switch2)
  4857                                          ;    BEGIN
  4858                                          ;     extended_flag = (FLAG)TRUE;
  4859                                          ;     extended_buff = (unsigned)sp_buff.p_value;
  4860                                          ;    END               
  4861                                  
  4862                                  		;cmp	word [sp_buff_p_synonym],p_swi1_sp_switch2
  4863 00000D92 3D[F6A0]                		cmp	ax,p_swi1_sp_switch2
  4864 00000D95 750A                    		jne	short psw2
  4865                                  		;mov	byte [extended_flag],1
  4866 00000D97 880E[D6C3]              		mov	[extended_flag],cl
  4867 00000D9B A1[D8CC]                		mov	ax,[sp_buff_p_value]
  4868 00000D9E A3[CCC3]                		mov	[extended_buff],ax
  4869                                  psw2:
  4870                                  		;cmp	word [sp_buff_p_synonym],p_swi1_sp_switch3
  4871 00000DA1 3D[FBA0]                		cmp	ax,p_swi1_sp_switch3
  4872 00000DA4 750A                    		jne	short psw3
  4873                                  		;mov	byte [logical_flag],1
  4874 00000DA6 880E[D3C3]              		mov	[logical_flag],cl
  4875 00000DAA A1[D8CC]                		mov	ax,[sp_buff_p_value]
  4876 00000DAD A3[D2CB]                		mov	[logical_buff],ax
  4877                                  psw3:
  4878                                  		;cmp	word [sp_buff_p_synonym],p_swi2_sp_switch4
  4879 00000DB0 3D[0BA1]                		cmp	ax,p_swi2_sp_switch4
  4880 00000DB3 7504                    		jne	short psw4
  4881                                  		;mov	byte [quiet_flag],1
  4882 00000DB5 880E[40A1]              		mov	[quiet_flag],cl
  4883                                  psw4:
  4884                                  		;cmp	word [sp_buff_p_synonym],p_swi3_sp_switch5
  4885 00000DB9 3D[17A1]                		cmp	ax,p_swi3_sp_switch5
  4886 00000DBC 7504                    		jne	short psw5
  4887                                  		;mov	byte [status_flag],1
  4888 00000DBE 880E[D4C3]              		mov	[status_flag],cl
  4889                                  psw5:
  4890                                  		;cmp	word [sp_buff_p_synonym],p_swi4_sp_switch6
  4891 00000DC2 3D[2BA1]                		cmp	ax,p_swi4_sp_switch6
  4892 00000DC5 7508                    		jne	short psw6
  4893 00000DC7 E80F00                  		call	DisplayOptionsExit ; Print options then exit
  4894                                  		; 16/11/2018
  4895 00000DCA 29C0                    		sub	ax,ax ; sub al,al
  4896 00000DCC E999F2                  		jmp	_exit
  4897                                  psw6:
  4898                                  
  4899                                  	; if (sp_buff.p_synonym == (unsigned)p_swi5.sp_switch7)
  4900                                          ;    BEGIN
  4901                                          ;     mbr_flag = (FLAG)TRUE;
  4902                                          ;    END
  4903                                  
  4904                                  		;cmp	word [sp_buff_p_synonym],p_swi5_sp_switch7
  4905 00000DCF 3D[39A1]                		cmp	ax,p_swi5_sp_switch7
  4906 00000DD2 7504                    		jne	short psw7
  4907                                  		;mov	byte [mbr_flag],1
  4908 00000DD4 880E[2EA1]              		mov	[mbr_flag],cl
  4909                                  psw7:
  4910 00000DD8 C3                      		retn
  4911                                  
  4912                                  ; 12/11/2018
  4913                                  
  4914                                  ;/************************************************************************/ 
  4915                                  ;/* DisplayOptionsExit           - Displays the options help message     */
  4916                                  ;/*                                lines onto standard output, and then  */
  4917                                  ;/*                                exits the program so the user can     */
  4918                                  ;/*                                retry the command.                    */
  4919                                  ;/*                                                                      */
  4920                                  ;/*      Inputs  : MSG_OPTIONS_FIRST - #defined with the number of the   */
  4921                                  ;/*                                    first message line to output.     */
  4922                                  ;/*                MSG_OPTIONS_LAST  - #defined with the number of the   */
  4923                                  ;/*                                    last message line to output.      */
  4924                                  ;/*                                                                      */
  4925                                  ;/*      Outputs : Options help lines as defined in FDISK.SKL            */
  4926                                  ;/*                Exits to DOS                                          */
  4927                                  ;/*                                                                      */
  4928                                  ;/*      Date    : 04/23/90  c-PaulB                                     */
  4929                                  ;/*      Version : DOS 5.00                                              */
  4930                                  ;/************************************************************************/
  4931                                  
  4932                                  ;void DisplayOptionsExit()
  4933                                  
  4934                                  ;BEGIN
  4935                                  ;	int	iMsgNbr;
  4936                                  ;
  4937                                  ;	/*
  4938                                  ;	 * Display each of the options message lines.
  4939                                  ;	 * Parse_message can't be used because it tries to display
  4940                                  ;	 * the text of an offending command.
  4941                                  ;	 */
  4942                                  ;
  4943                                  ;	for (iMsgNbr = MSG_OPTIONS_FIRST;     /* defined in parse.h */
  4944                                  ;		iMsgNbr <= MSG_OPTIONS_LAST;
  4945                                  ;		iMsgNbr++)
  4946                                  ;	BEGIN
  4947                                  ;	regs.x.ax = iMsgNbr;             /* message #     */
  4948                                  ;       regs.x.bx = STDOUT;              /* output handle */
  4949                                  ;       regs.x.cx = SUBCNT0;             /* # of subs     */
  4950                                  ;       regs.h.dl = No_Input;            /* input flag    */
  4951                                  ;       regs.h.dh = UTILITY_MSG_CLASS;   /* message class */
  4952                                  ;       regs.x.si = 0;                   /* sub list ptr  */
  4953                                  ;       sysdispmsg(&regs,&regs);
  4954                                  ;	END
  4955                                  ;
  4956                                  ;	/*
  4957                                  ;	 * Exit the program so the user can retry the command.
  4958                                  ;	 */
  4959                                  ;
  4960                                  ;	exit(ERR_LEVEL_0);
  4961                                  ;
  4962                                  ;END
  4963                                  
  4964                                  DisplayOptionsExit:
  4965                                  		; 14/11/2018 - Temporary
  4966 00000DD9 803E[40A1]00            		cmp	byte [quiet_flag],0
  4967 00000DDE 7605                    		jna	short DisplayOptions
  4968                                  
  4969 00000DE0 E8FB4E                  		call	print_fdisk_program_msg
  4970 00000DE3 EB27                    		jmp	short DisplayOptions_exit
  4971                                  	
  4972                                  DisplayOptions:
  4973                                  		MSG_OPTIONS_FIRST equ 300
  4974                                  		MSG_OPTIONS_LAST  equ 302
  4975                                  		
  4976                                  		;STDOUT	 equ 1
  4977                                  		;SUBCNT0 equ 0	
  4978                                  		;No_Input equ 0
  4979                                  		;UTILITY_MSG_CLASS equ 0FFh
  4980                                  	
  4981                                  		%define iMsgNbr bp-2
  4982                                  
  4983                                  		;push	bp
  4984 00000DE5 89E5                    		mov	bp,sp
  4985 00000DE7 83EC02                  		sub	sp,2
  4986 00000DEA C746FE2C01              		mov	word [iMsgNbr],MSG_OPTIONS_FIRST ; 300
  4987                                  displaynextopsrow:
  4988 00000DEF 8B46FE                  		mov	ax,[iMsgNbr]		    ; /* message # */
  4989                                  		;mov	[regs_x_ax],ax
  4990                                  		;mov	word [regs_x_bx],1
  4991 00000DF2 BB0100                  		mov	bx,1  ; STDOUT		    ; /* output handle */
  4992                                  		;mov	word [regs_x_cx],0
  4993 00000DF5 29C9                    		sub	cx,cx	; 0 ; SUBCNT0	    ; /* # of subs */
  4994                                  		;mov	byte [regs_x_dx],0
  4995 00000DF7 28D2                    		sub	dl,dl ; 0 ; No_Input 	    ; /* input flag */
  4996                                  		;mov	byte [regs_x_dx+1],0FFh
  4997 00000DF9 B6FF                    		mov	dh,0FFh ; UTILITY_MSG_CLASS ; /* message class */
  4998                                  		;mov	word [regs_x_si],0
  4999 00000DFB 29F6                    		sub	si,si ; 0		    ; /* sub list ptr */
  5000                                  		
  5001                                  		;mov	ax,[regs_x_ax]
  5002                                  		;push	ax ; outregs
  5003                                  		;push	ax ; inregs
  5004                                  		;call	sysdispmsg
  5005                                  		;pop	bx
  5006                                  		;pop	bx
  5007                                  
  5008 00000DFD E80D00                  		call	SYSDISPMSG  ; (msgserv.asm, MSDOS 6.0, 1991)
  5009                                  		
  5010 00000E00 FF46FE                  		inc	word [iMsgNbr]
  5011 00000E03 817EFE2E01              		cmp	word [iMsgNbr],MSG_OPTIONS_LAST ; 302
  5012 00000E08 7EE5                    		jle	short displaynextopsrow
  5013                                  		
  5014                                  		;sub	ax,ax
  5015                                  		;push	ax
  5016                                  		;call	_exit
  5017                                  		;pop	bx
  5018                                  
  5019 00000E0A 89EC                    		mov	sp,bp
  5020                                  		;pop	bp
  5021                                  DisplayOptions_exit:	; 16/11/2018
  5022 00000E0C C3                      		retn
  5023                                  ;DisplayOptions_exit:
  5024                                  ;		sub	ax,ax
  5025                                  ;		jmp	_exit
  5026                                  
  5027                                  ; ----------------------------------------------------------------------------
  5028                                  ; msgserv.asm (MSDOS 6.0, 1991)	
  5029                                  ; ----------------------------------------------------------------------------
  5030                                  ; Modified and simplified for NASM (by Erdogan Tan, 12/11/2018)
  5031                                  
  5032                                  ; sysmsg.inc (MSDOS 6.0, 1991)
  5033                                  ; ----------------------------------------------------------------------------
  5034                                  
  5035                                  ; SYSDISPMSG and SYSGETMSG Equates
  5036                                  
  5037                                  FALSE	equ 0		  ;;
  5038                                  TRUE	equ 1 ; NOT FALSE ;;    List message services and flags
  5039                                  
  5040                                  ; Control Characters For Message Skeleton file
  5041                                  
  5042                                  NULL			EQU	00H    ;; Null
  5043                                  BELL			EQU	07H    ;; Bell
  5044                                  TAB			EQU	09H    ;; Tab
  5045                                  LF			EQU	0AH    ;; Line Feed
  5046                                  HOME			EQU	0BH    ;; Home
  5047                                  FORMFD			EQU	0CH    ;; Form Feed
  5048                                  CR			EQU	0DH    ;; Carriage Return
  5049                                  COLON			EQU	3AH    ;; Colon
  5050                                  
  5051                                  MSG_SER_CLASS		EQU	00H    ;; Message Service Class (reserved)
  5052                                  EXT_ERR_CLASS		EQU	01H    ;; DOS Extended error class
  5053                                  PARSE_ERR_CLASS 	EQU	02H    ;; Parse error class
  5054                                  UTILITY_MSG_CLASS	EQU	0FFH   ;; Utility message class
  5055                                  
  5056                                  NO_HANDLE		EQU	0FFFFH ;; No handle specified
  5057                                  				       ;; (Use DOS functions 01H-09H only)
  5058                                  
  5059                                  NO_REPLACE		EQU	0000H  ;; No replacable parameters
  5060                                  
  5061                                  
  5062                                  ; SUBLIST Equates
  5063                                  
  5064                                    Sublist_Length	EQU	11     ;; Length of sublist structure
  5065                                    Reserved		EQU	0      ;; Reserved byte field
  5066                                  
  5067                                    Left_Align		EQU	0      ;;00xxxxxx
  5068                                    Right_Align		EQU	80h    ;;10xxxxxx
  5069                                  
  5070                                    Char_type		EQU	0      ;;axxx0000 - Character type
  5071                                    Char_Field_Char	EQU	0      ;;a0000000
  5072                                    Char_Field_ASCIIZ	EQU	10h    ;;a0010000
  5073                                  
  5074                                    Unsgn_Bin_Type	EQU	01h    ;;axxx0001 - Unsigned Binary to Decimal character
  5075                                    Unsgn_Bin_Byte	EQU	11h    ;;a0010001
  5076                                    Unsgn_Bin_Word	EQU	21h    ;;a0100001
  5077                                    Unsgn_Bin_DWord	EQU	31h    ;;a0110001
  5078                                  
  5079                                    Sgn_Bin_Type		EQU	02h    ;;axxx0010 - Signed Binary to Decimal character
  5080                                    Sgn_Bin_Byte		EQU	12h    ;;a0010010
  5081                                    Sgn_Bin_Word		EQU	22h    ;;a0100010
  5082                                    Sgn_Bin_DWord 	EQU	32h    ;;a0110010
  5083                                  
  5084                                    Bin_Hex_Type		EQU	03h    ;;axxx0011 - Unsigned Binary to Hexidecimal character
  5085                                    Bin_Hex_Byte		EQU	13h    ;;a0010011
  5086                                    Bin_Hex_Word		EQU	23h    ;;a0100011
  5087                                    Bin_Hex_DWord 	EQU	33h    ;;a0110011
  5088                                  
  5089                                    Date_Type		EQU	04h    ;;axxx0100 - Date to character using current country format
  5090                                    Date_MD		EQU	14h    ;;a0010100
  5091                                    Date_MDY_2		EQU	24h    ;;a0100100
  5092                                    Date_MDY_4		EQU	34h    ;;a0110100
  5093                                  
  5094                                    Time_Cty_Type 	EQU	05h    ;;axxx0101 - Time to character using current country format
  5095                                    Time_HHMM_Cty 	EQU	05h    ;;a0000101
  5096                                    Time_HHMMSS_Cty	EQU	15h    ;;a0010101
  5097                                    Time_HHMMSSHH_Cty	EQU	25h    ;;a0100101
  5098                                  
  5099                                    Time_24_Type		EQU	06h    ;;axxx0110 - Time to character using 24 hour format
  5100                                    Time_HHMM_24		EQU	06h    ;;a0000110
  5101                                    Time_HHMMSS_24	EQU	16h    ;;a0010110
  5102                                    Time_HHMMSSHH_24	EQU	26h    ;;a0100110
  5103                                  
  5104                                    $M_EXTPAR_Type	EQU	08h    ;;axxx1000 - Special case for extended parse replace format
  5105                                  
  5106                                  NO_INPUT		EQU	00H    ;; No input characters
  5107                                  DOS_KEYB_INP		EQU	01H    ;; DOS INT 21H - AH=01H := Keyboard Input
  5108                                  DOS_DIR_CON_INP 	EQU	07H    ;; DOS INT 21H - AH=07H := Direct Console Input Without Echo
  5109                                  DOS_CON_INP		EQU	08H    ;; DOS INT 21H - AH=08H := Console Input Without Echo (Check CTL-BK)
  5110                                  DOS_BUF_KEYB_INP	EQU	0AH    ;; DOS INT 21H - AH=0AH := Buffered Keyboard Input
  5111                                  DOS_CLR_KEYB_BUF	EQU	0CH    ;; DOS INT 21H - AH=0CH := Clear keyboard buffer
  5112                                  DOS_WRITE_HANDLE	EQU	40H    ;; DOS INT 21H - AH=40H := Write to a DOS handle
  5113                                  DOS_DISP_STRING 	EQU	09H    ;; DOS INT 21H - AH=09H := Display $ terminated string
  5114                                  DOS_DISP_CHAR		EQU	02H    ;; DOS INT 21H - AH=02H := Display Character
  5115                                  LOWEST_4CH_VERSION	EQU	0002H  ;; First DOS version to allow AH = 4CH Exit (VERSION 2.00)
  5116                                  
  5117                                  DOS_GET_DBCS_INFO	EQU   6300H    ;; DOS INT 21H - AX=6507H := Get DBCS Vector Table
  5118                                  DOS_GET_EXT_ERROR	EQU	59H    ;; DOS INT 21H - AH=59H := Get Extended Error
  5119                                  DOS_GET_EXT_ERROR_BX	EQU	00H    ;; DOS INT 21H - BX=0000H := Version 0
  5120                                  
  5121                                  DOS_EXTENDED_OPEN	EQU   6C00H    ;AN003; DOS INT 21H - AX=6C00H := Extended Open
  5122                                  NO_CRIT_OPEN		EQU   2000H    ;AN003; Extended Open Mode bit
  5123                                  NOT_EX_FAIL_EX_OPEN	EQU   0101H    ;AN003; Extended Open Flag
  5124                                  DOS_LSEEK_FILE		EQU   4200H    ;AN003; DOS INT 21H - AX=4200H := LSEEK file
  5125                                  DOS_READ_BYTE		EQU	3FH    ;AN003; DOS INT 21H - AH=3FH   := Read byte block
  5126                                  DOS_CLOSE_FILE		EQU	3EH    ;AN003; DOS INT 21H - AH=3EH   := Close file handle
  5127                                  
  5128                                  IFSFUNC_INSTALL_CHECK	EQU   0500H    ;AN006; IFSFUNC Installation Check
  5129                                  IFS_GET_ERR_TEXT	EQU   0502H    ;AN006; IFSFUNC Get Extended Error Text
  5130                                  IFSFUNC_INSTALLED	EQU    0FFH    ;AN006; Return code if IFSFUNC is installed
  5131                                  
  5132                                  EXT_ERR_39		EQU	39     ;; Insufficent Disk Space EXTENDED ERROR (changed from hex to decimal - eg d201)
  5133                                  ERROR_CLASS_39		EQU	01H    ;;   Error Class = 1
  5134                                  ACTION_39		EQU	04H    ;;   Suggested Action = 4
  5135                                  LOCUS_39		EQU	01H    ;;   Locus = 1
  5136                                  
  5137                                  DOS_GET_COUNTRY 	EQU	38H    ;; DOS INT 21H - AH=38H := Get Country Dependant Information
  5138                                  DOS_GET_VERSION 	EQU	30H    ;; DOS INT 21H - AH=30H := Get DOS Version number
  5139                                  DOS_IOCTL_GET_INFO	EQU	4400H  ;; DOS INT 21H - AH=4400H := I/O control for devices
  5140                                  DOS_IOCTL_SET_INFO	EQU	4401H  ;; DOS INT 21H - AH=4401H := I/O control for devices
  5141                                  DOS_GET_EXT_PARSE_ADD	EQU	122EH  ;; DOS INT 2FH - AX=122EH := Get Extended/Parse error address
  5142                                  DOS_GET_EXTENDED	EQU	00     ;; DOS INT 2FH - AX=122EH - DL=00 := Get Extended address
  5143                                  DOS_GET_PARSE		EQU	02     ;; DOS INT 2FH - AX=122EH - DL=02 := Get Parse address
  5144                                  DOS_GET_CRITICAL	EQU	04     ;; DOS INT 2FH - AX=122EH - DL=04 := Get Critical address
  5145                                  DOS_GET_FILE		EQU	06     ;; DOS INT 2FH - AX=122EH - DL=06 := Get File system dependant
  5146                                  DOS_GET_ADDR		EQU	08     ;; DOS INT 2FH - AX=122EH - DL=08 := Get Address of READ_DISK_PROC
  5147                                  DOS_SET_ADDR		EQU	09     ;; DOS INT 2FH - AX=122EH - DL=09 := Set Address of READ_DISK_PROC
  5148                                  LOW_NIB_MASK		EQU	0FH    ;; Mask out the high byte
  5149                                  DOS_CLR_KEYB_BUF_MASK	EQU	0C0H   ;; Check if high nibble is C Hex
  5150                                  $M_CON_INP		EQU	-1     ;; If DOS INT 21H Function 06H - DL := 0FFH for input
  5151                                  $M_CRIT_LO		EQU	19     ;; First Extended Error considered CRITICAL
  5152                                  $M_CRIT_HI		EQU	39     ;; Last Extended Error considered CRITICAL (EG - D191)
  5153                                  $M_AM			EQU	"a"    ;; Time format AM indicator
  5154                                  $M_PM			EQU	"p"    ;; Time format PM indicator
  5155                                  $M_NEG_SIGN		EQU	"-"    ;; Signed decimal number format negative indicator
  5156                                  $M_DEF_TIME_FORM	EQU	 1     ;; Default Time format - 24 hour
  5157                                  $M_DEF_DATE_FORM	EQU	 0     ;; Default Time format - 0 := USA format
  5158                                  $M_DEF_TIME_SEP 	EQU	":"    ;; Default Time separator - ":"
  5159                                  $M_DEF_DATE_SEP 	EQU	"-"    ;; Default Time separator - "-"
  5160                                  $M_DEF_DECI_SEP 	EQU	"."    ;; Default Time hundreds separator - "."
  5161                                  $M_TIMEDATE_PAD 	EQU	"0"    ;; Time/Date PAD character - "0" (ie 12:03p)
  5162                                  $M_MAX_2_YEAR		EQU	99     ;; Maximum 2 digit year
  5163                                  $M_SINGLE_CHAR		EQU	1      ;; A single character is this long      ^
  5164                                  $M_SPECIAL_CASE 	EQU	30H    ;; Special case for replacable parameters %0
  5165                                  $M_UNLIM_W		EQU	0      ;; Unlimited width character
  5166                                  $M_COMMA		EQU	","    ;; Default Thousand separate
  5167                                  $M_CR_LF		EQU	0A0DH  ;; Default CR/LF
  5168                                  $M_SPACE_HYP		EQU	"- "   ;; Default Space/Hyphan
  5169                                  $M_SPACE		EQU	" "    ;; Default Space
  5170                                  $M_NULL 		EQU	0      ;; Null
  5171                                  $M_FIRST_THOU		EQU	3      ;; Location of first thousand separator
  5172                                  $M_SECOND_THOU		EQU	6      ;; Location of second thousand separator
  5173                                  $M_THIRD_THOU		EQU	9      ;; Location of third thousand separator
  5174                                  $M_BASE10		EQU	10     ;; Base 10 for arthmetic
  5175                                  $M_BASE16		EQU	16     ;; Base 16 for arthmetic
  5176                                  $M_CLASS_NOT_EXIST	EQU	 0     ;; Does class exist?
  5177                                  $M_TERMINATING_FLAG	EQU	-1     ;; Is there any more classes?
  5178                                  $M_ADDR_SZ_NEAR 	EQU	2      ;; Size to increment if NEAR
  5179                                  $M_ADDR_SZ_FAR		EQU	4      ;; Size to increment if FAR
  5180                                  ;$M_SL			EQU   DS:[SI]  ;; Refer to SUBLIST as $M_SL
  5181                                  %define	$M_SL [SI] ; 13/11/2018	
  5182                                  $M_NO_HANDLE		EQU	-1     ;; No handle flag
  5183                                  $M_TEMP_BUF_SZ		EQU	64     ;; Size of temporary buffer	 ;AN003;
  5184                                  $M_NEXT_DBCS_VECTOR	EQU	2      ;; Amount to increment to get next vector
  5185                                  $M_DBCS_TERM		EQU    0000    ;; DBCS vector table terminating flag
  5186                                  $M_SPECIAL_MSG_NUM	EQU    0FFFFH  ;; Special generic message number
  5187                                  $M_CRLF_SIZE		EQU    2       ;; Size of the CR LF message
  5188                                  $M_NO_CRLF_MASK 	EQU  10000000B ;; Mask to supress CR LF
  5189                                  $M_ONE_REPLACE		EQU    1       ;; Indicate one replacement
  5190                                  $M_CRIT_ERR_MASK	EQU  00000001B ;; Mask to allow EOF/EOI Crit error
  5191                                  				       ;;
  5192                                  $M_ALIGN_MASK		EQU  10000000b ;; Mask for align
  5193                                  $M_TYPE_MASK		EQU  00001111b ;; Mask for types
  5194                                  $M_SIZE_MASK		EQU  00110000b ;; Mask for types
  5195                                  $M_TIME_MASK		EQU  00000001b ;; Mask for TIME
  5196                                  $M_DATE_MASK		EQU  00010000b ;; Mask for TIME
  5197                                  $M_BYTE 		EQU  00010000b ;; BYTE indicator
  5198                                  $M_WORD 		EQU  00100000b ;; WORD indicator
  5199                                  $M_DWORD		EQU  00110000b ;; DWORD indicator
  5200                                  
  5201                                  ; Standard reserved DOS handles
  5202                                  
  5203                                  _STDIN			EQU	0000H  ;; Standard Input device handle
  5204                                  _STDOUT			EQU	0001H  ;; Standard Output device handle
  5205                                  _STDERR			EQU	0002H  ;; Standard Error Output device handle
  5206                                  _STDAUX			EQU	0003H  ;; Standard Auxiliary device handle
  5207                                  _STDPRN			EQU	0004H  ;; Standard Printer device handle
  5208                                  
  5209                                  ; msghan.inc (MSDOS 6.0, 1991)
  5210                                  ; ----------------------------------------------------------------------------
  5211                                  
  5212                                  ; VALUES FOR THE MSG_DESC CONTROL BLOCK
  5213                                  ONE_SUBS       EQU   1		   	; ONE VARIABLE FIELD IN MESSAGE
  5214                                  TWO_SUBS       EQU   2		   	; TWO VARIABLE FIELDS IN MESSAGE
  5215                                  THREE_SUBS     EQU   3		   	; THREE VARIABLE FIELDS IN MESSAGE
  5216                                  CLASS_1        EQU   EXT_ERR_CLASS 	; CLASS 1 (DOS EXTENDED ERRORS)
  5217                                  CLASS_2        EQU   PARSE_ERR_CLASS 	; CLASS 2 (PARSE ERRORS)
  5218                                  CLASS_A        EQU   UTILITY_MSG_CLASS	; CLASS A TYPE MESSAGE
  5219                                  
  5220                                  ;THIS MESSAGE DESCRIPTOR CONTROL BLOCK IS GENERATED, ONE PER MESSAGE,
  5221                                  ;TO DEFINE THE SEVERAL PARAMETERS THAT ARE EXPECTED TO BE PASSED IN
  5222                                  ;CERTAIN REGISTERS WHEN THE SYSDISPMSG FUNCTION IS TO BE INVOKED.
  5223                                  
  5224                                  struc MSG_DESC
  5225                                  .MSG_NUM :	resw	0	   	; MESSAGE NUMBER (TO AX)
  5226 00000000 <res 00000002>          .MSG_HANDLE:	resw	_STDOUT	   	; HANDLE OF OUTPUT DEVICE (TO BX)
  5227                                  .MSG_SUBLIST:	resw	0	   	; POINTER TO SUBLIST (TO SI)
  5228                                  .MSG_COUNT:	resw	0	   	; SUBSTITUTION COUNT (TO CX)
  5229 00000002 <res 0001FE00>          .MSG_CLASS:	resw	CLASS_A << 8	; MESSAGE CLASS (IN HIGH BYTE, TO DH)
  5230                                  .size:				   	; LOW BYTE HAS 0 (FUNCTION "NO INPUT", TO DL)
  5231                                  endstruc
  5232                                  
  5233                                  ; VALUES FOR THE SUBLIST CONTROL BLOCK
  5234                                  PC_ID_0        EQU   0		   ; ID OF " - " TRAILER TO MESSAGE
  5235                                  PC_ID_1        EQU   1		   ; ID OF PERCENT VARIABLE FIELD
  5236                                  PC_ID_2        EQU   2		   ; ID OF PERCENT VARIABLE FIELD
  5237                                  PC_ID_3        EQU   3		   ; ID OF PERCENT VARIABLE FIELD
  5238                                  MAX_0	       EQU   0		   ; MAXIMUM WIDTH OF STRING FIELD (0=NO LIMIT)
  5239                                  MIN_1	       EQU   1		   ; MINIMUM WIDTH OF STRING FIELD
  5240                                  PAD_BLK        EQU   " "           ; CHAR FOR PAD FIELD
  5241                                  FILL_OFF       EQU   0		   ; TO BE REPLACED WITH ACTUAL OFFSET
  5242                                  FILL_SEG       EQU   0		   ; TO BE REPLACED WITH ACTUAL SEG ID
  5243                                  
  5244                                  struc SUBLIST
  5245 00000000 <res 00000001>          .SUB_SIZE:	resb 1 ;11	; SUBLIST SIZE (POINTER TO NEXT SUBLIST)
  5246 00000001 <res 00000001>          .SUB_RES:	resb 1 ;0	; RESERVED
  5247                                  				; NEXT FIELD IS TO BE USED AS A DOUBLE WORD
  5248 00000002 <res 00000002>          .SUB_VALUE:	resw 1 ;0	; TIME, DATE, OR PTR TO DATA ITEM
  5249 00000004 <res 00000002>          .SUB_VALUE_SEG:	resw 1 ;0	; SEG ID OF PTR
  5250                                  				; (ABOVE FIELD MUST BE FILLED AT EXECUTION TIME
  5251                                  				; IF THIS IS A .COM FILE)
  5252 00000006 <res 00000001>          .SUB_ID:	resb 1 ;0	; N OF %N
  5253 00000007 <res 00000001>          .SUB_FLAGS:	resb 1 ;0	; DATA TYPE FLAGS
  5254 00000008 <res 00000001>          .SUB_MAX_WIDTH:	resb 1 ;MAX_0	; MAXIMUM FIELD WIDTH (0=UNLIMITED)
  5255 00000009 <res 00000001>          .SUB_MIN_WIDTH:	resb 1 ;0	; MINIMUM FIELD WIDTH
  5256 0000000A <res 00000001>          .SUB_PAD_CHAR:	resb 1 ;PAD_BLK ; CHARACTER FOR PAD FIELD
  5257                                  .size:				; CAN BE " ", "0" OR ",".
  5258                                  endstruc			; "," CAUSES INSERTION OF THE ACTIVE
  5259                                  				; THOUSANDS SEPARATOR BETWEEN EVERY 3 DIGITS.
  5260                                  
  5261                                  ;		  BITS DEFINED FOR SUB_FLAGS ABOVE
  5262                                  ;			FORMAT = A0SSTTTT
  5263                                  ;				 ++ + +--- FIELD TYPE
  5264                                  ;				 || +--- DATA VARIABLE SIZE
  5265                                  ;				 |+--- RESERVED, MUST BE ZERO
  5266                                  ;				 +--- ALIGNMENT INDICATOR
  5267                                  ;SF_BITS     RECORD F_ALIGN:1,F_RES:1=0,F_SIZE:2,F_TYPE:4
  5268                                  
  5269                                  ;		F_ALIGN FIELD, ALIGNMENT INDICATOR
  5270                                  SF_LEFT 	  EQU	0	   ;AN000;LEFT ALIGN
  5271                                  SF_RIGHT	  EQU	1	   ;AN000;RIGHT ALIGN
  5272                                  
  5273                                  ;		F_RES FIELD, RESERVED, SHOULD BE ZERO
  5274                                  
  5275                                  ;		F_TYPE FIELD, FIELD TYPE
  5276                                  SF_CHAR 	  EQU	0000B	   ;AN000;TYPE IS CHARACTER
  5277                                  ;		F_SIZE FIELD,
  5278                                  SF_CH		  EQU	00B	   ;AN000;SINGLE CHARACTER
  5279                                  SF_ASCIIZ	  EQU	01B	   ;AN000;ASCIIZ STRING
  5280                                  
  5281                                  ;		F_TYPE FIELD, FIELD TYPE
  5282                                  SF_UN_BD	  EQU	0001B	   ;AN000;UNSIGNED BINARY TO DECIMAL CHARACTER
  5283                                  ;		F_SIZE FIELD,
  5284                                  SF_BYTE 	  EQU	01B	   ;AN000;DATA IS BYTE SIZED
  5285                                  SF_WORD 	  EQU	10B	   ;AN000;DATA IS WORD SIZED
  5286                                  SF_DWORD	  EQU	11B	   ;AN000;DATA IS DOUBLE WORD SIZED
  5287                                  
  5288                                  ;		F_TYPE FIELD, FIELD TYPE
  5289                                  SF_SIN_BD	  EQU	0010B	   ;AN000;SIGNED BINARY TO DECIMAL CHARACTER
  5290                                  ;		F_SIZE FIELD,
  5291                                  ;SF_BYTE	  EQU	01B	   ;DATA IS BYTE SIZED
  5292                                  ;SF_WORD	  EQU	10B	   ;DATA IS WORD SIZED
  5293                                  ;SF_DWORD	  EQU	11B	   ;DATA IS DOUBLE WORD SIZED
  5294                                  
  5295                                  ;		F_TYPE FIELD, FIELD TYPE
  5296                                  SF_UN_BH	  EQU	0011B	   ;AN000;UNSIGNED BINARY TO HEXADECIMAL CHARACTER
  5297                                  ;		F_SIZE FIELD,
  5298                                  ;SF_BYTE	  EQU	01B	   ;DATA IS BYTE SIZED
  5299                                  ;SF_WORD	  EQU	10B	   ;DATA IS WORD SIZED
  5300                                  ;SF_DWORD	  EQU	11B	   ;DATA IS DOUBLE WORD SIZED
  5301                                  
  5302                                  ;		F_TYPE FIELD, FIELD TYPE
  5303                                  SF_DATE 	  EQU	0100B	   ;AN000;DATE TO CHARACTER,
  5304                                  				   ; USING CURRENT COUNTRY FORMAT
  5305                                  				   ;SUB_VALUE HIGH=YEAR
  5306                                  				   ;SUB_VALUE LOW=MMDD
  5307                                  ;		F_SIZE FIELD,
  5308                                  SF_MD		  EQU	01B	   ;AN000;MONTH AND DAY ONLY
  5309                                  SF_MDY2 	  EQU	10B	   ;AN000;MONTH,DAY AND YEAR (2 DIGITS)
  5310                                  SF_MDY4 	  EQU	11B	   ;AN000;MONTH,DAY AND YEAR (4 DIGITS)
  5311                                  
  5312                                  ;		F_TYPE FIELD, FIELD TYPE
  5313                                  SF_TIME_12	  EQU	0101B	   ;AN000;TIME TO CHARACTER, 12 HOUR FORMAT
  5314                                  				   ; USING CURRENT COUNTRY FORMAT
  5315                                  				   ;SUB_VALUE HIGH=HHMM
  5316                                  				   ;SUB_VALUE LOW=SSHH
  5317                                  ;		F_SIZE FIELD,
  5318                                  SF_HHMM 	  EQU	00B	   ;AN000;HH:MM (ACTIVE TIME FORMAT)
  5319                                  SF_HHMMSS	  EQU	01B	   ;AN000;HH:MM:SS (ACTIVE TIME FORMAT)
  5320                                  SF_HHMMSSHH	  EQU	10B	   ;AN000;HH:MM:SS:HH
  5321                                  
  5322                                  ;		F_TYPE FIELD, FIELD TYPE
  5323                                  SF_TIME_24	  EQU	0110B	   ;AN000;TIME TO CHARACTER, 24 HOUR FORMAT
  5324                                  				   ; USING CURRENT COUNTRY FORMAT
  5325                                  				   ;SUB_VALUE HIGH=HHMM
  5326                                  				   ;SUB_VALUE LOW=SSHH
  5327                                  ;		F_SIZE FIELD,
  5328                                  ;SF_HHMM	  EQU	00B	   ;HH:MM (ACTIVE TIME FORMAT)
  5329                                  ;SF_HHMMSS	  EQU	01B	   ;HH:MM:SS (ACTIVE TIME FORMAT)
  5330                                  ;SF_HHMMSSHH	  EQU	10B	   ;HH:MM:SS:HH
  5331                                  
  5332                                  ;		THE NEXT GROUP ARE ALL CLASS "1" MESSAGES
  5333                                  
  5334                                  ;		PUBLIC MSGNUM_EXTERR;AN000;
  5335                                  ;MSGNUM_EXTERR  MSG_DESC <,STDERR,,,CLASS_1 SHL 8> ; ALL EXTENDED DOS ERRORS
  5336                                  ;				   ; ERROR NUMBER WILL NEED TO BE FILLED IN
  5337                                  
  5338                                  ;		THE NEXT GROUP ARE ALL CLASS "2" MESSAGES
  5339                                  
  5340                                  ;		PUBLIC MSGNUM_PARSE ; SO PARSE DRIVER CAN FIND IT
  5341                                  ;MSGNUM_PARSE   MSG_DESC <,STDERR,,,CLASS_2 SHL 8> ; ALL PARSING ERRORS
  5342                                  ;				   ; ERROR NUMBER WILL NEED TO BE FILLED IN
  5343                                  
  5344                                  ;		THE NEXT GROUP ARE ALL CLASS "A" MESSAGES
  5345                                  ;		THESE ARE THE "CANNED" MESSAGES ALWAYS PRESENT
  5346                                  
  5347                                  ;		PUBLIC MSGNUM_VER   ;
  5348                                  ;MSGNUM_VER	MSG_DESC <1,STDERR> ; "Incorrect DOS Version"
  5349                                  
  5350                                  ; msgserv.asm (MSDOS 6.0, 1991)	
  5351                                  ; ----------------------------------------------------------------------------
  5352                                  
  5353                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  5354                                  ;;
  5355                                  ;;  Proc Name:	SYSDISPMSG
  5356                                  ;;
  5357                                  ;;  Function:	The DISPLAY service will output a defined message to a handle
  5358                                  ;;		requested by the caller. It also provides function to display
  5359                                  ;;		messages when handles are not applicable (ie. DOS function calls
  5360                                  ;;		00h to 0Ah) Replaceable parameters are allowed and are
  5361                                  ;;		defined previous to entry.
  5362                                  ;;
  5363                                  ;;		It is assumes that a PRELOAD function has already determined
  5364                                  ;;		the addressibilty internally to the message retriever services.
  5365                                  ;;  Inputs:
  5366                                  ;;
  5367                                  ;;  Outputs:
  5368                                  ;;
  5369                                  ;;  Psuedocode:
  5370                                  ;;		Save registers needed later
  5371                                  ;;		Get address of the message requested
  5372                                  ;;		IF Message number exists THEN
  5373                                  ;;		  IF replacable parameters were specified THEN
  5374                                  ;;		     Display message with replacable parms
  5375                                  ;;		  ELSE
  5376                                  ;;		     Display string without replacable parms
  5377                                  ;;		  ENDIF
  5378                                  ;;		  IF character input was requested THEN
  5379                                  ;;		     Wait for character input
  5380                                  ;;		  ENDIF
  5381                                  ;;		  Clear CARRY FLAG
  5382                                  ;;		ELSE
  5383                                  ;;		   Set CARRY FLAG
  5384                                  ;;		ENDIF
  5385                                  ;;		Return
  5386                                  ;;
  5387                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  5388                                  
  5389                                  ; Input:
  5390                                  ; AX = MSG_DESC.MSG_NUM		; MESSAGE NUMBER
  5391                                  ; BX = MSG_DESC.MSG_HANDLE	; HANDLE OF OUTPUT DEVICE
  5392                                  ; CX = MSG_DESC.MSG_COUNT	; SUBSTITUTION COUNT
  5393                                  ; SI = MSG_DESC.MSG_SUBLIST	; POINTER TO SUBLIST
  5394                                  ; DH = MSG_DESC.MSG_CLASS	; MESSAGE CLASS
  5395                                  ; DL = 0
  5396                                  
  5397                                  SYSDISPMSG:
  5398 00000E0D 06                      		push	es	; Save registers and values needed later
  5399 00000E0E 55                      		push	bp
  5400                                  		;push	dx		
  5401                                  
  5402 00000E0F 89CD                    		mov	bp,cx		; Use BP to hold replace count
  5403                                  
  5404 00000E11 891E[205D]              		mov	[$M_HANDLE],bx	; Save handle
  5405 00000E15 8836[255D]              		mov	[$M_CLASS],dh	; Save class
  5406                                  
  5407                                  		; Get address of the message requested
  5408 00000E19 E81D00                  		call	_$M_GET_MSG_ADDRESS
  5409                                  
  5410 00000E1C 83F901                  		cmp	cx,1		; Was message found?
  5411                                  		;jb	short $MEN94	; NO
  5412 00000E1F 7215                    		jb	short $MIF104 	; CF = 1
  5413                                  				
  5414                                  					; YES, Message address in ES:DI
  5415                                  
  5416                                  		; Test if replacable parameters were specified
  5417 00000E21 09ED                    		or	bp,bp		; Were replacable parameters requested		
  5418 00000E23 7505                    		jnz	short $MIF94
  5419                                  
  5420                                  		; Display string without replacable parms
  5421 00000E25 E85904                  		call	_$M_DISPLAY_STRING ; No, great . . . Display message
  5422 00000E28 EB03                    		jmp	short $MEN94
  5423                                  $MIF94:
  5424                                  		; Display message with replacable parms		
  5425 00000E2A E80B01                  		call	_$M_DISPLAY_MESSAGE
  5426                                  $MEN94:
  5427                                  		;pop	dx		; Get Input/Class request
  5428 00000E2D 7207                    		jc	short $MIF104
  5429                                  
  5430 00000E2F 8A36[255D]              		mov	dh,[$M_CLASS]	; Restore class
  5431                                  
  5432 00000E33 E81F05                  		call	_$M_ADD_CRLF	; Check if we need to add the CR LF chars.
  5433                                  $MIF104:
  5434 00000E36 5D                      		pop	bp
  5435 00000E37 07                      		pop	es
  5436                                  
  5437                                  		;retf
  5438 00000E38 C3                      		retn
  5439                                  
  5440                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  5441                                  ;;
  5442                                  ;;	PROC NAME: $M_GET_MSG_ADDRESS
  5443                                  ;;
  5444                                  ;;	FUNCTION:  To scan thru classes to return pointer to the message header
  5445                                  ;;	INPUTS:    Access to $M_RES_ADDRESSES
  5446                                  ;;	OUTPUTS:   IF CX = 0 THEN Message was not found
  5447                                  ;;		   IF CX > 1 THEN ES:DI points to the specified message
  5448                                  ;;	REGS CHANGED: ES,DI,CX
  5449                                  ;;
  5450                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  5451                                  
  5452                                  _$M_GET_MSG_ADDRESS:
  5453 00000E39 56                      		push	si
  5454 00000E3A 53                      		push	bx
  5455 00000E3B 31F6                    		xor	si,si		; Use SI as an index
  5456 00000E3D 31C9                    		xor	cx,cx		; Use CX as an size
  5457                                  $MDO36:
  5458 00000E3F 80FEFF                  		cmp	dh,0FFh	 ; UTILITY_MSG_CLASS ; Were utility messages requested?
  5459 00000E42 7508                    		jne	short $MIF37	; No,
  5460 00000E44 C4BC[105D]              		les	di,[$M_CLASS_A_ADDRS+si] ; Yes, get address of class	
  5461 00000E48 8CC3                    		mov	bx,es
  5462 00000E4A EB25                    		jmp	short $MEN37
  5463                                  $MIF37:
  5464 00000E4C F6C602                  		test	dh,2	; PARSE_ERR_CLASS ; Were parse errors requested?
  5465 00000E4F 7408                    		jz	short $MIF39	; No, extended errors were specified
  5466                                  						 ; Yes
  5467 00000E51 C4BC[F45C]              		les	di,[$M_PARSE_COMMAND+si] ; Get address of class
  5468 00000E55 8CC3                    		mov	bx,es
  5469 00000E57 EB18                    		jmp	short $MEN37
  5470                                  $MIF39:
  5471 00000E59 83F813                  		cmp	ax,13h ; $M_CRIT_LO	; Is this a critical error?
  5472 00000E5C 720D                    		jb	short $MIF41	; No,
  5473 00000E5E 83F827                  		cmp	ax,27h ; $M_CRIT_HI
  5474 00000E61 7708                    		ja	short $MIF41	; No,
  5475                                  						; Yes, (extended errors considered critical)
  5476 00000E63 C4BC[005D]              		les	di,[$M_CRIT_ADDRS+si]	; Get address of class
  5477 00000E67 8CC3                    		mov	bx,es
  5478 00000E69 EB06                    		jmp	short $MEN37
  5479                                  $MIF41:					; Extended Errors
  5480 00000E6B C4BC[E45C]              		les	di,[$M_EXT_ERR_ADDRS+si] ; Get address of class
  5481 00000E6F 8CC3                    		mov	bx,es
  5482                                  $MEN37:
  5483 00000E71 83FBFF                  		cmp	bx,0FFFFh ; $M_TERMINATING_FLAG	; Are we finished all classes?
  5484 00000E74 7516                    		jne	short $MIF46	; No,
  5485                                  						; Yes,
  5486 00000E76 80FEFF                  		cmp	dh,0FFh	; UTILITY_MSG_CLASS ; Was it a UTILITY class?
  5487 00000E79 7503                    		jne	short $MIF47	; No,
  5488 00000E7B F9                      		stc				; Yes, set the carry flag
  5489                                  		;jmp	short $MEN47
  5490 00000E7C EB1E                    		jmp	short $MEN36 ; 13/11/2018
  5491                                  		
  5492                                  $MIF47:
  5493 00000E7E A3[285D]                		mov	[$M_MSG_NUM],ax		; Save message number
  5494 00000E81 B8FFFF                  		mov	ax,0FFFFh ; $M_SPECIAL_MSG_NUM	; Set special message number
  5495 00000E84 BD0100                  		mov	bp,1  ; $M_ONE_REPLACE	; Set one replace in message
  5496 00000E87 31F6                    		xor	si,si			; Reset the SI index to start again
  5497 00000E89 F8                      		clc
  5498                                  $MEN47:
  5499                                  		;jmp	short $MEN46
  5500 00000E8A EB0C                    		jmp	short $MIF49 ; 13/11/2018
  5501                                  $MIF46:
  5502 00000E8C 83FB00                  		cmp	bx,0 ; $M_CLASS_NOT_EXIST ; Does this class exist?	
  5503 00000E8F 7403                    		je	short $MIF51	; No,
  5504                                  						; Yes,	
  5505 00000E91 E84600                  		call	_$M_FIND_SPECIFIED_MSG	; Try to find the message 
  5506                                  $MIF51:
  5507 00000E94 83C604                  		add	si,4 ; $M_ADDR_SZ_FAR	; Get next class
  5508 00000E97 F8                      		clc
  5509                                  ;$MEN46:
  5510                                  		;jc	short $MEN36
  5511                                  $MIF49: ; 13/11/2018
  5512 00000E98 09C9                    		or	cx,cx			; Was the message found?
  5513                                  		;jnz	short $MEN36		; Yes,
  5514                                  		;jmp	short $MDO36
  5515 00000E9A 74A3                    		jz	short $MDO36 ; 13/11/2018 ; No,
  5516                                  $MEN36:
  5517 00000E9C 9C                      		pushf	 ; not necessary ; * 	; Save the flag state
  5518 00000E9D 80FE01                  		cmp	dh,1 ; EXT_ERR_CLASS	; Was an extended error requested?
  5519 00000EA0 7525                    		jne	short $MIF56
  5520 00000EA2 52                      		push	dx		; Save all needed registers
  5521 00000EA3 55                      		push	bp
  5522 00000EA4 51                      		push	cx
  5523 00000EA5 06                      		push	es
  5524 00000EA6 57                      		push	di
  5525 00000EA7 50                      		push	ax
  5526 00000EA8 B80005                  		mov	ax,0500h	; Check if IFSFUNC is installed
  5527 00000EAB CD2F                    		int	2Fh	; Multiplex - DOS 3+ CRITICAL ERROR HANDLER - INSTALLATION CHECK
  5528                                  				; Return: AL = 00h not installed, OK to	install
  5529                                  				; 01h not installed, can't install
  5530                                  				; FFh installed
  5531 00000EAD 3CFF                    		cmp	al,0FFh		; Is it installed?
  5532 00000EAF 58                      		pop	ax		; Restore msg number
  5533                                  		;jne	short $MIF57	; No,
  5534 00000EB0 7208                    		jb	short $MEN58 ; 13/11/2018 ; cf = 1
  5535                                  					; Yes,
  5536 00000EB2 93                      		xchg	ax, bx		; BX is the extended error number
  5537 00000EB3 B80205                  		mov	ax,0502h	; AX is the multiplex number
  5538                                  					; Call IFSFUNC	
  5539 00000EB6 CD2F                    		int	2Fh	; Multiplex - DOS 3+ CRITICAL ERROR HANDLER -
  5540                                  		;jmp	short $MEN57
  5541                                  ;$MIF57:
  5542                                  ;		stc
  5543                                  ;$MEN57:				; Was there an update?
  5544 00000EB8 7305                    		jnc	short $MIF60	; No,
  5545                                  $MEN58: ; 13/11/2018		
  5546 00000EBA 5F                      		pop	di		; Restore old pointer
  5547 00000EBB 07                      		pop	es
  5548 00000EBC 59                      		pop	cx
  5549 00000EBD EB06                    		jmp	short $MEN60
  5550                                  $MIF60:
  5551 00000EBF 83C406                  		add	sp,6		; Throw away old pointer
  5552 00000EC2 E80600                  		call	_$M_SET_LEN_IN_CX ; Get the length of the ASCIIZ string
  5553                                  $MEN60:
  5554 00000EC5 5D                      		pop	bp		; Restore other Regs
  5555 00000EC6 5A                      		pop	dx
  5556                                  $MIF56:
  5557                                  ;		jmp	short _$M_POPF
  5558                                  ;_$M_MYRET:
  5559                                  ;		iret
  5560                                  
  5561                                  		; 12/11/2018
  5562                                  
  5563 00000EC7 9D                      		popf		; * ; not necessary
  5564                                  
  5565 00000EC8 5B                      		pop	bx 	; *
  5566 00000EC9 5E                      		pop	si	; *
  5567 00000ECA C3                      		retn		; *
  5568                                  
  5569                                  ;_$M_POPF:				; Restore the flag state
  5570                                  		;push	cs
  5571                                  		;call	_$M_MYRET
  5572                                  		;pop	bx
  5573                                  		;pop	si
  5574                                  
  5575                                  		;;retf
  5576                                  		;retn
  5577                                  
  5578                                  ;_$M_MYRET:	iret
  5579                                  		
  5580                                  ; ----------------------------------------------------------------------------
  5581                                  		
  5582                                  				; Get the length of the ASCIIZ string
  5583                                  _$M_SET_LEN_IN_CX:			;
  5584 00000ECB 57                      		push	di		; Save position
  5585 00000ECC 50                      		push	ax		;
  5586 00000ECD B9FFFF                  		mov	cx,-1		; Set CX for decrements
  5587 00000ED0 30C0                    		xor	al,al		; Prepare compare register
  5588 00000ED2 F2AE                    		repne scasb		; Scan for zero
  5589 00000ED4 F7D1                    		not	cx		; Change decrement into number
  5590 00000ED6 49                      		dec	cx		; Don't include the zero
  5591 00000ED7 58                      		pop	ax		;
  5592 00000ED8 5F                      		pop	di		; Restore position
  5593 00000ED9 C3                      		retn			;
  5594                                  
  5595                                  ; ----------------------------------------------------------------------------
  5596                                  
  5597                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  5598                                  ;;
  5599                                  ;;	PROC NAME: $M_FIND_SPECIFIED_MSG
  5600                                  ;;
  5601                                  ;;	FUNCTION:  To scan thru message headers until message is found
  5602                                  ;;	INPUTS:    ES:DI points to beginning of msg headers
  5603                                  ;;		   CX contains the number of messages in class
  5604                                  ;;		   DH contains the message class
  5605                                  ;;	OUPUTS:    IF CX = 0 THEN Message was not found
  5606                                  ;;		   IF CX > 1 THEN ES:DI points to header of specified message
  5607                                  ;;
  5608                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  5609                                  
  5610                                  _$M_FIND_SPECIFIED_MSG:
  5611 00000EDA 83FB01                  		cmp	bx,1		; Do we have an address to CALL?
  5612 00000EDD 751F                    		jne	short $MIF64
  5613                                  					; Do we have an address to CALL?
  5614 00000EDF 833E[0C5D]FF            		cmp	word [$M_DISK_PROC_ADDR], -1 ; 0FFFFh
  5615 00000EE4 7418                    		je	short $MIF64
  5616                                  					; Yes
  5617                                  				; Are we displaying a default Ext Err?
  5618 00000EE6 83F8FF                  		cmp	ax,0FFFFh ; $M_SPECIAL_MSG_NUM
  5619 00000EE9 750B                    		jne	short $MIF65	 ;No
  5620                                  
  5621 00000EEB 50                      		push	ax		; Reset the special message number
  5622 00000EEC A1[285D]                		mov	ax,[$M_MSG_NUM] ; Get the old message number
  5623                                  				 ; Call the READ_DISK_PROC to get error text	
  5624 00000EEF FF1E[0C5D]              		call	far [$M_DISK_PROC_ADDR]
  5625 00000EF3 58                      		pop	ax		; Reset the special message number
  5626 00000EF4 EB04                    		jmp	short $MEN65
  5627                                  $MIF65:
  5628                                  		;CALL	DWORD PTR $M_RT.$M_DISK_PROC_ADDR
  5629                                  					; Call the READ_DISK_PROC to get error text 
  5630 00000EF6 FF1E[0C5D]              		call	far [$M_DISK_PROC_ADDR]
  5631                                  $MEN65:
  5632                                  		;jmp	short $MEN64
  5633 00000EFA 7330                    		jnc	short $MIF88	; *
  5634                                  		; cf = 1
  5635 00000EFC EB19                    		jmp	short $MDO76	; *	
  5636                                  $MIF64:
  5637 00000EFE 31C9                    		xor	cx,cx		; CX = 0 will allow us to
  5638 00000F00 80FEFF                  		cmp	dh,0FFh ; UTILITY_MSG_CLASS
  5639 00000F03 7406                    		je	short $MIF69
  5640                                  		;MOV	CL,BYTE PTR ES:[DI].$M_NUM_CLS_MSG 
  5641 00000F05 268A4D03                		mov	cl,[es:di+3]	; Get number of messages in class
  5642 00000F09 EB09                    		jmp	short $MEN69
  5643                                  $MIF69:
  5644                                  		;CMP	BYTE PTR ES:[DI].$M_CLASS_ID,DH
  5645 00000F0B 263835                  		cmp	[es:di],dh	; Check if class still exists at
  5646 00000F0E 7504                    		jne	short $MEN69
  5647                                  					; pointer (hopefully)
  5648                                  		;MOV	CL,BYTE PTR ES:[DI].$M_NUM_CLS_MSG
  5649 00000F10 268A4D03                		mov	cl,[es:di+3]	; Get number of messages in class
  5650                                  $MEN69:
  5651                                  					;  go on to the next class
  5652 00000F14 83C704                  		add	di,4 ; $M_CLASS_ID_SZ ; Point past the class header
  5653                                  		;stc			; Flag that we haven't found anything yet
  5654                                  		
  5655                                  		;jmp	short $MDO76 	; *
  5656                                  ;$MEN64:
  5657                                  		;;jnc	short $MIF86	; Have we found anything yet?
  5658                                  		
  5659                                  		;jnc	short $MIF88	; *	
  5660                                  		
  5661                                  		;;clc			; No, reset carry
  5662                                  $MDO76:
  5663 00000F17 09C9                    		or	cx,cx		; Do we have any to check?
  5664                                  		;jz	short $MEN76	; No, return with CX = 0
  5665                                  		
  5666 00000F19 7417                    		jz	short $MIF91 	; *
  5667                                  		
  5668                                  		;cmp	dh,0FFh	; UTILITY_MSG_CLASS
  5669                                  		;je	short $MIF78
  5670                                  
  5671                                  		;;CMP	AX,WORD PTR ES:[DI].$M_NUM
  5672                                  		;cmp	ax,[es:di]	; Is this the message requested?
  5673                                  		;jmp	short $MEN78
  5674                                  ;$MIF78:
  5675 00000F1B 263B05                  		cmp	ax,[es:di]	; Is this the message requested?
  5676                                  ;$MEN78:
  5677                                  		;jne	short $MIF76
  5678                                  		;jmp	short $MSR76
  5679 00000F1E 7408                    		je	short $MSR77	; *
  5680                                  ;$MIF76:
  5681 00000F20 49                      		dec	cx		; No, well do we have more to check?	
  5682                                  		;jz	short $MEN76
  5683 00000F21 740F                    		jz	short $MIF91	; * ; No, return with CX = 0	
  5684 00000F23 83C704                  		add	di,4		    ; Yes, skip past msg header
  5685 00000F26 EBEF                    		jmp	short $MDO76
  5686                                  ;$MEN76:
  5687                                  		;stc
  5688                                  		;jmp	short $MIF86	; *
  5689                                  ;$MSR76:
  5690                                  ;		jc	short $MIF86
  5691                                  $MSR77: 				; *
  5692                                  		;cmp	dh,0FFh
  5693                                  		;clc
  5694                                  		;jnz	short $+2  ; $MIF87
  5695                                  ;$MIF87:
  5696                                  		;ADD	DI,WORD PTR ES:[DI].$M_TXT_PTR
  5697 00000F28 26037D02                		add	di,[es:di+2]	; Prepare ES:DI pointing to the message
  5698                                  ;$MIF86:
  5699                                  ;		jc	short $MIF91	; Did we find the message?
  5700                                  $MIF88:					; *
  5701 00000F2C 30ED                    		xor	ch,ch
  5702 00000F2E 268A0D                  		mov	cl,[es:di]	; Move size into CX
  5703 00000F31 47                      		inc	di		; Increment past length
  5704                                  $MIF91:
  5705 00000F32 C606[225D]00            		mov	byte [$M_SIZE],0 ; Reset variable	
  5706 00000F37 C3                      		retn
  5707                                  
  5708                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  5709                                  ;;
  5710                                  ;;	PROC NAME: $M_DISPLAY_MESSAGE
  5711                                  ;;
  5712                                  ;;	FUNCTION:  Will display or write entire message (with replacable parameters)
  5713                                  ;;	INPUTS:    ES:DI points to beginning of message
  5714                                  ;;		   DS:SI points to first sublist structure in chain
  5715                                  ;;		   BX contains the handle to write to (if applicable)
  5716                                  ;;		   CX contains the length of string to write (before substitutions)
  5717                                  ;;		   BP contains the count of replacables
  5718                                  ;;
  5719                                  ;;	OUTPUTS:
  5720                                  ;;	REGS USED: All
  5721                                  ;;
  5722                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  5723                                  
  5724                                  _$M_DISPLAY_MESSAGE:
  5725                                  					; Note: DS:SI -> message
  5726                                  $MDO165:
  5727 00000F38 31D2                    		xor	dx,dx		; Set size = 0
  5728 00000F3A 09C9                    		or	cx,cx
  5729 00000F3C 741F                    		jz	short $MEN167
  5730                                  
  5731                                  		;mov	ah,"%" ; 25h	; Prepare to scan for %
  5732                                  	    	;mov	al,0
  5733 00000F3E B80025                  		mov	ax,2500h
  5734                                  
  5735                                  $MDO167:				; Scan through string until %
  5736 00000F41 263825                  		cmp	[es:di],ah	; Is this character NOT a %
  5737 00000F44 750A                    		jne	short $MLL168	; No,
  5738 00000F46 26386501                		cmp	[es:di+1],ah	; Is the next character also a %
  5739 00000F4A 7404                    		je	short $MLL168	; Yes,
  5740 00000F4C 38E0                    		cmp	al,ah		; Was the character before a %
  5741 00000F4E 750D                    		jne	short $MEN167	; No, GREAT found it
  5742                                  $MLL168:
  5743 00000F50 268A05                  		mov	al,[es:di]	; Yes, (to any of the above)
  5744 00000F53 E81504                  		call	_$M_IS_IT_DBCS	; Is this character the first part of a DBCS?
  5745 00000F56 7301                    		jnc	short $MIF169	; No,
  5746                                  					; Yes,
  5747 00000F58 47                      		inc	di		; Increment past second part
  5748                                  $MIF169:
  5749 00000F59 47                      		inc	di		; Next character in string
  5750 00000F5A 42                      		inc	dx		; Size = Size + 1
  5751                                  		
  5752                                  		;dec	cx		; Decrement total size
  5753                                  		;jnz	short $MDO167		
  5754                                  		
  5755 00000F5B E2E4                    		loop	$MDO167		
  5756                                  					; Exit scan if we're at the end of the line
  5757                                  $MEN167:
  5758 00000F5D 56                      		push	si		; Save beginning of sublists
  5759 00000F5E 87CA                    		xchg	cx,dx		; Get size of message to display (tot sz in DX)
  5760 00000F60 09ED                    		or	bp,bp		; Do we have any replacables to do?
  5761 00000F62 7433                    		jz	short $MSR175	; No,
  5762                                  					; Yes,
  5763 00000F64 4D                      		dec	bp		; Decrement number of replacables
  5764                                  
  5765                                  	; Search through sublists to find applicable one
  5766                                  
  5767 00000F65 833E[285D]00            		cmp	word [$M_MSG_NUM],0 ;$M_NULL ; Is this an Extended/Parse case
  5768 00000F6A 752B                    		jne	short $MSR175	; No,	
  5769                                  $MDO175:				; Yes,
  5770                                  		;MOV	AL,$M_SL.$M_S_ID
  5771 00000F6C 8A4406                  		mov	al,[si+6] ; $M_S_ID ; Get ID byte
  5772 00000F6F 0430                    		add	al,'0'		; Convert to ASCII
  5773 00000F71 263A4501                		cmp	al,[es:di+1]	; Is this the right sublist?
  5774 00000F75 7502                    		jne	short $MIF175	; No,
  5775 00000F77 EB1E                    		jmp	short $MSR175	; Yes,
  5776                                  $MIF175:
  5777 00000F79 3C30                    		cmp	al,'0' ; $M_SPECIAL_CASE ; Does this sublist have ID = 0
  5778 00000F7B 7504                    		jne	short $MLL178	; No,
  5779                                  					; Yes,
  5780 00000F7D 09D2                    		or	dx,dx		; Are we at the end of the message?
  5781 00000F7F 7404                    		jz	short $MEN175	; No,
  5782                                  $MLL178:
  5783 00000F81 0334                    		add	si,[si]
  5784 00000F83 EBE7                    		jmp	short $MDO175
  5785                                  $MEN175:
  5786                                  		;CMP	$M_RT.$M_CLASS,UTILITY_MSG_CLASS
  5787 00000F85 803E[255D]FF            		cmp	byte [$M_CLASS],0FFh ; Is it a utility message?
  5788 00000F8A 7508                    		jne	short $MIF180	; No,
  5789                                  					; Yes,
  5790 00000F8C 42                      		inc	dx		; Remember to display CR,LF
  5791 00000F8D 42                      		inc	dx		;   at the end of the message
  5792 00000F8E 49                      		dec	cx		; Adjust message length
  5793 00000F8F 49                      		dec	cx
  5794 00000F90 4F                      		dec	di		; Adjust ending address of message
  5795 00000F91 4F                      		dec	di
  5796 00000F92 EB03                    		jmp	short $MSR175
  5797                                  $MIF180:
  5798 00000F94 BAFFFF                  		mov	dx,-1		; Set special case
  5799                                  
  5800                                  	; Prepare and display this part of message
  5801                                  $MSR175:
  5802 00000F97 57                      		push	di		; Save pointer to replace number
  5803 00000F98 29CF                    		sub	di,cx		; Determine beginning of string
  5804 00000F9A E8E402                  		call	_$M_DISPLAY_STRING ; Display string until % (or end)
  5805 00000F9D 5F                      		pop	di		; Get back pointer to replace number
  5806 00000F9E 59                      		pop	cx		; Clean up stack in case error
  5807 00000F9F 7302                    		jnc	short $MXL3
  5808                                  					; Fail if carry was set
  5809 00000FA1 EB7C                    		jmp	$MEN165
  5810                                  $MXL3:
  5811 00000FA3 51                      		push	cx
  5812 00000FA4 89D1                    		mov	cx,dx		; Get the size of the rest of the message
  5813                                  		;CMP	$M_SL.$M_S_ID,$M_SPECIAL_CASE-30H
  5814 00000FA6 807C0600                		cmp	byte [si+6],0	; Is this the %0 case?
  5815 00000FAA 740D                    		je	short $MIF187	; Yes,
  5816                                  					; No,
  5817 00000FAC 09C9                    		or	cx,cx		; Are we finished the whole message?
  5818 00000FAE 7406                    		jz	short $MIF188	; Yes
  5819                                  					; No,
  5820 00000FB0 49                      		dec	cx		; Decrement total size (%)
  5821 00000FB1 49                      		dec	cx		; Decrement total size (#)
  5822 00000FB2 47                      		inc	di		; Go past %
  5823 00000FB3 47                      		inc	di		; Go past replace number
  5824 00000FB4 EB01                    		jmp	short $MEN188	; (Note this will not leave because INC)
  5825                                  $MIF188:
  5826 00000FB6 5E                      		pop	si		; Get back pointer to beginning of SUBLISTs
  5827                                  $MEN188:				; 
  5828 00000FB7 EB10                    		jmp	short $MEN187	; (Note this will not leave because INC)
  5829                                  $MIF187:
  5830 00000FB9 09C9                    		or	cx,cx		; Are we finished the whole message?
  5831 00000FBB 7503                    		jnz	short $MIF192	; No,
  5832 00000FBD 5E                      		pop	si
  5833 00000FBE EB09                    		jmp	short $MEN187
  5834                                  $MIF192:
  5835 00000FC0 83F9FF                  		cmp	cx,-1 ; 0FFFFh	; Are we at the end of the message?
  5836 00000FC3 7502                    		jne	short $MIF194	; No,
  5837 00000FC5 31C9                    		xor	cx,cx
  5838                                  $MIF194:
  5839 00000FC7 09FF                    		or	di,di		; Turn ZF off
  5840                                  $MEN187:
  5841 00000FC9 7454                    		jz	short $MEN165
  5842 00000FCB 55                      		push	bp		; Save the replace count
  5843 00000FCC 57                      		push	di
  5844 00000FCD 06                      		push	es
  5845 00000FCE 51                      		push	cx		; Save size of the rest of the message
  5846 00000FCF 31C9                    		xor	cx,cx		; Reset CX used for character count
  5847                                  
  5848                                  	; Determine what action is required on parameter
  5849                                  
  5850                                  		;CMP	$M_RT.$M_MSG_NUM,$M_NULL
  5851 00000FD1 833E[285D]00            		cmp	word [$M_MSG_NUM],0  ; Is this an Extended/Parse case
  5852 00000FD6 752B                    		jne	short $MIF199
  5853                                  		
  5854                                  		;TEST	BYTE PTR $M_SL.$M_S_FLAG,NOT Char_Type AND $M_TYPE_MASK
  5855 00000FD8 F644070F                		test	byte [si+7],0Fh
  5856 00000FDC 7508                    		jnz	short $MIF200
  5857                                  
  5858                                  	; Character type requested
  5859                                  
  5860                                  		;LES	DI,DWORD PTR $M_SL.$M_S_VALUE
  5861 00000FDE C47C02                  		les	di,[si+2]	; Load pointer to replacing parameter
  5862 00000FE1 E84701                  		call	_$M_CHAR_REPLACE
  5863 00000FE4 EB18                    		jmp	short $MIF202
  5864                                  $MIF200:
  5865                                  		;TEST	BYTE PTR $M_SL.$M_S_FLAG,NOT Sgn_Bin_Type AND $M_TYPE_MASK
  5866 00000FE6 F644070D                		test	byte [si+7],0Dh
  5867 00000FEA 740C                    		jz	short $MLL202
  5868                                  
  5869                                  		;TEST	BYTE PTR $M_SL.$M_S_FLAG,NOT Unsgn_Bin_Type AND $M_TYPE_MASK
  5870 00000FEC F644070E                		test	byte [si+7],0Eh
  5871 00000FF0 7406                    		jz	short $MLL202
  5872                                  
  5873                                  		;TEST 	BYTE PTR $M_SL.$M_S_FLAG,NOT Bin_Hex_Type AND $M_TYPE_MASK
  5874 00000FF2 F644070C                		test	byte [si+7],0Ch
  5875 00000FF6 7506                    		jnz	short $MIF202
  5876                                  
  5877                                  	; Numeric type requested
  5878                                  $MLL202:
  5879                                  		;LES	DI,DWORD PTR $M_SL.$M_S_VALUE
  5880 00000FF8 C47C02                  		les	di,[si+2]
  5881 00000FFB E85501                  		call	_$M_BIN2ASC_REPLACE
  5882                                  		;jmp	short $+2
  5883                                  $MIF202:
  5884                                  	; With the replace information of the Stack, display the replaceable field
  5885                                  
  5886 00000FFE E85200                  		call	_$M_DISPLAY_REPLACE	; Display the replace
  5887 00001001 EB03                    		jmp	short $MEN199
  5888                                  $MIF199:
  5889                                  	; None of the above - Extended/Parse replace
  5890                                  
  5891 00001003 E82000                  		call	_$M_EXT_PAR_REPLACE
  5892                                  $MEN199:
  5893                                  	; We must go back and complete the message after the replacable parameter
  5894                                  	;   if there is any left
  5895                                  
  5896 00001006 7207                    		jc	short $MIF211 ; IF there was an error displaying then EXIT
  5897 00001008 59                      		pop	cx	; Get size of the rest of the message
  5898 00001009 07                      		pop	es	; Get address of the rest of the message
  5899 0000100A 5F                      		pop	di
  5900 0000100B 5D                      		pop	bp	; Get replacment count
  5901 0000100C 5E                      		pop	si	; ELSE get address of first sublist structure
  5902 0000100D EB06                    		jmp	short $MEN211
  5903                                  $MIF211:
  5904 0000100F 83C40A                  		add	sp,10	; Clean up stack if error
  5905 00001012 F9                      		stc
  5906 00001013 EB0A                    		jmp	short $MEN165
  5907                                  $MEN211:
  5908                                  		;CMP	$M_RT.$M_MSG_NUM,$M_NULL
  5909 00001015 833E[285D]00            		cmp	word [$M_MSG_NUM],0 ; Is this an Extended/Parse case
  5910 0000101A 7503                    		jne	short $MEN165 
  5911                                  		;jb	short $MEN165
  5912                                  				; Go back and display the rest of the message
  5913 0000101C E919FF                  		jmp	_$M_DISPLAY_MESSAGE
  5914                                  $MEN165:
  5915 0000101F C706[285D]0000          		mov	word [$M_MSG_NUM],0 ; Reset message number to null
  5916 00001025 C3                      		retn			    ; then Return
  5917                                  
  5918                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  5919                                  ;;
  5920                                  ;;	PROC NAME: $M_EXT_PAR_REPLACE
  5921                                  ;;
  5922                                  ;;	FUNCTION:
  5923                                  ;;	INPUTS:
  5924                                  ;;	OUPUTS:
  5925                                  ;;
  5926                                  ;;	REGS USED:
  5927                                  ;;
  5928                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  5929                                  
  5930                                  _$M_EXT_PAR_REPLACE:
  5931 00001026 31D2                    		xor	dx,dx		; Prepare for get binary value (HIGH)
  5932 00001028 A1[285D]                		mov	ax,[$M_MSG_NUM]	; Prepare for get binary value (LOW)
  5933 0000102B C706[2A5D]0A00          		mov	word [$M_DIVISOR],10 ; Set default divisor
  5934 00001031 E8E401                  		call	_$M_CONVERT2ASC
  5935                                  		; cx = number of characters
  5936                                  		; bx = 0
  5937                                  $MDO215:
  5938 00001034 58                      		pop	ax		; Get character in register
  5939                                  					; Move char into the buffer
  5940 00001035 8887[2C5D]              		mov	[$M_TEMP_BUF+bx],al ; "$$$$$$$"
  5941 00001039 43                      		inc	bx		; Increase buffer count
  5942 0000103A 83FB40                  		cmp	bx,64 ; $M_TEMP_BUF_SZ	; Is buffer full?
  5943 0000103D 7503                    		jne	short $MIF216
  5944                                  					; Yes,
  5945 0000103F E8CE00                  		call	_$M_FLUSH_BUF	; Flush the buffer
  5946                                  		; bx = 0
  5947                                  $MIF216:
  5948 00001042 FEC9                    		dec	cl		; Have we completed replace?
  5949 00001044 75EE                    		jnz	short $MDO215	; No, get next char from stack
  5950 00001046 B80D0A                  		mov	ax,0A0Dh ; $M_CR_LF ; Move char into the buffer	
  5951 00001049 8987[2C5D]              		mov	[$M_TEMP_BUF+bx],ax ; "$$$$$$$"
  5952 0000104D 43                      		inc	bx		; Increase buffer count
  5953 0000104E 43                      		inc	bx
  5954 0000104F E8BE00                  		call	_$M_FLUSH_BUF	; Flush the buffer
  5955 00001052 C3                      		retn
  5956                                  
  5957                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  5958                                  ;;
  5959                                  ;;	PROC NAME: $M_DISPLAY_REPLACE
  5960                                  ;;
  5961                                  ;;	FUNCTION:
  5962                                  ;;	INPUTS:
  5963                                  ;;	OUPUTS:
  5964                                  ;;
  5965                                  ;;	REGS USED:
  5966                                  ;;
  5967                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  5968                                  
  5969                                  _$M_DISPLAY_REPLACE:
  5970 00001053 31DB                    		xor	bx,bx
  5971                                  			 ; Is this the special case (convert to ASCII)
  5972                                  		;CMP	$M_SL.$M_S_ID,$M_SPECIAL_CASE-30H
  5973 00001055 807C0600                		cmp	byte [si+6],0
  5974 00001059 7511                    		jnz	short $MIF276
  5975                                  		;MOV	WORD PTR $M_RT.$M_TEMP_BUF[BX],$M_SPACE_HYP
  5976 0000105B C787[2C5D]202D          		mov	word [$M_TEMP_BUF+bx],2D20h ; Move in a " -"
  5977 00001061 43                      		inc	bx		; Increment count
  5978 00001062 43                      		inc	bx
  5979 00001063 C687[2C5D]20            		mov	byte [$M_TEMP_BUF+bx],' ' ; Move in a " "
  5980 00001068 43                      		inc	bx		; Increment count
  5981                                  				; Write out " - " to prepare for special case	
  5982 00001069 E8A400                  		call	_$M_FLUSH_BUF 
  5983                                  $MIF276:
  5984 0000106C 5D                      		pop	bp		; Remember the return address
  5985 0000106D 31DB                    		xor	bx,bx	; Use BX for buffer count
  5986 0000106F 31D2                    		xor	dx,dx	; Use DX for count of parms taken off the stack
  5987                                  		;MOV	$M_RT.$M_SIZE,CL
  5988 00001071 880E[225D]              		mov	[$M_SIZE],cl	; Save size to later clear stack
  5989                                  		;MOV	AL,BYTE PTR $M_SL.$M_S_MINW
  5990 00001075 8A4409                  		mov	al,[si+9]	; Get the minimum width
  5991 00001078 38C8                    		cmp	al,cl		; Do we need pad chars added?
  5992 0000107A 761E                    		jbe	short $MIF278	; No,
  5993                                  					; Yes,
  5994 0000107C 28C8                    		sub	al,cl		; Calculate how many pad chars are needed.
  5995 0000107E 88C6                    		mov	dh,al		; Save the number of pad characters
  5996                                  		;TEST	BYTE PTR $M_SL.$M_S_FLAG,Right_Align
  5997 00001080 F6440780                		test	byte [si+7],80h	; Was replaceable parm to be right aligned?
  5998 00001084 7414                    		jz	short $MIF278	; No,
  5999                                  $MDO280:
  6000 00001086 8A440A                  		mov	al,[si+0Ah]	; Yes,
  6001 00001089 8887[2C5D]              		mov	[$M_TEMP_BUF+bx],al ; Begin filling buffer with pad chars
  6002 0000108D 43                      		inc	bx
  6003 0000108E 83FB40                  		cmp	bx,64		; Is buffer full?
  6004 00001091 7503                    		jne	short $MIF281
  6005 00001093 E87A00                  		call	_$M_FLUSH_BUF	; Flush the buffer
  6006                                  $MIF281:
  6007 00001096 FECE                    		dec	dh		; Have we filled with enough pad chars?
  6008 00001098 75EC                    		jnz	short $MDO280	; No, next pad character
  6009                                  $MIF278:
  6010                                  		;CMP	BYTE PTR $M_SL.$M_S_MAXW,$M_UNLIM_W
  6011 0000109A 807C0800                		cmp	byte [si+8],0	; Is maximum width unlimited?
  6012 0000109E 740D                    		jz	short $MIF286	; Yes,
  6013 000010A0 384C08                  		cmp	[si+8],cl	; Will we exceed maximum width?
  6014 000010A3 7308                    		jnb	short $MIF286	; No,
  6015                                  					; Yes,
  6016 000010A5 2A4C08                  		sub	cl,[si+8]	; Calculate how many extra chars	
  6017 000010A8 88CA                    		mov	dl,cl		; Remember how many chars to pop off
  6018                                  		;MOV	CL,BYTE PTR $M_SL.$M_S_MAXW
  6019 000010AA 8A4C08                  		mov	cl,[si+8]	; Set new string length
  6020                                  $MIF286:
  6021 000010AD 09C9                    		or	cx, cx
  6022 000010AF 7424                    		jz	short $MIF290
  6023                                  $MDO291:				; Begin filling buffer with string
  6024                                  		;TEST	BYTE PTR $M_SL.$M_S_FLAG,NOT Char_Type AND $M_TYPE_MASK
  6025 000010B1 F644070F                		test	byte [si+7],0Fh
  6026 000010B5 750C                    		jnz	short $MIF292
  6027                                  		;TEST	$M_SL.$M_S_FLAG,Char_field_ASCIIZ AND $M_SIZE_MASK
  6028 000010B7 F6440710                		test	byte [si+7],10h	; Is this replace a ASCIIZ string?
  6029 000010BB 7406                    		jz	short $MIF292
  6030                                  					; Yes,
  6031 000010BD 268A05                  		mov	al,[es:di]	; Get first character from string
  6032 000010C0 47                      		inc	di		; Next character in string
  6033 000010C1 EB01                    		jmp	short $MEN292
  6034                                  $MIF292:
  6035 000010C3 58                      		pop	ax		; Get character in register
  6036                                  $MEN292:
  6037 000010C4 8887[2C5D]              		mov	[$M_TEMP_BUF+bx],al ; Move char into the buffer
  6038 000010C8 43                      		inc	bx		; Increase buffer count
  6039 000010C9 83FB40                  		cmp	bx,64		; Is buffer full?
  6040 000010CC 7503                    		jnz	short $MIF295
  6041 000010CE E83F00                  		call	_$M_FLUSH_BUF	; Flush the buffer
  6042                                  $MIF295:
  6043 000010D1 FEC9                    		dec	cl		; Have we completed replace?
  6044 000010D3 75DC                    		jnz	short $MDO291
  6045                                  $MIF290:
  6046                                  		;TEST	BYTE PTR $M_SL.$M_S_FLAG,Right_Align
  6047 000010D5 F6440780                		test	byte [si+7],80h ; Was replaceable parm to be left aligned?
  6048 000010D9 7518                    		jnz	short $MIF299	; No, (right aligned)
  6049                                  					; Yes,
  6050 000010DB 08F6                    		or	dh,dh		; Do we need pad chars added?	
  6051 000010DD 7414                    		jz	short $MIF299
  6052                                  $MDO301:
  6053                                  		;MOV	AL,BYTE PTR $M_SL.$M_S_PAD
  6054 000010DF 8A440A                  		mov	al,[si+0Ah]	; Begin filling buffer with pad chars
  6055 000010E2 8887[2C5D]              		mov	[$M_TEMP_BUF+bx],al ; Move in a pad char
  6056 000010E6 43                      		inc	bx
  6057 000010E7 83FB40                  		cmp	bx,64		; Is buffer full?
  6058 000010EA 7503                    		jnz	short $MIF302
  6059 000010EC E82100                  		call	_$M_FLUSH_BUF	; Flush the buffer
  6060                                  $MIF302:
  6061 000010EF FECE                    		dec	dh		; Have we filled with enough pad chars?
  6062 000010F1 75EC                    		jnz	short $MDO301
  6063                                  $MIF299:
  6064                                  		;TEST	BYTE PTR $M_SL.$M_S_FLAG,NOT Char_Type AND $M_TYPE_MASK
  6065 000010F3 F644070F                		test	byte [si+7],0Fh
  6066 000010F7 7506                    		jnz	short $MIF307
  6067                                  		;TEST	$M_SL.$M_S_FLAG,Char_field_ASCIIZ AND $M_SIZE_MASK	
  6068 000010F9 F6440710                		test	byte [si+7],10h	; Is this replace a ASCIIZ string?
  6069                                  		;jz	short $MIF307
  6070                                  		;jmp	short $MEN307
  6071 000010FD 750C                    		jnz	short $MEN307
  6072                                  $MIF307:
  6073 000010FF 08D2                    		or	dl,dl
  6074 00001101 7408                    		jz	short $MEN307
  6075                                  $MDO310:				; Clean Up stack using spare variable
  6076 00001103 8F06[265D]              		pop	word [$M_RETURN_ADDR]
  6077 00001107 FECA                    		dec	dl		; Are we done?
  6078 00001109 75F8                    		jnz	short $MDO310
  6079                                  $MEN307:
  6080 0000110B E80200                  		call	_$M_FLUSH_BUF	; Flush the buffer for the final time
  6081 0000110E 55                      		push	bp		; Restore the return address
  6082 0000110F C3                      		retn
  6083                                  
  6084                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  6085                                  ;;
  6086                                  ;;	PROC NAME: $M_FLUSH_BUFFER
  6087                                  ;;
  6088                                  ;;	FUNCTION: Display the contents of the temporary buffer
  6089                                  ;;	INPUTS: DI contains the number of bytes to display
  6090                                  ;;	OUTPUTS: BX reset to zero
  6091                                  ;;
  6092                                  ;;	REGS USED:
  6093                                  ;;
  6094                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  6095                                  
  6096                                  _$M_FLUSH_BUF:
  6097 00001110 51                      		push	cx		; Save changed regs
  6098 00001111 06                      		push	es
  6099 00001112 57                      		push	di
  6100 00001113 1E                      		push	ds
  6101 00001114 07                      		pop	es		; Set ES pointing to buffer
  6102 00001115 89D9                    		mov	cx,bx		; Set number of bytes to display
  6103 00001117 31DB                    		xor	bx,bx		; Reset buffer counter
  6104                                  		;LEA	DI,$M_RT.$M_TEMP_BUF
  6105 00001119 8D3E[2C5D]              		lea	di,[$M_TEMP_BUF] ; Reset buffer location pointer
  6106 0000111D E86101                  		call	_$M_DISPLAY_STRING ; Display the buffer
  6107 00001120 7204                    		jc	short $MIF314	; Error?
  6108 00001122 5F                      		pop	di		; No, Restore changed regs
  6109 00001123 07                      		pop	es
  6110 00001124 59                      		pop	cx
  6111 00001125 C3                      		retn
  6112                                  $MIF314:				; Yes,
  6113 00001126 83C406                  		add	sp,6		; Fix stack
  6114 00001129 F9                      		stc			; Set cf to indicate Error
  6115 0000112A C3                      		retn			; Return
  6116                                  
  6117                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  6118                                  ;;
  6119                                  ;;	PROC NAME: $M_CHAR_REPLACE
  6120                                  ;;
  6121                                  ;;	FUNCTION: Will prepare a single char or ASCIIZ string for replace
  6122                                  ;;	INPUTS: DS:SI points at corresponding SUBLIST
  6123                                  ;;		ES:DI contains the VALUE from SUBLIST
  6124                                  ;;	OUTPUTS: CX contains number of characters on stack
  6125                                  ;;		 Top of stack  --> Last character
  6126                                  ;;					. . .
  6127                                  ;;		 Bot of stack  --> First character
  6128                                  ;;
  6129                                  ;;	OTHER REGS Revised: AX
  6130                                  ;;
  6131                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  6132                                  
  6133                                  _$M_CHAR_REPLACE:
  6134 0000112B 5D                      		pop	bp		; Save return address
  6135                                  		;TEST	$M_SL.$M_S_FLAG,NOT Char_Field_Char AND $M_SIZE_MASK
  6136 0000112C F6440730                		test	byte [si+7],30h ; Was Character specified?	
  6137 00001130 7512                    		jnz	short $MDO321
  6138 00001132 268A05                  		mov	al,[es:di]	; Get the character
  6139 00001135 50                      		push	ax		; Put it on the stack
  6140 00001136 41                      		inc	cx		; Increase the count
  6141 00001137 E83102                  		call	_$M_IS_IT_DBCS	; Is this the first byte of a DB character
  6142 0000113A 7306                    		jnc	short $MIF318	; No,
  6143                                  					; Yes,
  6144 0000113C 268A4501                		mov	al,[es:di+1]	; Get the next character
  6145 00001140 50                      		push	ax		; Put it on the stack
  6146 00001141 F8                      		clc
  6147                                  $MIF318:				; No, it was an ASCIIZ string
  6148 00001142 EB0D                    		jmp	short $MEN317
  6149                                  $MDO321:
  6150 00001144 268A05                  		mov	al,[es:di]	; Get the character
  6151 00001147 08C0                    		or	al,al		; Is it the NULL?
  6152 00001149 7404                    		jz	short $MEN321
  6153 0000114B 47                      		inc	di		; Next character
  6154 0000114C 41                      		inc	cx		; Increment the count
  6155 0000114D EBF5                    		jmp	short $MDO321
  6156                                  $MEN321:
  6157 0000114F 29CF                    		sub	di,cx		; Set DI at the beginning of the string
  6158                                  $MEN317:
  6159 00001151 55                      		push	bp		; Restore return address
  6160 00001152 C3                      		retn
  6161                                  
  6162                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  6163                                  ;;
  6164                                  ;;	PROC NAME: $M_BIN2ASC_REPLACE
  6165                                  ;;
  6166                                  ;;	FUNCTION: Convert a signed or unsigned binary number to an ASCII string
  6167                                  ;;		  and prepare to display
  6168                                  ;;	INPUTS: DS:SI points at corresponding SUBLIST
  6169                                  ;;		ES:DI contains the VALUE from SUBLIST
  6170                                  ;;	OUTPUTS: CX contains number of characters on stack
  6171                                  ;;		 Top of stack  --> Last character
  6172                                  ;;					. . .
  6173                                  ;;		 Bot of stack  --> First character
  6174                                  ;;	OTHER REGS Revised: BX,DX,AX
  6175                                  ;;
  6176                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  6177                                  
  6178                                  _$M_BIN2ASC_REPLACE:
  6179 00001153 5D                      		pop	bp		; Save return address
  6180 00001154 31C0                    		xor	ax,ax		; Prepare for get binary value (LOW)
  6181                                  		;xor	dx,dx
  6182 00001156 99                      		cwd			; Prepare for get binary value (HIGH)
  6183                                  		;MOV	$M_RT.$M_DIVISOR,$M_BASE16
  6184 00001157 C706[2A5D]1000          		mov	word [$M_DIVISOR],16 ; Set default divisor
  6185 0000115D 31DB                    		xor	bx,bx		; Use BX as the NEG flag (if applicable)
  6186                                  		;TEST	$M_SL.$M_S_FLAG,NOT $M_BYTE AND $M_SIZE_MASK
  6187 0000115F F6440720                		test	byte [si+7],20h ; Was BYTE specified?
  6188 00001163 7524                    		jnz	short $MIF325	; No,
  6189                                  					; Yes,
  6190 00001165 268A05                  		mov	al,[es:di]	; Setup byte in AL
  6191                                  		;TEST	$M_SL.$M_S_FLAG,NOT Sgn_Bin_Type AND $M_TYPE_MASK
  6192 00001168 F644070D                		test	byte [si+7],0Dh ; Was Signed binary specified?
  6193 0000116C 750D                    		jnz	short $MIF326	; No,
  6194                                  					; Yes,
  6195 0000116E A880                    		test	al,80h		; Is this number negative?
  6196 00001170 7403                    		jz	short $MIF327	; No,
  6197                                  					; Yes,	
  6198 00001172 43                      		inc	bx		; Remember that it was negative		
  6199 00001173 247F                    		and	al,7Fh		; Make it positive
  6200                                  $MIF327:
  6201                                  		;MOV	$M_RT.$M_DIVISOR,$M_BASE10
  6202 00001175 C706[2A5D]0A00          		mov	word [$M_DIVISOR],10
  6203                                  $MIF326:
  6204                                  		;TEST	$M_SL.$M_S_FLAG,NOT Unsgn_Bin_Type AND $M_TYPE_MASK
  6205 0000117B F644070E                		test	byte [si+7],0Eh	; Was Unsigned binary specified?
  6206 0000117F 7506                    		jnz	short $MIF330	; No,
  6207 00001181 C706[2A5D]0A00          		mov	word [$M_DIVISOR],10 ; Yes,
  6208                                  $MIF330:
  6209 00001187 EB54                    		jmp	short $MIF345
  6210                                  $MIF325:
  6211                                  		;TEST	$M_SL.$M_S_FLAG,NOT $M_WORD AND $M_SIZE_MASK
  6212 00001189 F6440710                		test	byte [si+7],10h	; Was WORD specified?
  6213 0000118D 7526                    		jnz	short $MIF333	; No,
  6214                                  					; Yes,
  6215 0000118F 268B05                  		mov	ax,[es:di]	; Setup byte in AX
  6216                                  		;TEST	$M_SL.$M_S_FLAG,NOT Sgn_Bin_Type AND $M_TYPE_MASK
  6217 00001192 F644070D                		test	byte [si+7],0Dh	; Was Signed binary specified?
  6218 00001196 750F                    		jnz	short $MIF334	; No,
  6219                                  					; Yes,
  6220 00001198 F6C480                  		test	ah,80h		; Is this number negative?
  6221 0000119B 7404                    		jz	short $MIF335
  6222 0000119D 43                      		inc	bx		; Remember that it was negative
  6223 0000119E 80E47F                  		and	ah,7Fh		; Make it positive
  6224                                  $MIF335:
  6225 000011A1 C706[2A5D]0A00          		mov	word [$M_DIVISOR],10
  6226                                  $MIF334:
  6227                                  		;TEST	$M_SL.$M_S_FLAG,NOT Unsgn_Bin_Type AND $M_TYPE_MASK
  6228 000011A7 F644070E                		test	byte [si+7],0Eh	; Was Unsigned binary specified?
  6229                                  		;jnz	short $MIF338	; No,
  6230 000011AB 7530                    		jnz	short $MIF345	
  6231                                  				; Yes,
  6232                                  		; MOV	$M_RT.$M_DIVISOR,$M_BASE10
  6233 000011AD C706[2A5D]0A00          		mov	word [$M_DIVISOR],10
  6234                                  $MIF338:
  6235 000011B3 EB28                    		jmp	short $MIF345
  6236                                  $MIF333:
  6237 000011B5 268B05                  		mov	ax,[es:di]	; Setup Double word in DX:AX
  6238 000011B8 268B5502                		mov	dx,[es:di+2]
  6239                                  		;TEST	$M_SL.$M_S_FLAG,NOT Sgn_Bin_Type AND $M_TYPE_MASK
  6240 000011BC F644070D                		test	byte [si+7],0Dh ; Was Signed binary specified?
  6241 000011C0 750F                    		jnz	short $MIF341	; No,
  6242                                  					; Yes,
  6243 000011C2 F6C680                  		test	dh,80h		; Is this number negative?
  6244 000011C5 7404                    		jz	short $MIF342	; No,
  6245                                  					; yes,
  6246 000011C7 43                      		inc	bx		; Remember that it was negative		
  6247 000011C8 80E67F                  		and	dh,7Fh		; Make it positive
  6248                                  $MIF342:
  6249 000011CB C706[2A5D]0A00          		mov	word [$M_DIVISOR],10
  6250                                  $MIF341:
  6251                                  		;TEST	$M_SL.$M_S_FLAG,NOT Unsgn_Bin_Type AND $M_TYPE_MASK
  6252 000011D1 F644070E                		test	byte [si+7],0Eh ; Was Unsigned binary specified?
  6253 000011D5 7506                    		jnz	short $MIF345	; No,
  6254                                  					; Yes,
  6255 000011D7 C706[2A5D]0A00          		mov	word [$M_DIVISOR],10
  6256                                  $MIF345:
  6257                                  		; Thousand separator bit ? 
  6258                                  		; (This code portion is not existing in MSDOS 6.0 files.)
  6259 000011DD F6440740                		test	byte [si+7],40h ; Reserved bit (for MSDOS 6.0 sublist)
  6260 000011E1 7428                    		jz	short $MIF346
  6261 000011E3 50                      		push	ax
  6262 000011E4 52                      		push	dx
  6263 000011E5 B438                    		mov	ah,38h
  6264 000011E7 30C0                    		xor	al,al
  6265 000011E9 8D16[2C5D]              		lea	dx,[$M_TEMP_BUF]
  6266 000011ED CD21                    		int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
  6267                                  				; get current-country info ; (*)
  6268                                  				; DS:DX	-> buffer for returned info
  6269 000011EF 7305                    		jnc	short $MEN325
  6270 000011F1 C606[335D]2C            		mov	byte [$M_THOU_SEPARA],',' ; [$M_TEMP_BUF+7]
  6271                                  $MEN325:
  6272                                  			;DOS Country Info (DOS 3.0+) (*)
  6273                                  			
  6274                                  		      ;Offset  Size  Description
  6275                                  			;00    word  Date and time format
  6276                                  			;	0 = month day year, hh:mm:ss (USA)
  6277                                  			;	1 = day month year, hh:mm:ss (Europe)
  6278                                  			;	2 = year month day, hh:mm:ss (Japan)
  6279                                  			;02  5 bytes ASCIIZ currency symbol
  6280                                  			;07  2 bytes ASCIIZ thousands separator
  6281                                  			;09  2 bytes ASCIIZ decimal separator
  6282                                  			;0B  2 bytes ASCIIZ date separator
  6283                                  			;0D  2 bytes ASCIIZ time separator
  6284                                  			;0F    byte  Currency symbol format
  6285                                  			;	0 = symbol leads, without space
  6286                                  			;	1 = symbol follows, without space
  6287                                  			;	2 = symbol leads, one space
  6288                                  			;	3 = symbol follows, one space
  6289                                  			;	4 = symbol replace decimal separator
  6290                                  			;10    byte  Number of digits after decimal
  6291                                  			;11    byte  Time format
  6292                                  			;	Bit 0 = 0 12 hour clock
  6293                                  			;	      = 1 24 hour clock
  6294                                  			;12    dword Case map call address
  6295                                  			;16  2 bytes ASCIIZ data list separator
  6296                                  			;18  10 bytes Reserved
  6297                                  
  6298 000011F6 8A440A                  		mov	al,[si+10] ; get sublist pad_char
  6299 000011F9 89C7                    		mov	di,ax	; save pad_char
  6300 000011FB 5A                      		pop	dx
  6301 000011FC 58                      		pop	ax
  6302 000011FD C6440A2C                		mov	byte [si+10],',' ; set pad_char to ',' for using thous. sep.
  6303 00001201 E81400                  		call	_$M_CONVERT2ASC
  6304 00001204 89F8                    		mov	ax,di	; restore pad_char 
  6305 00001206 88440A                  		mov	[si+10],al
  6306 00001209 EB03                    		jmp	short $MIF347
  6307                                  $MIF346:			; Default number displaying (without thous. sep.)
  6308 0000120B E80A00                  		call	_$M_CONVERT2ASC
  6309                                  $MIF347:
  6310 0000120E 09DB                    		or	bx,bx		; Was number negative?
  6311 00001210 7404                    		jz	short $MIF349	; No,
  6312                                  					; Yes,
  6313 00001212 BA2D00                  		mov	dx,'-'		; Put "-" on the stack with the number
  6314 00001215 52                      		push	dx
  6315                                  $MIF349:
  6316 00001216 55                      		push	bp		; Restore return address
  6317 00001217 C3                      		retn
  6318                                  
  6319                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  6320                                  ;;
  6321                                  ;;	PROC NAME: $M_CONVERT2ASC
  6322                                  ;;
  6323                                  ;;	FUNCTION: Convert a binary number to a ASCII string
  6324                                  ;;	INPUTS: DX:AX contains the number to be converted
  6325                                  ;;		$M_RT_DIVISOR contains the divisor
  6326                                  ;;	OUTPUTS: CX contains the number of characters
  6327                                  ;;		Top of stack  --> Last character
  6328                                  ;;				     . . .
  6329                                  ;;		Bot of stack  --> First character
  6330                                  ;;	REGS USED:
  6331                                  ;;
  6332                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  6333                                  
  6334                                  		; CX = 0
  6335                                  _$M_CONVERT2ASC:
  6336 00001218 8F06[265D]              		pop	word [$M_RETURN_ADDR]	; Save Return Address
  6337 0000121C 31DB                    		xor	bx,bx		; Use BX as a swapping register
  6338 0000121E 93                      		xchg	ax,bx		; Initialize - Low Word in BX
  6339 0000121F 92                      		xchg	ax,dx		;            - High Word in AX
  6340                                  $MDO145:				; DO UNTIL Low Word becomes zero
  6341 00001220 F736[2A5D]              		div	word [$M_DIVISOR] ; Divide High Word by divisor
  6342 00001224 93                      		xchg	ax,bx		; Setup to divide Low Word using remainder
  6343                                  					;   and save reduced High Word in BX
  6344 00001225 F736[2A5D]              		div	word [$M_DIVISOR] ; Divide Low Word by divisor
  6345 00001229 83FA09                  		cmp	dx,9		; Make a digit of the remainder	
  6346 0000122C 7605                    		jbe	short $MIF146	; IF 10 to 15,
  6347 0000122E 80C237                  		add	dl,37h ; '7'	;    Make A to F ASCII
  6348 00001231 EB03                    		jmp	short $MEN146
  6349                                  $MIF146:				; IF 0 to 9,
  6350 00001233 80C230                  		add	dl,'0'		;    Make 0 to 9 ASCII
  6351                                  $MEN146:
  6352 00001236 52                      		push	dx		; Save the digit on the stack
  6353 00001237 41                      		inc	cx		; Count that digit
  6354 00001238 09C0                    		or	ax,ax		; Are we done?
  6355 0000123A 7504                    		jnz	short $MLL149
  6356 0000123C 09DB                    		or	bx,bx		; AX and BX must be ZERO!!
  6357 0000123E 7439                    		jz	short $MEN145
  6358                                  $MLL149:
  6359 00001240 83F903                  		cmp	cx,3		; Are we at the first thousands mark
  6360 00001243 750D                    		jne	short $MIF150	; No,
  6361                                  					; Yes,
  6362                                  		;CMP	$M_SL.$M_S_PAD,$M_COMMA
  6363 00001245 807C0A2C                		cmp	byte [si+10],',' ; Is the pad character a comma?
  6364 00001249 7505                    		jne	short $MIF151	; No,
  6365                                  					; Yes,
  6366 0000124B FF36[335D]              		push	word [$M_THOU_SEPARA] ; Insert a thousand separator
  6367 0000124F 41                      		inc	cx
  6368                                  $MIF151:
  6369 00001250 EB22                    		jmp	short $MEN150
  6370                                  $MIF150:
  6371 00001252 83F907                  		cmp	cx,7		; Are we at the second thousands mark
  6372 00001255 750D                    		jne	short $MIF154
  6373                                  					; Yes,
  6374 00001257 807C0A2C                		cmp	byte [si+10],','  ; Is the pad character a comma?
  6375 0000125B 7505                    		jne	short $MIF155
  6376                                  					; Yes,
  6377 0000125D FF36[335D]              		push	word [$M_THOU_SEPARA] ; Insert a thousand separator
  6378 00001261 41                      		inc	cx
  6379                                  $MIF155:
  6380 00001262 EB10                    		jmp	short $MEN150
  6381                                  $MIF154:
  6382 00001264 83F90B                  		cmp	cx,11		; Are we at the third thousands mark
  6383 00001267 750B                    		jne	short $MEN150	; No,
  6384                                  					; Yes,
  6385 00001269 807C0A2C                		cmp	byte [si+10],',' ; Is the pad character a comma?
  6386 0000126D 7505                    		jnz	short $MEN150	; No,
  6387                                  					; Yes,
  6388 0000126F FF36[335D]              		push	word [$M_THOU_SEPARA] ; Insert a thousand separator
  6389 00001273 41                      		inc	cx
  6390                                  $MEN150:
  6391 00001274 93                      		xchg	ax,bx		; Setup to divide the reduced High Word
  6392                                  					;   and Revised Low Word
  6393 00001275 31D2                    		xor	dx,dx		; Reset remainder
  6394 00001277 EBA7                    		jmp	short $MDO145	; NEXT
  6395                                  $MEN145:
  6396 00001279 31C0                    		xor	ax,ax		; Reset remainder
  6397                                  		;xor	dx,dx
  6398 0000127B 99                      		cwd			; Reset remainder
  6399 0000127C FF36[265D]              		push	word [$M_RETURN_ADDR] ;	Restore Return Address
  6400 00001280 C3                      		retn			; Return
  6401                                  
  6402                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  6403                                  ; 
  6404                                  ;;
  6405                                  ;;	PROC NAME: $M_DISPLAY_STRING
  6406                                  ;;
  6407                                  ;;	FUNCTION:  Will display or write string
  6408                                  ;;	INPUTS:    ES:DI points to beginning of message
  6409                                  ;;		   CX contains the length of string to write (if applicable)
  6410                                  ;;	OUTPUTS:   None
  6411                                  ;;	REGS Revised: None
  6412                                  ;;
  6413                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  6414                                  
  6415                                  _$M_DISPLAY_STRING:
  6416 00001281 50                      		push	ax
  6417 00001282 53                      		push	bx
  6418 00001283 52                      		push	dx
  6419                                  		;MOV	BX,$M_RT.$M_HANDLE
  6420 00001284 8B1E[205D]              		mov	bx,[$M_HANDLE]	; Retrieve handle
  6421 00001288 83FBFF                  		cmp	bx,0FFFFh ; -1	; Was there a handle specified?
  6422                                  		;jne	short $MIF107
  6423 0000128B 741C                    		je	short $MIF107 ; * ; No, display $ terminated string
  6424                                  		;call	_$M_DISPLAY_$_STRING
  6425                                  		;;jmp	short $MEN107
  6426                                  ;$MIF107:
  6427 0000128D E86E00                  		call	_$M_DISPLAY_H_STRING ; Yes, display string to handle	
  6428 00001290 730B                    		jnc	short $MIF110 ; *  ; Was there an error?
  6429                                  $MEN107:
  6430                                  		;jnc	short $MIF110
  6431                                  					; Yes,
  6432 00001292 B459                    		mov	ah,59h		; Get extended error
  6433 00001294 BB0000                  		mov	bx,0
  6434 00001297 CD21                    		int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
  6435                                  				; BX = version code (0000h for DOS 3.x)
  6436 00001299 30E4                    		xor	ah,ah		; Clear AH
  6437 0000129B EB07                    		jmp	short $MEN111 ; *
  6438                                  		;add	sp,6
  6439                                  		;stc
  6440                                  		;;jmp	short $MIF112
  6441                                  		;retn ; *
  6442                                  ;$MIF110:
  6443                                  		;cmp	bx,0FFFFh ; -1
  6444                                  		;je	short $MIF112
  6445                                  $MIF110: ; *
  6446                                  		; BX <> -1
  6447 0000129D 39C8                    		cmp	ax,cx		; Was it ALL written?
  6448 0000129F 740B                    		je	short $MIF112	; Yes
  6449                                  					; No,
  6450 000012A1 E8A800                  		call	_$M_GET_EXT_ERR_39 ; Set Extended error
  6451                                  $MEN111: ; *		
  6452 000012A4 83C406                  		add	sp,6		; Clean up stack
  6453 000012A7 F9                      		stc			; Flag that there was an error
  6454 000012A8 C3                      		retn ; *
  6455                                  
  6456                                  $MIF107: ; *
  6457                                  		; BX = -1	; Display $ terminated string
  6458 000012A9 E80400                  		call	_$M_DISPLAY_$_STRING ; *
  6459                                  		;jc	short $MEN107	     ; *	
  6460                                  $MIF112:
  6461                                  		;jc	short $MIF117
  6462 000012AC 5A                      		pop	dx		; Restore regs
  6463 000012AD 5B                      		pop	bx
  6464 000012AE 58                      		pop	ax
  6465                                  $MIF117:
  6466 000012AF C3                      		retn
  6467                                  
  6468                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  6469                                  ;;
  6470                                  ;;	PROC NAME: $M_DISPLAY_$_STRING
  6471                                  ;;
  6472                                  ;;	FUNCTION:  Will display a $ terminated string
  6473                                  ;;	INPUTS:    ES:DI points to beginning of message text (not the length)
  6474                                  ;;	OUPUTS:    None
  6475                                  ;;	REGS USED: AX,DX
  6476                                  ;;
  6477                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  6478                                  
  6479                                  _$M_DISPLAY_$_STRING:
  6480 000012B0 1E                      		push	ds
  6481 000012B1 06                      		push	es
  6482 000012B2 1F                      		pop	ds
  6483                                  
  6484 000012B3 83F901                  		cmp	cx,1		; Is this a single character?
  6485 000012B6 751B                    		jne	short $MIF119	; No,
  6486                                  
  6487 000012B8 B402                    		mov	ah,2
  6488 000012BA 268A15                  		mov	dl,[es:di]
  6489 000012BD CD21                    		int	21h	; DOS -	DISPLAY	OUTPUT
  6490                                  				; DL = character to send to standard output
  6491 000012BF 1F                      		pop	ds
  6492 000012C0 88D0                    		mov	al,dl
  6493 000012C2 E8A600                  		call	_$M_IS_IT_DBCS
  6494 000012C5 1E                      		push	ds
  6495 000012C6 06                      		push	es
  6496 000012C7 1F                      		pop	ds
  6497                                  		;jnc	short $MIF120
  6498 000012C8 7317                    		jnc	short $MEN119 ; *
  6499 000012CA 268A5501                		mov	dl,[es:di+1]
  6500 000012CE CD21                    		int	21h		; DOS -
  6501 000012D0 F8                      		clc
  6502                                  ;$MIF120:
  6503 000012D1 EB0E                    		jmp	short $MEN119
  6504                                  $MIF119:
  6505                                  		;mov	ah,2		; DOS Function to display CHARACTER
  6506                                  ;$MDO123:
  6507 000012D3 09C9                    		or	cx,cx		; Are there any left to display?
  6508 000012D5 740A                    		jz	short $MEN119	; No, (CF=0 ; *) 
  6509                                  				
  6510 000012D7 B402                    		mov	ah,2 ; *
  6511                                  					; Yes,	
  6512                                  $MDO123: ; *
  6513 000012D9 268A15                  		mov	dl,[es:di] 	; Get the character
  6514 000012DC CD21                    		int	21h	; DOS -	DISPLAY	OUTPUT
  6515                                  				; DL = character to send to standard output
  6516 000012DE 47                      		inc	di		; Set pointer to next character
  6517 000012DF E2F8                    		loop	$MDO123
  6518                                  $MEN119:
  6519                                  		;clc	; *
  6520 000012E1 1F                      		pop	ds
  6521                                  		; cf = 0
  6522 000012E2 C3                      		retn
  6523                                  
  6524                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  6525                                  ;
  6526                                  ; Scan_ctrlZ : This routine looks through the string to be printed and 
  6527                                  ; truncates it at the Ctrl-Z if any present.
  6528                                  ;
  6529                                  ;	ENTRY:	ds:dx = String to be displayed
  6530                                  ;		cx = number of chars to be displayed
  6531                                  ;
  6532                                  ;	EXIT:	cx = number of chars to be displayed
  6533                                  ;
  6534                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  6535                                  
  6536                                  Scan_CtrlZ:
  6537 000012E3 57                      		push	di
  6538 000012E4 50                      		push	ax
  6539 000012E5 06                      		push	es
  6540 000012E6 53                      		push	bx
  6541 000012E7 89D7                    		mov	di,dx
  6542 000012E9 1E                      		push	ds
  6543 000012EA 07                      		pop	es		; es:di points at string
  6544 000012EB 89CB                    		mov	bx,cx		; save current count
  6545 000012ED B01A                    		mov	al,1Ah
  6546 000012EF FC                      		cld
  6547 000012F0 F2AE                    		repne scasb		; find first Ctrl-Z
  6548 000012F2 7503                    		jnz	short noCtrlZ	; no CtrlZ found in string
  6549 000012F4 29CB                    		sub	bx,cx		; bx = new count to display
  6550 000012F6 4B                      		dec	bx
  6551                                  noCtrlZ:
  6552 000012F7 89D9                    		mov	cx,bx		; cx = actual display count
  6553 000012F9 5B                      		pop	bx
  6554 000012FA 07                      		pop	es
  6555 000012FB 58                      		pop	ax
  6556 000012FC 5F                      		pop	di
  6557 000012FD C3                      		retn
  6558                                  
  6559                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  6560                                  ;;
  6561                                  ;;	PROC NAME: $M_DISPLAY_H_STRING
  6562                                  ;;
  6563                                  ;;	FUNCTION:  Will display a string to a specified handle
  6564                                  ;;	INPUTS:    ES:DI points to beginning of message
  6565                                  ;;		   CX contains the number of bytes to write
  6566                                  ;;		   BX contains the handle to write to
  6567                                  ;;	OUPUTS:    None
  6568                                  ;;	REGS USED: AX,DX
  6569                                  ;;
  6570                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  6571                                  
  6572                                  _$M_DISPLAY_H_STRING:
  6573 000012FE 31C0                    		xor	ax,ax		; Set number of bytes written to 0
  6574 00001300 09C9                    		or	cx,cx		; For performance, don't write if not necessary
  6575 00001302 7447                    		jz	short $MIF127	; Any chars to write?
  6576 00001304 1E                      		push	ds		; Yes,
  6577 00001305 06                      		push	es
  6578 00001306 1F                      		pop	ds		; Set DS to segment of message text
  6579                                  					; DOS function to write to a handle
  6580 00001307 B440                    		mov	ah,40h ; DOS_WRITE_HANDLE
  6581 00001309 89FA                    		mov	dx,di		; Pointer to data to write
  6582 0000130B 83F901                  		cmp	cx,1		; Is this a single character?
  6583 0000130E 7522                    		jne	short $MIF128
  6584                                  					; Yes,
  6585 00001310 CD21                    		int	21h	; DOS -	2+ - WRITE TO FILE WITH	HANDLE
  6586                                  				; BX = file handle, CX = number	of bytes to write,
  6587                                  				; DS:DX -> buffer
  6588 00001312 1F                      		pop	ds		; Restore DS
  6589 00001313 50                      		push	ax
  6590 00001314 268A05                  		mov	al,[es:di]	; Get the character
  6591 00001317 E85100                  		call	_$M_IS_IT_DBCS	; Is this the first byte of a DB character
  6592 0000131A 58                      		pop	ax
  6593 0000131B 1E                      		push	ds
  6594 0000131C 06                      		push	es		; Set DS to segment of message text
  6595 0000131D 1F                      		pop	ds
  6596 0000131E 7306                    		jnc	short $MIF129
  6597 00001320 F8                      		clc			; Clear the DBCS indicator		
  6598 00001321 B440                    		mov	ah,40h		; DOS function to write to a handle
  6599 00001323 42                      		inc	dx		; Point to next character
  6600 00001324 CD21                    		int	21h	; DOS -	2+ - WRITE TO FILE WITH	HANDLE
  6601                                  				; BX = file handle, CX = number	of bytes to write, 
  6602                                  				; DS:DX -> buffer
  6603                                  $MIF129:
  6604                                  
  6605                                  ; If the single char happened to be a Ctrl-Z, the dos write would return
  6606                                  ; 0 chars written making the caller think there was an error writing. To 
  6607                                  ; avoid this, we check if the single char was a Ctrl-Z and if so, return that
  6608                                  ; the char was written, thus fooling the caller.
  6609                                  
  6610 00001326 9C                      		pushf			 ; save flags
  6611 00001327 26803D1A                		cmp	byte [es:di],1Ah ; is char a Ctrl-Z?
  6612 0000132B 7502                    		jne	short $MEN129	 ; no, continue
  6613 0000132D 89C8                    		mov	ax,cx		 ; yes, fake as if it was written
  6614                                  $MEN129:
  6615                                  		;jmp	short _$M_Popf
  6616 0000132F 9D                      		popf	; *		 ; restore flags
  6617 00001330 EB18                    		jmp	short $MEN128
  6618                                  ;_$M_Mret:
  6619                                  ;		iret
  6620                                  ;_$M_Popf:
  6621                                  		;push	cs
  6622                                  		;call	_$M_Mret
  6623                                  		;jmp	short $MEN128
  6624                                  $MIF128:
  6625                                  
  6626                                  ; Prescan the string looking for Ctrl-Z. We terminate the message the moment 
  6627                                  ; we hit a Ctrl-Z. cx will contain the number of characters to be printed.
  6628                                  
  6629 00001332 55                      		push	bp
  6630 00001333 51                      		push	cx
  6631 00001334 E8ACFF                  		call	Scan_CtrlZ	; cx = count without Ctrl-Z
  6632 00001337 89CD                    		mov	bp,cx		; store no ^Z count in bp 
  6633 00001339 59                      		pop	cx		; get old count back
  6634                                  				; Write String at DS:SI to handle
  6635 0000133A CD21                    		int	21h	; DOS -
  6636 0000133C 720B                    		jc	short m_cnt_ok	;error, return with carry set
  6637                                  chk_count:				;no error, adjust return count
  6638                                  
  6639                                  ; If we are writing to con and there is a Ctrl-Z in the string, the
  6640                                  ; return count will be much less and if this returns to the caller we can get
  6641                                  ; spurious error messages. We check here if the count returned is same as
  6642                                  ; original count or same as the count if we stop at Ctrl-Z. In the second
  6643                                  ; case, we fake it as if all bytes have been written. If the return count
  6644                                  ; does not match either count, then we had some other disk error (such as
  6645                                  ; insufficient disk space) and we pass it through
  6646                                  
  6647 0000133E 39C1                    		cmp	cx,ax		; have all bytes been written?
  6648 00001340 7407                    		je	short m_cnt_ok	; there was an error writing
  6649 00001342 39C5                    		cmp	bp,ax		; count = Ctrl-Z count?
  6650 00001344 F8                      		clc			; no error either way
  6651 00001345 7502                    		jne	short m_cnt_ok	; no, pass it through
  6652 00001347 89C8                    		mov	ax,cx		; return old count
  6653                                  m_cnt_ok:
  6654 00001349 5D                      		pop	bp
  6655                                  $MEN128:
  6656 0000134A 1F                      		pop	ds
  6657                                  $MIF127:
  6658 0000134B C3                      		retn
  6659                                  
  6660                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  6661                                  ;;
  6662                                  ;;	PROC NAME: $M_GET_EXT_ERR_39
  6663                                  ;;
  6664                                  ;;	FUNCTION:  Will set registers for extended error #39
  6665                                  ;;	INPUTS:    None
  6666                                  ;;	OUPUTS:    AX,BX,CX set
  6667                                  ;;	REGS USED:
  6668                                  ;;
  6669                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  6670                                  
  6671                                  _$M_GET_EXT_ERR_39:
  6672 0000134C B82700                  		mov	ax,39
  6673                                  					; Bug!? 12/11/2018 (Erdogan Tan)
  6674                                  		;MOV	BX,(ERROR_CLASS_39 SHR 8) + ACTION_39  ;!?
  6675                                  						; BH = 1, BL = 4 ; !?
  6676                                  		;MOV	BX,(ERROR_CLASS_39 SHL 8) + ACTION_39
  6677                                  		;mov	bx,4
  6678 0000134F BB0401                  		mov	bx,0104h ; * BugFix
  6679                                  		;MOV	CH,LOCUS_39
  6680 00001352 B501                    		mov	ch,1
  6681 00001354 C3                      		retn
  6682                                  
  6683                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  6684                                  ;;
  6685                                  ;;	PROC NAME: $M_ADD_CRLF
  6686                                  ;;
  6687                                  ;;	FUNCTION:  Will decide whether to display a CRLF
  6688                                  ;;	INPUTS:    DX contains the Input/Class requested
  6689                                  ;;	OUTPUTS:   None
  6690                                  ;;	REGS Revised: CX,ES,DI
  6691                                  ;;
  6692                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  6693                                  
  6694                                  _$M_ADD_CRLF:				; Is it a utility message? 
  6695 00001355 80FEFF                  		cmp	dh,0FFh ; UTILITY_MSG_CLASS
  6696 00001358 7410                    		je	short $MIF135	; Yes,
  6697                                  					; No,
  6698 0000135A F6C680                  		test	dh,80h ; $M_NO_CRLF_MASK ; Are we to supress the CR LF?
  6699 0000135D 750B                    		jnz	short $MIF135 ; Yes,
  6700                                  				      ; No,	
  6701 0000135F 1E                      		push	ds
  6702 00001360 07                      		pop	es		; Set ES to data segment
  6703                                  		;lea	di,[$M_CRLF]
  6704 00001361 BF[235D]                		mov	di,$M_CRLF	; Point at CRLF message
  6705 00001364 B90200                  		mov	cx,2		; Set the message size
  6706 00001367 E817FF                  		call	_$M_DISPLAY_STRING ; Display the CRLF
  6707                                  $MIF135:
  6708 0000136A C3                      		retn
  6709                                  
  6710                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  6711                                  ;;
  6712                                  ;;	PROC NAME: $M_IS_IT_DBCS
  6713                                  ;;
  6714                                  ;;	FUNCTION:  Will decide whether character is Single or Double Byte
  6715                                  ;;	INPUTS:    AL contains the byte to be checked
  6716                                  ;;	OUPUTS:    Carry flag = 0 if byte is NOT in DBCS range
  6717                                  ;;		   Carry flag = 1 if byte IS in DBCS range
  6718                                  ;;	REGS USED: All restored
  6719                                  ;;
  6720                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  6721                                  
  6722                                  _$M_IS_IT_DBCS:
  6723 0000136B 06                      		push	es		; Save ES, DI registers
  6724 0000136C 57                      		push	di
  6725                                  		;LES	DI,$M_RT.$M_DBCS_VEC
  6726 0000136D C43E[1C5D]              		les	di,[$M_DBCS_VEC] ; 15/11/2018
  6727 00001371 09FF                    		or	di,di		; Was the DBCS vector set?
  6728 00001373 7418                    		jz	short $MIF138
  6729                                  $MDO139:
  6730                                  		;CMP	WORD PTR ES:[DI],$M_DBCS_TERM
  6731 00001375 26833D00                		cmp	word [es:di],0	; Is this the terminating flag?
  6732                                  		;clc
  6733 00001379 7412                    		je	short $MIF138	; Yes,
  6734                                  					; No,
  6735 0000137B 263A05                  		cmp	al,[es:di]	; Does the character fall in the DBCS range?
  6736 0000137E 7209                    		jb	short $MIF141
  6737 00001380 263A4501                		cmp	al,[es:di+1]	; Does the character fall in the DBCS range?
  6738 00001384 7703                    		ja	short $MIF141
  6739 00001386 F9                      		stc			; Yes, Set carry flag
  6740                                  		; Bug!: Never returns with cf = 1 ; 12/11/2018 (Erdogan Tan) ; *
  6741 00001387 EB04                    		jmp	short $MIF138 ; * BugFix
  6742                                  $MIF141:
  6743 00001389 47                      		inc	di		; Go to next vector
  6744 0000138A 47                      		inc	di
  6745 0000138B EBE8                    		jmp	short $MDO139
  6746                                  $MIF138:
  6747 0000138D 5F                      		pop	di
  6748 0000138E 07                      		pop	es
  6749 0000138F C3                      		retn
  6750                                  
  6751                                  ; ----------------------------------------------------------------------------
  6752                                  
  6753                                  ;_$M_CLS_A:	; proc far
  6754                                  		;push	cs
  6755                                  		;pop	es
  6756                                  		;lea	di,[CLASS_A_msg_tbl]
  6757                                  		;mov	di,CLASS_A_msg_tbl
  6758                                  		;add	cx,278
  6759                                  		;;retf
  6760                                  		;retn
  6761                                  
  6762                                  ; ----------------------------------------------------------------------------
  6763                                  
  6764                                  ;_$M_CLS_B:	; proc far
  6765                                  		;push	cs
  6766                                  		;pop	es
  6767                                  		;lea	di,[CLASS_B_msg_tbl]
  6768                                  		;mov	di,CLASS_B_msg_tbl
  6769                                  		;add	cx,189
  6770                                  		;;retf
  6771                                  		;retn
  6772                                  
  6773                                  ; ----------------------------------------------------------------------------
  6774                                  
  6775                                  ;_$M_CLS_1:	;proc far
  6776                                  		;push	cs
  6777                                  		;pop	es
  6778                                  		;lea	di,[CLASS_1_msg_tbl]
  6779                                  		;mov	di,CLASS_1_msg_tbl
  6780                                  		;add	cx,32
  6781                                  		;;retf
  6782                                  		;retn
  6783                                  
  6784                                  ; ----------------------------------------------------------------------------
  6785                                  
  6786                                  ;_$M_CLS_2:	;proc far
  6787                                  		;push	cs
  6788                                  		;pop	es
  6789                                  		;lea	di,[CLASS_2_msg_tbl]
  6790                                  		;mov	di,CLASS_2_msg_tbl
  6791                                  		;add	cx,29
  6792                                  		;;retf
  6793                                  		;retn
  6794                                  
  6795                                  ; ----------------------------------------------------------------------------
  6796                                  
  6797                                  ; ----------------------------------------------------------------------------
  6798                                  ; fdparse.c (FDISK, MSDOS 6.0, 1991)	
  6799                                  ; ----------------------------------------------------------------------------
  6800                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 14/11/2018)
  6801                                  
  6802                                  ;/************************************************************************/
  6803                                  ;/* Parse_Message                - This routine will print only those    */
  6804                                  ;/*                                messages that require 1 replaceable   */
  6805                                  ;/*                                parm.                                 */
  6806                                  ;/*                                                                      */
  6807                                  ;/*      Inputs  : Msg_Num       - number of applicable message          */
  6808                                  ;/*                Handle        - display type                          */
  6809                                  ;/*                Message_Type  - type of message to display            */
  6810                                  ;/*                Replace_Parm  - pointer to parm to replace            */
  6811                                  ;/*                                                                      */
  6812                                  ;/*      Outputs : message                                               */
  6813                                  ;/*                                                                      */
  6814                                  ;/*      Date    : 03/28/88                                              */
  6815                                  ;/*      Version : DOS 4.00                                              */
  6816                                  ;/************************************************************************/
  6817                                  
  6818                                  ;void Parse_msg(Msg_Num,Handle,Message_Type) 
  6819                                  
  6820                                  	;int             Msg_Num;
  6821                                  	;int             Handle;
  6822                                  	;unsigned char   Message_Type; 
  6823                                  
  6824                                  Parse_msg:
  6825                                  	; char    far *Cmd_Ptr; 
  6826                                  
  6827                                  	;%define _Cmd_Ptr    bp-4
  6828                                  	%define Msg_Num      bp+4
  6829                                  	%define	Handle       bp+6
  6830                                  	%define	Message_Type bp+8
  6831                                  
  6832 00001390 55                      		push	bp
  6833 00001391 89E5                    		mov	bp,sp
  6834                                  		;sub	sp,4
  6835                                  		;sub	sp-2 ; *
  6836                                  		;mov	ax,segregs_es
  6837                                  		;push	ax
  6838                                  		;call	segread ; segread(&segregs);  
  6839                                  		;pop	bx
  6840                                  
  6841                                  		;FP_SEG(Cmd_Ptr) = segregs.ds;
  6842                                  		;FP_OFF(Cmd_Ptr) = regs.x.si;
  6843                                  		;*Cmd_Ptr        = '\0';
  6844                                  
  6845                                  		;;mov	ax,[segregs_ds]
  6846                                  		;;mov	[_Cmd_Ptr+2],ax
  6847                                  		;mov	[_Cmd_Ptr+2],ds
  6848                                  		;;mov	ax,[regs_x_si]
  6849                                  		;;mov	[_Cmd_Ptr],ax
  6850                                  		;mov	[_Cmd_Ptr],si
  6851                                  		;les	bx,[_Cmd_Ptr]
  6852                                  		;mov	byte [es:bx],0
  6853                                  		;mov	bx,sp ; *
  6854                                  		;mov	byte [bx],0 ; *
  6855 00001393 C60400                  		mov	byte [si],0
  6856                                  
  6857                                  		;FP_SEG(sublistp[0].value) = segregs.ds;
  6858                                  		;FP_OFF(sublistp[0].value) = Parse_Ptr;     
  6859                                  
  6860                                  		;mov	ax,[segregs_ds]
  6861                                  		;mov	[sublistp_value_seg],ax
  6862 00001396 8C1E[E0A0]              		mov	[sublistp_value_seg],ds ; [sublistp_value+2]
  6863 0000139A A1[E0CB]                		mov	ax,[Parse_Ptr]
  6864 0000139D A3[DEA0]                		mov	[sublistp_value],ax
  6865                                  
  6866                                  		;sublistp[0].size      = Sublist_Length;
  6867                                  		;sublistp[0].reserved  = Reserved;
  6868                                  		;sublistp[0].id        = 0;
  6869                                  		;sublistp[0].flags     = Char_Field_ASCIIZ+Left_Align;
  6870                                  		;sublistp[0].max_width = 80;
  6871                                  		;sublistp[0].min_width = 01;
  6872                                  		;sublistp[0].pad_char  = Blank;
  6873                                  
  6874 000013A0 C606[DCA0]0B            		mov	byte [sublistp_size],11
  6875 000013A5 C606[E3A0]10            		mov	byte [sublistp_flags],10h ; Char_Field_ASCIIZ+Left_Align
  6876 000013AA C606[E4A0]50            		mov	byte [sublistp_max_width],80
  6877 000013AF C606[E5A0]01            		mov	byte [sublistp_min_width],1
  6878 000013B4 C606[E6A0]20            		mov	byte [sublistp_pad_char], ' '
  6879                                  
  6880                                  		;regs.x.ax = Msg_Num;
  6881                                  		;regs.x.bx = Handle;
  6882                                  		;regs.x.cx = SubCnt1;
  6883                                  		;regs.h.dl = No_Input;
  6884                                  		;regs.h.dh = Message_Type;
  6885                                  		;regs.x.si = (unsigned int)&sublistp[0];   
  6886                                  
  6887                                  		;mov	ax,[Msg_Num]
  6888                                  		;mov	[regs_x_ax],ax
  6889                                  		;mov	ax,[Handle]
  6890                                  		;mov	[regs_x_bx],ax
  6891                                  		;mov	[regs_x_cx],1
  6892 000013B9 28C0                    		sub	al,al ; 0
  6893 000013BB A2[DDA0]                		mov	[sublistp_res],al ; 0
  6894 000013BE A2[E2A0]                		mov	[sublistp_id],al ; 0
  6895                                  		;mov	[regs_x_dx],al
  6896                                  		;mov	al,[Message_Type]
  6897                                  		;mov	[regs_x_dx+1],al
  6898                                  		;mov	word [regs_x_si],sublistp_size
  6899                                  		;mov	ax,regs ; regs_x_ax
  6900                                  		;push	ax
  6901                                  		;push	ax
  6902                                  		;call	sysdispmsg  ; sysdispmsg(&regs,&regs);
  6903                                  		;pop	bx
  6904                                  		;pop	bx
  6905                                  
  6906 000013C1 57                      		push	di ; *
  6907 000013C2 56                      		push	si ; **
  6908                                  
  6909 000013C3 8B4604                  		mov	ax,[Msg_Num]	  ; ***
  6910 000013C6 8B5E06                  		mov	bx,[Handle]	  ; ***
  6911 000013C9 B90100                  		mov	cx,1 ; SubCnt1	  ; ***   
  6912 000013CC 8A7608                  		mov	dh,[Message_Type] ; ***
  6913                                  		;mov	dl,0 ; No_Input   ; ***
  6914 000013CF 28D2                    		sub	dl,dl
  6915 000013D1 BE[DCA0]                		mov	si,sublistp_size  ; ***
  6916                                  
  6917 000013D4 E836FA                  		call	SYSDISPMSG ; *, **, ***
  6918                                  
  6919 000013D7 5E                      		pop	si ; **
  6920 000013D8 5F                      		pop	di ; *
  6921                                  
  6922 000013D9 89EC                    		mov	sp,bp
  6923 000013DB 5D                      		pop	bp
  6924 000013DC C3                      		retn	; return;
  6925                                  
  6926                                  ; ----------------------------------------------------------------------------
  6927                                  ; fdisk.c (FDISK, MSDOS 6.0, 1991)	
  6928                                  ; ----------------------------------------------------------------------------
  6929                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 15/11/2018)
  6930                                  
  6931                                  ;/*  */
  6932                                  ; ----------------------------------------------------------------------------
  6933                                  ;char check_valid_environment()
  6934                                  
  6935                                  check_valid_environment:
  6936                                  			; /* See if the net is there */
  6937 000013DD B800B8                  		mov	ax,0B800h ; NETWORK - INSTALLATION CHECK
  6938 000013E0 CD2F                    		int	2Fh
  6939                                  			;Return:
  6940                                  			;  AL = status
  6941                                  			;	00h -> not installed
  6942                                  			;	>00h -> installed
  6943                                  			;  BX = installed component flags (test in this order!)
  6944                                  			;	bit 6   server
  6945                                  			;	bit 2   messenger
  6946                                  			;	bit 7   receiver
  6947                                  			;	bit 3   redirector
  6948                                  			;	bit 1   LANPUP (LANtastic 4.0)
  6949                                  		
  6950                                  		; /* See if server is loaded, otherwise okay */
  6951 000013E2 20C0                    		and	al,al
  6952 000013E4 741E                    		jz	short cve_true ; not installed, ok
  6953                                  
  6954 000013E6 F6C340                  		test	bl,40h  ; bit 6, server
  6955 000013E9 7419                    		jz	short cve_true ; not server running, ok
  6956                                  		
  6957                                  		; Error ! 
  6958                                  		; (FDISK must not be used in a network while the server is running.)
  6959                                  		;mov	al,0FFh
  6960 000013EB B8FF00                  		mov	ax,0FFh ; msgclass = 0FFh, UTILTY_MSG_CLASS
  6961 000013EE 50                      		push	ax
  6962 000013EF 28C0                    		sub	al,al ; 0
  6963 000013F1 A2[05C4]                		mov	[no_fatal_error],al ; FALSE
  6964 000013F4 50                      		push	ax	; msginput = 0, (noinput)
  6965                                  		;sub	ax,ax
  6966 000013F5 50                      		push	ax	; msgsub = 0,  (nosubptr)
  6967 000013F6 50                      		push	ax	; msgparms = 0, (nosubcnt)
  6968 000013F7 B002                    		mov	al,2	; msghan = 2, STDERR (DosStdEr)
  6969 000013F9 50                      		push	ax
  6970 000013FA B004                    		mov	al,4	; msgnum = 4, "Cannot FDISK with network loaded"
  6971 000013FC 50                      		push	ax
  6972                                  
  6973 000013FD E81AF9                  		call	display_msg
  6974 00001400 83C40C                  		add	sp,12
  6975                                  cve_false:
  6976                                  		;sub	al,al ; 0
  6977 00001403 F9                      		stc
  6978                                  cve_true:
  6979 00001404 C3                      		retn
  6980                                  ;cve_true:
  6981                                  		;mov	al,1
  6982                                  		;;clc	
  6983                                  		;retn
  6984                                  
  6985                                  ; ----------------------------------------------------------------------------
  6986                                  ; video.c (FDISK, MSDOS 6.0, 1991)	
  6987                                  ; ----------------------------------------------------------------------------
  6988                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 15/11/2018)
  6989                                  
  6990                                  ;/*  */
  6991                                  ;/*                                                                         */
  6992                                  ;/***************************************************************************/
  6993                                  ;/* Initializes the screen and stores the lower right hand corner           */
  6994                                  ;/* of the screen in the global variable LowerRightHandCorner. This         */
  6995                                  ;/* is which is used for screen clears. If the screen is in graphics mode,  */
  6996                                  ;/* it is changed to BW 40x25. This procedure is only called once at program*/
  6997                                  ;/* start. Also saves the current screen                                    */
  6998                                  ;/***************************************************************************/
  6999                                  ;/*                                                                         */
  7000                                  
  7001                                  init_video_information:
  7002 00001405 C606[CAC3]00            		mov	byte [mono_flag],0 ; FALSE
  7003                                  
  7004                                  		; /* Get the current video state */
  7005 0000140A B40F                    		mov	ah,0Fh
  7006 0000140C CD10                    		int	10h
  7007                                  		
  7008                                  		; /* Save the mode and display page */
  7009 0000140E A2[84A0]                		mov	[video_mode],al
  7010 00001411 883E[20A1]              		mov	[display_page],bh
  7011                                  
  7012                                  		; get_video_attribute();
  7013 00001415 E87100                  		call	get_video_attribute
  7014                                  
  7015                                  		; if (status_flag == FALSE)
  7016 00001418 803E[D4C3]00            		cmp	byte [status_flag],0
  7017 0000141D 7521                    		jne	short ivi_3
  7018                                  
  7019                                  		; /* assume color mode */
  7020 0000141F B003                    		mov	al,3
  7021                                  
  7022                                  		; /* See if we are in MONOCHROME mode */
  7023 00001421 803E[84A0]07            		cmp	byte [video_mode],7  ; Text 80x25 chars	Monochrome
  7024 00001426 7407                    		je	short ivi_1
  7025                                  			; Graphics 640x350 Monochrome
  7026 00001428 803E[84A0]0F            		cmp	byte [video_mode],0Fh
  7027 0000142D 7507                    		jne	short ivi_2
  7028                                  
  7029                                  ivi_1:		; /* Nope,set to BW80x25*/
  7030 0000142F B002                    		mov	al,2	; Text 80x25 chars Greyscale
  7031 00001431 C606[CAC3]01            		mov	byte [mono_flag],1
  7032                                  ivi_2:
  7033                                  		; /* go set the new mode */
  7034                                  		;mov	ah,0
  7035 00001436 28E4                    		sub	ah,ah
  7036 00001438 CD10                    		int	10h
  7037                                  		
  7038                                  		; /* Set the display page */
  7039 0000143A B405                    		mov	ah,5
  7040                                  		;mov	al,0
  7041 0000143C 28C0                    		sub	al,al
  7042 0000143E CD10                    		int	10h
  7043                                  ivi_3:
  7044 00001440 C3                      		retn
  7045                                  
  7046                                  ;/*  */
  7047                                  ;/***************************************************************************/
  7048                                  ;/* Resets the video mode to the original value 			    */
  7049                                  ;/***************************************************************************/
  7050                                  
  7051                                  ;void reset_video_information()
  7052                                  
  7053                                  reset_video_information:
  7054                                  		;  /* Do this if we are not using the /STATUS switch */
  7055                                  		; if (status_flag == FALSE)
  7056                                  		
  7057 00001441 803E[D4C3]00            		cmp	byte [status_flag],0
  7058 00001446 7515                    		jne	short rvi_ret
  7059                                  
  7060                                  		; /* Clear display with colors that were present when FDISK was invoked */
  7061 00001448 8A3E[10C4]              		mov	bh,[video_attribute]
  7062                                  		;sub	cx,cx ; cl = start (upper left) column
  7063                                  			      ; ch = start (top) row				
  7064                                  		;mov	dl,24 ; dl = end (lower right) column
  7065                                  		;mov	dh,79 ; dh = end (bottom) row
  7066                                  		;mov	al,0  ; lines
  7067                                  		;mov	ah,6 ; SCROLL_UP ; BIOS scroll up function
  7068                                  		;	 		 ; BIOS video call
  7069                                  		;int	10h	; - VIDEO - SCROLL PAGE	UP
  7070                                  				; AL = number of lines to scroll window	
  7071                                  				;	(0 = blank whole window)
  7072                                  				; BH = attributes to be	used on	blanked	lines
  7073                                  				; CH,CL	= row,column of	upper left corner of window to scroll
  7074                                  				; DH,DL	= row,column of	lower right corner of window
  7075                                  
  7076 0000144C E81200                  		call	RVI_CLS ; 16/11/2018
  7077                                  		
  7078                                  		; /* Reset the video mode */
  7079 0000144F 30E4                    		xor	ah,ah ; 0 ; SET MODE
  7080 00001451 A0[84A0]                		mov	al,[video_mode]
  7081 00001454 CD10                    		int	10h
  7082                                  
  7083                                  		; /* Set the page */
  7084 00001456 B405                    		mov	ah,5
  7085 00001458 A0[20A1]                		mov	al,[display_page]
  7086 0000145B CD10                    		int	10h
  7087                                  rvi_ret:
  7088 0000145D C3                      		retn
  7089                                  
  7090                                  ; ============================================================================
  7091                                  ;  CLS (clear screen, clear whole video page)
  7092                                  ; ============================================================================
  7093                                  ; 16/11/2018
  7094                                  
  7095                                  CLS:
  7096 0000145E E80D00                  		call	CLS_ATTRIBUTE ; Set cls (scroll) page attribute in bh		
  7097                                  RVI_CLS:
  7098                                  		; INPUT: bh = Page (blanked line) attributes
  7099                                  
  7100 00001461 29C9                    		sub	cx,cx ; cl = start (upper left) column
  7101                                  			      ; ch = start (top) row			
  7102 00001463 B24F                    		mov	dl,79 ; dl = end (lower right) column
  7103 00001465 B618                    		mov	dh,24 ; dh = end (bottom) row	
  7104 00001467 B000                    		mov	al,0  ; lines
  7105 00001469 B406                    		mov	ah,6 ; SCROLL_UP ; BIOS scroll up function
  7106                                  			 		 ; BIOS video call
  7107 0000146B CD10                    		int	10h	; - VIDEO - SCROLL PAGE	UP
  7108                                  				; AL = number of lines to scroll window	
  7109                                  				;	(0 = blank whole window)
  7110                                  				; BH = attributes to be	used on	blanked	lines
  7111                                  				; CH,CL	= row,column of	upper left corner of window to scroll
  7112                                  				; DH,DL	= row,column of	lower right corner of window
  7113 0000146D C3                      		retn
  7114                                  
  7115                                  ; cls_attribute
  7116                                  ; ----------------------------------------------------------------------------
  7117                                  ; 16/11/2018
  7118                                  
  7119                                  CLS_ATTRIBUTE:
  7120 0000146E 803E[D4C3]01            		cmp	byte [status_flag],1
  7121 00001473 7506                    		jne	short clscr_1
  7122                                  
  7123 00001475 8A3E[10C4]              		mov	bh,[video_attribute]
  7124 00001479 EB0D                    		jmp	short clscr_3
  7125                                  clscr_1:
  7126 0000147B 803E[CAC3]01            		cmp	byte [mono_flag],1
  7127 00001480 7504                    		jne	short clscr_2
  7128 00001482 B707                    		mov	bh,7	; GRAY_ON_BLACK
  7129 00001484 EB02                    		jmp	short clscr_3
  7130                                  clscr_2:
  7131 00001486 B717                    		mov	bh,17h	; WHITE_ON_BLUE
  7132                                  clscr_3:
  7133 00001488 C3                      		retn
  7134                                  
  7135                                  
  7136                                  ;/*****************************************************************************/
  7137                                  ;/*Routine name:  GET_VIDEO_ATTRIBUTE                                         */
  7138                                  ;/*****************************************************************************/
  7139                                  ;/*                                                                           */
  7140                                  ;/*Description:   This routine will invoke interrupt 10 function 08h to       */
  7141                                  ;/*               get the current attributes at the cursor position in order  */
  7142                                  ;/*               to restore the correct colors when returning out of FDISK.  */
  7143                                  ;/*                                                                           */
  7144                                  ;/*Called Procedures:    none                                                 */
  7145                                  ;/*                                                                           */
  7146                                  ;/*                                                                           */
  7147                                  ;/*Change History: Created        3/11/88         DRM                         */
  7148                                  ;/*                                                                           */
  7149                                  ;/*Input: None                                                                */
  7150                                  ;/*                                                                           */
  7151                                  ;/*Output: None                                                               */
  7152                                  ;/*                                                                           */
  7153                                  ;/*****************************************************************************/
  7154                                  
  7155                                  ;void get_video_attribute()
  7156                                  
  7157                                  get_video_attribute:	; /* Get current attributes */
  7158 00001489 B408                    		mov	ah,8 ; CURRENT_VIDEO_ATTRIBUTE
  7159 0000148B 8A3E[20A1]              		mov	bh,[display_page]
  7160 0000148F CD10                    		int	10h
  7161 00001491 8826[10C4]              		mov	[video_attribute],ah ; 16/11/2018
  7162 00001495 C3                      		retn
  7163                                  
  7164                                  ;/*  */
  7165                                  ; ============================================================================
  7166                                  ;  CLEAR SCREEN
  7167                                  ; ============================================================================
  7168                                  ; 15/11/2018
  7169                                  
  7170                                  ;void clear_screen(TopRow,LeftCol,BotRow,RightCol)
  7171                                  
  7172                                  ;unsigned     TopRow;
  7173                                  ;unsigned     LeftCol;
  7174                                  ;unsigned     BotRow;
  7175                                  ;unsigned     RightCol;
  7176                                  
  7177                                  ;BEGIN
  7178                                  
  7179                                  ;char    attribute;
  7180                                  ;char    *attribute_ptr = &attribute;
  7181                                  
  7182                                  ;	if (status_flag == TRUE)
  7183                                  ;		attribute = video_attribute;
  7184                                  ;	else
  7185                                  ;		{
  7186                                  ;  		if (mono_flag == TRUE) 
  7187                                  ;      		attribute = GRAY_ON_BLACK;
  7188                                  ;   		else
  7189                                  ;       	attribute = WHITE_ON_BLUE;
  7190                                  ;		}
  7191                                  ;  VIOSCROLLUP(TopRow,LeftCol,BotRow,RightCol,u(0),attribute_ptr,u(0));
  7192                                  ;  return;
  7193                                  ;END
  7194                                  
  7195                                  clear_screen: ; (clear_screen_down, clear screen rows)
  7196                                  
  7197                                  		%define	TopRow   bp+4
  7198                                  		%define LeftCol  bp+6
  7199                                  		%define BotRow   bp+8
  7200                                  		%define	RightCol bp+10	
  7201                                  
  7202 00001496 55                      		push	bp
  7203 00001497 89E5                    		mov	bp,sp
  7204                                  
  7205 00001499 53                      		push	bx
  7206 0000149A 51                      		push	cx
  7207 0000149B 52                      		push	dx
  7208                                  		;push	si
  7209                                  		;push	di
  7210                                  		;push	ds
  7211                                  		;push	es
  7212                                  		;push	ss
  7213                                  		;push	bp
  7214                                  
  7215                                  ;		cmp	byte [status_flag],1
  7216                                  ;		jne	short clscr_1
  7217                                  ;
  7218                                  ;		mov	bh,[video_attribute]
  7219                                  ;		jmp	short clscr_3
  7220                                  ;clscr_1:
  7221                                  ;		cmp	byte [mono_flag],1
  7222                                  ;		jne	short clscr_2
  7223                                  ;		mov	bh,7	; GRAY_ON_BLACK
  7224                                  ;		jmp	short clscr_3
  7225                                  ;clscr_2:
  7226                                  ;		mov	bh,17h	; WHITE_ON_BLUE
  7227                                  
  7228 0000149C E8CFFF                  		call	CLS_ATTRIBUTE ; 16/11/2018
  7229                                  		
  7230                                  		; bh = Attribute for erased lines
  7231                                  ;clscr_3:
  7232 0000149F 28C0                    		sub	al,al ; # of lines to scroll (0 = whole window)
  7233                                  		
  7234                                  		; ... VIOSCROLLUP ...
  7235                                  
  7236                                  ; video.asm (MSDOS 6.0, 1991)
  7237                                  ; ----------------------------------------------------------------------------
  7238                                  ; 15/11/2018 - Modified for NASM syntax & FDISK subroutines (by Erdogan Tan)
  7239                                  
  7240                                  ; ============================================================================
  7241                                  ; void VideoScrollUp( int StartRow, int StartCol, int EndRow, int EndCol,
  7242                                  ;                     int Lines, int Attrib )
  7243                                  ; ============================================================================
  7244                                  
  7245                                  VideoScrollUp:
  7246                                  VIOSCROLLUP:
  7247                                  		; bh =  Attribute for erased lines
  7248                                  		; al =  # of lines to scroll
  7249                                  	
  7250                                  		;;mov	al,[Lines]	 ; # of lines to scroll
  7251                                  
  7252                                  		;cmp	al,25
  7253                                  		;jg 	short vioscrollup_1
  7254                                  
  7255 000014A1 8A560A                  		mov	dl,[RightCol]	 ; Put ending column in DL
  7256                                  	
  7257                                  		;cmp	dl,80
  7258                                  		;jg 	short vioscrollup_1
  7259                                  
  7260 000014A4 8A7608                  		mov	dh,[BotRow]	 ; Put ending row in DH
  7261                                  
  7262                                  		;cmp	dh,25
  7263                                  		;jg 	short vioscrollup_1
  7264                                  
  7265 000014A7 8A6E04                  		mov	ch,[TopRow]	 ; Put starting row in CH
  7266 000014AA 8A4E06                  		mov	cl,[LeftCol]	 ; Put starting column in CL
  7267                                  
  7268                                  		;;mov	bh,[Attrib]	 ; Attribute for erased lines
  7269                                  	
  7270 000014AD B406                    		mov	AH,6 ; SCROLL_UP ; BIOS scroll up function
  7271                                  			 		 ; BIOS video call
  7272 000014AF CD10                    		int	10h	; - VIDEO - SCROLL PAGE	UP
  7273                                  				; AL = number of lines to scroll window	
  7274                                  				;	(0 = blank whole window)
  7275                                  				; BH = attributes to be	used on	blanked	lines
  7276                                  				; CH,CL	= row,column of	upper left corner of window to scroll
  7277                                  				; DH,DL	= row,column of	lower right corner of window
  7278                                  ;		sub	ax,ax ; 0
  7279                                  ;		jmp	short vioscrollup_2
  7280                                  ;vioscrollup_1:
  7281                                  ;		mov	ax,2
  7282                                  ;vioscrollup_2:
  7283                                  		;pop	bp
  7284                                  		;pop	ss
  7285                                  		;pop	es
  7286                                  		;pop	ds
  7287                                  		;pop	di
  7288                                  		;pop	si
  7289 000014B1 5A                      		pop	dx
  7290 000014B2 59                      		pop	cx
  7291 000014B3 5B                      		pop	bx
  7292 000014B4 89EC                    		mov	sp,bp
  7293 000014B6 5D                      		pop	bp
  7294                                  		;retn	12
  7295 000014B7 C20800                  		retn	8	; return and clean stack
  7296                                  
  7297                                  ; ----------------------------------------------------------------------------
  7298                                  ; int13.c (FDISK, MSDOS 6.0, 1991)	
  7299                                  ; ----------------------------------------------------------------------------
  7300                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 16/11/2018)
  7301                                  
  7302                                  ;/*  */
  7303                                  ; ----------------------------------------------------------------------------
  7304                                  ;char get_disk_info()
  7305                                  ;BEGIN
  7306                                  ;   unsigned char   i;
  7307                                  ;   /* Initialize values */
  7308                                  ;   number_of_drives = uc(0);
  7309                                  ;   for (i=uc(0); i < uc(MAX_HDISK); i++)
  7310                                  ;     BEGIN
  7311                                  ;        total_disk[i] = u(0);
  7312                                  ;        total_mbytes[i] = f(0);
  7313                                  ;        max_sector[i] = uc(0);
  7314                                  ;        max_head[i] = u(0);
  7315                                  ;     END
  7316                                  ;   /* See how many drives there are */
  7317                                  ;   if (get_drive_parameters(uc(0x80)))
  7318                                  ;      BEGIN
  7319                                  ;        /* Get the drive parameters for all drives */
  7320                                  ;        for (i = uc(0); i < number_of_drives;i++)
  7321                                  ;           BEGIN
  7322                                  ;            if (get_drive_parameters(uc(0x80)+i))
  7323                                  ;              BEGIN
  7324                                  ;                /* Save drive parameters */
  7325                                  ;                max_sector[i] = ((unsigned char)(regs.h.cl & 0x3F));
  7326                                  ;                max_head[i] = ((unsigned)(regs.h.dh +1));
  7327                                  ;                total_disk[i] = ((((unsigned)(regs.h.cl & 0xc0)) << 2) | regs.h.ch) + 1;
  7328                                  ;                total_mbytes[i] = cylinders_to_mbytes(total_disk[i],i);
  7329                                  ;              END
  7330                                  ;           else
  7331                                  ;              BEGIN
  7332                                  ;               good_disk[i] = FALSE;
  7333                                  ;               return(FALSE);
  7334                                  ;              END
  7335                                  ;          END
  7336                                  ;       return(TRUE);
  7337                                  ;      END
  7338                                  ;   else
  7339                                  ;      /* No drives present */
  7340                                  ;      BEGIN
  7341                                  ;        no_fatal_error = FALSE;
  7342                                  ;        return(FALSE);
  7343                                  ;      END
  7344                                  ;END
  7345                                  
  7346                                  get_disk_info:
  7347                                  		;%define _i_ bp-2
  7348                                  
  7349                                  		;push	bp
  7350                                  		;mov	bp,sp
  7351                                  
  7352                                  		;sub	sp,2
  7353                                  		;xor	ax,ax ; [_i_] = 0 ; 19/11/2018
  7354                                  		;push	ax
  7355                                  
  7356 000014BA 31ED                    		xor	bp,bp ; [_i_] = 0
  7357                                  
  7358                                  		;push	si
  7359                                  
  7360                                  		; /* Initialize values */
  7361                                  
  7362                                  		;sub	al,al
  7363 000014BC 29C0                    		sub	ax,ax ; 19/11/2018	
  7364 000014BE A2[D5C3]                		mov	[number_of_drives],al ; 0
  7365                                  
  7366                                  		;mov	[_i_],al ; 0
  7367 000014C1 31DB                    		xor	bx,bx ; 0
  7368                                  		;jmp	short gdi_2
  7369                                  gdi_1:
  7370                                  		;mov	bl,[_i_]
  7371                                  		;sub	bh,bh
  7372 000014C3 88BF[A0A0]              		mov	[max_sector+bx],bh ; 0
  7373                                  		;sub	ax,ax
  7374                                  		;shl	bx,1
  7375 000014C7 D0E3                    		shl	bl,1 ; 19/11/2018
  7376 000014C9 8987[B8A0]              		mov	[total_disk+bx],ax ; 0
  7377 000014CD 8987[C8A0]              		mov	[total_mbytes+bx],ax ; 0
  7378 000014D1 8987[A8A0]              		mov	[max_head+bx],ax ; 0
  7379                                  		;inc	byte [_i]
  7380 000014D5 D0EB                    		shr	bl,1 ; 19/11/2018
  7381 000014D7 FEC3                    		inc	bl
  7382                                  gdi_2:
  7383                                  		;cmp	byte [_i_],8 ; MAX_HDISK
  7384 000014D9 80FB08                  		cmp	bl,8 ; Max. 8 hard disks
  7385 000014DC 72E5                    		jb	short gdi_1
  7386                                  
  7387                                  		; /* See how many drives there are */
  7388                                  
  7389                                  		;mov	al,80h
  7390                                  		;push	ax
  7391 000014DE B280                    		mov	dl,80h
  7392 000014E0 E84E00                  		call	get_drive_parameters
  7393                                  		;pop	bx
  7394                                  		;or	al,al
  7395                                  		;jz	short gdi_7 ; AL = 0 -> Error, no hard disks present
  7396                                  
  7397                                  		; AL = 1 -> 1 or 2 or more hard disks present
  7398                                  
  7399                                  		; /* Get the drive parameters for all drives */
  7400                                  
  7401                                  		;mov	byte [_i_],0
  7402                                  		;sub	bp,bp ; [_i_] = 0
  7403                                  		;jmp	short gdi_4
  7404                                  
  7405                                  		; 14/12/2018
  7406 000014E3 3C01                    		cmp	al,1
  7407 000014E5 7317                    		jnb	short gdi_4 ; bp = 0
  7408                                  		
  7409                                  		; cf = 1 ; *
  7410                                  ;gdi_7:
  7411                                  		;/* No drives present */
  7412                                  
  7413                                  		;sub	al,al
  7414 000014E7 A2[05C4]                		mov	[no_fatal_error],al ; 0 ; FALSE
  7415                                  ;gdi_8:
  7416                                  		;stc ; *
  7417                                  ;gdi_9:
  7418                                  		;pop	si
  7419                                  		;mov	sp,bp
  7420                                  		;pop	bp
  7421                                  	
  7422 000014EA C3                      		retn
  7423                                  
  7424                                  gdi_3:
  7425                                  		;inc	byte [_i_]
  7426 000014EB 45                      		inc	bp
  7427                                  ;gdi_4:
  7428                                  		;mov	al,[_i_]
  7429                                  		;mov	dl,[_i_]
  7430 000014EC 89EA                    		mov	dx,bp ; [_i_]
  7431                                  		;cmp	[number_of_drives],al
  7432                                  		;cmp	[number_of_drives],dl
  7433                                  		;jbe	short gdi_6
  7434 000014EE 3A16[D5C3]              		cmp	dl,[number_of_drives]
  7435                                  		;jnb	short gdi_6
  7436 000014F2 733A                    		jnb	short gdi_5 ; cf=0, success return (14/12/2018)
  7437                                  		;add	al,80h
  7438 000014F4 80C280                  		add	dl,80h
  7439                                  		;push	ax
  7440 000014F7 E83700                  		call	get_drive_parameters
  7441                                  		;pop	bx
  7442                                  		;or	al,al
  7443                                  		;jz	short gdi_5
  7444                                  		; 14/12/2018
  7445 000014FA 3C01                    		cmp	al,1
  7446                                  		;jb	short gdi_5
  7447 000014FC 7232                    		jb	short gdi_6 ; cf=1, error return (14/12/2018)	
  7448                                  gdi_4: 			; 14/12/2018		
  7449                                  		; /* Save drive parameters */
  7450                                  
  7451                                  		;mov	al,[regs_x_cx]
  7452 000014FE 88C8                    		mov	al,cl
  7453 00001500 243F                    		and	al,3Fh
  7454                                  		;mov	bl,[_i_]
  7455                                  		;sub	bh,bh
  7456 00001502 89EB                    		mov	bx,bp ; 17/11/2018
  7457 00001504 8887[A0A0]              		mov	[max_sector+bx],al
  7458                                  		;mov	al,[regs_x_dx+1]
  7459 00001508 88F0                    		mov	al,dh
  7460 0000150A 28E4                    		sub	ah,ah
  7461 0000150C 40                      		inc	ax
  7462                                  		;shl	bx,1
  7463                                  		;shl	bl,1 ; 19/11/2018
  7464                                  		;mov	[max_head+bx],ax  ; Heads (<= 256)	  	
  7465                                  
  7466                                  		; 19/11/2018
  7467 0000150D 89DE                    		mov	si,bx  ; Drive number (0 to 7)
  7468 0000150F D1E6                    		shl	si,1
  7469 00001511 8984[A8A0]              		mov	[max_head+si],ax  ; Heads (<= 256)	
  7470                                  
  7471                                  		;mov	al,[regs_x_cx]
  7472 00001515 88C8                    		mov	al,cl ; 19/11/2018
  7473 00001517 25C000                  		and	ax,0C0h
  7474 0000151A D1E0                    		shl	ax,1
  7475 0000151C D1E0                    		shl	ax,1
  7476                                  		;mov	cl,[regs_x_cx+1]
  7477                                  		;sub	ch,ch
  7478                                  		;or	ax,cx
  7479 0000151E 88E8                    		mov	al,ch
  7480 00001520 40                      		inc	ax
  7481                                  		;mov	[total_disk+bx],ax ; cylinders (<= 1024)
  7482 00001521 8984[B8A0]              		mov	[total_disk+si],ax ; 19/11/2018	
  7483                                  	
  7484                                  		;mov	cl,[_i_]
  7485                                  		;;sub	ch,ch
  7486                                  		;mov	cx,bp ; [_i_]
  7487                                  		;push	cx
  7488                                  		;push	ax
  7489                                  		;mov	si,bx ; 19/11/2018
  7490                                  		;;mov	bl,[_i]
  7491                                  		;;xor	bh,bh
  7492                                  		;mov	bx,bp  ; Disk/Drive number (0 to 7) 
  7493 00001525 E83400                  		call	cylinders_to_mbytes
  7494                                  		;pop	bx
  7495                                  		;pop	bx
  7496 00001528 8984[C8A0]              		mov	[total_mbytes+si],ax
  7497 0000152C EBBD                    		jmp	short gdi_3
  7498                                  ;gdi_5:
  7499                                  		; cf = 1  ; 14/12/2018
  7500                                  		;;sub	al,al
  7501                                  		;;mov	bl,[_i_]
  7502                                  		;;sub	bh,bh
  7503                                  		;; ss = ds ; 19/11/2018
  7504                                  		;;mov	bx,bp ; [_i_]
  7505                                  		;;;mov	[good_disk+bx],al ; 0 ; FALSE
  7506                                  		;mov	[good_disk+bp],al ; 19/11/2018
  7507                                  		;;jmp	short gdi_8
  7508                                  		; 14/12/2018
  7509                                  		;stc
  7510                                  		;retn
  7511                                  ;gdi_6:
  7512                                  gdi_5:
  7513                                  		; cf = 0 ; 14/12/2018
  7514 0000152E B001                    		mov	al,1
  7515                                  		;jmp	short gdi_8
  7516                                  		; 14/12/2018
  7517                                  		;clc ; *
  7518                                  		;jmp	short gdi_9
  7519                                  gdi_6:
  7520 00001530 C3                      		retn
  7521                                  ;gdi_7:
  7522                                  ;		;/* No drives present */
  7523                                  ;
  7524                                  ;		;sub	al,al
  7525                                  ;		mov	[no_fatal_error],al ; 0 ; FALSE
  7526                                  ;gdi_8:
  7527                                  ;		stc ; *
  7528                                  ;gdi_9:
  7529                                  ;		;pop	si
  7530                                  ;		
  7531                                  ;		;mov	sp,bp
  7532                                  ;		;pop	bp
  7533                                  ;		
  7534                                  ;		retn
  7535                                  
  7536                                  
  7537                                  ;/*  */
  7538                                  ; ----------------------------------------------------------------------------
  7539                                  ;char get_drive_parameters(drive)
  7540                                  ;
  7541                                  ;unsigned char   drive;
  7542                                  ;
  7543                                  ;BEGIN
  7544                                  ;    /* See how many drives there are */
  7545                                  ;    regs.h.ah = uc(DISK_INFO);
  7546                                  ;    regs.h.dl = drive;
  7547                                  ;    DiskIo(&regs,&regs,&segregs);
  7548                                  ;
  7549                                  ;    /* See if any drives exist */
  7550                                  ;    if ((regs.h.dl == uc(0)) || ((regs.x.cflag & 1) == u(1)))
  7551                                  ;       BEGIN
  7552                                  ;        display(error_1);
  7553                                  ;        return(FALSE);
  7554                                  ;       END
  7555                                  ;    else
  7556                                  ;       BEGIN
  7557                                  ;        /* Save the number of drives */
  7558                                  ;        number_of_drives = regs.h.dl;
  7559                                  ;        if (number_of_drives > MAX_HDISK)
  7560                                  ;            number_of_drives = MAX_HDISK;
  7561                                  ;        return(TRUE);
  7562                                  ;       END
  7563                                  ;END
  7564                                  
  7565                                  get_drive_parameters:
  7566                                  		;push	bp
  7567                                  		;mov	bp,sp
  7568                                  
  7569                                  		;push	es
  7570                                  		;push	di
  7571                                  
  7572                                  		;mov	dl,[bp+4] ; hard disk drive number (80h = C:)
  7573 00001531 B408                    		mov	ah,8 ; Return Disk parameters
  7574 00001533 CD13                    		int	13h
  7575                                  			; AL = 0
  7576                                  			; CF = 1, Error
  7577                                  			;	AH = Error Code (>0)
  7578                                  			; CF = 0, NO error
  7579                                  			;	AH = 0
  7580                                  			; 	CH = Lower 8 bits of last cylinder number 
  7581                                  			;	CL = Sector number (bit 0 to bit 6) 
  7582                                  			;	     and High two bits of last cylinder number
  7583                                  			;	     (bits 7 and bit 8)
  7584                                  			;	DH = Last head number	
  7585                                  			;	DL = Number of hard disk drives
  7586                                  			; ES:DI = BIOS DPT address (Ref: AMIBIOS guide, 1993)	
  7587 00001535 9F                      		lahf
  7588                                  
  7589 00001536 1E                      		push	ds
  7590 00001537 07                      		pop	es
  7591                                  
  7592                                  		;cmp	dl,0
  7593 00001538 08D2                    		or	dl,dl
  7594 0000153A 7405                    		jz	short gdprm_1
  7595                                  
  7596 0000153C 80E401                  		and	ah,1 ; check cf
  7597 0000153F 740B                    		jz	short gdprm_2
  7598                                  gdprm_1:
  7599                                  		;push	word [error_1_seg]
  7600 00001541 1E                      		push	ds ; 17/11/2018
  7601 00001542 FF36[769E]              		push	word [error_1_off]
  7602 00001546 E8D100                  		call	display
  7603                                  		;pop	bx ; 19/11/2018 (!*!*)
  7604                                  		;pop	bx
  7605                                  
  7606                                  		;sub	al,al
  7607 00001549 29C0                    		sub	ax,ax ; 0
  7608                                  		;jmp	short gdprm_4
  7609                                  			; CF = 0, AL = 0 
  7610 0000154B C3                      		retn
  7611                                  gdprm_2:
  7612 0000154C 80FA08                  		cmp	dl,8
  7613 0000154F 7602                    		jbe	short gdprm_3
  7614 00001551 B208                    		mov	dl,8
  7615                                  gdprm_3:
  7616 00001553 8816[D5C3]              		mov	[number_of_drives],dl
  7617                                  		;mov	al,1
  7618 00001557 31C0                    		xor	ax,ax ; 14/12/2018
  7619 00001559 FEC0                    		inc	al  ; CF = 0, AL = 1	
  7620                                  gdprm_4:
  7621                                  		;pop	di
  7622                                  		;pop	es
  7623                                  
  7624                                  		;;mov	sp,bp
  7625                                  		;pop	bp
  7626                                  
  7627 0000155B C3                      		retn
  7628                                  
  7629                                  ; ----------------------------------------------------------------------------
  7630                                  ;
  7631                                  ;;; Temporary: 19/11/2018
  7632                                  ;display:
  7633                                  ;		pop	ax ; return address
  7634                                  ;		pop	si ; offset error_1_msg
  7635                                  ;		pop	bx ; segment	
  7636                                  ;		;mov	si, error_1_msg
  7637                                  ;		push	ax 
  7638                                  ;		jmp	print_msg
  7639                                  ;
  7640                                  ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  7641                                  ;
  7642                                  ;error_1_msg:
  7643                                  ;		db	0Dh,0Ah
  7644                                  ;		db	'No fixed disks present!'
  7645                                  ;		db	0Dh,0Ah,0
  7646                                  ;error_1_off:
  7647                                  ;		dw 	error_1_msg
  7648                                  ;
  7649                                  ; ----------------------------------------------------------------------------
  7650                                  
  7651                                  ; ----------------------------------------------------------------------------
  7652                                  ; convert.c (FDISK, MSDOS 6.0, 1991)	
  7653                                  ; ----------------------------------------------------------------------------
  7654                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 16/11/2018)
  7655                                  
  7656                                  ;/*  */
  7657                                  ;/*******************************************************************************/
  7658                                  ;/*Routine name:  CYLINDERS_TO_MBYTES                                           */
  7659                                  ;/*******************************************************************************/
  7660                                  ;/*                                                                             */
  7661                                  ;/*Description:   This routine will take input of cylinders and convert         */
  7662                                  ;/*               it to MBytes.                                                 */
  7663                                  ;/*                                                                             */
  7664                                  ;/*                                                                             */
  7665                                  ;/*Called Procedures:                                                           */
  7666                                  ;/*                                                                             */
  7667                                  ;/*                                                                             */
  7668                                  ;/*Change History: Created        5/16/87         DRM                           */
  7669                                  ;/*                                                                             */
  7670                                  ;/*Input: Cylinders_in                                                          */
  7671                                  ;/*                                                                             */
  7672                                  ;/*Output: MBytes_out                                                           */
  7673                                  ;/*                                                                             */
  7674                                  ;/*                                                                             */
  7675                                  ;/*                                                                             */
  7676                                  ;/*******************************************************************************/
  7677                                  
  7678                                  ;XFLOAT	   cylinders_to_mbytes(cylinders_in,which_disk)
  7679                                  ;
  7680                                  ;unsigned	cylinders_in;
  7681                                  ;char		which_disk;
  7682                                  ;
  7683                                  ;BEGIN
  7684                                  ;
  7685                                  ;unsigned	 mbytes_out;
  7686                                  ;/*C34 unsigned long    number_of_bytes; */
  7687                                  ;unsigned long	 number_of_sectors;
  7688                                  ;unsigned long	 number_of_tracks;
  7689                                  ;unsigned long	 bytes_in_one_sector;
  7690                                  ;
  7691                                  ;     bytes_in_one_sector = BYTES_PER_SECTOR;
  7692                                  ;     number_of_tracks = (ul(cylinders_in) * ul(max_head[which_disk]));
  7693                                  ;     number_of_sectors = (number_of_tracks * ul(max_sector[which_disk]));
  7694                                  ;/*C34 number_of_bytes = (ul(number_of_sectors) * ul(bytes_in_one_sector)); */
  7695                                  ;/*C34 mbytes_out =  f(number_of_bytes / ONE_MEG);                          */
  7696                                  ;/*C34 if ((number_of_bytes % ONE_MEG) >= (ONE_MEG / 2)) mbytes_out++;      */
  7697                                  ;     mbytes_out = numsecs_to_mbytes(number_of_sectors);                 /*C34*/
  7698                                  ;     return(mbytes_out);
  7699                                  ;
  7700                                  ;END
  7701                                  
  7702                                  cylinders_to_mbytes:
  7703                                  
  7704                                  		; INPUT: BX = Disk/Drive number (0 to 7)
  7705                                  		;	 AX = Cylinders (Total or partition's cylinder count)	
  7706                                  
  7707                                  		;push	bp
  7708                                  		;mov	bp,sp
  7709                                  		
  7710                                  		;mov	al,[bp+6] ; Disk/Drive number (0 to 7)
  7711                                  		;cbw
  7712                                  		;mov	bx,ax
  7713                                  		
  7714                                  		;mov	bl,[bp+6]
  7715                                  		;xor	bh,bh
  7716                                  
  7717                                  		;shl	bx,1
  7718 0000155C D0E3                    		shl	bl,1  ; word index	
  7719                                  
  7720                                  		;mov	cx,ax
  7721                                  		;mov	ax,[max_head+bx]
  7722                                  		;mul	word [bp+4]
  7723 0000155E 8B97[A8A0]              		mov	dx,[max_head+bx]
  7724 00001562 F7E2                    		mul	dx
  7725                                  			; dx:ax = Number of tracks (cylinders*heads)
  7726                                  
  7727                                  		;mov	bx,cx
  7728                                  		;shr	bx,1 ; byte index
  7729 00001564 D0EB                    		shr	bl,1 ; 11/12/2018
  7730 00001566 8A8F[A0A0]              		mov	cl,[max_sector+bx]
  7731 0000156A 28ED                    		sub	ch,ch
  7732                                  		;sub	bx,bx ; 0
  7733 0000156C 28DB                    		sub	bl,bl ; 11/12/2018
  7734 0000156E 53                      		push	bx ; yh - multiplier_hw
  7735 0000156F 51                      		push	cx ; yl - multiplier_lw
  7736 00001570 52                      		push	dx ; xh - multiplicand_hw
  7737 00001571 50                      		push	ax ; xl - multiplicand_lw
  7738 00001572 E85C00                  		call	mul32
  7739                                  			; dx:ax = Number of sectors 
  7740                                  		;push	dx
  7741                                  		;push	ax
  7742 00001575 E80100                  		call	numsecs_to_mbytes
  7743                                  			; AX = disk capacity as mega bytes
  7744                                  		;pop	bx
  7745                                  		;pop	bx
  7746                                  
  7747                                  		;mov	sp,bp
  7748                                  		;pop	bp
  7749                                  
  7750 00001578 C3                      		retn
  7751                                  
  7752                                  ; ----------------------------------------------------------------------------
  7753                                  
  7754                                  ;XFLOAT	   numsecs_to_mbytes(numsecs)
  7755                                  ;unsigned  long numsecs;
  7756                                  ;{
  7757                                  ;
  7758                                  ;unsigned long	 bytes_in_one_sector;
  7759                                  ;/*C34 unsigned long    number_of_bytes; */
  7760                                  ;unsigned         sectors_in_one_meg;					/*C34*/
  7761                                  ;unsigned	 mbytes_out;
  7762                                  ;
  7763                                  ;     bytes_in_one_sector = BYTES_PER_SECTOR;
  7764                                  ;/*C34 number_of_bytes = (numsecs * ul(bytes_in_one_sector));        */
  7765                                  ;/*C34 mbytes_out =  f((number_of_bytes + ul(ONE_MEG/2)) / ONE_MEG); */
  7766                                  ;     sectors_in_one_meg = u(ONE_MEG / bytes_in_one_sector);            /*C34*/
  7767                                  ;     mbytes_out = f((numsecs + ul(sectors_in_one_meg/2)) / sectors_in_one_meg)
  7768                                  ;									/*C34*/
  7769                                  ;     return(mbytes_out);
  7770                                  ;}
  7771                                  
  7772                                  numsecs_to_mbytes:
  7773                                  		; INPUT: DX:AX = Sector count (32 bit)
  7774                                  		;   OUT:    AX = Mega bytes	
  7775                                  		;push	bp
  7776                                  		;mov	bp,sp
  7777                                  		;mov	ax,[bp+4] ; sector count lw
  7778                                  		;mov	dx,[bp+6] ; sector count hw
  7779                                  
  7780                                  	;sectors_in_one_meg = u(ONE_MEG / bytes_in_one_sector);
  7781                                  	;mbytes_out = f((numsecs + ul(sectors_in_one_meg/2)) / sectors_in_one_meg)
  7782                                  
  7783 00001579 050004                  		add	ax,1024 ; round up
  7784 0000157C 83D200                  		adc	dx,0
  7785                                  			; DX:AX = (X kilo byte)*2 sectors
  7786 0000157F B10B                    		mov	cl,11 ; / 2048
  7787 00001581 E87F00                  		call	shr32
  7788                                  			; (X kilo bytes)*2 / 2048 = X/1024 mega bytes
  7789                                  		;mov	sp,bp
  7790                                  		;pop	bp
  7791 00001584 C3                      		retn
  7792                                  
  7793                                  ; ----------------------------------------------------------------------------
  7794                                  
  7795                                  ;unsigned  mbytes_to_percent(mbytes_used, total_cap)
  7796                                  ;unsigned  mbytes_used;
  7797                                  ;XFLOAT    total_cap;
  7798                                  ;
  7799                                  ;BEGIN
  7800                                  ;
  7801                                  ;unsigned      percentage_out;
  7802                                  ;
  7803                                  ;unsigned long large_number;
  7804                                  ;
  7805                                  ;	if (mbytes_used) {
  7806                                  ;		large_number = ( mbytes_used * 100L ) +total_cap/2;
  7807                                  ;		percentage_out = (unsigned) (large_number/total_cap);
  7808                                  ;		if (percentage_out > u(100)) percentage_out = u(100);
  7809                                  ;	}
  7810                                  ;	else percentage_out = 0;
  7811                                  ;    	return(percentage_out);
  7812                                  ;END
  7813                                  
  7814                                  mbytes_to_percent:
  7815                                  		; 21/11/2018
  7816                                  
  7817                                  	;%define percent    bp-2
  7818                                  	%define partmbytes  bp+4  ; mbytes_used
  7819                                  	%define	totalmbytes bp+6  ; total_cap	
  7820                                  
  7821 00001585 55                      		push	bp
  7822 00001586 89E5                    		mov	bp,sp
  7823                                  		;xor	bx,bx ; 0
  7824                                  		;push	bx
  7825                                  		
  7826                                  		;if (mbytes_used) {
  7827                                  
  7828                                  		;cmp	word [partmbytes],0
  7829                                  		;je	short mtp_0
  7830                                  
  7831 00001588 8B4604                  		mov	ax,[partmbytes]
  7832 0000158B 09C0                    		or	ax,ax
  7833 0000158D 741C                    		jz	short mtp_0
  7834                                  
  7835                                  		;large_number = ( mbytes_used * 100L ) +total_cap/2;
  7836                                  
  7837                                  		;mov	ax,[totalmbytes]
  7838                                  		;sub	dx,dx
  7839                                  		;push	dx ; divisor_hw = 0
  7840                                  		;push	ax ; divisor_lw
  7841                                  		;;;push	ax ;* divisor (16 bit)
  7842 0000158F 8B4E06                  		mov	cx,[totalmbytes] ; divisor (16 bit)
  7843                                  		;mov	ax,100
  7844                                  		;mul	word [partmbytes] ; X
  7845 00001592 BA6400                  		mov	dx,100
  7846 00001595 F7E2                    		mul	dx		
  7847                                  
  7848                                  		;mov	cx,[totalmbytes]
  7849                                  		;shr	cx,1
  7850                                  		;add	ax,cx
  7851                                  		
  7852                                  		;;;mov	bx,[totalmbytes]  ; Y
  7853 00001597 89CB                    		mov	bx,cx
  7854 00001599 D1EB                    		shr	bx,1 ; 1/2 Y
  7855 0000159B 01D8                    		add	ax,bx ; ((100*X)/Y)+(0.5)*Y/Y
  7856 0000159D 83D200                  		adc	dx,0
  7857                                  		
  7858                                  		;percentage_out = (unsigned) (large_number/total_cap);
  7859                                  
  7860                                  		;;;pop	cx ;* 21/11/2018 - divisor (16 bit)
  7861                                  		;push	dx ; dividend_hw
  7862                                  		;push	ax ; dividend_lw
  7863                                  		;call	div32
  7864                                  
  7865                                  		; dx:ax = dividend (32 bit)
  7866                                  		; cx = divisor (16 bit)
  7867 000015A0 E86900                  		call	div32
  7868                                  		;mov	[percent],ax
  7869                                  
  7870                                  		;if (percentage_out > u(100)) percentage_out = u(100);
  7871                                  
  7872 000015A3 83F864                  		cmp	ax,100
  7873 000015A6 7603                    		jbe	short mtp_0
  7874                                  		;mov	word [percent],100
  7875 000015A8 B86400                  		mov	ax,100
  7876                                  		;jmp	short mtp_1
  7877                                  mtp_0:
  7878                                  		;mov	word [percent],0
  7879                                  mtp_1:
  7880                                  		;mov	ax,[percent]
  7881                                  		;mov	sp,bp
  7882 000015AB 5D                      		pop	bp
  7883                                  
  7884 000015AC C20400                  		retn	4 ; 06/01/2019
  7885                                  
  7886                                  ; ----------------------------------------------------------------------------
  7887                                  
  7888                                  ; 26/11/2018
  7889                                  
  7890                                  ;/*  */
  7891                                  ;/*******************************************************************************/
  7892                                  ;/*Routine name:  CYLINDERS_TO_PERCENT                                          */
  7893                                  ;/*******************************************************************************/
  7894                                  ;/*                                                                             */
  7895                                  ;/*Description:   This routine will take input of cylinders and convert         */
  7896                                  ;/*               it to Percent.                                                */
  7897                                  ;/*                                                                             */
  7898                                  ;/*                                                                             */
  7899                                  ;/*Called Procedures:                                                           */
  7900                                  ;/*                                                                             */
  7901                                  ;/*                                                                             */
  7902                                  ;/*Change History: Created        5/16/87         DRM                           */
  7903                                  ;/*                                                                             */
  7904                                  ;/*Input: Cylinders_in                                                          */
  7905                                  ;/*                                                                             */
  7906                                  ;/*Output: percent_out                                                          */
  7907                                  ;/*                                                                             */
  7908                                  ;/*                                                                             */
  7909                                  ;/*******************************************************************************/
  7910                                  
  7911                                  ;unsigned  cylinders_to_percent(cylinders_in,total_cylinders)
  7912                                  ;
  7913                                  ;unsigned      cylinders_in;
  7914                                  ;unsigned      total_cylinders;
  7915                                  ;
  7916                                  ;BEGIN
  7917                                  ;
  7918                                  ;unsigned      percentage_out;
  7919                                  ;
  7920                                  ;/* SR; 9/26/89; Changed from double to unsigned long */
  7921                                  ;unsigned long large_number;
  7922                                  ;
  7923                                  ;    /* This is the same as (cyl_in / tot_cyl) * 100 to get the percentage */
  7924                                  ;    /* because * 100 is really 100/1 which is (cyl_in*100)/(tot_cyl*1).   */
  7925                                  ;
  7926                                  ;	 /* SR; 9/26/89; Check for cylinders_in = 0 because round off errors
  7927                                  ;		may cause total_cylinders = 1 but cylinders_in = 0 */
  7928                                  ;    if (cylinders_in == 0)
  7929                                  ;	 percentage_out = 0;
  7930                                  ;    else if (total_cylinders == 0)
  7931                                  ;            percentage_out = 0;
  7932                                  ;         else
  7933                                  ;            BEGIN
  7934                                  ;	       /* SR; 9/26/89; Changed double to unsigned long */
  7935                                  ;	       large_number = (unsigned long)(ul(cylinders_in) * 100l);
  7936                                  ;	       percentage_out = u(large_number / total_cylinders);
  7937                                  ;            END
  7938                                  ;    /* this should round up to the next percent if more than .5 percent */
  7939                                  ;
  7940                                  ;	 /* SR; 9/26/89; Need type cast to long or results truncated */
  7941                                  ;    if ((((long)cylinders_in * 100l) % total_cylinders) >= (total_cylinders / 2))
  7942                                  ;       percentage_out++;
  7943                                  ;    if (percentage_out > u(100)) percentage_out = u(100);
  7944                                  ;    return(percentage_out);
  7945                                  ;END
  7946                                  
  7947                                  cylinders_to_percent:
  7948                                  		; 26/11/2018
  7949                                  		; INPUT:
  7950                                  		;	bx = Number of cylinders (of partition) -dividend-
  7951                                  		;	cx = Total cylinders -divisor-
  7952                                  		; OUTPUT:
  7953                                  		;	ax = Percentage
  7954                                  		;
  7955                                  		; Modified registers: ax,bx,cx,dx	
  7956                                  
  7957                                  		;;%define percentage_out bp-6
  7958                                  		;;%define percentage_out bp-2 ; **
  7959                                  		;%define cylinders_in	bp+4
  7960                                  		;%define total_cylinders bp+6
  7961                                  
  7962                                  		;push	bp
  7963                                  		;mov	bp,sp
  7964                                  		;;sub	sp,6
  7965 000015AF 31C0                    		xor	ax,ax ; 26/11/2018 ; **
  7966                                  		;push	ax
  7967                                  
  7968                                  		;  if (cylinders_in == 0)
  7969                                  		;	 percentage_out = 0;
  7970                                  		;  else if (total_cylinders == 0)
  7971                                  		;           percentage_out = 0;
  7972                                  		;       else
  7973                                  
  7974                                  		;cmp	word [cylinders_in],0
  7975                                  		;cmp	[cylinders_in],ax ; 0
  7976                                  		;ja	short ctpc_2
  7977                                  		;mov	bx,[cylinders_in]
  7978 000015B1 09DB                    		or	bx,bx
  7979                                  		; 11/12/2018
  7980                                  		;jnz	short ctpc_2
  7981 000015B3 741B                    		jz	short ctpc_6 ; ax = 0 = percentage_out 
  7982                                  ctpc_1:
  7983                                  		;;mov	word [percentage_out],0
  7984                                  		;;mov	[percentage_out],ax ; 0
  7985                                  		;;jmp	short ctpc_3
  7986                                  		; 11/12/2018
  7987                                  		;jmp	short ctpc_6 ; ax = 0 = percentage_out
  7988                                  ctpc_2:
  7989                                  		;cmp	word [total_cylinders],0
  7990                                  		;je	short ctpc_1	
  7991                                  	
  7992                                  		;mov	cx,[total_cylinders]
  7993 000015B5 09C9                    		or	cx,cx
  7994                                  		; 11/12/2018
  7995                                  		;jz	short ctpc_1
  7996                                  			; cx = Divisor
  7997 000015B7 7417                    		jz	short ctpc_6
  7998                                  
  7999                                  		;large_number = (unsigned long)(ul(cylinders_in) * 100l);
  8000                                  		;percentage_out = u(large_number / total_cylinders);
  8001                                  		
  8002                                  		;mov	ax,[total_cylinders]
  8003                                  		;sub	dx,dx
  8004                                  		;push	dx
  8005                                  		;push	ax
  8006                                   
  8007 000015B9 B86400                  		mov	ax,100
  8008                                  		;mul	word [cylinders_in] ; 100*cylinders_in
  8009 000015BC F7E3                    		mul	bx ; [cylinders_in] 
  8010                                  
  8011                                  		;push	dx
  8012                                  		;push	ax
  8013                                  			; dx:ax = Dividend
  8014                                  
  8015 000015BE E84B00                  		call	div32	 ; 100*cylinders_in / total_cylinders
  8016                                  			; DX:AX = Quotient
  8017                                  			; BX = Remainder
  8018                                  
  8019                                  		;mov	[percentage_out],ax
  8020                                  		
  8021                                  		; ax = percentage_out	
  8022                                  ctpc_3:
  8023                                  
  8024                                  	;    if ((((long)cylinders_in * 100l) % total_cylinders) >= (total_cylinders / 2))
  8025                                  	;       percentage_out++;
  8026                                  	;    if (percentage_out > u(100)) percentage_out = u(100);
  8027                                  	;    return(percentage_out);
  8028                                  
  8029                                  		;mov	ax,[total_cylinders]
  8030                                  		;sub	dx,dx
  8031                                  		;push	dx
  8032                                  		;push	ax
  8033                                  		;mov	ax,100
  8034                                  		;mul	word [cylinders_in]
  8035                                  
  8036                                  		;push	dx
  8037                                  		;push	ax
  8038                                  		;call	_mod32
  8039                                  
  8040                                  		;mov	cx,[total_cylinders]
  8041 000015C1 D1E9                    		shr	cx,1	; total_cylinders/2
  8042                                  		;sub	bx,bx
  8043                                  		;cmp	dx,bx	; Remainder
  8044                                  		;jl	short ctpc_5
  8045                                  		;jg	short ctpc_4
  8046                                  		;cmp	ax,cx
  8047                                  		;jb	short ctpc_5
  8048 000015C3 39CB                    		cmp	bx,cx	; is remainder >= total_cylinders/2 ?
  8049 000015C5 7201                    		jb	short ctpc_5 ; No. 
  8050                                  ctpc_4:
  8051                                  		;inc	word [percentage_out] ; Yes, (x.5)% --> (x+1)%
  8052 000015C7 40                      		inc	ax
  8053                                  ctpc_5:
  8054                                  		;cmp	word [percentage_out],100
  8055 000015C8 83F864                  		cmp	ax,100
  8056 000015CB 7603                    		jbe	short ctpc_6
  8057                                  		;mov	word [percentage_out],100  ;  max. 100% (no 101%)
  8058 000015CD B86400                  		mov	ax,100
  8059                                  ctpc_6:
  8060                                  		;;mov	ax,[percentage_out]
  8061                                  		;pop	ax ; [percentage_out]
  8062                                  		;;mov	sp,bp
  8063                                  		;pop	bp
  8064 000015D0 C3                      		retn
  8065                                  
  8066                                  ; ----------------------------------------------------------------------------
  8067                                  
  8068                                  ; 32 bit multiplication (Microsoft C 6.0 runtime library, MSDOS 6.0, 1991)
  8069                                  ; ============================================================================
  8070                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 16/11/2018)
  8071                                  
  8072                                  mul32:
  8073                                  	%define MULTIPLICAND_L	bp+4  ; xl
  8074                                  	%define MULTIPLICAND_H	bp+6  ; xh
  8075                                  	%define MULTIPLIER_L	bp+8  ; yl
  8076                                  	%define MULTIPLIER_H	bp+10 ; yh
  8077                                  
  8078 000015D1 55                      		push	bp
  8079 000015D2 89E5                    		mov	bp,sp
  8080 000015D4 8B4606                  		mov	ax,[MULTIPLICAND_H] ; yh
  8081 000015D7 8B4E0A                  		mov	cx,[MULTIPLIER_H]   ; xh
  8082 000015DA 09C1                    		or	cx,ax
  8083 000015DC 8B4E08                  		mov	cx,[MULTIPLIER_L]   ; yl
  8084 000015DF 7509                    		jnz	short mul32_1
  8085                                  mul32_0:
  8086 000015E1 8B4604                  		mov	ax,[MULTIPLICAND_L] ; xl
  8087 000015E4 F7E1                    		mul	cx ; xl*yl
  8088 000015E6 5D                      		pop	bp
  8089 000015E7 C20800                  		retn	8
  8090                                  mul32_1:
  8091 000015EA 53                      		push	bx
  8092 000015EB F7E1                    		mul	cx ; xh*yl
  8093 000015ED 89C3                    		mov	bx,ax ; (xh*yl)
  8094 000015EF 8B4604                  		mov	ax,[MULTIPLICAND_L] ; xl 
  8095 000015F2 F7660A                  		mul	word [MULTIPLIER_H] ; yh
  8096 000015F5 01C3                    		add	bx,ax ; (xh*yl)+(xl*yh)
  8097 000015F7 8B4604                  		mov	ax,[MULTIPLICAND_L] ; xl
  8098 000015FA F7E1                    		mul	cx ; xl*yl
  8099 000015FC 01DA                    		add	dx,bx ; (H(xl*yl)+(xh*yl)+(xl*yh))
  8100                                  			      ; ax = L(xl*yl)	
  8101 000015FE 5B                      		pop	bx
  8102 000015FF 5D                      		pop	bp
  8103 00001600 C20800                  		retn	8
  8104                                  			; 132*9
  8105                                  			; yl = 32, yh = 1
  8106                                  			; xl = 9, xh = 0
  8107                                  			; xh*yl = 0, xl*yh = 9
  8108                                  			; 32*9 = 288, H(xl*yl) = 2, L(xl*yl) = 88 (AA)
  8109                                  			; 2+9 = 11 (BB)
  8110                                  			; 132*9 = 1188 (BBAA)
  8111                                  
  8112                                  ; 32 bit shift (Microsoft C 6.0 runtime library, MSDOS 6.0, 1991)	
  8113                                  ; ============================================================================
  8114                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 16/11/2018)
  8115                                  
  8116                                  shr32:
  8117                                  		;xor	ch,ch
  8118                                  		;jcxz	short shr32_1
  8119                                  shr32_0:
  8120 00001603 D1EA                    		shr	dx,1
  8121 00001605 D1D8                    		rcr	ax,1
  8122                                  		;loop	shr32_0
  8123 00001607 FEC9                    		dec	cl
  8124 00001609 75F8                    		jnz	short shr32_0
  8125                                  shr32_1:
  8126 0000160B C3                      		retn
  8127                                  
  8128                                  ; 32 bit division (Microsoft C 6.0 runtime library, MSDOS 6.0, 1991)	
  8129                                  ; ============================================================================
  8130                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 21/11/2018)
  8131                                  
  8132                                  ;	%define dividend_lw bp+4
  8133                                  ;	%define dividend_hw bp+6
  8134                                  ;	%define divisor_lw  bp+8
  8135                                  ;	%define divisor_hw  bp+10
  8136                                  ;
  8137                                  ;		push	bp
  8138                                  ;		mov	bp,sp
  8139                                  ;		push	bx
  8140                                  ;		push	si
  8141                                  ;		mov	ax,[divisor_hw]
  8142                                  ;		or	ax,ax
  8143                                  ;		jnz	short div32_0
  8144                                  ;		mov	cx,[divisor_lw]
  8145                                  ;		mov	ax,[dividend_hw]
  8146                                  ;		xor	dx,dx
  8147                                  ;		div	cx
  8148                                  ;		mov	bx,ax
  8149                                  ;		mov	ax,[dividend_lw]
  8150                                  ;		div	cx
  8151                                  ;		mov	dx,bx
  8152                                  ;		jmp	short div32_4
  8153                                  ;div32_0:
  8154                                  ;		mov	cx,ax
  8155                                  ;		mov	bx,[divisor_lw]
  8156                                  ;		mov	dx,[dividend_hw]
  8157                                  ;		mov	ax,[dividend_lw]
  8158                                  ;div32_1:
  8159                                  ;		shr	cx,1
  8160                                  ;		rcr	bx,1
  8161                                  ;		shr	dx,1
  8162                                  ;		rcr	ax,1
  8163                                  ;		or	cx,cx
  8164                                  ;		jnz	short div32_1
  8165                                  ;		div	bx
  8166                                  ;		mov	si,ax
  8167                                  ;		mul	word [divisor_hw]
  8168                                  ;		xchg	ax,cx
  8169                                  ;		mov	ax,[divisor_lw]
  8170                                  ;		mul	si
  8171                                  ;		add	dx,cx
  8172                                  ;		jc	short div32_2
  8173                                  ;		cmp	dx,[dividend_hw]
  8174                                  ;		ja	short div32_2
  8175                                  ;		jb	short div32_3
  8176                                  ;		cmp	ax,[dividend_lw]
  8177                                  ;		jbe	short div32_3
  8178                                  ;div32_2:
  8179                                  ;		dec	si
  8180                                  ;div32_3:
  8181                                  ;		xor	dx,dx
  8182                                  ;		xchg	ax,si
  8183                                  ;div32_4:
  8184                                  ;		pop	si
  8185                                  ;		pop	bx
  8186                                  ;		pop	bp
  8187                                  ;		retn	8
  8188                                  
  8189                                  ; 11/12/2018
  8190                                  div32:
  8191                                  		; 21/11/2018
  8192                                  		; DX:AX = Dividend
  8193                                  		; CX = Divisor
  8194                                  
  8195 0000160C 89C3                    		mov	bx,ax  ; dividend_lw	
  8196 0000160E 89D0                    		mov	ax,dx  ; dividend_hw
  8197 00001610 31D2                    		xor	dx,dx
  8198 00001612 F7F1                    		div	cx	
  8199 00001614 93                      		xchg	bx,ax
  8200 00001615 F7F1                    		div	cx
  8201                                  		;mov	dx,bx
  8202 00001617 87D3                    		xchg	dx,bx
  8203                                  
  8204                                  		; DX:AX = Quotient
  8205                                  		; BX = Remainder 
  8206                                  
  8207 00001619 C3                      		retn
  8208                                  
  8209                                  ; Remainder after 32 bit signed division (Microsoft C 6.0 runtime library)	
  8210                                  ; ============================================================================
  8211                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 26/11/2018)
  8212                                  
  8213                                  ;;Note: This subroutine is not needed for assembly language programming
  8214                                  ;; because, remainder is ready after a 32 bit division in dx (for 32/16 div)
  8215                                  ;; or bx (for 32/32 division, div32) register.
  8216                                  ; (as above!!) 
  8217                                  
  8218                                  ;_mod32:
  8219                                  ;	%define _dividend_lw_ bp+4
  8220                                  ;	%define _dividend_hw_ bp+6
  8221                                  ;	%define _divisor_lw_  bp+8
  8222                                  ;	%define _divisor_hw_  bp+10	
  8223                                  ;
  8224                                  ;		push	bp
  8225                                  ;		mov	bp,sp
  8226                                  ;		push	bx
  8227                                  ;		push	di
  8228                                  ;		xor	di,di
  8229                                  ;		mov	ax,[_dividend_hw_]
  8230                                  ;		or	ax,ax
  8231                                  ;		jge	short _mod32_0
  8232                                  ;		inc	di
  8233                                  ;		mov	dx,[_dividend_lw_]
  8234                                  ;		neg	ax
  8235                                  ;		neg	dx
  8236                                  ;		sbb	ax,0
  8237                                  ;		mov	[_dividend_hw_],ax
  8238                                  ;		mov	[_dividend_lw_],dx
  8239                                  ;_mod32_0:
  8240                                  ;		mov	ax,[_divisor_hw_]
  8241                                  ;		or	ax,ax
  8242                                  ;		jge	short _mod32_1
  8243                                  ;		mov	dx,[_divisor_lw_]
  8244                                  ;		neg	ax
  8245                                  ;		neg	dx
  8246                                  ;		sbb	ax,0
  8247                                  ;		mov	[_divisor_hw_],ax
  8248                                  ;		mov	[_divisor_lw_],dx
  8249                                  ;_mod32_1:
  8250                                  ;		or	ax,ax
  8251                                  ;		jnz	short _mod32_2
  8252                                  ;		mov	cx,[_divisor_lw_]
  8253                                  ;		mov	ax,[_dividend_hw_]
  8254                                  ;		xor	dx,dx
  8255                                  ;		div	cx
  8256                                  ;		mov	ax,[_dividend_lw_]
  8257                                  ;		div	cx
  8258                                  ;		mov	ax,dx
  8259                                  ;		xor	dx,dx
  8260                                  ;		dec	di
  8261                                  ;		jns	short _mod32_6
  8262                                  ;		jmp	short _mod32_7
  8263                                  ;_mod32_2:
  8264                                  ;		mov	bx,ax
  8265                                  ;		mov	cx,[_divisor_lw_]
  8266                                  ;		mov	dx,[_dividend_hw_]
  8267                                  ;		mov	ax,[_dividend_lw_]
  8268                                  ;_mod32_3:
  8269                                  ;		shr	bx,1
  8270                                  ;		rcr	cx,1
  8271                                  ;		shr	dx,1
  8272                                  ;		rcr	ax,1
  8273                                  ;		or	bx,bx
  8274                                  ;		jnz	short _mod32_3
  8275                                  ;		div	cx
  8276                                  ;		mov	cx,ax
  8277                                  ;		mul	[_divisor_hw_]
  8278                                  ;		xchg	ax,cx
  8279                                  ;		mul	[_divisor_lw_]
  8280                                  ;		add	dx,cx
  8281                                  ;		jb	short _mod32_4
  8282                                  ;		cmp	dx,[_dividend_hw_]
  8283                                  ;		ja	short _mod32_4
  8284                                  ;		jb	short _mod32_5
  8285                                  ;		cmp	ax,[_dividend_lw_]
  8286                                  ;		jbe	short _mod32_5
  8287                                  ;_mod32_4:
  8288                                  ;		sub	ax,[_divisor_lw_]
  8289                                  ;		sbb	dx,[_divisor_hw_]
  8290                                  ;_mod32_5:
  8291                                  ;		sub	ax,[_dividend_lw_]
  8292                                  ;		sbb	dx,[_dividend_hw_]
  8293                                  ;		dec	di
  8294                                  ;		jns	short _mod32_7
  8295                                  ;_mod32_6:
  8296                                  ;		neg	dx
  8297                                  ;		neg	ax
  8298                                  ;		sbb	dx,0
  8299                                  ;_mod32_7:
  8300                                  ;		; DX:AX = Remainder
  8301                                  ;		pop	di
  8302                                  ;		pop	bx
  8303                                  ;		pop	bp
  8304                                  ;		retn	8
  8305                                  
  8306                                  ;=============================================================================
  8307                                  ;DOSEXIT (doscall.h, MSDOS 6.0, 1991) & 
  8308                                  ;=============================================================================
  8309                                  
  8310                                  ; doscall.h (doscall.h, fdisk, MSDOS 6.0, 1991)
  8311                                  ; ----------------------------------------------------------------------------
  8312                                  ;/***	DosExit - Exit a program
  8313                                  ; *
  8314                                  ; *	This call is issued when a thread completes its execution.
  8315                                  ; *	The current thread is ended.
  8316                                  ; */
  8317                                  ;
  8318                                  ;extern void far pascal DOSEXIT (
  8319                                  ;	unsigned,			/* 0=end current thread, 1=end all */
  8320                                  ;	unsigned );			/* Result Code to save for DosCwait */
  8321                                  
  8322                                  ; dos.asm (MSDOS 6.0, lib\common, 1991)
  8323                                  ;*--------------------------------------------------------------------------*
  8324                                  ;*                                                                          *
  8325                                  ;*  DosExit(ec);                                                            *
  8326                                  ;*                                                                          *
  8327                                  ;*  Terminate program                                                       *
  8328                                  ;*                                                                          *
  8329                                  ;*--------------------------------------------------------------------------*
  8330                                  
  8331                                  ;cProc DosExit, <FAR, PUBLIC>
  8332                                  ;ParmW   ec
  8333                                  ;cBegin
  8334                                  ;        mov     al,byte ptr ec
  8335                                  ;        mov     ah,4Ch
  8336                                  ;        int     21h
  8337                                  ;cEnd
  8338                                  
  8339                                  
  8340                                  ; DOSEXIT (IBM PC-DOS 7.0, FDISK, segment 2, 005DFh)
  8341                                  ; ----------------------------------------------------------------------------
  8342                                  
  8343                                  ;DOSEXIT:	;proc near (Erdogan Tan)	; proc far (Original)
  8344                                  ;
  8345                                  ;%define ret_code bp+4 ; bp+6 ; word
  8346                                  ;%define end_op	  bp+6 ; bp+8 ; word
  8347                                  ;
  8348                                  ;		push	bp
  8349                                  ;		mov	bp,sp
  8350                                  ;		push	bx
  8351                                  ;		push	cx
  8352                                  ;		push	dx
  8353                                  ;		push	si
  8354                                  ;		push	di
  8355                                  ;		push	ds
  8356                                  ;		push	es
  8357                                  ;		push	ss
  8358                                  ;		push	bp
  8359                                  ;		mov	ax,[end_op]
  8360                                  ;		cmp	ax,1
  8361                                  ;		jg	short dosexit_0
  8362                                  ;		mov	ax,[ret_code]
  8363                                  ;		mov	ah,4Ch
  8364                                  ;		int	21h		; DOS -	2+ - QUIT WITH EXIT CODE (EXIT)
  8365                                  ;					; AL = exit code
  8366                                  ;		xor	ax, ax
  8367                                  ;dosexit_0:
  8368                                  ;		pop	bp
  8369                                  ;		pop	ss
  8370                                  ;		pop	es
  8371                                  ;		pop	ds
  8372                                  ;		pop	di
  8373                                  ;		pop	si
  8374                                  ;		pop	dx
  8375                                  ;		pop	cx
  8376                                  ;		pop	bx
  8377                                  ;		mov	sp,bp
  8378                                  ;		pop	bp
  8379                                  ;		;retf	4
  8380                                  ;		retn	4
  8381                                  
  8382                                  ; ----------------------------------------------------------------------------
  8383                                  ; display.c (FDISK, MSDOS 6.0, 1991)	
  8384                                  ; ----------------------------------------------------------------------------
  8385                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 16/11/2018)
  8386                                  			
  8387                                  ;/*  */
  8388                                  ;/******************* START OF SPECIFICATIONS *******************/
  8389                                  ;/*                                                             */
  8390                                  ;/* SUBROUTINE NAME: DISPLAY                                    */
  8391                                  ;/*                                                             */
  8392                                  ;/* DESCRIPTIVE NAME: Display full screen interface messages    */
  8393                                  ;/*                                                             */
  8394                                  ;/* FUNCTION: Displays messages and handles control characters  */
  8395                                  ;/*                                                             */
  8396                                  ;/* NOTES:                                                      */
  8397                                  ;/*  FDISK MESSAGES                                             */
  8398                                  ;/* Portions of the screen that are handled in the msg are      */
  8399                                  ;/* indicated on the listing of the screen with the message     */
  8400                                  ;/* name given.  If the text message is defined in another      */
  8401                                  ;/* screen, then the name is followed by a "#" character        */
  8402                                  ;/*                                                             */
  8403                                  ;/* NOTE TO TRANSLATORS The characters inside the <> and the [] */
  8404                                  ;/* are control characters and should not be translated.  The   */
  8405                                  ;/* Control characters are defined as follows:                  */
  8406                                  ;/*                                                             */
  8407                                  ;/* <H> - Highlight the following text                          */
  8408                                  ;/* <R> - Regular text                                          */
  8409                                  ;/* <B> - Blink the following text                              */
  8410                                  ;/* <O> - Turn blinking off                                     */
  8411                                  ;/* <Y> - Print YES character, as set by define                 */
  8412                                  ;/* <N> - Print NO character, as set by define                  */
  8413                                  ;/* <W> - Sound the beep                                        */
  8414                                  ;/* <S> - Save cursor position for later use                    */
  8415                                  ;/* <I> - Insert character from insert[] string. This string    */
  8416                                  ;/*       must be set up prior to displaying the message. The   */
  8417                                  ;/*       first <I> will insert Insert[0], the second           */
  8418                                  ;/*       insert[1], etc....This will move the cursor one       */
  8419                                  ;/*       position. The insert[] string will be initialized     */
  8420                                  ;/*                                                             */
  8421                                  ;/* Multiple control characters can be between the <>.          */
  8422                                  ;/*                                                             */
  8423                                  ;/* The ^####^indicates Row and column for the text and has the */
  8424                                  ;/* format of [rrcc] where the numbers are decimal and zero     */
  8425                                  ;/* based (first row/col is 00.  The numbers are in decimal,    */
  8426                                  ;/* and must be 2 characters, which means rows/cols 0-9 should  */
  8427                                  ;/* be listed as 00-09.  For example, the 5th row, 3rd column   */
  8428                                  ;/* on the screen would be listed as ^0402^.                    */
  8429                                  ;/*                                                             */
  8430                                  ;/* The column number is always the column desired.  The row    */
  8431                                  ;/* number is an offset from the previous row.  For example, if */
  8432                                  ;/* the text just printed is on row 6, and the next text should */
  8433                                  ;/* be printed 2 rows down in column 0, then the control strin  */
  8434                                  ;/* would be ^0201^.  The first row specified in the message is */
  8435                                  ;/* assumed to be based off of row 0, it would actually specify */
  8436                                  ;/* the actual row for the start of the msg to be printed.      */
  8437                                  ;/*                                                             */
  8438                                  ;/* ENTRY POINTS: display(*message_name);                       */
  8439                                  ;/*      LINKAGE: Near call                                     */
  8440                                  ;/*                                                             */
  8441                                  ;/* INPUT: char *message_name                                   */
  8442                                  ;/*                                                             */
  8443                                  ;/* EXIT-NORMAL:                                                */
  8444                                  ;/*                                                             */
  8445                                  ;/* EXIT-ERROR:                                                 */
  8446                                  ;/*                                                             */
  8447                                  ;/* EFFECTS:                                                    */
  8448                                  ;/* input_row changed if <S> control character in message       */
  8449                                  ;/* input_col changed if <S> control character in message       */
  8450                                  ;/*                                                             */
  8451                                  ;/* INTERNAL REFERENCES:                                        */
  8452                                  ;/*   ROUTINES:                                                 */
  8453                                  ;/*                                                             */
  8454                                  ;/* EXTERNAL REFERENCES:                                        */
  8455                                  ;/*   ROUTINES:                                                 */
  8456                                  ;/*                                                             */
  8457                                  ;/* viowrtcharstratt();                                         */
  8458                                  ;/******************** END OF SPECIFICATIONS ********************/
  8459                                  ;/*  */
  8460                                  
  8461                                  ;void display(s)
  8462                                  ;
  8463                                  ;char far *s;
  8464                                  ;
  8465                                  ;BEGIN
  8466                                  ;       unsigned      row;
  8467                                  ;       unsigned      col;
  8468                                  ;       char          attribute;
  8469                                  ;       char far      *attribute_ptr = &attribute;
  8470                                  ;       unsigned      insert_count;
  8471                                  ;
  8472                                  ;       /* Initialize row and col, and index into array */
  8473                                  ;       row = u(0);							/* AC000 */
  8474                                  ;       col = u(0);							/* AC000 */
  8475                                  ;       insert_count = u(0);						/* AC000 */
  8476                                  ;       /* check for a request to display a null string */
  8477                                  ;       if (*s == c('\0'))						/* AC000 */
  8478                                  ;          BEGIN
  8479                                  ;           /* Message string error */
  8480                                  ;           insert[0] = c('1');						/* AC000 */
  8481                                  ;           display(debug_msg);
  8482                                  ;          END
  8483                                  ;       else
  8484                                  ;          BEGIN
  8485                                  ;           /* There is data there, lets go handle it */
  8486                                  ;
  8487                                  ;			  if (status_flag == TRUE )
  8488                                  ;				attribute = video_attribute;
  8489                                  ;			  else
  8490                                  ;           			attribute = c(0x00);			/* AC000 */
  8491                                  ;
  8492                                  ;           /* Go until end of string */
  8493                                  ;           while (*s != c('\0'))                                       /* AC000 */
  8494                                  ;              BEGIN
  8495                                  ;
  8496                                  ;               /* Check for any imbedded control strings */
  8497                                  ;               switch (*s)
  8498                                  ;                  BEGIN
  8499                                  ;                   /* Check for control characters */
  8500                                  ;                   case '<':
  8501                                  ;			BEGIN
  8502                                  ;                         s++;
  8503                                  ;                         while ( (*s != c('>')) && (*s != c('\0')) ) /* AC000 */
  8504                                  ;			      BEGIN
  8505                                  ;                             	switch (*s++)
  8506                                  ;				     BEGIN
  8507                                  ;					case 'H': if (status_flag == FALSE)
  8508                                  ;						     {				
  8509                                  ;						       if (mono_flag == TRUE)				     /* AN006 */
  8510                                  ;                                                      	  attribute = (attribute & 0x80) | HIWHITE_ON_BLACK; /* AN006 */
  8511                                  ;                                                      else						     /* AN006 */
  8512                                  ;                                                      	  attribute = (attribute & 0x80) | HIWHITE_ON_BLUE;  /* AC006 */
  8513                                  ;						     }
  8514                                  ;						  else
  8515                                  ;						       attribute = (attribute & 0x80) | video_attribute;
  8516                                  ;						       break;
  8517                                  ;					case 'R': if (status_flag == FALSE)
  8518                                  ;						     {				
  8519                                  ;						       if (mono_flag == TRUE)				  /* AN006 */
  8520                                  ;                                                         attribute = (attribute & 0x80) | GRAY_ON_BLACK; /* AN006 */
  8521                                  ;                                                      else						  /* AN006 */
  8522                                  ;							  attribute = (attribute & 0x80) | WHITE_ON_BLUE; /* AC006 */
  8523                                  ;						     }
  8524                                  ;						  else
  8525                                  ;						       attribute = (attribute & 0x80) | video_attribute;
  8526                                  ;						       break;
  8527                                  ;					case 'B': attribute |= 0x80;
  8528                                  ;                                                 break;
  8529                                  ;					case 'O': attribute &= 0x7F;
  8530                                  ;                                                 break;
  8531                                  ;					case 'W': DOSBEEP(u(900),u(400)); /* AC000 */
  8532                                  ;                                                 break;
  8533                                  ;					case 'I': if (status_flag == TRUE)
  8534                                  ;						    attribute = video_attribute;
  8535                                  ;						  else
  8536                                  ;						    BEGIN
  8537                                  ;							/* display next element in the array */
  8538                                  ;                                                  	if ((mono_flag == TRUE) && (attribute == c(0x00)))  /* AN006 */
  8539                                  ;                                                      	   attribute = c(GRAY_ON_BLACK);		    /* AN006 */
  8540                                  ;                                                  	if ((mono_flag == FALSE) && (attribute == c(0x00))) /* AN006 */
  8541                                  ;                                                      	   attribute = c(WHITE_ON_BLUE);		    /* AC006 */
  8542                                  ;						    END
  8543                                  ;              					  VIOWRTCHARSTRATT(pinsert+insert_count++,u(1),row,col++,attribute_ptr,u(0));
  8544                                  ;                                                 break;
  8545                                  ;					case 'Y':                                                          /* AC011 */
  8546                                  ;                                                 BEGIN
  8547                                  ;                                                   /* display YES character in next location */
  8548                                  ;                                                   if ((mono_flag == TRUE) && (attribute == c(0x00)))      /* AN006 */
  8549                                  ;                                                      attribute = c(GRAY_ON_BLACK);                       /* AN006 */
  8550                                  ;                                                   if ((mono_flag == FALSE) && (attribute == c(0x00)))     /* AN006 */
  8551                                  ;                                                      attribute = c(WHITE_ON_BLUE);                       /* AC006 */
  8552                                  ;                                                   VIOWRTCHARSTRATT(&Yes,u(1),row,col++,attribute_ptr,u(0)); /* AC000 */
  8553                                  ;                                                   break;
  8554                                  ;                                                 END
  8555                                  ;					case 'N':                                                          /* AC011 */
  8556                                  ;                                                 BEGIN
  8557                                  ;                                                   /* display NO character in next location */
  8558                                  ;                                                   if ((mono_flag == TRUE) && (attribute == c(0x00)))      /* AN006 */
  8559                                  ;                                                      attribute = c(GRAY_ON_BLACK);                       /* AN006 */
  8560                                  ;                                                   if ((mono_flag == FALSE) && (attribute == c(0x00)))     /* AN006 */
  8561                                  ;                                                      attribute = c(WHITE_ON_BLUE);                       /* AC006 */
  8562                                  ;                                                   VIOWRTCHARSTRATT(&No,u(1),row,col++,attribute_ptr,u(0)); /* AC000 */
  8563                                  ;                                                   break;
  8564                                  ;                                                 END
  8565                                  ;					case 'S':
  8566                                  ;                                                 BEGIN
  8567                                  ;                                                   input_row = row;
  8568                                  ;                                                   input_col = col;
  8569                                  ;                                                   break;
  8570                                  ;                                                 END
  8571                                  ;					case 'C':
  8572                                  ;                                                 BEGIN
  8573                                  ;                                                   /* Clear from current position to end of line */
  8574                                  ;                                                   clear_screen(row,col,row,u(79)); /* AC000 */
  8575                                  ;                                                   break;
  8576                                  ;                                                 END
  8577                                  ;					case '\0':
  8578                                  ;                                                 BEGIN
  8579                                  ;                                                   /* Message string error - string ended in the middle of control string*/
  8580                                  ;                                                   insert[0] = c('7');	/* AC000 */
  8581                                  ;                                                   display(debug_msg);
  8582                                  ;                                                   break;
  8583                                  ;						  END
  8584                                  ;					default:
  8585                                  ;                                                 BEGIN
  8586                                  ;                                                   /* Message string error - no valid control char found */
  8587                                  ;                                                   insert[0] = c('6');	/* AC000 */
  8588                                  ;                                                   display(debug_msg);
  8589                                  ;                                                   break;
  8590                                  ;                                                 END
  8591                                  ;				   END /* Switch */
  8592                                  ;			     END /* While */
  8593                                  ;			     /* Get the pointer past the '>' */
  8594                                  ;                            s++;
  8595                                  ;                            break;
  8596                                  ;                        END /* control characters */
  8597                                  ;
  8598                                  ;                   /* Check for row,col */
  8599                                  ;                   case '':                                           /* AC000 */
  8600                                  ;			BEGIN
  8601                                  ;			     s++;
  8602                                  ;                            /* determine the row to put the message on */
  8603                                  ;                            if ( !isdigit(*s) )
  8604                                  ;				BEGIN
  8605                                  ;				   /* Message string error */
  8606                                  ;                                  insert[0] = c('2');                  /* AC000 */
  8607                                  ;                                  display(debug_msg);
  8608                                  ;				END
  8609                                  ; 			     else
  8610                                  ;				BEGIN
  8611                                  ;                                  row = row+((unsigned)(((*s++ - '0')*10)));
  8612                                  ;                                  if ( !isdigit(*s) )
  8613                                  ;                                     BEGIN
  8614                                  ;                                       /* Message string error */
  8615                                  ;                                       insert[0] = c('2');               /* AC000 */
  8616                                  ;                                       display(debug_msg);
  8617                                  ;                                     END
  8618                                  ;                                  else
  8619                                  ;                                     BEGIN
  8620                                  ;                                       row = row+((unsigned)(*s++ - '0'));
  8621                                  ;                                       /* determine the col to put the message on */
  8622                                  ;                                       if ( !isdigit(*s) )
  8623                                  ;                                          BEGIN
  8624                                  ;                                            /* Message string error */
  8625                                  ;                                            insert[0] = c('3');          /* AC000 */
  8626                                  ;                                            display(debug_msg);
  8627                                  ;                                          END
  8628                                  ;					else
  8629                                  ;                                          BEGIN
  8630                                  ;                                            col = ((unsigned)(*s++ - '0'));
  8631                                  ;                                            if ( !isdigit(*s) )
  8632                                  ;                                               BEGIN
  8633                                  ;                                                 /* Message string error */
  8634                                  ;                                                 insert[0] = c('3');      /* AC000 */
  8635                                  ;                                                 display(debug_msg);
  8636                                  ;                                               END
  8637                                  ;					     else
  8638                                  ;                                                BEGIN
  8639                                  ;                                                 col = ((unsigned)((col* 10) + (*s++ - '0')));
  8640                                  ;                                                 if (*s++ != c(''))      /* AC000 */
  8641                                  ;                                                    BEGIN
  8642                                  ;                                                      /* Message string error */
  8643                                  ;                                                      insert[0] = c('4');  /* AC000 */
  8644                                  ;                                                      display(debug_msg);
  8645                                  ;                                                    END /* 2nd sq bracket */
  8646                                  ;                                                 END /* 2nd digit col */
  8647                                  ;                                               END /* 1st digit col */
  8648                                  ;                                           END /* 2nd digit row */
  8649                                  ;                                       END /* 1st digit row */
  8650                                  ;                              		break;
  8651                                  ;				END
  8652                                  ;                   /* Handle anything else */
  8653                                  ;                   default:
  8654                                  ;			BEGIN
  8655                                  ;			   /* See if attribute set to anything */
  8656                                  ;                          if ((mono_flag == FALSE) && (attribute == c(0x00)))	/* AN006 */
  8657                                  ;			      attribute = c(WHITE_ON_BLUE);			/* AC006 */
  8658                                  ;			   if ((mono_flag == TRUE) && (attribute == c(0x00)))	/* AN006 */
  8659                                  ;			      attribute = c(GRAY_ON_BLACK);			/* AN006 */
  8660                                  ;		   ;#ifdef DBCS    /* MSKK01 07/18/89 */
  8661                                  ;		   ;       VIOWRTCHARSTRATT(s,u(1),row,col++,attribute_ptr,u(0)); /* AC000 */
  8662                                  ;			   if (IsDBCSLeadByte( (unsigned char)*s ))
  8663                                  ;			      VIOWRTCHARSTRATT(++s,u(1),row,col++,attribute_ptr,u(0)); /* AC000 */
  8664                                  ;			   s++;
  8665                                  ;		   ;#else
  8666                                  ;                          VIOWRTCHARSTRATT(s++,u(1),row,col++,attribute_ptr,u(0)); /* AC000 */
  8667                                  ;		   ;#endif
  8668                                  ;                          break;
  8669                                  ;                       END
  8670                                  ;                  END
  8671                                  ;              END /* End of string check */
  8672                                  ;          END /* No characters in string check */
  8673                                  ;       return;
  8674                                  ;
  8675                                  ;END
  8676                                  
  8677                                  ; 19/11/2018
  8678                                  
  8679                                  display:
  8680                                  		%define	col 	      bp-12 ; word
  8681                                  		%define	insert_count  bp-10 ; word
  8682                                  		%define attribute_ptr bp-8  ; dword
  8683                                  		%define	row 	      bp-4  ; word
  8684                                  		%define attribute     bp-2  ; word
  8685                                  
  8686                                  		%define _s_ 	      bp+4  ; arg_0, dword
  8687                                  
  8688 0000161A 55                      		push	bp
  8689 0000161B 89E5                    		mov	bp,sp
  8690 0000161D 83EC0C                  		sub	sp,12
  8691                                  
  8692 00001620 8D46FE                  		lea	ax,[attribute]
  8693 00001623 8946F8                  		mov	[attribute_ptr],ax
  8694 00001626 8C56FA                  		mov	[attribute_ptr+2],ss
  8695                                  
  8696                                  		;/* Initialize row and col, and index into array */
  8697 00001629 29C0                    		sub	ax,ax ; 0
  8698 0000162B 8946FC                  		mov	[row],ax
  8699 0000162E 8946F4                  		mov	[col],ax
  8700 00001631 8946F6                  		mov	[insert_count],ax
  8701                                  
  8702 00001634 8846FE                  		mov	[attribute],al ; 0 ; 19/11/2018
  8703                                  		
  8704                                  		;/* check for a request to display a null string */
  8705                                  		
  8706                                  		;if (*s == c('\0')) 
  8707 00001637 C45E04                  		les	bx,[_s_]
  8708 0000163A 26803F00                		cmp	byte [es:bx],0
  8709 0000163E 7510                    		jne	short display_1
  8710                                  		;/* Message string error */
  8711 00001640 C606[E6CC]31            		mov	byte [insert],'1'
  8712                                  		;push	word [debug_msg_seg]
  8713 00001645 1E                      		push	ds ; 17/11/2018
  8714 00001646 FF36[C09E]              		push	word [debug_msg_off]
  8715 0000164A E8CDFF                  		call	display
  8716                                  		;pop	bx	; 19/11/2018 ; (!*!*)
  8717                                  		;pop	bx
  8718 0000164D E98302                  		jmp	display_43
  8719                                  display_1:
  8720                                  		;/* There is data there, lets go handle it */
  8721                                  
  8722                                  		;if (status_flag == TRUE )
  8723                                  		; 	attribute = video_attribute;
  8724                                  
  8725 00001650 803E[D4C3]01            		cmp	byte [status_flag],1 ; TRUE
  8726 00001655 7508                    		jne	short display_2
  8727 00001657 A0[10C4]                		mov	al,[video_attribute]
  8728 0000165A 8846FE                  		mov	[attribute],al
  8729 0000165D EB03                    		jmp	short display_3 ; 19/11/2018
  8730                                  ;display_2:
  8731                                  ;		;else
  8732                                  ;		;	attribute = c(0x00);
  8733                                  ;
  8734                                  ;		;mov	byte [attribute],0 ; 19/11/2018
  8735                                  ;display_3:
  8736                                  display_2:	;/* Go until end of string */
  8737                                  
  8738                                  		; while (*s != c('\0')) 
  8739 0000165F C45E04                  		les	bx,[_s_]
  8740                                  		;cmp	byte [es:bx],0
  8741                                  		;jne	short display_4
  8742                                  display_3:
  8743                                  		; 19/11/2018
  8744 00001662 268A07                  		mov	al,[es:bx]
  8745 00001665 08C0                    		or	al,al
  8746 00001667 7503                    		jnz	short display_4		
  8747 00001669 E96702                  		jmp	display_43
  8748                                  display_4:
  8749                                  		;/* Check for any imbedded control strings */
  8750                                  		
  8751                                  		;switch (*s)
  8752                                  		
  8753                                  		; /* Check for control characters */
  8754                                  		;mov	al,[es:bx]
  8755                                  		;cbw
  8756                                  		;sub	ax,6
  8757 0000166C 30E4                    		xor	ah,ah
  8758 0000166E 2C06                    		sub	al,6 ; Check for char 06h (ACK)
  8759 00001670 7503                    		jnz	short sc_default ; default : 
  8760 00001672 E9C401                  		jmp	display_36 ; case '': 
  8761                                  sc_default:
  8762                                  		;sub	ax,'6' ; '<' (3Ch)
  8763 00001675 2C36                    		sub	al,'6' ; 19/11/2018
  8764 00001677 743F                    		jz	short display_7  ; case '<':
  8765                                  
  8766                                  		;/* Handle anything else */
  8767                                  ;default:
  8768                                  		;/* See if attribute set to anything */
  8769 00001679 803E[CAC3]00            		cmp	byte [mono_flag],0 ; FALSE
  8770 0000167E 7511                    		jne	short display_5
  8771                                  			;&&
  8772 00001680 807EFE00                		cmp	byte [attribute],0
  8773                                  		;jne	short display_5
  8774 00001684 7515                    		jne	short display_6 ; 19/11/2018
  8775 00001686 C646FE17                		mov	byte [attribute],17h ; WHITE_ON_BLUE
  8776                                  ;display_5:
  8777 0000168A 803E[CAC3]01            		cmp	byte [mono_flag],1 ; TRUE
  8778 0000168F 750A                    		jne	short display_6
  8779                                  			;&&
  8780                                  display_5: ; 19/11/2018
  8781 00001691 807EFE00                		cmp	byte [attribute],0
  8782 00001695 7504                    		jne	short display_6
  8783 00001697 C646FE07                		mov	byte [attribute],7 ; GRAY_ON_BLACK
  8784                                  display_6:
  8785                                  		;VIOWRTCHARSTRATT(s++,u(1),row,col++,attribute_ptr,u(0))
  8786 0000169B 06                      		push	es
  8787 0000169C 53                      		push	bx
  8788 0000169D FF4604                  		inc	word [_s_]
  8789 000016A0 B80100                  		mov	ax,1
  8790 000016A3 50                      		push	ax
  8791 000016A4 FF76FC                  		push	word [row]
  8792 000016A7 FF76F4                  		push	word [col]			
  8793                                  		;inc	word [col]
  8794 000016AA FE46F4                  		inc	byte [col]
  8795                                  		;push	ss ; 17/11/2018
  8796 000016AD FF76FA                  		push	word [attribute_ptr+2]	; segment
  8797 000016B0 FF76F8                  		push	word [attribute_ptr]	; offset
  8798                                  		; 19/11/2018
  8799                                  		;sub	ax,ax ; 0
  8800                                  		;push	ax
  8801 000016B3 E82302                  		call	VIOWRTCHARSTRATT
  8802                                  		;jmp	short display_3
  8803 000016B6 EBA7                    		jmp	short display_2 ; 19/11/2018
  8804                                  display_7:
  8805                                  ;case '<':
  8806                                  		;s++;
  8807 000016B8 FF4604                  		inc	word [_s_]
  8808                                  sc_break:
  8809                                  		;while ( (*s != c('>')) && (*s != c('\0')) ) /* AC000 */
  8810                                  
  8811 000016BB C45E04                  		les	bx,[_s_]
  8812 000016BE 268A07                  		mov	al,[es:bx]
  8813                                  		;cmp	byte ptr [es:bx],'>'
  8814 000016C1 3C3E                    		cmp	al,'>'
  8815 000016C3 7503                    		jne	short display_8 ; &&
  8816 000016C5 E96B01                  		jmp	display_35
  8817                                  display_8:
  8818                                  		;cmp	byte [es:bx], 0
  8819                                  		;jne	short display_9
  8820 000016C8 20C0                    		and	al,al	; cmp al,0
  8821 000016CA 7503                    		jnz	short display_9
  8822 000016CC E96401                  		jmp	display_35
  8823                                  display_9:
  8824                                  		;switch (*s++)
  8825 000016CF FF4604                  		inc	word [_s_]
  8826                                  		;mov	al,[es:bx] ; 19/11/2018
  8827                                  		;cbw
  8828                                  		;cmp	ax,'Y'
  8829 000016D2 3C59                    		cmp	al,'Y'
  8830 000016D4 7503                    		jne	short display_10
  8831 000016D6 E9DF00                  		jmp	case_Y  ; case 'Y'
  8832                                  display_10:
  8833 000016D9 7733                    		ja	short display_17
  8834                                  		; 19/11/2018
  8835                                  		;or	al,al
  8836                                  		;jnz	short display_11
  8837                                  		;jmp	case_0  ; case '\0'
  8838                                  display_11:
  8839 000016DB 2C42                    		sub	al,'B'
  8840 000016DD 7503                    		jnz	short display_12
  8841 000016DF E98A00                  		jmp	display_25  ; case 'B'
  8842                                  display_12:
  8843                                  		; AL > 0 and AL < 'Y'-'B'
  8844 000016E2 FEC8                    		dec	al ; AL = 1 ('C'-'B') ?
  8845 000016E4 7503                    		jnz	short display_13
  8846 000016E6 E93701                  		jmp	case_C	; case 'C'
  8847                                  display_13:	
  8848 000016E9 2C05                    		sub	al,5 ; AL = 5 ('H'-'C') ?
  8849 000016EB 7430                    		jz	short display_19 ; case 'H'
  8850 000016ED FEC8                    		dec	al
  8851 000016EF 7503                    		jnz	short display_14
  8852 000016F1 E98C00                  		jmp	case_I ; case 'I'
  8853                                  display_14:
  8854 000016F4 2C05                    		sub	al,5 ; AL = 5 ('N'-'I') ?
  8855 000016F6 7503                    		jnz	short display_15
  8856 000016F8 E9DD00                  		jmp	case_N	; case 'N'
  8857                                  display_15:
  8858 000016FB FEC8                    		dec	al   ; 'O' ?
  8859 000016FD 7474                    		jz	short display_26  ; case 'O'
  8860 000016FF 2C03                    		sub	al,3 ; 'R' ?
  8861 00001701 7449                    		jz	short display_23  ; case 'R'	
  8862 00001703 FEC8                    		dec	al
  8863 00001705 7503                    		jnz	short display_16
  8864 00001707 E90701                  		jmp	case_S  ; case 'S'
  8865                                  display_16:
  8866 0000170A 2C04                    		sub	al,4  ; 'W' ?
  8867 0000170C 746C                    		jz	short case_W ; case 'W'
  8868                                  display_17:
  8869                                  ;default:
  8870                                  		;/* Message string error - no valid control char found */
  8871 0000170E C606[E6CC]36            		mov	byte [insert],'6'
  8872                                  display_18:
  8873                                  		;push	word [debug_msg_seg]
  8874 00001713 1E                      		push	ds ; 17/11/2018 
  8875 00001714 FF36[C09E]              		push	word [debug_msg_off]
  8876 00001718 E8FFFE                  		call	display
  8877                                  		;pop	bx	; 19/11/2018 ; (!*!*)
  8878                                  		;pop	bx
  8879 0000171B EB9E                    		jmp	short sc_break
  8880                                  display_19:
  8881                                  ;case 'H':	;if (status_flag == FALSE)
  8882 0000171D 803E[D4C3]00            		cmp	byte [status_flag],0
  8883 00001722 751D                    		jne	short display_22
  8884 00001724 803E[CAC3]01            		cmp	byte [mono_flag],1
  8885 00001729 7509                    		jne	short display_20
  8886                                  		;attribute = (attribute & 0x80) | HIWHITE_ON_BLACK;
  8887 0000172B 8A46FE                  		mov	al,[attribute]
  8888 0000172E 248F                    		and	al,8Fh
  8889 00001730 0C0F                    		or	al,0Fh ; HIWHITE_ON_BLACK
  8890 00001732 EB07                    		jmp	short display_21
  8891                                  display_20:
  8892 00001734 8A46FE                  		mov	al,[attribute]
  8893                                  		;attribute = (attribute & 0x80) | WHITE_ON_BLUE;
  8894 00001737 249F                    		and	al,9Fh
  8895 00001739 0C1F                    		or	al,1Fh ; WHITE_ON_BLUE
  8896                                  display_21:
  8897 0000173B 8846FE                  		mov	byte [attribute],al
  8898 0000173E E97AFF                  		jmp	sc_break
  8899                                  display_22:	
  8900                                  		;(status_flag == TRUE)
  8901                                  		;attribute = (attribute & 0x80) | video_attribute;
  8902 00001741 8A46FE                  		mov	al,[attribute]
  8903 00001744 2480                    		and	al,80h
  8904 00001746 0A06[10C4]              		or	al,[video_attribute]
  8905 0000174A EBEF                    		jmp	short display_21
  8906                                  display_23:
  8907                                  ;case 'R':
  8908                                  		;if (status_flag == FALSE)
  8909 0000174C 803E[D4C3]00            		cmp	byte [status_flag],0
  8910 00001751 75EE                    		jne	short display_22
  8911                                  		;if (mono_flag == TRUE) 
  8912 00001753 803E[CAC3]01            		cmp	byte [mono_flag],1
  8913 00001758 7509                    		jne	short display_24
  8914                                  		;attribute = (attribute & 0x80) | GRAY_ON_BLACK
  8915 0000175A 8A46FE                  		mov	al,[attribute]
  8916 0000175D 2487                    		and	al,87h
  8917 0000175F 0C07                    		or	al,7  ; GRAY_ON_BLACK
  8918 00001761 EBD8                    		jmp	short display_21
  8919                                  display_24:
  8920                                  		;attribute = (attribute & 0x80) | WHITE_ON_BLUE;
  8921 00001763 8A46FE                  		mov	al,[attribute]
  8922 00001766 2497                    		and	al,97h
  8923 00001768 0C17                    		or	al,17h	; WHITE_ON_BLUE
  8924 0000176A EBCF                    		jmp	short display_21
  8925                                  display_25:
  8926                                  ; case 'B':	;attribute |= 0x80;
  8927 0000176C 804EFE80                		or	byte [attribute],80h
  8928 00001770 E948FF                  		jmp	sc_break
  8929                                  display_26:
  8930                                  ;case 'O':	;attribute &= 0x7F;
  8931 00001773 8066FE7F                		and	byte [attribute],7Fh
  8932 00001777 E941FF                  		jmp	sc_break
  8933                                  case_W:
  8934                                  		;DOSBEEP(u(900),u(400))
  8935                                  		;mov	ax,900
  8936                                  		;push	ax
  8937                                  		;mov	ax,400
  8938                                  		;push	ax
  8939 0000177A E8C001                  		call	DOSBEEP  ; 01/01/2019
  8940 0000177D E93BFF                  		jmp	sc_break
  8941                                  case_I:
  8942                                  		;if (status_flag == TRUE)
  8943 00001780 803E[D4C3]01            		cmp	byte [status_flag],1
  8944 00001785 7508                    		jne	short display_27
  8945                                  				;attribute = video_attribute;
  8946 00001787 A0[10C4]                		mov	al,[video_attribute]
  8947 0000178A 8846FE                  		mov	[attribute],al
  8948 0000178D EB1D                    		jmp	short display_29
  8949                                  
  8950                                  display_27:
  8951                                  		;(status_flag == FALSE)
  8952                                  
  8953                                  		;/* display next element in the array */
  8954                                  
  8955                                  		;if ((mono_flag == TRUE) &&
  8956 0000178F 803E[CAC3]01            		cmp	byte [mono_flag],1
  8957 00001794 750C                    		jne	short display_28
  8958                                  		; (attribute == c(0x00)))
  8959 00001796 807EFE00                		cmp	byte [attribute],0
  8960                                  		;jne	short display_28
  8961 0000179A 7510                    		jne	short display_29 ; 17/11/2018
  8962                                  		;attribute = c(GRAY_ON_BLACK);      
  8963 0000179C C646FE07                		mov	byte [attribute],7 ; GRAY_ON_BLACK
  8964 000017A0 EB0A                    		jmp	short display_29 ; 17/11/2018
  8965                                  ;display_28:
  8966                                  ;		;if ((mono_flag == FALSE) &&
  8967                                  ;		cmp	byte [mono_flag],0
  8968                                  ;		jne	short display_29
  8969                                  display_28: ; 17/11/2018
  8970                                  		;(attribute == c(0x00)))
  8971 000017A2 807EFE00                		cmp	byte [attribute],0
  8972 000017A6 7504                    		jne	short display_29
  8973                                  		;attribute = c(WHITE_ON_BLUE);
  8974 000017A8 C646FE17                		mov	byte [attribute],17h ; WHITE_ON_BLUE
  8975                                  display_29:
  8976                                  		;VIOWRTCHARSTRATT(pinsert+insert_count++,u(1),row,col++,attribute_ptr,u(0));	
  8977                                  
  8978                                  		; pinsert+insert_count++
  8979 000017AC 8B46F6                  		mov	ax,[insert_count]
  8980 000017AF FF46F6                  		inc	word [insert_count]
  8981 000017B2 0306[8A70]              		add	ax,[pinsert]
  8982 000017B6 EB3E                    		jmp	short display_34
  8983                                  case_Y:
  8984                                  		;/* display YES character in next location */
  8985                                  
  8986 000017B8 803E[CAC3]01            		cmp	byte [mono_flag],1 ; TRUE
  8987 000017BD 750A                    		jne	short display_30
  8988                                  			; &&
  8989 000017BF 807EFE00                		cmp	byte [attribute],0
  8990                                  		;jne	short display_30
  8991 000017C3 750E                    		jne	short display_31 ; 17/11/2018
  8992                                  		;if ((mono_flag == TRUE) && (attribute == c(0x00))) 
  8993 000017C5 C646FE07                		mov	byte [attribute],7 ;attribute = c(GRAY_ON_BLACK);
  8994                                  ;display_30:	
  8995                                  ;		;if ((mono_flag == FALSE) && (attribute == c(0x00)))
  8996                                  ;		cmp	byte [mono_flag],0  ; FALSE
  8997                                  ;		jne	short display_31
  8998                                  			; &&
  8999                                  display_30: ; 17/11/2018
  9000 000017C9 807EFE00                		cmp	byte [attribute],0
  9001 000017CD 7504                    		jne	short display_31
  9002 000017CF C646FE17                		mov	byte [attribute], 17h ;attribute = c(WHITE_ON_BLUE);
  9003                                  display_31:
  9004                                  		;VIOWRTCHARSTRATT(&Yes,u(1),row,col++,attribute_ptr,u(0));
  9005                                  
  9006 000017D3 B8[CBC3]                		mov	ax,Yes	; &YES, offset Yes
  9007 000017D6 EB1E                    		jmp	short display_34
  9008                                  case_N:
  9009                                  		;/* display NO character in next location */
  9010                                  
  9011 000017D8 803E[CAC3]01            		cmp	byte [mono_flag],1 ; TRUE
  9012 000017DD 750A                    		jne	short display_32
  9013                                  			; &&
  9014 000017DF 807EFE00                		cmp	byte [attribute],0
  9015                                  		;jne	short display_32
  9016 000017E3 750E                    		jne	short display_33 ; 17/11/2018
  9017                                  		;if ((mono_flag == TRUE) && (attribute == c(0x00))) 
  9018 000017E5 C646FE07                		mov	byte [attribute],7 ;attribute = c(GRAY_ON_BLACK);
  9019                                  ;display_32:
  9020                                  ;		;if ((mono_flag == FALSE) && (attribute == c(0x00))) 
  9021                                  ;		cmp	byte [mono_flag],0 ; FALSE
  9022                                  ;		jne	short display_33
  9023                                  			; &&
  9024                                  display_32: ; 17/11/2018	
  9025 000017E9 807EFE00                		cmp	byte [attribute],0
  9026 000017ED 7504                    		jne	short display_33
  9027 000017EF C646FE17                		mov	byte [attribute],17h ;attribute = c(WHITE_ON_BLUE);
  9028                                  display_33:
  9029 000017F3 B8[9EA0]                		mov	ax,No	; &NO, offset No
  9030                                  
  9031                                  		;VIOWRTCHARSTRATT(&No,u(1),row,col++,attribute_ptr,u(0));
  9032                                  display_34:
  9033                                  		;VIOWRTCHARSTRATT(pinsert+insert_count++,u(1),row,col++,attribute_ptr,u(0));
  9034                                  		;VIOWRTCHARSTRATT(&Yes,u(1),row,col++,attribute_ptr,u(0));
  9035                                  
  9036                                  		; String address (far) to be written
  9037 000017F6 1E                      		push	ds
  9038 000017F7 50                      		push	ax ; pinsert+insert_count++ (display_29) or &YES (display_31)
  9039                                  			   ; or &NO (display_33)
  9040                                  		; Length of string	
  9041 000017F8 B80100                  		mov	ax,1
  9042 000017FB 50                      		push	ax
  9043                                  		; Starting row position for output
  9044 000017FC FF76FC                  		push	word [row]
  9045                                  		; Starting column position for output
  9046 000017FF FF76F4                  		push	word [col]
  9047                                  		;inc	word [col]
  9048 00001802 FE46F4                  		inc	byte [col]
  9049                                  		; Attribute address (far) to be replicated
  9050 00001805 FF76FA                  		push	word [attribute_ptr+2] ; segment
  9051 00001808 FF76F8                  		push	word [attribute_ptr] ; offset
  9052                                  		; Video handle (!is not used!)
  9053                                  		;sub	ax,ax
  9054                                  		;push	ax
  9055 0000180B E8CB00                  		call	VIOWRTCHARSTRATT
  9056 0000180E E9AAFE                  		jmp	sc_break
  9057                                  case_S:
  9058                                  ;case 'S':
  9059 00001811 8B46FC                  		mov	ax,[row]
  9060 00001814 A3[3EA1]                		mov	[input_row],ax
  9061 00001817 8B46F4                  		mov	ax,[col]
  9062 0000181A A3[9CA0]                		mov	[input_col],ax
  9063 0000181D E99BFE                  		jmp	sc_break
  9064                                  case_C:
  9065                                  ;case 'C':
  9066                                  		; /* Clear from current position to end of line */
  9067                                  		
  9068                                  		;clear_screen(row,col,row,u(79)); 
  9069 00001820 B84F00                  		mov	ax,79
  9070 00001823 50                      		push	ax
  9071 00001824 FF76FC                  		push	word [row]
  9072 00001827 FF76F4                  		push	word [col]
  9073 0000182A FF76FC                  		push	word [row]
  9074 0000182D E866FC                  		call	clear_screen ; clear_screen_down
  9075                                  		;add	sp,8
  9076 00001830 E988FE                  		jmp	sc_break
  9077                                  ;case_0:	
  9078                                  ;;case '\0': 
  9079                                  ;	;/* Message string error - string ended in the middle of control string*/
  9080                                  ;		mov	byte [insert],'7'
  9081                                  ;		jmp	display_18
  9082                                  display_35:
  9083                                  		; /* Get the pointer past the '>' */
  9084                                  		;s++;
  9085 00001833 FF4604                  		inc	word [_s_]
  9086                                  		;break;
  9087                                  		;jmp	display_3
  9088 00001836 E926FE                  		jmp	display_2 ; 19/11/2018
  9089                                  		;END /* control characters */
  9090                                  display_36:	
  9091                                  		;/* Check for row,col */
  9092                                  ;case '':
  9093                                  		;s++;
  9094 00001839 FF4604                  		inc	word [_s_]
  9095                                  
  9096                                  		;/* determine the row to put the message on */
  9097                                  
  9098                                  		;if ( !isdigit(*s) )
  9099 0000183C 8B5E04                  		mov	bx,[_s_]
  9100 0000183F 268A07                  		mov	al,[es:bx]
  9101                                  		;cbw
  9102 00001842 89C3                    		mov	bx,ax
  9103 00001844 F687[FC9E]04            		test	byte [isdigit+bx],4
  9104 00001849 741D                    		jz	short display_37
  9105                                  		
  9106                                  		;row = row+((unsigned)(((*s++ - '0')*10)));
  9107                                  		;mov	bx,[_s_]
  9108 0000184B FF4604                  		inc	word [_s_]
  9109                                  		;mov	al,10
  9110                                  		;imul	byte [es:bx]
  9111 0000184E 2C30                    		sub	al,'0' ; 19/11/2018
  9112 00001850 B30A                    		mov	bl,10
  9113 00001852 F6E3                    		mul	bl 
  9114                                  		;sub	ax,480 ; 1E0h (10*ASC('0'))
  9115 00001854 0146FC                  		add	[row],ax
  9116                                  		
  9117                                  		;if ( !isdigit(*s) )
  9118 00001857 8B5E04                  		mov	bx,[_s_]
  9119 0000185A 268A07                  		mov	al,[es:bx] ; **
  9120                                  		;cbw	
  9121 0000185D 30E4                    		xor	ah,ah ; 19/11/2018
  9122 0000185F 89C3                    		mov	bx,ax
  9123 00001861 F687[FC9E]04            		test	byte [isdigit+bx],4
  9124 00001866 7507                    		jnz	short display_38
  9125                                  display_37:
  9126                                  		;/* Message string error */
  9127 00001868 C606[E6CC]32            		mov	byte [insert],'2'
  9128 0000186D EB33                    		jmp	short display_40
  9129                                  display_38:
  9130                                  		;row = row+((unsigned)(*s++ - '0'));
  9131                                  		;mov	bx,[_s_] ; **
  9132 0000186F FF4604                  		inc	word [_s_]
  9133                                  		;mov	al,[es:bx] ; **
  9134                                  		;;cbw
  9135                                  		;;sub	ax,'0'
  9136 00001872 2C30                    		sub	al,'0'
  9137                                  		;xor	ah,ah
  9138 00001874 0146FC                  		add	[row],ax
  9139                                  		
  9140                                  		;/* determine the col to put the message on */
  9141                                  
  9142                                  		;if ( !isdigit(*s) )
  9143 00001877 8B5E04                  		mov	bx,[_s_]
  9144 0000187A 268A07                  		mov	al,[es:bx] ; **
  9145                                  		;cbw
  9146 0000187D 89C3                    		mov	bx,ax
  9147 0000187F F687[FC9E]04            		test	byte [isdigit+bx],4
  9148 00001884 7417                    		jz	short display_39
  9149                                  
  9150                                  		;col = ((uns/igned)(*s++ - '0'));
  9151                                  		;mov	bx,[_s_] ; **
  9152 00001886 FF4604                  		inc	word [_s_]
  9153                                  		;mov	al,[es:bx]
  9154                                  		;;cbw
  9155                                  		;;sub	ax,'0'
  9156 00001889 2C30                    		sub	al,'0' ; **
  9157                                  		;xor	ah,ah
  9158 0000188B 8946F4                  		mov	[col],ax
  9159                                  		
  9160                                  		;if ( !isdigit(*s) )
  9161 0000188E 8B5E04                  		mov	bx,[_s_]
  9162 00001891 268A07                  		mov	al,[es:bx]
  9163                                  		;cbw
  9164 00001894 89C3                    		mov	bx,ax ; *
  9165 00001896 F687[FC9E]04            		test	byte [isdigit+bx],4
  9166 0000189B 7510                    		jnz	short display_41
  9167                                  display_39:	
  9168                                  		;/* Message string error */
  9169 0000189D C606[E6CC]33            		mov	byte [insert],'3'
  9170                                  display_40:
  9171                                  		;push	word [debug_msg_seg]
  9172 000018A2 1E                      		push	ds ; 17/11/2018
  9173 000018A3 FF36[C09E]              		push	word [debug_msg_off]
  9174 000018A7 E870FD                  		call	display
  9175                                  		;pop	bx ; 19/11/2018 ; (!*!*)
  9176                                  		;pop	bx
  9177                                  		;jmp	display_3
  9178 000018AA E9B2FD                  		jmp	display_2 ; 19/11/2018
  9179                                  display_41:
  9180                                  		;col = ((unsigned)((col* 10) + (*s++ - '0')));
  9181                                  		;mov	ax,10
  9182                                  		;mul	word [col]
  9183                                  		; 19/11/2018
  9184 000018AD B00A                    		mov	al,10
  9185 000018AF F666F4                  		mul	byte [col]
  9186                                  		;mov	bx,[_s_]
  9187 000018B2 FF4604                  		inc	word [_s_]
  9188                                  		;mov	cx,ax ; 19/11/2018
  9189                                  		;mov	al,[es:bx]
  9190                                  		;;cbw
  9191                                  		;;add	cx,ax
  9192                                  		;;sub	cx,'0'
  9193                                  		;sub	al,'0'
  9194                                  		;xor	ah,ah
  9195                                  		;add	cx,ax
  9196                                  		; 19/11/2018
  9197 000018B5 80EB30                  		sub	bl,'0' ; *
  9198                                  		;add	cx,bx ; *
  9199                                  		;mov	[col],cx
  9200 000018B8 01D8                    		add	ax,bx ; *
  9201 000018BA 8946F4                  		mov	[col],ax
  9202                                  
  9203                                  		;if (*s++ != c('')) 
  9204 000018BD 8B5E04                  		mov	bx,[_s_]
  9205 000018C0 FF4604                  		inc	word [_s_]
  9206 000018C3 26803F06                		cmp	byte [es:bx],6
  9207 000018C7 7503                    		jne	short display_42
  9208                                  		;jmp	display_3
  9209 000018C9 E993FD                  		jmp	display_2 ; 19/11/2018
  9210                                  display_42:
  9211                                  		;/* Message string error */
  9212 000018CC C606[E6CC]34            		mov	byte [insert],'4'
  9213 000018D1 EBCF                    		jmp	short display_40
  9214                                  display_43:
  9215 000018D3 89EC                    		mov	sp,bp
  9216 000018D5 5D                      		pop	bp
  9217                                  		;retn
  9218 000018D6 C20400                  		retn	4 ; 19/11/2018 (!*!*)
  9219                                  
  9220                                  ; video.asm (MSDOS 6.0, 1991)
  9221                                  ; ----------------------------------------------------------------------------
  9222                                  ; 17/11/2018 - Modified for NASM syntax & FDISK subroutines (by Erdogan Tan)
  9223                                  
  9224                                  ; doscall.h (FDISK, MSDOS 6.0, 1991)
  9225                                  
  9226                                  ;/***	VioWrtCharStrAtt - Write Character String With Attribute
  9227                                  ; *
  9228                                  ; *	Write a character string with repeated attribute to the display
  9229                                  ; */
  9230                                  
  9231                                  ;extern unsigned far pascal VIOWRTCHARSTRATT (
  9232                                  ;	char far *,			/* String to be written */
  9233                                  ;	unsigned,			/* Length of string */
  9234                                  ;	unsigned,			/* Starting position for output (row) */
  9235                                  ;	unsigned,			/* Starting position for output (col) */
  9236                                  ;	char far *,			/* Attribute to be replicated */
  9237                                  ;	unsigned );			/* Vio Handle */
  9238                                  
  9239                                  ; ============================================================================
  9240                                  ; Write string (with specified attribute) at specified cursor position
  9241                                  ; ============================================================================
  9242                                  ; Disassembled from (PCDOS 7.0) FDISK.COM (Segment 3, Offset 00C3h)
  9243                                  ; Modified for NASM syntax & FDISK (v2) subroutines (by Erdogan Tan)
  9244                                  ; 17/11/2018
  9245                                  
  9246                                  VIOWRTCHARSTRATT:  ; near procedure  (it was FAR proc in original FDISK.COM)	
  9247                                  
  9248                                  	;%define _hnd-	bp+4  ; word   ; Vio Handle (!is not used!)
  9249                                  	 	
  9250                                  	%define _atr_	bp+4  ; bp+6  ; dword  ; Attribute ptr
  9251                                  	%define _col_	bp+8  ; bp+10 ; word   ; Column 
  9252                                  	%define _row_	bp+10 ; bp+12 ; word   ; Row	
  9253                                  	%define	_cnt_	bp+12 ; bp+14 ; word   ; Count
  9254                                  	%define _str_	bp+14 ; bp+16 ; dword  ; String ptr
  9255                                  
  9256 000018D9 55                      		push	bp
  9257 000018DA 89E5                    		mov	bp,sp
  9258                                  
  9259 000018DC 53                      		push	bx
  9260 000018DD 51                      		push	cx
  9261 000018DE 52                      		push	dx
  9262 000018DF 56                      		push	si
  9263 000018E0 57                      		push	di
  9264 000018E1 1E                      		push	ds
  9265                                  		;push	es
  9266                                  		;push	ss
  9267                                  		;push	bp
  9268                                  
  9269 000018E2 28FF                    		sub	bh,bh		; Video page 0
  9270                                  		;sub	ax,ax
  9271                                  		;mov	dx,[_col_]	; Put screen column in DL
  9272 000018E4 8A5608                  		mov	dl,[_col_]
  9273                                  
  9274 000018E7 80FA50                  		cmp	dl,80		; Column limit check
  9275                                  		;jg	short viowchratt_2
  9276 000018EA 7342                    		jnb	short viowchratt_2 ; 10/12/2018
  9277                                  		;mov	ax,[_row_]
  9278                                  		;cmp	al,25		; Row limit check
  9279 000018EC 8A760A                  		mov	dh,[_row_]
  9280 000018EF 80FE19                  		cmp	dh,25
  9281                                  		;jg	short viowchratt_2
  9282 000018F2 733A                    		jnb	short viowchratt_2 ; 10/12/2018
  9283                                  		
  9284                                  		; Set cursor to Row,Col
  9285                                  		;mov	dh,al		; Put screen row in DH
  9286 000018F4 B402                    		mov	ah,2		; BIOS set cursor function
  9287                                  		
  9288                                  		;push	bx
  9289                                  		;push	cx
  9290                                  		;push	dx
  9291                                  		;push	si
  9292                                  		;push	di
  9293                                  		;push	ds
  9294                                  		;push	es
  9295                                  		;push	ss
  9296                                  		;push	bp
  9297                                  				; - VIDEO - SET	CURSOR POSITION
  9298 000018F6 CD10                    		int	10h	; DH,DL	= row, column (0,0 = upper left)
  9299                                  				; BH = page number
  9300                                  		;pop	bp
  9301                                  		;pop	ss
  9302                                  		;pop	es
  9303                                  		;pop	ds
  9304                                  		;pop	di
  9305                                  		;pop	si
  9306                                  		;pop	dx
  9307                                  		;pop	cx
  9308                                  		;pop	bx
  9309                                  
  9310 000018F8 C57604                  		lds	si,[_atr_]
  9311 000018FB 8A1C                    		mov	bl,[si] 	; Attribute or color of character
  9312 000018FD C5760E                  		lds	si,[_str_]
  9313 00001900 8B7E0C                  		mov	di,[_cnt_] 	; String length (count of string characters)
  9314                                  viowchratt_0:
  9315                                  		;mov	al,[si] 	; ASCII code of character to be written
  9316 00001903 AC                      		lodsb	; 17/11/2017
  9317                                  
  9318 00001904 B409                    		mov	ah,9 		; Function: Write character or attribute 
  9319                                  					;           at current cursor position
  9320 00001906 B90100                  		mov	cx,1		; Number of repetitions
  9321                                  		
  9322                                  		;push	bx
  9323                                  		;push	cx
  9324                                  		;push	dx
  9325                                  		;push	si
  9326                                  		;push	di
  9327                                  		;push	ds
  9328                                  		;push	es
  9329                                  		;push	ss
  9330                                  		;push	bp
  9331                                  				; - VIDEO - WRITE ATTRIBUTES/CHARACTERS	AT CURSOR POSITION
  9332 00001909 CD10                    		int	10h	; AL = character, BH = display page
  9333                                  				; BL = attributes of character (alpha modes) or	color (graphics	modes)
  9334                                  				; CX = number of times to write	character
  9335                                  		;pop	bp
  9336                                  		;pop	ss
  9337                                  		;pop	es
  9338                                  		;pop	ds
  9339                                  		;pop	di
  9340                                  		;pop	si
  9341                                  		;pop	dx
  9342                                  		;pop	cx
  9343                                  		;pop	bx
  9344                                  		
  9345                                  		;inc	si		; next char (ptr) ; 17/11/2017
  9346 0000190B 4F                      		dec	di		; decrease count
  9347 0000190C FEC2                    		inc	dl		; next column
  9348 0000190E 80FA50                  		cmp	dl,80		; column limit check
  9349 00001911 750E                    		jne	short viowchratt_1 ; ok
  9350 00001913 FEC6                    		inc	dh		; next row (and)
  9351 00001915 B200                    		mov	dl,0		; column 0
  9352 00001917 80FE19                  		cmp	dh,25		; Check row limit
  9353 0000191A 7505                    		jne	short viowchratt_1 ; ok
  9354 0000191C B80100                  		mov	ax,1		; Error 1 (string could not be written completely)
  9355 0000191F EB10                    		jmp	short viowchratt_3
  9356                                  		;nop
  9357                                  viowchratt_1:
  9358 00001921 B402                    		mov	ah,2		; BIOS set cursor function
  9359                                  
  9360                                  		;push	bx
  9361                                  		;push	cx
  9362                                  		;push	dx
  9363                                  		;push	si
  9364                                  		;push	di
  9365                                  		;push	ds
  9366                                  		;push	es
  9367                                  		;push	ss
  9368                                  		;push	bp
  9369                                  		
  9370 00001923 CD10                    		int	10h	; - VIDEO - SET	CURSOR POSITION
  9371                                  				; DH,DL	= row, column (0,0 = upper left)
  9372                                  				; BH = page number
  9373                                  		;pop	bp
  9374                                  		;pop	ss
  9375                                  		;pop	es
  9376                                  		;pop	ds
  9377                                  		;pop	di
  9378                                  		;pop	si
  9379                                  		;pop	dx
  9380                                  		;pop	cx
  9381                                  		;pop	bx
  9382                                  		
  9383 00001925 83FF00                  		cmp	di,0	; is countdown completed?
  9384 00001928 75D9                    		jne	short viowchratt_0 ; No
  9385                                  				; Yes	
  9386 0000192A 29C0                    		sub	ax,ax	; OK (successful, string written completely)
  9387                                  
  9388 0000192C EB03                    		jmp	short viowchratt_3 ; 17/11/2018 
  9389                                  viowchratt_2:
  9390 0000192E B80200                  		mov	ax,2	; Error 2 (invalid column or row value)
  9391                                  viowchratt_3:
  9392                                  		;pop	bp
  9393                                  		;pop	ss
  9394                                  		;pop	es
  9395 00001931 1F                      		pop	ds
  9396 00001932 5F                      		pop	di
  9397 00001933 5E                      		pop	si
  9398 00001934 5A                      		pop	dx
  9399 00001935 59                      		pop	cx
  9400 00001936 5B                      		pop	bx
  9401 00001937 89EC                    		mov	sp,bp
  9402 00001939 5D                      		pop	bp
  9403                                  		;retn	16	; ? (with video handle) ?
  9404 0000193A C20E00                  		retn	14	; (without video handle)
  9405                                  
  9406                                  ; DOSBEEP (IBM PC-DOS 7.0 FDISK.COM)
  9407                                  ; ----------------------------------------------------------------------------
  9408                                  ; 17/11/2018 - Modified for NASM syntax & FDISK subroutines (by Erdogan Tan)
  9409                                  
  9410                                  ; ============================================================================
  9411                                  ; DOSBEEP
  9412                                  ; ============================================================================
  9413                                  ; Disassembled from (PCDOS 7.0) FDISK.COM (Segment 2, Offset 0000h)
  9414                                  ; Modified for NASM syntax & FDISK (v2) subroutines (by Erdogan Tan)
  9415                                  ; 17/11/2018 
  9416                                  
  9417                                  ; doscall.h (FDISK, MSDOS 6.0, 1991)
  9418                                  
  9419                                  ;/***	DosBeep - Generate Sound From Speaker */
  9420                                  ;
  9421                                  ;extern unsigned far pascal DOSBEEP (
  9422                                  ;	unsigned,			/* Hertz (25H-7FFFH) */
  9423                                  ;	unsigned );			/* Length of sound  in ms */
  9424                                  
  9425                                  DOSBEEP:	; near procedure (it was FAR proc in original FDISK.COM)	
  9426                                  
  9427                                  	%define	duration  bp+4 ; bp+6 (far return) ; word
  9428                                  	%define frequency bp+6 ; bp+8 (far return) ; word
  9429                                  
  9430                                  		;push	bp
  9431                                  		;mov	bp,sp
  9432                                  		
  9433 0000193D 53                      		push	bx
  9434 0000193E 51                      		push	cx
  9435 0000193F 52                      		push	dx
  9436                                  		
  9437                                  		;push	si
  9438                                  		;push	di
  9439                                  		;push	ds
  9440                                  		;push	es
  9441                                  		;push	ss
  9442                                  		;push	bp
  9443                                  
  9444                                  		; 01/01/2019 (same frequency and duration for all DOSBEEPs)
  9445 00001940 BB8403                  		mov	bx,900 ; frequency
  9446 00001943 B99001                  		mov	cx,400 ; duration	
  9447                                  
  9448                                  		; set mode control register
  9449                                  
  9450 00001946 B0B6                    		mov	al,0B6h ; 10-11-011-0b
  9451                                  				;  10b - timer counter 2
  9452                                  				;  11b - write LSB then MSB
  9453                                  				; 011b - mode 3 - generate square wave
  9454                                  				;   0b - binary counter
  9455                                  
  9456 00001948 E643                    		out	43h,al	; Timer	8253-5 (AT: 8254.2).
  9457                                  
  9458 0000194A BA1200                  		mov	dx,12h 	 ; 18
  9459 0000194D B87029                  		mov	ax,2970h ; 10608
  9460                                  			; DX:AX = 122970h ; 1190256 (!?)
  9461                                  				; Note: This dividend value was/is 1193180 commonly
  9462                                  
  9463                                  		; 01/01/2019 (900 Hertz and 400 milliseconds for all DOSBEEPs)
  9464                                  
  9465                                  		;mov	cx,[frequency]	; value of frequency into CX
  9466                                  		;mov	bx,37	; Minimum 37 Hz
  9467                                  		;cmp	cx,bx
  9468                                  		;jl	short dosbeep_3 ; not a proper value (very low)
  9469                                  		;mov	bx,32767 ; Maximum 32767 Hz
  9470                                  		;cmp	cx,bx
  9471                                  		;jg	short dosbeep_3 ; not a proper value (very high)
  9472                                  
  9473                                  		;div	cx
  9474 00001950 F7F3                    		div	bx	; 01/01/2019
  9475 00001952 E642                    		out	42h,al	; counter 2 divisor, LSB
  9476 00001954 88E0                    		mov	al,ah
  9477 00001956 E642                    		out	42h,al	; counter 2 divisor, MSB
  9478                                  
  9479                                  		; turn the sound on
  9480                                  
  9481 00001958 E461                    		in	al,61h  ; read PPI port
  9482                                  				
  9483                                  				; PC/XT	PPI port B bits:
  9484                                  				; 0: Tmr 2 gate	--> OR	03H=spkr ON
  9485                                  				; 1: Tmr 2 data	-|  AND	0FCh=spkr OFF
  9486                                  				; 3: 1=read high switches
  9487                                  				; 4: 0=enable RAM parity checking
  9488                                  				; 5: 0=enable I/O channel check
  9489                                  				; 6: 0=hold keyboard clock low
  9490                                  				; 7: 0=enable kbrd
  9491                                  
  9492 0000195A 88C4                    		mov	ah,al	; save PPI port bits/status
  9493                                  
  9494 0000195C 0C03                    		or	al,3	; set bits 0 and 1 of port 61h to 1
  9495 0000195E E661                    		out	61h,al	; turn speaker and timer 2 clock on
  9496                                  
  9497                                  		;mov	cx,[duration] ; value of the duration into CX
  9498                                  dosbeep_1:
  9499 00001960 BBC400                  		mov	bx,196  ; factor to convert milliseconds to loop count
  9500                                  				; (196 may be experimental, depending on CPU speed)
  9501                                  dosbeep_2:
  9502 00001963 4B                      		dec	bx
  9503 00001964 75FD                    		jnz	short dosbeep_2  
  9504                                  				; delay depends on countdown start value and CPU speed 
  9505 00001966 E2F8                    		loop	dosbeep_1
  9506                                  
  9507 00001968 88E0                    		mov	al,ah	; restore port 61h bits/status
  9508 0000196A E661                    		out	61h,al	; (turn off speaker, restore frq)
  9509                                  
  9510 0000196C 29C0                    		sub	ax,ax ; 0
  9511                                  ;		jmp	short dosbeep_4  ; OK
  9512                                  ;		;nop
  9513                                  ;dosbeep_3:
  9514                                  ;		mov	ax,2	; Error (invalid freq values)
  9515                                  dosbeep_4:
  9516                                  		;pop	bp
  9517                                  		;pop	ss
  9518                                  		;pop	es
  9519                                  		;pop	ds
  9520                                  		;pop	di
  9521                                  		;pop	si
  9522                                  		
  9523 0000196E 5A                      		pop	dx
  9524 0000196F 59                      		pop	cx
  9525 00001970 5B                      		pop	bx
  9526                                  
  9527                                  		;mov	sp,bp
  9528                                  		;pop	bp
  9529                                  		;retf	4
  9530                                  		;retn	4	; return and clean stack
  9531                                  
  9532 00001971 C3                      		retn	; 01/01/2019
  9533                                  
  9534                                  ; ----------------------------------------------------------------------------
  9535                                  ; fdisk.c (FDISK, MSDOS 6.0, 1991)	
  9536                                  ; ----------------------------------------------------------------------------
  9537                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 20/11/2018)
  9538                                  
  9539                                  ; 26/11/2018
  9540                                  ; hdisk.h ; MSDOS 6.0, 1991
  9541                                  ;/***************************************************************************/
  9542                                  ;/* Hard disk partition record																*/
  9543                                  ;/***************************************************************************/
  9544                                  ;
  9545                                  ;struct	Part
  9546                                  ;{
  9547                                  ;   unsigned char  BootIndicator;   /* If 80h means this is boot partition */
  9548                                  ;   unsigned char  StartHead;	    /* Partition starting head based 0     */
  9549                                  ;   unsigned char  StartSector;	    /* Partition starting sector based 1   */
  9550                                  ;   unsigned char  StartCylinder;   /* Partion starting track based 0      */
  9551                                  ;   	
  9552                                  ;   unsigned char  SystemIndicator; /* Partition type signature field      */
  9553                                  ;   unsigned char  EndHead; 	    /* Partition ending head based 0       */
  9554                                  ;   unsigned char  EndSector;	    /* Partition ending sector based 1     */
  9555                                  ;   unsigned char  EndCylinder;	    /* Partition ending track based 0      */
  9556                                  ;   
  9557                                  ;   unsigned long  RelativeSector;  /* Physcial starting sector based 0    */
  9558                                  ;   unsigned long  TotalSectors;    /* Total physical sectors in partition */
  9559                                  ;};
  9560                                  
  9561                                  
  9562                                  ; 23/11/2018
  9563                                  
  9564                                  ; Partition Table Entry Structure (at offset 1BEh in MasterBoot sector)
  9565                                  
  9566                                  struc pt_entry	; partition
  9567 00000000 <res 00000001>          .boot_ind: 	resb 1	; Active (bootable, 80h) or not (0)
  9568 00000001 <res 00000001>          .start_head:	resb 1	; Beginning head
  9569 00000002 <res 00000001>          .start_sector:	resb 1	; Beginning sector (6 bits, bits 0 to 5)
  9570                                  			; and high 2 bits of beginning cylinder
  9571 00000003 <res 00000001>          .start_cyl:	resb 1  ; Low 8 bits of beginning cylinder (total 10 bits)
  9572 00000004 <res 00000001>          .sys_id:	resb 1	; Partition (File System) ID (Type)
  9573 00000005 <res 00000001>          .end_head:	resb 1	; Ending head
  9574 00000006 <res 00000001>          .end_sector:	resb 1	; Ending sector (6 bits, bits 0 to 5)
  9575                                  			; and high 2 bits of ending cylinder
  9576 00000007 <res 00000001>          .end_cyl:	resb 1  ; Low 8 bits of ending cylinder (total 10 bits)
  9577 00000008 <res 00000004>          .rel_sec:	resd 1	; First sector relative to start of disk
  9578 0000000C <res 00000004>          .num_sec:	resd 1	; Number of sectors in partition
  9579                                  .entry_size:
  9580                                  endstruc
  9581                                  
  9582                                  	; FDISK Partition Data (46 bytes)
  9583                                  
  9584                                  struc pt_data	; partition_data
  9585 00000000 <res 00000001>          .boot_ind:	resb 1	; Active (Bootable) partition indicator
  9586 00000001 <res 00000001>          .start_head:	resb 1	; Start head (0 to 255)
  9587 00000002 <res 00000001>          .start_sector:	resb 1	; Start sector (1 to 63)
  9588 00000003 <res 00000002>          .start_cyl:	resw 1	; Start cylinder (0 to 1023)
  9589 00000005 <res 00000001>          .sys_id:	resb 1	; System (Partition, File System) ID
  9590 00000006 <res 00000001>          .end_head:	resb 1	; End head (0 to 255)
  9591 00000007 <res 00000001>          .end_sector:	resb 1	; End sector (1 to 63)	
  9592 00000008 <res 00000002>          .end_cyl:	resw 1	; End cylinder (0 to 1023)
  9593 0000000A <res 00000002>          .rec_sec_lw:	resw 1	; Beginning sector (LBA) of partition (low 16 bits)
  9594 0000000C <res 00000002>          .rel_sec_hw:	resw 1	; High 16 bits of beginning sector address	
  9595 0000000E <res 00000002>          .num_sec_lw:	resw 1	; Partition size in sectors (low 16 bits)
  9596 00000010 <res 00000002>          .num_sec_hw:	resw 1	; High 16 bits of sector count
  9597 00000012 <res 00000001>          .not_used:	resb 1	; (This struc byte is) not used in current FDISK
  9598 00000013 <res 00000001>          .changed:	resb 1	; Partition data changed flag
  9599 00000014 <res 00000002>          .mbytes_used:	resw 1	; Partition size in megabytes
  9600 00000016 <res 00000002>          .percent_used:	resw 1	; Percentage of total disk capacity (for partition)
  9601 00000018 <res 0000000C>          .vol_label:	resb 12 ; Volume label
  9602 00000024 <res 00000009>          .system:	resb 9	; Partition (File System) name for partition ID 
  9603 0000002D <res 00000001>          .drive_letter:	resb 1	; Logical DOS drive letter (C,D,...)
  9604                                  .size:	; = 46 bytes
  9605                                  endstruc
  9606                                  
  9607                                  ;/*  */
  9608                                  ;void init_partition_tables()
  9609                                  ;BEGIN
  9610                                  ;
  9611                                  ;unsigned i;
  9612                                  ;unsigned char j;
  9613                                  ;/*C00 unsigned k;       */
  9614                                  ;/*C00 unsigned l;       */
  9615                                  ;unsigned partition_location;
  9616                                  ;char temp;
  9617                                  ;char more_drives_exist;
  9618                                  ;char num_logical_drives;
  9619                                  ;/*C00 unsigned insert;  */
  9620                                  ;unsigned index;
  9621                                  ;unsigned char active_primary_count;                                     /*C32*/
  9622                                  ;unsigned char pri_part;                                                 /*C32*/
  9623                                  ;
  9624                                  ;	/* initialize first drive found to "C" */
  9625                                  ;	next_letter = c(SEA);						/* AC000 */
  9626                                  ;
  9627                                  ;	/* initialize primary partition count */
  9628                                  ;/*C32   primary_partition_count = 0; */
  9629                                  ;
  9630                                  ;	/* Look at both disks */
  9631                                  ;	for (j = uc(0); j < number_of_drives; j++)                      /* AC000 */
  9632                                  ;	   BEGIN
  9633                                  ;
  9634                                  ;	    /* initialize variables */                                  /*C32*/
  9635                                  ;	    primary_partition_count = 0;                                /*C32*/
  9636                                  ;	    active_primary_count = 0;                                   /*C32*/
  9637                                  ;	    pri_part = 0xFF;                                            /*C32*/
  9638                                  ;
  9639                                  ;	    /* Initialize the cur_disk field to the drive in question so */
  9640                                  ;	    /* that the calls to the partition information routines will work */
  9641                                  ;	    cur_disk = ((char)(j));
  9642                                  ;
  9643                                  ;	    /* Read in the master boot record and see if it was okay */
  9644                                  ;	    if (read_boot_record(u(0),j,uc(0),uc(1)))                  /* AC000 */
  9645                                  ;	       BEGIN
  9646                                  ;
  9647                                  ;		/* See if there was a valid boot record there */
  9648                                  ;		if ((boot_record[510] == uc(0x55)) && (boot_record[511] == uc(0xAA))) /* AC000 */
  9649                                  ;		   BEGIN
  9650                                  ;
  9651                                  ;		    /* What was on the disk is a valid boot record, so save it */
  9652                                  ;		    for (i=u(0);i < u(BYTES_PER_SECTOR); i++)           /* AC000 */
  9653                                  ;		       BEGIN
  9654                                  ;			master_boot_record[j][i] = boot_record[i];
  9655                                  ;		       END
  9656                                  ;		   END
  9657                                  ;		/* We've now got a copy of the master boot record saved. Now we need */
  9658                                  ;		/* to translate what in the boot record to the area that it's going  */
  9659                                  ;		/* to be worked on (part_table) */
  9660                                  ;
  9661                                  ;		/* Read in the data from the master boot record partition entries*/
  9662                                  ;		for (i=u(0); i < u(4); i++)                             /* AC000 */
  9663                                  ;		   BEGIN
  9664                                  ;		    index = i*16;
  9665                                  ;
  9666                                  ;		    /* Get boot ind */
  9667                                  ;		    part_table[j][i].boot_ind = master_boot_record[j][0x1BE+index];
  9668                                  ;
  9669                                  ;		    /* Start head */
  9670                                  ;		    part_table[j][i].start_head = master_boot_record[j][0x1BF+index];
  9671                                  ;
  9672                                  ;		    /* Start sector - unscramble it from INT 13 format*/
  9673                                  ;		    part_table[j][i].start_sector= (master_boot_record[j][0x1C0+index] & 0x3F);
  9674                                  ;
  9675                                  ;		    /* Start cyl - unscramble it from INT 13 format*/
  9676                                  ;		    part_table[j][i].start_cyl= ((((unsigned)master_boot_record[j][0x1C0+index]) & 0x00C0) << 2)
  9677                                  ;						+ ((unsigned)master_boot_record[j][0x1C1+index]);
  9678                                  ;
  9679                                  ;		    /* System id */
  9680                                  ;		    part_table[j][i].sys_id = master_boot_record[j][0x1C2+index];
  9681                                  ;
  9682                                  ;		    /* End head */
  9683                                  ;		    part_table[j][i].end_head = master_boot_record[j][0x1C3+index];
  9684                                  ;
  9685                                  ;		    /* End sector - unscramble it from INT 13 format*/
  9686                                  ;		    part_table[j][i].end_sector= (master_boot_record[j][0x1C4+index] & 0x3F);
  9687                                  ;
  9688                                  ;		    /* End cyl - unscramble it from INT 13 format*/
  9689                                  ;		    part_table[j][i].end_cyl= ((((unsigned)master_boot_record[j][0x1C4+index]) & 0x00C0) << 2)
  9690                                  ;						+ ((unsigned)master_boot_record[j][0x1C5+index]);
  9691                                  ;
  9692                                  ;		    /* Relative sectors */
  9693                                  ;
  9694                                  ;		    part_table[j][i].rel_sec =
  9695                                  ;		       ((unsigned long)master_boot_record[j][0x1C9+index]) << 24;
  9696                                  ;
  9697                                  ;		    part_table[j][i].rel_sec = part_table[j][i].rel_sec +
  9698                                  ;		       (((unsigned long)master_boot_record[j][0x1C8+index]) << 16);
  9699                                  ;
  9700                                  ;		    part_table[j][i].rel_sec = part_table[j][i].rel_sec +
  9701                                  ;		       (((unsigned long)master_boot_record[j][0x1C7+index]) << 8);
  9702                                  ;
  9703                                  ;		    part_table[j][i].rel_sec = part_table[j][i].rel_sec +
  9704                                  ;		       ((unsigned long)master_boot_record[j][0x1C6+index]);
  9705                                  ;
  9706                                  ;		    /* Number of sectors */
  9707                                  ;		    part_table[j][i].num_sec =
  9708                                  ;		       ((unsigned long)master_boot_record[j][0x1CD+index]) << 24;
  9709                                  ;
  9710                                  ;		    part_table[j][i].num_sec = part_table[j][i].num_sec +
  9711                                  ;		       (((unsigned long)master_boot_record[j][0x1CC+index]) << 16);
  9712                                  ;
  9713                                  ;		    part_table[j][i].num_sec = part_table[j][i].num_sec +
  9714                                  ;		       (((unsigned long)master_boot_record[j][0x1CB+index]) << 8);
  9715                                  ;
  9716                                  ;		    part_table[j][i].num_sec = part_table[j][i].num_sec +
  9717                                  ;		       ((unsigned long)master_boot_record[j][0x1CA+index]);
  9718                                  ;
  9719                                  ;		    part_table[j][i].mbytes_used = (unsigned)
  9720                                  ;		       numsecs_to_mbytes(part_table[j][i].num_sec);
  9721                                  ;
  9722                                  ;		    part_table[j][i].percent_used =
  9723                                  ;		       mbytes_to_percent(part_table[j][i].mbytes_used,total_mbytes[cur_disk]);
  9724                                  ;
  9725                                  ;		    /* Set drive letter */
  9726                                  ;		    if ( (part_table[j][i].sys_id == DOS12) ||  /* AN000 */
  9727                                  ;			 (part_table[j][i].sys_id == DOS16) ||  /* AN000 */
  9728                                  ;			 (part_table[j][i].sys_id == DOSNEW)   ) /* AN000 */
  9729                                  ;		       {
  9730                                  ;/*C32                  part_table[j][i].drive_letter = next_letter++;*/  /* AN000 */
  9731                                  ;			part_table[j][i].drive_letter = c(' ');         /*C32*/ /* AN000 */
  9732                                  ;			if ((primary_partition_count == 0) ||           /*C32*/
  9733                                  ;			    ((part_table[j][i].boot_ind == 0x80) &&     /*C32*/
  9734                                  ;			     (active_primary_count == 0)))              /*C32*/
  9735                                  ;			    pri_part = c(i);                            /*C32*/
  9736                                  ;			if (part_table[j][i].boot_ind == 0x80)          /*C32*/
  9737                                  ;			    active_primary_count++;                     /*C32*/
  9738                                  ;			primary_partition_count++; /*Keep track of partition number */
  9739                                  ;		       }
  9740                                  ;
  9741                                  ;		    /* Set changed flag */
  9742                                  ;		    part_table[j][i].changed = FALSE;
  9743                                  ;		   END
  9744                                  ;		if (pri_part != 0xFF)                                   /*C32*/
  9745                                  ;		   {                                                    /*C32*/
  9746                                  ;		    part_table[j][pri_part].drive_letter = next_letter++; /*C32*/
  9747                                  ;		    get_volume(j,pri_part);                             
  9748                                  ;		   }                                                    /*C32*/
  9749                                  ;	       END
  9750                                  ;	    else
  9751                                  ;	       BEGIN
  9752                                  ;		return;
  9753                                  ;	       END
  9754                                  ;	   END
  9755                                  ;
  9756                                  ;	/* Look at both disks */
  9757                                  ;	for (j = uc(0); j < number_of_drives; j++)                     /* AC000 */
  9758                                  ;	   BEGIN
  9759                                  ;
  9760                                  ;	    /* Initialize the cur_disk field to the drive in question so */
  9761                                  ;	    /* that the calls to the partition information routines will work */
  9762                                  ;	    cur_disk = ((char)(j));
  9763                                  ;
  9764                                  ;	    /* Read in the master boot record and see if it was okay */
  9765                                  ;	    if (read_boot_record(u(0),j,uc(0),uc(1)))                  /* AC000 */
  9766                                  ;	       BEGIN
  9767                                  ;		/* Now, go read in extended partition info */
  9768                                  ;		if (find_partition_type(uc(EXTENDED)))                 /* AC000 */
  9769                                  ;		   BEGIN
  9770                                  ;		    /* Initialize the array to zero's - include one dummy entry */
  9771                                  ;		    for (i=u(0); i < u(24); i++)                       /* AC000 */
  9772                                  ;		       BEGIN
  9773                                  ;			ext_table[j][i].boot_ind = uc(0);              /* AC000 */
  9774                                  ;			ext_table[j][i].start_head = uc(0);            /* AC000 */
  9775                                  ;			ext_table[j][i].start_sector = uc(0);          /* AC000 */
  9776                                  ;			ext_table[j][i].start_cyl = u(0);              /* AC000 */
  9777                                  ;			ext_table[j][i].sys_id = uc(0);                /* AC000 */
  9778                                  ;			ext_table[j][i].end_head = uc(0);              /* AC000 */
  9779                                  ;			ext_table[j][i].end_sector = uc(0);            /* AC000 */
  9780                                  ;			ext_table[j][i].end_cyl = u(0);                /* AC000 */
  9781                                  ;			ext_table[j][i].rel_sec = ul(0);               /* AC000 */
  9782                                  ;			ext_table[j][i].num_sec = ul(0);               /* AC000 */
  9783                                  ;			ext_table[j][i].mbytes_used = f(0);            /* AN000 */
  9784                                  ;			ext_table[j][i].percent_used = u(0);           /* AN000 */
  9785                                  ;			ext_table[j][i].changed = FALSE;
  9786                                  ;			ext_table[j][i].drive_letter = NUL;            /* AN000 */
  9787                                  ;
  9788                                  ;			strcpy(ext_table[cur_disk][i].system,NUL);     /* AN000 */
  9789                                  ;			strcpy(ext_table[cur_disk][i].vol_label,NUL);  /* AN000 */
  9790                                  ;
  9791                                  ;		       END
  9792                                  ;
  9793                                  ;		    /* Find where the first extended boot record is */
  9794                                  ;		    temp = find_partition_location(uc(EXTENDED));      /* AC000 */
  9795                                  ;		    partition_location = part_table[j][temp].start_cyl;
  9796                                  ;
  9797                                  ;		    /* Go find extended boot records as long as there are more of them */
  9798                                  ;		    more_drives_exist = TRUE;
  9799                                  ;
  9800                                  ;		    /* Init the number of logical drives, for a array index */
  9801                                  ;		    num_logical_drives = c(0);                        /* AC000 */
  9802                                  ;
  9803                                  ;		    while (more_drives_exist)
  9804                                  ;		       BEGIN
  9805                                  ;		       /* Assume we won't find another logical drive */
  9806                                  ;		       more_drives_exist = FALSE;
  9807                                  ;
  9808                                  ;			 /*Read in the extended boot record */
  9809                                  ;			 if (read_boot_record(partition_location,
  9810                                  ;					      j,
  9811                                  ;					      uc(0),
  9812                                  ;					      uc(1)))   /* AC000 */
  9813                                  ;			    BEGIN
  9814                                  ;			     load_logical_drive(num_logical_drives,j);
  9815                                  ;
  9816                                  ;
  9817                                  ;			     /* find the next logical drive */
  9818                                  ;			     for (i = u(0); i < u(4); i++)            /* AC000 */
  9819                                  ;				BEGIN
  9820                                  ;				 index = i*16;
  9821                                  ;				 /* See if a sys id byte of extended exists */
  9822                                  ;				 if (boot_record[0x1C2+index] == uc(EXTENDED))   /* AC000 */
  9823                                  ;				    BEGIN
  9824                                  ;				     /* Found another drive, now get its location */
  9825                                  ;				     partition_location= (((((unsigned)(boot_record[0x1C0 + index])) & 0x00C0) << 2));
  9826                                  ;				     partition_location = partition_location + ((unsigned)(boot_record[0x1C1+index]));
  9827                                  ;
  9828                                  ;				     /* Indicate we found another one */
  9829                                  ;				     more_drives_exist = TRUE;
  9830                                  ;
  9831                                  ;				     /* Up the count of found ones */
  9832                                  ;				     /* SR; 9/28/89; The count should be
  9833                                  ;					incremented only if there is a
  9834                                  ;					logical drive defined */
  9835                                  ;				     if (ext_table[j][num_logical_drives].sys_id != 0)
  9836                                  ;					 num_logical_drives++;
  9837                                  ;				     break;
  9838                                  ;				    END
  9839                                  ;				END
  9840                                  ;			    END
  9841                                  ;		       END
  9842                                  ;		   END
  9843                                  ;	       END
  9844                                  ;	   END
  9845                                  ;
  9846                                  ;	/* Look at all disks */                                         /*C32*/
  9847                                  ;	for (j = uc(0); j < number_of_drives; j++)                      /*C32*/
  9848                                  ;	   BEGIN                                                        /*C32*/
  9849                                  ;									/*C32*/
  9850                                  ;	    /* Look at all active primary partitions */                 /*C32*/
  9851                                  ;	    for (i=u(0); i < u(4); i++)                                 /*C32*/
  9852                                  ;	       BEGIN                                                    /*C32*/
  9853                                  ;		/* Set drive letter */                                  /*C32*/
  9854                                  ;		if (((part_table[j][i].sys_id == DOS12) ||              /*C32*/	/* AN000 */
  9855                                  ;		     (part_table[j][i].sys_id == DOS16) ||              /*C32*/	/* AN000 */
  9856                                  ;		     (part_table[j][i].sys_id == DOSNEW)) &&            /*C32*/	/* AN000 */
  9857                                  ;		    (part_table[j][i].boot_ind == 0x80))                /*C32*/	/* AN000 */
  9858                                  ;		   {                                                    /*C32*/
  9859                                  ;		    if (part_table[j][i].drive_letter == c(' '))        /*C32*/
  9860                                  ;		       {                                                /*C32*/
  9861                                  ;			part_table[j][i].drive_letter = next_letter++;  /*C32*/	/* AN000 */
  9862                                  ;			get_volume(j,i);                                /*C32*/
  9863                                  ;		       }                                                /*C32*/
  9864                                  ;		   }                                                    /*C32*/
  9865                                  ;	       END                                                      /*C32*/
  9866                                  ;									/*C32*/
  9867                                  ;	    /* Look at all non-active primary partitions */             /*C32*/
  9868                                  ;	    for (i=u(0); i < u(4); i++)                                 /*C32*/
  9869                                  ;	       BEGIN                                                    /*C32*/
  9870                                  ;		/* Set drive letter */                                  /*C32*/
  9871                                  ;		if (((part_table[j][i].sys_id == DOS12) ||              /*C32*/	/* AN000 */
  9872                                  ;		     (part_table[j][i].sys_id == DOS16) ||              /*C32*/	/* AN000 */
  9873                                  ;		     (part_table[j][i].sys_id == DOSNEW)) &&            /*C32*/	/* AN000 */
  9874                                  ;		    (part_table[j][i].boot_ind != 0x80))                /*C32*/	/* AN000 */
  9875                                  ;		   {                                                    /*C32*/
  9876                                  ;		    if (part_table[j][i].drive_letter == c(' '))        /*C32*/
  9877                                  ;		       {                                                /*C32*/
  9878                                  ;			part_table[j][i].drive_letter = next_letter++;  /*C32*/	/* AN000 */
  9879                                  ;			get_volume(j,i);                                /*C32*/
  9880                                  ;		       }                                                /*C32*/
  9881                                  ;		   }                                                    /*C32*/
  9882                                  ;	       END                                                      /*C32*/
  9883                                  ;	   END                                                          /*C32*/
  9884                                  ;
  9885                                  ;	return;
  9886                                  ;END
  9887                                  
  9888                                  init_partition_tables:
  9889                                  		; 23/11/2018
  9890                                  
  9891                                  	%define pt_num_sec_lw	     bp-22 ; word, unsigned int
  9892                                  	%define pt_num_sec_hw	     bp-20 ; word, unsigned int
  9893                                  	%define pt_rel_sec_temp_lw   bp-18 ; word, unsigned int
  9894                                  	%define pt_rel_sec_temp_hw   bp-16 ; word, unsigned int
  9895                                  	; 15/12/2018
  9896                                  	;%define more_drives_exist   bp-14 ; byte, unsigned int
  9897                                  	%define char_j		     bp-12 ; byte, char
  9898                                  	%define	unsigned_i	     bp-10 ; word, unsigned int
  9899                                  	%define active_primary_count bp-8  ; byte, unsigned char
  9900                                  	%define num_logical_drives   bp-6  ; byte, char	
  9901                                  	%define partition_location   bp-4  ; word, unsigned int	
  9902                                  	%define char_pri_part        bp-2  ; word, unsigned char
  9903                                  
  9904                                  		; 14/12/2018
  9905                                  	;%define ext_part_num	     bp-24 ; byte, char
  9906                                  		; 15/12/2018
  9907                                  	%define ext_part_num	     bp-14 ; byte, char
  9908                                  
  9909                                  		;push	bp
  9910 00001972 89E5                    		mov	bp,sp
  9911                                  		;;;sub	sp,26
  9912                                  		;;sub	sp,22 ; 20/11/2018
  9913                                  		;sub	sp,24 ; 14/12/2018
  9914 00001974 83EC16                  		sub	sp,22 ; 15/12/2018 
  9915                                  
  9916                                  		;push	di
  9917                                  		;push	si
  9918                                  
  9919                                  		;/* initialize first drive found to "C" */
  9920 00001977 C606[1FA1]43            		mov	byte [next_letter],'C'
  9921                                  ipt_for1_0:
  9922                                  		;/* Look at both disks */
  9923                                  		;for (j = uc(0); j < number_of_drives; j++)
  9924                                  		
  9925                                  		; 11/12/2018
  9926                                  		;mov	byte [char_j],0
  9927                                  		;jmp	ipt_for1_1
  9928 0000197C 31C0                    		xor	ax,ax
  9929 0000197E 8946F4                  		mov	[char_j],ax ; 0
  9930                                  ipt_for1_next:
  9931                                  		;/* initialize variables */ 
  9932 00001981 C606[CEC3]00            		mov	byte [primary_partition_count],0
  9933 00001986 C646FEFF                		mov	byte [char_pri_part],0FFh
  9934                                  	;/* Initialize the cur_disk field to the drive in question so */
  9935                                  	;/* that the calls to the partition information routines will work */
  9936 0000198A A2[D4CB]                		mov	[cur_disk],al
  9937                                  	;/* Read in the master boot record and see if it was okay */
  9938                                  	;if (read_boot_record(u(0),j,uc(0),uc(1)))
  9939                                  		;mov	cl,1
  9940 0000198D B90100                  		mov	cx,1 ; 11/12/2018
  9941 00001990 51                      		push	cx ; uc(1)
  9942 00001991 28C9                    		sub	cl,cl
  9943 00001993 884EF8                  		mov	[active_primary_count],cl
  9944 00001996 51                      		push	cx ; uc(0)
  9945 00001997 50                      		push	ax ; j
  9946 00001998 29C0                    		sub	ax,ax
  9947 0000199A 50                      		push	ax ; u(0)
  9948 0000199B E85406                  		call	read_boot_record
  9949                                  		;add	sp,8	; 22/12/2018
  9950                                  		;or	al,al
  9951                                  		;jnz	short ipt_1
  9952 0000199E 7303                    		jnc	short ipt_1 ; 27/11/2018
  9953 000019A0 E9BE02                  		jmp	ipt_26
  9954                                  ipt_1:
  9955                                  	;/* See if there was a valid boot record there */
  9956                                  	;if ((boot_record[510] == uc(0x55)) && (boot_record[511] == uc(0xAA)))
  9957                                  		;cmp	byte [boot_record+1FEh],55h
  9958                                  		;jne	short ipt_3
  9959                                  		;cmp	byte [boot_record+1FFh],0AAh
  9960                                  		;jne	short ipt_3
  9961                                  		;mov	word [unsigned_i],0
  9962                                  
  9963                                  		; 14/12/2018
  9964 000019A3 8B5EF4                  		mov	bx,[char_j]
  9965 000019A6 89DA                    		mov	dx,bx	; Disk/Drive number (0 to 7)
  9966 000019A8 C1E309                  		shl	bx,9	; * 512 ; FDISK MBR offset
  9967                                  
  9968                                  		; 23/11/2018
  9969 000019AB 813E[D0CB]55AA          		cmp	word [boot_record+1FEh],0AA55h
  9970 000019B1 750C                    		jne	short ipt_3
  9971                                  ;ipt_2:
  9972                                  	;/* What was on the disk is a valid boot record, so save it */
  9973                                  	; for (i=u(0);i < u(BYTES_PER_SECTOR); i++)
  9974                                  	;     master_boot_record[j][i] = boot_record[i];
  9975                                  
  9976                                  		;mov	bx,[unsigned_i]
  9977                                  		;mov	al,[boot_record+bx]
  9978                                  		;mov	cl,9
  9979                                  		;mov	dl,[char_j]
  9980                                  		;sub	dh,dh
  9981                                  		;mov	si,dx
  9982                                  		;shl	si,cl
  9983                                  		;mov	[master_boot_record+bx+si],al
  9984                                  		;inc	word [unsigned_i]
  9985                                  		;cmp	word [unsigned_i],512
  9986                                  		;jb	short ipt_2
  9987                                  
  9988                                  		; 20/11/2018
  9989                                  		;mov	bl,[char_j] ; Drive number (0 to 7)
  9990                                  		;xor	bh,bh
  9991                                  		; 14/12/2018
  9992                                  		;mov	bx,[char_j] ; 11/12/2018
  9993                                  		;mov	dx,bx ; 21/11/2018	
  9994                                  		;shl	bx,9 ; * 512
  9995                                  		
  9996 000019B3 8DBF[845F]              		lea	di,[master_boot_record+bx] ; mbr 0 to mbr 7
  9997 000019B7 BE[D2C9]                		mov	si,boot_record
  9998 000019BA B90001                  		mov	cx,256
  9999 000019BD F3A5                    		rep	movsw
 10000                                  ipt_3:
 10001                                  	;/* We've now got a copy of the master boot record saved. Now we need */
 10002                                  	;/* to translate what in the boot record to the area that it's going  */
 10003                                  	;/* to be worked on (part_table) */
 10004                                  
 10005 000019BF C746F60000              		mov	word [unsigned_i],0
 10006                                  ipt_4:
 10007                                     		; index = i*16;
 10008                                  		;
 10009                                  		; /* Get boot ind */
 10010                                  		; part_table[j][i].boot_ind = master_boot_record[j][0x1BE+index];
 10011                                  
 10012                                  		;mov	al,[char_j] ; drive number 
 10013                                  		;sub	ah,ah
 10014                                  		;mov	cl,9
 10015                                  		;mov	dx,ax
 10016                                  		;shl	ax,cl
 10017                                  
 10018                                  		; 21/11/2018	
 10019                                  		; bx = drive number * 512
 10020 000019C4 B104                    		mov	cl,4
 10021                                  		;mov	bx,[unsigned_i]
 10022                                  		;shl	bx,cl
 10023                                  		;add	bx,ax
 10024                                  		; 14/12/2018
 10025 000019C6 8B46F6                  		mov	ax,[unsigned_i] ; partition (partition table entry) number
 10026                                  		;shl	ax,cl
 10027 000019C9 D2E0                    		shl	al,cl ; 16*PartitionTableEntryNum	
 10028 000019CB 01C3                    		add	bx,ax ; MasterBoot Offset (for drive) + PT Entry offset
 10029                                  		;mov	al,[master_boot_record+1BEh+bx] ; Partition Table Entry address
 10030 000019CD 8DB7[4261]              		lea	si,[master_boot_record+1BEh+bx] ; 1BEh = Partition Table offset 
 10031 000019D1 AC                      		lodsb 
 10032                                  		;xor	ah,ah
 10033 000019D2 89C1                    		mov	cx,ax
 10034                                  		;mov	ax,dx ; Drive Number (0 to 7)
 10035                                  		;shl	ax,1
 10036                                  		;shl	ax,1  ; Drive Number * 4
 10037 000019D4 88D0                    		mov	al,dl
 10038 000019D6 D0E0                    		shl	al,1
 10039 000019D8 D0E0                    		shl	al,1
 10040                                  		;add	ax,[unsigned_i] ; partition index number
 10041 000019DA 0246F6                  		add	al,[unsigned_i]
 10042                                  		;mov	si,46
 10043                                  		;mul	si
 10044                                  		;mov	si,ax
 10045                                  		;mov	di,46 ; FDISK partition data/parameters (structure) size
 10046                                  		;mul	di
 10047 000019DD B42E                    		mov	ah,46
 10048 000019DF F6E4                    		mul	ah
 10049 000019E1 89C7                    		mov	di,ax
 10050                                  		;mov	[part_table_boot_ind+si],cl
 10051 000019E3 888D[12C4]              		mov	[part_table_boot_ind+di],cl
 10052                                  
 10053                                  		;/* Start head */
 10054                                  		;mov	al,[master_boot_record+1BFh+bx]
 10055 000019E7 AC                      		lodsb
 10056                                  		;mov	[part_table_start_head+si],al
 10057 000019E8 8885[13C4]              		mov	[part_table_start_head+di],al
 10058                                  
 10059                                  		;/* Start sector - unscramble it from INT 13 format*/
 10060                                  		;mov	al,[master_boot_record+1C0h+bx]
 10061                                  		;mov	cx,ax
 10062 000019EC AC                      		lodsb
 10063 000019ED 88C1                    		mov	cl,al
 10064 000019EF 243F                    		and	al,3Fh
 10065                                  		;mov	[part_table_start_sector+si],al
 10066 000019F1 8885[14C4]              		mov	[part_table_start_sector+di],al
 10067                                  
 10068                                  		;/* Start cylinder - unscramble it from INT 13 format*/
 10069                                  		;mov	al,[master_boot_record+1C1h+bx]
 10070 000019F5 AC                      		lodsb
 10071                                  		;sub	ah,ah
 10072                                  		;and	cx,0C0h
 10073                                  		; 11/12/2018
 10074                                  		;and	cl,0C0h 
 10075                                  		; ch = 0
 10076 000019F6 D1E1                    		shl	cx,1
 10077 000019F8 D1E1                    		shl	cx,1  ; 000000??00000000b ; high two bits
 10078                                  		;add	cx,ax
 10079 000019FA 88C1                    		mov	cl,al ; low 8 bits of cylinder
 10080                                  		;mov	[part_table_start_cyl+si],cx
 10081 000019FC 898D[15C4]              		mov	[part_table_start_cyl+di],cx
 10082                                  
 10083                                  		;/* System id */
 10084                                  		;mov	al,[master_boot_record+1C2h+bx]
 10085 00001A00 AC                      		lodsb
 10086                                  		;mov	[part_table_sys_id+si],al
 10087 00001A01 8885[17C4]              		mov	[part_table_sys_id+di],al
 10088                                  
 10089                                  		;/* End head */
 10090                                  		;mov	al,[master_boot_record+1C3h+bx]
 10091 00001A05 AC                      		lodsb
 10092                                  		;mov	[part_table_end_head+si],al
 10093 00001A06 8885[18C4]              		mov	[part_table_end_head+di],al
 10094                                  
 10095                                  		;/* End sector - unscramble it from INT 13 format*/
 10096                                  		;mov	al,[master_boot_record+1C4h+bx]
 10097 00001A0A AC                      		lodsb
 10098                                  		;mov	cx,ax
 10099 00001A0B 88C1                    		mov	cl,al
 10100 00001A0D 243F                    		and	al,3Fh
 10101                                  		;mov	[part_table_end_sector+si],al
 10102 00001A0F 8885[19C4]              		mov	[part_table_end_sector+di],al
 10103                                  
 10104                                  		;/* End cylinder - unscramble it from INT 13 format*/
 10105                                  		;mov	al,[master_boot_record+1C5h+bx]
 10106 00001A13 AC                      		lodsb
 10107 00001A14 81E1C000                		and	cx,0C0h
 10108 00001A18 D1E1                    		shl	cx,1
 10109 00001A1A D1E1                    		shl	cx,1  ; 000000??00000000b ; high two bits	
 10110                                  		;add	cx,ax
 10111 00001A1C 88C1                    		mov	cl,al ; low 8 bits of cylinder
 10112                                  		;mov	[part_table_end_cyl+si],cx
 10113 00001A1E 898D[1AC4]              		mov	[part_table_end_cyl+di],cx
 10114                                  
 10115                                  		;/* Relative sectors */
 10116                                  
 10117                                  		;mov	al,[master_boot_record+1C9h+bx]
 10118                                  		;mov	ah,al
 10119                                  		;sub	al,al
 10120                                  		;sub	cx,cx
 10121                                  		;mov	[part_table_rec_sec_lw+si],cx
 10122                                  		;mov	[part_table_rel_sec_hw+si],ax
 10123                                  		;mov	dl,[master_boot_record+1C8h+bx]
 10124                                  		;sub	dh,dh
 10125                                  		;sub	di,di
 10126                                  		;add	cx,di
 10127                                  		;adc	ax,dx
 10128                                  		;mov	[part_table_rec_sec_lw+si],cx
 10129                                  		;mov	[part_table_rel_sec_hw+si],ax
 10130                                  		;mov	dx,ax
 10131                                  		;mov	al,[master_boot_record+1C7h+bx]
 10132                                  		;sub	ah,ah
 10133                                  		;mov	di,dx
 10134                                  		;;sub	dx,dx
 10135                                  		;mov	[pt_rel_sec_temp_lw],cx
 10136                                  		;mov	[pt_rel_sec_temp_hw],di
 10137                                  		;mov	cl,8
 10138                                  		;mov	di,bx
 10139                                  		;call	shl32
 10140                                  		;add	ax,[pt_rel_sec_temp_lw]
 10141                                  		;adc	dx,[pt_rel_sec_temp_hw]
 10142                                  		;mov	[part_table_rec_sec_lw+si],ax
 10143                                  		;mov	[part_table_rel_sec_hw+si],dx
 10144                                  		;mov	cl,[master_boot_record+1C6h+di]
 10145                                  		;sub	ch,ch
 10146                                  		;add	ax,cx
 10147                                  		;adc	dx,0
 10148                                  
 10149                                  		; 21/11/2018
 10150 00001A22 AD                      		lodsw	; mov ax,[master_boot_record+1C6h+bx]
 10151                                  		;mov	dx,ax ; *
 10152 00001A23 8985[1CC4]              		mov	[part_table_rel_sec_lw+di],ax ; 06/01/2019
 10153                                  
 10154 00001A27 AD                      		lodsw ; ** ; mov ax,[master_boot_record+1C8h+bx]; 
 10155                                  		;xchg	ax,dx
 10156                                  		; DX:AX = part_table_rel_sec (32 bit LBA value)
 10157                                  				
 10158                                  		;mov	[part_table_rel_sec_lw+si],ax
 10159                                  		;mov	[part_table_rel_sec_hw+si],dx
 10160                                  
 10161                                  		; 06/01/2019
 10162 00001A28 8985[1EC4]              		mov	[part_table_rel_sec_hw+di],ax ; high word ; **
 10163                                  
 10164                                  		;/* Number of sectors */
 10165                                  
 10166                                  		;mov	al,[master_boot_record+1CDh+di]
 10167                                  		;mov	ah,al
 10168                                  		;sub	al,al
 10169                                  		;sub	cx,cx
 10170                                  		;mov	[part_table_num_sec_lw+si],cx
 10171                                  		;mov	[part_table_num_sec_hw+si],ax
 10172                                  		;mov	dl,[master_boot_record+1CCh+di]
 10173                                  		;sub	dh,dh
 10174                                  		;sub	bx,bx
 10175                                  		;add	cx,bx
 10176                                  		;adc	ax,dx
 10177                                  		;mov	[part_table_num_sec_lw+si],cx
 10178                                  		;mov	[part_table_num_sec_hw+si],ax
 10179                                  		;mov	dx,ax
 10180                                  		;mov	al,[master_boot_record+1CBh+di]
 10181                                  		;sub	ah,ah
 10182                                  		;mov	bx,dx
 10183                                  		;sub	dx,dx
 10184                                  		;mov	[pt_num_sec_lw],cx
 10185                                  		;mov	[pt_num_sec_hw],bx
 10186                                  		;mov	cl,8
 10187                                  		;call	shl32
 10188                                  		;add	ax,[pt_num_sec_lw]
 10189                                  		;adc	dx,[pt_num_sec_hw]
 10190                                  		;mov	[part_table_num_sec_lw+si],ax
 10191                                  		;mov	[part_table_num_sec_hw+si],dx
 10192                                  		;mov	cl,[master_boot_record+1CAh+di]
 10193                                  		;sub	ch,ch
 10194                                  		;add	ax,cx
 10195                                  		;adc	dx,0
 10196                                  
 10197 00001A2C AD                      		lodsw	; mov ax,[master_boot_record+1CAh+bx]
 10198 00001A2D 89C2                    		mov	dx,ax ; ***
 10199                                  
 10200 00001A2F AD                      		lodsw	; mov ax,[master_boot_record+1CCh+bx]
 10201 00001A30 92                      		xchg	ax,dx ; ****
 10202                                  		; DX:AX = part_table_num_sec (32 bit LBA value)
 10203                                  		
 10204                                  		;mov	[part_table_num_sec_lw+si],ax
 10205                                  		;mov	[part_table_num_sec_hw+si],dx
 10206                                  
 10207 00001A31 8985[20C4]              		mov	[part_table_num_sec_lw+di],ax ; low word  ; ***
 10208 00001A35 8995[22C4]              		mov	[part_table_num_sec_hw+di],dx ; high word ; ****		
 10209                                  
 10210                                  	;part_table[j][i].mbytes_used = (unsigned)
 10211                                  	;  numsecs_to_mbytes(part_table[j][i].num_sec);
 10212                                  
 10213                                  		;push	dx ; ****
 10214                                  		;;push	word [part_table_num_sec_lw+si]
 10215                                  		;push	ax ; ***
 10216                                  		;call	numsecs_to_mbytes
 10217                                  		;pop	bx
 10218                                  		;pop	bx
 10219                                  
 10220 00001A39 E83DFB                  		call	numsecs_to_mbytes ; 21/11/2018
 10221                                  
 10222                                  		;mov	[part_table_mbytes_used+si],ax
 10223 00001A3C 8985[26C4]              		mov	[part_table_mbytes_used+di],ax ; =*=
 10224                                  
 10225                                  	; part_table[j][i].percent_used =
 10226                                  	;   mbytes_to_percent(part_table[j][i].mbytes_used,total_mbytes[cur_disk]);
 10227                                  
 10228                                  		;mov	al,[cur_disk]
 10229                                  		;cbw
 10230                                  		;mov	bx,ax
 10231                                  		; 14/12/2018
 10232 00001A40 30FF                    		xor	bh,bh
 10233 00001A42 8A1E[D4CB]              		mov	bl,[cur_disk]
 10234 00001A46 D1E3                    		shl	bx,1
 10235 00001A48 FFB7[C8A0]              		push	word [total_mbytes+bx]
 10236                                  		;;push	word [part_table_mbytes_used+si]
 10237                                  		;push	word [part_table_mbytes_used+di]
 10238 00001A4C 50                      		push	ax ; =*= ; 14/12/2018
 10239 00001A4D E835FB                  		call	mbytes_to_percent
 10240                                  		;pop	bx ; 06/01/2019
 10241                                  		;pop	bx
 10242                                  		;mov	[part_table_percent_used+si],ax
 10243 00001A50 8985[28C4]              		mov	[part_table_percent_used+di],ax
 10244                                  
 10245                                  		;/* Set drive letter */
 10246                                  
 10247                                  		;if ( (part_table[j][i].sys_id == DOS12) ||
 10248                                  		;     (part_table[j][i].sys_id == DOS16) ||
 10249                                  		;     (part_table[j][i].sys_id == DOSNEW)   )
 10250                                  		;       {
 10251                                  
 10252                                  		;cmp	byte [part_table_sys_id+si],1 ; DOS12
 10253                                  		;je	short ipt_5
 10254                                  		;cmp	byte [part_table_sys_id+si],4 ; DOS16
 10255                                  		;je	short ipt_5
 10256                                  		;cmp	byte [part_table_sys_id+si],6 ; DOSNEW
 10257                                  		;jne	short ipt_9
 10258                                  
 10259                                  		; 22/11/2018
 10260 00001A54 8A46F4                  		mov	al,[char_j] ; Drive number (0 to 7)
 10261                                  		;sub	ah,ah
 10262 00001A57 D0E0                    		shl	al,1
 10263 00001A59 D0E0                    		shl	al,1
 10264 00001A5B 0246F6                  		add	al,[unsigned_i] ; PT entry number (0 to 3)
 10265                                  		; ax = partition index (0 to 31)
 10266 00001A5E B12E                    		mov	cl,46 ; Partition data (structure) size
 10267 00001A60 F6E1                    		mul	cl
 10268 00001A62 89C3                    		mov	bx,ax ; Partition data offset 
 10269                                  
 10270 00001A64 8A85[17C4]              		mov	al,[part_table_sys_id+di] ; 06/01/2019
 10271                                  
 10272                                  		;cmp	byte [part_table_sys_id+di],1 ; FAT12
 10273 00001A68 3C01                    		cmp	al,1
 10274 00001A6A 7408                    		je	short ipt_5
 10275                                  		;cmp	byte [part_table_sys_id+di],4 ; FAT16
 10276 00001A6C 3C04                    		cmp	al,4
 10277 00001A6E 7404                    		je	short ipt_5
 10278                                  		;cmp	byte [part_table_sys_id+di],6 ; FAT16 big
 10279 00001A70 3C06                    		cmp	al,6
 10280 00001A72 7526                    		jne	short ipt_9
 10281                                  ipt_5:
 10282                                  		;mov	al,[char_j] ; Drive number (0 to 7)
 10283                                  		;sub	ah,ah
 10284                                  		;shl	ax,1
 10285                                  		;shl	ax,1
 10286                                  		;add	ax,[unsigned_i] ; PT entry number (0 to 3)
 10287                                  		; ax = partition index (0 to 31) 
 10288                                  		;mov	cx,46 ; Partition data (structure) size
 10289                                  		;mul	cx
 10290                                  		;mov	bx,ax ; Partition data offset
 10291                                  		
 10292                                  		;part_table[j][i].drive_letter = c(' ');  
 10293 00001A74 C687[3FC4]20            		mov	byte [part_table_drive_letter+bx],' '
 10294                                  
 10295                                  		;if ((primary_partition_count == 0) ||
 10296                                  		;   ((part_table[j][i].boot_ind == 0x80) &&
 10297                                  		;     (active_primary_count == 0)))
 10298                                  		;	pri_part = c(i);
 10299                                  		;	if (part_table[j][i].boot_ind == 0x80)
 10300                                  		;	   active_primary_count++;
 10301                                  		;	primary_partition_count++; /*Keep track of partition number */
 10302                                  		;	}
 10303                                  
 10304 00001A79 803E[CEC3]00            		cmp	byte [primary_partition_count],0
 10305 00001A7E 740D                    		je	short ipt_6
 10306 00001A80 80BF[12C4]80            		cmp	byte [part_table_boot_ind+bx],80h
 10307                                  		;jne	short ipt_7
 10308 00001A85 750F                    		jne	short ipt_8 ; 22/11/2018
 10309 00001A87 807EF800                		cmp	byte [active_primary_count],0
 10310                                  		;jne	short ipt_7
 10311 00001A8B 7706                    		ja	short ipt_7
 10312                                  ipt_6:
 10313 00001A8D 8A46F6                  		mov	al,[unsigned_i]
 10314 00001A90 8846FE                  		mov	[char_pri_part],al
 10315                                  ipt_7:
 10316                                  		; 22/11/2018
 10317                                  		;mov	al,[char_j]
 10318                                  		;sub	ah,ah
 10319                                  		;shl	ax,1
 10320                                  		;shl	ax,1
 10321                                  		;add	ax,[unsigned_i]
 10322                                  		;mul	cx
 10323                                  		;mov	bx,ax
 10324                                  
 10325                                  		;cmp	byte [part_table_boot_ind+bx],80h
 10326                                  		;jne	short ipt_8
 10327                                  
 10328 00001A93 FE46F8                  		inc	byte [active_primary_count]
 10329                                  ipt_8:
 10330 00001A96 FE06[CEC3]              		inc	byte [primary_partition_count]
 10331                                  ipt_9:
 10332                                  		;mov	al,[char_j]
 10333                                  		;sub	ah,ah
 10334                                  		;shl	ax,1
 10335                                  		;shl	ax,1
 10336                                  		;add	ax,[unsigned_i]
 10337                                  		;mov	cx,46 ; Partition data (structure) size	
 10338                                  		;mul	cx
 10339                                  		;mov	bx,ax
 10340                                  	
 10341                                  		;/* Set changed flag */
 10342 00001A9A C687[25C4]00            		mov	byte [part_table_changed+bx],0
 10343                                  	
 10344                                  		;inc	word [unsigned_i]
 10345 00001A9F FE46F6                  		inc	byte [unsigned_i]
 10346                                  		;cmp	word [unsigned_i],4
 10347 00001AA2 807EF604                		cmp	byte [unsigned_i],4
 10348 00001AA6 730B                    		jnb	short ipt_10
 10349                                  
 10350                                  		; 22/11/2018
 10351                                  		;mov	bl,[char_j] ; Drive number (0 to 7)
 10352                                  		;xor	bh,bh
 10353                                  
 10354                                  		; 11/12/2018
 10355 00001AA8 8B5EF4                  		mov	bx,[char_j]
 10356                                  	
 10357 00001AAB 89DA                    		mov	dx,bx	; 21/11/2018	
 10358 00001AAD C1E309                  		shl	bx,9	; Drive number * 512
 10359                                  
 10360 00001AB0 E911FF                  		jmp	ipt_4
 10361                                  ipt_10:
 10362                                  		; 23/11/2018
 10363                                  		;if (pri_part != 0xFF) 
 10364 00001AB3 807EFEFF                		cmp	byte [char_pri_part],0FFh
 10365 00001AB7 7425                    		je	short ipt_11
 10366                                  
 10367                                  	;part_table[j][pri_part].drive_letter = next_letter++;
 10368                                  	;get_volume(j,pri_part);
 10369                                  
 10370 00001AB9 8A46F4                  		mov	al,[char_j] ; Disk/Drive number (0 to 7)
 10371                                  		;sub	ah,ah
 10372                                  		;shl	ax,1
 10373                                  		;shl	ax,1
 10374 00001ABC D0E0                    		shl	al,1
 10375 00001ABE D0E0                    		shl	al,1
 10376 00001AC0 8A4EFE                  		mov	cl,[char_pri_part]
 10377                                  		;sub	ch,ch
 10378                                  		;add	ax,cx
 10379 00001AC3 00C8                    		add	al,cl
 10380                                  		;mov	bx,46 ; Partition data (structure) size	
 10381                                  		;imul	bx
 10382 00001AC5 B32E                    		mov	bl,46
 10383 00001AC7 F6E3                    		mul	bl
 10384 00001AC9 89C3                    		mov	bx,ax
 10385 00001ACB A0[1FA1]                		mov	al,[next_letter]
 10386 00001ACE FE06[1FA1]              		inc	byte [next_letter]
 10387 00001AD2 8887[3FC4]              		mov	[part_table_drive_letter+bx],al
 10388                                  
 10389                                  		; 14/12/2018
 10390                                  		;push	cx
 10391 00001AD6 88CC                    		mov	ah,cl  ; Partition number
 10392 00001AD8 8A46F4                  		mov	al,[char_j] ; Disk/Drive number
 10393                                  		;push	ax
 10394 00001ADB E88601                  		call	get_volume
 10395                                  		;pop	bx
 10396                                  		;pop	bx
 10397                                  ipt_11:
 10398 00001ADE FE46F4                  		inc	byte [char_j]
 10399                                  ipt_for1_1:
 10400                                  		;/* Look at both disks */
 10401                                  
 10402 00001AE1 8A46F4                  		mov	al,[char_j] ; Drive number (0 to 7)
 10403 00001AE4 3806[D5C3]              		cmp	[number_of_drives],al
 10404 00001AE8 7603                    		jna	short ipt_for2_0
 10405 00001AEA E994FE                  		jmp	ipt_for1_next
 10406                                  ipt_for2_0:
 10407                                  		; 23/11/2018
 10408                                  		; Initializing logical dos drives (in extended partitions)
 10409                                  
 10410                                  		;mov	byte [char_j],0
 10411                                  		;jmp	short ipt_for2_1
 10412                                  		; 11/12/2018
 10413 00001AED 31C0                    		xor	ax,ax
 10414 00001AEF 8846F4                  		mov	[char_j],al ; 0
 10415 00001AF2 EB53                    		jmp	short ipt_for2_next
 10416                                  ipt_12:
 10417                                  		;inc	word [unsigned_i]
 10418 00001AF4 FE46F6                  		inc	byte [unsigned_i] ; Partition number (0 to 3)
 10419                                  ipt_in_while_for_1:
 10420                                  		;cmp	word [unsigned_i],4
 10421 00001AF7 807EF604                		cmp	byte [unsigned_i],4 ; Partition number (0 to 3)
 10422                                  		; 15/12/2018
 10423                                  		;jb	short ipt_in_while_for_next
 10424                                  		;jmp	ipt_while_more_drives_exist
 10425 00001AFB 733C                    		jnb	short ipt_while_end
 10426                                  		
 10427                                  ipt_in_while_for_next:
 10428                                  		;    /* See if a sys id byte of extended exists */
 10429                                  		;    if (boot_record[0x1C2+index] == uc(EXTENDED))
 10430                                  		;	BEGIN
 10431                                  		;	  /* Found another drive, now get its location */
 10432                                  		;	  partition_location = (((((unsigned)(boot_record[0x1C0 + index])) & 0x00C0) << 2));
 10433                                  		;	  partition_location = partition_location + ((unsigned)(boot_record[0x1C1+index]));
 10434                                  
 10435 00001AFD B104                    		mov	cl,4
 10436 00001AFF 8B5EF6                  		mov	bx,[unsigned_i] ; Partition number (0 to 3)
 10437                                  		;shl	bx,cl ; 16 * PTE number ; (= Partition Table offset from 1BEh. 0,16,32,48,64)
 10438 00001B02 D2E3                    		shl	bl,cl
 10439 00001B04 80BF[94CB]05            		cmp	byte [boot_record+1C2h+bx],5 ; System ID, EXTENDED 
 10440 00001B09 75E9                    		jne	short ipt_12
 10441 00001B0B 8A87[92CB]              		mov	al,[boot_record+1C0h+bx] ; Partition Table Offset + sector byte
 10442 00001B0F 25C000                  		and	ax,0C0h  ; Bit 6 and 7 are cylinder bits 8 and 9
 10443 00001B12 D1E0                    		shl	ax,1
 10444 00001B14 D1E0                    		shl	ax,1 ; (bits 8 and 9)
 10445                                  		;mov	cl,[boot_record+1C1h+bx] ; Partition Table Offset + cylinder (low) byte
 10446                                  		;sub	ch,ch
 10447                                  		;add	ax,cx
 10448 00001B16 8A87[93CB]              		mov	al,[boot_record+1C1h+bx] ; 23/11/2018
 10449 00001B1A 8946FC                  		mov	[partition_location],ax ; start cylinder 
 10450                                  
 10451                                  		;	  /* Indicate we found another one */
 10452                                  		;	  more_drives_exist = TRUE;
 10453                                  
 10454                                  		; 15/12/2018
 10455                                  		;mov	byte [more_drives_exist],1 ; TRUE
 10456                                  
 10457                                  		;mov	al,[num_logical_drives]
 10458                                  		;cbw
 10459                                  		;mov	cx,ax
 10460                                  		;mov	cl,[num_logical_drives] ; 0 to 23
 10461                                  
 10462                                  		;	  /* Up the count of found ones */
 10463                                  		;	  /* SR; 9/28/89; The count should be incremented 
 10464                                  		;	     only if there is a logical drive defined */
 10465                                  		;	  if (ext_table[j][num_logical_drives].sys_id != 0)
 10466                                  		;	     num_logical_drives++;
 10467                                  		;	     break;
 10468                                  
 10469 00001B1D B018                    		mov	al,24 ; 24 logical drives per disk (and 1 extended partition per disk)
 10470 00001B1F F666F4                  		mul	byte [char_j] ; Disk/Drive number (0 to 7)
 10471                                  		;add	ax,cx
 10472                                  		;add	al,cl ; Logical partition index
 10473 00001B22 0246FA                  		add	al,[num_logical_drives] ; 19/12/2018
 10474                                  		;mov	cx,46
 10475                                  		;imul	cx
 10476 00001B25 B12E                    		mov	cl,46 ; Logical partition data (structure) size
 10477 00001B27 F6E1                    		mul	cl
 10478 00001B29 89C3                    		mov	bx,ax ; Logical partition data address
 10479 00001B2B 80BF[4FA1]00            		cmp	byte [ext_table_sys_id+bx],0  ; System ID
 10480 00001B30 7502                    		jne	short ipt_13
 10481                                  		;jmp	ipt_while_more_drives_exist
 10482 00001B32 EB4A                    		jmp	ipt_in_while ; 15/12/2018
 10483                                  ipt_13:
 10484 00001B34 FE46FA                  		inc	byte [num_logical_drives]
 10485                                  
 10486                                  		;jmp	ipt_while_more_drives_exist
 10487 00001B37 EB45                    		jmp	ipt_in_while ; 15/12/2018
 10488                                  
 10489                                  ipt_while_end:
 10490 00001B39 FE46F4                  		inc	byte [char_j]
 10491                                  ipt_for2_1:
 10492                                  	;/* Initialize the cur_disk field to the drive in question so */
 10493                                  	;/* that the calls to the partition information routines will work */
 10494 00001B3C 8A46F4                  		mov	al,[char_j]
 10495 00001B3F 3806[D5C3]              		cmp	[number_of_drives],al
 10496 00001B43 7702                    		ja	short ipt_for2_next
 10497 00001B45 EB5C                    		jmp	ipt_16
 10498                                  ipt_for2_next:
 10499 00001B47 A2[D4CB]                		mov	[cur_disk],al
 10500                                  		; ah = 0 ; 11/12/2018
 10501                                  
 10502                                  	;/* Read in the master boot record and see if it was okay */
 10503                                  	; if (read_boot_record(u(0),j,uc(0),uc(1)))    
 10504                                  		;mov	cl,1
 10505                                  		; 11/12/2018
 10506 00001B4A 31C9                    		xor 	cx,cx
 10507 00001B4C FEC1                    		inc	cl ; 1
 10508 00001B4E 51                      		push	cx
 10509                                  		;sub	cl,cl
 10510 00001B4F FEC9                    		dec	cl ; 0
 10511 00001B51 51                      		push	cx
 10512 00001B52 50                      		push	ax
 10513                                  		;sub	ax,ax
 10514 00001B53 28C0                    		sub	al,al ; 11/12/2018
 10515 00001B55 50                      		push	ax
 10516 00001B56 E89904                  		call	read_boot_record
 10517                                  		;add	sp,8	; 22/12/2018
 10518                                  		;or	al,al
 10519                                  		;jz	short ipt_while_end
 10520 00001B59 72DE                    		jc	short ipt_while_end ; 27/11/2018
 10521                                  	
 10522                                  	;/* Now, go read in extended partition info */
 10523                                  	; if (find_partition_type(uc(EXTENDED)))      
 10524 00001B5B B005                    		mov	al,EXTENDED ; 5
 10525                                  		;push	ax
 10526 00001B5D E85A02                  		call	find_partition_type
 10527                                  		;pop	bx
 10528                                  		;or	al,al
 10529                                  		;jz	short ipt_while_end
 10530 00001B60 72D7                    		jc	short ipt_while_end ; 24/11/2018
 10531                                  
 10532                                  		; 14/12/2018
 10533                                  		;mov	[ext_part_num],cl ; 0 to 3 
 10534 00001B62 88C8                    		mov	al,cl ; 15/12/2018
 10535                                  
 10536                                  	;/* Initialize the array to zero's - include one dummy entry */
 10537                                  	; for (i=u(0); i < u(24); i++)
 10538                                  	;     BEGIN
 10539                                  	;	ext_table[j][i].boot_ind = uc(0);
 10540                                  	;	ext_table[j][i].start_head = uc(0);
 10541                                  	;	ext_table[j][i].start_sector = uc(0);
 10542                                  	;	ext_table[j][i].start_cyl = u(0);
 10543                                  	;	ext_table[j][i].sys_id = uc(0);
 10544                                  	;	ext_table[j][i].end_head = uc(0);
 10545                                  	;	ext_table[j][i].end_sector = uc(0);
 10546                                  	;	ext_table[j][i].end_cyl = u(0);
 10547                                  	;	ext_table[j][i].rel_sec = ul(0);
 10548                                  	;	ext_table[j][i].num_sec = ul(0);
 10549                                  	;	ext_table[j][i].mbytes_used = f(0);
 10550                                  	;	ext_table[j][i].percent_used = u(0);
 10551                                  	;	ext_table[j][i].changed = FALSE;
 10552                                  	;	ext_table[j][i].drive_letter = NUL;
 10553                                  	;
 10554                                  	;	strcpy(ext_table[cur_disk][i].system,NUL);
 10555                                  	;	strcpy(ext_table[cur_disk][i].vol_label,NUL);
 10556                                  	;     END
 10557                                  
 10558                                  		;;mov	word [unsigned_i],0
 10559                                  		;mov	byte [unsigned_i],0
 10560                                  ipt_14:
 10561                                  ;		mov	al,24 ; 24 logical drives
 10562                                  ;		mul	byte [char_j] ; Disk/Driver number (0 to 7)
 10563                                  ;		;add	ax,[unsigned_i]
 10564                                  ;		add	al,[unsigned_i] ; 23/11/2018
 10565                                  ;		;mov	cx,46
 10566                                  ;		mov	cl,46
 10567                                  ;		;mul	cx
 10568                                  ;		mul	cl
 10569                                  ;		mov	bx,ax ; Logical disk drive -partition- data offset
 10570                                  ;		;sub	al,al ; 0
 10571                                  ;		sub	ax,ax ; 0
 10572                                  ;		mov	[ext_table_boot_ind+bx],al
 10573                                  ;		mov	[ext_table_start_head+bx],al
 10574                                  ;		mov	[ext_table_start_sector+bx],al
 10575                                  ;		;mov	[ext_table_start_cyl+bx],0
 10576                                  ;		mov	[ext_table_start_cyl+bx],ax
 10577                                  ;		mov	[ext_table_sys_id+bx],al
 10578                                  ;		mov	[ext_table_end_head+bx],al
 10579                                  ;		mov	[ext_table_end_sector+bx],al
 10580                                  ;		;mov	[ext_table_end_cyl+bx],0
 10581                                  ;		mov	[ext_table_end_cyl+bx],ax
 10582                                  ;		;sub	ax,ax ; 0
 10583                                  ;		mov	[ext_table_rel_sec_hw+bx],ax
 10584                                  ;		mov	[ext_table_rel_sec_lw+bx],ax
 10585                                  ;		mov	[ext_table_num_sec_hw+bx],ax
 10586                                  ;		mov	[ext_table_num_sec_lw+bx],ax
 10587                                  ;		mov	[ext_table_mbytes_used+bx],ax
 10588                                  ;		mov	[ext_table_percent_used+bx],ax
 10589                                  ;		sub	al,al
 10590                                  ;		mov	[ext_table_changed+bx],al
 10591                                  ;		mov	[ext_table_drive_letter+bx],al
 10592                                  ;		;sub	ax,ax ; 0
 10593                                  ;		;push	ax ; NUL
 10594                                  ;		mov	al,24
 10595                                  ;		;imul	byte [cur_disk]
 10596                                  ;		mul	byte [cur_disk] ; 23/11/2018
 10597                                  ;		;add	ax,[unsigned_i] ; Current logical drive index (0 to 23)
 10598                                  ;		add	al,[unsigned_i]
 10599                                  ;		;mul	cx
 10600                                  ;		mul	cl ; cl = 46
 10601                                  ;		;;;mov	dx,ax ; *
 10602                                  ;		;add	ax,ext_table_system ; Partition (File System) ID address
 10603                                  ;		;push	ax
 10604                                  ;		;call	strcpy
 10605                                  ;		;pop	bx
 10606                                  ;		;pop	bx
 10607                                  ;		
 10608                                  ;		; 23/11/2018 - clear Volume Name field (12 bytes)
 10609                                  ;		mov	di,ext_table_vol_label 
 10610                                  ;		add	di,ax
 10611                                  ;		;sub	al,al
 10612                                  ;		sub	ax,ax ; 0
 10613                                  ;		;mov	cl,6 ; 6 words, 12 bytes
 10614                                  ;		;;ch = 0
 10615                                  ;		;rep	stosw
 10616                                  ;		; System ID field -9 bytes- is just after Volume Name field
 10617                                  ;		; ! Clear Volume Name and System ID fields. (21 bytes) !	
 10618                                  ;		mov	cl,10 ; 10 words
 10619                                  ;		rep	stosw
 10620                                  ;		stosb	      ; +1 bytes = 12+9 bytes		
 10621                                  ;		
 10622                                  ;		;sub	ax,ax ; 0
 10623                                  ;		;push	ax ; NUL
 10624                                  ;		;mov	al,24
 10625                                  ;		;;imul	byte [cur_disk]
 10626                                  ;		;mul	byte [cur_disk]
 10627                                  ;		;;add	ax,[unsigned_i]
 10628                                  ;		;add	al,[unsigned_i]
 10629                                  ;		;;mov	cx,46
 10630                                  ;		;;mul	cx
 10631                                  ;		;mov	cl,46
 10632                                  ;		;mul	cl
 10633                                  ;		;;;mov	ax,dx ; *
 10634                                  ;		;add	ax,ext_table_vol_label ; Volume name address
 10635                                  ;		
 10636                                  ;		;push	ax
 10637                                  ;		;call	strcpy
 10638                                  ;		;pop	bx
 10639                                  ;		;pop	bx
 10640                                  ;
 10641                                  ;		;; 23/11/2018 - clear Partition (File System) ID field (9 bytes)
 10642                                  ;		;;mov	di,ext_table_system
 10643                                  ;		;;add	di,ax ; (Already) System ID field is just after Volume Name field
 10644                                  ;		;;;sub	ax,ax
 10645                                  ;		;mov	cl,9 ; 9 bytes
 10646                                  ;		;;ch = 0
 10647                                  ;		;rep	stosb
 10648                                  ;
 10649                                  ;		;inc	word [unsigned_i]
 10650                                  ;		inc	byte [unsigned_i]
 10651                                  ;		;cmp	word [unsigned_i],24
 10652                                  ;		cmp	byte [unsigned_i],24
 10653                                  ;		jnb	short ipt_15
 10654                                  ;		jmp	ipt_14
 10655                                  
 10656                                  		; 14/12/2018
 10657                                  		; (bss -extended partition data area- already has been cleared)
 10658                                  		;		
 10659                                  		;; 23/11/2018
 10660                                  		;; Clear Logical Drive/Partition data area for current disk
 10661                                  		;mov	di,ext_table_boot_ind ; Start of logical drives data
 10662                                  		;mov	al,24
 10663                                  		;mul	byte [cur_disk]
 10664                                  		;mov	cl,46
 10665                                  		;mul	cl
 10666                                  		;; ax =  offset from ext_table_boot_ind
 10667                                  		;add	di,ax ; Start of logical drives data (for current disk)
 10668                                  		;
 10669                                  		;xor	ax,ax ; 0
 10670                                  		;mov	cx,(24*46)/2 ; 24 logical drives per extended partition (per disk) 
 10671                                  		;rep	stosw	; clear 552 words instead of 1104 bytes
 10672                                  
 10673                                  ipt_15:
 10674                                  	;/* Find where the first extended boot record is */
 10675                                  	; temp = find_partition_location(uc(EXTENDED));
 10676                                  	; partition_location = part_table[j][temp].start_cyl;
 10677                                  		
 10678                                  		; 14/12/2018
 10679                                  		;mov	al,5 ; EXTENDED
 10680                                  		;;push	ax
 10681                                  		;call	find_partition_location
 10682                                  		;;pop	bx
 10683                                  
 10684                                  		;mov	al,[ext_part_num] ; 14/12/2018
 10685                                  		; 15/12/2018
 10686                                  		; AL = Partition number of extended partition (in MBR)
 10687                                  
 10688                                  		; 24/11/2018
 10689                                  			 ; AL = Partition number (0 to 3)
 10690                                  			 ; 	or AL =	0FFh (not found)
 10691                                  			 ; BX = Partition data (structure) offset ; =*=
 10692                                  		;cbw
 10693                                  		; ax = partition number (0 to 3) of extended partition
 10694 00001B64 8A4EF4                  		mov	cl,[char_j] ; Disk number (0 to 7)
 10695                                  		;sub	ch,ch
 10696                                  		;shl	cx,1
 10697                                  		;shl	cx,1
 10698 00001B67 D0E1                    		shl	cl,1
 10699 00001B69 D0E1                    		shl	cl,1 ; 4 * disk number (every disk/MBR has 4 partition table entries) 
 10700                                  		;add	ax,cx ; Partition index in FDISK partitions data
 10701 00001B6B 00C8                    		add	al,cl
 10702                                  		;mov	cx,46
 10703                                  		;imul	cx
 10704 00001B6D B12E                    		mov	cl,46
 10705 00001B6F F6E1                    		mul	cl
 10706 00001B71 89C3                    		mov	bx,ax ; Partition data (structure) offset -of extended partition-
 10707                                   
 10708 00001B73 8B87[15C4]              		mov	ax,[part_table_start_cyl+bx]
 10709 00001B77 8946FC                  		mov	[partition_location],ax ; start cylinder of extended partition
 10710                                  
 10711                                  	;/* Go find extended boot records as long as there are more of them */
 10712                                  	; 	more_drives_exist = TRUE;
 10713                                  	;
 10714                                  	;/* Init the number of logical drives, for a array index */
 10715                                  	; 	num_logical_drives = c(0);
 10716                                  
 10717                                  		;mov	byte [more_drives_exist],1  ; TRUE
 10718 00001B7A C646FA00                		mov	byte [num_logical_drives],0
 10719                                  
 10720                                  		; 15/12/2018
 10721                                  		;jmp	short ipt_in_while ; 23/11/2018
 10722                                  
 10723                                  ; 15/12/2018
 10724                                  ;ipt_while_more_drives_exist:
 10725                                  ;
 10726                                  ;	;while (more_drives_exist)
 10727                                  ;	;	BEGIN
 10728                                  ;	;	/* Assume we won't find another logical drive */
 10729                                  ;	;	more_drives_exist = FALSE;
 10730                                  ;
 10731                                  ;		cmp	byte [more_drives_exist],0
 10732                                  ;		jne	short ipt_in_while
 10733                                  ;		jmp	ipt_while_end
 10734                                  
 10735                                  ipt_in_while:
 10736                                  		; 15/12/2018
 10737                                  		;mov	byte [more_drives_exist],0
 10738                                  
 10739                                  	;	/*Read in the extended boot record */
 10740                                  	;	if (read_boot_record(partition_location,j,uc(0),uc(1)))
 10741                                  	;	BEGIN
 10742                                  	;	   load_logical_drive(num_logical_drives,j);
 10743                                  
 10744                                  		;mov	al,1
 10745 00001B7E B80100                  		mov	ax,1 ; 11/12/2018
 10746 00001B81 50                      		push	ax
 10747 00001B82 28C0                    		sub	al,al ; 0
 10748 00001B84 50                      		push	ax
 10749 00001B85 8A46F4                  		mov	al,[char_j] ; Disk number (0 to 7)
 10750 00001B88 50                      		push	ax
 10751 00001B89 FF76FC                  		push	word [partition_location]
 10752 00001B8C E86304                  		call	read_boot_record
 10753                                  		;add	sp,8	; 22/12/2018
 10754                                  		;or	al,al
 10755                                  		;jz	short ipt_while_more_drives_exist
 10756                                  		;jc	short ipt_while_more_drives_exist ; 27/11/2018
 10757 00001B8F 72A8                    		jc	short ipt_while_end
 10758                                  		;
 10759 00001B91 8A46F4                  		mov	al,[char_j]
 10760 00001B94 50                      		push	ax
 10761 00001B95 8A46FA                  		mov	al,[num_logical_drives]
 10762 00001B98 50                      		push	ax
 10763 00001B99 E84302                  		call	load_logical_drive
 10764                                  		;pop	bx ; 06/01/2019
 10765                                  		;pop	bx
 10766                                  ipt_in_while_for:
 10767                                  		;  /* find the next logical drive */
 10768                                  		;  for (i = u(0); i < u(4); i++)
 10769                                  		;      BEGIN
 10770                                  		;      index = i*16;
 10771                                  
 10772                                  		;mov	word [unsigned_i],0
 10773 00001B9C C646F600                		mov	byte [unsigned_i],0 ; Partition number (0 to 3)
 10774                                  		;jmp	ipt_in_while_for_1
 10775                                  		; 14/12/2018
 10776 00001BA0 E95AFF                  		jmp	ipt_in_while_for_next
 10777                                  ipt_16:
 10778                                  		; 23/11/2018
 10779                                  		; Set drive letters and volume names
 10780                                  
 10781 00001BA3 C646F400                		mov	byte [char_j],0
 10782 00001BA7 EB55                    		jmp	short ipt_22
 10783                                  ipt_17:
 10784                                  		;inc	word [unsigned_i]
 10785 00001BA9 FE46F6                  		inc	byte [unsigned_i]
 10786                                  ipt_18:
 10787                                  		;cmp	word [unsigned_i],4
 10788 00001BAC 807EF604                		cmp	byte [unsigned_i],4
 10789 00001BB0 7349                    		jnb	short ipt_21
 10790                                  ipt_19:		
 10791                                  		; 23/11/2018
 10792                                  		;/* Look at all non-active primary partitions */  
 10793                                  
 10794 00001BB2 8A46F4                  		mov	al,[char_j] ; Disk number
 10795                                  		;sub	ah,ah
 10796                                  		;shl	ax,1
 10797                                  		;shl	ax,1
 10798 00001BB5 D0E0                    		shl	al,1
 10799 00001BB7 D0E0                    		shl	al,1 ; 4 partition table entries per disk/MBR
 10800                                  		;add	ax,[unsigned_i]
 10801 00001BB9 0246F6                  		add	al,[unsigned_i]
 10802                                  		;mov	cx,46
 10803                                  		;mul	cx
 10804 00001BBC B12E                    		mov	cl,46 ; Partition data (structure) size
 10805 00001BBE F6E1                    		mul	cl
 10806 00001BC0 89C3                    		mov	bx,ax ; Partition data address
 10807 00001BC2 80BF[17C4]01            		cmp	byte [part_table_sys_id+bx],1 ; DOS12
 10808 00001BC7 740E                    		je	short ipt_20
 10809 00001BC9 80BF[17C4]04            		cmp	byte [part_table_sys_id+bx],4 ; DOS16
 10810 00001BCE 7407                    		je	short ipt_20
 10811 00001BD0 80BF[17C4]06            		cmp	byte [part_table_sys_id+bx],6 ; DOSNEW
 10812 00001BD5 75D2                    		jne	short ipt_17
 10813                                  ipt_20:
 10814                                  		;mov	al,[char_j]
 10815                                  		;sub	ah,ah
 10816                                  		;shl	ax,1
 10817                                  		;shl	ax,1
 10818                                  		;add	ax,[unsigned_i]
 10819                                  		;mul	cx
 10820                                  		;mov	bx,ax
 10821 00001BD7 80BF[12C4]80            		cmp	byte [part_table_boot_ind+bx],80h
 10822 00001BDC 74CB                    		je	short ipt_17
 10823 00001BDE 80BF[3FC4]20            		cmp	byte [part_table_drive_letter+bx],' '
 10824 00001BE3 75C4                    		jne	short ipt_17
 10825 00001BE5 A0[1FA1]                		mov	al,[next_letter]
 10826 00001BE8 FE06[1FA1]              		inc	byte [next_letter]
 10827 00001BEC 8887[3FC4]              		mov	[part_table_drive_letter+bx],al
 10828                                  		
 10829                                  		; 14/12/2018
 10830                                  		;push	word [unsigned_i]
 10831 00001BF0 8A66F6                  		mov	ah,[unsigned_i] ; Partition number		
 10832 00001BF3 8A46F4                  		mov	al,[char_j] ; Disk number
 10833                                  		;push	ax
 10834 00001BF6 E86B00                  		call	get_volume
 10835                                  		;pop	bx
 10836                                  		;pop	bx
 10837 00001BF9 EBAE                    		jmp	short ipt_17
 10838                                  ipt_21:
 10839 00001BFB FE46F4                  		inc	byte [char_j]
 10840                                  ipt_22:
 10841                                  		; 23/11/2018
 10842                                  		;/* Look at all active primary partitions */
 10843                                  
 10844                                  		;mov	al,[char_j]
 10845 00001BFE A0[D5C3]                		mov	al,[number_of_drives]
 10846                                  		;cmp	byte [number_of_drives],al
 10847                                  		;jbe	short ipt_26
 10848 00001C01 3A46F4                  		cmp	al,[char_j]
 10849 00001C04 765B                    		jna	short ipt_26 ; 10/12/2018
 10850                                  		;mov	word [unsigned_i],0
 10851 00001C06 C646F600                		mov	byte [unsigned_i],0
 10852                                  ipt_23:
 10853 00001C0A 8A46F4                  		mov	al,[char_j] ; Disk number (0 to 7)
 10854                                  		;sub	ah,ah
 10855                                  		;shl	ax,1
 10856                                  		;shl	ax,1
 10857 00001C0D D0E0                    		shl	al,1
 10858 00001C0F D0E0                    		shl	al,1 ; 4 partition entries in a MBR
 10859                                  		;add	ax,[unsigned_i]
 10860 00001C11 0246F6                  		add	al,[unsigned_i] ; Partition index (for current disk)
 10861                                  		;mov	cx,46
 10862                                  		;mul	cx
 10863 00001C14 B12E                    		mov	cl,46
 10864 00001C16 F6E1                    		mul	cl
 10865 00001C18 89C3                    		mov	bx,ax	; Partition data offset
 10866 00001C1A 80BF[17C4]01            		cmp	byte [part_table_sys_id+bx],1 ; DOS12 (FAT12)
 10867 00001C1F 740E                    		je	short ipt_24
 10868 00001C21 80BF[17C4]04            		cmp	byte [part_table_sys_id+bx],4 ; DOS16 (FAT16)
 10869 00001C26 7407                    		je	short ipt_24
 10870 00001C28 80BF[17C4]06            		cmp	byte [part_table_sys_id+bx],6 ; DOSNEW (FAT16 big)
 10871 00001C2D 7522                    		jne	short ipt_25
 10872                                  ipt_24:
 10873                                  		;mov	al,[char_j]
 10874                                  		;sub	ah,ah
 10875                                  		;shl	ax,1
 10876                                  		;shl	ax,1
 10877                                  		;add	ax,[unsigned_i]
 10878                                  		;mul	cx
 10879                                  		;mov	bx,ax
 10880                                  
 10881 00001C2F 80BF[12C4]80            		cmp	byte [part_table_boot_ind+bx],80h ; ACTIVE ?
 10882 00001C34 751B                    		jne	short ipt_25
 10883 00001C36 80BF[3FC4]20            		cmp	byte [part_table_drive_letter+bx],' '
 10884 00001C3B 7514                    		jne	short ipt_25
 10885 00001C3D A0[1FA1]                		mov	al,[next_letter]
 10886 00001C40 FE06[1FA1]              		inc	byte [next_letter]
 10887 00001C44 8887[3FC4]              		mov	[part_table_drive_letter+bx],al
 10888                                  		; 14/12/2018
 10889                                  		;push	word [unsigned_i]
 10890 00001C48 8A66F6                  		mov	ah,[unsigned_i] ; Partition number		
 10891 00001C4B 8A46F4                  		mov	al,[char_j] ; Disk number
 10892                                  		;push	ax
 10893 00001C4E E81300                  		call	get_volume
 10894                                  		;pop	bx
 10895                                  		;pop	bx
 10896                                  ipt_25:
 10897                                  		;inc	word [unsigned_i]
 10898 00001C51 FE46F6                  		inc	byte [unsigned_i]
 10899                                  		;cmp	word [unsigned_i],4
 10900 00001C54 807EF604                		cmp	byte [unsigned_i],4
 10901 00001C58 72B0                    		jb	short ipt_23
 10902                                  		;mov	word [unsigned_i],0
 10903 00001C5A C646F600                		mov	byte [unsigned_i],0
 10904                                  		;jmp	ipt_18
 10905 00001C5E E951FF                  		jmp	ipt_19 ; 23/11/2018
 10906                                  ipt_26:
 10907                                  		; 23/11/2018
 10908                                  		;pop	si
 10909                                  		;pop	di
 10910 00001C61 89EC                    		mov	sp,bp
 10911                                  		;pop	bp
 10912 00001C63 C3                      		retn
 10913                                  
 10914                                  ; ----------------------------------------------------------------------------
 10915                                  
 10916                                  ; convert.c (FDISK, MSDOS 6.0, 1991)
 10917                                  
 10918                                  ;numsecs_to_mbytes:
 10919                                  ;		; INPUT: DX:AX = Sector count (32 bit)	
 10920                                  ;		;push	bp
 10921                                  ;		;mov	bp,sp
 10922                                  ;		;mov	ax,[bp+4] ; sector count lw
 10923                                  ;		;mov	dx,[bp+6] ; sector count hw
 10924                                  ;
 10925                                  ;	;sectors_in_one_meg = u(ONE_MEG / bytes_in_one_sector);
 10926                                  ;	;mbytes_out = f((numsecs + ul(sectors_in_one_meg/2)) / sectors_in_one_meg)
 10927                                  ;
 10928                                  ;		add	ax,1024 ; round up
 10929                                  ;		adc	dx,0
 10930                                  ;			; DX:AX = (X kilo byte)*2 sectors
 10931                                  ;		mov	cl,11 ; / 2048
 10932                                  ;		call	shr32
 10933                                  ;			; (X kilo bytes)*2 / 2048 = X/1024 mega bytes
 10934                                  ;		;mov	sp,bp
 10935                                  ;		;pop	bp
 10936                                  ;		retn
 10937                                  
 10938                                  ; ----------------------------------------------------------------------------
 10939                                  
 10940                                  ; convert.c (FDISK, MSDOS 6.0, 1991)
 10941                                  
 10942                                  ;mbytes_to_percent:
 10943                                  ;		; 21/11/2018
 10944                                  ;
 10945                                  ;	;%define percent    bp-2
 10946                                  ;	%define partmbytes  bp+4  ; mbytes_used
 10947                                  ;	%define	totalmbytes bp+6  ; total_cap	
 10948                                  ;
 10949                                  ;		push	bp
 10950                                  ;		mov	bp,sp
 10951                                  ;		;xor	bx,bx ; 0
 10952                                  ;		;push	bx
 10953                                  ;		
 10954                                  ;		;if (mbytes_used) {
 10955                                  ;
 10956                                  ;		;cmp	word [partmbytes],0
 10957                                  ;		;je	short mtp_0
 10958                                  ;		mov	ax,[partmbytes]
 10959                                  ;		or	ax,ax
 10960                                  ;		jz	short mtp_0
 10961                                  ;
 10962                                  ;		;large_number = ( mbytes_used * 100L ) +total_cap/2;
 10963                                  ;
 10964                                  ;		;mov	ax,[totalmbytes]
 10965                                  ;		;sub	dx,dx
 10966                                  ;		;push	dx ; divisor_hw = 0
 10967                                  ;		;push	ax ; divisor_lw
 10968                                  ;		;;;push	ax ;* divisor (16 bit)
 10969                                  ;		mov	cx,[totalmbytes] ; divisor (16 bit)
 10970                                  ;		;mov	ax,100
 10971                                  ;		;mul	word [partmbytes] ; X
 10972                                  ;		mov	dx,100
 10973                                  ;		mul	dx		
 10974                                  ;
 10975                                  ;		;mov	cx,[totalmbytes]
 10976                                  ;		;shr	cx,1
 10977                                  ;		;add	ax,cx
 10978                                  ;		
 10979                                  ;		;;;mov	bx,[totalmbytes]  ; Y
 10980                                  ;		mov	bx,cx
 10981                                  ;		shr	bx,1 ; 1/2 Y
 10982                                  ;		add	ax,bx ; ((100*X)/Y)+(0.5)*Y/Y
 10983                                  ;		adc	dx,0
 10984                                  ;		
 10985                                  ;		;percentage_out = (unsigned) (large_number/total_cap);
 10986                                  ;
 10987                                  ;		;;;pop	cx ;* 21/11/2018 - divisor (16 bit)
 10988                                  ;		;push	dx ; dividend_hw
 10989                                  ;		;push	ax ; dividend_lw
 10990                                  ;		;call	div32
 10991                                  ;
 10992                                  ;		; dx:ax = dividend (32 bit)
 10993                                  ;		; cx = divisor (16 bit)
 10994                                  ;		call	div32
 10995                                  ;		;mov	[percent],ax
 10996                                  ;
 10997                                  ;		;if (percentage_out > u(100)) percentage_out = u(100);
 10998                                  ;
 10999                                  ;		cmp	ax,100
 11000                                  ;		jbe	short mtp_0
 11001                                  ;		;mov	word [percent],100
 11002                                  ;		mov	ax,100
 11003                                  ;		;jmp	short mtp_1
 11004                                  ;mtp_0:
 11005                                  ;		;mov	word [percent],0
 11006                                  ;mtp_1:
 11007                                  ;		;mov	ax,[percent]
 11008                                  ;		;mov	sp,bp
 11009                                  ;		pop	bp
 11010                                  ;
 11011                                  ;		retn	
 11012                                  
 11013                                  ; ----------------------------------------------------------------------------
 11014                                  
 11015                                  ;div32:
 11016                                  ;	%define dividend_lw bp+4
 11017                                  ;	%define dividend_hw bp+6
 11018                                  ;	%define divisor_lw  bp+8
 11019                                  ;	%define divisor_hw  bp+10
 11020                                  ;
 11021                                  ;		push	bp
 11022                                  ;		mov	bp,sp
 11023                                  ;		push	bx
 11024                                  ;		push	si
 11025                                  ;		mov	ax,[divisor_hw]
 11026                                  ;		or	ax,ax
 11027                                  ;		jnz	short div32_0
 11028                                  ;		mov	cx,[divisor_lw]
 11029                                  ;		mov	ax,[dividend_hw]
 11030                                  ;		xor	dx,dx
 11031                                  ;		div	cx
 11032                                  ;		mov	bx,ax
 11033                                  ;		mov	ax,[dividend_lw]
 11034                                  ;		div	cx
 11035                                  ;		mov	dx,bx
 11036                                  ;		jmp	short div32_4
 11037                                  ;div32_0:
 11038                                  ;		mov	cx,ax
 11039                                  ;		mov	bx,[divisor_lw]
 11040                                  ;		mov	dx,[dividend_hw]
 11041                                  ;		mov	ax,[dividend_lw]
 11042                                  ;div32_1:
 11043                                  ;		shr	cx,1
 11044                                  ;		rcr	bx,1
 11045                                  ;		shr	dx,1
 11046                                  ;		rcr	ax,1
 11047                                  ;		or	cx,cx
 11048                                  ;		jnz	short div32_1
 11049                                  ;		div	bx
 11050                                  ;		mov	si,ax
 11051                                  ;		mul	word [divisor_hw]
 11052                                  ;		xchg	ax,cx
 11053                                  ;		mov	ax,[divisor_lw]
 11054                                  ;		mul	si
 11055                                  ;		add	dx,cx
 11056                                  ;		jc	short div32_2
 11057                                  ;		cmp	dx,[dividend_hw]
 11058                                  ;		ja	short div32_2
 11059                                  ;		jb	short div32_3
 11060                                  ;		cmp	ax,[dividend_lw]
 11061                                  ;		jbe	short div32_3
 11062                                  ;div32_2:
 11063                                  ;		dec	si
 11064                                  ;div32_3:
 11065                                  ;		xor	dx,dx
 11066                                  ;		xchg	ax,si
 11067                                  ;div32_4:
 11068                                  ;		pop	si
 11069                                  ;		pop	bx
 11070                                  ;		pop	bp
 11071                                  ;		retn	8
 11072                                  
 11073                                  ;		mov	cx,[divisor_lw]
 11074                                  ;		mov	ax,[dividend_hw]
 11075                                  ;		xor	dx,dx
 11076                                  ;		div	cx
 11077                                  ;		mov	bx,ax
 11078                                  ;		mov	ax,[dividend_lw]
 11079                                  ;		div	cx
 11080                                  ;		mov	dx,bx
 11081                                  ;		jmp	short div32_4
 11082                                  ;
 11083                                  ;div32:
 11084                                  ;		; 21/11/2018
 11085                                  ;		; DX:AX = Dividend
 11086                                  ;		; CX = Divisor
 11087                                  ;
 11088                                  ;		mov	bx,ax  ; dividend_lw	
 11089                                  ;		mov	ax,dx  ; dividend_hw
 11090                                  ;		xor	dx,dx
 11091                                  ;		div	cx	
 11092                                  ;		xchg	bx,ax
 11093                                  ;		div	cx
 11094                                  ;		;mov	dx,bx
 11095                                  ;		xchg	dx,bx
 11096                                  ;
 11097                                  ;		; DX:AX = Quotient
 11098                                  ;		; BX = Remainder
 11099                                  ;
 11100                                  ;		retn
 11101                                  
 11102                                  ; ----------------------------------------------------------------------------
 11103                                  ; fdisk.c (FDISK, MSDOS 6.0, 1991)	
 11104                                  ; ----------------------------------------------------------------------------
 11105                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 23/11/2018)
 11106                                  
 11107                                  ;/*  */
 11108                                  ;void get_volume(j,i)                                                    
 11109                                  ;									/*C21*/
 11110                                  ;unsigned char j;                                                        
 11111                                  ;unsigned i;                                                             
 11112                                  ;									/*C21*/
 11113                                  ;BEGIN                                                                   
 11114                                  ;									/*C21*/
 11115                                  ;char     volume_label[13];                                              
 11116                                  ;unsigned k;                                                             
 11117                                  ;unsigned length;                                                        
 11118                                  ;									/*C21*/
 11119                                  ;    /* See if the disk has already been formated */                     
 11120                                  ;    if (check_format(part_table[j][i].drive_letter) == TRUE )           
 11121                                  ;       BEGIN                                                            
 11122                                  ;	/* get volume and system info */                                
 11123                                  ;									/*C21*/
 11124                                  ;	for (k = u(0); k < u(12); k++)                                  
 11125                                  ;	   BEGIN                                                        
 11126                                  ;	    part_table[j][i].vol_label[k]=u(0);                         
 11127                                  ;	   END                                                          
 11128                                  ;									/*C21*/
 11129                                  ;	for (k = u(0); k < u(9); k++)                                   
 11130                                  ;	   BEGIN                                                        
 11131                                  ;	    part_table[j][i].system[k]=u(0);                            
 11132                                  ;	   END                                                          
 11133                                  ;									/*C21*/
 11134                                  ;	get_volume_string(part_table[j][i].drive_letter,&volume_label[0]);
 11135                                  ;									/*C21*/
 11136                                  ;	for (k = u(0); k < strlen(volume_label); k++)                   
 11137                                  ;	   BEGIN                                                        
 11138                                  ;	    part_table[j][i].vol_label[k]=volume_label[k];              
 11139                                  ;	   END                                                          
 11140                                  ;									/*C21*/
 11141                                  ;	/* Now try to get it using GET MEDIA ID */                      
 11142                                  ;	if (get_fs_and_vol(part_table[j][i].drive_letter))              
 11143                                  ;	   BEGIN                                                        
 11144                                  ;	    for (k=u(0); k < u(8); k++)                                 
 11145                                  ;	       BEGIN                                                    
 11146                                  ;		if (dx_buff.file_system[k] != ' ')                      
 11147                                  ;		    length = k+1;                                       
 11148                                  ;	       END                                                      
 11149                                  ;	    strncpy(part_table[j][i].system,&dx_buff.file_system[0],u(length));
 11150                                  ;	   END                                                          
 11151                                  ;	else                                                            
 11152                                  ;	   BEGIN                                                        
 11153                                  ;	    if (part_table[j][i].num_sec > (unsigned long)FAT16_SIZE)   
 11154                                  ;		strcpy(part_table[j][i].system,FAT16);                  
 11155                                  ;	    else                                                        
 11156                                  ;		strcpy(part_table[j][i].system,FAT12);                  
 11157                                  ;	   END                                                          
 11158                                  ;       END                                                              
 11159                                  ;    else                                                                
 11160                                  ;       BEGIN                                                            
 11161                                  ;	/* set up to no file system or volume label */                  
 11162                                  ;	strcpy(part_table[j][i].vol_label,NOVOLUME);                    
 11163                                  ;	strcpy(part_table[j][i].system,NOFORMAT);                       
 11164                                  ;      END                                                              
 11165                                  ;   return;                                                             
 11166                                  ;END 
 11167                                  
 11168                                  ;NOTE: 'get_volume' is not compatible with MSDOS 3.3 (and Retro DOS v3.0)
 11169                                  ;	(23/11/2018 - Erdogan Tan)
 11170                                  ; Solution: For MSDOS 3.3 or Retro DOS v3.0, this FDISK code must be modified
 11171                                  ; to exclude volume name in partition table (displaying, deleting) procedures.
 11172                                  
 11173                                  get_volume:
 11174                                  
 11175                                  	;%define _k_	    bp-18 ; unsigned integer (word)
 11176                                  	;%define vol_label  bp-16 ; char volume_label(13) ; 13 bytes
 11177                                  	;%define _length_   bp-2  ; unsigned integer (word)	 
 11178                                  
 11179                                  	%define vol_label   bp-14 ; char volume_label(13) ; 13 bytes ; *****
 11180                                  
 11181                                  	;%define j_disk	    bp+4  ; unsigned char (byte)	
 11182                                  	;%define i_partition bp+6  ; unsigned integer (word)
 11183                                  
 11184                                  		; 14/12/2018
 11185                                  		; INPUT:
 11186                                  		;   AL = Disk/Drive number (0 to 7)
 11187                                  		;   AH = Partition number (0 to 3)		
 11188                                  
 11189 00001C64 55                      		push	bp
 11190 00001C65 89E5                    		mov	bp,sp
 11191                                  		;sub	sp,18
 11192 00001C67 83EC0E                  		sub	sp,14 ; *****
 11193                                  		;push	si
 11194                                  		;push	di ; *
 11195                                  		
 11196                                  		; 14/12/2018
 11197                                  		;mov	al,[j_disk] ; Disk number (0 to 7)
 11198                                  		; AL = Disk number		
 11199                                  
 11200                                  		;sub	ah,ah
 11201                                  		;shl	ax,1
 11202                                  		;shl	ax,1
 11203                                  		;add	ax,[i_partition] ; Partition number (0 to 3)
 11204                                  
 11205 00001C6A D0E0                    		shl	al,1
 11206 00001C6C D0E0                    		shl	al,1
 11207                                  		
 11208                                  		;14/12/2018		
 11209                                  		;add	al,[i_partition]
 11210 00001C6E 00E0                    		add	al,ah  ; ah = Partition number
 11211                                  
 11212                                  		;mov	cx,46
 11213                                  		;mul	cx
 11214 00001C70 B92E00                  		mov	cx,46
 11215 00001C73 F6E1                    		mul	cl
 11216                                  		;mov	bx,ax
 11217 00001C75 89C6                    		mov	si,ax ; ** ; 12/12/2018
 11218                                  
 11219                                  		;mov	al,[part_table_drive_letter+bx]
 11220 00001C77 8A84[3FC4]              		mov	al,[part_table_drive_letter+si]
 11221                                  		; 24/11/2018
 11222                                  		;push	ax
 11223 00001C7B E8AC00                  		call	check_format
 11224                                  		;pop	bx
 11225                                  		;dec	al
 11226                                  		;jz	short gv_1
 11227                                  
 11228 00001C7E 7302                    		jnc	short gv_1
 11229 00001C80 EB73                    		jmp	gv_11
 11230                                  gv_1:
 11231                                  		;mov	word [_k_],0
 11232                                  gv_2:
 11233                                  ;		;mov	al,[j_disk]
 11234                                  ;		;sub	ah,ah
 11235                                  ;		;shl	ax,1
 11236                                  ;		;shl	ax,1
 11237                                  ;		;add	ax,[i_partition]
 11238                                  ;		;mov	cx,46
 11239                                  ;		;mul	cx
 11240                                  ;		;mov	si,ax ; ** ; 12/12/2018
 11241                                  ;		mov	bx,[_k_]
 11242                                  ;		mov	byte [part_table_vol_label+bx+si],0
 11243                                  ;		;inc	word [_k_]
 11244                                  ;		inc	byte [_k_]
 11245                                  ;		;cmp	word [_k_],12
 11246                                  ;		cmp	byte [_k_],12
 11247                                  ;		jb	short gv_2
 11248                                  ;		;mov	word [_k_],0
 11249                                  ;		mov	byte [_k_],0
 11250                                  
 11251                                  ;		; 23/11/2018
 11252                                  ;		xor	ax,ax
 11253                                  ;		mov	di,part_table_vol_label ; *
 11254                                  ;		add	di,si ; ** ; 12/12/2018
 11255                                  ;		;mov	cx,6
 11256                                  ;		mov	cl,6
 11257                                  ;		rep	stosw
 11258                                  
 11259                                  		; 23/11/2018
 11260 00001C82 31C0                    		xor	ax,ax
 11261 00001C84 BF[2AC4]                		mov	di,part_table_vol_label ; *
 11262 00001C87 01F7                    		add	di,si ; ** ; 12/12/2018
 11263                                  			; clear 12+9 bytes vol_label & system fields
 11264                                  		;mov	cl,10
 11265 00001C89 B90A00                  		mov	cx,10 ; 17/12/2018 (ch>0)
 11266 00001C8C F3AB                    		rep	stosw ; clear 20 bytes
 11267 00001C8E AA                      		stosb	      ; and then clear +1 byte (total 21 bytes) 		
 11268                                  gv_3:
 11269                                  ;		;mov	al,[j_disk]
 11270                                  ;		;;sub	ah,ah
 11271                                  ;		;;shl	ax,1
 11272                                  ;		;;shl	ax,1
 11273                                  ;		;shl	al,1
 11274                                  ;		;shl	al,1
 11275                                  ;		;;add	ax,[i_partition]
 11276                                  ;		;add	al,[i_partition]
 11277                                  ;		;;;mov	cl,46
 11278                                  ;		;mul	cx
 11279                                  ;		;mov	si,ax ; ** ; 12/12/2018
 11280                                  ;		mov	bx,[_k_]
 11281                                  ;		mov	byte [part_table_system+bx+si],0
 11282                                  ;		inc	word [_k_]
 11283                                  ;		cmp	word [_k_],9
 11284                                  ;		jb	short gv_3
 11285                                  
 11286                                  ;		; 23/11/2018
 11287                                  ;		;xor	ax,ax
 11288                                  ;		;mov	di,part_table_system ; *
 11289                                  ;		;add	di,si ; ** ; 12/12/2018
 11290                                  ;		  ; part_table_system is just after
 11291                                  ;		  ; part_table_volume_label
 11292                                  ;		  ; (di already points to part_table_system+si)	
 11293                                  ;		;mov	cx,9
 11294                                  ;		mov	cl,9
 11295                                  ;		rep	stosb
 11296                                  
 11297                                  	;get_volume_string(part_table[j][i].drive_letter,&volume_label[0])
 11298                                  
 11299 00001C8F 8D46F2                  		lea	ax,[vol_label]
 11300 00001C92 50                      		push	ax
 11301                                  
 11302                                  		;mov	al,[j_disk]
 11303                                  		;sub	ah,ah
 11304                                  		;shl	ax,1
 11305                                  		;shl	ax,1
 11306                                  		;add	ax,[i_partition]
 11307                                  		;mov	cx,46
 11308                                  		;mul	cx
 11309                                  		;mov	bx,ax
 11310                                  		;mov	si,ax ; ** ; 12/12/2018
 11311                                  
 11312                                  		;mov	al,[part_table_drive_letter+bx]
 11313 00001C93 8A84[3FC4]              		mov	al,[part_table_drive_letter+si]
 11314 00001C97 50                      		push	ax
 11315 00001C98 E8B800                  		call	get_volume_string
 11316                                  		;pop	bx ; 05/01/2019
 11317                                  		;pop	bx
 11318                                  
 11319                                  		;;mov	word [_k_],0
 11320                                  		;mov	byte [_k_],0
 11321                                  		;jmp	short gv_5
 11322                                  ;gv_4:
 11323                                  		;mov	si,[_k_]
 11324                                  		;mov	al,[vol_label+si]
 11325                                  		;mov	cx,ax
 11326                                  		;mov	al,[j_disk]
 11327                                  		;sub	ah,ah
 11328                                  		;shl	ax,1
 11329                                  		;shl	ax,1
 11330                                  		;add	ax,[i_partition]
 11331                                  		;mov	bx,46
 11332                                  		;mul	bx
 11333                                  		;mov	bx,ax
 11334                                  		;mov	[part_table_vol_label+bx+si],cl
 11335                                  		;inc	word [_k_]
 11336                                  ;gv_5:
 11337                                  		;lea	ax,[vol_label]
 11338                                  		;push	ax
 11339                                  		;call	strlen
 11340                                  		;pop	bx
 11341                                  		;cmp	ax,[_k_]
 11342                                  		;ja	short gv_4
 11343                                  
 11344                                  		; 23/11/2018
 11345                                  		; Copy/Move volume name to partition data field
 11346 00001C9B 89F7                    		mov	di,si ; ** ; 12/12/2018
 11347 00001C9D 81C7[2AC4]              		add	di,part_table_vol_label
 11348 00001CA1 56                      		push	si ; ** ; 12/12/2018
 11349 00001CA2 8D76F2                  		lea	si,[vol_label]
 11350                                  		;call	strlen
 11351                                  		; cx = string length (except terminating zero)
 11352                                  		;jcxz	gv_5
 11353                                  		;;cmp	cx,12
 11354                                  		;;ja	short gv_4
 11355                                  		;mov	cx,12
 11356                                  ;gv_4:
 11357                                  		;rep	movsb
 11358                                  ;gv_5:
 11359                                  		; 05/01/2019
 11360 00001CA5 B10C                    		mov	cl,12
 11361                                  gv_4:
 11362 00001CA7 AC                      		lodsb
 11363 00001CA8 20C0                    		and	al,al
 11364 00001CAA 7403                    		jz	short gv_5
 11365 00001CAC AA                      		stosb
 11366                                  		;jmp	short gv_4
 11367 00001CAD E2F8                    		loop	gv_4
 11368                                  gv_5:
 11369                                  		;mov	al,[j_disk]
 11370                                  		;sub	ah,ah
 11371                                  		;shl	ax,1
 11372                                  		;shl	ax,1
 11373                                  		;add	ax,[i_partition]
 11374                                  		;mov	cx,46
 11375                                  		;mul	cx
 11376                                  		;mov	bx,ax
 11377                                  		;;pop	dx ; **
 11378                                  		;;pop	bx,dx ; **
 11379                                  
 11380 00001CAF 5F                      		pop	di ; ** ; 12/12/2018
 11381                                  
 11382                                  		;mov	bx,di ; **
 11383                                  		;mov	al,[part_table_drive_letter+bx]
 11384 00001CB0 8A85[3FC4]              		mov	al,[part_table_drive_letter+di] ; 12/12/2018
 11385                                  		;push	ax
 11386 00001CB4 E8E700                  		call	get_fs_and_vol
 11387                                  		;pop	bx
 11388                                  		;or	al,al
 11389                                  		;jz	short gv_8
 11390 00001CB7 721F                    		jc	short gv_8 ; 24/11/2018
 11391                                  
 11392                                  		;mov	word [_k_],0
 11393 00001CB9 31DB                    		xor	bx,bx ; *****
 11394                                  gv_6:
 11395                                  		;mov	bx,[_k_] ; *****
 11396 00001CBB 80BF[7CA0]20            		cmp	byte [dx_buff_file_system+bx],' '
 11397 00001CC0 7403                    		je	short gv_7
 11398                                  		;lea	ax,[bx+1]
 11399                                  		;mov	[_length_],ax
 11400 00001CC2 8D4F01                  		lea	cx,[bx+1] ; *****
 11401                                  gv_7:
 11402                                  		;inc	word [_k_]
 11403                                  		;inc	byte [_k_]
 11404 00001CC5 FEC3                    		inc	bl ; *****
 11405                                  		;cmp	word [_k_],8
 11406                                  		;cmp	byte [_k_],8
 11407 00001CC7 80FB08                  		cmp	bl,8 ; *****
 11408 00001CCA 72EF                    		jb	short gv_6
 11409                                  
 11410                                  ;		push	word [_length_] ; n
 11411                                  ;		mov	ax,dx_buff_file_system
 11412                                  ;		push	ax  		; src	
 11413                                  ;
 11414                                  ;		mov	al,[j_disk]
 11415                                  ;		;sub	ah,ah
 11416                                  ;		;shl	ax,1
 11417                                  ;		;shl	ax,1
 11418                                  ;		;add	ax,[i_partition]
 11419                                  ;		shl	al,1
 11420                                  ;		shl	al,1
 11421                                  ;		add	al,[i_partition]
 11422                                  ;		
 11423                                  ;		;mov	cx,46
 11424                                  ;		;mul	cx
 11425                                  ;		mov	cl,46
 11426                                  ;		mul	cl
 11427                                  ;
 11428                                  ;		mov	dx,ax ; ***	
 11429                                  ;
 11430                                  ;		add	ax,part_table_system
 11431                                  ;		push	ax		 ; dest
 11432                                  ;
 11433                                  ;		call	strncpy  ; strncpy (dest,src,n)
 11434                                  ;		add	sp,6
 11435                                  ;		jmp	short gv_13
 11436                                  
 11437                                  		; 23/11/2018
 11438                                  ;		mov	ah,46
 11439                                  ;		mul	ah
 11440                                  ;		;mov	dx,ax ; **
 11441                                  		
 11442                                  		;mov	cx,[_length_] ; *****
 11443                                  		;jcxz	short gv_8
 11444                                  
 11445 00001CCC BE[7CA0]                		mov	si,dx_buff_file_system
 11446                                  		;mov	di,ax
 11447                                  		; 12/12/2018
 11448                                  		;mov	di,dx ; **
 11449                                  		; DI = Partition data/structure offset
 11450 00001CCF 81C7[36C4]              		add	di,part_table_system
 11451 00001CD3 E84100                  		call	strncpy
 11452                                  			; cx = 0
 11453 00001CD6 EB2E                    		jmp	short gv_13
 11454                                  gv_8:
 11455                                  		;mov	al,[j_disk]
 11456                                  		;sub	ah,ah
 11457                                  		;;shl	ax,1
 11458                                  		;;shl	ax,1
 11459                                  		;;add	ax,[i_partition]
 11460                                  		;shl	al,1
 11461                                  		;shl	al,1
 11462                                  		;add	al,[i_partition]
 11463                                  		
 11464                                  		;;mov	cx,46
 11465                                  		;;mul	cx
 11466                                  		;mov	cl,46
 11467                                  		;mul	cl
 11468                                  		;mov	bx,ax
 11469                                  
 11470                                  		; 12/12/2018
 11471                                  		;mov	bx,dx; **
 11472                                  	
 11473                                  		; DI = Partition data/structure offset ; **
 11474                                  		
 11475 00001CD8 B8[675F]                		mov	ax,FAT16 ; "FAT16   " ; !*!
 11476                                  
 11477                                  		;cmp	word [part_table_num_sec_hw+bx],0
 11478 00001CDB 83BD[22C4]00            		cmp	word [part_table_num_sec_hw+di],0
 11479                                  		;jne	short gv_9
 11480 00001CE0 770B                    		ja	short gv_9
 11481                                  		;cmp	word [part_table_num_sec_lw+bx],32680
 11482 00001CE2 81BD[20C4]A87F          		cmp	word [part_table_num_sec_lw+di],32680
 11483                                  		;jbe	short gv_10
 11484 00001CE8 7703                    		ja	short gv_9 ; !*!
 11485 00001CEA B8[705F]                		mov	ax,FAT12 ; "FAT12   " ; !*!
 11486                                  gv_9:
 11487                                  		;;mov	ax,FAT16 ; "FAT16   " ; !*!
 11488                                  		;push	ax
 11489                                  		;add	bx,part_table_system
 11490                                  		;push	bx
 11491                                  
 11492                                  		; 12/12/2018
 11493 00001CED 89C6                    		mov	si,ax	; strcpy, source
 11494                                  		;mov	di,bx	; strcpy, destination	
 11495 00001CEF 81C7[36C4]              		add	di,part_table_system
 11496                                  
 11497 00001CF3 EB0E                    		jmp	short gv_12
 11498                                  gv_10:
 11499                                  		;mov	ax,FAT12 ; "FAT12   "
 11500                                  		;push	ax
 11501                                  		;mov	al,[j_disk]
 11502                                  		;sub	ah,ah
 11503                                  		;shl	ax,1
 11504                                  		;shl	ax,1
 11505                                  		;add	ax,[i_partition]
 11506                                  		;mul	cx
 11507                                  		;add	ax,part_table_system
 11508                                  		;push	ax
 11509                                  		;jmp	short gv_12
 11510                                  gv_11:
 11511 00001CF5 56                      		push	si ; ** ; 12/12/2018
 11512                                  
 11513                                  		;mov	ax,NOVOLUME
 11514                                  		;push	ax
 11515                                  			
 11516                                  		; 05/01/2019			
 11517                                  		;mov	si,NOVOLUME ; ****
 11518                                  
 11519                                  ;		mov	al,[j_disk]
 11520                                  ;		;sub	ah,ah
 11521                                  ;		;shl	ax,1
 11522                                  ;		;shl	ax,1
 11523                                  ;		;add	ax,[i_partition]
 11524                                  ;		shl	al,1
 11525                                  ;		shl	al,1
 11526                                  ;		add	al,[i_partition]
 11527                                  ;		
 11528                                  ;		;mov	cx,46
 11529                                  ;		;mul	cx
 11530                                  ;		mov	cl,46
 11531                                  ;		mul	cl
 11532                                  ;
 11533                                  ;		;;mov	cx,ax
 11534                                  ;		;mov	si,ax
 11535                                  ;		;add	ax,part_table_vol_label
 11536                                  ;		;push	ax
 11537                                  ;		;;mov	si,cx
 11538                                  ;		;call	strcpy
 11539                                  ;		;pop	bx
 11540                                  ;		;pop	bx
 11541                                  ;	
 11542                                  ;		;mov	dx,ax ; **
 11543                                  		
 11544                                  		;mov	di,dx ; ** ; ****
 11545                                  		
 11546 00001CF6 5F                      		pop	di ; ** ; 12/12/2018
 11547                                  
 11548                                  		; 05/01/2019
 11549                                  		;add	di,part_table_vol_label
 11550                                  		
 11551                                  		; 05/01/2019
 11552                                  		;call	strcpy 
 11553                                  
 11554 00001CF7 C685[2AC4]00            		mov	byte [di+part_table_vol_label],0 ; NOVOLUME
 11555                                  	
 11556                                  		;mov	ax,UNKNOWN ; "UNKNOWN "
 11557                                  		;push	ax
 11558                                  
 11559 00001CFC BE[7A5F]                		mov	si,UNKNOWN ; ****	
 11560                                  		
 11561                                  		;add	si,part_table_system
 11562                                  		;push	si
 11563                                  		
 11564                                  		;mov	di,dx ; ** ; ****
 11565 00001CFF 81C7[36C4]              		add	di,part_table_system ; 05/01/2019
 11566                                  gv_12:
 11567 00001D03 E81D00                  		call	strcpy
 11568                                  		;pop	bx
 11569                                  		;pop	bx
 11570                                  gv_13:
 11571                                  		;pop	di ; *
 11572                                  		;pop	si
 11573 00001D06 89EC                    		mov	sp,bp
 11574 00001D08 5D                      		pop	bp
 11575 00001D09 C3                      		retn
 11576                                  
 11577                                  ; strlen (Microsoft C 6.0 runtime library, MSDOS 6.0, 1991)	
 11578                                  ; ============================================================================
 11579                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 23/11/2018)
 11580                                  
 11581                                  ; Get (ASCIIZ) string length (except terminating null/zero character)
 11582                                  
 11583                                  ;strlen
 11584                                  ;------
 11585                                  ;size_t strlen ( const char * str );
 11586                                  ;Get string length
 11587                                  ;Returns the length of the C string str.
 11588                                  
 11589                                  ;The length of a C string is determined by the terminating null-character: 
 11590                                  ;A C string is as long as the number of characters between the beginning 
 11591                                  ;of the string and the terminating null character 
 11592                                  ;(without including the terminating null character itself).
 11593                                   
 11594                                  strlen:	
 11595                                  		;push	bp
 11596                                  		;mov	bp,sp
 11597                                  		;mov	dx,di
 11598                                  		;mov	ax,ds
 11599                                  		;mov	es,ax
 11600                                  		;mov	di,[bp+4] ; String address
 11601                                  		; 23/11/2018	
 11602 00001D0A 89F7                    		mov	di,si ; String address
 11603                                  		;xor	ax,ax
 11604 00001D0C 30C0                    		xor	al,al
 11605 00001D0E B9FFFF                  		mov	cx,65535 ; 0FFFFh
 11606 00001D11 F2AE                    		repne scasb
 11607 00001D13 F7D1                    		not	cx
 11608 00001D15 49                      		dec	cx ; except terminating null character
 11609                                  		;xchg	ax,cx
 11610                                  		;mov	di,dx
 11611                                  		;pop	bp
 11612                                  		; cx = string length
 11613 00001D16 C3                      		retn
 11614                                  
 11615                                  ; strncpy (Microsoft C 6.0 runtime library, MSDOS 6.0, 1991)	
 11616                                  ; ============================================================================
 11617                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 23/11/2018)
 11618                                  
 11619                                  ; char *strncpy(char *dest, const char *src, size_t n)
 11620                                  
 11621                                  ;strncpy
 11622                                  ;-------
 11623                                  ;char * strncpy ( char * destination, const char * source, size_t num );
 11624                                  ;Copy characters from string
 11625                                  ;Copies the first num characters of source to destination. 
 11626                                  ;If the end of the source C string (which is signaled by a null-character)
 11627                                  ;is found before num characters have been copied, destination is padded with zeros
 11628                                  ;until a total of num characters have been written to it.
 11629                                  ;
 11630                                  ;No null-character is implicitly appended at the end of destination if 
 11631                                  ;source is longer than num. Thus, in this case, 
 11632                                  ;destination shall not be considered a null terminated C string
 11633                                  ;(reading it as such would overflow).
 11634                                  ;destination and source shall not overlap 
 11635                                  ;(see memmove for a safer alternative when overlapping).
 11636                                  
 11637                                  strncpy:
 11638                                  	;%define _dest_	bp+4 ; word ; destination address pointer
 11639                                  	;%define _src	bp+6 ; word ; source address pointer 	
 11640                                  	;%define _n_	bp+8 ; word ; length (n characters/bytes)
 11641                                  
 11642                                  		;push	bp
 11643                                  		;mov	bp,sp
 11644                                  		;;push	di
 11645                                  		;;;push	si
 11646                                  		;;push	ds
 11647                                  		;;pop	es
 11648                                  		;mov	di,[_dest_]
 11649                                  		;mov	si,[_src_]
 11650                                  		;mov	bx,di
 11651                                  		;mov	cx,[_n_]
 11652                                  		;jcxz	short strncpy_2
 11653                                  strncpy_0:
 11654 00001D17 AC                      		lodsb
 11655 00001D18 08C0                    		or	al,al
 11656 00001D1A 7404                    		jz	short strncpy_1
 11657 00001D1C AA                      		stosb
 11658 00001D1D E2F8                    		loop	strncpy_0
 11659 00001D1F C3                      		retn ; 11/12/2018
 11660                                  ;strncpy_1:
 11661                                  		;xor	al,al
 11662                                  strncpy_1: ; 23/11/2018
 11663 00001D20 F3AA                    		rep	stosb
 11664                                  strncpy_2:
 11665                                  		;mov	ax,bx
 11666                                  		;pop	si
 11667                                  		;pop	di
 11668                                  		;mov	sp,bp
 11669                                  		;pop	bp
 11670 00001D22 C3                      		retn
 11671                                  
 11672                                  ; strcpy (Microsoft C 6.0 runtime library, MSDOS 6.0, 1991)	
 11673                                  ; ============================================================================
 11674                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 23/11/2018)
 11675                                  
 11676                                  ;strcpy
 11677                                  ;------
 11678                                  ;char * strcpy ( char * destination, const char * source );
 11679                                  ;Copy string
 11680                                  ;Copies the C string pointed by source into the array pointed by destination, 
 11681                                  ; including the terminating null character (and stopping at that point).
 11682                                  ;
 11683                                  ;To avoid overflows, the size of the array pointed by destination shall be 
 11684                                  ;long enough to contain the same C string as source 
 11685                                  ;(including the terminating null character), and should not overlap
 11686                                  ;in memory with source.
 11687                                  
 11688                                  strcpy:
 11689                                  	;%define _destination_ bp+4 ; word
 11690                                  	;%define _source_      bp+6 ; word
 11691                                  
 11692                                  		;push	bp
 11693                                  		;mov	bp,sp
 11694                                  		;mov	dx,di
 11695                                  		;mov	bx,si
 11696                                  		;mov	si,[_source_]
 11697                                  		;mov	di,si
 11698                                  		;mov	ax,ds
 11699                                  		;mov	es,ax
 11700                                  		;xor	ax,ax
 11701                                  		;xor	al,al
 11702                                  		;mov	cx,65535 ; 0FFFFh
 11703                                  		;repne scasb
 11704                                  		;not	cx
 11705                                  		;mov	di,[_destination_]
 11706                                  		;mov	ax,di
 11707                                  		;test	al,1
 11708                                  		;jz	short strcpy_0
 11709                                  		;movsb
 11710                                  		;dec	cx
 11711                                  ;strcpy_0:
 11712                                  		;shr	cx,1
 11713                                  		;rep movsw
 11714                                  		;adc	cx,cx
 11715                                  		;rep movsb
 11716                                  		;mov	si,bx
 11717                                  		;mov	di,dx
 11718                                  		;pop	bp
 11719                                  		;retn
 11720                                  strcpy_1:
 11721                                  		; 23/11/2018
 11722 00001D23 AC                      		lodsb
 11723 00001D24 AA                      		stosb
 11724 00001D25 20C0                    		and	al,al
 11725 00001D27 75FA                    		jnz	short strcpy_1
 11726                                  strcpy_2:
 11727 00001D29 C3                      		retn
 11728                                  
 11729                                  ; ----------------------------------------------------------------------------
 11730                                  ; convert.c (FDISK, MSDOS 6.0, 1991)	
 11731                                  ; ----------------------------------------------------------------------------
 11732                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 24/11/2018)
 11733                                  	
 11734                                  ;/*  */
 11735                                  ;/*******************************************************************************/
 11736                                  ;/*Routine name:  CHECK_FORMAT                                                  */
 11737                                  ;/*******************************************************************************/
 11738                                  ;/*                                                                             */
 11739                                  ;/*Description:   This routine will invoke INT21 44h (Block Generic IOCTL       */
 11740                                  ;/*               Subfunction) call to see if the drive has been previously     */
 11741                                  ;/*               formatted by using a undocumented call.                       */
 11742                                  ;/*                                                                             */
 11743                                  ;/*Called Procedures:                                                           */
 11744                                  ;/*                                                                             */
 11745                                  ;/*Change History: Created        2/07/88         DRM                           */
 11746                                  ;/*                                                                             */
 11747                                  ;/*Input: input_drive                                                           */
 11748                                  ;/*                                                                             */
 11749                                  ;/*Output: pointer to dx register                                               */
 11750                                  ;/*                                                                             */
 11751                                  ;/*******************************************************************************/
 11752                                  
 11753                                  ;FLAG check_format(input_drive)                                          /*AN002*/
 11754                                  ;
 11755                                  ;         char input_drive;                                              /*AN002*/
 11756                                  ;
 11757                                  ;BEGIN                                                                   /*AN002*/
 11758                                  ;
 11759                                  ;         char formatted;                                                /*AN002*/
 11760                                  ;
 11761                                  ;/*C32    if (input_drive <= 'Z') */                                     /*C30*/
 11762                                  ;         if ((input_drive >= 'C') && (input_drive <= 'Z'))              /*C32*/
 11763                                  ;         {                                                              /*C30*/
 11764                                  ;         /* Set up registers for Generic IOCTL INT21 (44h) check media */
 11765                                  ;         regs.x.ax = u(GENERIC_IOCTL);                                  /*AN002*/
 11766                                  ;         regs.h.bh = uc(ZERO);                                          /*AN002*/
 11767                                  ;         regs.h.bl = (((unsigned char)input_drive - 'A') + 1);          /*AN002*/
 11768                                  ;         regs.x.cx = u(SPECIAL_FUNCTION);                               /*AN002*/
 11769                                  ;         regs.x.dx = (unsigned)&disk_access;                            /*AN002*/
 11770                                  ;         segread(&segregs);                                             /*AN002*/
 11771                                  ;         intdosx(&regs,&regs,&segregs);                                 /*AN002*/
 11772                                  ;
 11773                                  ;         /* see if buffer returned good or not */
 11774                                  ;         if (disk_access.dac_access_flag == ZERO)                       /*AN002*/
 11775                                  ;            formatted = FALSE;                                          /*AN002*/
 11776                                  ;         else                                                           /*AN002*/
 11777                                  ;            formatted = TRUE;                                           /*AN002*/
 11778                                  ;         }                                                              /*C30*/
 11779                                  ;         else                                                           /*C30*/
 11780                                  ;            formatted = FALSE;                                          /*C30*/
 11781                                  ;
 11782                                  ;          return(formatted);                                            /*AN002*/
 11783                                  ;
 11784                                  ;END                                                                     /*AN002*/
 11785                                  
 11786                                  
 11787                                  ;INT 21H, Function 44H, Sub function 0DH 
 11788                                  ;I/O Ctrl --> generic I/O control for block devices
 11789                                  
 11790                                  ;Call with: 
 11791                                  ;	AH = 44H
 11792                                  ;	AL = 0DH
 11793                                  ;	BL = drive code (0 =default, 1=A,2=B, etc.)
 11794                                  ;	CH = category (major) code:
 11795                                  ;		08H = disk drive
 11796                                  ;		48H = FAT32 disk drive
 11797                                  ;	CL = function (minor) code:
 11798                                  ;		40H = Set Drive Parameters
 11799                                  ;		41H = Write Track
 11800                                  ;		42H = Format and Verify Track
 11801                                  ;		46H = Set Volume Serial Number	
 11802                                  ;		47H = Set Access Flag 
 11803                                  ;		60H = Get Device Parameters
 11804                                  ;		61H = Read Track
 11805                                  ;		62H = Verify track
 11806                                  ;		66H = Get Volume Serial Number
 11807                                  ;		67H = Get Access Flag
 11808                                  ;
 11809                                  ;	DS: DX = segment: offset of parameter block 
 11810                                  ;
 11811                                  ;Returns: 
 11812                                  ;	If function successful
 11813                                  ;	   Carry flag = clear
 11814                                  ;	   And if called with CL = 60H or 61H
 11815                                  ;	   DS: DX = segment: offset of parameter block
 11816                                  ;
 11817                                  ;	If function unsuccessful 
 11818                                  ;	   Carry flag = set
 11819                                  ;	   AX = error code
 11820                                  ;
 11821                                  ;Comments:
 11822                                  ;	This sub function provides a general-purpose mechanism for communication 
 11823                                  ;	between application programs and block-device drivers. Allows a program 
 11824                                  ;	to inspect or change device parameters for a logical drive and to read, 
 11825                                  ;	write, format, and verify disk tracks in a hardware-independent manner.
 11826                                  ;
 11827                                  ;Format of parameter block for functions 47h, 67h:
 11828                                  ;
 11829                                  ;Offset  Size    Description
 11830                                  ; 00h    BYTE    special-function field (must be zero)
 11831                                  ; 01h    BYTE    disk-access flag, nonzero if access allowed by driver
 11832                                  ;
 11833                                  ;Format of parameter block for functions 46h, 66h:
 11834                                  ;
 11835                                  ;Offset  Size    Description
 11836                                  ; 00h    WORD    (call) info level (should be 0000h)
 11837                                  ; 02h    DWORD   disk serial number (binary)
 11838                                  ; 06h  11 BYTEs   volume label or "NO NAME    "
 11839                                  ; 11h   8 BYTEs   filesystem type "FAT12   " or "FAT16   "
 11840                                  ;
 11841                                  ;(generally CL=66h only, but MS-DOS 5.0 will write the
 11842                                  ;given filesystem type to the disk)
 11843                                  
 11844                                  check_format:
 11845                                  ;	%define formatted   bp-2
 11846                                  ;	%define input_drive bp+4
 11847                                  ;
 11848                                  ;		push	bp
 11849                                  ;		mov	bp,sp
 11850                                  ;		sub	sp,2
 11851                                  ;		cmp	byte [input_drive],'C'
 11852                                  ;		jl	short chkf_1
 11853                                  ;		cmp	byte [input_drive],'Z'
 11854                                  ;		jg	byte short chkf_1
 11855                                  ;		mov	byte [dac_access_flag],0
 11856                                  ;		mov	word [regs_x_ax],440Dh
 11857                                  ;		mov	byte [regs_x_bx+1],0 ; bh
 11858                                  ;		mov	al,[input_drive]
 11859                                  ;		sub	al,40h
 11860                                  ;		mov	[regs_x_bx],al ; bl
 11861                                  ;		mov	word [regs_x_cx],867h
 11862                                  ;		mov	word [regs_x_dx],disk_access
 11863                                  ;		mov	ax,segregs ;segregs_es
 11864                                  ;		push	ax
 11865                                  ;		call	segread
 11866                                  ;		pop	bx
 11867                                  ;		mov	ax,segregs ;segregs_es
 11868                                  ;		push	ax
 11869                                  ;		mov	ax,regs	;regs_x_ax
 11870                                  ;		push	ax
 11871                                  ;		push	ax
 11872                                  ;		call	intdosx
 11873                                  ;		add	sp,6
 11874                                  ;		cmp	byte [dac_access_flag],0
 11875                                  ;		jz	short chkf_1
 11876                                  ;		mov	byte [formatted],1
 11877                                  ;		jmp	short chkf_2
 11878                                  ;chkf_1:
 11879                                  ;		mov	byte [formatted],0
 11880                                  ;chkf_2:
 11881                                  ;		mov	al,[formatted]
 11882                                  ;		mov	sp,bp
 11883                                  ;		pop	bp
 11884                                  ;		retn
 11885                                  
 11886                                  		; 24/11/2018
 11887                                  		;xor	bh,bh
 11888                                  		;mov	bl,al ; [input_drive]
 11889                                  		;xor	al,al
 11890                                  		; 17/12/2018
 11891 00001D2A 30E4                    		xor	ah,ah
 11892 00001D2C 89C3                    		mov	bx,ax ; al = [input_drive]
 11893 00001D2E 30C0                    		xor	al,al
 11894 00001D30 A2[D3CC]                		mov	[dac_access_flag],al ; 0
 11895 00001D33 80FB43                  		cmp	bl,'C'
 11896 00001D36 721A                    		jb	short chkf_2
 11897 00001D38 80FB5A                  		cmp	bl,'Z'
 11898 00001D3B 7713                    		ja	short chkf_1
 11899 00001D3D 80EB40                  		sub	bl,40h
 11900 00001D40 B96708                  		mov	cx,0867h
 11901 00001D43 52                      		push	dx ; * DX is in use by the caller
 11902 00001D44 BA[D2CC]                		mov	dx,disk_access
 11903 00001D47 B80D44                  		mov	ax,440Dh
 11904 00001D4A CD21                    		int	21h
 11905 00001D4C 5A                      		pop	dx ; * 
 11906 00001D4D A0[D3CC]                		mov	al,[dac_access_flag]
 11907                                  chkf_1:
 11908 00001D50 3C01                    		cmp	al,1
 11909                                  			; cf = 1 -> not formatted (AL=0)
 11910                                  			; cf = 0 -> formatted (AL>0)
 11911                                  chkf_2:
 11912 00001D52 C3                      		retn
 11913                                  
 11914                                  ;/*  */
 11915                                  ;/*******************************************************************************/
 11916                                  ;/*Routine name:  GET_VOLUME_STRING                                             */
 11917                                  ;/*******************************************************************************/
 11918                                  ;/*                                                                             */
 11919                                  ;/*Description:   This routine will invoke INT21 4Eh (Find First Matching File) */
 11920                                  ;/*               and return the disk volume label.                             */
 11921                                  ;/*                                                                             */
 11922                                  ;/*Called Procedures:                                                           */
 11923                                  ;/*                                                                             */
 11924                                  ;/*Change History: Created        6/01/87         DRM                           */
 11925                                  ;/*                                                                             */
 11926                                  ;/*Input: input_drive                                                           */
 11927                                  ;/*                                                                             */
 11928                                  ;/*Output: volume_out                                                           */
 11929                                  ;/*                                                                             */
 11930                                  ;/*******************************************************************************/
 11931                                  
 11932                                  ;void get_volume_string(input_drive,vol_label_addr)                     /*AN000*/
 11933                                  ;        char input_drive;                                              /*AN000*/
 11934                                  ;        char *vol_label_addr;                                          /*AN000*/
 11935                                  ;BEGIN                                                                  /*AN000*/
 11936                                  ;
 11937                                  ;         char  first_string[13];                                       /*AC000*/
 11938                                  ;         char  find_first_buffer[50];                                  /*AN000*/
 11939                                  ;         unsigned i,j;                                                 /*AC000*/
 11940                                  ;
 11941                                  ;         /* clear out any garbage in volume label field */
 11942                                  ;         for (i = u(0); i < u(12); i++)                                /*AN015*/
 11943                                  ;             BEGIN                                                     /*AN015*/
 11944                                  ;                 vol_label_addr[i] = u(0);                             /*AN015*/
 11945                                  ;             END                                                       /*AN015*/
 11946                                  ;
 11947                                  ;         /* Point the DTA to our buffer so we can get the FindFirst output */
 11948                                  ;         regs.h.ah = uc(0x1A);                                         /*AN000*/
 11949                                  ;         regs.x.dx = (unsigned)&find_first_buffer[0];                  /*AN000*/
 11950                                  ;         segread(&segregs);
 11951                                  ;         intdosx(&regs,&regs,&segregs);                                /*AN000*/
 11952                                  ;
 11953                                  ;         /* Find the first volume id */
 11954                                  ;         first_string[0] = input_drive;       /* Find the vol label - AN000*/
 11955                                  ;         first_string[1] = (char) '\0';
 11956                                  ;         strcat(first_string,FILE_NAME);                               /*AN000*/
 11957                                  ;         regs.h.ah = uc(FIND_FIRST_MATCH);                             /*AN000*/
 11958                                  ;         regs.x.cx = u(VOL_LABEL);                                     /*AN000*/
 11959                                  ;         regs.x.dx = (unsigned)&first_string[0];                       /*AN000*/
 11960                                  ;         intdos(&regs,&regs);                                		/*AN000*/
 11961                                  ;
 11962                                  ;/* AC000 The following is modified to take care of "." in the middle of the */
 11963                                  ;/*name */
 11964                                  ;
 11965                                  ;         if ((regs.x.cflag & CARRY_FLAG) != CARRY_FLAG)                /*AN000*/
 11966                                  ;           BEGIN                                                       /*AN000*/
 11967                                  ;           for (i=j=u(0); i < strlen (&find_first_buffer[30]) ; i++)   /*AN000*/
 11968                                  ;               BEGIN                                                   /*AN000*/
 11969                                  ;               if (find_first_buffer[30+i] != PERIOD)                  /*AN003*/
 11970                                  ;                       vol_label_addr[i-j] = find_first_buffer[30+i];  /*AN000*/
 11971                                  ;               else                                                    /*AN000*/
 11972                                  ;                       j = u(1);                                       /*AN000*/
 11973                                  ;               END                                                     /*AN000*/
 11974                                  ;           END                                                         /*AN000*/
 11975                                  ;         return;                                                       /*AN000*/
 11976                                  ;END                                                                    /*AN000*/
 11977                                  
 11978                                  ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
 11979                                  
 11980                                  ; Attributes: bp-based frame
 11981                                  
 11982                                  get_volume_string:
 11983                                  
 11984                                  	;;%define first_string	  bp-68  ; char first_string[13];
 11985                                  	;%define first_string	  bp-70  ; 24/11/2018 (db 'C:\????????.???',0)
 11986                                  	;%define _jj_		  bp-54	 ; unsigned j;	
 11987                                  	;%define _ii_		  bp-52	 ; unsigned i;
 11988                                  	;%define find_first_buffer bp-50	 ; char find_first_buffer[50];
 11989                                  	;%define _input_drive_	  bp+4 ; char input_drive;
 11990                                  	;%define vol_label_addr	  bp+6 ; char *vol_label_addr;
 11991                                  
 11992                                  		; 17/12/2018
 11993                                  	%define first_string	  bp-60  ; (db 'C:\????????.???',0)
 11994                                  	%define find_first_buffer bp-44	 ; char find_first_buffer[44];
 11995                                  	%define _input_drive_	  bp+4 ; char input_drive;
 11996                                  	%define vol_label_addr	  bp+6 ; char *vol_label_addr;
 11997                                  
 11998 00001D53 55                      		push	bp
 11999 00001D54 89E5                    		mov	bp,sp
 12000                                  		;sub	sp,68
 12001                                  		;sub	sp,70	; 24/11/2018
 12002                                  
 12003 00001D56 83EC3C                  		sub	sp,60	; 17/12/2018
 12004                                  
 12005                                  		; 12/12/2018
 12006                                  		;push	di
 12007 00001D59 56                      		push	si ; * SI is in use by the caller
 12008                                  
 12009                                  		;/* clear out any garbage in volume label field */
 12010                                  		;mov	word [_ii_],0
 12011                                  gvs_1:
 12012                                  		;mov	bx,[_ii_]
 12013                                  		;mov	si,[vol_label_addr]
 12014                                  		;mov	byte [bx+si],0
 12015                                  		;inc	byte [_ii_]
 12016                                  		;cmp	byte [_ii_],12
 12017                                  		;jb	short gvs_1
 12018                                  
 12019 00001D5A 8B7E06                  		mov	di,[vol_label_addr]
 12020                                  		; 05/01/2019
 12021 00001D5D B90600                  		mov	cx,6
 12022 00001D60 31C0                    		xor	ax,ax
 12023 00001D62 F3AB                    		rep	stosw
 12024                                  
 12025                                  		;/* Point the DTA to our buffer 
 12026                                  		;   so we can get the FindFirst output */
 12027                                  
 12028                                  		;mov	byte [regs_x_ax+1],1Ah
 12029                                  		;lea	ax,[find_first_buffer]
 12030                                  		;mov	[regs_x_dx],ax
 12031                                  		;mov	ax,segregs ;segregs_es
 12032                                  		;push	ax
 12033                                  		;call	segread
 12034                                  		;pop	bx
 12035                                  		;mov	ax,segregs ;segregs_es
 12036                                  		;push	ax
 12037                                  		;mov	ax,regs	;regs_x_ax
 12038                                  		;push	ax
 12039                                  		;push	ax
 12040                                  		;call	intdosx
 12041                                  		;add	sp,6
 12042                                  
 12043 00001D64 B41A                    		mov	ah,1Ah  ; Set DTA address
 12044 00001D66 8D56D4                  		lea	dx,[find_first_buffer]
 12045 00001D69 CD21                    		int	21h		
 12046                                  
 12047                                  		;/* Find the first volume id */
 12048                                  
 12049 00001D6B 8A4604                  		mov	al,[_input_drive_]
 12050                                  		;mov	[first_string],al
 12051                                  		;mov	byte [first_string+1],0
 12052                                  		
 12053                                  		;mov	ax,FILE_NAME ; ":\????????.???"
 12054                                  		;push	ax
 12055                                  		;lea	ax,[first_string]
 12056                                  		;push	ax
 12057                                  		;call	strcat
 12058                                  		;pop	bx
 12059                                  		;pop	bx
 12060                                  
 12061 00001D6E 8D7EC4                  		lea	di,[first_string]
 12062 00001D71 AA                      		stosb    ; al = 'C' (or 'D' ...)
 12063                                  
 12064 00001D72 BE[7B70]                		mov	si,FILE_NAME ; ":\????????.???"
 12065                                  ;starcat_loop:
 12066                                  		;lodsb
 12067                                  		;stosb
 12068                                  		;or	al,al
 12069                                  		;jnz	short starcat_loop
 12070                                  
 12071                                  		;mov	cx,15 ; db ':\????????.???',0
 12072 00001D75 B10F                    		mov	cl,15
 12073 00001D77 F3A4                    		rep	movsb			
 12074                                  			; [first_string] = 'C:\????????.???',0
 12075                                  
 12076                                  		; Find First Matching File
 12077                                  		; (Find Volume Name)
 12078                                  
 12079                                  		;mov	byte [regs_x_ax+1],4Eh
 12080                                  		;mov	word [regs_x_cx],8
 12081                                  		;lea	ax,[first_string]
 12082                                  		;mov	[regs_x_dx],ax
 12083                                  		;mov	ax,regs_x_ax
 12084                                  		;push	ax
 12085                                  		;push	ax
 12086                                  		;call	intdos
 12087                                  		;pop	bx
 12088                                  		;pop	bx
 12089                                  		;mov	al,[regs_x_cflag]
 12090                                  		;and	al,1
 12091                                  		;cmp	al,1
 12092                                  		;je	short gvs_5
 12093                                  
 12094 00001D79 B44E                    		mov	ah,4Eh  ; Find First File
 12095                                  		;mov	cx,8 ; attribute (volume name)
 12096 00001D7B B108                    		mov	cl,8
 12097 00001D7D 8D56C4                  		lea	dx,[first_string]  ; ASCIIZ file name address
 12098 00001D80 CD21                    		int	21h
 12099 00001D82 7213                    		jc	short gvs_5
 12100                                  		
 12101                                  		; take care of "." in the middle of the name */
 12102                                  
 12103                                  		;sub	ax,ax
 12104                                  		;mov	[_jj_],ax
 12105                                  		;;mov	[_ii_],ax
 12106                                  		;mov	[_ii_],al
 12107                                  
 12108                                  		; 24/11/2018
 12109                                  		;lea	ax,[find_first_buffer+30]
 12110                                  		;push	ax
 12111                                  		;call	strlen
 12112                                  		;pop	bx
 12113                                  
 12114 00001D84 8D76F2                  		lea	si,[find_first_buffer+30]
 12115 00001D87 E880FF                  		call	strlen	; /**/
 12116                                  			; CX = string length (except terminating null)
 12117                                  		; 17/12/2018 (lodsb,stosb,loop)
 12118                                  		;xor	si,si ; mov word [_ii_],0
 12119                                  		;xor	dx,dx ; mov word [_jj_],0
 12120 00001D8A 8B7E06                  		mov	di,[vol_label_addr]
 12121                                   		;jmp	short gvs_4
 12122 00001D8D EB00                    		jmp	short gvs_3 
 12123                                  gvs_2:
 12124                                  		;mov	byte [_jj_],1
 12125                                  		;mov	dl,1	 ; 17/12/2018
 12126                                  ;gvs_3:
 12127                                  		;inc	byte [_ii_]
 12128                                  		;inc	si ; 17/12/2018
 12129                                  ;gvs_4:
 12130                                  		;lea	ax,[find_first_buffer+30]
 12131                                  		;push	ax
 12132                                  		;call	strlen
 12133                                  		;pop	bx
 12134                                  		
 12135                                  		;cmp	ax,[_ii_]
 12136                                  		;cmp	al,[_ii_]
 12137                                  		;cmp	cx,[_ii_] ; /**/
 12138                                  
 12139                                  		;cmp	cx,si
 12140                                  		;jbe	short gvs_5  ; jna
 12141                                  
 12142                                  		; 17/12/2018
 12143                                  		;cmp	si,cx
 12144                                  		;jnb	short gvs_5 ; 12/12/2018
 12145                                  
 12146                                  		;mov	si,[_ii_]
 12147                                  		;cmp	byte [si+find_first_buffer+30],'.'
 12148                                  		;je	short gvs_2
 12149                                  		;mov	al,[si+find_first_buffer+30]
 12150                                  gvs_3:		
 12151                                  		; 17/12/2018
 12152 00001D8F AC                      		lodsb
 12153 00001D90 3C2E                    		cmp	al,'.'
 12154 00001D92 7401                    		je	short gvs_4
 12155                                  		
 12156                                  		;mov	bx,si
 12157                                  		;sub	bx,[_jj_]
 12158                                  		;sub	bx,dx
 12159                                  		;mov	si,[vol_label_addr]
 12160                                  		;mov	[bx+si],al
 12161                                  		;add	bx,di
 12162                                  		;mov	[bx],al
 12163                                  
 12164                                  		; 05/01/2019
 12165 00001D94 AA                      		stosb
 12166                                  gvs_4:	
 12167 00001D95 E2F8                    		loop	gvs_3 ; 17/12/2018
 12168                                  gvs_5:
 12169 00001D97 5E                      		pop	si ; * ; 12/12/2018
 12170                                  		;pop	di
 12171 00001D98 89EC                    		mov	sp,bp
 12172 00001D9A 5D                      		pop	bp
 12173 00001D9B C20400                  		retn	4 ; 05/01/2019
 12174                                  
 12175                                  ;/*  */
 12176                                  ;/*******************************************************************************/
 12177                                  ;/*Routine name:  GET_FS_AND_VOL                                                */
 12178                                  ;/*******************************************************************************/
 12179                                  ;/*                                                                             */
 12180                                  ;/*Description:   This routine will invoke INT21 44h (Block Generic IOCTL       */
 12181                                  ;/*               Subfunction) call to get volume label and file system type.   */
 12182                                  ;/*                                                                             */
 12183                                  ;/*Called Procedures:                                                           */
 12184                                  ;/*                                                                             */
 12185                                  ;/*Change History: Created        6/01/87         DRM                           */
 12186                                  ;/*                                                                             */
 12187                                  ;/*Input: input_drive                                                           */
 12188                                  ;/*                                                                             */
 12189                                  ;/*Output: pointer to dx register                                               */
 12190                                  ;/*                                                                             */
 12191                                  ;/*******************************************************************************/
 12192                                  ;
 12193                                  ;FLAG get_fs_and_vol(input_drive)                                        /*AN000*/
 12194                                  ;
 12195                                  ;         char input_drive;                                              /*AN000*/
 12196                                  ;
 12197                                  ;BEGIN                                                                   /*AN000*/
 12198                                  ;
 12199                                  ;         char output;
 12200                                  ;
 12201                                  ;         /* Set up registers for Generic IOCTL INT21 (44h) get media ID */
 12202                                  ;         regs.x.ax = u(GENERIC_IOCTL);                                  /*AN000*/
 12203                                  ;         regs.h.bh = uc(ZERO);                                          /*AN000*/
 12204                                  ;         regs.h.bl = (((unsigned char)input_drive - 'A') + 1);          /*AN000*/
 12205                                  ;         regs.x.cx = u(GET_MEDIA_ID);                                   /*AN000*/
 12206                                  ;         regs.x.dx = (unsigned)&dx_buff;                                /*AN000*/
 12207                                  ;         segread(&segregs);
 12208                                  ;         intdosx(&regs,&regs,&segregs);                                 /*AN000*/
 12209                                  ;
 12210                                  ;         /* see if carry flag was zero or one */
 12211                                  ;         if ((regs.x.cflag & CARRY_FLAG) == CARRY_FLAG)                 /*AN000*/
 12212                                  ;            output = FALSE;                                             /*AN000*/
 12213                                  ;         else                                                           /*AN000*/
 12214                                  ;            output = TRUE;                                              /*AN000*/
 12215                                  ;
 12216                                  ;         return(output);                                                /*AN000*/
 12217                                  ;                                                                        /*AN000*/
 12218                                  ;END
 12219                                  
 12220                                  get_fs_and_vol:
 12221                                  	;%define _output_     bp-2  ; char
 12222                                  	;%define _inputdrive_ bp+4  ; char
 12223                                  
 12224                                  		;push	bp
 12225                                  		;mov	bp,sp
 12226                                  		;;sub	sp,2
 12227                                  		;xor	bx,bx	; mov word [_output_],0
 12228                                  		;push	bx
 12229                                  		
 12230                                  		;push	dx ; 12/12/2018	
 12231                                  
 12232 00001D9E 88C3                    		mov	bl,al ; 05/01/2019
 12233                                  
 12234                                  		;mov	[regs_x_ax],440Dh
 12235 00001DA0 B80D44                  		mov	ax,440Dh ; IOCTL - Generic Block Device Request
 12236                                  
 12237                                  		;mov	byte [regs_x_bx+1],0 ; bh
 12238                                  
 12239                                  		;mov	al,[_inputdrive_] ; [bp+4]
 12240                                  		;sub	al,40h
 12241                                  		;mov	[regs_x_bx],al ; bl
 12242                                  
 12243                                  		;xor	bh,bh
 12244                                  		;mov	bl,[_inputdrive_] ; [bp+4]
 12245                                  
 12246 00001DA3 80EB40                  		sub	bl,40h ; drive number (0 = default, 1 = 'A', 3 = 'C' ..)
 12247                                  		
 12248                                  		;mov	word [regs_x_cx],866h
 12249                                  		;mov	word [regs_x_dx],dx_buff
 12250                                  		
 12251                                  		;mov	ax,segregs ; segregs_es
 12252                                  		;push	ax
 12253                                  		;call	segread
 12254                                  		;pop	bx
 12255                                  		;mov	ax,segregs ; segregs_es
 12256                                  		;push	ax
 12257                                  		;mov	ax,regs ; regs_x_ax
 12258                                  		;push	ax
 12259                                  		;push	ax
 12260                                  		;call	intdosx
 12261                                  		;add	sp,6
 12262                                  
 12263 00001DA6 B96608                  		mov	cx,0866h   ; Get fs name and volume serial number
 12264 00001DA9 BA[6BA0]                		mov	dx,dx_buff ; buffer
 12265 00001DAC CD21                    		int	21h
 12266                                  
 12267                                  		;mov	al,[regs_x_cflag]
 12268                                  		;and	al,1
 12269                                  		;cmp	al,1
 12270                                  		;jne	short gfsv_1
 12271                                  		;mov	word [_output_],0 ; [bp-2]
 12272                                  
 12273 00001DAE 7304                    		jnc	short gfsv_1
 12274 00001DB0 29C0                    		sub	ax,ax		
 12275 00001DB2 EB03                    		jmp	short gvsv_2
 12276                                  gfsv_1:
 12277                                  		;mov	byte [_output_],1
 12278 00001DB4 B80100                  		mov	ax,1
 12279                                  gvsv_2:
 12280                                  		;mov	al,[_output_]
 12281                                  
 12282                                  		;pop 	dx ; 12/12/2018
 12283                                  
 12284 00001DB7 3C01                    		cmp	al,1 	
 12285                                  		;mov	sp,bp
 12286                                  		;pop	bp
 12287                                  			; CF = 1 -> Error
 12288                                  			; CF = 0 -> OK (fs name is in dx_buffer)
 12289 00001DB9 C3                      		retn
 12290                                  
 12291                                  ; strcat (Microsoft C 6.0 runtime library, MSDOS 6.0, 1991)	
 12292                                  ; ============================================================================
 12293                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 24/11/2018)
 12294                                  
 12295                                  ;strcat
 12296                                  ;------
 12297                                  ;char * strcat ( char * destination, const char * source );
 12298                                  ;Concatenate strings
 12299                                  ;Appends a copy of the source string to the destination string. 
 12300                                  ;The terminating null character in destination is overwritten by 
 12301                                  ;the first character of source, and a null-character is included at 
 12302                                  ;the end of the new string formed by the concatenation of both in destination.
 12303                                  ;
 12304                                  ;Destination and source shall not overlap.
 12305                                  
 12306                                  ;strcat:
 12307                                  ;	%define _destination_	bp+4
 12308                                  ;	%define _source_	bp+6
 12309                                  ;
 12310                                  ;		push	bp
 12311                                  ;		mov	bp,sp
 12312                                  ;		mov	dx,di
 12313                                  ;		mov	bx,si
 12314                                  ;		mov	ax,ds
 12315                                  ;		mov	es,ax
 12316                                  ;		mov	di,[_destination_]
 12317                                  ;		xor	ax,ax
 12318                                  ;		mov	cx,65535 ; 0FFFFh
 12319                                  ;		repne scasb
 12320                                  ;		lea	si,[di-1]
 12321                                  ;		mov	di,[_source_]
 12322                                  ;		mov	cx,65535 ; 0FFFFh
 12323                                  ;		repne scasb
 12324                                  ;		not	cx
 12325                                  ;		sub	di,cx
 12326                                  ;		xchg	di,si
 12327                                  ;		mov	ax,[_destination_]
 12328                                  ;		test	si,1
 12329                                  ;		jz	short strcat_0
 12330                                  ;		movsb
 12331                                  ;		dec	cx
 12332                                  ;strcat_0:
 12333                                  ;		shr	cx,1
 12334                                  ;		rep movsw
 12335                                  ;		adc	cx,cx
 12336                                  ;		rep movsb
 12337                                  ;		mov	si,bx
 12338                                  ;		mov	di,dx
 12339                                  ;		pop	bp
 12340                                  ;		retn
 12341                                  
 12342                                  ; ----------------------------------------------------------------------------
 12343                                  ; partinfo.c (FDISK, MSDOS 6.0, 1991)	
 12344                                  ; ----------------------------------------------------------------------------
 12345                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 24/11/2018)
 12346                                  
 12347                                  ;/*  */
 12348                                  ;char find_partition_type(type)
 12349                                  ;
 12350                                  ;unsigned char type;
 12351                                  ;
 12352                                  ;BEGIN
 12353                                  ; char  i;
 12354                                  ;
 12355                                  ;/*  Look at all four partition entries for system id byte that matches */
 12356                                  ; for (i = c(0); i < c(4);i++)                                   /*AC000*/
 12357                                  ;    BEGIN
 12358                                  ;
 12359                                  ;     /* if we find a match, do a TRUE return */
 12360                                  ;     if (part_table[cur_disk][i].sys_id == type)
 12361                                  ;        BEGIN
 12362                                  ;         return(TRUE);
 12363                                  ;         break;
 12364                                  ;        END
 12365                                  ;    END
 12366                                  ; /* Did not find one, return FALSE */
 12367                                  ; return(FALSE);
 12368                                  ;END
 12369                                  
 12370                                  find_partition_type:
 12371                                  		; 14/12/2018
 12372                                  		; INPUT:
 12373                                  		;   AL = Partition type (File system ID)
 12374                                  		;   [current_disk] = Current disk/drive number
 12375                                  
 12376                                  		; Modified registers: ax,bx,cx ; 24/01/2019
 12377                                  
 12378                                  		; 24/11/2018
 12379 00001DBA 31C9                    		xor	cx,cx
 12380 00001DBC EB07                    		jmp	short fpt_2
 12381                                  fpt_1:
 12382 00001DBE FEC1                    		inc	cl
 12383 00001DC0 80F904                  		cmp	cl,4
 12384 00001DC3 7318                    		jnb	short fpt_3
 12385                                  fpt_2:
 12386                                  		;xor	ah,ah
 12387 00001DC5 50                      		push	ax  ; al = Requested partition ID
 12388                                  
 12389 00001DC6 A0[D4CB]                		mov	al,[cur_disk] ; disk number (0 to 7)
 12390 00001DC9 D0E0                    		shl	al,1
 12391 00001DCB D0E0                    		shl	al,1 ; 4 partition (table entries) per disk
 12392 00001DCD 00C8                    		add	al,cl ; Partition number (0 to 3)
 12393 00001DCF B32E                    		mov	bl,46
 12394 00001DD1 F6E3                    		mul	bl
 12395 00001DD3 89C3                    		mov	bx,ax
 12396                                  
 12397 00001DD5 58                      		pop	ax 
 12398                                  
 12399 00001DD6 3887[17C4]              		cmp	[part_table_sys_id+bx],al
 12400 00001DDA 75E2                    		jne	short fpt_1
 12401                                  
 12402                                  		;mov	al,1
 12403                                  			; cl < 4
 12404 00001DDC C3                      		retn
 12405                                  fpt_3:
 12406                                  		;sub	al,al ; 0
 12407 00001DDD F9                      		stc
 12408                                  			; cl = 4
 12409 00001DDE C3                      		retn
 12410                                  
 12411                                  ; ----------------------------------------------------------------------------
 12412                                  
 12413                                  ;/*  */
 12414                                  ;char find_partition_location(type)
 12415                                  ;
 12416                                  ;unsigned char type;
 12417                                  ;
 12418                                  ;BEGIN
 12419                                  ; char  i;
 12420                                  ;
 12421                                  ;/*  Look at all four partition entries for system id byte that matches */
 12422                                  ; for (i = c(0); i < c(4);i++)                                   /*AC000*/
 12423                                  ;    BEGIN
 12424                                  ;
 12425                                  ;    /* if we find a match, do a TRUE return */
 12426                                  ;     if (part_table[cur_disk][i].sys_id == type)
 12427                                  ;        BEGIN
 12428                                  ;         return(i);
 12429                                  ;         break;
 12430                                  ;        END
 12431                                  ;    END
 12432                                  ; /* Did not find one, return */
 12433                                  ; return(c(NOT_FOUND));                                          /*AC000*/
 12434                                  ;END
 12435                                  
 12436                                  ;find_partition_location:
 12437                                  ;		; 24/11/2018
 12438                                  ;		xor	cx,cx
 12439                                  ;		jmp	short fpl_2
 12440                                  ;fpl_1:
 12441                                  ;		inc	cl
 12442                                  ;		cmp	cl,4
 12443                                  ;		jnb	short fpl_3
 12444                                  ;fpl_2:
 12445                                  ;		;xor	ah,ah
 12446                                  ;		push	ax  ; al = Requested partition ID
 12447                                  ;
 12448                                  ;		mov	al,[cur_disk] ; disk number (0 to 7)
 12449                                  ;		shl	al,1
 12450                                  ;		shl	al,1 ; 4 partition (table entries) per disk
 12451                                  ;		add	al,cl ; Partition number (0 to 3)
 12452                                  ;		mov	bl,46
 12453                                  ;		mul	bl
 12454                                  ;		mov	bx,ax
 12455                                  ;
 12456                                  ;		pop	ax 
 12457                                  ;
 12458                                  ;		cmp	[part_table_sys_id+bx],al
 12459                                  ;		jne	short fpl_1
 12460                                  ;
 12461                                  ;		mov	al,cl
 12462                                  ;		retn
 12463                                  ;fpl_3:
 12464                                  ;		mov	al,0FFh
 12465                                  ;		;stc
 12466                                  ;		retn
 12467                                  
 12468                                  ; 14/12/2018 
 12469                                  ; [ No need to find_partition_location for FDISK2.COM ..
 12470                                  ; .. because 'find_partition_type' returns with partition number in CL. ]
 12471                                  
 12472                                  ;find_partition_location:
 12473                                  		;call	find_partition_type
 12474                                  		;jc	short fpl_1
 12475                                  		;
 12476                                  		;mov	al,cl ; Partition number (0 to 3)
 12477                                  		;retn
 12478                                  ;fpl_1:
 12479                                  		;mov	al,0FFh
 12480                                  		;retn
 12481                                  
 12482                                  ; ----------------------------------------------------------------------------
 12483                                  ; fdisk.c (FDISK, MSDOS 6.0, 1991)	
 12484                                  ; ----------------------------------------------------------------------------
 12485                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 25/11/2018)		
 12486                                  		
 12487                                  ; 25/11/2018
 12488                                  
 12489                                  ;/*  */
 12490                                  ;void load_logical_drive(point,drive)
 12491                                  ;
 12492                                  ;char   point;
 12493                                  ;unsigned char   drive;
 12494                                  ;
 12495                                  ;BEGIN
 12496                                  ;
 12497                                  ;char        volume_label[13];                                           	/* AC000 */
 12498                                  ;unsigned    ext_part_num;                                               	/* AN000 */
 12499                                  ;unsigned    i;
 12500                                  ;/*C00 unsigned j; */                                                       	/* AN000 */
 12501                                  ;unsigned    k;                                                          	/* AN000 */
 12502                                  ;unsigned    length;                                                     	/* AN000 */
 12503                                  ;unsigned    index;
 12504                                  ;/*C00 unsigned dx_pointer; */                                               	/* AN000 */
 12505                                  ;unsigned    partition_location;                                         	/* AN000 */
 12506                                  ;
 12507                                  ;	/* Check to see if anything is there */
 12508                                  ;	if ((boot_record[510] == uc(0x55)) && (boot_record[511] == uc(0xAA)))	/* AC000 */
 12509                                  ;	    BEGIN
 12510                                  ;	    /* The boot record is there - read in the logical drive if it is there */
 12511                                  ;	    for (i = u(0); i < u(4); i++)                               /* AC000 */
 12512                                  ;		BEGIN
 12513                                  ;
 12514                                  ;		index = i*16;
 12515                                  ;		/* See if it is a defined extended drive*/
 12516                                  ;		if ((boot_record[0x1C2 + index] != uc(0)) && (boot_record[0x1C2 + index] != uc(EXTENDED))) 
 12517                                  ;		    BEGIN
 12518                                  ;		    /* Get boot ind */
 12519                                  ;		    ext_table[drive][point].boot_ind = boot_record[0x1BE + index];
 12520                                  ;
 12521                                  ;		    /* Start head */
 12522                                  ;		    ext_table[drive][point].start_head = boot_record[0x1BF + index];
 12523                                  ;
 12524                                  ;		    /* Start sector - unscramble it from INT 13 format*/
 12525                                  ;		    ext_table[drive][point].start_sector= (boot_record[0x1C0 + index] & 0x3F);
 12526                                  ;
 12527                                  ;		    /* Start cyl - unscramble it from INT 13 format*/
 12528                                  ;		    ext_table[drive][point].start_cyl= ((((unsigned)boot_record[0x1C0+index]) & 0x00C0) << 2)
 12529                                  ;						+ ((unsigned)boot_record[0x1C1+index]);
 12530                                  ;
 12531                                  ;		    /* System id */
 12532                                  ;		    ext_table[drive][point].sys_id = boot_record[0x1C2+index];
 12533                                  ;
 12534                                  ;		    /* End head */
 12535                                  ;		    ext_table[drive][point].end_head = boot_record[0x1C3+index];
 12536                                  ;
 12537                                  ;		    /* End sector - unscramble it from INT 13 format*/
 12538                                  ;		    ext_table[drive][point].end_sector= (boot_record[0x1C4+index] & 0x3F);
 12539                                  ;
 12540                                  ;		    /* End cyl - unscramble it from INT 13 format*/
 12541                                  ;		    ext_table[drive][point].end_cyl= ((((unsigned)boot_record[0x1C4+index]) & 0x00C0) << 2)
 12542                                  ;						+ ((unsigned)boot_record[0x1C5+index]);
 12543                                  ;
 12544                                  ;		    /* Relative sectors */
 12545                                  ;		    ext_table[drive][point].rel_sec =
 12546                                  ;			((unsigned long)boot_record[0x1C9+index]) << 24;
 12547                                  ;
 12548                                  ;		    ext_table[drive][point].rel_sec =
 12549                                  ;			ext_table[drive][point].rel_sec+(((unsigned long)boot_record[0x1C8+index]) << 16);
 12550                                  ;
 12551                                  ;		    ext_table[drive][point].rel_sec =
 12552                                  ;			ext_table[drive][point].rel_sec + (((unsigned long)boot_record[0x1C7+index]) << 8);
 12553                                  ;
 12554                                  ;		    ext_table[drive][point].rel_sec =
 12555                                  ;			ext_table[drive][point].rel_sec + ((unsigned long)boot_record[0x1C6+index]);
 12556                                  ;
 12557                                  ;		    /* Number of sectors */
 12558                                  ;		    ext_table[drive][point].num_sec =
 12559                                  ;			((unsigned long)boot_record[0x1CD+index]) << 24;
 12560                                  ;
 12561                                  ;		    ext_table[drive][point].num_sec =
 12562                                  ;			ext_table[drive][point].num_sec+(((unsigned long)boot_record[0x1CC+index]) << 16);
 12563                                  ;
 12564                                  ;		    ext_table[drive][point].num_sec =
 12565                                  ;			ext_table[drive][point].num_sec + (((unsigned long)boot_record[0x1CB+index]) << 8);
 12566                                  ;
 12567                                  ;		    ext_table[drive][point].num_sec =
 12568                                  ;			ext_table[drive][point].num_sec + ((unsigned long)boot_record[0x1CA+index]);
 12569                                  ;
 12570                                  ;		    ext_table[drive][point].mbytes_used =
 12571                                  ;			cylinders_to_mbytes(((ext_table[drive][point].end_cyl - ext_table[drive][point].start_cyl)+1),
 12572                                  ;					      cur_disk);                /* AN004 */
 12573                                  ;
 12574                                  ;		    ext_part_num = find_partition_location(uc(EXTENDED));
 12575                                  ;
 12576                                  ;		    ext_table[drive][point].percent_used =
 12577                                  ;			cylinders_to_percent(((ext_table[drive][point].end_cyl-ext_table[drive][point].start_cyl)+1),
 12578                                  ;			((part_table[drive][ext_part_num].end_cyl-part_table[drive][ext_part_num].start_cyl)+1));
 12579                                  ;
 12580                                  ;		    ext_table[drive][point].drive_letter = next_letter++;                   /* AN000 */
 12581                                  ;
 12582                                  ;		    partition_location = ext_table[drive][point].start_cyl;
 12583                                  ;
 12584                                  ;		    if (read_boot_record(ext_table[drive][point].start_cyl,
 12585                                  ;					 drive,
 12586                                  ;					 ext_table[drive][point].start_head,
 12587                                  ;					 ext_table[drive][point].start_sector));
 12588                                  ;			 BEGIN                                                             /* AN000 */
 12589                                  ;			 /* See if the disk has already been formated */
 12590                                  ;			 if (check_format(ext_table[drive][point].drive_letter) == TRUE )       /* AN002 */
 12591                                  ;			     BEGIN                                                         /* AN000 */
 12592                                  ;			     /* get volume and system info */
 12593                                  ;
 12594                                  ;			     /* AC000 Just for cleaning up purposes */
 12595                                  ;
 12596                                  ;			     for (k = u(0); k < u(12); k++)                                     /* AC000 */
 12597                                  ;				 BEGIN                                                          /* AC000 */
 12598                                  ;				     ext_table[drive][point].vol_label[k]=u(0);                 /* AC000 */
 12599                                  ;				 END                                                            /* AC000 */
 12600                                  ;
 12601                                  ;			     for (k = u(0); k < u(9); k++)                                      /* AC000 */
 12602                                  ;				 BEGIN                                                          /* AC000 */
 12603                                  ;				     ext_table[drive][point].system[k]=u(0);                    /* AC000 */
 12604                                  ;				 END                                                            /* AC000 */
 12605                                  ;
 12606                                  ;			     get_volume_string(ext_table[drive][point].drive_letter,&volume_label[0]);
 12607                                  ;
 12608                                  ;			      for (k = u(0); k < strlen(volume_label); k++)                     /* AC000 AC015 */
 12609                                  ;				   BEGIN                                                        /* AC000 AC015 */
 12610                                  ;				     ext_table[drive][point].vol_label[k]=volume_label[k];      /* AC000 AC015 */
 12611                                  ;				   END                                                          /* AC000 AC015 */
 12612                                  ;
 12613                                  ;			     /* Now try to get it using GET MEDIA ID function */
 12614                                  ;			     if (get_fs_and_vol(ext_table[drive][point].drive_letter))     /* AN000 */
 12615                                  ;
 12616                                  ;				BEGIN                                                      /* AN000 */
 12617                                  ;				/* AC000 Just use more conceptually simple logic */
 12618                                  ;				for (k=u(0); k < u(8); k++)                                     /* AC000 */
 12619                                  ;
 12620                                  ;				    BEGIN                                                       /* AC000 */
 12621                                  ;				      if (dx_buff.file_system[k] != ' ')                        /* AC000 */
 12622                                  ;						length = k+1;                                   /* AC000 */
 12623                                  ;				    END                                                         /* AC000 */
 12624                                  ;
 12625                                  ;				strncpy(ext_table[drive][point].system,&dx_buff.file_system[0],u(length));
 12626                                  ;				END                                                        /* AN000 */
 12627                                  ;
 12628                                  ;			      else                                                         /* AN000 */
 12629                                  ;
 12630                                  ;				BEGIN                                                      /* AN000 */
 12631                                  ;				if (ext_table[drive][point].num_sec > (unsigned long)FAT16_SIZE) /* AN000 */
 12632                                  ;				    strcpy(ext_table[drive][point].system,FAT16);          /* AN000 */
 12633                                  ;				else
 12634                                  ;				    strcpy(ext_table[drive][point].system,FAT12);          /* AN000 */
 12635                                  ;				END                                                        /* AN000 */
 12636                                  ;			     END                                                           /* AN000 */
 12637                                  ;			 else                                                              /* AN000 */
 12638                                  ;			     BEGIN                                                         /* AN000 */
 12639                                  ;			     /* set up array to say no file system or volume label */
 12640                                  ;			     strcpy(ext_table[drive][point].vol_label,NOVOLUME);           /* AN000 */
 12641                                  ;			     strcpy(ext_table[drive][point].system,NOFORMAT);              /* AN000 */
 12642                                  ;			     END                                                           /* AN000 */
 12643                                  ;
 12644                                  ;			 regs.x.dx = u(0);
 12645                                  ;			 regs.x.ax = NETWORK_IOCTL;
 12646                                  ;			 regs.h.bl = ((ext_table[drive][point].drive_letter - 'A') + 1);
 12647                                  ;			 intdos(&regs,&regs);
 12648                                  ;			 if (regs.x.dx & 0x1000) strcpy(ext_table[drive][point].vol_label,REMOTE);
 12649                                  ;			 END
 12650                                  ;		    read_boot_record(ext_table[drive][point].start_cyl,
 12651                                  ;				     drive,
 12652                                  ;				     uc(0),
 12653                                  ;				     uc(1));						/* AN000 */
 12654                                  ;		    END
 12655                                  ;		END
 12656                                  ;	    END
 12657                                  ;
 12658                                  ;	return;
 12659                                  ;
 12660                                  ;END
 12661                                  
 12662                                  load_logical_drive:
 12663                                  
 12664                                  	;;%define tempnumsec_lw bp-34
 12665                                  	;;%define tempnumsec_hw bp-32
 12666                                  	;;%define temprelsec_lw bp-30
 12667                                  	;;%define temprelsec_hw bp-28
 12668                                  	;;%define _int_k        bp-26
 12669                                  	;%define _int_i	        bp-24
 12670                                  	;;%define _int_index_   bp-22
 12671                                  	;%define _char_vol_label_ bp-20 ; char volume_label[13]
 12672                                  	;;%define ext_part_num  bp-6
 12673                                  	;;%define _int_length_  bp-4
 12674                                  	;;;%define _partition_location_ bp-2 ; not used!
 12675                                  	;%define _bx_	        bp-2 ; **
 12676                                  
 12677                                  	;%define _point_	bp+4
 12678                                  	%define numlogdrvs	bp+4  ; 14/12/2018
 12679                                  	%define _drive_		bp+6
 12680                                  
 12681                                  	%define _char_vol_label_ bp-18 ; char volume_label[13]
 12682                                  	%define _int_i	         bp-4
 12683                                  	%define _bx_	         bp-2 ; **
 12684                                  
 12685 00001DDF 55                      		push	bp
 12686 00001DE0 89E5                    		mov	bp,sp
 12687                                  		;sub	sp,34
 12688 00001DE2 83EC12                  		sub	sp,18 ; 26/11/2018
 12689                                  		
 12690                                  		; 15/12/2018
 12691                                  		;push	di
 12692                                  		;push	si
 12693                                  
 12694                                  		;cmp	byte [boot_record+1FEh],55h
 12695                                  		;jne	short lld_1
 12696                                  		;cmp	byte [boot_record+1FFh],0AAh
 12697                                  		;je	short lld_for1
 12698 00001DE5 813E[D0CB]55AA          		cmp	word [boot_record+1FEh],0AA55h
 12699 00001DEB 7403                    		je	short lld_for1		
 12700                                  lld_1:
 12701 00001DED E9FC01                  		jmp	lld_17
 12702                                  lld_for1:
 12703                                  		;mov	word [_int_i],0
 12704                                  		; 15/12/2018
 12705                                  		;jmp	lld_for1_1
 12706 00001DF0 31DB                    		xor	bx,bx		
 12707 00001DF2 895EFC                  		mov	[_int_i],bx ; 0
 12708                                  		;jmp	lld_for1_next
 12709 00001DF5 E9FB00                  		jmp	lld_for1_if
 12710                                  
 12711                                  lld_2:
 12712                                  		;;mov	al,[numlogdrvs]
 12713                                  		;;cbw
 12714                                  		;;mov	cx,ax
 12715                                  		;;mov	cl,al
 12716                                  		;mov	cl,[numlogdrvs] ; 14/12/2018
 12717                                  		;mov	al,24
 12718                                  		;mul	byte [_drive_] 
 12719                                  		;;add	ax,cx
 12720                                  		;add	al,cl
 12721                                  		;;mov	cx,46
 12722                                  		;;;imul	cx
 12723                                  		;;mul	cx
 12724                                  		;mov	cx,46
 12725                                  		;mul	cl
 12726                                  		;mov	bx,ax ; *
 12727                                  		
 12728                                  		;mov	[_bx_],ax ; **
 12729                                  
 12730                                  		; 15/12/2018
 12731                                  		; bx = [_bx_]
 12732                                  		
 12733 00001DF8 C687[77A1]20            		mov	byte [ext_table_drive_letter+bx],' '
 12734                                  lld_3:
 12735                                  		;mov	al,[numlogdrvs]
 12736                                  		;cbw
 12737                                  		;mov	cx,ax
 12738                                  		;mov	al,24
 12739                                  		;mul	[_drive_]
 12740                                  		;add	ax,cx
 12741                                  		;mov	cx,46
 12742                                  		;imul	cx
 12743                                  		;mov	bx,ax ; *
 12744                                  		
 12745 00001DFD 30ED                    		xor	ch,ch ; 11/12/2018
 12746                                  
 12747                                  		; Read logical DOS drive's boot sector
 12748                                  
 12749                                  	;if (read_boot_record(ext_table[drive][point].start_cyl,
 12750                                  	;		 drive,
 12751                                  	;		 ext_table[drive][point].start_head,
 12752                                  	;		 ext_table[drive][point].start_sector));
 12753                                  
 12754                                  		; 15/12/2018	
 12755                                  		; ??? - What for we read this boot sector ?
 12756                                  		; (There is not any error check or any bs parameter
 12757                                  		; using after this boot sector reading !?)
 12758                                  
 12759 00001DFF 8B87[4DA1]              		mov	ax,[ext_table_start_cyl+bx]
 12760                                  		;mov	[_partition_location_],ax ; not used!
 12761 00001E03 8A8F[4CA1]              		mov	cl,[ext_table_start_sector+bx]
 12762 00001E07 51                      		push	cx
 12763 00001E08 8A8F[4BA1]              		mov	cl,[ext_table_start_head+bx]
 12764 00001E0C 51                      		push	cx
 12765 00001E0D 8A4E06                  		mov	cl,[_drive_]
 12766 00001E10 51                      		push	cx
 12767 00001E11 50                      		push	ax
 12768 00001E12 E8DD01                  		call	read_boot_record
 12769                                  		;add	sp,8 ; 22/12/2018
 12770                                  
 12771                                  lld_for1_if_chk_format:
 12772                                  		;mov	al,[numlogdrvs]
 12773                                  		;cbw
 12774                                  		;mov	cx,ax
 12775                                  		;mov	al,24
 12776                                  		;mul	[_drive_]
 12777                                  		;add	ax,cx
 12778                                  		;mov	cx,46
 12779                                  		;imul	cx
 12780                                  		;mov	bx,ax
 12781                                  
 12782 00001E15 8B5EFE                  		mov	bx,[_bx_] ; **		
 12783                                  
 12784 00001E18 8A87[77A1]              		mov	al,[ext_table_drive_letter+bx]
 12785                                  		;push	ax
 12786 00001E1C E80BFF                  		call	check_format
 12787                                  		;pop	bx
 12788                                  		;dec	al
 12789                                  		;jz	short lld_for1_if_chk_format_true
 12790 00001E1F 7302                    		jnc	short lld_for1_if_chk_format_true ; 27/11/2018
 12791 00001E21 EB77                    		jmp	lld_for1_if_chk_format_false
 12792                                  
 12793                                  lld_for1_if_chk_format_true:
 12794                                  
 12795                                  		;for (k = u(0); k < u(12); k++)
 12796                                  		;    BEGIN
 12797                                  		;	ext_table[drive][point].vol_label[k]=u(0);
 12798                                  		;    END
 12799                                  
 12800                                  		;mov	word [_int_k],0
 12801                                  lld_4:
 12802                                  		;mov	al,[numlogdrvs]
 12803                                  		;cbw
 12804                                  		;mov	cx,ax
 12805                                  		;mov	al,24
 12806                                  		;mul	[_drive_]
 12807                                  		;add	ax,cx
 12808                                  		;mov	cx,46
 12809                                  		;mul	cx
 12810                                  		;mov	si,ax
 12811                                  		
 12812                                  		;mov	si,[_bx_] ; **
 12813                                  
 12814                                  		;mov	bx,[_int_k]
 12815                                  		;mov	byte [ext_table_vol_label+bx+si],0
 12816                                  		;inc	byte [_int_k]
 12817                                  		;cmp	byte [_int_k],12
 12818                                  		;jb	short lld_4
 12819                                  
 12820                                  		; 26/11/2018
 12821                                  
 12822                                  		;mov	cx,12
 12823 00001E23 B91500                  		mov	cx,21 ; 12+9  ; +**+
 12824 00001E26 8B7EFE                  		mov	di,[_bx_]
 12825 00001E29 81C7[62A1]              		add	di,ext_table_vol_label
 12826 00001E2D 30C0                    		xor	al,al
 12827 00001E2F F3AA                    		rep	stosb
 12828                                  
 12829                                  		; for (k = u(0); k < u(9); k++)
 12830                                  		;     BEGIN
 12831                                  		;	ext_table[drive][point].system[k]=u(0);
 12832                                  		;     END
 12833                                  
 12834                                  		;mov	byte [_int_k],0
 12835                                  lld_5:
 12836                                  		;mov	al,[numlogdrvs]
 12837                                  		;cbw
 12838                                  		;mov	cx,ax
 12839                                  		;mov	al,24
 12840                                  		;mul	[_drive_]
 12841                                  		;add	ax,cx
 12842                                  		;mov	cx,46
 12843                                  		;mul	cx
 12844                                  		;mov	si,ax
 12845                                  
 12846                                  		;mov	si,[_bx_] ; **
 12847                                  
 12848                                  		;mov	bx,[_int_k]
 12849                                  		;mov	byte [ext_table_system+bx+si],0
 12850                                  		;inc	byte [_int_k]
 12851                                  		;cmp	byte [_int_k],9
 12852                                  		;jb	short lld_5
 12853                                  
 12854                                  		; 26/11/2018
 12855                                  		;mov	cx,9 ; +**+
 12856                                  		;mov	di,[_bx_]
 12857                                  		;add	di,ext_table_system
 12858                                  		;xor	al,al
 12859                                  		;rep	stosb
 12860                                  
 12861                                  		;get_volume_string(ext_table[drive][point].drive_letter,&volume_label[0]);
 12862                                  		
 12863 00001E31 8D46EE                  		lea	ax,[_char_vol_label_]
 12864 00001E34 50                      		push	ax
 12865                                  				
 12866                                  		;mov	al,[numlogdrvs]
 12867                                  		;cbw
 12868                                  		;mov	cx,ax
 12869                                  		;mov	al,24
 12870                                  		;mul	[_drive_]
 12871                                  		;add	ax,cx
 12872                                  		;mov	cx,46
 12873                                  		;imul	cx
 12874                                  		;mov	bx,ax
 12875                                  		
 12876 00001E35 8B5EFE                  		mov	bx,[_bx_] ; **
 12877                                  		
 12878 00001E38 8A87[77A1]              		mov	al,[ext_table_drive_letter+bx]
 12879 00001E3C 50                      		push	ax
 12880 00001E3D E813FF                  		call	get_volume_string
 12881                                  		;pop	bx  ; 05/01/2019
 12882                                  		;pop	bx
 12883                                  
 12884                                  		;for (k = u(0); k < strlen(volume_label); k++)
 12885                                  		;    BEGIN
 12886                                  		;	ext_table[drive][point].vol_label[k]=volume_label[k];
 12887                                  		;    END 
 12888                                  
 12889                                  		;mov	byte [_int_k],0
 12890                                  		;jmp	short lld_7
 12891                                  lld_6:
 12892                                  		;mov	si,[_int_k]
 12893                                  		;mov	al,[si+_char_vol_label_]
 12894                                  		;;mov	cx,ax
 12895                                  		;;mov	cl,al
 12896                                  
 12897                                  		;;mov	al,[numlogdrvs]
 12898                                  		;;cbw
 12899                                  		;;mov	dx,ax
 12900                                  		;;mov	al,24
 12901                                  		;;mul	byte [_drive_]
 12902                                  		;;add	ax,dx
 12903                                  		;;mov	bx,46
 12904                                  		;;mul	bx
 12905                                  		;;mov	bx,ax
 12906                                  
 12907                                  		;mov	bx,[_bx_] ; **
 12908                                  
 12909                                  		;;mov	byte [ext_table_vol_label+bx+si],cl
 12910                                  		;mov	byte [ext_table_vol_label+bx+si],al
 12911                                  
 12912                                  		;inc	byte [_int_k]
 12913                                  lld_7:
 12914                                  		;; 26/11/2018
 12915                                  		;;lea	ax,[_char_vol_label_]  ; char volume_label[13];
 12916                                  		;;push	ax
 12917                                  
 12918                                  		;lea	si,[_char_vol_label_]
 12919                                  		;call	strlen
 12920                                  		;;pop	bx
 12921                                  		;;cmp	ax,[_int_k]
 12922                                  		;cmp	cx,[_int_k]
 12923                                  		;ja	short lld_6
 12924                                  
 12925                                  		;;mov	al,[numlogdrvs]
 12926                                  		;;cbw
 12927                                  		;;mov	cx,ax
 12928                                  		;;mov	al,24
 12929                                  		;;mul	byte [_drive_]
 12930                                  		;;add	ax,cx
 12931                                  		;;mov	cx,46
 12932                                  		;;imul	cx
 12933                                  		;;mov	bx,ax
 12934                                  				
 12935 00001E40 8D76EE                  		lea	si,[_char_vol_label_]
 12936 00001E43 8B7EFE                  		mov	di,[_bx_] ; **
 12937 00001E46 81C7[62A1]              		add	di,ext_table_vol_label
 12938 00001E4A E8D6FE                  		call	strcpy	; 26/11/2018
 12939                                  		
 12940 00001E4D 8B5EFE                  		mov	bx,[_bx_] ; **
 12941                                  
 12942 00001E50 8A87[77A1]              		mov	al,[ext_table_drive_letter+bx]
 12943                                  		;push	ax
 12944 00001E54 E847FF                  		call	get_fs_and_vol
 12945                                  		;pop	bx
 12946                                  		;or	al,al
 12947                                  		;jz	short lld_10
 12948 00001E57 7223                    		jc	short lld_10 ; 26/11/2018
 12949                                  
 12950                                  		;for (k=u(0); k < u(8); k++)
 12951                                  		;    BEGIN
 12952                                  		;     if (dx_buff.file_system[k] != ' ')
 12953                                  		;	 length = k+1;
 12954                                  		;    END
 12955                                  		;
 12956                                  		; strncpy(ext_table[drive][point].system,&dx_buff.file_system[0],u(length));
 12957                                  
 12958                                  		; 26/11/2018
 12959                                  		;mov	byte [_int_k],0
 12960 00001E59 31DB                    		xor	bx,bx
 12961 00001E5B 31C9                    		xor	cx,cx
 12962                                  lld_8:
 12963                                  		;mov	bx,[_int_k]
 12964 00001E5D 80BF[7CA0]20            		cmp	byte [dx_buff_file_system+bx],' '
 12965 00001E62 7402                    		je	short lld_9
 12966                                  		;lea	ax,[bx+1]
 12967                                  		;mov	[_int_length_],ax
 12968 00001E64 FEC1                    		inc	cl
 12969                                  lld_9:
 12970                                  		;inc	byte [_int_k]
 12971 00001E66 FEC3                    		inc	bl
 12972                                  		;cmp	byte [_int_k],8
 12973 00001E68 80FB08                  		cmp	bl,8
 12974 00001E6B 72F0                    		jb	short lld_8
 12975                                  		
 12976                                  		;push	word [_int_length_]
 12977                                  		;mov	cx,[_int_length_] ; copy length for strncpy ; 26/11/2018
 12978                                  		
 12979                                  		;mov	ax,dx_buff_file_system
 12980                                  		;push	ax
 12981                                  		
 12982                                  		;mov	al,[numlogdrvs]
 12983                                  		;cbw
 12984                                  		;mov	cx,ax
 12985                                  		;mov	al,24
 12986                                  		;mul	[_drive_]
 12987                                  		;add	ax,cx
 12988                                  		;mov	cx,46
 12989                                  		;imul	cx
 12990                                  
 12991                                  		; 26/11/2018
 12992                                  
 12993                                  		;mov	ax,[_bx_] ; **
 12994                                  
 12995                                  		;add	ax,ext_table_system
 12996                                  		;push	ax
 12997                                  		;call	strncpy
 12998                                  		;add	sp,6
 12999                                  
 13000 00001E6D BE[7CA0]                		mov	si,dx_buff_file_system  ; source
 13001 00001E70 8B7EFE                  		mov	di,[_bx_]
 13002 00001E73 81C7[6EA1]              		add	di,ext_table_system	; destination
 13003                                  			;cx = number of characters to be copied
 13004 00001E77 E89DFE                  		call	strncpy
 13005                                  
 13006 00001E7A EB30                    		jmp	short lld_14
 13007                                  
 13008                                  lld_10:
 13009                                  		;mov	al,[numlogdrvs]
 13010                                  		;cbw
 13011                                  		;mov	cx,ax
 13012                                  		;mov	al,24
 13013                                  		;mul	[_drive_]
 13014                                  		;add	ax,cx
 13015                                  		;mov	cx,46
 13016                                  		;imul	cx
 13017                                  		;mov	bx,ax
 13018                                  
 13019                                  		; 26/11/2018
 13020                                  		;mov	bx,[_bx_] ; **
 13021 00001E7C 8B7EFE                  		mov	di,[_bx_] ; **
 13022                                  		; 14/12/2018
 13023 00001E7F 81C7[6EA1]              		add	di,ext_table_system
 13024                                  
 13025 00001E83 BE[675F]                		mov	si,extFAT16 ; 14/12/2018
 13026                                  		;cmp	word [ext_table_num_sec_hw+bx],0
 13027 00001E86 83BD[5AA1]00            		cmp	word [ext_table_num_sec_hw+di],0
 13028                                  		;jnz	short lld_11
 13029 00001E8B 751C                    		jnz	short lld_13 ; 14/12/2018
 13030                                  		;cmp	word [ext_table_num_sec_lw+bx],32680
 13031 00001E8D 81BD[58A1]A87F          		cmp	word [ext_table_num_sec_lw+di],32680
 13032                                  		;jbe	short lld_12
 13033                                  		; 14/12/2018
 13034 00001E93 7714                    		ja	short lld_13
 13035 00001E95 BE[705F]                		mov	si,extFAT12
 13036 00001E98 EB0F                    		jmp	short lld_13	
 13037                                  ; 14/12/2018
 13038                                  ;lld_11:	
 13039                                  ;		;mov	ax,extFAT16 ; "FAT16   "
 13040                                  ;		;push	ax
 13041                                  ;		;add	bx,ext_table_system
 13042                                  ;		;push	bx
 13043                                  ;
 13044                                  ;		mov	si,extFAT16
 13045                                  ;		
 13046                                  ;		;add	di,ext_table_system
 13047                                  ;		
 13048                                  ;		jmp	short lld_13
 13049                                  ;
 13050                                  ;lld_12:
 13051                                  ;		;mov	ax,extFAT12 ; "FAT12   "
 13052                                  ;		;push	ax
 13053                                  ;
 13054                                  ;		;mov	al,[numlogdrvs]
 13055                                  ;		;cbw
 13056                                  ;		;mov	cx,ax
 13057                                  ;		;mov	al,24
 13058                                  ;		;mul	[_drive_]
 13059                                  ;		;add	ax,cx
 13060                                  ;		;mov	cx,46
 13061                                  ;		;imul	cx
 13062                                  ;		
 13063                                  ;		; 26/11/2018
 13064                                  ;		;mov	ax,[_bx_] ; **
 13065                                  ;
 13066                                  ;		;add	ax,ext_table_system
 13067                                  ;		;push	ax
 13068                                  ;
 13069                                  ;		mov	si,extFAT12
 13070                                  ;		
 13071                                  ;		;mov	di,[_bx_] ; **
 13072                                  ;		;add	di,ext_table_system
 13073                                  ;
 13074                                  ;		jmp	short lld_13
 13075                                  
 13076                                  lld_for1_if_chk_format_false:
 13077                                  		;mov	ax,extNOVOLUME
 13078                                  		;push	ax
 13079                                  
 13080                                  		;mov	al,[numlogdrvs]
 13081                                  		;cbw
 13082                                  		;mov	cx,ax
 13083                                  		;mov	al,24
 13084                                  		;mul	byte [_drive_]
 13085                                  		;add	ax,cx
 13086                                  		;mov	cx,46
 13087                                  		;imul	cx
 13088                                  		;mov	cx,ax
 13089                                  
 13090                                  		; 26/11/2018
 13091                                  		;mov	ax,[_bx_] ; **
 13092                                  		;mov	si,ax
 13093                                  		;add	ax,ext_table_vol_label
 13094                                  		;push	ax
 13095                                  		;;mov	si,cx
 13096                                  		;call	strcpy
 13097                                  		;pop	bx
 13098                                  		;pop	bx
 13099                                  
 13100                                  		; 05/01/2019
 13101                                  		;mov	si,extNOVOLUME
 13102 00001E9A 8B7EFE                  		mov	di,[_bx_] ; **
 13103                                  		;add	di,ext_table_vol_label
 13104                                  		;call	strcpy
 13105                                  
 13106 00001E9D C685[62A1]00            		mov	byte [di+ext_table_vol_label],0 ; extNOVOLUME
 13107                                  		
 13108                                  		;mov	ax,extUNKNOWN ;	"UNKNOWN "
 13109                                  		;push	ax
 13110                                  
 13111                                  		;add	si,ext_table_system
 13112                                  		;push	si
 13113                                  
 13114 00001EA2 BE[7A5F]                		mov	si,extUNKNOWN
 13115                                  		;mov	di,[_bx_] ; **
 13116                                  		; 05/01/2019
 13117 00001EA5 81C7[6EA1]              		add	di,ext_table_system ; =*
 13118                                  lld_13:
 13119 00001EA9 E877FE                  		call	strcpy
 13120                                  		;pop	bx
 13121                                  		;pop	bx
 13122                                  lld_14:
 13123                                  		;mov	word [regs_x_dx],0
 13124                                  		;mov	word [regs_x_ax],4409h
 13125                                  		
 13126                                  		;mov	al,[numlogdrvs]
 13127                                  		;cbw
 13128                                  		;mov	cx,ax
 13129                                  		;mov	al,24
 13130                                  		;mul	[_drive_]
 13131                                  		;add	ax,cx
 13132                                  		;mov	cx,46
 13133                                  		;imul	cx
 13134                                  		;mov	bx,ax
 13135                                  
 13136                                  		; 26/11/2018
 13137                                  
 13138                                  		;mov	bx,[_bx_] ; **
 13139                                  
 13140                                  		;mov	al,[ext_table_drive_letter+bx]
 13141                                  		;sub	al,40h
 13142                                  		;mov	[regs_x_bx],al
 13143                                  		;mov	ax,regs ; regs_x_ax
 13144                                  		;push	ax
 13145                                  		;push	ax
 13146                                  		;;mov	si,bx
 13147                                  		;mov	di,bx ; 26/11/2018 ; **
 13148                                  		;call	intdos
 13149                                  		;pop	bx
 13150                                  		;pop	bx
 13151                                  		;test	byte [regs_x_dx+1],10h
 13152                                  		;jz	short lld_15
 13153                                  
 13154                                  		; 14/12/2018
 13155 00001EAC 8B7EFE                  		mov	di,[_bx_] ; **
 13156                                  
 13157                                  		; DOS 3.1+ - IOCTL - CHECK IF BLOCK DEVICE REMOTE
 13158 00001EAF B80944                  		mov	ax,4409h
 13159 00001EB2 8A9D[77A1]              		mov	bl,[ext_table_drive_letter+di] ; **
 13160 00001EB6 80EB40                  		sub	bl,40h
 13161 00001EB9 CD21                    		int	21h
 13162 00001EBB F6C610                  		test	dh,10h ; DX bit 12, 'Drive is Remote' flag
 13163 00001EBE 740B                    		jz	short lld_15
 13164                                  			; Note: DX = 0800h (MSDOS) or 
 13165                                  			;	DX = 4800h (WINDOWS 95) --> RAM Drive
 13166                                  		
 13167                                  		; ah = 0 ?
 13168                                  
 13169                                  		;push	word [REMOTE]
 13170                                  		;add	si,ext_table_vol_label
 13171                                  		;push	si
 13172                                  
 13173 00001EC0 8B36[C89E]              		mov	si,[REMOTE]
 13174                                  
 13175                                  		;mov	di,[_bx_] ; ** ; 14/12/2018
 13176                                  
 13177 00001EC4 81C7[62A1]              		add	di,ext_table_vol_label ; **
 13178                                  
 13179 00001EC8 E858FE                  		call	strcpy
 13180                                  		;pop	bx
 13181                                  		;pop	bx
 13182                                  
 13183                                  		; ah = 0 ?
 13184                                  lld_15:
 13185                                  		;read_boot_record(ext_table[drive][point].start_cyl,
 13186                                  		;		     drive,
 13187                                  		;		     uc(0),
 13188                                  		;		     uc(1));              
 13189                                  
 13190                                  		;mov	al,1
 13191 00001ECB B80100                  		mov	ax,1 ; 11/12/2018 (ah = 0)
 13192 00001ECE 50                      		push	ax
 13193 00001ECF 28C0                    		sub	al,al ; 0
 13194 00001ED1 50                      		push	ax
 13195 00001ED2 8A4606                  		mov	al,[_drive_]
 13196 00001ED5 50                      		push	ax
 13197                                  		
 13198                                  		;mov	al,[numlogdrvs]
 13199                                  		;cbw
 13200                                  		;mov	cx,ax
 13201                                  		;mov	al,24
 13202                                  		;mul	byte [_drive_]
 13203                                  		;add	ax,cx
 13204                                  		;mov	cx,46
 13205                                  		;imul	cx
 13206                                  		;mov	bx,ax
 13207                                  		
 13208 00001ED6 8B5EFE                  		mov	bx,[_bx_] ; **
 13209                                  
 13210 00001ED9 FFB7[4DA1]              		push	word [ext_table_start_cyl+bx]
 13211 00001EDD E81201                  		call	read_boot_record
 13212                                  		;add	sp,8 ; 22/12/2018
 13213                                  
 13214                                  lld_for1_if_false:
 13215 00001EE0 FE46FC                  		inc	byte [_int_i]
 13216                                  lld_for1_1:
 13217 00001EE3 807EFC04                		cmp	byte [_int_i],4
 13218 00001EE7 7203                    		jb	short lld_for1_next
 13219 00001EE9 E90001                  		jmp	lld_17
 13220                                  
 13221                                  lld_for1_next:
 13222 00001EEC B104                    		mov	cl,4
 13223 00001EEE 8B5EFC                  		mov	bx,[_int_i]
 13224 00001EF1 D3E3                    		shl	bx,cl ; * 16
 13225                                  		; 26/11/2018
 13226                                  		;mov	[_int_index_],bx ; index = i*16;
 13227                                  lld_for1_if:
 13228                                  	;if ((boot_record[0x1C2 + index] != uc(0)) && 
 13229                                  	;	(boot_record[0x1C2 + index] != uc(EXTENDED))) 
 13230                                  
 13231                                  		;cmp	byte [boot_record+1C2h+bx],0 
 13232                                  		;je	short lld_for1_if_false
 13233                                  		;cmp	byte [boot_record+1C2h+bx],EXTENDED ; 5
 13234                                  		;je	short lld_for1_if_false
 13235                                  
 13236                                  		;mov	al,[boot_record+1C2h+bx]  ; Partition ID
 13237                                  		;or	al,al
 13238                                  		;jz	short lld_for1_if_false
 13239                                  		;cmp	al,EXTENDED ; 5
 13240                                  		;je	short lld_for1_if_false
 13241                                  
 13242                                  		; 15/12/2018
 13243                                  		; Here we are checking partition 0 to 3 of
 13244                                  		; (extended partition table of) extended volume.
 13245                                  		; (Partition 1,2 and 3 must have a ZERO or 
 13246                                  		; EXTENDED DOS partition ID while Partition 0 has a
 13247                                  		; valid DOS partition ID.)
 13248                                  		; [Otherwise, previous logical dos partition data 
 13249                                  		; would be overwritten, but logical drive letter 
 13250                                  		; would be changed to next letter!?]
 13251                                  
 13252                                  		; (For valid scheme: If there are 2 or more Logical 
 13253                                  		; DOS partitions.. partition -table entry- 0 must 
 13254                                  		; have DOS partition ID; partition 1 must have 
 13255                                  		; Extended DOS partition ID; partition 3 and 4 
 13256                                  		; must be empty in the extended partition table of 
 13257                                  		; the first -extended volume- logical dos partition.)
 13258                                  
 13259                                  		; (It seem as Extended DOS partition construction logic 
 13260                                  		; is defective. Instead of this defective construction,
 13261                                  		; it would be better if extended partition -boot sector- table
 13262                                  		; would have same construction with masterboot partition table.)
 13263                                  		; [Erdogan Tan, 15/12/2018]		
 13264                                  	
 13265 00001EF3 8A97[94CB]              		mov	dl,[boot_record+1C2h+bx]  ; Partition ID ; /**/	
 13266 00001EF7 08D2                    		or	dl,dl
 13267 00001EF9 74E5                    		jz	short lld_for1_if_false
 13268 00001EFB 80FA05                  		cmp	dl,EXTENDED ; 5
 13269 00001EFE 74E0                    		je	short lld_for1_if_false
 13270                                  
 13271                                  lld_for1_if_true:
 13272                                  		;mov	al,[numlogdrvs]
 13273                                  		;cbw
 13274                                  		;mov	cx,24
 13275                                  		;mov	dx,ax
 13276                                  		;mov	al,[_drive_]
 13277                                  		;sub	ah,ah
 13278                                  		;mov	si,dx
 13279                                  		;mov	di,46
 13280                                  		;mov	bx,ax
 13281                                  		;mul	cx
 13282                                  		;add	ax,si
 13283                                  		;imul	di
 13284                                  		;mov	si,ax
 13285                                  
 13286                                  		; 15/12/2018
 13287                                  		;mov	cl,[numlogdrvs] ; Logical drive index
 13288 00001F00 B018                    		mov	al,24
 13289 00001F02 F66606                  		mul	byte [_drive_] 
 13290                                  		;;add	ax,cx
 13291                                  		;add	al,cl
 13292 00001F05 024604                  		add	al,[numlogdrvs] ; 19/12/2018
 13293 00001F08 B92E00                  		mov	cx,46
 13294 00001F0B F6E1                    		mul	cl
 13295 00001F0D 89C6                    		mov	si,ax ; ** ; (([_drive_]*24)+[_numlogdrvs])*46
 13296                                  		
 13297 00001F0F 8946FE                  		mov	[_bx_],ax
 13298                                  
 13299                                  		; 14/12/2018
 13300                                  		;mov	[ext_table_sys_id+si],al ; /**/
 13301                                  		; 15/12/2018
 13302 00001F12 8894[4FA1]              		mov	[ext_table_sys_id+si],dl ; /**/		
 13303                                  
 13304                                  		;/* Get boot ind */
 13305                                  		;ext_table[drive][point].boot_ind = boot_record[0x1BE + index];
 13306                                  		;mov	di,[_int_index_]
 13307                                  		;mov	al,[boot_record+1BEh+di]
 13308 00001F16 8A87[90CB]              		mov	al,[boot_record+1BEh+bx]
 13309 00001F1A 8884[4AA1]              		mov	[ext_table_boot_ind+si],al
 13310                                  
 13311                                  		;/* Start head */
 13312                                  		;ext_table[drive][point].start_head = boot_record[0x1BF + index];
 13313                                  		;mov	al,[boot_record+1BFh+di]
 13314 00001F1E 8A87[91CB]              		mov	al,[boot_record+1BFh+bx]
 13315 00001F22 8884[4BA1]              		mov	[ext_table_start_head+si],al
 13316                                  
 13317                                  		;/* Start sector - unscramble it from INT 13 format*/
 13318                                  		;ext_table[drive][point].start_sector= (boot_record[0x1C0 + index] & 0x3F);
 13319                                  		;mov	al,[boot_record+1C0h+di]
 13320 00001F26 8A87[92CB]              		mov	al,[boot_record+1C0h+bx]
 13321                                  		;mov	cx,ax
 13322 00001F2A 88C1                    		mov	cl,al ; 15/12/2018
 13323 00001F2C 243F                    		and	al,3Fh
 13324 00001F2E 8884[4CA1]              		mov	[ext_table_start_sector+si],al
 13325                                      		;/* Start cyl - unscramble it from INT 13 format*/
 13326                                  		;  ext_table[drive][point].start_cyl= ((((unsigned)boot_record[0x1C0+index]) & 0x00C0) << 2)
 13327                                  		;	+ ((unsigned)boot_record[0x1C1+index]);
 13328                                  		;and	cx,0C0h
 13329 00001F32 80E1C0                  		and	cl,0C0h ; 15/12/2018
 13330 00001F35 D1E1                    		shl	cx,1
 13331 00001F37 D1E1                    		shl	cx,1
 13332                                  		;;mov	al,[boot_record+1C1h+di]
 13333                                  		;mov	al,[boot_record+1C1h+bx]
 13334                                  		;;sub	ah,ah
 13335                                  		;;add	cx,ax
 13336                                  		;mov	cl,al
 13337 00001F39 8A8F[93CB]              		mov	cl,[boot_record+1C1h+bx] ; 15/12/2018
 13338 00001F3D 898C[4DA1]              		mov	[ext_table_start_cyl+si],cx
 13339                                  
 13340                                  		;/* System id */
 13341                                  		;ext_table[drive][point].sys_id = boot_record[0x1C2+index];
 13342                                  		;mov	al,[boot_record+1C2h+di]
 13343                                  		; 14/12/2018
 13344                                  		;mov	al,[boot_record+1C2h+bx]
 13345                                  		;mov	[ext_table_sys_id+si],al ; /**/
 13346                                  
 13347                                  		;/* End head */
 13348                                  		;ext_table[drive][point].end_head = boot_record[0x1C3+index];
 13349                                  		;mov	al,[boot_record+1C3h+di]
 13350 00001F41 8A87[95CB]              		mov	al,[boot_record+1C3h+bx]
 13351 00001F45 8884[50A1]              		mov	[ext_table_end_head+si],al
 13352                                  
 13353                                  		;/* End sector - unscramble it from INT 13 format*/
 13354                                  		;ext_table[drive][point].end_sector= (boot_record[0x1C4+index] & 0x3F);
 13355                                  		;mov	al,[boot_record+1C4h+di]
 13356 00001F49 8A87[96CB]              		mov	al,[boot_record+1C4h+bx]
 13357                                  		;mov	cx,ax
 13358 00001F4D 88C1                    		mov	cl,al
 13359 00001F4F 243F                    		and	al,3Fh
 13360 00001F51 8884[51A1]              		mov	[ext_table_end_sector+si],al
 13361                                  		;/* End cyl - unscramble it from INT 13 format*/
 13362                                  		;ext_table[drive][point].end_cyl= ((((unsigned)boot_record[0x1C4+index]) & 0x00C0) << 2)
 13363                                  		;	+ ((unsigned)boot_record[0x1C5+index]);
 13364 00001F55 81E1C000                		and	cx,0C0h
 13365 00001F59 D1E1                    		shl	cx,1
 13366 00001F5B D1E1                    		shl	cx,1
 13367                                  		;;mov	al,[boot_record+1C5h+di]
 13368                                  		;mov	al,[boot_record+1C5h+bx]
 13369                                  		;;add	cx,ax
 13370                                  		;mov	cl,al
 13371 00001F5D 8A8F[97CB]              		mov	cl,[boot_record+1C5h+bx] ; 15/12/2018
 13372 00001F61 898C[52A1]              		mov	[ext_table_end_cyl+si],cx
 13373                                  
 13374                                  		;/* Relative sectors */
 13375                                  		;ext_table[drive][point].rel_sec = ((unsigned long)boot_record[0x1C9+index]) << 24;
 13376                                  		;ext_table[drive][point].rel_sec =
 13377                                  		;    ext_table[drive][point].rel_sec+(((unsigned long)boot_record[0x1C8+index]) << 16);
 13378                                  		;ext_table[drive][point].rel_sec =
 13379                                  		;    ext_table[drive][point].rel_sec+(((unsigned long)boot_record[0x1C7+index]) << 8);
 13380                                  		;ext_table[drive][point].rel_sec =
 13381                                  		;    ext_table[drive][point].rel_sec+((unsigned long)boot_record[0x1C6+index]);
 13382                                  
 13383                                  		;mov	al,[boot_record+1C9h+di]
 13384                                  		;mov	ah,al
 13385                                  		;sub	al,al
 13386                                  		;sub	cx,cx
 13387                                  		;mov	[ext_table_rel_sec_lw+si],cx
 13388                                  		;mov	[ext_table_rel_sec_hw+si],ax
 13389                                  		;mov	dl,[boot_record+1C8h+di]
 13390                                  		;sub	dh,dh
 13391                                  		;sub	di,di
 13392                                  		;add	cx,di
 13393                                  		;adc	ax,dx
 13394                                  		;mov	[ext_table_rel_sec_lw+si],cx
 13395                                  		;mov	[ext_table_rel_sec_hw+si],ax
 13396                                  		;mov	di,[_int_index_]
 13397                                  		;mov	dx,ax
 13398                                  		;mov	al,[boot_record+1C7h+di]
 13399                                  		;sub	ah,ah
 13400                                  		;mov	di,dx
 13401                                  		;sub	dx,dx
 13402                                  		;mov	[temprelsec_lw],cx
 13403                                  		;mov	[temprelsec_hw],di
 13404                                  		;mov	cl,8
 13405                                  		;mov	di,bx
 13406                                  		;call	shl32
 13407                                  		;add	ax,[temprelsec_lw]
 13408                                  		;adc	dx,[temprelsec_hw]
 13409                                  		;mov	[ext_table_rel_sec_lw+si], ax
 13410                                  		;mov	[ext_table_rel_sec_hw+si], dx
 13411                                  		;mov	bx,[_int_index_]
 13412                                  		;mov	cl,[boot_record+1C6h+bx]
 13413                                  		;sub	ch,ch
 13414                                  		;add	ax,cx
 13415                                  		;adc	dx,0
 13416                                  		;mov	[ext_table_rel_sec_lw+si],ax
 13417                                  		;mov	[ext_table_rel_sec_hw+si],dx
 13418                                  
 13419                                  		; 26/11/2018
 13420                                  		;mov	ax,[boot_record+1C6h+di]
 13421                                  		;mov	dx,[boot_record+1C8h+di]
 13422 00001F65 8B87[98CB]              		mov	ax,[boot_record+1C6h+bx]
 13423 00001F69 8B97[9ACB]              		mov	dx,[boot_record+1C8h+bx]
 13424 00001F6D 8984[54A1]              		mov	[ext_table_rel_sec_lw+si],ax
 13425 00001F71 8994[56A1]              		mov	[ext_table_rel_sec_hw+si],dx
 13426                                  
 13427                                  		;/* Number of sectors */
 13428                                  		;ext_table[drive][point].num_sec = ((unsigned long)boot_record[0x1CD+index]) << 24;
 13429                                  		;ext_table[drive][point].num_sec =
 13430                                  		;    ext_table[drive][point].num_sec+(((unsigned long)boot_record[0x1CC+index]) << 16);
 13431                                  		;ext_table[drive][point].num_sec =
 13432                                  		;    ext_table[drive][point].num_sec+(((unsigned long)boot_record[0x1CB+index]) << 8);
 13433                                  		;ext_table[drive][point].num_sec =
 13434                                  		;    ext_table[drive][point].num_sec + ((unsigned long)boot_record[0x1CA+index]);
 13435                                  
 13436                                  		;mov	al,[boot_record+1CDh+bx]
 13437                                  		;mov	ah,al
 13438                                  		;sub	al,al
 13439                                  		;sub	cx,cx
 13440                                  		;mov	[ext_table_num_sec_lw+si],cx
 13441                                  		;mov	[ext_table_num_sec_hw+si],ax
 13442                                  		;mov	dl,[boot_record+1CCh+bx]
 13443                                  		;sub	dh,dh
 13444                                  		;sub	bx,bx
 13445                                  		;add	cx,bx
 13446                                  		;adc	ax,dx
 13447                                  		;mov	[ext_table_num_sec_lw+si],cx
 13448                                  		;mov	[ext_table_num_sec_hw+si],ax
 13449                                  		;mov	bx,[_int_index_]
 13450                                  		;mov	dx,ax
 13451                                  		;mov	al,[boot_record+1CBh+bx]
 13452                                  		;sub	ah,ah
 13453                                  		;mov	bx,dx
 13454                                  		;sub	dx,dx
 13455                                  		;mov	[tempnumsec_lw],cx
 13456                                  		;mov	[tempnumsec_hw],bx
 13457                                  		;mov	cl,8
 13458                                  		;call	shl32
 13459                                  		;add	ax,[tempnumsec_lw]
 13460                                  		;adc	dx,[tempnumsec_hw]
 13461                                  		;mov	[ext_table_num_sec_lw+si],ax
 13462                                  		;mov	[ext_table_num_sec_hw+si],dx
 13463                                  		;mov	bx,[_int_index_]
 13464                                  		;mov	cl,[boot_record+1CAh+bx]
 13465                                  		;sub	ch,ch
 13466                                  		;add	ax,cx
 13467                                  		;adc	dx,0
 13468                                  		;mov	[ext_table_num_sec_lw+si],ax
 13469                                  		;mov	[ext_table_num_sec_hw+si],dx
 13470                                  
 13471                                  		; 26/11/2018
 13472                                  		;mov	ax,[boot_record+1CAh+di]
 13473                                  		;mov	dx,[boot_record+1CCh+di]
 13474 00001F75 8B87[9CCB]              		mov	ax,[boot_record+1CAh+bx]
 13475 00001F79 8B97[9ECB]              		mov	dx,[boot_record+1CCh+bx]
 13476 00001F7D 8984[58A1]              		mov	[ext_table_num_sec_lw+si],ax
 13477 00001F81 8994[5AA1]              		mov	[ext_table_num_sec_hw+si],dx
 13478                                  
 13479                                  	;ext_table[drive][point].mbytes_used =
 13480                                  	; cylinders_to_mbytes(((ext_table[drive][point].end_cyl - ext_table[drive][point].start_cyl)+1),
 13481                                  	; 			cur_disk);
 13482                                  
 13483 00001F85 89DF                    		mov	di,bx ; [_int_index_] ; ****
 13484                                  			; bh = 0
 13485                                  
 13486                                  		;mov	al,[cur_disk]
 13487                                  		;push	ax
 13488                                  		
 13489 00001F87 8A1E[D4CB]              		mov	bl,[cur_disk]
 13490                                  		;xor	bh,bh ; 0
 13491                                  			;bx = Disk drive Number 0 to 7
 13492                                  
 13493 00001F8B 8B84[52A1]              		mov	ax,[ext_table_end_cyl+si]
 13494 00001F8F 2B84[4DA1]              		sub	ax,[ext_table_start_cyl+si]
 13495 00001F93 40                      		inc	ax
 13496                                  			; ax = number of cylinders (partition size in cylinders)
 13497                                  		;push	ax
 13498 00001F94 E8C5F5                  		call	cylinders_to_mbytes
 13499                                  			; ax = partition size in megabytes
 13500                                  		;pop	bx
 13501                                  		;pop	bx
 13502 00001F97 8984[5EA1]              		mov	[ext_table_mbytes_used+si],ax
 13503                                  
 13504                                  		; 14/12/2018
 13505                                  		;mov	al,5 ; EXTENDED
 13506                                  		;;push	ax
 13507                                  		;call	find_partition_location
 13508                                  		;;pop	bx
 13509                                  		;	; al = partition number (0 to 3) or 0FFh (not found)
 13510                                  
 13511                                  		; 26/11/2018	
 13512                                  		;cbw
 13513                                  		;mov	[ext_part_num],ax
 13514                                  		
 13515                                  		; 14/12/2018
 13516                                  		; get partition entry number of extended dos partion
 13517                                   		; 	(on current disk/drive)
 13518 00001F9B B005                    		mov	al,5
 13519 00001F9D E81AFE                  		call	find_partition_type
 13520                                  		; CL = partition number (index), 0 to 3 or 4 (not found)
 13521                                  
 13522                                  		;mov	ax,di ; [_drive_] ; Drive number (0 to 7)
 13523                                  		;shl	ax,1
 13524                                  		;shl	ax,1
 13525                                  		;add	ax,[ext_part_num]
 13526                                  
 13527                                  		; 14/12/2018
 13528 00001FA0 8A4606                  		mov	al,[_drive_]
 13529 00001FA3 D0E0                    		shl	al,1
 13530 00001FA5 D0E0                    		shl	al,1
 13531 00001FA7 00C8                    		add	al,cl ; Partition (entry) number (0 to 3)
 13532                                  		;mov	cx,46
 13533                                  		;mul	cx
 13534 00001FA9 B12E                    		mov	cl,46
 13535 00001FAB F6E1                    		mul	cl
 13536 00001FAD 89C3                    		mov	bx,ax
 13537                                  		
 13538                                  		;mov	ax,[part_table_end_cyl+bx]
 13539                                  		;sub	ax,[part_table_start_cyl+bx]
 13540                                  		;inc	ax
 13541                                  		;push	ax
 13542                                  
 13543 00001FAF 8B8F[1AC4]              		mov	cx,[part_table_end_cyl+bx]
 13544 00001FB3 2B8F[15C4]              		sub	cx,[part_table_start_cyl+bx]
 13545 00001FB7 41                      		inc	cx 
 13546                                  			; cx = Total cylinders (of extended partition)
 13547                                  		
 13548                                  		;mov	ax,[ext_table_end_cyl+si]
 13549                                  		;;sub	ax,[ext_table_start_cyl+si]
 13550                                  		;inc	ax
 13551                                  		;push	ax
 13552                                  		
 13553 00001FB8 8B9C[52A1]              		mov	bx,[ext_table_end_cyl+si]
 13554 00001FBC 2B9C[4DA1]              		sub	bx,[ext_table_start_cyl+si]
 13555 00001FC0 43                      		inc	bx
 13556                                  			; bx = Number of logical drive/partition cylinders 
 13557                                  
 13558 00001FC1 E8EBF5                  		call	cylinders_to_percent   ; (100*bx/cx)%
 13559                                  		;pop	bx
 13560                                  		;pop	bx
 13561 00001FC4 8984[60A1]              		mov	[ext_table_percent_used+si],ax ; percentage (<=100)
 13562                                  		
 13563                                  		;mov	bx,[_int_index_]
 13564                                  		;mov	bx,di ; [_int_index_] ; ****
 13565                                  
 13566                                  		; 26/11/2018
 13567                                  
 13568                                  		;cmp	byte [boot_record+1C2h+bx],1
 13569                                  		;je	short lld_16
 13570                                  		;cmp	byte [boot_record+1C2h+bx],4
 13571                                  		;je	short lld_16
 13572                                  		;cmp	byte [boot_record+1C2h+bx],6
 13573                                  		;je	short lld_16
 13574                                  
 13575                                  		;mov	al,[bx+boot_record+1C2h] ; Partition/System ID	
 13576 00001FC8 8A85[94CB]              		mov	al,[di+boot_record+1C2h] ; ****	
 13577                                  
 13578                                  		; 15/12/2018
 13579 00001FCC 8B5EFE                  		mov	bx,[_bx_] ; **
 13580                                  
 13581 00001FCF 3C01                    		cmp	al,DOS12  ; 1		
 13582 00001FD1 740B                    		je	short lld_16
 13583 00001FD3 3C04                    		cmp	al,DOS16  ; 4
 13584 00001FD5 7407                    		je	short lld_16
 13585 00001FD7 3C06                    		cmp	al,DOSNEW ; 6 
 13586 00001FD9 7403                    		je	short lld_16
 13587                                  
 13588 00001FDB E91AFE                  		jmp	lld_2
 13589                                  lld_16:
 13590                                  		;mov	al,[numlogdrvs]
 13591                                  		;cbw
 13592                                  		;mov	cx,ax
 13593                                  		;mov	al,24
 13594                                  		;mul	[_drive_]
 13595                                  		;add	ax,cx
 13596                                  		;mov	cx,46
 13597                                  		;imul	cx
 13598                                  		;mov	bx,ax
 13599                                  
 13600                                  		; 15/12/2018
 13601                                  		;mov	bx,[_bx_] ; **
 13602                                  
 13603 00001FDE A0[1FA1]                		mov	al,[next_letter]
 13604 00001FE1 FE06[1FA1]              		inc	byte [next_letter]
 13605 00001FE5 8887[77A1]              		mov	[ext_table_drive_letter+bx],al
 13606 00001FE9 E911FE                  		jmp	lld_3
 13607                                  lld_17:
 13608                                  		; 15/12/2018
 13609                                  		;pop	si
 13610                                  		;pop	di
 13611                                  		
 13612 00001FEC 89EC                    		mov	sp,bp
 13613 00001FEE 5D                      		pop	bp
 13614 00001FEF C20400                  		retn	4 ; 06/01/2019
 13615                                  
 13616                                  ; ----------------------------------------------------------------------------
 13617                                  ; int13.c (FDISK, MSDOS 6.0, 1991)	
 13618                                  ; ----------------------------------------------------------------------------
 13619                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 26/11/2018)
 13620                                  
 13621                                  ;/*  */
 13622                                  ;char read_boot_record(cylinder,which_disk,which_head,which_sector) /* AC000 */
 13623                                  ;
 13624                                  ;unsigned        cylinder;
 13625                                  ;unsigned char   which_disk;
 13626                                  ;unsigned char   which_head;					  /* AN000 */
 13627                                  ;unsigned char   which_sector;					  /* AN000 */
 13628                                  ;
 13629                                  ;BEGIN
 13630                                  ;
 13631                                  ;   char far *buffer_pointer = boot_record;
 13632                                  ;
 13633                                  ;   /* Setup read, always on a cylinder boundary */
 13634                                  ;   regs.h.ah = uc(READ_DISK);                                    /* AC000 */
 13635                                  ;   regs.h.al = uc(1);                                            /* AC000 */
 13636                                  ;   regs.h.dh = which_head;                                       /* AC000 */
 13637                                  ;   regs.h.cl = which_sector;                                     /* AC000 */
 13638                                  ;
 13639                                  ;   /* Specify the disk */
 13640                                  ;   regs.h.dl = which_disk + 0x80;
 13641                                  ;
 13642                                  ;   /* Need to scramble CX so that sectors and cyl's are in INT 13 format */
 13643                                  ;
 13644                                  ;   if (cylinder > u(255))                                        /* AC000 */
 13645                                  ;      BEGIN
 13646                                  ;       regs.h.cl = regs.h.cl | ((char)((cylinder /256) << 6));
 13647                                  ;      END
 13648                                  ;   regs.h.ch = (unsigned char)(cylinder & 0xFF);
 13649                                  ;
 13650                                  ;   /* Point at the place to write the boot record */
 13651                                  ;   regs.x.bx = FP_OFF(buffer_pointer);
 13652                                  ;   segregs.es = FP_SEG(buffer_pointer);
 13653                                  ;
 13654                                  ;   /* read in the boot record */
 13655                                  ;   DiskIo(&regs,&regs,&segregs);			         /* AC000 */
 13656                                  ;   /* Check for error reading it */
 13657                                  ;   if ((regs.x.cflag & 1) != u(1))                              /* AC000 */
 13658                                  ;      BEGIN
 13659                                  ;       return(TRUE);
 13660                                  ;      END
 13661                                  ;   else
 13662                                  ;      BEGIN
 13663                                  ;       /* Tell user there was an error */
 13664                                  ;       good_disk[which_disk] = FALSE;
 13665                                  ;       clear_screen(u(0),u(0),u(24),u(79));			 /* AC000 */
 13666                                  ;       return(FALSE);
 13667                                  ;      END
 13668                                  ;END
 13669                                  
 13670                                  read_boot_record:
 13671                                  		; 26/11/2018
 13672                                  	
 13673                                  	;%define rbs_buffer   bp-4  ; word
 13674                                  	;%define rbs_segment  bp-2  ; word
 13675                                  	%define rbs_cylinder bp+4  ; word
 13676                                  	%define rbs_disk     bp+6  ; byte
 13677                                  	%define rbs_head     bp+8  ; byte
 13678                                  	%define rbs_sector   bp+10 ; byte
 13679                                  
 13680                                  		; Modified registers: ax,bx,cx,dx
 13681                                  
 13682 00001FF2 55                      		push	bp
 13683 00001FF3 89E5                    		mov	bp,sp
 13684                                  		;sub	sp,4 ; 11/12/2018
 13685                                  
 13686                                  		;mov	word [rbs_buffer],boot_record
 13687                                  		;mov	[rbs_segment],ds
 13688                                  		
 13689 00001FF5 BB[D2C9]                		mov	bx,boot_record
 13690                                  		;push	ds
 13691                                  		;pop	es
 13692                                  	
 13693                                  		;mov	byte [regs_x_ax+1],2 ; read
 13694                                  		;mov	byte [regs_x_ax],1   ; 1 sector
 13695                                  	
 13696                                  		;mov	al,[rbs_head]
 13697                                  		;mov	[regs_x_dx+1],al
 13698 00001FF8 8A7608                  		mov	dh,[rbs_head]	; Head (0 to 255)		
 13699                                  
 13700                                  		;mov	al,[rbs_sector]
 13701                                  		;mov	[regs_x_cx], al
 13702 00001FFB 8A4E0A                  		mov	cl,[rbs_sector]	; Sector (1 to 63)	
 13703                                  
 13704                                  		;mov	al,[rbs_disk]
 13705                                  		;add	al,80h
 13706                                  		;mov	[regs_x_dx],al
 13707 00001FFE 8A5606                  		mov	dl,[rbs_disk]
 13708 00002001 80C280                  		add	dl,80h	; Hard disk drive number (80h to 87h)	
 13709                                  
 13710                                  		;cmp	word [rbs_cylinder],255
 13711                                  		;jbe	short read_bs_1
 13712                                  		
 13713 00002004 8B4604                  		mov	ax,[rbs_cylinder] ; Cylinder (0 to 1023)
 13714 00002007 88C5                    		mov	ch,al  ; cylinder (low 8 bits)
 13715 00002009 3DFF00                  		cmp	ax,255
 13716 0000200C 7608                    		jbe	short read_bs_1
 13717                                  		
 13718 0000200E D1E8                    		shr	ax,1
 13719 00002010 D1E8                    		shr	ax,1
 13720 00002012 24C0                    		and	al,0C0h		 ; bits 8 and 9 of cylinder
 13721                                  		;or	[regs_x_cx],al	 ; -->
 13722 00002014 08C1                    		or	cl,al		 ; bits 6 and 7 of sector
 13723                                  read_bs_1:
 13724                                  		;mov	al,[rbs_cylinder]
 13725                                  		;mov	[regs_x_cx+1],al
 13726                                  		
 13727                                  		;mov	ax,[rbs_buffer]
 13728                                  		;mov	[regs_x_bx],ax
 13729                                  		;mov	ax,[rbs_segment]
 13730                                  		;mov	[segregs_es],ax
 13731                                  		
 13732                                  		;mov	ax,segregs ;segregs_es
 13733                                  		;push	ax
 13734                                  		;mov	ax,regs	   ; regs_x_ax
 13735                                  		;push	ax
 13736                                  		;push	ax
 13737                                  		;call	DiskIo
 13738                                  		;add	sp,6
 13739                                  		;mov	al,[regs_x_cflag]
 13740                                  		;and	al,1
 13741                                  		;cmp	al,1
 13742                                  		;je	short read_bs_2
 13743                                  		;mov	al,1
 13744                                  		;jmp	short read_bs_3
 13745                                  
 13746 00002016 B80102                  		mov	ax,0201h	; Read 1 sector (CHS read)
 13747 00002019 CD13                    		int	13h
 13748 0000201B 7204                    		jc	short read_bs_2
 13749                                  
 13750 0000201D B001                    		mov	al,1 ; TRUE
 13751 0000201F EB0D                    		jmp	short read_bs_3
 13752                                  read_bs_2:
 13753                                  		; 11/12/2018
 13754                                  		;mov	bl,[rbs_disk]
 13755                                  		;sub	bh,bh
 13756 00002021 8B5E06                  		mov	bx,[rbs_disk]
 13757                                  
 13758 00002024 88BF[42A1]              		mov	[good_disk+bx],bh ; 0
 13759                                  
 13760                                  		;mov	ax,79
 13761                                  		;push	ax	 ; Bottom Rigth Column (79)  
 13762                                  		;mov	ax,24
 13763                                  		;push	ax	 ; Bottom Row (24)
 13764                                  		;sub	ax,ax ; 0
 13765                                  		;push	ax	 ; Top Left Column (0)	
 13766                                  		;push	ax	 ; Top Row (0)
 13767                                  		;
 13768                                  		;call	clear_screen
 13769                                  
 13770                                  		; Clear screen (clear whole video page)
 13771 00002028 E833F4                  		call	CLS
 13772                                  
 13773 0000202B 28C0                    		sub	al,al ; FALSE
 13774 0000202D F9                      		stc	; cf = 1  (error!)
 13775                                  read_bs_3:
 13776                                  		;mov	sp,bp ; 11/12/2018
 13777 0000202E 5D                      		pop	bp
 13778                                  		;retn
 13779 0000202F C20800                  		retn	8 ; 22/12/2018
 13780                                  
 13781                                  ; ---------------------------------------------------------------------------
 13782                                  
 13783                                  ;/*  */
 13784                                  ;void DiskIo(InRegs,OutRegs,SegRegs)
 13785                                  ;union   REGS    *InRegs;
 13786                                  ;union   REGS    *OutRegs;
 13787                                  ;struct  SREGS   *SegRegs;
 13788                                  ;
 13789                                  ;BEGIN
 13790                                  ;   int86x((int)DISK,InRegs,OutRegs,SegRegs);		/* AC000 */
 13791                                  ;   return;
 13792                                  ;
 13793                                  ;END
 13794                                  
 13795                                  ;DiskIo:
 13796                                  ;	%define _InRegs_  bp+4
 13797                                  ;	%define _OutRegs_ bp+6
 13798                                  ;	%define _SegRegs_ bp+8
 13799                                  ;
 13800                                  ;		push	bp
 13801                                  ;		mov	bp,sp
 13802                                  ;		push	word [_SegRegs_]
 13803                                  ;		push	word [_OutRegs_]
 13804                                  ;		push	word [_InRegs_]
 13805                                  ;		mov	ax,13h
 13806                                  ;		push	ax
 13807                                  ;		call	int86x
 13808                                  ;		mov	sp,bp
 13809                                  ;		pop	bp
 13810                                  ;		retn
 13811                                  
 13812                                  ; int86x (Microsoft C 6.0 runtime library, MSDOS 6.0, 1991)	
 13813                                  ; ============================================================================
 13814                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 26/11/2018)
 13815                                  
 13816                                  ;int86x:
 13817                                  ;
 13818                                  ;	%define call_int	bp-16 ; dword
 13819                                  ;	%define int_opcode	bp-12 ; word
 13820                                  ;	%define retf_opcode_1	bp-10 ; byte
 13821                                  ;	%define inc_sp_opcode	bp-9  ; byte	
 13822                                  ;	%define retf_opcode_2	bp-8  ; byte
 13823                                  ;
 13824                                  ;	%define _disk_int_	bp+4  ; word
 13825                                  ;	%define _in_regs_	bp+6  ; word
 13826                                  ;	%define _out_regs_	bp+8  ; word
 13827                                  ;	%define _seg_regs_	bp+10  ;word
 13828                                  ;
 13829                                  ;		push	bp
 13830                                  ;		mov	bp,sp
 13831                                  ;		push	si
 13832                                  ;		push	di
 13833                                  ;		push	ds
 13834                                  ;		sub	sp,10
 13835                                  ;		mov	byte [int_opcode],0CDh
 13836                                  ;		mov	ax,[_disk_int_]
 13837                                  ;		mov	byte ptr [int_opcode+1],al
 13838                                  ;		cmp	al,25h
 13839                                  ;		je	short int86x_25h_26h
 13840                                  ;		cmp	al,26h
 13841                                  ;		je	short int86x_25h_26h
 13842                                  ;		mov	byte [retf_opcode_1],0CBh ; RETF
 13843                                  ;		jmp	short int86x_dos_func
 13844                                  ;int86x_25h_26h:
 13845                                  ;		mov	byte [retf_opcode_2],0CBh ; RETF
 13846                                  ;		mov	byte [inc_sp_opcode],44h  ; INC SP
 13847                                  ;		mov	byte [retf_opcode_1],44h  ; INC SP
 13848                                  ;int86x_dos_func:
 13849                                  ;		mov	[call_int+2],ss
 13850                                  ;		lea	ax,[int_opcode]
 13851                                  ;		mov	[call_int],ax
 13852                                  ;		mov	di,[_in_regs_]
 13853                                  ;		mov	ax,[di]
 13854                                  ;		mov	bx,[di+2]
 13855                                  ;		mov	cx,[di+4]
 13856                                  ;		mov	dx,[di+6]
 13857                                  ;		mov	si,[di+8]
 13858                                  ;		push	word [di+10]
 13859                                  ;		mov	di,[_seg_regs_]
 13860                                  ;		mov	es,[di]
 13861                                  ;		mov	ds,[di+6]
 13862                                  ;		pop	di
 13863                                  ;		push	bp
 13864                                  ;		call	far [call_int]
 13865                                  ;		pop	bp
 13866                                  ;		cld
 13867                                  ;		push	di
 13868                                  ;		push	ds
 13869                                  ;		push	ss
 13870                                  ;		pop	ds
 13871                                  ;		mov	di,[_seg_regs_]
 13872                                  ;		mov	[di],es
 13873                                  ;		pop	word [di+6]
 13874                                  ;		mov	di,[_out_regs_]
 13875                                  ;		mov	[di],ax
 13876                                  ;		mov	[di+2],bx
 13877                                  ;		mov	[di+4],cx
 13878                                  ;		mov	[di+6],dx
 13879                                  ;		mov	[di+8],si
 13880                                  ;		pop	word [di+10]
 13881                                  ;		jc	short int86x_dos_func_err
 13882                                  ;		xor	si,si
 13883                                  ;		jmp	short int86x_retn
 13884                                  ;int86x_dos_func_err:
 13885                                  ;		call	int86_err_conv
 13886                                  ;		mov	si,1
 13887                                  ;		mov	ax,[di]
 13888                                  ;int86x_retn:
 13889                                  ;		mov	[di+12],si
 13890                                  ;		add	sp,10
 13891                                  ;		pop	ds
 13892                                  ;		pop	di
 13893                                  ;		pop	si
 13894                                  ;		mov	sp,bp
 13895                                  ;		pop	bp
 13896                                  ;		retn
 13897                                  
 13898                                  ; ---------------------------------------------------------------------------
 13899                                  
 13900                                  ;int86_err_conv:
 13901                                  ;		xor	ah,ah
 13902                                  ;		call	error_conversion
 13903                                  ;		retn
 13904                                  
 13905                                  ; ---------------------------------------------------------------------------
 13906                                  
 13907                                  ;error_conversion:
 13908                                  ;		mov	[_doserrno],al
 13909                                  ;		or	ah,ah
 13910                                  ;		jnz	short errconv_5
 13911                                  ;		cmp	[_dosvermajor],3
 13912                                  ;		jb	short errconv_1
 13913                                  ;		cmp	al,22h
 13914                                  ;		jnb	short errconv_2
 13915                                  ;		cmp	al,20h
 13916                                  ;		jb	short errconv_1
 13917                                  ;		mov	al,5
 13918                                  ;		jmp	short errconv_3
 13919                                  ;errconv_1:
 13920                                  ;		cmp	al,13h
 13921                                  ;		jbe	short errconv_3
 13922                                  ;errconv_2:
 13923                                  ;		mov	al,13h
 13924                                  ;errconv_3:
 13925                                  ;		mov	bx,err_conv_tbl
 13926                                  ;		xlat
 13927                                  ;errconv_4:
 13928                                  ;		cbw
 13929                                  ;		mov	[errno],ax
 13930                                  ;		retn
 13931                                  ;errconv_5:
 13932                                  ;		mov	al,ah
 13933                                  ;		jmp	short errconv_4
 13934                                  
 13935                                  ; ----------------------------------------------------------------------------
 13936                                  ; vdisplay.c (FDISK, MSDOS 6.0, 1991)	
 13937                                  ; ----------------------------------------------------------------------------
 13938                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 27/11/2018)
 13939                                  
 13940                                  ;/******************************************************************************/
 13941                                  ;/*Routine name:  CHANGE_CURRENT_DRIVE                                         */
 13942                                  ;/******************************************************************************/
 13943                                  ;/*                                                                            */
 13944                                  ;/*Description:   This routine will change the current drive for FDISK         */
 13945                                  ;/*               to any valid drive (up to 7). It will also display a        */
 13946                                  ;/*               menu with disk information on all disks available for        */
 13947                                  ;/*               the system be FDISKed.                                       */
 13948                                  ;/*                                                                            */
 13949                                  ;/*Called Procedures:    Display                                               */
 13950                                  ;/*                      Find_part_free_space                                  */
 13951                                  ;/*                      Sort_Ext_Table                                        */
 13952                                  ;/*                      Get_Num_Input                                         */
 13953                                  ;/*                      Clear_Screen                                          */
 13954                                  ;/*                                                                            */
 13955                                  ;/*Change History: Created        1/06/89         DRM                          */
 13956                                  ;/*                                                                            */
 13957                                  ;/*Input:  None                                                                */
 13958                                  ;/*                                                                            */
 13959                                  ;/*Output: None                                                                */
 13960                                  ;/*                                                                            */
 13961                                  ;/******************************************************************************/
 13962                                  ;
 13963                                  ;void change_current_drive()                                         /* BN000 */
 13964                                  ;
 13965                                  ;BEGIN                                                               /* BN000 */
 13966                                  ;
 13967                                  ;    unsigned    i;                                                  /* BN000 */
 13968                                  ;/*C00 unsigned    j;    */                                          /* BN000 */
 13969                                  ;    unsigned    k;                                                  /* BN000 */
 13970                                  ;/*C32 char        drive_letter;         */                          /* BN000 */
 13971                                  ;/*C32 char        primary_drive_letter; */                          /* BN000 */
 13972                                  ;    char        drive_num;                                          /* BN000 */
 13973                                  ;    char        temp;                                               /* BN000 */
 13974                                  ;/*C11 char        temp1; */                                         /* BN000 */
 13975                                  ;    unsigned    temp1;                                                  /*C11*/
 13976                                  ;    unsigned    mbytes_free;                                            /*C11*/
 13977                                  ;    unsigned    percent_used;                                           /*C11*/
 13978                                  ;    unsigned    insert_offset;                                      /* BN000 */
 13979                                  ;    unsigned    input;                                              /* BN000 */
 13980                                  ;    char        max_input;                                          /* BN000 */
 13981                                  ;/*C00 char        blanks[9]; */                                     /* BN000 */
 13982                                  ;
 13983                                  ;    /* Initialize some variables */
 13984                                  ;    insert_offset = 0;                                              /* BN000 */
 13985                                  ;    drive_num = c(0);                                               /* BN000 */
 13986                                  ;/*C32  primary_drive_letter = c(SEA); */                            /* BN000 */
 13987                                  ;
 13988                                  ;   /* get the current drive letters */                                 /*C32*/
 13989                                  ;   get_letters();                                                      /*C32*/
 13990                                  ;
 13991                                  ;    /* Clear the whole screen for display */
 13992                                  ;    clear_screen(u(0),u(0),u(24),u(79));                            /* BN000 */
 13993                                  ;
 13994                                  ;    /* initialize all the inserts to blanks */
 13995                                  ;/*C19  memset(insert,c(' '),(31*15)); */                            /* BN000 */
 13996                                  ;    memset(insert,c(' '),(32*15));                                      /*C19*/
 13997                                  ;
 13998                                  ;    /* Save current disk */
 13999                                  ;    temp = cur_disk;                                                /* BN000 */
 14000                                  ;
 14001                                  ;    /* Display the heading */
 14002                                  ;    if (status_flag == FALSE)                                       /* BN000 */
 14003                                  ;        display(menu_47);                                           /* BN000 */
 14004                                  ;    else                                                            /* BN000 */
 14005                                  ;        display(menu_54);                                           /* BN000 */
 14006                                  ;
 14007                                  ;    /* Figure out which drive letter the extended partitions begin with  */
 14008                                  ;/*C32  drive_letter = (c(SEA) + primary_partition_count); */        /* BN000 */
 14009                                  ;
 14010                                  ;    /* Get the drive information in ascending order and put into array */
 14011                                  ;    for (i=u(0); i < u(number_of_drives); i++)                      /* BN000 */
 14012                                  ;
 14013                                  ;        BEGIN                                                       /* BN000 */
 14014                                  ;
 14015                                  ;        /* find freespace on current drive and display drive information */
 14016                                  ;        cur_disk = c(i);                                            /* BN000 */
 14017                                  ;/*C11   temp1 = find_part_free_space(PRIMARY); */                   /* BN000 */
 14018                                  ;        temp1 = part_table[cur_disk][0].mbytes_used +                   /*C11*/
 14019                                  ;                part_table[cur_disk][1].mbytes_used +                   /*C11*/
 14020                                  ;                part_table[cur_disk][2].mbytes_used +                   /*C11*/
 14021                                  ;                part_table[cur_disk][3].mbytes_used;                    /*C11*/
 14022                                  ;        if (temp1 < total_mbytes[cur_disk])                             /*C11*/
 14023                                  ;            mbytes_free = total_mbytes[cur_disk] - temp1;               /*C11*/
 14024                                  ;        else                                                            /*C11*/
 14025                                  ;            mbytes_free = u(0);                                         /*C11*/
 14026                                  ;        temp1 = part_table[cur_disk][0].percent_used +                  /*C11*/
 14027                                  ;                part_table[cur_disk][1].percent_used +                  /*C11*/
 14028                                  ;                part_table[cur_disk][2].percent_used +                  /*C11*/
 14029                                  ;                part_table[cur_disk][3].percent_used;                   /*C11*/
 14030                                  ;        if (temp1 < u(100))                                             /*C11*/
 14031                                  ;            percent_used = temp1;                                       /*C11*/
 14032                                  ;        else                                                            /*C11*/
 14033                                  ;            percent_used = u(100);                                      /*C11*/
 14034                                  ;        insert_offset += sprintf(&insert[insert_offset],"%1.0d%c%c%4.0d%4.0d%3.0d%%",
 14035                                  ;            (cur_disk + 1),
 14036                                  ;            ' ',
 14037                                  ;            ' ',
 14038                                  ;            total_mbytes[cur_disk],
 14039                                  ;/*C11       free_space[temp1].mbytes_unused,               */
 14040                                  ;/*C11       (u(100) - free_space[temp1].percent_unused));  */       /* BN000 */
 14041                                  ;            mbytes_free,                                                /*C11*/
 14042                                  ;            percent_used);                                              /*C11*/
 14043                                  ;        drive_num++;                                                /* BN000 */
 14044                                  ;
 14045                                  ;        /* Sort the partitions */
 14046                                  ;        sort_part_table(c(4));                                      /* BN000 */
 14047                                  ;        /* Now look at the partitions in order */
 14048                                  ;        for (k=u(0); k < u(4); k++)                                 /* BN000 */
 14049                                  ;            BEGIN                                                   /* BN000 */
 14050                                  ;            /* see if there is a primary partition */
 14051                                  ;            if( (part_table[cur_disk][sort[k]].sys_id == DOSNEW) ||
 14052                                  ;                (part_table[cur_disk][sort[k]].sys_id == DOS16) ||
 14053                                  ;                (part_table[cur_disk][sort[k]].sys_id == DOS12) )
 14054                                  ;                BEGIN                                               /* BN000 */
 14055                                  ;                insert_offset += sprintf(&insert[insert_offset],"%c%c%c%4.0d%8c",
 14056                                  ;                    ' ',
 14057                                  ;/*C32               c(primary_drive_letter),               */
 14058                                  ;/*C32               (drive_letter == c(' ') ) ? ' ' : ':', */
 14059                                  ;                    part_table[cur_disk][sort[k]].drive_letter,         /*C32*/
 14060                                  ;                    (part_table[cur_disk][sort[k]].drive_letter == c(' ') ) ? ' ' : ':',
 14061                                  ;                    part_table[cur_disk][sort[k]].mbytes_used,
 14062                                  ;                    ' ');                                           /* BN000 */
 14063                                  ;                    drive_num++;                                    /* BN000 */
 14064                                  ;/*C32               primary_drive_letter++; */                      /* BN000 */
 14065                                  ;                END                                                 /* BN000 */
 14066                                  ;            END                                                     /* BN000 */
 14067                                  ;
 14068                                  ;        /* loop thru the partitions, only print stuff if it is there */
 14069                                  ;
 14070                                  ;        /* Get the drives in order by location on disk */
 14071                                  ;        sort_ext_table(c(23));                                      /* BN000 */
 14072                                  ;
 14073                                  ;        for (k=u(0); k < u(23); k++)                                /* BN000 */
 14074                                  ;            BEGIN                                                   /* BN000 */
 14075                                  ;            /* if last drive letter was Z, print spaces */
 14076                                  ;/*C32       if ((drive_letter > c('Z')) ) */
 14077                                  ;/*C32            drive_letter = c(' ');   */                        /* BN000 */
 14078                                  ;            /* If it has a size, print it */
 14079                                  ;            if ( (ext_table[cur_disk][sort[k]].mbytes_used != u(0)) ||
 14080                                  ;                 (ext_table[cur_disk][sort[k]].percent_used != u(0)) ) /* BN000 */
 14081                                  ;
 14082                                  ;                BEGIN
 14083                                  ;                insert_offset += sprintf(&insert[insert_offset],"%c%c%c%4.0d%8c",
 14084                                  ;                    ' ',
 14085                                  ;/*C32               drive_letter, */
 14086                                  ;/*C32               (drive_letter == c(' ') ) ? ' ' : ':', */
 14087                                  ;                    ext_table[cur_disk][sort[k]].drive_letter,          /*C32*/
 14088                                  ;                    (ext_table[cur_disk][sort[k]].drive_letter == c(' ') ) ? ' ' : ':', /*C32*/
 14089                                  ;                    ext_table[cur_disk][sort[k]].mbytes_used,
 14090                                  ;                    ' ');                                           /* BN000 */
 14091                                  ;                    drive_num++;                                    /* BN000 */
 14092                                  ;/*C32               drive_letter++; */                              /* BN000 */
 14093                                  ;                END                                                 /* BN000 */
 14094                                  ;            END                                                     /* BN000 */
 14095                                  ;        END                                                         /* BN000 */
 14096                                  ;
 14097                                  ;    /* Display the column of drives */
 14098                                  ;    BEGIN                                                           /* BN000 */
 14099                                  ;
 14100                                  ;    if ( drive_num > 0 )                                            /* BN000 */
 14101                                  ;        BEGIN                                                       /* BN000 */
 14102                                  ;        pinsert = &insert[0];                                       /* BN000 */
 14103                                  ;        display(menu_48);                                           /* BN000 */
 14104                                  ;        END                                                         /* BN000 */
 14105                                  ;
 14106                                  ;    if ( drive_num > 8 )                                            /* BN000 */
 14107                                  ;        BEGIN                                                       /* BN000 */
 14108                                  ;        pinsert = &insert[8*15];                                    /* BN000 */
 14109                                  ;        display(menu_49);                                           /* BN000 */
 14110                                  ;        END                                                         /* BN000 */
 14111                                  ;
 14112                                  ;    if ( drive_num > 16 )                                           /* BN000 */
 14113                                  ;        BEGIN                                                       /* BN000 */
 14114                                  ;        pinsert = &insert[16*15];                                   /* BN000 */
 14115                                  ;        display(menu_50);                                           /* BN000 */
 14116                                  ;        END                                                         /* BN000 */
 14117                                  ;
 14118                                  ;    if ( drive_num > 24 )                                           /* BN000 */
 14119                                  ;        BEGIN                                                       /* BN000 */
 14120                                  ;        pinsert = &insert[24*15];                                   /* BN000 */
 14121                                  ;        display(menu_51);                                           /* BN000 */
 14122                                  ;        END                                                         /* BN000 */
 14123                                  ;    pinsert = &insert[0];                                           /* BN000 */
 14124                                  ;    END                                                             /* BN000 */
 14125                                  ;
 14126                                  ;   /* display Mbytes = line */
 14127                                  ;   display(menu_52);                                               /* BN000 */
 14128                                  ;
 14129                                  ;    /* reset current disk back to original */
 14130                                  ;    cur_disk = temp;                                                /* BN000 */
 14131                                  ;
 14132                                  ;    if (status_flag == FALSE)                                       /* BN000 */
 14133                                  ;        BEGIN
 14134                                  ;        /* Display prompt of which disk */
 14135                                  ;        sprintf(insert,"%1.0d%1.0d",number_of_drives,(cur_disk+1)); /* BN000 */
 14136                                  ;        display(menu_53);                                           /* BN000 */
 14137                                  ;
 14138                                  ;        /* ESC line at bottom of screen */
 14139                                  ;        display(menu_11);                                           /* BN000 */
 14140                                  ;
 14141                                  ;        max_input = c(number_of_drives);                            /* BN000 */
 14142                                  ;
 14143                                  ;        valid_input = (FLAG)FALSE;                                  /* BN000 */
 14144                                  ;
 14145                                  ;       /* Get the input from screen */
 14146                                  ;        while (!valid_input)                                        /* BN000 */
 14147                                  ;            BEGIN                                                   /* BN000 */
 14148                                  ;            input = get_num_input(c(cur_disk+1),max_input,input_row,input_col);
 14149                                  ;            clear_screen(u(21),u(0),u(23),u(79));                   /* BN000 */
 14150                                  ;
 14151                                  ;           /* set current disk to zero base */
 14152                                  ;           if (input != u(ESC)) cur_disk = c(input-'1');           /* BN000 */
 14153                                  ;            END                                                     /* BN000 */
 14154                                  ;
 14155                                  ;        /* clear the screen before going back to main menu */
 14156                                  ;        clear_screen(u(0),u(0),u(24),u(79));                        /* BN000 */
 14157                                  ;        END                                                         /* BN000 */
 14158                                  ;    return;                                                         /* BN000 */
 14159                                  ;END                                                                 /* BN000 */
 14160                                  
 14161 00002032 0000                    usp: dw 0
 14162                                  
 14163                                  change_current_drive:
 14164                                  				; 12/12/2018
 14165                                  	%define _k		bp-16 ; bp-20 ; unsigned int
 14166                                  	%define _insert_offset	bp-14 ; bp-18 ; unsigned int
 14167                                  	%define _i		bp-12 ; bp-16 ; unsigned int
 14168                                  	%define _drive_num	bp-10 ; bp-14 ; char
 14169                                  	%define _temp_		bp-8  ; bp-10 ; char
 14170                                  	%define _mbytes_free	bp-6  ; bp-8  ; unsigned int
 14171                                  	%define _max_input	bp-4  ; bp-6  ; unsigned int
 14172                                  	;%define _percent_used	bp-4  ;	bp-4  ; unsigned int
 14173                                  	%define _input_		bp-2  ; bp-2  ; unsigned int
 14174                                  
 14175 00002034 55                      		push	bp
 14176 00002035 89E5                    		mov	bp,sp
 14177                                  		;sub	sp,20
 14178 00002037 83EC10                  		sub	sp,16 ; 12/12/2018
 14179 0000203A 56                      		push	si
 14180                                  
 14181                                  		;/* Initialize some variables */
 14182                                  		;mov	word [_drive_num],0
 14183 0000203B 31C0                    		xor	ax,ax ; 0
 14184 0000203D 8946F6                  		mov	[_drive_num],ax ; 0		
 14185 00002040 8946F2                  		mov	[_insert_offset],ax ; 0
 14186                                  
 14187                                  		;/* get the current drive letters */ 
 14188 00002043 E89007                  		call	get_letters
 14189                                  		
 14190                                  		;/* Clear the whole screen for display */
 14191                                  		;mov	ax,79
 14192                                  		;push	ax
 14193                                  		;mov	ax,24
 14194                                  		;push	ax
 14195                                  		;sub	ax,ax ; 0
 14196                                  		;mov	[_insert_offset],ax
 14197                                  		;push	ax
 14198                                  		;push	ax
 14199                                  		;call	clear_screen
 14200                                  		;;add	sp,8
 14201                                  
 14202                                  		; Clear screen (clear whole video page)
 14203 00002046 E815F4                  		call	CLS
 14204                                  
 14205                                  		;/* initialize all the inserts to blanks */
 14206                                  		;memset(insert,c(' '),(32*15));            
 14207                                  
 14208                                  		;mov	ax,480
 14209                                  		;push	ax
 14210                                  		;mov	ax,' '
 14211                                  		;push	ax
 14212                                  		;mov	ax,insert
 14213                                  		;push	ax
 14214                                  		;call	memset
 14215                                  		;add	sp,6
 14216                                  
 14217                                  		; 01/12/2018
 14218                                  		; memset shortcut
 14219 00002049 B020                    		mov	al,' '
 14220 0000204B B9E001                  		mov	cx,480
 14221 0000204E BF[E6CC]                		mov	di,insert
 14222                                  		;push	ds
 14223                                  		;pop	es
 14224 00002051 F3AA                    		rep	stosb
 14225                                  
 14226                                  		;/* Save current disk */
 14227 00002053 A0[D4CB]                		mov	al,[cur_disk]
 14228 00002056 8846F8                  		mov	[_temp_],al
 14229                                  
 14230                                  		;/* Display the heading */
 14231                                  		;if (status_flag == FALSE)
 14232                                  		;   display(menu_47);
 14233                                  		;else
 14234                                  		;   display(menu_54);
 14235                                  
 14236 00002059 803E[D4C3]00            		cmp	byte [status_flag],0
 14237 0000205E 7507                    		jne	short ccd_1
 14238                                  		;push	word [menu_47_segment]
 14239 00002060 1E                      		push	ds
 14240 00002061 FF36[499E]              		push	word [menu_47_offset]
 14241 00002065 EB05                    		jmp	short ccd_2
 14242                                  ccd_1:
 14243                                  		;push	word [menu_54_segment]
 14244 00002067 1E                      		push	ds
 14245 00002068 FF36[579E]              		push	word [menu_54_offset]
 14246                                  ccd_2:
 14247 0000206C E8ABF5                  		call	display
 14248                                  		;pop	bx
 14249                                  		;pop	bx
 14250                                  
 14251                                  	;/* Get the drive information in ascending order and put into array */
 14252                                  	;for (i=u(0); i < u(number_of_drives); i++)  
 14253                                  
 14254 0000206F C746F40000              		mov	word [_i],0
 14255 00002074 E92901                  		jmp	ccd_20
 14256                                  ccd_3:
 14257 00002077 C746FA0000              		mov	word [_mbytes_free],0
 14258                                  ccd_4:
 14259                                  	;temp1 = part_table[cur_disk][0].percent_used +
 14260                                  	;        part_table[cur_disk][1].percent_used +
 14261                                  	;        part_table[cur_disk][2].percent_used +
 14262                                  	;        part_table[cur_disk][3].percent_used;
 14263                                  	;if (temp1 < u(100))
 14264                                  	;   percent_used = temp1;
 14265                                  	;else
 14266                                  	;   percent_used = u(100);
 14267                                  
 14268                                  		;mov	al,[cur_disk]
 14269                                  		;cbw
 14270                                  		;;imul	cx
 14271                                  		;mul	cx ; 184, 4*46
 14272                                  		;mov	bx,ax
 14273                                  		;mov	ax,[part_table_percent_used+bx]
 14274                                  		;add	ax,[pt_part4_percent_used+bx]
 14275                                  		;add	ax,[pt_part3_percent_used+bx]
 14276                                  		;add	ax,[pt_part2_percent_used+bx]
 14277                                  
 14278                                  		; 27/11/2018 (si from ccd_20)
 14279 0000207C 8B84[28C4]              		mov	ax,[part_table_percent_used+si] ; +***
 14280 00002080 0384[B2C4]              		add	ax,[pt_part4_percent_used+si]
 14281 00002084 0384[84C4]              		add	ax,[pt_part3_percent_used+si]
 14282 00002088 0384[56C4]              		add	ax,[pt_part2_percent_used+si]
 14283                                  		
 14284                                  		;cmp	ax,100
 14285                                  		;jnb	short ccd_5
 14286                                  		;mov	[_percent_used],ax
 14287                                  		;jmp	short ccd_6
 14288                                  		
 14289                                  		; 09/12/2018
 14290 0000208C 83F864                  		cmp	ax,100
 14291 0000208F 7603                    		jna	short ccd_5
 14292 00002091 B86400                  		mov	ax,100
 14293                                  ccd_5:
 14294                                  		;mov	word [_percent_used],100
 14295                                  		; 12/12/2018
 14296                                  		;mov	[_percent_used],ax ; 09/12/2018	
 14297                                  ccd_6:
 14298                                  	;insert_offset += sprintf(&insert[insert_offset],"%1.0d%c%c%4.0d%4.0d%3.0d%%",
 14299                                  	;    (cur_disk + 1),' ',' ',total_mbytes[cur_disk],mbytes_free,percent_used);                                              /*C11*/
 14300                                  	;drive_num++;
 14301                                  
 14302                                  		;push	word [_percent_used]
 14303 00002094 50                      		push	ax ; 12/12/2018 
 14304 00002095 FF76FA                  		push	word [_mbytes_free]
 14305 00002098 A0[D4CB]                		mov	al,[cur_disk]
 14306 0000209B 98                      		cbw
 14307                                  		;mov	bx,ax
 14308                                  		;shl	bx,1
 14309                                  		; 27/11/2018 (bx from ccd_21)
 14310 0000209C FFB7[C8A0]              		push	word [total_mbytes+bx] ; ++***
 14311                                  		;mov	cx,' '
 14312 000020A0 B120                    		mov	cl,' ' ; 01/12/2018
 14313 000020A2 51                      		push	cx
 14314 000020A3 51                      		push	cx
 14315 000020A4 40                      		inc	ax
 14316 000020A5 50                      		push	ax
 14317 000020A6 B8[0170]                		mov	ax,cd_pt_row_format ; "%1.0d%c%c%4.1d%4.1d%3.1d%%"
 14318 000020A9 50                      		push	ax
 14319 000020AA 8B46F2                  		mov	ax,[_insert_offset]
 14320 000020AD 05[E6CC]                		add	ax,insert
 14321 000020B0 50                      		push	ax
 14322 000020B1 E80702                  		call	sprintf
 14323 000020B4 83C410                  		add	sp,16
 14324 000020B7 0146F2                  		add	[_insert_offset],ax
 14325 000020BA FE46F6                  		inc	byte [_drive_num]
 14326                                  
 14327                                  		;/* Sort the partitions */
 14328                                  		;sort_part_table(c(4));
 14329                                  		;mov	al,4
 14330                                  		;push	ax
 14331 000020BD B104                    		mov	cl,4 ; 12/12/2018
 14332 000020BF E8D908                  		call	sort_part_table
 14333                                  		;pop	bx
 14334                                  
 14335                                  		;/* Now look at the partitions in order */
 14336                                  		;for (k=u(0); k < u(4); k++)
 14337                                  
 14338 000020C2 C746F00000              		mov	word [_k],0
 14339 000020C7 EB32                    		jmp	short ccd_10
 14340                                  ccd_7:
 14341                                  		; 28/11/2018
 14342                                  		; al = ' ', ah = 0
 14343 000020C9 80BF[3FC4]20            		cmp	byte [part_table_drive_letter+bx],' '
 14344 000020CE 7402                    		je	short ccd_8
 14345                                  		;mov	ax,':'
 14346 000020D0 B03A                    		mov	al,':'
 14347                                  ccd_8:
 14348 000020D2 50                      		push	ax
 14349 000020D3 8A87[3FC4]              		mov	al,[part_table_drive_letter+bx]
 14350                                  		;cbw
 14351 000020D7 50                      		push	ax
 14352                                  		;mov	ax,' '
 14353 000020D8 B020                    		mov	al,' '
 14354 000020DA 50                      		push	ax
 14355 000020DB B8[1C70]                		mov	ax,drv_mb_row_format ; "%c%c%c%4.1d%8c"
 14356 000020DE 50                      		push	ax
 14357 000020DF 8B46F2                  		mov	ax,[_insert_offset]
 14358 000020E2 05[E6CC]                		add	ax,insert
 14359 000020E5 50                      		push	ax
 14360 000020E6 E8D201                  		call	sprintf
 14361 000020E9 83C40E                  		add	sp,14
 14362 000020EC 0146F2                  		add	[_insert_offset],ax
 14363                                  
 14364 000020EF FE46F6                  		inc	byte [_drive_num]
 14365                                  ccd_9:
 14366 000020F2 FE46F0                  		inc	byte [_k]
 14367                                  ;ccd_10:
 14368 000020F5 807EF004                		cmp	byte [_k],4
 14369 000020F9 7336                    		jnb	short ccd_13
 14370                                  ccd_10: 			; 09/12/2018
 14371                                  
 14372                                  		;/* see if there is a primary partition */
 14373                                  		;if( (part_table[cur_disk][sort[k]].sys_id == DOSNEW) ||
 14374                                  		;    (part_table[cur_disk][sort[k]].sys_id == DOS16) ||
 14375                                  		;    (part_table[cur_disk][sort[k]].sys_id == DOS12) )
 14376                                  
 14377                                  		; 28/11/2018
 14378                                  
 14379                                  		;mov	al,[cur_disk]
 14380                                  		;cbw
 14381                                  		;shl	ax,1
 14382                                  		;shl	ax,1
 14383                                  		;mov	cx,ax
 14384 000020FB 8A0E[D4CB]              		mov	cl,[cur_disk]
 14385                                  		;xor	ch,ch
 14386                                  		; 01/12/2018
 14387 000020FF D0E1                    		shl	cl,1
 14388 00002101 D0E1                    		shl	cl,1
 14389                                  
 14390 00002103 8B5EF0                  		mov	bx,[_k]
 14391 00002106 8A87[E2C3]              		mov	al,[sort+bx] ; 07/12/2018
 14392                                  
 14393                                  		;cbw
 14394                                  		;add	ax,cx
 14395 0000210A 00C8                    		add	al,cl
 14396                                  		;mov	cx,46
 14397                                  		;imul	cx
 14398 0000210C B12E                    		mov	cl,46
 14399 0000210E F6E1                    		mul	cl
 14400                                  
 14401 00002110 89C3                    		mov	bx,ax ;+++**
 14402                                  
 14403 00002112 80BF[17C4]06            		cmp	byte [part_table_sys_id+bx],DOSNEW ; 6
 14404 00002117 740E                    		je	short ccd_11
 14405 00002119 80BF[17C4]04            		cmp	byte [part_table_sys_id+bx],DOS16  ; 4
 14406 0000211E 7407                    		je	short ccd_11
 14407 00002120 80BF[17C4]01            		cmp	byte [part_table_sys_id+bx],DOS12  ; 1
 14408 00002125 75CB                    		jne	short ccd_9
 14409                                  ccd_11:
 14410                                  	;insert_offset += sprintf(&insert[insert_offset],"%c%c%c%4.0d%8c",
 14411                                  	;	' ',part_table[cur_disk][sort[k]].drive_letter,
 14412                                  	;	(part_table[cur_disk][sort[k]].drive_letter == c(' ') ) ? ' ' : ':',
 14413                                  	;	part_table[cur_disk][sort[k]].mbytes_used,' '); 
 14414                                  	; drive_num++;
 14415                                  
 14416 00002127 B82000                  		mov	ax,' '
 14417 0000212A 50                      		push	ax
 14418                                  
 14419                                  		; 28/11/2018
 14420                                  		;mov	al,[cur_disk]
 14421                                  		;cbw
 14422                                  		;shl	ax,1
 14423                                  		;shl	ax,1
 14424                                  		;mov	bx,[_k]
 14425                                  		;mov	cx,ax
 14426                                  		;mov	al,[sort+bx] ; 07/12/2018
 14427                                  		;cbw
 14428                                  		;add	ax,cx
 14429                                  		;mov	cx,46
 14430                                  		;imul	cx
 14431                                  		;mov	bx,ax ; +++**
 14432                                  		
 14433 0000212B FFB7[26C4]              		push	word [part_table_mbytes_used+bx]
 14434                                  		;cmp	byte [part_table_drive_letter+bx],' '
 14435                                  		;;je	short ccd_12
 14436                                  		;jmp	short ccd_7
 14437                                  		;je	short ccd_8
 14438 0000212F EB98                    		jmp	short ccd_7
 14439                                  ;ccd_12:
 14440                                  		;mov	ax,' ' ; 28/11/2018
 14441                                  		;jmp	short ccd_8
 14442                                  ccd_13:
 14443                                  		;/* Get the drives in order by location on disk */
 14444                                  		;sort_ext_table(c(23));   
 14445                                  
 14446                                  		;mov	al,23
 14447                                  		;push	ax
 14448 00002131 B117                    		mov	cl,23 ; 12/12/2018
 14449 00002133 E8CF08                  		call	sort_ext_table
 14450                                  		;pop	bx
 14451                                  
 14452                                  		;for (k=u(0); k < u(23); k++)
 14453                                  
 14454 00002136 C646F000                		mov	byte [_k],0
 14455 0000213A EB32                    		jmp	short ccd_17
 14456                                  ccd_14:
 14457                                  		; 01/12/2018
 14458                                  		;mov	ax,':'
 14459                                  
 14460                                  		; al = ' ', ah = 0
 14461 0000213C 80BF[77A1]20            		cmp	byte [ext_table_drive_letter+bx],' '
 14462 00002141 7402                    		je	short ccd_15
 14463                                  		;mov	ax,':'
 14464 00002143 B03A                    		mov	al,':'
 14465                                  ccd_15:
 14466 00002145 50                      		push	ax
 14467 00002146 8A87[77A1]              		mov	al,[ext_table_drive_letter+bx]
 14468                                  		;cbw
 14469 0000214A 50                      		push	ax
 14470                                  		;mov	ax,' '
 14471 0000214B B020                    		mov	al,' '
 14472 0000214D 50                      		push	ax
 14473 0000214E B8[2B70]                		mov	ax,cdrv_mb_format ; "%c%c%c%4.1d%8c"
 14474 00002151 50                      		push	ax
 14475 00002152 8B46F2                  		mov	ax,[_insert_offset]
 14476 00002155 05[E6CC]                		add	ax,insert
 14477 00002158 50                      		push	ax
 14478 00002159 E85F01                  		call	sprintf
 14479 0000215C 83C40E                  		add	sp,14
 14480 0000215F 0146F2                  		add	[_insert_offset],ax
 14481                                  
 14482 00002162 FE46F6                  		inc	byte [_drive_num]
 14483                                  ccd_16:
 14484 00002165 FE46F0                  		inc	byte [_k]
 14485                                  ;ccd_17:
 14486 00002168 807EF017                		cmp	byte [_k],23
 14487 0000216C 732F                    		jnb	short ccd_19
 14488                                  ccd_17: 		; 13/12/2018
 14489                                  		;/* If it has a size, print it */
 14490                                  		;if ( (ext_table[cur_disk][sort[k]].mbytes_used != u(0)) ||
 14491                                  		;     (ext_table[cur_disk][sort[k]].percent_used != u(0)) )
 14492                                  
 14493 0000216E B018                    		mov	al,24
 14494                                  		;imul	byte [cur_disk]
 14495 00002170 F626[D4CB]              		mul	byte [cur_disk] ; 0 to 7
 14496 00002174 8B5EF0                  		mov	bx,[_k]
 14497 00002177 89C1                    		mov	cx,ax ; ah = 0 (ax<=168)
 14498 00002179 8A87[E2C3]              		mov	al,[sort+bx] ; 07/12/2018
 14499                                  		;cbw
 14500                                  		;add	ax,cx
 14501 0000217D 00C8                    		add	al,cl
 14502                                  		;mov	cx,46
 14503                                  		;imul	cx
 14504 0000217F B12E                    		mov	cl,46
 14505 00002181 F6E1                    		mul	cl
 14506 00002183 89C3                    		mov	bx,ax ; +++**+
 14507 00002185 83BF[5EA1]00            		cmp	word [ext_table_mbytes_used+bx],0
 14508 0000218A 7507                    		jne	short ccd_18
 14509 0000218C 83BF[60A1]00            		cmp	word [ext_table_percent_used+bx],0
 14510 00002191 74D2                    		je	short ccd_16
 14511                                  ccd_18:
 14512                                  	;insert_offset += sprintf(&insert[insert_offset],"%c%c%c%4.0d%8c",' ',
 14513                                  	;   ext_table[cur_disk][sort[k]].drive_letter,
 14514                                  	;   (ext_table[cur_disk][sort[k]].drive_letter == c(' ') ) ? ' ' : ':',
 14515                                  	;   ext_table[cur_disk][sort[k]].mbytes_used,' ');
 14516                                  	;drive_num++;
 14517                                  
 14518 00002193 B82000                  		mov	ax,' '
 14519 00002196 50                      		push	ax
 14520                                  		
 14521                                  		; 01/12/2018
 14522                                  
 14523                                  		;mov	al,24
 14524                                  		;;imul	byte [cur_disk]
 14525                                  		;mul	byte [cur_disk]
 14526                                  		;mov	bx,[_k]
 14527                                  		;mov	cx,ax
 14528                                  		;mov	al,[sort+bx] ; 07/12/2018
 14529                                  		;cbw
 14530                                  		;add	ax,cx
 14531                                  		;mov	cx,46
 14532                                  		;;imul	cx
 14533                                  		;mul	cx
 14534                                  		;mov	bx,ax ; +++**+
 14535                                  		
 14536 00002197 FFB7[5EA1]              		push	word [ext_table_mbytes_used+bx]
 14537                                  		;cmp	byte [ext_table_drive_letter+bx],' '
 14538                                  		;jne	short ccd_14
 14539                                  		;mov	ax,' '
 14540                                  		;jmp	short ccd_15
 14541 0000219B EB9F                    		jmp	short ccd_14 ; 01/12/2018
 14542                                  ccd_19:
 14543 0000219D FE46F4                  		inc	byte [_i]
 14544                                  ccd_20:
 14545                                  	;/* find freespace on current drive and display drive information */
 14546                                  		;cur_disk = c(i);
 14547                                  		;mov	al,[number_of_drives]
 14548                                  		;sub	ah,ah
 14549                                  		;;cmp	ax,[_i]
 14550                                  		;cmp	al,[_i] ; 01/12/2018
 14551                                  		;jbe	short ccd_22
 14552                                  		;mov	al,[_i]
 14553                                  		;mov	[cur_disk],al
 14554                                  
 14555                                  		; 10/12/2018
 14556                                  		;mov	al,[_i]
 14557                                  		;sub	ah,ah
 14558 000021A0 8B46F4                  		mov	ax,[_i] ; 12/12/2018
 14559 000021A3 3A06[D5C3]              		cmp	al,[number_of_drives]
 14560 000021A7 7333                    		jnb	short ccd_22
 14561                                  
 14562 000021A9 A2[D4CB]                		mov	[cur_disk],al	
 14563                                  
 14564                                  	;temp1 = part_table[cur_disk][0].mbytes_used +
 14565                                  	;        part_table[cur_disk][1].mbytes_used +
 14566                                  	;        part_table[cur_disk][2].mbytes_used +
 14567                                  	;        part_table[cur_disk][3].mbytes_used;
 14568                                  
 14569                                  	;if (temp1 < total_mbytes[cur_disk])
 14570                                  	;   mbytes_free = total_mbytes[cur_disk] - temp1
 14571                                  	;else
 14572                                  	;   mbytes_free = u(0);
 14573                                  
 14574                                  		;cbw
 14575 000021AC B9B800                  		mov	cx,184 ; 4*46
 14576 000021AF 89C3                    		mov	bx,ax  ; [cur_disk], 0 to 7
 14577                                  		;imul	cx
 14578                                  		;mul	cx
 14579 000021B1 F6E1                    		mul	cl
 14580 000021B3 89C6                    		mov	si,ax
 14581 000021B5 8B84[26C4]              		mov	ax,[part_table_mbytes_used+si] ; +***
 14582 000021B9 0384[B0C4]              		add	ax,[pt_part4_mbytes_used+si]
 14583 000021BD 0384[82C4]              		add	ax,[pt_part3_mbytes_used+si]
 14584 000021C1 0384[54C4]              		add	ax,[pt_part2_mbytes_used+si]
 14585 000021C5 D1E3                    		shl	bx,1
 14586 000021C7 3B87[C8A0]              		cmp	ax,[total_mbytes+bx]
 14587 000021CB 7203                    		jb	short ccd_21
 14588 000021CD E9A7FE                  		jmp	ccd_3
 14589                                  ccd_21:
 14590 000021D0 2B87[C8A0]              		sub	ax,[total_mbytes+bx] ; ++***
 14591 000021D4 F7D8                    		neg	ax
 14592 000021D6 8946FA                  		mov	[_mbytes_free],ax
 14593 000021D9 E9A0FE                  		jmp	ccd_4
 14594                                  ccd_22:
 14595                                  		;/* Display the column of drives */
 14596                                  	
 14597                                  		;if ( drive_num > 0 )
 14598                                  		;     BEGIN
 14599                                  		;     pinsert = &insert[0];
 14600                                  		;     display(menu_48);
 14601                                  		;     END
 14602                                  
 14603 000021DC 807EF600                		cmp	byte [_drive_num],0
 14604                                  		;jle	short ccd_23
 14605 000021E0 764A                    		jna	short ccd_26 ; 01/12/2018
 14606                                  		
 14607 000021E2 C706[8A70][E6CC]        		mov	word [pinsert],insert
 14608                                  
 14609                                  		;push	word [menu_48_segment]
 14610 000021E8 1E                      		push	ds
 14611 000021E9 FF36[4B9E]              		push	word [menu_48_offset]
 14612 000021ED E82AF4                  		call	display
 14613                                  		;pop	bx
 14614                                  		;pop	bx
 14615                                  ccd_23:
 14616                                  		;if ( drive_num > 8 )
 14617                                  		;     BEGIN
 14618                                  		;     pinsert = &insert[8*15];
 14619                                  		;     display(menu_49);
 14620                                  		;     END             
 14621                                  
 14622 000021F0 807EF608                		cmp	byte [_drive_num],8
 14623                                  		;jle	short ccd_24
 14624 000021F4 7636                    		jna	short ccd_26 ; 01/12/2018
 14625                                  
 14626 000021F6 C706[8A70][5ECD]        		mov	word [pinsert],insert+120
 14627                                  
 14628                                  		;push	word [menu_49_segment]
 14629 000021FC 1E                      		push	ds
 14630 000021FD FF36[4D9E]              		push	word [menu_49_offset]
 14631 00002201 E816F4                  		call	display
 14632                                  		;pop	bx
 14633                                  		;pop	bx
 14634                                  ccd_24:
 14635                                  		;if ( drive_num > 16 )
 14636                                  		;     BEGIN
 14637                                  		;     pinsert = &insert[16*15];
 14638                                  		;     display(menu_50);
 14639                                  		;     END
 14640                                  
 14641 00002204 807EF610                		cmp	byte [_drive_num],16
 14642                                  		;jle	short ccd_25
 14643 00002208 7622                    		jna	short ccd_26 ; 01/12/2018
 14644                                  
 14645 0000220A C706[8A70][D6CD]        		mov	word [pinsert],insert+240
 14646                                  
 14647                                  		;push	word [menu_50_segment]
 14648 00002210 1E                      		push	ds
 14649 00002211 FF36[4F9E]              		push	word [menu_50_offset]
 14650 00002215 E802F4                  		call	display
 14651                                  		;pop	bx
 14652                                  		;pop	bx
 14653                                  ccd_25:
 14654                                  		;if ( drive_num > 24 )
 14655                                  		;     BEGIN
 14656                                  		;     pinsert = &insert[24*15];
 14657                                  		;     display(menu_51);
 14658                                  		;     END
 14659                                  		;pinsert = &insert[0];  
 14660                                  
 14661 00002218 807EF618                		cmp	byte [_drive_num],24
 14662                                  		;jle	short ccd_26
 14663 0000221C 760E                    		jna	short ccd_26 ; 01/12/2018
 14664                                  
 14665 0000221E C706[8A70][4ECE]        		mov	word [pinsert],insert+360
 14666                                  
 14667                                  		;push	word [menu_51_segment]
 14668 00002224 1E                      		push	ds
 14669 00002225 FF36[519E]              		push	word [menu_51_offset]
 14670 00002229 E8EEF3                  		call	display
 14671                                  		;pop	bx
 14672                                  		;pop	bx
 14673                                  ccd_26:
 14674 0000222C C706[8A70][E6CC]        		mov	word [pinsert],insert
 14675                                  
 14676                                  		;/* display Mbytes = line */
 14677                                  		;display(menu_52);
 14678                                  		;push	word [menu_52_segment]
 14679 00002232 1E                      		push	ds
 14680 00002233 FF36[539E]              		push	word [menu_52_offset]
 14681 00002237 E8E0F3                  		call	display
 14682                                  		;pop	bx
 14683                                  		;pop	bx
 14684                                  
 14685                                  		;/* reset current disk back to original */
 14686                                  		;cur_disk = temp;  
 14687 0000223A 8A46F8                  		mov	al,[_temp_]
 14688 0000223D A2[D4CB]                		mov	[cur_disk],al
 14689                                  
 14690                                  		;if (status_flag == FALSE)  
 14691 00002240 803E[D4C3]00            		cmp	byte [status_flag],0
 14692 00002245 756F                    		jne	short ccd_30 ; 09/12/2018
 14693                                  ccd_27:
 14694                                  		;/* Display prompt of which disk */
 14695                                  		;sprintf(insert,"%1.0d%1.0d",number_of_drives,(cur_disk+1));
 14696                                  		;display(menu_53); 
 14697                                  
 14698                                  		;cbw
 14699                                  		;inc	ax
 14700 00002247 28E4                    		sub	ah,ah
 14701 00002249 FEC0                    		inc	al  ; [cur_disk] + 1
 14702 0000224B 50                      		push	ax
 14703 0000224C A0[D5C3]                		mov	al,[number_of_drives]
 14704                                  		;sub	ah,ah
 14705 0000224F 50                      		push	ax
 14706 00002250 B8[3A70]                		mov	ax,cdrive_format ; "%1.0d%1.0d"
 14707 00002253 50                      		push	ax
 14708 00002254 B8[E6CC]                		mov	ax,insert
 14709 00002257 50                      		push	ax
 14710 00002258 E86000                  		call	sprintf
 14711 0000225B 83C408                  		add	sp,8
 14712                                  
 14713                                  		;push	word [menu_53_segment]
 14714 0000225E 1E                      		push	ds
 14715 0000225F FF36[559E]              		push	word [menu_53_offset]
 14716 00002263 E8B4F3                  		call	display
 14717                                  		;pop	bx
 14718                                  		;pop	bx
 14719                                  
 14720                                  		;/* ESC line at bottom of screen */
 14721                                  		;display(menu_11);                            
 14722                                  		
 14723                                  		;;push	word [menu_11_segment]
 14724                                  		;push	ds
 14725                                  		;push	word [menu_11_offset]
 14726                                  		;call	display
 14727                                  		;;pop	bx
 14728                                  		;;pop	bx
 14729                                  
 14730 00002266 E8FB0B                  		call	display_menu_11 ; 31/12/2018
 14731                                  
 14732                                  		;max_input = c(number_of_drives);
 14733 00002269 A0[D5C3]                		mov	al,[number_of_drives]
 14734 0000226C 8846FC                  		mov	[_max_input],al
 14735                                  		;valid_input = (FLAG)FALSE;
 14736 0000226F C606[DECB]00            		mov	byte [valid_input],0
 14737                                  ccd_28:
 14738                                  		;/* Get the input from screen */
 14739                                  	;input = get_num_input(c(cur_disk+1),max_input,input_row,input_col);
 14740                                  
 14741 00002274 FF36[9CA0]              		push	word [input_col]
 14742 00002278 FF36[3EA1]              		push	word [input_row]
 14743 0000227C 8A46FC                  		mov	al,[_max_input]
 14744 0000227F 50                      		push	ax
 14745 00002280 A0[D4CB]                		mov	al,[cur_disk]
 14746 00002283 FEC0                    		inc	al
 14747 00002285 50                      		push	ax
 14748 00002286 E8E107                  		call	get_num_input
 14749                                  		;add	sp,8 ; 15/12/2018
 14750                                  		;cbw	 ; *-* 
 14751 00002289 8946FE                  		mov	[_input_],ax ;*-*
 14752                                  
 14753                                  		;clear_screen(u(21),u(0),u(23),u(79));
 14754                                  
 14755 0000228C B84F00                  		mov	ax,79	; Right Column = 79
 14756 0000228F 50                      		push	ax	
 14757 00002290 B81700                  		mov	ax,23	; Bottom Row = 23
 14758 00002293 50                      		push	ax	
 14759 00002294 29C0                    		sub	ax,ax	; Left Column = 0
 14760 00002296 50                      		push	ax	
 14761 00002297 B81500                  		mov	ax,21	; Top Row = 21
 14762 0000229A 50                      		push	ax
 14763 0000229B E8F8F1                  		call	clear_screen  ; (clear_screen_down, clear screen rows)
 14764                                  		;add	sp,8
 14765                                  
 14766                                  		;/* set current disk to zero base */
 14767                                  		;if (input != u(ESC)) cur_disk = c(input-'1');
 14768                                  
 14769                                  		;cmp	word [_input_],1Bh ; *-*
 14770 0000229E 807EFE1B                		cmp	byte [_input_],1Bh  ; ESC
 14771 000022A2 7408                    		je	short ccd_29
 14772 000022A4 8A46FE                  		mov	al,[_input_]
 14773 000022A7 2C31                    		sub	al,'1'
 14774 000022A9 A2[D4CB]                		mov	[cur_disk],al
 14775                                  ccd_29:
 14776                                  		;/* Get the input from screen */
 14777                                  		;while (!valid_input)
 14778                                  
 14779 000022AC 803E[DECB]00            		cmp	byte [valid_input],0
 14780 000022B1 74C1                    		je	short ccd_28
 14781                                  
 14782                                  		;/* clear the screen before going back to main menu */
 14783                                  		;clear_screen(u(0),u(0),u(24),u(79)); 
 14784                                  
 14785                                  		;mov	ax,79
 14786                                  		;push	ax
 14787                                  		;mov	ax,24
 14788                                  		;push	ax
 14789                                  		;sub	ax,ax
 14790                                  		;push	ax
 14791                                  		;push	ax
 14792                                  		;call	clear_screen
 14793                                  		;add	sp,8
 14794                                  
 14795                                  		; Clear screen (clear whole video page)
 14796 000022B3 E8A8F1                  		call	CLS
 14797                                  ccd_30:
 14798                                  
 14799                                  ;;temporary - 13/12/2018
 14800                                  ;push cs
 14801                                  ;pop ds
 14802                                  ;mov si,insert
 14803                                  ;mov ah,4Eh
 14804                                  ;mov bx,7
 14805                                  ;lccd1:
 14806                                  ;lodsb
 14807                                  ;and al,al
 14808                                  ;jz short lccd2
 14809                                  ;int 10h
 14810                                  ;jmp short lccd1
 14811                                  ;lccd2:
 14812                                  ;xor ax,ax
 14813                                  ;int 16h	
 14814 000022B6 5E                      		pop	si
 14815 000022B7 89EC                    		mov	sp,bp
 14816 000022B9 5D                      		pop	bp
 14817 000022BA C3                      		retn
 14818                                  
 14819                                  ; memset function (Microsoft C 6.0 runtime library)	
 14820                                  ; ============================================================================
 14821                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 01/12/2018)
 14822                                  
 14823                                  ; http://www.cplusplus.com/reference/cstring/memset/
 14824                                  ;
 14825                                  ;function	;<cstring>
 14826                                  ;memset:
 14827                                  ;
 14828                                  ;void * memset ( void * ptr, int value, size_t num );
 14829                                  ;
 14830                                  ;Fill block of memory
 14831                                  ;Sets the first num bytes of the block of memory pointed by ptr to the specified value 
 14832                                  ;	(interpreted as an unsigned char).
 14833                                  ;
 14834                                  ;Parameters:
 14835                                  ;	ptr:	Pointer to the block of memory to fill.
 14836                                  ;	value:	Value to be set. The value is passed as an int, 
 14837                                  ;		but the function fills the block of memory using 
 14838                                  ;		the unsigned char conversion of this value.
 14839                                  ;	num:	Number of bytes to be set to the value.
 14840                                  ;		size_t is an unsigned integral type.
 14841                                  ;
 14842                                  ;Return Value:
 14843                                  ;	ptr is returned.
 14844                                  
 14845                                  ;memset:
 14846                                  ;	%define	_ptr	bp+4
 14847                                  ;	%define	_value	bp+6
 14848                                  ;	%define _num	bp+8
 14849                                  ;
 14850                                  ;		push	bp
 14851                                  ;		mov	bp,sp
 14852                                  ;		mov	dx,di
 14853                                  ;		mov	ax,ds
 14854                                  ;		mov	es,ax
 14855                                  ;		mov	di,[_ptr]
 14856                                  ;		mov	bx,di
 14857                                  ;		mov	cx,[_num]
 14858                                  ;		jcxz	short memset_2
 14859                                  ;		mov	al,[_value]
 14860                                  ;		mov	ah,al
 14861                                  ;		test	di,1
 14862                                  ;		jz	short metset_1
 14863                                  ;		stosb
 14864                                  ;		dec	cx
 14865                                  ;metset_1:
 14866                                  ;		shr	cx,1
 14867                                  ;		rep stosw
 14868                                  ;		adc	cx,cx
 14869                                  ;		rep stosb
 14870                                  ;memset_2:
 14871                                  ;		mov	di,dx
 14872                                  ;		xchg	ax,bx
 14873                                  ;		pop	bp
 14874                                  ;		retn
 14875                                  
 14876                                  ; sprintf function (Microsoft C 6.0 runtime library)	
 14877                                  ; ============================================================================
 14878                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 01/12/2018)
 14879                                  
 14880                                  ; http://www.cplusplus.com/reference/cstdio/sprintf/
 14881                                  ;
 14882                                  ;function	;<cstdio>
 14883                                  ;sprintf:
 14884                                  ;
 14885                                  ;int sprintf ( char * str, const char * format, ... );
 14886                                  ;
 14887                                  ;Write formatted data to string
 14888                                  ; Composes a string with the same text that would be printed if 
 14889                                  ; format was used on printf, but instead of being printed, 
 14890                                  ; the content is stored as a C string in the buffer pointed by str.
 14891                                  ;
 14892                                  ;Parameters:
 14893                                  ;	str:	Pointer to a buffer where the resulting C-string is stored.
 14894                                  ;		The buffer should be large enough to contain the resulting string.
 14895                                  ;	format:	C string that contains a format string that follows 
 14896                                  ;		the same specifications as format in printf (see printf for details).
 14897                                  ;
 14898                                  ;	... (additional arguments)
 14899                                  ;
 14900                                  ;		Depending on the format string, the function may expect 
 14901                                  ;		a sequence of additional arguments, each containing a value 
 14902                                  ;		to be used to replace a format specifier in the format string 
 14903                                  ;		(or a pointer to a storage location, for n).
 14904                                  ;		There should be at least as many of these arguments 
 14905                                  ;		as the number of values specified in the format specifiers. 
 14906                                  ;		Additional arguments are ignored by the function.
 14907                                  ;Return Value:
 14908                                  ;	On success, the total number of characters written is returned. 
 14909                                  ;	This count does not include the additional null-character 
 14910                                  ;	automatically appended at the end of the string.
 14911                                  ;	On failure, a negative number is returned.
 14912                                  
 14913                                  ; sprintf and _doprnt from PORTABLE C Compiler (8086.zip,1983-1987)
 14914                                  ; ----------------------------------------------------------------------------
 14915                                  ;			   8086/nlib86/stdio/doprnt.c  ; 1982	 
 14916                                  ;			   8086/nlib86/stdio/sprintf.c ; 1982
 14917                                  ;
 14918                                  ; https://www.tuhs.org/Archive/Applications/Portable_CC/  
 14919                                  ; (01/12/2018)
 14920                                  ;
 14921                                  ;Index of /Archive/Applications/Portable_CC
 14922                                  ;
 14923                                  ;  Name           Last modified	   Size    Description
 14924                                  ;----------     ----------------  ------- -------------
 14925                                  ;286.zip	2002-08-09 12:38   169K	 
 14926                                  ;8086.zip	2002-08-09 12:38   1.3M	 ; **this**
 14927                                  ;16032.zip	2002-08-09 12:39   305K	 
 14928                                  ;68000.zip	2002-08-09 12:40   504K	 
 14929                                  ;README		2002-08-10 10:10    145
 14930                                  ;	 
 14931                                  ;Apache/2.4.18 (Ubuntu) Server at www.tuhs.org Port 443
 14932                                  
 14933                                  ;
 14934                                  ; https://www.tuhs.org/Archive/Applications/Portable_CC/README
 14935                                  ;
 14936                                  ; Al Kossow sent in these versions of the portable C compiler for the 8086,
 14937                                  ; Z8000, and 68000 done by MIT's Laboratory for Computer Science. Enjoy.
 14938                                  ;
 14939                                  
 14940                                  ; stdio.h
 14941                                  ;---------
 14942                                  ;
 14943                                  ;#define	BUFSIZ	512
 14944                                  ;#define	_NFILE	20
 14945                                  ;# ifndef FILE
 14946                                  ;extern	struct	_iobuf {
 14947                                  ;	char	*_ptr;
 14948                                  ;	int	_cnt;
 14949                                  ;	char	*_base;
 14950                                  ;	char	_flag;
 14951                                  ;	char	_file;
 14952                                  ;} _iob[_NFILE];
 14953                                  ;# endif
 14954                                  ;
 14955                                  ;#define _IOREAD  01	; 01h
 14956                                  ;#define _IOWRT	  02	; 02h	
 14957                                  ;#define _IONBF	  04	; 04h
 14958                                  ;#define _IOMYBUF 010	; 08h
 14959                                  ;#define _IOEOF	  020	; 10h
 14960                                  ;#define _IOERR	  040	; 20h
 14961                                  ;#define _IOSTRG  0100	; 40h
 14962                                  
 14963                                  ;#define NULL	0
 14964                                  ;#define FILE	struct _iobuf
 14965                                  ;#define EOF	(-1)
 14966                                  ;
 14967                                  ;#define stdin	(&_iob[0])
 14968                                  ;#define stdout	(&_iob[1])
 14969                                  ;#define stderr	(&_iob[2])
 14970                                  ;#define getc(p)   (--(p)->_cnt>=0? *(p)->_ptr++&0377:_filbuf(p))
 14971                                  ;#define getchar() getc(stdin)
 14972                                  ;#define putc(x,p) (--(p)->_cnt>=0? ((int)(*(p)->_ptr++=(unsigned)(x))):_flsbuf((unsigned)(x),p))
 14973                                  ;#define putchar(x) putc(x,stdout)
 14974                                  ;#define feof(p)   (((p)->_flag&_IOEOF)!=0)
 14975                                  ;#define ferror(p) (((p)->_flag&_IOERR)!=0)
 14976                                  ;#define fileno(p) (p)->_file
 14977                                  ;
 14978                                  ;FILE	*fopen();
 14979                                  ;FILE	*freopen();
 14980                                  ;FILE	*fdopen();
 14981                                  ;long	ftell();
 14982                                  ;char	*fgets();
 14983                                  
 14984                                  
 14985                                  ; sprintf.c
 14986                                  ;-----------
 14987                                  ; 
 14988                                  ;#include	<stdio.h>
 14989                                  ;
 14990                                  ;char *sprintf(str, fmt, args)
 14991                                  ;char *str, *fmt;
 14992                                  ;{
 14993                                  ;	struct _iobuf _strbuf;
 14994                                  ;
 14995                                  ;	_strbuf._flag = _IOWRT+_IOSTRG;
 14996                                  ;	_strbuf._ptr = str;
 14997                                  ;	_strbuf._cnt = 32767;
 14998                                  ;	_doprnt(fmt, &args, &_strbuf);
 14999                                  ;	putc('\0', &_strbuf);
 15000                                  ;	return(str);
 15001                                  ;}
 15002                                  
 15003                                  ; SPRINTF.C (VCCRT2.ZIP) - Microsoft Visual C++ 1.0 Run-Time Library Sources
 15004                                  ; ----------------------------------------------------------------------------
 15005                                  ; Microsoft(R) Visual C++ Version 1.0 Run-Time Library Sources (1993)
 15006                                  ;
 15007                                  ; Downloaded From : The Programmer's Corner (www.pcorner.com) - 01/12/2018 -
 15008                                  
 15009                                  ;/****************************************************************************
 15010                                  ;#ifndef _COUNT_
 15011                                  ;*int sprintf(string, format, ...) - print formatted data to string
 15012                                  ;#else
 15013                                  ;*int _snprintf(string, cnt, format, ...) - print formatted data to string
 15014                                  ;#endif
 15015                                  ;*
 15016                                  ;*Purpose:
 15017                                  ;*   Prints formatted data to the using the format string to
 15018                                  ;*   format data and getting as many arguments as called for
 15019                                  ;*   Sets up a FILE so file i/o operations can be used, make string look
 15020                                  ;*   like a huge buffer to it, but _flsbuf will refuse to flush it if it
 15021                                  ;*   fills up.  Appends '\0' to make it a true string.
 15022                                  ;*   _output does the real work here
 15023                                  ;*
 15024                                  ;*   Allocate the 'fake' _iob[] entryit statically instead of on
 15025                                  ;*   the stack so that other routines can assume that _iob[] entries are in
 15026                                  ;*   are in DGROUP and, thus, are near.
 15027                                  ;*
 15028                                  ;#ifdef _COUNT_
 15029                                  ;*   The _snprintf() flavor takes a count argument that is
 15030                                  ;*   the max number of bytes that should be written to the
 15031                                  ;*   user's buffer.
 15032                                  ;#endif
 15033                                  ;*
 15034                                  ;*   Multi-thread: (1) Since there is no stream, this routine must never try
 15035                                  ;*   to get the stream lock (i.e., there is no stream lock either). (2)
 15036                                  ;*   Also, since there is only one staticly allocated 'fake' iob, we must
 15037                                  ;*   lock/unlock to prevent collisions.
 15038                                  ;*
 15039                                  ;*Entry:
 15040                                  ;*   char *string - pointer to place to put output
 15041                                  ;#ifdef _COUNT_
 15042                                  ;*   size_t count - max number of bytes to put in buffer
 15043                                  ;#endif
 15044                                  ;*   char *format - format string to control data format/number of arguments
 15045                                  ;*   followed by list of arguments, number and type controlled by
 15046                                  ;*   format string
 15047                                  ;*
 15048                                  ;*Exit:
 15049                                  ;*   returns number of characters printed
 15050                                  ;*
 15051                                  ;*Exceptions:
 15052                                  ;*
 15053                                  ;****************************************************************************/
 15054                                  
 15055                                  ;#ifndef _COUNT_
 15056                                  ;
 15057                                  ;int 
 15058                                  ;sprintf (char *string, const char *format, ...)
 15059                                  ;
 15060                                  ;#else
 15061                                  ;
 15062                                  ;int 
 15063                                  ;_snprintf (char *string, size_t count, const char *format, ...)
 15064                                  ;
 15065                                  ;#endif
 15066                                  ;
 15067                                  ;{
 15068                                  ;   static FILE _NEAR_ str;
 15069                                  ;   REG1 FILE _NEAR_ *outfile = &str;
 15070                                  ;   va_list arglist;
 15071                                  ;   REG2 int retval;
 15072                                  ;
 15073                                  ;   va_start(arglist, format);
 15074                                  ;
 15075                                  ;   assert(string != NULL);
 15076                                  ;   assert(format != NULL);
 15077                                  ;
 15078                                  ;   outfile->_flag = _IOWRT|_IOSTRG;
 15079                                  ;   outfile->_ptr = outfile->_base = string;
 15080                                  ;#ifndef _COUNT_
 15081                                  ;   outfile->_cnt = MAXSTR;
 15082                                  ;#else
 15083                                  ;   outfile->_cnt = count;
 15084                                  ;#endif
 15085                                  ;
 15086                                  ;   retval = _output(outfile,format,arglist);
 15087                                  ;
 15088                                  ;   putc('\0',outfile); /* no-lock version */
 15089                                  ;
 15090                                  ;   return(retval);
 15091                                  ;}
 15092                                  
 15093                                  ; NASM structure format of _strbuf (_iobuf structure)
 15094                                  struc	_strbuf
 15095 00000000 <res 00000002>          ._ptr:	resw 1	; pointer ; char *_ptr;
 15096 00000002 <res 00000002>          ._cnt:	resw 1	; integer ; int	 _cnt;
 15097 00000004 <res 00000002>          ._base: resw 1 	; pointer ; char *_base;
 15098 00000006 <res 00000001>          ._flag:	resb 1  ; char    ; char _flag;
 15099 00000007 <res 00000001>          ._file: resb 1  ; char    ; char _file;	
 15100                                  .size:
 15101                                  endstruc
 15102                                  
 15103                                  ;; IBM PC-DOS 7.0 FDISK.COM (!unpacked!) segment 0 (code segment), Offset 70BEh. 
 15104                                  
 15105                                  sprintf:
 15106                                  
 15107                                  	%define _printf_buff	bp+4
 15108                                  	%define _printf_format	bp+6
 15109                                  	%define _printf_arg	bp+8
 15110                                  
 15111 000022BB 55                      		push	bp
 15112 000022BC 89E5                    		mov	bp,sp
 15113                                  		;sub	sp,2 ; ?
 15114                                  
 15115 000022BE 57                      		push	di ; *
 15116 000022BF 56                      		push	si ; **
 15117                                  
 15118                                  	; _strbuf._flag = _IOWRT+_IOSTRG;
 15119                                  	; _strbuf._ptr = str;
 15120                                  	; _strbuf._cnt = 32767;
 15121                                  
 15122                                  		; 13/12/2018
 15123                                  		;mov	byte [_strbuf_flag],42h ; _IOWRT + _IOSTRG
 15124                                  	
 15125 000022C0 8B4604                  		mov	ax,[_printf_buff] ; insert + x
 15126                                  
 15127                                  		;mov	[_strbuf_base],ax
 15128                                  
 15129                                  		;mov	si,strbuf ; _strbuf_ptr
 15130                                  		;mov	[si],ax
 15131                                  		;mov	word [_strbuf_cnt],32767
 15132                                  
 15133                                  		; 13/12/2018
 15134 000022C3 A3[E2CC]                		mov	[outbuf_ptr],ax
 15135                                  		;mov	cx,insert+800
 15136                                  		;sub	cx,ax
 15137                                  		;mov	[outbuf_cnt],cx
 15138                                  		
 15139                                  		; 17/12/2018
 15140                                  		; ( 'number_in_msg' procedure -buffer- fixup)
 15141 000022C6 3D[E6CC]                		cmp	ax,insert
 15142 000022C9 7305                    		jnb	short sprintf_buf_set_2
 15143                                  sprintf_buf_set_1:
 15144                                  		;mov	cx,32
 15145 000022CB B90400                  		mov	cx,4
 15146 000022CE EB09                    		jmp	short sprintf_buf_set_3
 15147                                  sprintf_buf_set_2:
 15148 000022D0 B9[06D0]                		mov	cx,insert+800
 15149 000022D3 39C8                    		cmp	ax,cx
 15150 000022D5 73F4                    		jnb	short sprintf_buf_set_1
 15151 000022D7 29C1                    		sub	cx,ax
 15152                                  sprintf_buf_set_3:
 15153 000022D9 890E[E4CC]              		mov	[outbuf_cnt],cx
 15154                                  		 		
 15155                                  		; _doprnt(fmt, &args, &_strbuf); ; Portable C Compiler
 15156                                  
 15157                                  		; retval = _output(outfile,format,arglist); ; Microsoft C Compiler
 15158                                  
 15159 000022DD 8D4608                  		lea	ax,[_printf_arg] 
 15160 000022E0 50                      		push	ax
 15161 000022E1 FF7606                  		push	word [_printf_format]
 15162                                  		;mov	ax,si ; 13/12/2018
 15163                                  		;push	ax
 15164                                  		;call	_doprnt
 15165 000022E4 E81E00                  		call	_output ; 02/12/2018
 15166                                  		;add	sp,6		
 15167 000022E7 83C404                  		add	sp,4 ; 13/12/2018
 15168                                  
 15169                                  		;mov	di,ax
 15170                                  
 15171                                  		; 13/12/2018
 15172 000022EA 50                      		push	ax ; ***
 15173 000022EB B000                    		mov	al,0
 15174 000022ED E84D04                  		call	putc
 15175                                  	
 15176                                  		; putc('\0', &_strbuf);
 15177                                  		; putc('\0',outfile); /* no-lock version */
 15178                                  
 15179                                  ;#define putc(x,p) (--(p)->_cnt>=0? ((int)(*(p)->_ptr++=(unsigned)(x))):_flsbuf((unsigned)(x),p))
 15180                                  
 15181                                  ;#define putc(_c,_stream)  (--(_stream)->_cnt >= 0 ;    ? 0xff & (*(_stream)->_ptr++ = (char)(_c)) :  _flsbuf((_c),(_stream)))
 15182                                  
 15183                                  		;dec	word [_strbuf_cnt]
 15184                                  		;js	short sprintf_0
 15185                                  		;mov	bx,[_strbuf_ptr]
 15186                                  		;inc	word [_strbuf_ptr]
 15187                                  		;mov	byte [bx],0
 15188                                  		;jmp	short sprintf_1
 15189                                  		;;nop
 15190                                  		;;align 2
 15191                                  ;sprintf_0:
 15192                                  		;push	si ; p = &_strbuf
 15193                                  		;sub	ax,ax ; 0
 15194                                  		;push	ax ; x = 0
 15195                                  		;call	_flsbuf
 15196                                  		;add	sp,4
 15197                                  ;sprintf_1:
 15198                                  		;mov	ax,di ; return(retval);
 15199 000022F0 58                      		pop	ax ; *** ; 13/12/2018
 15200                                  
 15201 000022F1 5E                      		pop	si ; **
 15202 000022F2 5F                      		pop	di ; *
 15203                                  
 15204                                  		;mov	sp,bp
 15205 000022F3 5D                      		pop	bp
 15206 000022F4 C3                      		retn
 15207                                  
 15208                                  ;***
 15209                                  ;stdio.inc - Definitions and declarations needed by the STDIO functions
 15210                                  ;	     written in assembler.
 15211                                  ;
 15212                                  ;	Copyright (c) 1988-1992, Microsoft Corporation. All rights reserved.
 15213                                  ;
 15214                                  ;Purpose:
 15215                                  ;	Analog of STDIO.H and FILE2.H for assembler routines.
 15216                                  ;
 15217                                  ;*******************************************************************************
 15218                                  
 15219                                  ; Miscellaneous constants
 15220                                  
 15221                                  ;BUFSIZ		equ	200h
 15222                                  ;EOF		equ	0FFFFh
 15223                                  
 15224                                  ; Element structure for _iob array
 15225                                  
 15226                                  ;_iobuf	struc
 15227                                  ;
 15228                                  ;if sizeD				; far data
 15229                                  ;	_ptr		dd	?
 15230                                  ;	_cnt		dw	?
 15231                                  ;	_base		dd	?
 15232                                  ;	_flag		db	?
 15233                                  ;	_file		db	?
 15234                                  ;
 15235                                  ;else					; near data
 15236                                  ;	_ptr		dw	?
 15237                                  ;	_cnt		dw	?
 15238                                  ;	_base		dw	?
 15239                                  ;	_flag		db	?
 15240                                  ;	_file		db	?
 15241                                  ;endif
 15242                                  ;
 15243                                  ;_iobuf	ends
 15244                                  
 15245                                  ; Size of _iob element (i.e., size of stream structure)
 15246                                  
 15247                                  ;if sizeD				; far data
 15248                                  ;
 15249                                  ;_STREAMSZ	equ	12
 15250                                  ;
 15251                                  ;else					; near data
 15252                                  ;
 15253                                  ;_STREAMSZ	equ	8
 15254                                  ;
 15255                                  ;endif
 15256                                  
 15257                                  ; Element structure for _iob2 array
 15258                                  ;
 15259                                  ;_iobuf2 struc
 15260                                  ;
 15261                                  ;	_flag2		db     ?
 15262                                  ;	_charbuf	db     ?
 15263                                  ;	_bufsiz 	dw     ?
 15264                                  ;	_tmpnum 	dw     ?
 15265                                  ;
 15266                                  ;if sizeD
 15267                                  ;	_padding	db     6 dup (?)
 15268                                  ;else
 15269                                  ;	_padding	db     2 dup (?)
 15270                                  ;endif
 15271                                  ;
 15272                                  ;_iobuf2 ends
 15273                                  
 15274                                  ; Standard streams
 15275                                  ;
 15276                                  ;stdin		equ	dataOFFSET _iob
 15277                                  ;stdout		equ	dataOFFSET _iob + _STREAMSZ
 15278                                  ;stderr		equ	dataOFFSET _iob + 2 * _STREAMSZ
 15279                                  ;stdaux		equ	dataOFFSET _iob + 3 * _STREAMSZ
 15280                                  ;stdprn		equ	dataOFFSET _iob + 4 * _STREAMSZ
 15281                                  
 15282                                  ;; Flags
 15283                                  ;
 15284                                  ;_IOREAD 	equ	01h
 15285                                  ;_IOWRT		equ	02h
 15286                                  ;
 15287                                  ;_IOFBF		equ	0h
 15288                                  ;_IOLBF		equ	040h
 15289                                  ;_IONBF		equ	04h
 15290                                  ;
 15291                                  ;_IOMYBUF	equ	08h
 15292                                  ;_IOEOF		equ	010h
 15293                                  ;_IOERR		equ	020h
 15294                                  ;_IOSTRG 	equ	040h
 15295                                  ;_IORW		equ	080h
 15296                                  ;
 15297                                  ;_IOYOURBUF	equ	01h
 15298                                  ;_IOFEOF 	equ	08h
 15299                                  ;_IOFLRTN	equ	10h
 15300                                  ;_IOCTRLZ	equ	20h
 15301                                  ;_IOCOMMIT	equ	40h
 15302                                  
 15303                                  ; _FLSBUF.ASM (VCCRT2.ZIP) - Microsoft Visual C++ 1.0 Run-Time Library Sources
 15304                                  ; ----------------------------------------------------------------------------
 15305                                  ; Microsoft(R) Visual C++ Version 1.0 Run-Time Library Sources (1993)
 15306                                  ;
 15307                                  ; Downloaded From : The Programmer's Corner (www.pcorner.com) - 01/12/2018 -
 15308                                  
 15309                                  ;***
 15310                                  ;_flsbuf.asm - flush buffer and output character.
 15311                                  ;
 15312                                  ;	Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
 15313                                  ;
 15314                                  ;Purpose:
 15315                                  ;	defines _flsbuf() - flush a file buffer and output a character.
 15316                                  ;	If no buffer, make one.
 15317                                  ;
 15318                                  ;*******************************************************************************
 15319                                  ;
 15320                                  ;--- C VERSION OF ROUTINE
 15321                                  ;
 15322                                  ; #include <stdio.h>
 15323                                  ; #include <register.h>
 15324                                  ; #include <file2.h>
 15325                                  ; #include <assertm.h>
 15326                                  ; #include <malloc.h>
 15327                                  ; #include <msdos.h>
 15328                                  ; #include <internal.h>
 15329                                  ; #include <dos.h>
 15330                                  ; #ifdef MTHREAD
 15331                                  ; #include <os2dll.h>
 15332                                  ; #endif
 15333                                  ;
 15334                                  ; int cdecl _LOAD_DS
 15335                                  ; _flsbuf (ch, str)
 15336                                  ; int ch;
 15337                                  ; FILE *str;
 15338                                  ; {
 15339                                  ;     REG1 FILE _NEAR_ *stream;
 15340                                  ;     FILE2 _NEAR_ *stream2;
 15341                                  ;     REG2 int charcount;
 15342                                  ;     REG3 int written;
 15343                                  ;     int fh;
 15344                                  ;
 15345                                  ;     assert(str,"str==NULL");
 15346                                  ;
 15347                                  ;     /* Init file handle and pointers */
 15348                                  ;     stream = (FILE _NEAR_ *) FP_OFF(str);
 15349                                  ;     fh = fileno(stream);
 15350                                  ;     stream2 = &(_iob2_(stream));
 15351                                  ;
 15352                                  ;     if (!inuse(stream) || stream->_flag & _IOSTRG) {
 15353                                  ;	  stream->_flag |= _IOERR;
 15354                                  ;	  return(-1);
 15355                                  ;     }
 15356                                  ;
 15357                                  ;     if (stream->_flag & _IOREAD) {
 15358                                  ;	  stream->_flag |= _IOERR;
 15359                                  ;	  stream->_cnt = 0;
 15360                                  ;	  return(-1);
 15361                                  ;     }
 15362                                  ;
 15363                                  ;     stream->_flag |= _IOWRT;
 15364                                  ;     stream->_flag &= ~_IOEOF;
 15365                                  ;     written = charcount = stream->_cnt = 0;
 15366                                  ;
 15367                                  ;     /* Get a buffer for this stream, if necessary. */
 15368                                  ;     if (!anybuf2(stream,stream2)) {
 15369                                  ;
 15370                                  ;	  /* Do NOT get a buffer if (1) stream is stdout/stderr, and
 15371                                  ;	     (2) stream is NOT a tty.
 15372                                  ;	     [If stdout/stderr is a tty, we do NOT set up single char buffering.
 15373                                  ;	     This is so that later temporary buffering will not be thwarted
 15374                                  ;	     by the _IONBF bit being set (see _stbuf/_ftbuf usage).]
 15375                                  ;	  */
 15376                                  ; #ifdef  OS2
 15377                                  ;	  if (!( ((stream==stdout) || (stream==stderr))
 15378                                  ; #else
 15379                                  ;	  if (!( ((stream==stdout) || (stream==stderr) || (stream==stdprn))
 15380                                  ; #endif
 15381                                  ;		  && (isatty(fh)) ))
 15382                                  ;
 15383                                  ;		      _getbuf(stream);
 15384                                  ;
 15385                                  ;	  } /* end !anybuf() */
 15386                                  ;
 15387                                  ;     /* If big buffer is assigned to stream... */
 15388                                  ;     if (bigbuf2(stream,stream2)) {
 15389                                  ;	  assert(stream->_ptr - stream->_base >= 0, "inconsistent IOB fields");
 15390                                  ;
 15391                                  ;	  charcount = stream->_ptr - stream->_base;
 15392                                  ;	  stream->_ptr = stream->_base + 1;
 15393                                  ;	  stream->_cnt = stream2->_bufsiz - 1;
 15394                                  ;
 15395                                  ;	  if (charcount > 0)
 15396                                  ;	      written = _write(fh, stream->_base, charcount);
 15397                                  ;	  else
 15398                                  ;	      if (_osfile[fh] & FAPPEND)
 15399                                  ;		  _lseek(fh,0L,SEEK_END);
 15400                                  ;
 15401                                  ;	  *stream->_base = ch;
 15402                                  ;	  }
 15403                                  ;
 15404                                  ;     /* Perform single character output (either _IONBF or no buffering) */
 15405                                  ;     else {
 15406                                  ;	  charcount = 1;
 15407                                  ;	  written = _write(fh, &ch, charcount);
 15408                                  ;	  }
 15409                                  ;
 15410                                  ;     /* See if the write() was successful. */
 15411                                  ;     if (written != charcount) {
 15412                                  ;	  stream->_flag |= _IOERR;
 15413                                  ;	  return(-1);
 15414                                  ;	  }
 15415                                  ;
 15416                                  ;     return(ch & 0xff);
 15417                                  ; }
 15418                                  ;
 15419                                  ;
 15420                                  ;--- END OF C VERSION
 15421                                  ;
 15422                                  
 15423                                  ;msdos.inc - MS-DOS definitions for C runtime
 15424                                  ;----------------------------------------------
 15425                                  ; __osfile flag values for DOS file handles
 15426                                  ;
 15427                                  ;FOPEN	 equ	01H		; file handle open
 15428                                  ;FEOFLAG equ	02H		; end of file has been encountered
 15429                                  ;FCRLF	 equ	04H		; CR-LF across read buffer (in text mode)
 15430                                  ;FPIPE	 equ	08H		; file handle refers to a pipe
 15431                                  ;FRDONLY equ	10H		; file handle associated with read only file
 15432                                  ;FAPPEND equ	20H		; file handle opened O_APPEND
 15433                                  ;FDEV	 equ	40H		; file handle refers to device
 15434                                  ;FTEXT	 equ	80H		; file handle is in text mode
 15435                                  
 15436                                  ;; IBM PC-DOS 7.0 FDISK.COM (!unpacked!) segment 0 (code segment), Offset 7654h. 
 15437                                  
 15438                                  ;*******************************************************************************
 15439                                  ;int _flsbuf(ch, stream) - flush buffer and output character.
 15440                                  ;
 15441                                  ;Purpose:
 15442                                  ;	flush a buffer if this stream has one. if not, try to get one. put the
 15443                                  ;	next output char (ch) into the buffer (or output it immediately if this
 15444                                  ;	stream can't have a buffer). called only from putc. intended for use
 15445                                  ;	only within library.
 15446                                  ;
 15447                                  ;	[NOTE 1: It is valid for this module to assign a value directly to
 15448                                  ;	_flag2 instead of simply twiddling bits in the case where we are
 15449                                  ;	initializing an i/o buffer.]
 15450                                  ;
 15451                                  ;	[NOTE 2: Multi-thread - It is assumed that the caller has aquired
 15452                                  ;	the stream lock.]
 15453                                  ;
 15454                                  ;	[NOTE 3: The code depends on _iob[] and _iob2[] being near arrays of
 15455                                  ;	the total size and element size.]
 15456                                  ;
 15457                                  ;Entry:
 15458                                  ;	FILE *stream - stream to flish and write on
 15459                                  ;	char ch - character to output.
 15460                                  ;
 15461                                  ;Exit:
 15462                                  ;	returns -1 if FILE is actually a string, or if can't write ch to
 15463                                  ;	unbuffered file, or if we flush a buffer but the number of chars
 15464                                  ;	written doesn't agree with buffer size.  Otherwise returns ch.
 15465                                  ;	all fields in FILE struct can be affected except _file.
 15466                                  ;
 15467                                  ;Uses:	ax, bx, cx, dx
 15468                                  ;
 15469                                  ;Exceptions:
 15470                                  ;
 15471                                  ;*******************************************************************************
 15472                                  
 15473                                  ; 14/12/2018 (no need to _flshbuf for FDISK2.COM)
 15474                                  
 15475                                  ;_flsbuf:
 15476                                  ;
 15477                                  ;	%define _c_	bp+4
 15478                                  ;	%define _strm_	bp+6
 15479                                  ;
 15480                                  ;		push	bp
 15481                                  ;		mov	bp,sp
 15482                                  ;		push	si
 15483                                  ;		push	di
 15484                                  ;
 15485                                  ;	; Set:
 15486                                  ;	;	si = stream (= _iob entry)
 15487                                  ;	;	al = stream->_flag
 15488                                  ;
 15489                                  ;		mov	si,[_strm_]
 15490                                  ;		mov	al,[si+6]    ; [_strbuf_flag]
 15491                                  ;
 15492                                  ;	;**
 15493                                  ;	; Check that either _IOWRT or _IORW is set, and _IOSTRG is not set.
 15494                                  ;
 15495                                  ;		test	al,82h ; _IOWRT OR _IORW 
 15496                                  ;		jz	short flsbuf_4 ; reterror
 15497                                  ;		test	al,40h ; _IOSTRG
 15498                                  ;		jnz	short flsbuf_4 ; reterorr
 15499                                  ;;**
 15500                                  ;; Set the _cnt field to 0. This isn't need in the case of a 'big' buffer and
 15501                                  ;; is overwritten in that case. However, it is needed in all other cases and
 15502                                  ;; this is the cheapest place to do it.
 15503                                  ;
 15504                                  ;		mov	word [si+2],0 ; [si]._cnt ; reset _cnt field to 0
 15505                                  ;;**
 15506                                  ;; Check that _IOREAD is not set or, if it is, then so is _IOEOF. Note that
 15507                                  ;; _IOREAD and IOEOF both being set implies switching from read to write at
 15508                                  ;; end-of-file, which is allowed by ANSI. Note that resetting the _cnt and
 15509                                  ;; _ptr fields amounts to doing an fflush() on the stream in this case. Note
 15510                                  ;; also that the _cnt field has to be reset to 0 for the error path as well
 15511                                  ;; (i.e., _IOREAD set but _IOEOF not set) as well as the non-error path.
 15512                                  ;
 15513                                  ;		test	al,1	; _IOREAD
 15514                                  ;		jz	short flsbuf_1 ; set_flag
 15515                                  ;		test	al,10h	; _IOEOF ; ; at end-of-file?
 15516                                  ;		jz	short flsbuf_4 ; reterror ; no, go do error return
 15517                                  ;		mov	cx,[si+4]      ; [si]._base
 15518                                  ;				       ; reset _ptr field to _base field
 15519                                  ;		mov	[si],cx	;[si]._ptr 
 15520                                  ;
 15521                                  ;		and	al,~1 ; NOT _IOREAD ; clear _IOREAD bit
 15522                                  ;flsbuf_1:
 15523                                  ;		;**
 15524                                  ;		; Set _IOWRT and clear _IOEOF
 15525                                  ;;set_flag:
 15526                                  ;		or	al,2	; _IOWRT
 15527                                  ;		and	al,~10h ; NOT _IOEOF
 15528                                  ;		mov	[si+6],al ; [si]._flag
 15529                                  ;	;**
 15530                                  ;	; Set:
 15531                                  ;	;	di = _iob2 entry (aka stream2)
 15532                                  ;	;	bx = stream->_file (= file handle)
 15533                                  ;
 15534                                  ;		mov	di,si
 15535                                  ;		;sub	di,STDIN ; _iob
 15536                                  ;		sub	di,_iob	; 07/12/2018
 15537                                  ;		add	di,_iob2	; di = stream2 corresponding to stream
 15538                                  ;		xor	bx,bx
 15539                                  ;		mov	bl,[si+7] ; [si]._file	; bx = file handle for stream
 15540                                  ;	;**
 15541                                  ;	; Test the buffering flags and branch accordingly
 15542                                  ;
 15543                                  ;		test	al,8 ; _IOMYBUF
 15544                                  ;		jnz	short flsbuf_6 ; bigbuf
 15545                                  ;		test	al,4 ; _IONBF
 15546                                  ;		jnz	short flsbuf_3 ; singlechar
 15547                                  ;
 15548                                  ;		test	byte [di],1 ; test [di]._flag2,_IOYOURBUF
 15549                                  ;		jnz	short flsbuf_6 ; bigbuf
 15550                                  ;	;**
 15551                                  ;	; No buffering is in place at all. Check to see if the stream is stdout,
 15552                                  ;	; stderr or, in DOS only, stdprn. If it is and if it is attached to a device,
 15553                                  ;	; go do single character output. Otherwise, go try to buffer it.
 15554                                  ;
 15555                                  ;		cmp	si,STDOUT
 15556                                  ;		je	short flsbuf_2	; testdev
 15557                                  ;		cmp	si,STDERR
 15558                                  ;		je	short flsbuf_2	; testdev
 15559                                  ;		cmp	si,STDPRN
 15560                                  ;		jne	short flsbuf_5	; dogetbuf
 15561                                  ;flsbuf_2:
 15562                                  ;;testdev:
 15563                                  ;		;test	byte ptr [bx + dataOFFSET _osfile],FDEV
 15564                                  ;		test	byte [bx+_osfile],40h ; FDEV
 15565                                  ;		jz	short flsbuf_5	; dogetbuf
 15566                                  ;flsbuf_3:
 15567                                  ;;try_again:	;if (iop->_flag&_IONBF) {
 15568                                  ;		;	c1 = c;
 15569                                  ;		;	rn = 1;
 15570                                  ;		;	n = write(fileno(iop), &c1, rn);
 15571                                  ;		;	iop->_cnt = 0;
 15572                                  ;	;**
 15573                                  ;	; Single character output (either _IONBF or no buffering at all).
 15574                                  ;singlechar:
 15575                                  ;		mov	cx,1	 ; rn
 15576                                  ;		push	cx
 15577                                  ;		lea	di,[_c_] ; &c1 ; [char] ; ss:di = address of char
 15578                                  ;		push	di
 15579                                  ;		push	bx	 ; fileno(iop)
 15580                                  ;		call	_write	 ; write(handle,&char,1)
 15581                                  ;		add	sp,6
 15582                                  ;		mov	cx,1	 ; rn	; set cx = 1 = number of chars...
 15583                                  ;			; ax = n
 15584                                  ;		jmp	short flsbuf_8  ; doret
 15585                                  ;					; ...that should have been written
 15586                                  ;flsbuf_4:
 15587                                  ;	;**
 15588                                  ;	; Set up a return of -1 to indicate that an error has occurred and jump
 15589                                  ;	; to done. Set the error flag on the stream.
 15590                                  ;;reterorr:
 15591                                  ;		mov	ax,-1	; return -1 to indicate error
 15592                                  ;		;or	[si]._flag,_IOERR ; set error flag
 15593                                  ;		or	byte [si+6],20h ; iop->_flag |= _IOERR
 15594                                  ;		jmp	short flsbuf_10	; done ; return(EOF) 
 15595                                  ;flsbuf_5:
 15596                                  ;	;**
 15597                                  ;	; The stream is unbuffered, try to buffer it. Then, check the buffering
 15598                                  ;	; flags again and branch accordingly.
 15599                                  ;;dogetbuf:
 15600                                  ;		push	bx		; save file handle
 15601                                  ;		;push	si	; 09/12/2018
 15602                                  ;		call	_getbuf 	; _getbuf(stream)
 15603                                  ;		;pop	bx		; clean off arg
 15604                                  ;		pop	bx		; restore file handle
 15605                                  ;
 15606                                  ;		;test	[si]._flag,_IOMYBUF ; did we get a 'big' buffer?
 15607                                  ;		;jz	short singlechar    ; no, single char buffering
 15608                                  ;
 15609                                  ;		test	byte [si+6],8	; _IOMYBUF
 15610                                  ;		jz	short flsbuf_3	; try_again
 15611                                  ;flsbuf_6:
 15612                                  ;	;**
 15613                                  ;	; The stream has a 'big' buffer. Empty it with a write().
 15614                                  ;; bigbuf:
 15615                                  ;		mov	cx,[si]   ; [si]._ptr
 15616                                  ;		mov	dx,[si+4] ; [si]._base	
 15617                                  ;		sub	cx,dx	  ; cx = number of chars in stream buffer
 15618                                  ;		inc	dx
 15619                                  ;		mov	[si],dx	  ; [si]._ptr ; set _ptr to _base + 1
 15620                                  ;		mov	dx,[di+2] ; [di]._bufsiz 	
 15621                                  ;		dec	dx		
 15622                                  ;		mov	[si+2],	dx ; [si]._cnt ; set _cnt to _bufsiz - 1
 15623                                  ;		jcxz	flsbuf_9 ; dolseek ; no chars in buffer to write
 15624                                  ;
 15625                                  ;		push	cx	; save count
 15626                                  ;
 15627                                  ;		push	cx	; push args
 15628                                  ;		push	word [si+4] ; [si]._base
 15629                                  ;		push	bx
 15630                                  ;		call	_write
 15631                                  ;		add	sp,6	; clean off args
 15632                                  ;
 15633                                  ;		pop	cx	; restore count
 15634                                  ;flsbuf_7:
 15635                                  ;		;**
 15636                                  ;		; Place 'char' in the stream buffer
 15637                                  ;;bufchar:
 15638                                  ;		mov	di,[si+4] ; [si]._base
 15639                                  ;		mov	dx,[_c_]  ; [char]
 15640                                  ;		mov	[di],dl
 15641                                  ;flsbuf_8:
 15642                                  ;		;if (rn != n) {
 15643                                  ;		;	iop->_flag |= _IOERR;
 15644                                  ;		;	return(EOF);
 15645                                  ;		;}
 15646                                  ;		;return(c);
 15647                                  ;	;**
 15648                                  ;	; Test the results of the call to write() (i.e., compare ax and cx). If
 15649                                  ;	; successful, return char. Otherwise, return -1.
 15650                                  ;
 15651                                  ;		cmp	ax,cx ; ax = n, cx = rn
 15652                                  ;		jne	short flsbuf_4  ; != ; reterror
 15653                                  ;
 15654                                  ;		;return(c);	
 15655                                  ;		xor	ax,ax
 15656                                  ;		mov	al,[_c_] ; [char]
 15657                                  ;		jmp	short flsbuf_10 ; done
 15658                                  ;flsbuf_9:
 15659                                  ;	;**
 15660                                  ;	; There are no characters in the stream buffer. If the FAPPEND bit is set
 15661                                  ;	; in the _osfile entry, position the file pointer at the end of the file.
 15662                                  ;;dolseek:
 15663                                  ;		xor	ax,ax		; needed for both branchings below
 15664                                  ;		;test	byte ptr [bx + dataOFFSET _osfile],FAPPEND
 15665                                  ;		test	byte [bx+_osfile],20h
 15666                                  ;		jz	short flsbuf_7 ; bufchar
 15667                                  ;		
 15668                                  ;		mov	cx,2	; SEEK_END
 15669                                  ;		push	cx		; push args
 15670                                  ;		push	ax		; note that ax is 0
 15671                                  ;		push	ax
 15672                                  ;		push	bx
 15673                                  ;		call	_lseek		; _lseek(handle,0L,SEEK_END)
 15674                                  ;		add	sp,8
 15675                                  ;		xor	ax,ax
 15676                                  ;		mov	cx,ax		; set ax = cx = 0
 15677                                  ;		;jmp	short bufchar
 15678                                  ;		jmp	short flsbuf_7
 15679                                  ;flsbuf_10:
 15680                                  ;;done:
 15681                                  ;		pop	di
 15682                                  ;		pop	si
 15683                                  ;		pop	bp
 15684                                  ;		retn
 15685                                  
 15686                                  ; OUTPUT.ASM (VCCRT2.ZIP) - Microsoft Visual C++ 1.0 Run-Time Library Sources
 15687                                  ; ----------------------------------------------------------------------------
 15688                                  ; Microsoft(R) Visual C++ Version 1.0 Run-Time Library Sources (1993)
 15689                                  ;
 15690                                  ; Downloaded From : The Programmer's Corner (www.pcorner.com) - 01/12/2018 -
 15691                                  
 15692                                  ; 06/12/2018
 15693                                  
 15694                                  ;***
 15695                                  ;output.asm - formatted output for printf, etc.
 15696                                  ;
 15697                                  ;	Copyright (c) 1988-1992, Microsoft Corporation. All rights reserved.
 15698                                  ;
 15699                                  ;Purpose:
 15700                                  ;	defines _output() for formatted output by *printf.
 15701                                  ;	if CPRFLAG is defined, defines cprintf instead.
 15702                                  ;
 15703                                  ;******************************************************************************
 15704                                  
 15705                                  ; size of conversion buffer (ANSI-specified minimum is 509)
 15706                                  BUFSIZE 	equ	512		; size of buffer for conversions
 15707                                  
 15708                                  ; flag definitions for flag 1
 15709                                  FL_SIGN 	equ	01h		; put plus/minus sign in front
 15710                                  FL_SIGNSP	equ	02h		; put space/minus sign in front
 15711                                  FL_LEFT 	equ	04h		; left justify
 15712                                  FL_LEADZERO	equ	08h		; pad with leading zeros
 15713                                  FL_LONG 	equ	10h		; long value given (def: short)
 15714                                  FL_FAR		equ	20h		; far pointer given (def: model dep.)
 15715                                  FL_SIGNED	equ	40h		; signed data given (def: unsigned)
 15716                                  FL_ALTERNATE	equ	80h		; alternate form requested
 15717                                  
 15718                                  ; flag definitions for flag 2
 15719                                  FL_NEGATIVE	equ	01h		; value is negative
 15720                                  FL_FORCEOCTAL	equ	02h		; force 0 in front (for octals only)
 15721                                  FL_LONGDOUBLE	equ	04h		; long double value given
 15722                                  FL_SHORT	equ	08h		; short value given
 15723                                  FL_NEAR 	equ	10h		; near ptr given (useful only for %p)
 15724                                  
 15725                                  ; possible state values
 15726                                  ST_NORMAL	equ	0		; normal state -- just output char
 15727                                  ST_PERCENT	equ	1		; just read percent sign
 15728                                  ST_FLAG 	equ	2		; just read flag character
 15729                                  ST_WIDTH	equ	3		; just read width specification char
 15730                                  ST_DOT		equ	4		; just read dot
 15731                                  ST_PRECIS	equ	5		; just read precision spec. char
 15732                                  ST_SIZE 	equ	6		; just read size specification char
 15733                                  ST_TYPE 	equ	7		; just read type specification
 15734                                  
 15735                                  ; define character type values
 15736                                  CH_OTHER	equ	0		; character with no special meaning
 15737                                  CH_PERCENT	equ	1		; '%'
 15738                                  CH_DOT		equ	2		; '.'
 15739                                  CH_STAR 	equ	3		; '*'
 15740                                  CH_ZERO 	equ	4		; '0'
 15741                                  CH_DIGIT	equ	5		; '1'..'9'
 15742                                  CH_FLAG 	equ	6		; ' ', '+', '-', '#'
 15743                                  CH_SIZE 	equ	7		; 'h', 'l', 'L', 'N', 'F'
 15744                                  CH_TYPE 	equ	8		; type specification character
 15745                                  
 15746                                  ;*******************************************************************************
 15747                                  ;int _output(stream, format, argptr) - formatted output (used internally only)
 15748                                  ;
 15749                                  ;Purpose:
 15750                                  ;	_output performs printf-style output onto a stream.  It is called
 15751                                  ;	by printf/fprintf/sprintf/vprintf/vfprintf/vsprintf to do the
 15752                                  ;	dirty work.  In multi-thread situations, _output assumes that
 15753                                  ;	the given stream is already locked.
 15754                                  ;
 15755                                  ;	Algorithm:
 15756                                  ;	   The format string is parsed by using a finite-state machine
 15757                                  ;	   based on the current state and the current character read
 15758                                  ;	   from the format string.  Thus, looping is on a per-character
 15759                                  ;	   basis, not a per conversion specifier basis.  Once the format
 15760                                  ;	   specifying character is read, output is performed.
 15761                                  ;
 15762                                  ;Entry:
 15763                                  ;	FILE *stream	-    stream for output
 15764                                  ;	char *format	-    printf-style format string
 15765                                  ;	void *argptr	-    pointer to the list of subsidiary arguments
 15766                                  ;
 15767                                  ;Exit:
 15768                                  ;	If no output error occurs, returns the number of characters written
 15769                                  ;	If an I/O error occurs, -1 is returned.
 15770                                  ;
 15771                                  ;Uses:
 15772                                  ;	Performs I/O on the given stream by using the assembly
 15773                                  ;	equivalent of getc/_getc_lk macros.
 15774                                  ;
 15775                                  ;*******************************************************************************
 15776                                  
 15777                                  ;jump table based on current state
 15778 000022F5 [5A23]                  jumptable:	dw normal_state
 15779 000022F7 [6523]                  		dw percent_state
 15780 000022F9 [7923]                  		dw flag_state
 15781 000022FB [AD23]                  		dw width_state
 15782 000022FD [D923]                  		dw dot_state
 15783 000022FF [E123]                  		dw precis_state
 15784 00002301 [0A24]                  		dw size_state
 15785 00002303 [3C24]                  		dw type_state
 15786                                  
 15787                                  ;cProc	output, <NEAR>, <>	      ; static, near routine
 15788                                  ;        parmDP  format
 15789                                  ;    ifdef _WINDOWS
 15790                                  ;        parmD   arglist
 15791                                  ;    else
 15792                                  ;        parmDP  arglist
 15793                                  ;    endif
 15794                                  ;
 15795                                  ;else		; defining normal _output routine
 15796                                  ;
 15797                                  ;cProc	_output, <PUBLIC>, <>
 15798                                  ;	parmDP	stream
 15799                                  ;	parmDP	format
 15800                                  ;	parmDP  arglist
 15801                                  ;
 15802                                  ;endif ;CPRFLAG
 15803                                  ;
 15804                                  ;; define local variables manually (ick!) -- because we need stack checking
 15805                                  ;
 15806                                  ;ifdef _WINDOWS
 15807                                  ;    if    sizeC
 15808                                  ;	BASE equ <(bp-2)>
 15809                                  ;    else
 15810                                  ;	BASE equ <bp>
 15811                                  ;    endif ;sizeC
 15812                                  ;else
 15813                                  ;	BASE equ <bp>
 15814                                  ;endif ;_WINDOWS
 15815                                  ;
 15816                                  ;hexadd		equ	byte ptr [BASE-1]	  ; offset to add when hex converting
 15817                                  ;char		equ	byte ptr [BASE-2]	  ; character just read
 15818                                  ;flags		equ	word ptr [BASE-4]	  ; flag word (byte equates below)
 15819                                  ;flags2		equ	byte ptr [BASE-3]	  ; flag byte 2
 15820                                  ;flags1		equ	byte ptr [BASE-4]	  ; flag byte 1
 15821                                  ;state		equ	byte ptr [BASE-5]	  ; state we're in
 15822                                  ;radix		equ	byte ptr [BASE-6]	  ; radix to convert by
 15823                                  ;charsout	equ	word ptr [BASE-8]	  ; chars written so far
 15824                                  ;fldwidth	equ	word ptr [BASE-10]	  ; selected width
 15825                                  ;precision	equ	word ptr [BASE-12]	  ; selected precision
 15826                                  ;prefix		equ	byte ptr [BASE-14]	  ; up to two-byte prefix
 15827                                  ;prfxlen 	equ	word ptr [BASE-16]	  ; length of prefix
 15828                                  ;capexp		equ	word ptr [BASE-18]	  ; capital exponent?
 15829                                  ;buffer		equ	byte ptr [BASE-20-BUFSIZE]; buffer for conversions
 15830                                  ;
 15831                                  ;LOCALDATSIZE	equ	20+BUFSIZE	; amount of local data
 15832                                  ;
 15833                                  ; begin procedure
 15834                                  ;
 15835                                  ;cBegin _output
 15836                                  
 15837                                  LOCALDATSIZE	equ	20+BUFSIZE	; Visual C++ Version 1.0 Run-Time Library
 15838                                  					; OUTPUT.ASM
 15839                                  
 15840                                  ; IBM PC-DOS 7.0 FDISK.COM Segment 0 (Code Segment), Offset 7744h
 15841                                  
 15842                                  _output:
 15843                                  
 15844                                  	;%define output_buff bp-369	; IBM PC-DOS 7.0 FDISK.COM
 15845                                  	%define output_buff  bp-532	; Visual C++ Version 1.0 Run-Time Library
 15846                                  					; OUTPUT.ASM
 15847                                  	%define capexp	  bp-18
 15848                                  	%define prfxlen   bp-16
 15849                                  	%define prefix	  bp-14
 15850                                  	%define precision bp-12
 15851                                  	%define fldwidth  bp-10
 15852                                  	%define charsout  bp-8
 15853                                  	%define radix	  bp-6
 15854                                  	%define state	  bp-5
 15855                                  	%define flags	  bp-4
 15856                                  	%define char	  bp-2
 15857                                  	%define hexadd	  bp-1
 15858                                  
 15859                                  	;%define stream	  bp+4	
 15860                                  	;%define format	  bp+6
 15861                                  	;%define arglist  bp+8
 15862                                  
 15863                                  	; 13/12/2018
 15864                                  	%define format	bp+4
 15865                                  	%define arglist	bp+6
 15866                                  	
 15867 00002305 55                      		push	bp
 15868 00002306 89E5                    		mov	bp,sp
 15869                                  		
 15870                                  		;mov	ax,369 ; PC-DOS 7.0 FDISK.COM
 15871 00002308 B81402                  		mov	ax,LOCALDATSIZE ; 532
 15872 0000230B E8AA04                  		call	_chkstk		; allocate local data
 15873                                  		
 15874 0000230E 56                      		push	si
 15875 0000230F 57                      		push	di
 15876 00002310 31C0                    		xor	ax,ax ; 0
 15877 00002312 8946F8                  		mov	[charsout],ax	; charsout = 0
 15878 00002315 8846FB                  		mov	[state],al	; state = 0
 15879                                  
 15880                                  		; beginning of main loop	
 15881                                  loopagain:
 15882                                  
 15883                                  ;if sizeD
 15884                                  ;	les	si, format
 15885                                  ;	lods	byte ptr es:[si]
 15886                                  ;else
 15887                                  ;	mov	si, format
 15888                                  ;	lodsb
 15889                                  ;endif
 15890 00002318 8B7604                  		mov	si,[format]
 15891 0000231B AC                      		lodsb
 15892 0000231C 897604                  		mov	[format],si
 15893 0000231F 8846FE                  		mov	[char],al	; char = *format++
 15894 00002322 08C0                    		or	al,al		; char == '\0'?
 15895 00002324 7406                    		jz	short output_done ; yes - end loop
 15896 00002326 837EF800                		cmp	word [charsout],0 ; charsout < 0
 15897 0000232A 7D06                    		jge	short output_loopok ; no - don't end loop
 15898                                  output_done:
 15899 0000232C 8B46F8                  		mov	ax,[charsout]	; return chars written
 15900 0000232F E9D403                  		jmp	output_return
 15901                                  
 15902                                  output_loopok:
 15903 00002332 BB[FC9F]                		mov	bx,lookuptable	; bx points to lookup table
 15904 00002335 2C20                    		sub	al,' ' ; 20h	; al = char - ' '
 15905 00002337 3C58                    		cmp	al,'X'		; beyond end of table?
 15906 00002339 7705                    		ja	short output_main1 ; yes, make it other char
 15907 0000233B D7                      		xlat			; al = lookuptable[al]
 15908 0000233C 240F                    		and	al,0Fh		; keep low nybble -- al has char class
 15909 0000233E EB02                    		jmp	short output_main2
 15910                                  
 15911                                  output_main1:
 15912 00002340 B000                    		mov	al,0  ; CH_OTHER ; not in table, must be other
 15913                                  output_main2:
 15914 00002342 B103                    		mov	cl,3
 15915 00002344 D2E0                    		shl	al,cl		; al *= 8
 15916 00002346 0246FB                  		add	al,[state]	; al += state
 15917 00002349 D7                      		xlat			; al = lookuptable[al]
 15918 0000234A FEC1                    		inc	cl		; cl = 4
 15919 0000234C D2E8                    		shr	al,cl		; al >>= 4
 15920 0000234E 8846FB                  		mov	[state],al	; save new state	
 15921 00002351 98                      		cbw			; zero ah (al < 80h)
 15922                                  	
 15923                                  	; ax now has the state # (recall ah = 0) -- now we
 15924                                  	; use this to index into a jump table and go to
 15925                                  	; correct code for the current state
 15926                                  
 15927 00002352 89C3                    		mov	bx,ax
 15928 00002354 D1E3                    		shl	bx,1		; index words (bx = state #)
 15929                                  		;jmp	jumptable[bx]
 15930                                  		;jmp	far [cs:bx+jumptable]
 15931 00002356 FFA7[F522]              		jmp	word [bx+jumptable] ; jump to correct state code
 15932                                  
 15933                                  normal_state:
 15934                                  		; normal state - just output the character involved
 15935 0000235A 8A56FE                  		mov	dl,[char]
 15936 0000235D B90100                  		mov	cx,1
 15937 00002360 E81104                  		call	outpad
 15938 00002363 EBB3                    		jmp	short loopagain
 15939                                  
 15940                                  percent_state:
 15941                                  		; just read the percent character
 15942 00002365 31C0                    		xor	ax,ax ; 0
 15943 00002367 8946F0                  		mov	[prfxlen],ax	; prfxlen = 0
 15944 0000236A 8946F6                  		mov	[fldwidth],ax	; fldwidth = 0
 15945 0000236D 8946EE                  		mov	[capexp],ax	; capexp = 0
 15946                                  ;if sizeD
 15947                                  ;	mov	flags, FL_FAR		; large data -- default far ptrs
 15948                                  ;else
 15949                                  ;	mov	flags, ax		; small data -- default near ptrs
 15950                                  ;endif
 15951 00002370 8946FC                  		mov	[flags],ax	; flags = 0
 15952 00002373 48                      		dec	ax
 15953 00002374 8946F4                  		mov	[precision],ax	; precision = -1 (default)
 15954 00002377 EB9F                    		jmp	short loopagain	; end of state code
 15955                                  
 15956                                  flag_state:
 15957                                  		; just read a flag, so set the flag bits accordingly
 15958 00002379 8A46FE                  		mov	al,[char]
 15959 0000237C 3C2D                    		cmp	al,'-'
 15960 0000237E 7506                    		jne	short fl1
 15961                                  doprnt_case_minus:
 15962                                  		;or	flags1,FL_LEFT
 15963 00002380 804EFC04                		or	byte [flags],4	; FL_LEFT
 15964                                  					; char=='-' => left justify
 15965 00002384 EB92                    		jmp	short loopagain
 15966                                  fl1:
 15967 00002386 3C2B                    		cmp	al,'+'
 15968 00002388 7506                    		jne	short fl2	
 15969                                  doprnt_case_plus:
 15970                                  		;or	flags1,FL_SIGN
 15971 0000238A 804EFC01                		or	byte [flags],1	; FL_SIGN
 15972                                  					; char=='+' => force sign indicator
 15973 0000238E EB88                    		jmp	short loopagain
 15974                                  fl2:
 15975 00002390 3C20                    		cmp	al,' '		; FL_SIGNSP 
 15976 00002392 7507                    		jnz	short fl3
 15977                                  doprnt_case_space:
 15978                                  		;or	flags1,FL_SIGNSP
 15979 00002394 804EFC02                		or	byte [flags],2	; char==' ' => as above, 
 15980                                  					; but space not +
 15981 00002398 E97DFF                  		jmp	loopagain	; end of state
 15982                                  fl3:
 15983 0000239B 3C23                    		cmp	al,'#'		 
 15984 0000239D 7507                    		jnz	short fl4
 15985                                  doprnt_case_sharp:
 15986                                  		;or	flags1,FL_ALTERNATE
 15987 0000239F 804EFC80                		or	byte [flags],80h ; FL_ALTERNATE 
 15988                                  					; char=='#' => alternate form
 15989 000023A3 E972FF                  		jmp	loopagain
 15990                                  fl4:
 15991                                  		;or	flags1,FL_LEADZERO
 15992 000023A6 804EFC08                		or	byte [flags],8	; FL_LEADZERO
 15993 000023AA E96BFF                  		jmp	loopagain	; char=='0' => pade with leading zeros
 15994                                  width_state:
 15995                                  		; just read a width specifier -- set width value
 15996 000023AD 8A4EFE                  		mov	cl,[char]
 15997 000023B0 80F92A                  		cmp	cl,'*'		; char == '*'
 15998 000023B3 750F                    		jne	short widthdigit ; no - must be a digit
 15999                                  		; char == '*' means get width from argument list	
 16000 000023B5 E85403                  		call	getwordarg	; AX = word argument	
 16001 000023B8 09C0                    		or	ax,ax		; ax < 0
 16002 000023BA 7917                    		jns	short storewidth ; no - do normal
 16003 000023BC F7D8                    		neg	ax		; ANSI: neg width means - flags
 16004                                  		;or	flags1, FL_LEFT
 16005 000023BE 804EFC04                		or	byte [flags],4	;FL_LEFT ; and positive width
 16006 000023C2 EB0F                    		jmp	short storewidth
 16007                                  widthdigit:
 16008                                  		; we just read a digit to add to the stored width value
 16009 000023C4 80E930                  		sub	cl,'0'
 16010 000023C7 30ED                    		xor	ch,ch		; dx = value of digit
 16011 000023C9 8B46F6                  		mov	ax,[fldwidth]
 16012 000023CC BB0A00                  		mov	bx,10
 16013 000023CF F7E3                    		mul	bx
 16014 000023D1 01C8                    		add	ax,cx		; fldwidth = 10*fldwidth + (digit-'0')
 16015                                  storewidth:
 16016 000023D3 8946F6                  		mov	[fldwidth],ax
 16017 000023D6 E93FFF                  		jmp	loopagain
 16018                                  
 16019                                  dot_state:
 16020                                  		; We just read the dot -- char must == '.'
 16021                                  		; and all we need to do is zero the precision.
 16022 000023D9 C746F40000              		mov	word [precision],0	; zero precision, no longer default
 16023 000023DE E937FF                  		jmp	loopagain
 16024                                  
 16025                                  precis_state:
 16026                                  		; just read a precision specifier -- set precision value
 16027 000023E1 8A4EFE                  		mov	cl,[char]
 16028 000023E4 80F92A                  		cmp	cl,'*'		; char == '*'
 16029 000023E7 750C                    		jne	short precisdigit ; no - must be a digit
 16030                                  		; char == '*' means get precision from argument list
 16031 000023E9 E82003                  		call	getwordarg	; AX = word argument
 16032 000023EC 09C0                    		or	ax,ax		; ax < 0
 16033 000023EE 7914                    		jns	short storeprecis ; no - do normal
 16034 000023F0 B8FFFF                  		mov	ax,0FFFFh ; -1	; ANSI: neg precis. means default value	
 16035 000023F3 EB0F                    		jmp	short storeprecis
 16036                                  
 16037                                  precisdigit:
 16038                                  		; we just read a digit to add to the stored precision value
 16039 000023F5 80E930                  		sub	cl,'0'
 16040 000023F8 30ED                    		xor	ch,ch
 16041 000023FA 8B46F4                  		mov	ax,[precision]
 16042 000023FD BB0A00                  		mov	bx,10
 16043 00002400 F7E3                    		mul	bx
 16044 00002402 01C8                    		add	ax,cx	; precision = 10*precision + (digit-'0')
 16045                                  storeprecis:
 16046 00002404 8946F4                  		mov	[precision],ax	; store precision
 16047 00002407 E90EFF                  		jmp	loopagain
 16048                                  
 16049                                  size_state:
 16050                                  		; just read a size specifier -- set the flags based on it
 16051 0000240A 8A46FE                  		mov	al,[char]
 16052 0000240D 3C6C                    		cmp	al,'l'
 16053 0000240F 7506                    		jne	short sz1
 16054                                  		;or	byte [flags1],FL_LONG
 16055 00002411 804EFC10                		or	byte [flags],10h ; FL_LONG
 16056                                  				; char=='l' or 'L' => long value given
 16057 00002415 EB22                    		jmp	short szret
 16058                                  sz1:
 16059 00002417 3C46                    		cmp	al,'F'		
 16060 00002419 7506                    		jne	short sz2
 16061                                  		;or 	byte [flags1],FL_FAR
 16062 0000241B 804EFC20                		or	byte [flags],20h ; FL_FAR
 16063                                  					; char=='F' => far ptr given
 16064 0000241F EB18                    		jmp	short szret
 16065                                  sz2:
 16066 00002421 3C4E                    		cmp	al,'N'
 16067 00002423 7506                    		jnz	short sz3
 16068                                  		;or	byte [flags2],FL_NEAR
 16069 00002425 804EFD10                		or	byte [flags+1],10h ; FL_NEAR
 16070                                  					; char=='N' => near ptr given	
 16071 00002429 EB0E                    		jmp	short szret
 16072                                  sz3:
 16073 0000242B 3C4C                    		cmp	al,'L'
 16074 0000242D 7506                    		jnz	short sz4
 16075                                  		;or	byte [flags2],FL_LONGDOUBLE
 16076 0000242F 804EFD04                		or	byte [flags+1],4 ; FL_LONGDOUBLE
 16077                                  					; char=='L' => long double given	
 16078 00002433 EB04                    		jmp	short szret
 16079                                  sz4:
 16080                                  		; at this point we must have h given
 16081                                  		;or	byte [flags2], FL_SHORT
 16082 00002435 804EFD08                		or	byte [flags+1],8 ; FL_SHORT
 16083                                  szret:					; char=='h' => short value given
 16084 00002439 E9DCFE                  		jmp	loopagain
 16085                                  
 16086                                  type_state:
 16087                                  	; OK, we just read the type specifier character, so we now actually
 16088                                  	; have to format and 'print' the output. We do this with the
 16089                                  	; equivalent of a big switch statement to routines that formats the
 16090                                  	; correct input and set ES:DI to point to the text to print
 16091                                  	; and CX to the length of this output. Common code later on
 16092                                  	; then takes care of right/left justifying it. Note that many of
 16093                                  	; the cases share code; in particular all integer formatting is
 16094                                  	; done in one place.
 16095                                  
 16096 0000243C 8A46FE                  		mov	al,[char]
 16097 0000243F 3C64                    		cmp	al,'d'
 16098 00002441 7503                    		jne	short t1
 16099                                  		;jmp	doprnt_case_i_d
 16100 00002443 E98D01                  		jmp	type_d
 16101                                  t1:
 16102 00002446 3C69                    		cmp	al,'i'
 16103 00002448 7503                    		jne	short t2
 16104                                  		;jmp	doprnt_case_i_d
 16105 0000244A E98601                  		jmp	type_i
 16106                                  t2:
 16107 0000244D 3C75                    		cmp	al,'u'
 16108 0000244F 7503                    		jne	short t3
 16109 00002451 E98301                  		jmp	type_u
 16110                                  t3:
 16111 00002454 3C58                    		cmp	al,'X'
 16112 00002456 7503                    		jne	short t4
 16113 00002458 E98201                  		jmp	type_bigx
 16114                                  t4:
 16115 0000245B 3C78                    		cmp	al,'x'
 16116 0000245D 7503                    		jne	short t5
 16117 0000245F E98101                  		jmp	type_x
 16118                                  t5:
 16119 00002462 3C6F                    		cmp	al,'o'
 16120 00002464 7503                    		jne	short t6
 16121 00002466 E99B01                  		jmp	type_o
 16122                                  t6:
 16123 00002469 3C63                    		cmp	al,'c'
 16124 0000246B 741A                    		je	short type_c
 16125 0000246D 3C73                    		cmp	al,'s'
 16126 0000246F 7427                    		je	short type_s
 16127 00002471 3C6E                    		cmp	al,'n'
 16128 00002473 7451                    		je	short type_n
 16129 00002475 3C70                    		cmp	al,'p'
 16130 00002477 7460                    		je	short type_p
 16131 00002479 3C45                    		cmp	al,'E'
 16132 0000247B 7407                    		je	short bigeg
 16133 0000247D 3C47                    		cmp	al,'G'
 16134 0000247F 7403                    		je	short bigeg
 16135                                  
 16136                                  	; only possible remaining type is 'e', 'f', 'g' -- go to it
 16137 00002481 E9BB00                  		jmp	type_efg	;'e', 'f', 'g' same destination	
 16138                                  bigeg:
 16139 00002484 E9B500                  		jmp	type_bigeg
 16140                                  
 16141                                  	; Now we do case by case output formatting
 16142                                  type_c:
 16143                                  		; character output
 16144 00002487 E88202                  		call	getwordarg	; AX = word argument
 16145                                  		;lea	di,[bp-369] ;  PC-DOS 7.0 FDISK.COM
 16146 0000248A 8DBEECFD                		lea	di,[output_buff]
 16147 0000248E 16                      		push	ss
 16148 0000248F 07                      		pop	es		; es:di points to buffer	
 16149 00002490 AA                      		stosb
 16150 00002491 4F                      		dec	di		; mov es:[di],al
 16151 00002492 B90100                  		mov	cx,1		; length of 1
 16152 00002495 E9E801                  		jmp	justify		; goto general justify/output
 16153                                  type_s:
 16154                                  	; string output -- must handle both far and near
 16155                                  	; we have to know how much of the string to print -- rule is
 16156                                  	; all of it if precision is default, min(precision, length) if
 16157                                  	; precision given. We do it simply as one computation here
 16158                                  	; because default precision stored as -1, which we treat
 16159                                  	; as 65535, the longest possible string length.
 16160                                  	; a null ptr is printed as '(null)'
 16161                                  
 16162 00002498 E88502                  		call	getptrarg	; read pointer into es:di
 16163 0000249B 09FF                    		or	di,di		; di == 0?
 16164 0000249D 7512                    		jnz	short s2	; no - a normal string	
 16165 0000249F 8CC0                    		mov	ax,es
 16166 000024A1 09C0                    		or	ax,ax		; es == 0?
 16167 000024A3 750C                    		jnz	short s2	; no - a normal string	
 16168                                  
 16169 000024A5 1E                      		push	ds
 16170 000024A6 07                      		pop	es
 16171 000024A7 BF[55A0]                		mov	di,nullstring ;	"(null)"  ; es:di points to '(null)'
 16172 000024AA 8B0E[5BA0]              		mov	cx,[nullstrlen]	; cx has the length
 16173 000024AE E9CF01                  		jmp	justify		; go to justify routine
 16174                                  s2:
 16175 000024B1 57                      		push	di		; save di
 16176 000024B2 8B4EF4                  		mov	cx,[precision]	; how much of string to scan
 16177 000024B5 E307                    		jcxz	s3		; precision == 0; print nothing
 16178 000024B7 30C0                    		xor	al,al		; scan for '\0'
 16179 000024B9 F2AE                    		repne scasb		; scan string - zero flag set if found
 16180 000024BB 7501                    		jnz	short s3	; no - we scanned exactly precision bytes	
 16181 000024BD 4F                      		dec	di		; yes - point to the null byte
 16182                                  s3:
 16183                                  		; di now points just beyond last byte to print
 16184 000024BE 59                      		pop	cx		; cx has old di
 16185 000024BF 29CF                    		sub	di,cx		; di has count of bytes
 16186 000024C1 87CF                    		xchg	cx,di		; di restored, cx has count of bytes
 16187 000024C3 E9BA01                  		jmp	justify		; goto justify/output
 16188                                  type_n:
 16189                                  		; store count of characters written so far into int/long
 16190                                  		; pointed to by pointer argument.
 16191                                  		; NOTHING IS OUTPUT
 16192                                  
 16193 000024C6 E85702                  		call	getptrarg	; read ptr into es:di
 16194 000024C9 8B46F8                  		mov	ax,[charsout]	; ax = number of characters written
 16195 000024CC AB                      		stosw
 16196                                  		;test	byte [flags1],FL_LONG
 16197 000024CD F646FC10                		test	byte [flags],10h ; FL_LONG ; a long value?
 16198 000024D1 7403                    		jz	short n1	; no - just a short
 16199 000024D3 31C0                    		xor	ax,ax		; clear ax
 16200 000024D5 AB                      		stosw			; store high word (0)
 16201                                  n1:
 16202 000024D6 E93FFE                  		jmp	loopagain	; skip output, go straight to loop top
 16203                                  type_p:
 16204                                  		; write a pointer -- this is complicated by the fact that
 16205                                  		; the pointer could be 2 bytes or 4 bytes on the stack,
 16206                                  		; and that we can output in seg:off or off form.
 16207                                  
 16208                                  		;test	byte [flags1],FL_FAR | FL_LONG
 16209 000024D9 F646FC30                		test	byte [flags],30h ; FL_FAR | FL_LONG
 16210 000024DD 7505                    		jnz	short p4byte	; 4 or 2 bytes on stack?	
 16211 000024DF E82A02                  		call	getwordarg	; get 2 byte ptr in AX
 16212 000024E2 EB39                    		jmp	short pshortfmt	; read 2 bytes implies short format
 16213                                  p4byte:
 16214 000024E4 E82D02                  		call	getlongarg	; get 4 byte ptr into DX:AX
 16215                                  
 16216                                  		;test	byte [flags2],FL_SHORT| FL_NEAR
 16217 000024E7 F646FD18                		test	byte [flags+1],18h ; specified short format?
 16218 000024EB 7530                    		jnz	short pshortfmt	; yes - goto short format
 16219                                  
 16220                                  		; output xxxx:yyyy
 16221                                  
 16222                                  		;mov byte [heaxadd], 'A' - '9' - 1
 16223 000024ED C646FF07                		mov	byte [hexadd],7 ; use uppercase hex	
 16224 000024F1 B91000                  		mov	cx,16		; radix 16
 16225 000024F4 16                      		push	ss
 16226 000024F5 07                      		pop	es		; es point to segment with buffer
 16227 000024F6 52                      		push	dx		; save segment
 16228 000024F7 31D2                    		xor	dx,dx		; no high word
 16229                                  		;lea	di,[bp-361]	; IBM PC-DOS 7.0 FDISK.COM
 16230                                  		;lea	di,buffer[8]	; point to end of offset spot in buffer
 16231 000024F9 8DBEF4FD                		lea	di,[output_buff+8]
 16232 000024FD BE0400                  		mov	si,4		; 4 digit output
 16233 00002500 E88602                  		call	convert		; convert and place in buffer
 16234                                  
 16235 00002503 B91000                  		mov	cx,16		; radix 16 again
 16236                                  		;lea	di,[bp-366]	; IBM PC-DOS 7.0 FDISK.COM
 16237                                  		;lea	di,buffer[3]	; point to end of segment spot in buffer
 16238 00002506 8DBEEFFD                		lea	di,[output_buff+3]
 16239 0000250A 58                      		pop	ax		; ax has segment
 16240 0000250B 31D2                    		xor	dx,dx		; no high word
 16241 0000250D BE0400                  		mov	si,4		; 4 digit output again
 16242 00002510 E87602                  		call	convert		; convert again
 16243                                  
 16244                                  		;mov	byte [bp-365],':'
 16245                                  		;mov	buffer[4], ':'	; put colon in middle
 16246 00002513 C686F0FD3A              		mov	byte [output_buff+4],':'
 16247 00002518 B90900                  		mov	cx,9		; 9 character output
 16248 0000251B EB18                    		jmp	short p1	; skip near ptr code	
 16249                                  pshortfmt:
 16250                                  		;  output xxxx:yyyy
 16251                                  
 16252                                  		;mov	byte [hexadd],'A' - '9' - 1 ; use uppercase hex
 16253 0000251D C646FF07                		mov	byte [hexadd],7
 16254 00002521 B91000                  		mov	cx,16		; radix 16
 16255 00002524 16                      		push	ss
 16256 00002525 07                      		pop	es		; es point to segment with buffer
 16257 00002526 31D2                    		xor	dx,dx		; no high word
 16258                                  		;lea	di,[bp-366]
 16259                                  		;lea	di,buffer[3]	
 16260 00002528 8DBEEFFD                		lea	di,[output_buff+3] ; point to end of 4 byte buffer
 16261 0000252C BE0400                  		mov	si,4		; 4 character output format
 16262 0000252F E85702                  		call	convert		; convert it into buffer
 16263 00002532 B90400                  		mov	cx,4		; 4 character text length
 16264                                  p1:
 16265                                  		;lea	di,[bp+369]
 16266                                  		;lea	di, buffer	; di points to buffer, cx has length
 16267 00002535 8DBEECFD                		lea	di,[output_buff]
 16268 00002539 E94401                  		jmp	justify		; justify and output
 16269                                  type_bigeg:
 16270                                  		;inc	word [capexp]	; capitalize exponent
 16271 0000253C FE46EE                  		inc	byte [capexp]
 16272                                  type_efg:
 16273                                  		; floating point conversion -- this is relatively easy
 16274                                  		; because cfltcvt does the work for us
 16275                                  
 16276                                  		;or	flags1, FL_SIGNED ; this is a signed conversion
 16277 0000253F 804EFC40                		or	byte [flags],40h
 16278 00002543 8A46FE                  		mov	al,[char]
 16279 00002546 0C20                    		or	al,20h		; convert to lower case
 16280 00002548 98                      		cbw			; ax has format char is lower case
 16281 00002549 89C6                    		mov	si,ax
 16282 0000254B 837EF400                		cmp	word [precision],0
 16283 0000254F 7F12                    		jg	short f2	; precision > 0, no adjustment	
 16284 00002551 7407                    		je	short f1	; precision = 0
 16285 00002553 C746F40600              		mov	word [precision],6 ; precision < 0, make it 6 (default)
 16286 00002558 EB09                    		jmp	short f2
 16287                                  f1:
 16288                                  		;cmp	ax,'g'
 16289 0000255A 3C67                    		cmp	al,'g'
 16290 0000255C 7505                    		jne	short f2
 16291 0000255E C746F40100              		mov	word [precision],1
 16292                                  f2:
 16293                                  		;lea	di,[bp+369]	; PC--DOS 7.0 FDISK.COM
 16294                                  		;lea	di,buffer	; ss:di points to buffer
 16295 00002563 8DBEECFD                		lea	di,[output_buff]
 16296                                  
 16297 00002567 FF76EE                  		push	word [capexp]
 16298 0000256A FF76F4                  		push	word [precision]
 16299                                  
 16300 0000256D 56                      		push	si		; si has format character
 16301                                  ;if sizeD
 16302                                  ;	push	ss
 16303                                  ;else
 16304                                  ;ifdef _WINDOWS			; buffer in ss
 16305                                  ;	push	ss
 16306                                  ;endif
 16307                                  ;endif
 16308 0000256E 57                      		push	di		; push pointer to buffer
 16309                                  ;
 16310                                  ;if sizeD
 16311                                  ;	push	word ptr (arglist[2])
 16312                                  ;else
 16313                                  ;ifdef _WINDOWS			; args in ss
 16314                                  ;	push	ss
 16315                                  ;endif
 16316                                  ;endif
 16317 0000256F FF7606                  		push	word [arglist]	; push arglist
 16318                                  
 16319                                  		;test	flags2,FL_LONGDOUBLE
 16320 00002572 F646FD04                		test	byte [flags+1],4 ; FL_LONGDOUBLE
 16321 00002576 740A                    		jz	short f3
 16322                                  		;call	_cldcvt
 16323                                  		; 14/12/2018
 16324 00002578 FF16[68A0]              		call	word [_cldcvt]	; do long double conversion
 16325 0000257C 8346060A                		add	word [arglist],10  ; go to next argument 
 16326                                  					   ; (long double is 10 bytes)
 16327 00002580 EB08                    		jmp	short f4
 16328                                  f3:
 16329                                  		;call	_cfltcvt
 16330                                  		; 14/12/2018
 16331 00002582 FF16[62A0]              		call	word [_cfltcvt]	; do float conversion	
 16332 00002586 83460608                		add	word [arglist],8 ; go to next argument 
 16333                                  					; (double is 8 bytes)
 16334                                  f4:
 16335                                  ;if sizeD
 16336                                  ;	add	sp, 14
 16337                                  ;else
 16338                                  ;ifdef _WINDOWS
 16339                                  ;	add	sp, 14
 16340                                  ;else
 16341 0000258A 83C40A                  		add	sp,10		; pop arguments
 16342                                  ;endif
 16343                                  		;test	flags1,FL_ALTERNATE	; alternate form?
 16344 0000258D F646FC80                		test	byte [flags],80h ; FL_ALTERNATE
 16345 00002591 740E                    		jz	short f5
 16346 00002593 837EF400                		cmp	word [precision],0 ; precision == 0?
 16347 00002597 7508                    		jne	short f5	; no - skip decimal forcing
 16348                                  	
 16349                                  	; '#' flag and precision == 0 => need to stick in a decimal point
 16350                                  ;if sizeD
 16351                                  ;	push	ss
 16352                                  ;else
 16353                                  ;	ifdef _WINDOWS
 16354                                  ;		push	ss
 16355                                  ;	endif
 16356                                  ;endif
 16357 00002599 57                      		push	di		; push pointer to buffer
 16358                                  		;call	_forcdecpt	; force decimal point
 16359                                  		; 14/12/2018
 16360 0000259A FF16[66A0]              		call	word [_forcdecpt]
 16361                                  ;if sizeD
 16362                                  ;	add	sp, 4
 16363                                  ;else
 16364                                  ;	ifdef _WINDOWS
 16365                                  ;		add	sp, 4
 16366                                  ;	else
 16367 0000259E 83C402                  		add	sp,2		; restore stack
 16368                                  ;	endif				
 16369                                  ;endif
 16370                                  
 16371                                  f5:
 16372 000025A1 83FE67                  		cmp	si,'g'		; g format?
 16373 000025A4 750F                    		jne	short f6	; no - skip zero cropping
 16374                                  		
 16375                                  		;test	flags,FL_ALTERNATE ; '#' given
 16376 000025A6 F746FC8000              		test	word [flags],80h
 16377 000025AB 7508                    		jnz	short f6	; yes - skip zero cropping
 16378                                  
 16379                                  		; 'g' format and no '#' flag => crop trailing zeros
 16380                                  ;if sizeD
 16381                                  ;	push	ss
 16382                                  ;else
 16383                                  ;	ifdef _WINDOWS
 16384                                  ;		push	ss
 16385                                  ;	endif
 16386                                  ;endif
 16387 000025AD 57                      		push	di		; push pointer to buffer
 16388                                  		;call	_cropzeros ; crop zeros if g fmt and not alternate form
 16389                                  		; 14/12/2018
 16390 000025AE FF16[64A0]              		call	word [_cropzeros]
 16391                                  ;if sizeD
 16392                                  ;	add	sp, 4
 16393                                  ;else
 16394                                  ;	ifdef _WINDOWS
 16395                                  ;		add	sp, 4
 16396                                  ;	else
 16397 000025B2 83C402                  		add	sp,2
 16398                                  ;	endif
 16399                                  ;endif					; restore stack
 16400                                  
 16401                                  f6:
 16402 000025B5 16                      		push	ss
 16403 000025B6 07                      		pop	es		; es:di points to text to output
 16404 000025B7 26803D2D                		cmp	byte [es:di], '-' ; are we negative?
 16405 000025BB 7505                    		jne	short f7	; no -- skip it
 16406 000025BD 47                      		inc	di		; go beyond negative sign
 16407                                  		;or	flags2,FL_NEGATIVE ; record negative number
 16408 000025BE 804EFD01                		or	byte [flags+1],1
 16409                                  f7:
 16410                                  		; now we must find length of buffer to output
 16411 000025C2 B9FFFF                  		mov	cx,0FFFFh
 16412 000025C5 57                      		push	di
 16413 000025C6 B000                    		mov	al,0		; scan for null byte
 16414 000025C8 F2AE                    		repne scasb	; do the scan -- now di point just after null byte
 16415 000025CA 4F                      		dec	di		; di points to null byte
 16416 000025CB 59                      		pop	cx		; cx has old di
 16417 000025CC 29CF                    		sub	di,cx		; di has length of string
 16418 000025CE 87CF                    		xchg	cx,di		; cx has length, di restored
 16419 000025D0 E9AD00                  		jmp	justify		; done -- justify/output it
 16420                                  type_d:		
 16421                                  		;'d' and 'i' and synonymns
 16422                                  doprnt_case_i_d:
 16423                                  type_i:		; signed decimal output
 16424                                  		;or	flags1, FL_SIGNED
 16425 000025D3 804EFC40                		or	byte [flags],40h
 16426                                  type_u:	
 16427                                  		; unsigned decimal output
 16428 000025D7 C646FA0A                		mov	byte [radix],10
 16429 000025DB EB35                    		jmp	short int_out	; go to common int formatting
 16430                                  type_bigx:
 16431                                  		; unsigned hex output, with ABCDEF
 16432                                  		;mov	hexadd,'A' - '9' - 1	; hex conversion constant, uppercase
 16433 000025DD C646FF07                		mov	byte [hexadd],7
 16434 000025E1 EB04                    		jmp	short dohex
 16435                                  type_x:
 16436                                  		; unsigned hex output, with abcdef
 16437                                  		;mov	hexadd,'a' - '9' - 1	; hex conversion constant, lowercase
 16438 000025E3 C646FF27                		mov	byte [hexadd],27h
 16439                                  
 16440                                  dohex:		
 16441                                  		;test	flags1,FL_ALTERNATE ; alternate form?
 16442 000025E7 F646FC80                		test	byte [flags],80h
 16443 000025EB 7411                    		jz	short hex1		; no -- skip alternate formatting
 16444 000025ED C746F00200              		mov	word [prfxlen],2	; yes, store 2-byte hex prefix
 16445 000025F2 C646F230                		mov	byte [prefix],'0'
 16446                                  		;mov	dl,'x'-'a'+'9'+1
 16447 000025F6 B251                    		mov	dl,51h
 16448 000025F8 0256FF                  		add	dl,[hexadd]
 16449 000025FB 8856F3                  		mov	byte [prefix+1],dl	; byte 2: 'x' or 'X' as appropriate
 16450                                  hex1:
 16451 000025FE C646FA10                		mov	byte [radix],16
 16452 00002602 EB0E                    		jmp	short int_out
 16453                                  type_o:
 16454                                  		; unsigned octal output
 16455                                  		;test	flags1,FL_ALTERNATE	; alternate form?
 16456 00002604 F646FC80                		test	byte [flags],80h
 16457 00002608 7404                    		jz	short oct1		; no - skip alternate formatting
 16458                                  		;or	flags2,FL_FORCEOCTAL	; force leading zero
 16459 0000260A 804EFD02                		or	byte [flags+1],2
 16460                                  oct1:
 16461 0000260E C646FA08                		mov	byte [radix],8
 16462                                  
 16463                                  int_out:
 16464                                  	; Here is the common integer formatting routine.
 16465                                  	; Note that shorts and ints are the same, so we ignore FL_SHORT
 16466                                  
 16467                                  ; 1.  Read argument from arglist; if a word, extend into long as appropriate
 16468                                  		;test	flags1,FL_LONG		; read long word?
 16469 00002612 F646FC10                		test	byte [flags],10h
 16470 00002616 7405                    		jz	short int1		; no - read short word
 16471 00002618 E8F900                  		call	getlongarg		; read long word into dx:ax
 16472 0000261B EB0E                    		jmp	short int3
 16473                                  int1:
 16474 0000261D E8EC00                  		call	getwordarg		; read short word into ax
 16475                                  		;test	flags1,FL_SIGNED	; signed argument?
 16476 00002620 F646FC40                		test	byte [flags],40h
 16477 00002624 7403                    		jz	short int2		; no - goto zeroextend
 16478 00002626 99                      		cwd				; sign extend ax -> dx:ax
 16479 00002627 EB02                    		jmp	short int3
 16480                                  int2:
 16481 00002629 31D2                    		xor	dx, dx
 16482                                  
 16483                                  ; 2.  If signed and negative, make it positive and remember the negative sign
 16484                                  int3:
 16485                                  		;test	flags1,FL_SIGNED	; signed argument?
 16486 0000262B F646FC40                		test	byte [flags],40h
 16487 0000262F 740F                    		jz	short int4		; no - skip this
 16488 00002631 09D2                    		or	dx,dx			; dx:ax < 0?
 16489 00002633 7D0B                    		jge	short int4		; no - skip this
 16490                                  		;or	flags2,FL_NEGATIVE	; remember negative sign
 16491 00002635 804EFD01                		or	byte [flags+1],1
 16492 00002639 F7D8                    		neg	ax
 16493 0000263B 83D200                  		adc	dx, 0
 16494 0000263E F7DA                    		neg	dx			; dx:ax = -dx:ax
 16495                                  
 16496                                  ; 3.  Check the precision value for default; non-default turns off 0 flag (ANSI)
 16497                                  int4:
 16498 00002640 837EF400                		cmp	word [precision],0	; precision < 0 (default)
 16499 00002644 7D07                    		jge	short int5		; no - go turn off zero flag
 16500 00002646 C746F40100              		mov	word [precision],1	; default precision = 1
 16501 0000264B EB04                    		jmp	short int6		; don't turn off zero flag
 16502                                  int5:
 16503                                  		;and	flags1, (NOT FL_LEADZERO) AND 0FFh ; (~FL_LEADZERO) & 0FFh
 16504 0000264D 8066FCF7                		and	byte [flags],0F7h ; turn off zero flags when explicit precision
 16505                                  
 16506                                  ; 4.  Check if data is zero, if so, turn off hex prefix
 16507                                  int6:
 16508 00002651 89C3                    		mov	bx,ax
 16509 00002653 09D3                    		or	bx,dx			; dx:ax == 0?
 16510 00002655 7505                    		jnz	short int7		; no - skip this
 16511 00002657 C746F00000              		mov	word [prfxlen],0	; kill hex prefix for zero data
 16512                                  
 16513                                  ; 5.  Convert data into ASCII characters
 16514                                  int7:
 16515                                  		;lea	di,[bp-21]	 ; IBM PC-DOS 7.0 FDISK.COM
 16516                                  		;lea	di,buffer[BUFSIZE-1]
 16517 0000265C 8D7EEB                  		lea	di,[output_buff+BUFSIZE-1] ; [output_buf+511] = [bp-(532-511)]
 16518 0000265F 16                      		push	ss
 16519 00002660 07                      		pop	es			; es:di points at end of buffer
 16520 00002661 8A4EFA                  		mov	cl,[radix]
 16521 00002664 30ED                    		xor	ch,ch			; cx = radix
 16522 00002666 8B76F4                  		mov	si,[precision]		; si = precision
 16523 00002669 E81D01                  		call	convert			; Convert that sucker:
 16524                                  						; cx has length, es:di points to digits
 16525                                  ; 6.  Force a leading 0 if FL_FORCEOCTAL set
 16526                                  		;test	flags2,FL_FORCEOCTAL	; FORCEOCTAL flags set?
 16527 0000266C F646FD02                		test	byte  [flags+1],2
 16528 00002670 740E                    		jz	short int8		; nope - don't do it
 16529 00002672 E306                    		jcxz	addzero			; if printing no digits, add a zero
 16530 00002674 26803D30                		cmp	byte [es:di],'0'	; first digit already a 0?
 16531 00002678 7406                    		je	short int8		; yep - don't do it
 16532                                  addzero:
 16533 0000267A 4F                      		dec	di			; move back a digit
 16534 0000267B 26C60530                		mov	byte [es:di],'0'	; add in a zero
 16535 0000267F 41                      		inc	cx			; increase number of bytes displayed
 16536                                  ; 7.  Jump to general justify/output procedure
 16537                                  int8:
 16538                                  		;;jmp	short $+2
 16539                                  		;jmp	short justify
 16540                                  
 16541                                  justify:
 16542                                  ; here we justify and output the results
 16543                                  
 16544                                  ; Find any prefix that we need to stick on -- note that hex prefixes
 16545                                  ; have already been done.
 16546                                  
 16547 00002680 B80100                  		mov	ax,1 ; 07/12/2018
 16548                                  
 16549                                  		;test	flags1,FL_SIGNED	; is this a signed conversion?	
 16550 00002683 F646FC40                		test	byte [flags],40h
 16551 00002687 7429                    		jz	short just3		; if not, no sign prefix
 16552                                  		;test	flags2,FL_NEGATIVE	; a negative number?
 16553                                  		;test	byte [flags+1],1
 16554 00002689 8446FD                  		test	[flags+1],al ; 1
 16555 0000268C 7409                    		jz	short just1		; no - skip
 16556 0000268E C646F22D                		mov	byte [prefix], '-'	; prefix is '-'
 16557                                  		;mov	word [prfxlen],1	; prefix length = 1
 16558 00002692 8946F0                  		mov	[prfxlen],ax
 16559 00002695 EB1B                    		jmp	short just3
 16560                                  just1:
 16561                                  		;test	flags1,FL_SIGN		; forcing sign?
 16562                                  		;test	byte [flags],1
 16563 00002697 8446FC                  		test	[flags],al ; 1
 16564 0000269A 7409                    		jz	short just2
 16565                                  		;mov	prefix[0],'+'		; prefix is '+' (can't be negative)
 16566 0000269C C646F22B                		mov	byte [prefix],'+'
 16567                                  		;mov	word [prfxlen],1	; prefix length = 1
 16568 000026A0 8946F0                  		mov	[prfxlen],ax
 16569 000026A3 EB0D                    		jmp	short just3		; skip next test ('+' overrides ' ')
 16570                                  just2:
 16571                                  		;test	flags1,FL_SIGNSP	; forcing sign with blank?
 16572 000026A5 F646FC02                		test	byte [flags],2
 16573 000026A9 7407                    		jz	short just3
 16574                                  		;mov	prefix[0],' '		; prefix is ' ' (can't be negative)
 16575 000026AB C646F220                		mov	byte [prefix],' '
 16576                                  		;mov	word [prfxlen],1	; prefix length = 1
 16577 000026AF 8946F0                  		mov	[prfxlen],ax
 16578                                  just3:
 16579 000026B2 8B46F6                  		mov	ax,[fldwidth]		; subtract length of text
 16580 000026B5 29C8                    		sub	ax,cx			; ax = width - textlen - prfxlen
 16581 000026B7 2B46F0                  		sub	ax,[prfxlen]
 16582 000026BA 7D02                    		jge	short just4		; ax < 0? skip next
 16583 000026BC 31C0                    		xor	ax,ax			; yes - ax = 0
 16584                                  
 16585                                  ; ax now has amount of padding, it's just a question of where to put it
 16586                                  ; es:di points to output string, cx is length
 16587                                  
 16588                                  just4:
 16589 000026BE 06                      		push	es
 16590 000026BF 57                      		push	di
 16591 000026C0 51                      		push	cx			; save these for now...
 16592                                  
 16593                                  		;test	flags1,FL_LEFT OR FL_LEADZERO ; left justify or lead zero?
 16594 000026C1 F646FC0C                		test	byte [flags],0Ch ; FL_LEFT | FL_LEADZERO
 16595 000026C5 7507                    		jnz	short just5
 16596 000026C7 89C1                    		mov	cx,ax
 16597 000026C9 B220                    		mov	dl,' '
 16598 000026CB E8A600                  		call	outpad
 16599                                  just5:
 16600 000026CE 50                      		push	ax			; save pad count
 16601 000026CF 16                      		push	ss
 16602 000026D0 07                      		pop	es
 16603 000026D1 8D7EF2                  		lea	di,[prefix]		; es:di points to prefix
 16604 000026D4 8B4EF0                  		mov	cx,[prfxlen]		; length of prefix
 16605 000026D7 E88100                  		call	outch			; write prefix
 16606 000026DA 58                      		pop	ax			; recover pad count
 16607                                  
 16608                                  		;test	flags1,FL_LEADZERO	; use leading zeros?
 16609 000026DB F646FC08                		test	byte [flags],8
 16610 000026DF 740D                    		jz	short just6		; no - don't put padding now
 16611                                  		;test	flags1,FL_LEFT		; left justifying?
 16612 000026E1 F646FC04                		test	byte [flags],4
 16613 000026E5 7507                    		jnz	short just6		; yes - skip ('-' overrides '0')
 16614                                  
 16615 000026E7 89C1                    		mov	cx,ax			; amount of padding
 16616 000026E9 B230                    		mov	dl,'0'			; pad with zeros
 16617 000026EB E88600                  		call	outpad			; write the zero padding
 16618                                  just6:
 16619 000026EE 59                      		pop	cx	
 16620 000026EF 5F                      		pop	di
 16621 000026F0 07                      		pop	es			; recover pointer to text
 16622                                  
 16623 000026F1 50                      		push	ax			; save pad count
 16624 000026F2 E86600                  		call	outch			; output the text
 16625 000026F5 58                      		pop	ax			; recover pad count
 16626                                  
 16627                                  		;test	flags1,FL_LEFT		; left justify?
 16628 000026F6 F646FC04                		test	byte [flags],4
 16629 000026FA 7407                    		jz	short just7		; no - don't put padding now
 16630                                  		
 16631 000026FC 89C1                    		mov	cx,ax			; amount of padding
 16632 000026FE B220                    		mov	dl,' '			; pad with spaces
 16633 00002700 E87100                  		call	outpad
 16634                                  
 16635                                  ; Now, everything has been output, just go back to start of loop.
 16636                                  
 16637                                  just7:
 16638 00002703 E912FC                  		jmp	loopagain
 16639                                  
 16640                                  ; 07/12/2018
 16641                                  ; PC-DOS 7.0 FDISK.COM segment 0, offset 7C13h
 16642                                  
 16643                                  output_return:
 16644 00002706 5F                      		pop	di
 16645 00002707 5E                      		pop	si
 16646 00002708 89EC                    		mov	sp,bp
 16647 0000270A 5D                      		pop	bp
 16648 0000270B C3                      		retn
 16649                                  
 16650                                  ; ------------------------------------------------------ ;
 16651                                  ; END OF MAIN PROCEDURE -- NOW WE HAVE LOCAL SUBROUTINES ;
 16652                                  ; USED BY THE MAIN PROCEDURE.				 ;
 16653                                  ; ------------------------------------------------------ ;
 16654                                  
 16655                                  ; 07/12/2018
 16656                                  ; PC-DOS 7.0 FDISK.COM segment 0, offset 7B4Eh
 16657                                  
 16658                                  ; ----------------------------------------------------------------------------
 16659                                  
 16660                                  ; Read a word argument from the argument list
 16661                                  ; Bumps arglist by 2 bytes
 16662                                  ;   PARAMETERS: none
 16663                                  ;   RETURNS:	word read in AX
 16664                                  ;   TRASHES:	ES, SI
 16665                                  
 16666                                  ;getwordarg:
 16667                                  ;if sizeD
 16668                                  ;	les	si, arglist
 16669                                  ;	lods	word ptr es:[si]	; ax = *arglist++
 16670                                  ;else
 16671                                  ;	mov	si, arglist
 16672                                  ;	lodsw				; ax = *arglist++
 16673                                  ;endif
 16674                                  ;	mov	word ptr (arglist), si	; store arglist back
 16675                                  ;	retn				; return near
 16676                                  
 16677                                  getwordarg:
 16678                                  		;mov	si,[bp+8]
 16679 0000270C 8B7606                  		mov	si,[arglist]	; (%define arglist bp+8)
 16680 0000270F AD                      		lodsw			; ax = *arglist++
 16681                                  		;mov	[bp+8],si
 16682 00002710 897606                  		mov	[arglist],si	; store arglist back
 16683 00002713 C3                      		retn			; return near
 16684                                  
 16685                                  ; ----------------------------------------------------------------------------
 16686                                  
 16687                                  ; Read a long argument from the argument list
 16688                                  ; Bumps arglist by 4 bytes
 16689                                  ;   PARAMETERS: none
 16690                                  ;   RETURNS:	long read in DX:AX
 16691                                  ;   TRASHES:	ES, SI
 16692                                  
 16693                                  ;getlongarg:
 16694                                  ;if sizeD
 16695                                  ;	les	si, arglist
 16696                                  ;	lods	word ptr es:[si]	; ax = *arglist++  (LSW)
 16697                                  ;	mov	dx, ax			; dx = LSW
 16698                                  ;	lods	word ptr es:[si]	; ax = *arglist++  (MSW)
 16699                                  ;	xchg	dx, ax			; ax = LSW, dx = MSW
 16700                                  ;else
 16701                                  ;	mov	si, arglist
 16702                                  ;	lodsw				; ax = *arglist++  (LSW)
 16703                                  ;	mov	dx, ax			; dx = LSW
 16704                                  ;	lodsw				; ax = *arglist++  (MSW)
 16705                                  ;	xchg	dx, ax			; ax = LSW, dx = MSW
 16706                                  ;endif
 16707                                  ;	mov	word ptr (arglist), si	; store arglist back
 16708                                  ;	retn				; return near
 16709                                  
 16710                                  getlongarg:
 16711                                  		;mov	si,[bp+8]
 16712 00002714 8B7606                  		mov	si,[arglist]	; (%define arglist bp+8)
 16713 00002717 AD                      		lodsw			; ax = *arglist++  (LSW)
 16714 00002718 89C2                    		mov	dx,ax		; dx = LSW
 16715 0000271A AD                      		lodsw			; ax = *arglist++  (MSW)
 16716 0000271B 92                      		xchg	ax,dx		; ax = LSW, dx = MSW
 16717                                  		;mov	[bp+8],si
 16718 0000271C 897606                  		mov	[arglist],si	; store arglist back
 16719 0000271F C3                      		retn			; return near
 16720                                  
 16721                                  ; ----------------------------------------------------------------------------
 16722                                  
 16723                                  ; Read a pointer from the argument list into es:di
 16724                                  ; Size of pointer read depends on FL_FAR flag, if near, then
 16725                                  ; ds is used as segment.
 16726                                  ; Note that we don't need to check FL_NEAR, because in C/L models,
 16727                                  ; near ptrs are passed as far, and in S/M models near is default
 16728                                  ; anyway.
 16729                                  ;
 16730                                  ;   PARAMETERS: none
 16731                                  ;   RETURNS:	ES:DI holds pointer read
 16732                                  ;   TRASHES:	AX, DX
 16733                                  
 16734                                  getptrarg:
 16735                                  		;test	flags1, FL_FAR	; a far pointer
 16736 00002720 F646FC20                		test	byte [bp-4],20h
 16737 00002724 7408                    		jz	short rp1	; no - goto near pointer code
 16738 00002726 E8EBFF                  		call	getlongarg	; read far pointer into dx:ax
 16739 00002729 8EC2                    		mov	es,dx
 16740 0000272B 89C7                    		mov	di,ax		; put far pointer into es:di
 16741 0000272D C3                      		retn
 16742                                  rp1:
 16743 0000272E E8DBFF                  		call	getwordarg	; read near pointer into ax
 16744 00002731 89C7                    		mov	di,ax
 16745 00002733 09C0                    		or	ax,ax		; read NULL ptr?
 16746 00002735 7503                    		jnz	short rp2	; no - store ds
 16747 00002737 8EC0                    		mov	es,ax		; make long NULL ptr (ax = 0)
 16748 00002739 C3                      		retn
 16749                                  rp2:
 16750 0000273A 1E                      		push	ds
 16751 0000273B 07                      		pop	es		; put near pointer into es:di
 16752 0000273C C3                      		retn
 16753                                  
 16754                                  ; ----------------------------------------------------------------------------
 16755                                  
 16756                                  ;  Put a character on the output string -- this is the
 16757                                  ;  equivalent of putc_lk(c, f)
 16758                                  ;    PARAMETERS: AL = character to write
 16759                                  ;    RETURNS:	 AX == -1: error, AX == 0: no error
 16760                                  ;    TRASHED:	 BX
 16761                                  
 16762                                  ;putc: ; 13/12/2018
 16763                                  
 16764                                  ;ifdef CPRFLAG		; put on console instead of to stream
 16765                                  ;
 16766                                  ;	cbw				; sign-extend char to AX
 16767                                  ;	push	es			; save es
 16768                                  ;	push	cx
 16769                                  ;	push	dx			; save cx and dx
 16770                                  ;	push	ax			; parameter: char to write
 16771                                  ;	callcrt _putch			; normal put console character
 16772                                  ;	add	sp, 2			; restore stack
 16773                                  ;	pop	dx
 16774                                  ;	pop	cx			; restore cx, dx
 16775                                  ;	pop	es			; restore es
 16776                                  ;	cmp	ax, -1			; error
 16777                                  ;	je	putchret		; yes - return -1 already in ax
 16778                                  ;	xor	ax, ax			; no - return 0
 16779                                  ;
 16780                                  ;putchret:
 16781                                  ;	retn
 16782                                  ;
 16783                                  ;else ; not CPRFLAG  -  now do normal stream output
 16784                                  
 16785                                  		;13/12/2018
 16786                                  		;cbw
 16787                                  
 16788                                  ;if sizeD
 16789                                  ;	push	es			; save es
 16790                                  ;	push	di			; save di
 16791                                  ;	les	bx, stream		; es:bx is file *
 16792                                  ;	dec	es:[bx]._cnt		; --f->_cnt
 16793                                  ;	js	flush			; out of buffer, must flush
 16794                                  ;	mov	di, word ptr es:[bx]._ptr
 16795                                  ;	inc	word ptr es:[bx]._ptr
 16796                                  ;	mov	es, word ptr es:[bx+2]._ptr ; es:di = *f->_ptr++
 16797                                  ;	stosb				; mov es:[di],al - store byte
 16798                                  ;noerrret:
 16799                                  ;	xor	ax, ax			; no error
 16800                                  ;putcret:
 16801                                  ;	pop	di
 16802                                  ;	pop	es			; restore di, es
 16803                                  ;	retn				; return
 16804                                  ;
 16805                                  ;flush:
 16806                                  ;	push	cx
 16807                                  ;	push	dx			; save cx and dx
 16808                                  ;	push	es
 16809                                  ;	push	bx			; push FILE *
 16810                                  ;	push	ax			; character to write
 16811                                  ;	callcrt _flsbuf 		; call _flsbuf(f, c)
 16812                                  ;	add	sp, 6
 16813                                  ;	pop	dx
 16814                                  ;	pop	cx			; restore cx and dx
 16815                                  ;	cmp	ax,-1			; check for an error
 16816                                  ;	jne	noerrret		; no error, go clear ax and return
 16817                                  ;	jmp	short putcret		; return with ax = -1
 16818                                  ;
 16819                                  ;else ; not DataSize
 16820                                  
 16821                                  		; 13/12/2018
 16822                                  		;push	di
 16823                                  		;;mov	bx,[bp+4]
 16824                                  		;mov	bx,[stream]	; (%define stream bp+4)
 16825                                  		;			; bx is FILE *
 16826                                  		;;dec	[bx]._cnt	; dec f->_cnt
 16827                                  		;;dec	word [bx+_strbuf._cnt]
 16828                                  		;dec	word [bx+2]
 16829                                  		;js	short flush
 16830                                  		;;mov	di,[bx]._ptr
 16831                                  		;;inc	[bx]._ptr	; di = f->_ptr++
 16832                                  		;mov	di,[bx]
 16833                                  		;inc	word [bx]	; [bx+_strbuf.ptr] = _strbuf_ptr 	
 16834                                  		;mov	[di],al		; store byte to write
 16835                                  ;noerrret:
 16836                                  		;xor	ax, ax		; no error
 16837                                  ;putcret:
 16838                                  		;pop	di		; restore di
 16839                                  		;retn			; return
 16840                                  ;flush:
 16841                                  		;push	es
 16842                                  		;push	cx
 16843                                  		;push	dx		; save es, cx and dx
 16844                                  		;push	bx		; push file *
 16845                                  		;push	ax		; character to write
 16846                                  		;call	_flsbuf		; call _flsbuf(f, c)
 16847                                  		;add	sp,4		
 16848                                  		;pop	dx
 16849                                  		;pop	cx
 16850                                  		;pop	es		; restore es, cx and dx
 16851                                  		;cmp	ax,-1		; check for an error
 16852                                  		;jnz	short noerrret	; no error, go clear ax and return
 16853                                  		;jmp	short putcret	; return with ax = -1
 16854                                  
 16855                                  putc:
 16856                                  		; 13/12/2018
 16857                                  		; AL = character to be written
 16858 0000273D FF0E[E4CC]              		dec	word [outbuf_cnt]
 16859 00002741 7908                    		jns	short putc_1 
 16860                                  		; Write count was ZERO (end of buffer)
 16861                                  putc_0:		
 16862 00002743 FF06[E4CC]              		inc	word [outbuf_cnt]
 16863 00002747 30C0                    		xor	al,al ; 0 (end)
 16864 00002749 F9                      		stc
 16865                                  		; zf = 1 and cf = 1
 16866 0000274A C3                      		retn
 16867                                  putc_1:	
 16868 0000274B 06                      		push	es
 16869                                  		;push	di
 16870 0000274C 1E                      		push	ds
 16871 0000274D 07                      		pop	es
 16872 0000274E 8B3E[E2CC]              		mov	di,[outbuf_ptr]
 16873 00002752 AA                      		stosb
 16874 00002753 893E[E2CC]              		mov	[outbuf_ptr],di
 16875                                  		;pop	di
 16876 00002757 07                      		pop	es
 16877 00002758 08C0                    		or	al,al ; cf = 0, zf = 1 if al = 0
 16878 0000275A C3                      		retn
 16879                                  
 16880                                  ; ----------------------------------------------------------------------------
 16881                                  
 16882                                  ;  Output a character string:
 16883                                  ;  Put a (NOT zero-terminated) string of character on the output
 16884                                  ;  stream, and increment the charsout variable
 16885                                  ;    PARAMETERS:  ES:DI points to string to output
 16886                                  ;		  CX specifies count of characters to output
 16887                                  ;    RETURNS:	  none
 16888                                  ;    TRASHES:	  AX, BX, CX, SI, ES
 16889                                  ;    NOTES:	  The DI is used to accumulate possible error returns from
 16890                                  ;		  the calls to putc. However, it is also saved and restored.
 16891                                  
 16892                                  outch:
 16893 0000275B E316                    		jcxz	outchret	; no characters to write - return
 16894 0000275D 89FE                    		mov	si,di		; DS:SI points to string
 16895                                  		;add	[bp-8],	cx
 16896                                  		;add	charsout,cx	; increase count of characters out
 16897 0000275F 014EF8                  		add	[charsout],cx	; (%define charsout bp-8)
 16898                                  		; 13/12/2018
 16899                                  		;push	di
 16900                                  		;xor	di,di
 16901                                  out1:
 16902                                  		;;lods	byte ptr es:[si] ; al = next char to write, inc si
 16903 00002762 26                      		es
 16904 00002763 AC                      		lodsb
 16905 00002764 E8D6FF                  		call	putc		; write that character
 16906                                  		;or	di,ax		; or the return value into di
 16907 00002767 7205                    		jc	short out2 ; 13/12/2018
 16908 00002769 7408                    		jz	short outchret ; 13/12/2018	
 16909 0000276B E2F5                    		loop	out1		; write another character if more
 16910                                  		;or	di,di		; did an error occur?
 16911                                  		;pop	di		; restore di
 16912                                  		;jz	short outchret	; no, return
 16913 0000276D C3                      		retn	; 13/12/2018
 16914                                  out2:
 16915                                  		;mov	word [bp-8],0FFFFh
 16916                                  		;mov	charsout,-1	; yes - signal error, then return
 16917 0000276E C746F8FFFF              		mov	word [charsout],-1
 16918                                  outchret:
 16919 00002773 C3                      		retn
 16920                                  
 16921                                  ; ----------------------------------------------------------------------------
 16922                                  
 16923                                  ; Output a string of identical characters for padding
 16924                                  ;   PARAMETERS:   DL = character to write, CX = count of character to write
 16925                                  ;   RETURNS:	  none
 16926                                  ;   TRASHES:	  AX, BX, CX
 16927                                  ;   NOTES:	  The DI is used to accumulate possible error returns from
 16928                                  ;		  the calls to putc. However, it is also saved and restored.
 16929                                  
 16930                                  outpad:
 16931 00002774 E312                    		jcxz	outpadret	; no character to write -- return
 16932                                  		; 13/12/2018
 16933                                  		;add	[bp-8],cx
 16934                                  		;add	charsout,cx	; increase count of chars written
 16935 00002776 014EF8                  		add	[charsout],cx	; (%define charsout bp-8)
 16936                                  		; 13/12/2018
 16937                                  		;push	di
 16938                                  		;xor	di,di		; clear di
 16939 00002779 88D0                    		mov	al,dl ; 13/12/2018
 16940                                  outpad1:
 16941                                  		;mov	al,dl		; al = char to write
 16942 0000277B E8BFFF                  		call	putc		; write that character
 16943                                  		;or	di,ax		; or the return value into di
 16944 0000277E 7203                    		jc	short outpad2 ; 13/12/2018 
 16945 00002780 E2F9                    		loop	outpad1		; write another character if more
 16946                                  		
 16947                                  		;or	di,di		; did an error occur?
 16948                                  		;pop	di		; restore di
 16949                                  		;jz	short outpadret	; no - return
 16950                                  
 16951 00002782 C3                      		retn	; 13/12/2018
 16952                                  outpad2:
 16953                                  		;mov	word [bp-8],0FFFFh
 16954                                  		;mov	charsout,-1	; yes - signal error
 16955 00002783 C746F8FFFF              		mov	word [charsout],-1
 16956                                  outpadret:
 16957 00002788 C3                      		retn
 16958                                  
 16959                                  ; ----------------------------------------------------------------------------
 16960                                  
 16961                                  ; Convert a unsigned long to a character string.
 16962                                  ;   PARAMETERS: DX:AX is number to convert
 16963                                  ;		CX is radix to convert with
 16964                                  ;		ES:DI points to where to store LAST digit
 16965                                  ;		SI is min digits to store (pad with zero until this length)
 16966                                  ;   (N.B. Converting 0 with SI==0 gives blank result: this is correct
 16967                                  ;    and ANSI mandated)
 16968                                  ;
 16969                                  ;   RETURNS:	ES:DI points to first digit
 16970                                  ;		CX is length of digit string
 16971                                  ;
 16972                                  ;   TRASHES:	AX, BX, DX, DI, SI
 16973                                  ;
 16974                                  ;
 16975                                  ;   This algorithm does a 32 bit divided by 16 bit division to
 16976                                  ;   get 32 bit quotient and 16 bit remainder like this (lifted from xtoa.asm):
 16977                                  ;
 16978                                  ;	   h/r	:  (h%r:l)/r
 16979                                  ;      --------------
 16980                                  ;   r  )   h	:   l
 16981                                  ;	 r(h/r)
 16982                                  ;	 ------------
 16983                                  ;	  h%r	:   l
 16984                                  ;	 r((h%r:l)/r)
 16985                                  ;	 ------------
 16986                                  ;		((h%r):l)%r  (REMAINDER)
 16987                                  
 16988                                  convert:
 16989 00002789 FD                      		std			; store string in reverse
 16990 0000278A 57                      		push	di		; save di
 16991 0000278B 93                      		xchg	ax,bx		; dx = h, bx = l
 16992                                  conv1:
 16993 0000278C 09F6                    		or	si,si		; si == 0?
 16994 0000278E 7F08                    		jg	short conv2	; count > 0 => keep converting
 16995 00002790 09DB                    		or	bx,bx		; l == 0?
 16996 00002792 7504                    		jnz	short conv2	; l != 0 => keep converting
 16997 00002794 09D2                    		or	dx,dx		; h == 0?
 16998                                  		;jnz	short conv2	; h != 0 => keep converting	
 16999                                  		;jmp	short conv4	; stop converting (h:l==0, count<=0);
 17000 00002796 741A                    		jz	short conv4	
 17001                                  conv2:
 17002 00002798 92                      		xchg	ax,dx		; ax = h, bx = l
 17003 00002799 31D2                    		xor	dx,dx		; ax = h, bx = l, dx = 0
 17004 0000279B F7F1                    		div	cx		; ax = h/r, dx = h%r, bx = l
 17005 0000279D 93                      		xchg	ax,bx		; dx = h%r, ax = l, bx = h/r
 17006 0000279E F7F1                    		div	cx		; ax = (h%r:l)/r, dx = (h%r:l)%r, bx = h/r
 17007                                  					; bx:ax = (h:l)/r, dx = (h:l)%r
 17008 000027A0 92                      		xchg	ax,dx		; bx:dx = (h:l)/r, ax = (h:l)%r
 17009 000027A1 87D3                    		xchg	dx,bx		; dx:bx = (h:l)/r, ax = (h:l)%r
 17010                                  
 17011                                  ; now al has x%r, which is the numeric value of the digit -- now convert to ASCII
 17012                                  
 17013 000027A3 0430                    		add	al,'0'
 17014 000027A5 3C39                    		cmp	al,'9'		; a normal digit?
 17015 000027A7 7603                    		jbe	short conv3	; yes, store it
 17016                                  		;add	al,[bp-1]
 17017                                  		;add	al,hexadd	; no, convert to hex
 17018 000027A9 0246FF                  		add	al,[hexadd]	; (%define hexadd bp-1)
 17019                                  conv3:
 17020 000027AC AA                      		stosb			; *(es:di) = al, --di
 17021 000027AD 89D0                    		mov	ax,dx		; ax:bx = (h:l)/r
 17022 000027AF 4E                      		dec	si		; stored a digit, subtract from count
 17023 000027B0 EBDA                    		jmp	short conv1
 17024                                  	
 17025                                  	; OK, we're done -- set up the return values
 17026                                  conv4:
 17027 000027B2 59                      		pop	cx		; cx has orginal di
 17028 000027B3 29F9                    		sub	cx,di		; subtract di now, get string length
 17029 000027B5 47                      		inc	di		; point to first digit
 17030 000027B6 FC                      		cld			; must keep direction flag cleared
 17031 000027B7 C3                      		retn
 17032                                  
 17033                                  ;return to user
 17034                                  ;
 17035                                  ;output_return:
 17036                                  ;	pop	di
 17037                                  ;	pop	si			; pop register variables
 17038                                  ;	mov	sp,bp
 17039                                  ;	pop	bp
 17040                                  ;	retn
 17041                                  
 17042                                  ; ----------------------------------------------------------------------------
 17043                                  
 17044                                  ; 07/12/2018 
 17045                                  
 17046                                  ;***
 17047                                  ;chkstk.asm - C stack checking routine
 17048                                  ;
 17049                                  ;	Copyright (c) 1985-1992 Microsoft Corporation, All Rights Reserved
 17050                                  ;
 17051                                  ;Purpose:
 17052                                  ;	Provides support for automatic stack checking in C procedures
 17053                                  ;	when stack checking is enabled.
 17054                                  ;
 17055                                  ;*******************************************************************************
 17056                                  
 17057                                  ;***
 17058                                  ;_chkstk - check stack upon procedure entry
 17059                                  ;
 17060                                  ;Purpose:
 17061                                  ;	Provide stack checking on procedure entry.
 17062                                  ;
 17063                                  ;	[LLIBCDLL.LIB NOTE: Unlike other LLIBCDLL routines, DS != DGROUP
 17064                                  ;	when chkstk() is called.]
 17065                                  ;
 17066                                  ;Entry:
 17067                                  ;	AX = size of local frame
 17068                                  ;
 17069                                  ;Exit:
 17070                                  ;	SP = new stackframe if successful
 17071                                  ;
 17072                                  ;Uses:
 17073                                  ;	AX, BX, CX, DX
 17074                                  ;
 17075                                  ;Exceptions:
 17076                                  ;	Gives out of memory error and aborts if there is not enough
 17077                                  ;	stack space for the routine.
 17078                                  ;
 17079                                  ;*******************************************************************************
 17080                                  
 17081                                  _chkstk:
 17082 000027B8 59                      		pop	cx		; get return offset
 17083 000027B9 89E3                    		mov	bx,sp		; bx = current SP
 17084 000027BB 29C3                    		sub	bx,ax		; bx = new position
 17085 000027BD 720A                    		jc	short OMerr
 17086                                  		;cmp	bx,[_STKHQQ]	; SP - AX : _STKHQQ (for heap/stack)
 17087 000027BF 3B1E[60A0]              		cmp	bx,[end_of_bss]
 17088 000027C3 7204                    		jb	short OMerr	; error - out of memory
 17089 000027C5 89DC                    		mov	sp,bx
 17090 000027C7 FFE1                    		jmp	cx		; return to cx
 17091                                  OMerr:
 17092                                  		;push	cx
 17093                                  		;xor	ax,ax
 17094                                  		;jmp	_amsg_exit	; give stack overflow and die
 17095                                  		; 14/12/2018
 17096 000027C9 1E                      		push	ds
 17097 000027CA FF36[C49E]              		push	word [stackerror_msg_off]
 17098 000027CE E849EE                  		call	display
 17099                                  		;pop	bx
 17100                                  		;pop	bx
 17101 000027D1 B0FF                    		mov	al,255
 17102 000027D3 E992D8                  		jmp	_exit
 17103                                  
 17104                                  ; ----------------------------------------------------------------------------
 17105                                  ; tdisplay.c (FDISK, MSDOS 6.0, 1991)	
 17106                                  ; ----------------------------------------------------------------------------
 17107                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 07/12/2018)
 17108                                  
 17109                                  ;void get_letters()                                                   /*C32*/
 17110                                  ;BEGIN                                                                /*C32*/
 17111                                  ;                                                                     /*C32*/
 17112                                  ;unsigned char i,j;                                                   /*C32*/
 17113                                  ;unsigned char active_primary_count;                                  /*C32*/
 17114                                  ;unsigned char pri_part;                                              /*C32*/
 17115                                  ;                                                                     /*C32*/
 17116                                  ;    /* initialize next letter */                                     /*C32*/
 17117                                  ;    next_letter = c(SEA);                                            /*C32*/
 17118                                  ;                                                                     /*C32*/
 17119                                  ;    /* get primary DOS partition letters on all drives */            /*C32*/
 17120                                  ;    for (j = uc(0); j < number_of_drives; j++)                       /*C32*/
 17121                                  ;       BEGIN                                                         /*C32*/
 17122                                  ;        /* initialize variables */                                   /*C32*/
 17123                                  ;        primary_partition_count = 0;                                 /*C32*/
 17124                                  ;        active_primary_count = 0;                                    /*C32*/
 17125                                  ;        pri_part = 0xFF;                                             /*C32*/
 17126                                  ;                                                                     /*C32*/
 17127                                  ;        /* Look at all partitions */                                 /*C32*/
 17128                                  ;        for (i=u(0); i < u(4); i++)                                  /*C32*/
 17129                                  ;           BEGIN                                                     /*C32*/
 17130                                  ;            /* Compute e letter */                                   /*C32*/
 17131                                  ;            if ( (part_table[j][i].sys_id == DOS12) ||               /*C32*/
 17132                                  ;                 (part_table[j][i].sys_id == DOS16) ||               /*C32*/
 17133                                  ;                 (part_table[j][i].sys_id == DOSNEW)   )             /*C32*/
 17134                                  ;               BEGIN                                                 /*C32*/
 17135                                  ;                part_table[j][i].drive_letter = c(' ');              /*C32*/
 17136                                  ;                if ((primary_partition_count == 0) ||                /*C32*/
 17137                                  ;                    ((part_table[j][i].boot_ind == 0x80) &&          /*C32*/
 17138                                  ;                     (active_primary_count == 0)))                   /*C32*/
 17139                                  ;                    pri_part = c(i);                                 /*C32*/
 17140                                  ;                if (part_table[j][i].boot_ind == 0x80)               /*C32*/
 17141                                  ;                    active_primary_count++;                          /*C32*/
 17142                                  ;                primary_partition_count++;                           /*C32*/
 17143                                  ;               END                                                   /*C32*/
 17144                                  ;           END                                                       /*C32*/
 17145                                  ;        if ((pri_part != 0xFF) && (next_letter <= c('Z')))           /*C32*/
 17146                                  ;            part_table[j][pri_part].drive_letter = next_letter++;    /*C32*/
 17147                                  ;       END                                                           /*C32*/
 17148                                  ;                                                                     /*C32*/
 17149                                  ;    /* get logical DOS drive letters on all drives */                /*C32*/
 17150                                  ;    for (j = uc(0); j < number_of_drives; j++)                       /*C32*/
 17151                                  ;       BEGIN                                                         /*C32*/
 17152                                  ;       /* Look at all partitions */                                  /*C32*/
 17153                                  ;        for (i=u(0); i < u(23); i++)                                 /*C32*/
 17154                                  ;           BEGIN                                                     /*C32*/
 17155                                  ;            /* Set drive letter */                                   /*C32*/
 17156                                  ;            if ( (ext_table[j][i].sys_id == DOS12) ||                /*C32*/
 17157                                  ;                 (ext_table[j][i].sys_id == DOS16) ||                /*C32*/
 17158                                  ;                 (ext_table[j][i].sys_id == DOSNEW)   )              /*C32*/
 17159                                  ;                if (next_letter <= c('Z'))                           /*C32*/
 17160                                  ;                    ext_table[j][i].drive_letter = next_letter++;    /*C32*/
 17161                                  ;                else                                                 /*C32*/
 17162                                  ;                    ext_table[j][i].drive_letter = c(' ');           /*C32*/
 17163                                  ;           END                                                       /*C32*/
 17164                                  ;       END                                                           /*C32*/
 17165                                  ;                                                                     /*C32*/
 17166                                  ;    /* get enhdisk partition letters on all drives */                /*C32*/
 17167                                  ;    for (j = uc(0); j < number_of_drives; j++)                       /*C32*/
 17168                                  ;       BEGIN                                                         /*C32*/
 17169                                  ;        /* Look at all active primary partitions */                  /*C32*/
 17170                                  ;        for (i=u(0); i < u(4); i++)                                  /*C32*/
 17171                                  ;           BEGIN                                                     /*C32*/
 17172                                  ;            /* Set drive letter */                                   /*C32*/
 17173                                  ;            if (((part_table[j][i].sys_id == DOS12) ||               /*C32*/
 17174                                  ;                 (part_table[j][i].sys_id == DOS16) ||               /*C32*/
 17175                                  ;                 (part_table[j][i].sys_id == DOSNEW)) &&             /*C32*/
 17176                                  ;                (part_table[j][i].boot_ind == 0x80))                 /*C32*/
 17177                                  ;                if ((part_table[j][i].drive_letter == c(' ')) &&     /*C32*/
 17178                                  ;                    (next_letter <= c('Z')))                         /*C32*/
 17179                                  ;                    part_table[j][i].drive_letter = next_letter++;   /*C32*/
 17180                                  ;           END                                                       /*C32*/
 17181                                  ;        /* Look at all non-active primary partitions */              /*C32*/
 17182                                  ;        for (i=u(0); i < u(4); i++)                                  /*C32*/
 17183                                  ;           BEGIN                                                     /*C32*/
 17184                                  ;            /* Set drive letter */                                   /*C32*/
 17185                                  ;            if (((part_table[j][i].sys_id == DOS12) ||               /*C32*/
 17186                                  ;                 (part_table[j][i].sys_id == DOS16) ||               /*C32*/
 17187                                  ;                 (part_table[j][i].sys_id == DOSNEW)) &&             /*C32*/
 17188                                  ;                (part_table[j][i].boot_ind != 0x80))                 /*C32*/
 17189                                  ;                if ((part_table[j][i].drive_letter == c(' ')) &&     /*C32*/
 17190                                  ;                    (next_letter <= c('Z')))                         /*C32*/
 17191                                  ;                    part_table[j][i].drive_letter = next_letter++;   /*C32*/
 17192                                  ;           END                                                       /*C32*/
 17193                                  ;       END                                                           /*C32*/
 17194                                  ;                                                                     /*C32*/
 17195                                  ;    return;                                                          /*C32*/
 17196                                  ;                                                                     /*C32*/
 17197                                  ;END  
 17198                                  
 17199                                  get_letters:
 17200                                  
 17201                                  	%define gdl_j		bp-8
 17202                                  	%define gdl_i		bp-6
 17203                                  	%define a_primary_count	bp-4
 17204                                  	%define p_part		bp-2
 17205                                  
 17206 000027D6 55                      		push	bp
 17207 000027D7 89E5                    		mov	bp,sp
 17208 000027D9 83EC08                  		sub	sp,8
 17209                                  
 17210                                  		;/* initialize next letter */ 
 17211 000027DC C606[1FA1]43            		mov	byte [next_letter],'C'
 17212                                  
 17213                                  		;/* get primary DOS partition letters on all drives */
 17214                                  		;mov	word [gdl_j],0
 17215 000027E1 C646F800                		mov	byte [gdl_j],0
 17216 000027E5 B12E                    		mov	cl,46  ; *CL* ; 07/12/2018
 17217 000027E7 E98200                  		jmp	gdl_10
 17218                                  gdl_1:
 17219                                  		;/* Compute a letter */  
 17220 000027EA 8A46F8                  		mov	al,[gdl_j]
 17221                                  		;sub	ah,ah
 17222                                  		;shl	ax,1
 17223                                  		;shl	ax,1
 17224 000027ED D0E0                    		shl	al,1
 17225 000027EF D0E0                    		shl	al,1
 17226                                  		;mov	cl,[gdl_i]
 17227                                  		;sub	ch,ch
 17228                                  		;;add	ax,cx
 17229                                  		;add	al,cl
 17230                                  		;mov	cx,46
 17231                                  		;imul	cx
 17232 000027F1 0246FA                  		add	al,[gdl_i]
 17233                                  		;mov	cl,46  ; *CL*
 17234 000027F4 F6E1                    		mul	cl
 17235 000027F6 89C3                    		mov	bx,ax
 17236                                  
 17237 000027F8 80BF[17C4]01            		cmp	byte [part_table_sys_id+bx],1 ; DOS12  ; FAT12	
 17238 000027FD 740E                    		je	short gdl_2
 17239 000027FF 80BF[17C4]04            		cmp	byte [part_table_sys_id+bx],4 ; DOS16  ; FAT16
 17240 00002804 7407                    		je	short gdl_2
 17241 00002806 80BF[17C4]06            		cmp	byte [part_table_sys_id+bx],6 ; DOSNEW ; FAT16 big
 17242 0000280B 752D                    		jne	short gdl_6
 17243                                  gdl_2:
 17244                                  		;mov	al,[gdl_j]
 17245                                  		;sub	ah,ah
 17246                                  		;shl	ax,1
 17247                                  		;shl	ax,1
 17248                                  		;mov	cl,[gdl_i]
 17249                                  		;sub	ch,ch
 17250                                  		;add	ax,cx
 17251                                  		;mov	cx,46
 17252                                  		;imul	cx
 17253                                  		;mov	bx,ax
 17254                                  
 17255                                  		;part_table[j][i].drive_letter = c(' '); 
 17256 0000280D C687[3FC4]20            		mov	byte [part_table_drive_letter+bx],' '
 17257                                  
 17258                                  		; Only one primary dos partition per disk !
 17259                                  
 17260                                  		;if ((primary_partition_count == 0) ||
 17261                                                  ;   ((part_table[j][i].boot_ind == 0x80) &&
 17262                                                  ;   (active_primary_count == 0)))
 17263                                                  ;   pri_part = c(i);                 
 17264                                  
 17265 00002812 803E[CEC3]00            		cmp	byte [primary_partition_count],0
 17266 00002817 760D                    		jna	short gdl_3
 17267 00002819 80BF[12C4]80            		cmp	byte [part_table_boot_ind+bx],80h
 17268 0000281E 750C                    		jne	short gdl_4
 17269 00002820 807EFC00                		cmp	byte [a_primary_count],0 ;active_primary_count
 17270 00002824 7706                    		ja	short gdl_4
 17271                                  gdl_3:
 17272                                  		; Only one primary dos partition per disk !
 17273 00002826 8A46FA                  		mov	al,[gdl_i]
 17274 00002829 8846FE                  		mov	[p_part],al	; primary_part
 17275                                  gdl_4:
 17276                                  		;mov	al,[gdl_j]
 17277                                  		;sub	ah,ah
 17278                                  		;shl	ax,1
 17279                                  		;shl	ax,1
 17280                                  		;mov	cl,[gdl_i]
 17281                                  		;sub	ch,ch
 17282                                  		;add	ax,cx
 17283                                  		;mov	cx,46
 17284                                  		;imul	cx
 17285                                  		;mov	bx,ax
 17286                                  
 17287                                  		;if (part_table[j][i].boot_ind == 0x80)
 17288                                                  ;    active_primary_count++;
 17289                                                  ;primary_partition_count++;            
 17290                                  
 17291 0000282C 80BF[12C4]80            		cmp	byte [part_table_boot_ind+bx],80h
 17292 00002831 7503                    		jne	short gdl_5
 17293 00002833 FE46FC                  		inc	byte [a_primary_count]
 17294                                  gdl_5:
 17295 00002836 FE06[CEC3]              		inc	byte [primary_partition_count]
 17296                                  gdl_6:
 17297 0000283A FE46FA                  		inc	byte [gdl_i]
 17298                                  gdl_7:
 17299                                  		;/* Look at all partitions */
 17300                                  		;for (i=u(0); i < u(4); i++)
 17301                                  
 17302                                  		; if i < 4 -- NEXT -- 
 17303 0000283D 807EFA04                		cmp	byte [gdl_i],4
 17304                                  		;jnb	short gdl_8
 17305                                  		;jmp	gdl_1
 17306 00002841 72A7                    		jb	short gdl_1 ; next
 17307                                  gdl_8:
 17308                                  		;if ((pri_part != 0xFF) && (next_letter <= c('Z')))
 17309                                  		;   part_table[j][pri_part].drive_letter = next_letter++;
 17310                                  
 17311 00002843 807EFEFF                		cmp	byte [p_part],0FFh
 17312 00002847 7420                    		je	short gdl_9
 17313 00002849 803E[1FA1]5A            		cmp	byte [next_letter],'Z'
 17314 0000284E 7F19                    		jg	short gdl_9
 17315                                  
 17316 00002850 8A46F8                  		mov	al,[gdl_j]
 17317                                  		;sub	ah,ah
 17318                                  		;shl	ax,1
 17319                                  		;shl	ax,1
 17320 00002853 D0E0                    		shl	al,1
 17321 00002855 D0E0                    		shl	al,1
 17322                                  		;mov	cl,[p_part]
 17323                                  		;sub	ch,ch
 17324                                  		;add	ax,cx
 17325                                  		;add	al,cl
 17326                                  		;;mov	cx,46
 17327                                  		;mov	cl,46
 17328                                  		;imul	cx
 17329                                  		;mul	cl
 17330 00002857 0246FE                  		add	al,[p_part]
 17331 0000285A F6E1                    		mul	cl ; CL = 46 ; *CL*
 17332 0000285C 89C3                    		mov	bx,ax
 17333 0000285E A0[1FA1]                		mov	al,[next_letter]
 17334 00002861 8887[3FC4]              		mov	[part_table_drive_letter+bx],al
 17335 00002865 FE06[1FA1]              		inc	byte [next_letter]
 17336                                  gdl_9:
 17337 00002869 FE46F8                  		inc	byte [gdl_j]
 17338                                  gdl_10:
 17339                                  		;/* get primary DOS partition letters on all drives */
 17340                                  		;for (j = uc(0); j < number_of_drives; j++) 
 17341 0000286C A0[D5C3]                		mov	al,[number_of_drives]
 17342 0000286F 3846F8                  		cmp	[gdl_j],al
 17343 00002872 7313                    		jnb	short gdl_11
 17344                                  
 17345                                  		;/* initialize variables */
 17346                                  		;primary_partition_count = 0;
 17347                                  		;active_primary_count = 0;
 17348                                  		;pri_part = 0xFF;     
 17349 00002874 C606[CEC3]00            		mov	byte [primary_partition_count],0
 17350 00002879 C646FEFF                		mov	byte [p_part],0FFh
 17351 0000287D 28C0                    		sub	al,al ; 0
 17352 0000287F 8846FC                  		mov	[a_primary_count],al
 17353                                  
 17354                                  		;/* Look at all partitions */  ; For next disk/drive
 17355 00002882 8846FA                  		mov	[gdl_i],al ; 0
 17356 00002885 EBB6                    		jmp	short gdl_7
 17357                                  gdl_11:		
 17358                                  		;/* get logical DOS drive letters on all drives */
 17359 00002887 C646F800                		mov	byte [gdl_j],0
 17360 0000288B EB46                    		jmp	short gdl_17
 17361                                  gdl_12:
 17362                                  		;mov	al,24
 17363                                  		;mul	byte [gdl_j]
 17364                                  		;mov	cl,[gdl_i]
 17365                                  		;sub	ch,ch
 17366                                  		;add	ax,cx
 17367                                  		;mov	cx,46
 17368                                  		;imul	cx
 17369                                  		;mul	cl
 17370                                  		;mov	bx,ax
 17371                                  
 17372                                  		;ext_table[j][i].drive_letter = c(' ');  
 17373 0000288D C687[77A1]20            		mov	byte [ext_table_drive_letter+bx],' '
 17374                                  gdl_13:	
 17375 00002892 FE46FA                  		inc	byte [gdl_i]
 17376                                  gdl_14:
 17377                                  		;/* Look at all partitions */
 17378                                          	;for (i=u(0); i < u(23); i++) 
 17379                                  
 17380                                  		; if i < 23 ;  -- NEXT --
 17381 00002895 807EFA17                		cmp	byte [gdl_i],23
 17382 00002899 7335                    		jnb	short gdl_16
 17383                                  
 17384 0000289B B018                    		mov	al,24
 17385 0000289D F666F8                  		mul	byte [gdl_j]
 17386                                  			; ax < 192
 17387                                  		;mov	cl,[gdl_i]
 17388                                  		;sub	ch,ch
 17389                                  		;add	ax,cx
 17390 000028A0 0246FA                  		add	al,[gdl_i]
 17391                                  		;mov	cx,46
 17392                                  		;imul	cx
 17393 000028A3 F6E1                    		mul	cl ; CL = 46 ; *CL*
 17394 000028A5 89C3                    		mov	bx,ax
 17395                                  
 17396                                  		;/* Set drive letter */ 
 17397                                  
 17398 000028A7 80BF[4FA1]01            		cmp	byte [ext_table_sys_id+bx],1 ; DOS12
 17399 000028AC 740E                    		je	short gdl_15
 17400 000028AE 80BF[4FA1]04            		cmp	byte [ext_table_sys_id+bx],4 ; DOS16
 17401 000028B3 7407                    		je	short gdl_15
 17402 000028B5 80BF[4FA1]06            		cmp	byte [ext_table_sys_id+bx],6 ; DOSNEW ; FAT16 big
 17403 000028BA 75D6                    		jne	short gdl_13
 17404                                  gdl_15:
 17405                                  		;if (next_letter <= c('Z'))
 17406                                                  ;   ext_table[j][i].drive_letter = next_letter++;
 17407                                                  ;else
 17408                                                  ;   ext_table[j][i].drive_letter = c(' ');    
 17409                                  
 17410 000028BC 803E[1FA1]5A            		cmp	byte [next_letter],'Z'
 17411 000028C1 7FCA                    		jg	short gdl_12
 17412                                  
 17413                                  		;mov	al,24
 17414                                  		;mul	[gdl_j]
 17415                                  		;mov	cl,[gdl_i]
 17416                                  		;sub	ch,ch
 17417                                  		;add	ax,cx
 17418                                  		;mov	cx,46
 17419                                  		;imul	cx
 17420                                  		;mov	bx,ax
 17421                                  
 17422 000028C3 A0[1FA1]                		mov	al,[next_letter]
 17423 000028C6 8887[77A1]              		mov	[ext_table_drive_letter+bx],al
 17424 000028CA FE06[1FA1]              		inc	byte [next_letter]
 17425 000028CE EBC2                    		jmp	short gdl_13
 17426                                  gdl_16:
 17427 000028D0 FE46F8                  		inc	byte [gdl_j]
 17428                                  gdl_17:
 17429                                  		;/* get logical DOS drive letters on all drives */
 17430                                      		;for (j = uc(0); j < number_of_drives; j++)    
 17431                                  		
 17432 000028D3 A0[D5C3]                		mov	al,[number_of_drives]
 17433 000028D6 3846F8                  		cmp	[gdl_j],al
 17434 000028D9 7306                    		jnb	short gdl_18
 17435                                  		
 17436                                  		;/* Look at all partitions */
 17437 000028DB C646FA00                		mov	byte [gdl_i],0
 17438 000028DF EBB4                    		jmp	short gdl_14
 17439                                  gdl_18:
 17440                                  		;/* get enhdisk partition letters on all drives */   	
 17441 000028E1 C646F800                		mov	byte [gdl_j],0
 17442 000028E5 EB51                    		jmp	short gdl_23
 17443                                  gdl_19:
 17444 000028E7 FE46FA                  		inc	byte [gdl_i]  ; next partition
 17445                                  gdl_20:
 17446                                  		;/* Look at all non-active primary partitions */
 17447                                          	;for (i=u(0); i < u(4); i++)    
 17448                                  
 17449 000028EA 807EFA04                		cmp	byte [gdl_i],4
 17450 000028EE 7345                    		jnb	short gdl_22
 17451                                  
 17452 000028F0 8A46F8                  		mov	al,[gdl_j]
 17453                                  		;sub	ah,ah
 17454                                  		;shl	ax,1
 17455                                  		;shl	ax,1
 17456 000028F3 D0E0                    		shl	al,1
 17457 000028F5 D0E0                    		shl	al,1
 17458                                  		;mov	cl,[gdl_i]
 17459                                  		;sub	ch,ch
 17460                                  		;add	ax,cx
 17461 000028F7 0246FA                  		add	al,[gdl_i]
 17462                                  		;mov	cx,46
 17463                                  		;imul	cx
 17464                                  		;mov	bx,ax
 17465 000028FA F6E1                    		mul	cl ; CL = 46 ; *CL*
 17466 000028FC 89C3                    		mov	bx,ax
 17467                                  
 17468                                  		;/* Set drive letter */
 17469                                  		;if (((part_table[j][i].sys_id == DOS12) ||
 17470                                                  ;   (part_table[j][i].sys_id == DOS16) ||
 17471                                                  ;   (part_table[j][i].sys_id == DOSNEW)) &&
 17472                                                  ;   (part_table[j][i].boot_ind != 0x80))       
 17473                                  
 17474 000028FE 80BF[17C4]01            		cmp	byte [part_table_sys_id+bx],1 ; DOS12	
 17475 00002903 740E                    		je	short gdl_21
 17476 00002905 80BF[17C4]04            		cmp	byte [part_table_sys_id+bx],4 ; DOS16
 17477 0000290A 7407                    		je	short gdl_21
 17478 0000290C 80BF[17C4]06            		cmp	byte [part_table_sys_id+bx],6 ; DOSNEW ; FAT16 big
 17479 00002911 75D4                    		jne	short gdl_19
 17480                                  gdl_21:
 17481                                  		;mov	al,[gdl_j]
 17482                                  		;sub	ah,ah
 17483                                  		;shl	ax,1
 17484                                  		;shl	ax,1
 17485                                  		;mov	cl,[gdl_i]
 17486                                  		;sub	ch,ch
 17487                                  		;add	ax,cx
 17488                                  		;mov	cx,46
 17489                                  		;imul	cx
 17490                                  		;mov	bx,ax
 17491                                  
 17492                                  		;if ((part_table[j][i].drive_letter == c(' ')) &&
 17493                                                  ;   (next_letter <= c('Z')))
 17494                                                  ;   part_table[j][i].drive_letter = next_letter++;
 17495                                  
 17496 00002913 80BF[12C4]80            		cmp	byte [part_table_boot_ind+bx],80h
 17497 00002918 74CD                    		je	short gdl_19
 17498                                  
 17499 0000291A 80BF[3FC4]20            		cmp	byte [part_table_drive_letter+bx],' '
 17500 0000291F 75C6                    		jne	short gdl_19
 17501 00002921 803E[1FA1]5A            		cmp	byte [next_letter],'Z'
 17502 00002926 7FBF                    		jg	short gdl_19
 17503                                  
 17504 00002928 A0[1FA1]                		mov	al,[next_letter]
 17505 0000292B 8887[3FC4]              		mov	[part_table_drive_letter+bx],al
 17506 0000292F FE06[1FA1]              		inc	byte [next_letter]
 17507 00002933 EBB2                    		jmp	short gdl_19
 17508                                  gdl_22:
 17509 00002935 FE46F8                  		inc	byte [gdl_j]
 17510                                  gdl_23:
 17511                                  		;/* get enhdisk partition letters on all drives */   
 17512                                  		;for (j = uc(0); j < number_of_drives; j++)
 17513                                  
 17514 00002938 A0[D5C3]                		mov	al,[number_of_drives]
 17515 0000293B 3846F8                  		cmp	[gdl_j],al
 17516 0000293E 7357                    		jnb	short gdl_27
 17517                                  
 17518                                  		;/* Look at all active primary partitions */
 17519                                        		;for (i=u(0); i < u(4); i++)     
 17520 00002940 C646FA00                		mov	byte [gdl_i],0
 17521                                  gdl_24:
 17522 00002944 8A46F8                  		mov	al,[gdl_j]
 17523                                  		;sub	ah,ah
 17524                                  		;shl	ax,1
 17525                                  		;shl	ax,1
 17526 00002947 D0E0                    		shl	al,1
 17527 00002949 D0E0                    		shl	al,1
 17528                                  		;mov	cl,[gdl_i]
 17529                                  		;sub	ch,ch
 17530                                  		;add	ax,cx
 17531 0000294B 0246FA                  		add	al,[gdl_i]
 17532                                  		;mov	cx,46
 17533                                  		;imul	cx
 17534 0000294E F6E1                    		mul	cl ; CL = 46 ; *CL*
 17535 00002950 89C3                    		mov	bx,ax
 17536                                  
 17537                                  		;/* Set drive letter */
 17538                                              
 17539                                  		;if (((part_table[j][i].sys_id == DOS12) ||
 17540                                                  ;   (part_table[j][i].sys_id == DOS16) ||
 17541                                                  ;   (part_table[j][i].sys_id == DOSNEW)) && 
 17542                                                  ; (part_table[j][i].boot_ind == 0x80))    
 17543                                  
 17544 00002952 80BF[17C4]01            		cmp	byte [part_table_sys_id+bx],1 ; DOS12  ; FAT12	
 17545 00002957 740E                    		je	short gdl_25
 17546 00002959 80BF[17C4]04            		cmp	byte [part_table_sys_id+bx],4 ; DOS16  ; FAT16
 17547 0000295E 7407                    		je	short gdl_25
 17548 00002960 80BF[17C4]06            		cmp	byte [part_table_sys_id+bx],6 ; DOSNEW ; FAT16 big
 17549 00002965 7520                    		jne	short gdl_26
 17550                                  gdl_25:
 17551                                  		;mov	al,[gdl_j]
 17552                                  		;sub	ah,ah
 17553                                  		;shl	ax,1
 17554                                  		;shl	ax,1
 17555                                  		;mov	cl,[gdl_i]
 17556                                  		;sub	ch,ch
 17557                                  		;add	ax,cx
 17558                                  		;mov	cx,46
 17559                                  		;imul	cx
 17560                                  		;mov	bx,ax
 17561                                  
 17562 00002967 80BF[12C4]80            		cmp	byte [part_table_boot_ind+bx],80h
 17563 0000296C 7519                    		jne	short gdl_26
 17564                                  
 17565                                  		;if ((part_table[j][i].drive_letter == c(' ')) &&
 17566                                                  ;    (next_letter <= c('Z')))
 17567                                                  ;    part_table[j][i].drive_letter = next_letter++; 
 17568                                  
 17569 0000296E 80BF[3FC4]20            		cmp	byte [part_table_drive_letter+bx],' '
 17570 00002973 7512                    		jne	short gdl_26
 17571 00002975 803E[1FA1]5A            		cmp	byte [next_letter],'Z'
 17572 0000297A 7F0B                    		jg	short gdl_26
 17573 0000297C A0[1FA1]                		mov	al,[next_letter]
 17574 0000297F 8887[3FC4]              		mov	[part_table_drive_letter+bx],al
 17575 00002983 FE06[1FA1]              		inc	byte [next_letter]
 17576                                  gdl_26:
 17577 00002987 FE46FA                  		inc	byte [gdl_i]
 17578 0000298A 807EFA04                		cmp	byte [gdl_i],4
 17579 0000298E 72B4                    		jb	short gdl_24 ; next disk/drive
 17580                                  
 17581                                  		;/* Look at all non-active primary partitions */ 
 17582 00002990 C646FA00                		mov	byte [gdl_i],0
 17583 00002994 E953FF                  		jmp	gdl_20
 17584                                  gdl_27:
 17585 00002997 89EC                    		mov	sp,bp
 17586 00002999 5D                      		pop	bp
 17587 0000299A C3                      		retn
 17588                                  
 17589                                  ; ----------------------------------------------------------------------------
 17590                                  ; space.c (FDISK, MSDOS 6.0, 1991)	
 17591                                  ; ----------------------------------------------------------------------------
 17592                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 07/12/2018)
 17593                                  
 17594                                  ;void sort_part_table(size)
 17595                                  ;
 17596                                  ;char size;
 17597                                  ;
 17598                                  ;BEGIN
 17599                                  ;
 17600                                  ;char  changed;
 17601                                  ;char  temp;
 17602                                  ;char   i;
 17603                                  ;
 17604                                  ;       /* Init the sorting parameters */
 17605                                  ;       for (i=c(0); i < size; i++)                               /* AC000 */
 17606                                  ;          BEGIN
 17607                                  ;           sort[i] = i;
 17608                                  ;          END
 17609                                  ;
 17610                                  ;       /* Do a bubble sort */
 17611                                  ;       changed = TRUE;
 17612                                  ;
 17613                                  ;       /* Sort until we don't do a swap */
 17614                                  ;       while (changed)
 17615                                  ;
 17616                                  ;          BEGIN
 17617                                  ;           changed = FALSE;
 17618                                  ;           for (i=c(1); i < size; i++)                           /* AC000 */
 17619                                  ;              BEGIN
 17620                                  ;
 17621                                  ;               /* Does the partition entry start before the previous one, or */
 17622                                  ;               /* is it empty (0 ENTRY). If empty, it automatically gets shoved */
 17623                                  ;               /* to the front, if the previous entry isn't also empty */
 17624                                  ;
 17625                                  ;               if ((part_table[cur_disk][sort[i]].end_cyl < part_table[cur_disk][sort[i-1]].end_cyl)
 17626                                  ;                  || ((part_table[cur_disk][sort[i]].num_sec == ul(0))
 17627                                  ;                  &&  (part_table[cur_disk][sort[i-1]].num_sec != ul(0))))  /* AC000 */
 17628                                  ;
 17629                                  ;                  BEGIN
 17630                                  ;                   /* Swap the order indicators */
 17631                                  ;                   temp = sort[i-1];
 17632                                  ;                   sort[i-1] = sort[i];
 17633                                  ;                   sort[i] = temp;
 17634                                  ;
 17635                                  ;                /* printf("\nI-1 =%d\n",part_table[cur_disk][sort[i-1]].start_cyl);*/
 17636                                  ;                /* printf("I =%d\n",part_table[cur_disk][sort[i]].start_cyl);*/
 17637                                  ;                /* printf("Sort[i-1] = %d\n",sort[i-1]);*/
 17638                                  ;                /* printf("Sort[i] = %d\n",sort[i]); */
 17639                                  ;                /* wait_for_ESC(); */
 17640                                  ;
 17641                                  ;                   /* indicate we did a swap */
 17642                                  ;                   changed = TRUE;
 17643                                  ;                  END
 17644                                  ;              END
 17645                                  ;          END
 17646                                  ;       return;
 17647                                  ;END
 17648                                  
 17649                                  sort_part_table:
 17650                                  				     ; 12/12/2018	
 17651                                  	;%define sort_changed	bp-6    ; ch
 17652                                  	;%define sort_i		bp-4    ; bx
 17653                                  	;%define sort_temp	bp-2    ; ah
 17654                                  	;%define sort_count	bp+4    ; cl
 17655                                  
 17656                                  		; 12/12/2018
 17657                                  		;push	bp
 17658                                  		;mov	bp,sp
 17659                                  		;sub	sp,6
 17660                                  		
 17661                                  		;push	di
 17662                                  		;push	si
 17663                                  
 17664                                  		; CL = sort count ; 12/12/2018
 17665                                  
 17666                                  		;/* Init the sorting parameters */
 17667                                  		;for (i=c(0); i < size; i++)     
 17668                                  		
 17669                                  		;mov	word [sort_i],0
 17670 0000299B 31DB                    		xor	bx,bx ; 0 ; 12/12/2018
 17671 0000299D EB06                    		jmp	short sortpt_2
 17672                                  sortpt_1:
 17673                                  		;mov	al,[sort_i]
 17674                                  		;cbw
 17675                                  		
 17676                                  		;mov	ax,[sort_i] ; 12/12/2018
 17677                                  		;mov	bx,ax
 17678                                  		
 17679                                  		;mov	[bx+sort],al
 17680 0000299F 889F[E2C3]              		mov	[bx+sort],bl ; 12/12/2018		
 17681                                  
 17682                                  		;inc	byte [sort_i]
 17683 000029A3 FEC3                    		inc	bl ; 12/12/2018
 17684                                  sortpt_2:
 17685                                  		;mov	al,[sort_count] ; size
 17686                                  		;cmp	[sort_i],al	; i < size
 17687                                  		;jl	short sortpt_1
 17688                                  		
 17689                                  		; 12/12/2018
 17690                                  		; CL = sort count
 17691 000029A5 38CB                    		cmp	bl,cl
 17692 000029A7 7CF6                    		jl	short sortpt_1
 17693                                  
 17694                                  		;/* Do a bubble sort */
 17695                                  		;changed = TRUE;
 17696                                  
 17697                                  		;mov	byte [sort_changed],1
 17698 000029A9 EB04                    		jmp	short sortpt_4 ; 07/12/2018
 17699                                  sortpt_3:
 17700                                  		;/* Sort until we don't do a swap */
 17701                                          	;while (changed)
 17702                                  
 17703                                  		;cmp	byte [sort_changed],0
 17704                                  		;;jne	short sortpt_4
 17705                                  		;;jmp	sortpt_8
 17706                                  		;jna	short sortpt_8 ; 07/12/2018
 17707                                  		; 12/12/2018
 17708 000029AB 08ED                    		or	ch,ch ; sort changed ?
 17709 000029AD 7455                    		jz	short sortpt_8 ; no.
 17710                                  sortpt_4:
 17711                                  		;changed = FALSE;
 17712                                              	;for (i=c(1); i < size; i++) 
 17713                                  
 17714                                  		;mov	byte [sort_changed],0
 17715 000029AF 30ED                    		xor	ch,ch	; 12/12/2018
 17716                                  		
 17717                                  		;mov	byte [sort_i],1
 17718 000029B1 B301                    		mov	bl,1 ; 12/12/2018
 17719                                  
 17720 000029B3 B22E                    		mov	dl,46 ; *DL*  ; 07/12/2018
 17721 000029B5 EB02                    		jmp	short sortpt_6
 17722                                  sortpt_5:
 17723                                  		;inc	byte [sort_i]
 17724 000029B7 FEC3                    		inc	bl ; 12/12/2018
 17725                                  sortpt_6:
 17726                                  		;mov	al,[sort_count] ; size
 17727                                  		;cmp	[sort_i],al	; i < size
 17728                                  		;jge	short sortpt_3
 17729                                  
 17730                                  		; 12/12/2018
 17731                                  		; CL = sort count
 17732 000029B9 38CB                    		cmp	bl,cl
 17733 000029BB 7DEE                    		jge	short sortpt_3
 17734                                  
 17735                                  		;mov	al,[cur_disk]
 17736                                  		;cbw
 17737                                  		;shl	ax,1
 17738                                  		;shl	ax,1
 17739                                  		;mov	cx,ax
 17740                                  
 17741                                  		;mov	cl,[cur_disk] ; 07/12/2018
 17742                                  		;shl	cl,1
 17743                                  		;shl	cl,1	; 4 partitions per disk
 17744                                  
 17745                                  		; 12/12/2018
 17746 000029BD 8A36[D4CB]              		mov	dh,[cur_disk]
 17747 000029C1 D0E6                    		shl	dh,1
 17748 000029C3 D0E6                    		shl	dh,1
 17749                                  		
 17750                                  		;mov	al,[sort_i]
 17751                                  		;cbw
 17752                                  		;mov	bx,ax
 17753                                  
 17754                                  		;mov	bx,[sort_i] ; 12/12/2018
 17755                                  
 17756                                  		;mov	al,[bx+sort]
 17757                                  		;cbw
 17758                                  		;add	ax,cx
 17759                                  
 17760 000029C5 8A87[E2C3]              		mov	al,[bx+sort] ; 07/12/2018
 17761                                  		;add	al,cl ; skip partitions of previous drive (other drives)
 17762 000029C9 00F0                    		add	al,dh ; 12/12/2018
 17763                                  
 17764                                  		;mov	si,46
 17765                                  		;imul	si
 17766                                  		;mov	dl,46 ; *DL*
 17767 000029CB F6E2                    		mul	dl
 17768                                  
 17769                                  		;mov	di,ax
 17770                                  		;mov	ax,[part_table_end_cyl+di]
 17771                                  		;mov	dx,ax
 17772 000029CD 89C6                    		mov	si,ax
 17773                                  
 17774                                  		;mov	ax,[part_table_end_cyl+si]
 17775                                  		;mov	di,ax
 17776 000029CF 8BBC[1AC4]              		mov	di,[part_table_end_cyl+si] ; **DI** ; 07/12/2018
 17777                                  
 17778 000029D3 8A87[E1C3]              		mov	al,[bx+sort-1]
 17779                                  
 17780                                  		;cbw
 17781                                  		;add	ax,cx
 17782                                  		;add	al,cl
 17783                                  		;mov	cx,dx
 17784                                  		;imul	si
 17785                                  
 17786                                  		; DH = [cur_disk]
 17787 000029D7 00F0                    		add	al,dh ; 12/12/2018
 17788 000029D9 F6E2                    		mul	dl ; *DL* ; = 46
 17789                                  		;mov	bx,ax
 17790                                  
 17791 000029DB 97                      		xchg	di,ax ; **DI** 12/12/2018
 17792                                  
 17793                                  	;/* Does the partition entry start before the previous one, or */
 17794                                  	;/* is it empty (0 ENTRY). If empty, it automatically gets shoved */
 17795                                  	;/* to the front, if the previous entry isn't also empty */
 17796                                  	;
 17797                                  	;if ((part_table[cur_disk][sort[i]].end_cyl < part_table[cur_disk][sort[i-1]].end_cyl)
 17798                                  	;   || ((part_table[cur_disk][sort[i]].num_sec == ul(0))
 17799                                  	;   &&  (part_table[cur_disk][sort[i-1]].num_sec != ul(0))))
 17800                                  
 17801                                  		;cmp	[part_table_end_cyl+bx],cx
 17802                                  		;cmp	[part_table_end_cyl+bx],di ; **XCHG**
 17803 000029DC 3985[1AC4]              		cmp	[part_table_end_cyl+di],ax ; **XCHG** ; 12/12/2018
 17804 000029E0 7714                    		ja	short sortpt_7 ; pt[cur_disk][sort[i]].end_cyl < pt[cur_disk][sort[i-1]].end_cyl
 17805                                  
 17806                                  		;mov	ax,[part_table_num_sec_hw+di]
 17807 000029E2 8B84[22C4]              		mov	ax,[part_table_num_sec_hw+si] ; part_table[cur_disk][sort[i]].num_sec
 17808                                  		;or	ax,[part_table_num_sec_lw+di]
 17809 000029E6 0B84[20C4]              		or	ax,[part_table_num_sec_lw+si]
 17810 000029EA 75CB                    		jnz	short sortpt_5
 17811                                  		;mov	ax,[part_table_num_sec_hw+bx] ; part_table[cur_disk][sort[i-1]].num_sec
 17812 000029EC 8B85[22C4]              		mov	ax,[part_table_num_sec_hw+di] ; **XCHG** ; 12/12/2018
 17813                                  		;or	ax,[part_table_num_sec_lw+bx]
 17814 000029F0 0B85[20C4]              		or	ax,[part_table_num_sec_lw+di] ; **XCHG** ; 12/12/2018
 17815 000029F4 74C1                    		jz	short sortpt_5
 17816                                  sortpt_7:
 17817                                  		;/* Swap the order indicators */
 17818                                                  ;temp = sort[i-1];
 17819                                                  ;sort[i-1] = sort[i];
 17820                                                  ;sort[i] = temp;
 17821                                  
 17822                                  		;mov	al,[sort_i]
 17823                                  		;cbw
 17824                                  		;mov	bx,ax
 17825                                  		
 17826                                  		; 12/12/2018
 17827                                  		;mov	bx,[sort_i] ; 07/12/2018
 17828                                  
 17829                                  		;mov	al,[bx+sort-1]
 17830                                  		;mov	[sort_temp],al
 17831                                  		;mov	al,[bx+sort]
 17832                                  		;mov	[bx+sort-1],al
 17833                                  		;mov	al,[sort_temp]
 17834                                  		;mov	[bx+sort],al
 17835                                  
 17836                                  		; 12/12/2018
 17837 000029F6 8B87[E1C3]              		mov	ax,[bx+sort-1] ; 12/12/2018
 17838 000029FA 86E0                    		xchg	ah,al
 17839 000029FC 8987[E1C3]              		mov	[bx+sort-1],ax
 17840                                  
 17841                                  		;mov	byte [sort_changed],1
 17842 00002A00 B501                    		mov	ch,1 ; 12/12/2018
 17843 00002A02 EBB3                    		jmp	short sortpt_5
 17844                                  sortpt_8:
 17845                                  		;pop	si
 17846                                  		;pop	di
 17847                                  		
 17848                                  		;mov	sp,bp ; 12/12/2018
 17849                                  		;pop	bp
 17850                                  		
 17851 00002A04 C3                      		retn
 17852                                  
 17853                                  
 17854                                  ; 08/12/2018
 17855                                  
 17856                                  ;void sort_ext_table(size)
 17857                                  ;
 17858                                  ;char size;
 17859                                  ;
 17860                                  ;BEGIN
 17861                                  ;
 17862                                  ;char  changed;
 17863                                  ;char  temp;
 17864                                  ;char i;
 17865                                  ;
 17866                                  ;       /* Init the sorting parameters */
 17867                                  ;
 17868                                  ;       for (i=c(0); i < size; i++)			/* AC000 */
 17869                                  ;          BEGIN
 17870                                  ;           sort[i] = i;
 17871                                  ;          END
 17872                                  ;
 17873                                  ;       /* Do a bubble sort */
 17874                                  ;       changed = TRUE;
 17875                                  ;
 17876                                  ;       /* Sort until we don't do a swap */
 17877                                  ;       while (changed)
 17878                                  ;
 17879                                  ;          BEGIN
 17880                                  ;           changed = FALSE;
 17881                                  ;           for (i=c(1); i < size; i++)			/* AC000 */
 17882                                  ;              BEGIN
 17883                                  ;
 17884                                  ;               if (ext_table[cur_disk][sort[i]].start_cyl < ext_table[cur_disk][sort[i-1]].start_cyl)
 17885                                  ;                  BEGIN
 17886                                  ;
 17887                                  ;                   temp = sort[i-1];
 17888                                  ;                   sort[i-1] = sort[i];
 17889                                  ;                   sort[i] = temp;
 17890                                  ;                   /* indicate we did a swap */
 17891                                  ;                   changed = TRUE;
 17892                                  ;                  END
 17893                                  ;              END
 17894                                  ;          END
 17895                                  ;       return;
 17896                                  ;END
 17897                                  
 17898                                  sort_ext_table:	
 17899                                  
 17900                                  	;;%define swptemp2      bp-10
 17901                                  	;;%define swptemp1      bp-8
 17902                                  
 17903                                  	;%define sortex_changed bp-6  ; ch
 17904                                  	;%define sortex_i       bp-4  ; bx
 17905                                  	;%define sortex_temp    bp-2  ; ah
 17906                                  
 17907                                  	;%define sortex_count   bp+4  ; cl
 17908                                  
 17909                                  		; 12/12/2018
 17910                                  		;push	bp
 17911                                  		;mov	bp,sp
 17912                                  		;;sub	sp,10
 17913                                  		;sub	sp,6 ; 08/12/2018
 17914                                  		
 17915                                  		;push	di
 17916                                  		;push	si
 17917                                  
 17918                                  		; CL = sort count ; 12/12/2018
 17919                                  
 17920                                  		;/* Init the sorting parameters */
 17921                                  		;for (i=c(0); i < size; i++)
 17922                                  	
 17923                                  		;mov	word [sortex_i],0
 17924 00002A05 31DB                    		xor	bx,bx ; 0 ; 12/12/2018
 17925 00002A07 EB06                    		jmp	short sortept_2
 17926                                  sortept_1:
 17927                                  		;;mov	al,[sortex_i]
 17928                                  		;;cbw
 17929                                  		; 12/12/2018
 17930                                  		;mov	ax,[sortex_i]
 17931                                  		;mov	bx,ax
 17932                                  		;mov	[bx+sort],al
 17933                                  		
 17934                                  		;mov	bx,[sortex_i]
 17935 00002A09 889F[E2C3]              		mov	[bx+sort],bl ; 12/12/2018
 17936                                  
 17937                                  		;inc	byte [sortex_i]
 17938 00002A0D FEC3                    		inc	bl ; 12/12/2018
 17939                                  sortept_2:
 17940                                  		;mov	al,[sortex_count] ; size
 17941                                  		;cmp	[sortex_i],al ; if i < size
 17942                                  		;jl	short sortept_1 ; then ..
 17943                                  
 17944                                  		; 12/12/2018
 17945                                  		; CL = sort count
 17946 00002A0F 38CB                    		cmp	bl,cl
 17947 00002A11 72F6                    		jb	short sortept_1 ; 04/01/2019 
 17948                                  
 17949                                  		;/* Do a bubble sort */
 17950                                  		;changed = TRUE;
 17951                                  
 17952                                  		;mov	byte [sortex_changed],1
 17953 00002A13 EB04                    		jmp	short sortept_4
 17954                                  sortept_3:
 17955                                  		;/* Sort until we don't do a swap */
 17956                                  		;while (changed)
 17957                                  
 17958                                  		;cmp	byte [sortex_changed],0
 17959                                  		;je	short sortept_7
 17960                                  		
 17961                                  		; 12/12/2018
 17962 00002A15 08ED                    		or	ch,ch ; sort changed ?
 17963 00002A17 7442                    		jz	short sortept_7 ; no.
 17964                                  sortept_4:
 17965                                  		;changed = FALSE;
 17966                                  		;for (i=c(1); i < size; i++)	
 17967                                  
 17968                                  		;mov	byte [sortex_changed],0
 17969 00002A19 30ED                    		xor	ch,ch	; 12/12/2018
 17970                                  		
 17971                                  		;mov	byte [sortex_i],1
 17972 00002A1B B301                    		mov	bl,1 ; 12/12/2018
 17973                                  
 17974 00002A1D B22E                    		mov	dl,46 ; ***DI*** ; 08/12/2018
 17975 00002A1F EB02                    		jmp	short sortept_6
 17976                                  sortept_5:
 17977                                  		;inc	byte [sortex_i]
 17978 00002A21 FEC3                    		inc	bl ; 12/12/2018
 17979                                  sortept_6:
 17980                                  		;mov	al,[sortex_count] ; size
 17981                                  		;cmp	[sortex_i],al
 17982                                  		;jge	short sortept_3
 17983                                  
 17984                                  		; 12/12/2018
 17985                                  		; CL = sort count
 17986 00002A23 38CB                    		cmp	bl,cl
 17987 00002A25 7DEE                    		jge	short sortept_3
 17988                                  
 17989 00002A27 B018                    		mov	al,24
 17990                                  		;imul	byte [cur_disk]
 17991 00002A29 F626[D4CB]              		mul	byte [cur_disk]
 17992                                  
 17993                                  		;mov	cx,ax  ; skip logical drives on previous disk(s)
 17994                                  		; cl = [current_disk]*24, ch = 0
 17995                                  
 17996                                  		; 12/12/2018
 17997 00002A2D 88C6                    		mov	dh,al
 17998                                  		; dh = [current_disk]*24	
 17999                                  
 18000                                  		;mov	al,[sortex_i]
 18001                                  		;cbw
 18002                                  		;mov	bx,ax
 18003                                  		
 18004                                  		;mov	bx,[sortex_i]		
 18005                                  
 18006                                  		;mov	al,[bx+sort]
 18007                                  		;mov	dx,ax
 18008                                  		;cbw
 18009                                  		;add	ax,cx
 18010                                  
 18011 00002A2F 8A87[E2C3]              		mov	al,[bx+sort]
 18012                                  		;add	al,cl  ; ([current_disk]*24) + [sort[i]] 		
 18013 00002A33 00F0                    		add	al,dh  ; 12/12/2018 
 18014                                  
 18015                                  		;mov	si,ax
 18016                                  
 18017                                  		;mov	al,[bx+sort-1]
 18018                                  		;mov	di,46
 18019                                  		;mov	[swptemp1],ax
 18020                                  		;mov	ax,si
 18021                                  		;mov	[swptemp2],dx
 18022                                  		;imul	di
 18023                                  		;mov	si,ax
 18024                                  
 18025                                  		;mov	dl,46 ; ***DI***
 18026 00002A35 F6E2                    		mul	dl
 18027 00002A37 89C6                    		mov	si,ax
 18028                                  
 18029                                  		;mov	ax,[ext_table_start_cyl+si] ; ept[cur_disk][sort[i]].start_cyl
 18030                                  		;mov	dx,ax
 18031                                  		;mov	al,[swptemp1]
 18032                                  		;cbw
 18033                                  		;add	ax,cx
 18034                                  	
 18035 00002A39 8BBC[4DA1]              		mov	di,[ext_table_start_cyl+si] ; ept[cur_disk][sort[i]].start_cyl
 18036                                  		
 18037 00002A3D 8A87[E1C3]              		mov	al,[bx+sort-1]
 18038                                  		
 18039                                  		; ah = 0
 18040                                  		;add	al,cl ; ; ([current_disk]*24) + [sort[i-i]] 
 18041                                  		;mov	cx,dx
 18042                                  		;imul	di
 18043                                  		
 18044 00002A41 00F0                    		add	al,dh ; 12/12/2018
 18045 00002A43 F6E2                    		mul	dl ; 46
 18046 00002A45 89C6                    		mov	si,ax
 18047                                  		
 18048                                  ;if (ext_table[cur_disk][sort[i]].start_cyl < ext_table[cur_disk][sort[i-1]].start_cyl)
 18049                                  
 18050                                  		;cmp	[ext_table_start_cyl+si],cx
 18051 00002A47 39BC[4DA1]              		cmp	[ext_table_start_cyl+si],di ; ept[cur_disk][sort[i-1]].start_cyl
 18052 00002A4B 76D4                    		jna	short sortept_5
 18053                                  
 18054                                  		;ept[cur_disk][sort[i]].start_cyl < ept[cur_disk][sort[i-1]].start_cyl
 18055                                  
 18056                                  		;/* Swap the order indicators */
 18057                                  		;;mov	al,[swptemp1]
 18058                                  		;mov	al,[bx+sort-1]
 18059                                  		;mov	[sortex_temp],al
 18060                                  		;;mov	al,[swptemp2]
 18061                                  		;mov	al,[bx+sort]	
 18062                                  		;mov	[bx+sort-1],al
 18063                                  		;mov	al,[sortex_temp]
 18064                                  		;mov	[bx+sort],al
 18065                                  		
 18066                                  		; 12/12/2018
 18067 00002A4D 8B87[E1C3]              		mov	ax,[bx+sort-1] ; 12/12/2018
 18068 00002A51 86E0                    		xchg	ah,al
 18069 00002A53 8987[E1C3]              		mov	[bx+sort-1],ax
 18070                                  
 18071                                  		;mov	byte [sortex_changed],1
 18072 00002A57 B501                    		mov	ch,1 ; 12/12/2018
 18073 00002A59 EBC6                    		jmp	short sortept_5
 18074                                  sortept_7:
 18075                                  		;pop	si
 18076                                  		;pop	di
 18077                                  		
 18078                                  		;mov	sp,bp ; 12/12/2018
 18079                                  		;pop	bp
 18080                                  		
 18081 00002A5B C3                      		retn
 18082                                  
 18083                                  ; ----------------------------------------------------------------------------
 18084                                  ; IBM PC-DOS 7.0 FDISK.COM, Segment 0, Offset 0014h
 18085                                  
 18086                                  ; 07/12/2018
 18087                                  ;_fptrap:
 18088                                  ;		retn
 18089                                  
 18090                                  ; CRT0FP.ASM - Microsoft Visual C++ Version 1.0
 18091                                  
 18092                                  ;***
 18093                                  ;_fptrap - trap for missing floating-point software
 18094                                  ;
 18095                                  ;Purpose:
 18096                                  ;	Catches these cases of incomplete f.p. software linked into a program.
 18097                                  ;
 18098                                  ;	(1) 87.LIB chosen, but no coprocessor present;
 18099                                  ;	    (i.e., emulator not linked)
 18100                                  ;
 18101                                  ;	(2) "%e", "%f", and "%g" i/o conversion formats specified, but
 18102                                  ;	    not all conversion software has been linked in, because the
 18103                                  ;	    program did not use any floating-point variables or expressions.
 18104                                  ;
 18105                                  ;Entry:
 18106                                  ;	None.
 18107                                  ;
 18108                                  ;Exit:
 18109                                  ;	None.
 18110                                  ;
 18111                                  ;Uses:
 18112                                  ;	AX.
 18113                                  ;
 18114                                  ;Exceptions:
 18115                                  ;	Transfers control to _amsg_exit which ...
 18116                                  ;	- Writes error message to standard error:  "floating point not loaded";
 18117                                  ;	- Terminates the program by calling _exit().
 18118                                  ;*******************************************************************************
 18119                                  
 18120                                  ;labelNP <PUBLIC,_fptrap>
 18121                                  ;
 18122                                  ;ifdef	_LOAD_DGROUP
 18123                                  ;;	 push	 ds		; no need to save ds since program will dying
 18124                                  ;	mov	ax, DGROUP
 18125                                  ;	mov	ds, ax
 18126                                  ;endif	;_LOAD_DGROUP
 18127                                  ;
 18128                                  ;	mov	ax,_RT_FLOAT	; issue floating point not loaded
 18129                                  ;	jmp	_amsg_exit	;   and die
 18130                                  
 18131                                  ; 14/12/2018
 18132                                  _fptrap:
 18133                                  	; 14/12/2018
 18134 00002A5C 59                      	pop	cx  ; return address
 18135 00002A5D 1E                      	push	ds
 18136 00002A5E FF36[C69E]              	push	word [fperror_msg_off]
 18137 00002A62 E8B5EB                  	call	display
 18138                                  	;pop	bx
 18139                                  	;pop	bx
 18140 00002A65 B0FF                    	mov	al,255
 18141 00002A67 E9FED5                  	jmp	_exit
 18142                                  
 18143                                  ; CRT0.ASM (VCCRT2.ZIP) - Microsoft Visual C++ 1.0 Run-Time Library Sources
 18144                                  ; ----------------------------------------------------------------------------
 18145                                  ; Microsoft(R) Visual C++ Version 1.0 Run-Time Library Sources (1993)
 18146                                  ; ----------------------------------------------------------------------------
 18147                                  ; Modified and simplified for NASM syntax and com (single segment) file
 18148                                  ;						 (by Erdogan Tan, 07/12/2018)
 18149                                  
 18150                                  ;***
 18151                                  ;_amsg_exit, _cintDIV - Fast exit fatal errors
 18152                                  ;
 18153                                  ;Purpose:
 18154                                  ;	Exit the program with error code of 255 and appropriate error
 18155                                  ;	message.  cintDIV is used for integer divide by zero, amsg_exit
 18156                                  ;	is for other run time errors.
 18157                                  ;
 18158                                  ;ifdef _FATALHOOK
 18159                                  ;	Weak extern call through _fatalexit was added so programs
 18160                                  ;	may be notified of imminent termination (e.g., PWB).
 18161                                  ;endif
 18162                                  ;
 18163                                  ;Entry:
 18164                                  ;	AX	= error message number (amsg_exit only).
 18165                                  ;
 18166                                  ;Exit:
 18167                                  ;	calls exit() [cintDIV] or indirect through _aexit_rtn [amg_exit].
 18168                                  ;
 18169                                  ;Uses:
 18170                                  ;
 18171                                  ;Exceptions:
 18172                                  ;
 18173                                  ;*******************************************************************************
 18174                                  
 18175                                  ; 14/12/2018 (no need to _cintDIV and _agsm_exit for FDISK2.COM)
 18176                                  
 18177                                  ;; IBM PC-DOS 7.0 FDISK.COM, Segment 0, Offset 66D2h
 18178                                  ;
 18179                                  ;		_aDBdoswp equ 0D6D6h
 18180                                  ;_cintDIV:
 18181                                  ;
 18182                                  ;		;mov	ax,[cs:_dataseg] ; DGROUP
 18183                                  ;		;mov	ds,ax	
 18184                                  ;	
 18185                                  ;		push	cs	; 07/12/2018
 18186                                  ;		pop	ds
 18187                                  ;	
 18188                                  ;		mov	ax,3 ; _RT_INTDIV ; Integer divide by zero interrupt
 18189                                  ;		mov	word [_aexit_rtn],_exit ; call high-level exit()
 18190                                  ;				; to cause file buffer flushing
 18191                                  ;_amsg_exit:
 18192                                  ;		push	ax		; message number for _NMSG_WRITE
 18193                                  ;
 18194                                  ;		call	_FF_MSGBANNER	; run-time error message banner
 18195                                  ;		call	_NMSG_WRITE	; write error message to stdout
 18196                                  ;
 18197                                  ;		cmp	word [_aDBswpflg],_aDBdoswp  ; Aware debugger as parent?
 18198                                  ;		jne	short _@FF		     ; No -- skip
 18199                                  ;		pop	ax
 18200                                  ;		push	ax
 18201                                  ;		call	_aDBrterr	; Yes -- report a runtime error
 18202                                  ;_@FF:
 18203                                  ;		mov	ax,255
 18204                                  ;		push	ax
 18205                                  ;
 18206                                  ;		call	word [_aexit_rtn] ; _exit(255) ordinarily
 18207                                  ;					; (or exit(255) for div by 0)
 18208                                  ;					; NEAR routine pointer
 18209                                  
 18210                                  ;;_dataseg: dw	seg DGROUP ; for EXE file
 18211                                  ;_dataseg:  dw  0   ; for COM file
 18212                                  
 18213                                  ; ----------------------------------------------------------------------------
 18214                                  ; IBM PC-DOS 7.0 FDISK.COM, Segment 0, Offset 0016h
 18215                                  ;_FF_MSGBANNER:
 18216                                  ;		retn
 18217                                  
 18218                                  ; ----------------------------------------------------------------------------
 18219                                  ; IBM PC-DOS 7.0 FDISK.COM, Segment 0, Offset 0017h
 18220                                  ;_NMSG_WRITE:
 18221                                  ;		retn
 18222                                  
 18223                                  ; ----------------------------------------------------------------------------
 18224                                  ; IBM PC-DOS 7.0 FDISK.COM, Segment 0, Offset 6D61h
 18225                                  ;_aDBretaddr:
 18226                                  ;		retn
 18227                                  
 18228                                  ; LSEEK.ASM (VCCRT1.ZIP) - Microsoft Visual C++ 1.0 Run-Time Library Sources
 18229                                  ; ----------------------------------------------------------------------------
 18230                                  ; Downloaded From : The Programmer's Corner (www.pcorner.com) - 01/12/2018 -
 18231                                  
 18232                                  ; Modified and simplified for NASM syntax by Erdogan Tan (07/12/2018)
 18233                                  
 18234                                  ;***
 18235                                  ;long _lseek(fh,pos,mthd) - move the file pointer
 18236                                  ;
 18237                                  ;Purpose:
 18238                                  ;	Moves the file pointer associated with fh to a new position.
 18239                                  ;	The new position is pos bytes (pos may be negative) away
 18240                                  ;	from the origin specified by mthd.
 18241                                  ;
 18242                                  ;	If mthd == SEEK_SET, the origin in the beginning of file
 18243                                  ;	If mthd == SEEK_CUR, the origin is the current file pointer position
 18244                                  ;	If mthd == SEEK_END, the origin is the end of the file
 18245                                  ;
 18246                                  ;ifdef _QWIN
 18247                                  ;	Note:  Can't seek on QWIN file handles!
 18248                                  ;endif
 18249                                  ;
 18250                                  ;Entry:
 18251                                  ;	int fh - file handle to move file pointer on
 18252                                  ;	long pos - position to move to, relative to origin
 18253                                  ;	int mthd - specifies the origin pos is relative to (see above)
 18254                                  ;
 18255                                  ;Exit:
 18256                                  ;	returns the offset, in bytes, of the new position from the beginning
 18257                                  ;	of the file.
 18258                                  ;	returns -1L (and sets errno) if fails.
 18259                                  ;	Note that seeking beyond the end of the file is not an error.
 18260                                  ;	(although seeking before the beginning is.)
 18261                                  ;
 18262                                  ;Uses:
 18263                                  ;
 18264                                  ;Exceptions:
 18265                                  ;
 18266                                  ;*******************************************************************************
 18267                                  
 18268                                  ; 14/12/2018 (no need to _lseek for FDISK2.COM)
 18269                                  
 18270                                  ;; IBM PC-DOS 7.0 FDISK.COM, Segment 0, Offset 7C74h
 18271                                  ;
 18272                                  ;_lseek:
 18273                                  ;
 18274                                  ;	%define loword	bp-4
 18275                                  ;	%define hiword	bp-2
 18276                                  ;
 18277                                  ;	%define fh	bp+4
 18278                                  ;	%define	pos	bp+6
 18279                                  ;	%define pos2	bp+8
 18280                                  ;	%define mthd	bp+10
 18281                                  ;
 18282                                  ;		push	bp
 18283                                  ;		mov	bp,sp
 18284                                  ;		sub	sp,4
 18285                                  ;		
 18286                                  ;		mov	bx,[fh]		; file handle
 18287                                  ;		; make sure handle is in OS file handle range
 18288                                  ;		cmp	bx,_nfile
 18289                                  ;		jb	short handle_ok
 18290                                  ;
 18291                                  ;	; _dosret must set DX:AX to -1L
 18292                                  ;		;mov	ax,EBADF shl 8 + 0 ; file handle is out of range
 18293                                  ;		mov	ax,900h
 18294                                  ;		jmp	short seterr
 18295                                  ;handle_ok:
 18296                                  ;
 18297                                  ;; negative offset - due to a DOS idiosyncracy, we have to check here to see
 18298                                  ;; if the seek would move us to a location prior to the beginning of the
 18299                                  ;; file, and, if so, return an error.
 18300                                  ;
 18301                                  ;		test	word [pos+2],8000h ; negative offset ?
 18302                                  ;		jz	short doit	; not negative; just do lseek
 18303                                  ;
 18304                                  ;		cmp	byte [mthd],0	; byte 0 relative?
 18305                                  ;		je	short negative	; yes, error
 18306                                  ;
 18307                                  ;		xor	cx,cx		; no, find current position
 18308                                  ;		mov	dx,cx		; 0L
 18309                                  ;		mov	ax,4201h ; mov ax,DOS_lseek shl 8 + 1
 18310                                  ;		int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 18311                                  ;				; AL = method: offset from present location
 18312                                  ;		jc	short errexit	; if error
 18313                                  ;		test	byte [mthd],2
 18314                                  ;		jnz	short findeof	; mthd is 2
 18315                                  ;					; mthd is 1
 18316                                  ;		add	ax,[pos]	; low word
 18317                                  ;		adc	dx,[pos+2]	; hi word
 18318                                  ;		jns	short doit	; net position is not negative; do lseek
 18319                                  ;negative:				; net position is negative, return
 18320                                  ;		;mov	ax,EINVAL shl 8 + 0 ; invalid value error
 18321                                  ;		mov	ax,1600h
 18322                                  ;seterr:
 18323                                  ;		stc
 18324                                  ;		jmp	short errexit
 18325                                  ;findeof:				; mthd is relative to end of file
 18326                                  ;		mov	[hiword],dx	; save present position (dx:ax)
 18327                                  ;		mov	[loword],ax
 18328                                  ;		mov	dx,cx		; 0L - cx is still zero from previous call
 18329                                  ;		mov	ax,4202h ; mov	ax,DOS_lseek shl 8 + 2 ; find eof position
 18330                                  ;		int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 18331                                  ;				; AL = method: offset from end of file
 18332                                  ;		add	ax,[pos]	; low word
 18333                                  ;		adc	dx,[pos+2]	; hi word
 18334                                  ;		jns	short doit	; if non-negative, just do lseek
 18335                                  ;
 18336                                  ;	; net position would be negative, seek back to original location, then fail
 18337                                  ;
 18338                                  ;		mov	cx,[hiword]	; original offset
 18339                                  ;		mov	dx,[loword]
 18340                                  ;		;mov	ax,DOS_lseek shl 8 + 0 ; from beginning of file
 18341                                  ;		mov	ax,4200h	; go back
 18342                                  ;		int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 18343                                  ;				; AL = method: offset from beginning of	file
 18344                                  ;		jmp	short negative
 18345                                  ;
 18346                                  ;	; seek to the specified location
 18347                                  ;	; bx = file handle
 18348                                  ;doit:
 18349                                  ;		mov	dx,[pos]	; low(pos)
 18350                                  ;		mov	cx,[pos+2]	; high(pos)
 18351                                  ;		mov	al,[mthd]	; method
 18352                                  ;		mov	ah,42h	; move file ptr
 18353                                  ;		int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 18354                                  ;				; AL = method:
 18355                                  ;				; 0-from beginnig,1-from current,2-from	end
 18356                                  ;		jb	short errexit
 18357                                  ;		;and	__osfile[bx],NOT FEOFLAG ; clear ^z flag if lseek succeeds
 18358                                  ;		and	byte [_osfile+bx],~2 ; not 2
 18359                                  ;errexit:
 18360                                  ;		;jmp	__dosretax
 18361                                  ;		;jmp	short _dosretax
 18362                                  ;		;jmp	short DOSerror ; **errexit**
 18363                                  
 18364                                  ; ----------------------------------------------------------------------------
 18365                                  
 18366                                  ;***
 18367                                  ;dosret.asm - map DOS error number to standard C (XENIX) error numbers; returns
 18368                                  ;
 18369                                  ;	Copyright (c) 1987-1992, Microsoft Corporation. All rights reserved.
 18370                                  ;
 18371                                  ;Purpose:
 18372                                  ;	Maps the standard DOS error number to C (XENIX) error number and
 18373                                  ;	returns.  Used at the end of many runtime routines.
 18374                                  ;
 18375                                  ;*******************************************************************************
 18376                                  
 18377                                  ; 14/12/2018 (no need to _dosreto,_dosretax,Doseror,DOSnoerror for FDISK2.COM)
 18378                                  
 18379                                  ;;_dosret0:
 18380                                  ;;		jc	short DOSerror	; set errors
 18381                                  ;;
 18382                                  ;;ret_0:
 18383                                  ;;		xor	ax,ax		; clear errors
 18384                                  ;;		mov	sp,bp
 18385                                  ;;		pop	bp
 18386                                  ;;		retn
 18387                                  ;;_dosreturn:
 18388                                  ;;		jnc	short ret_0
 18389                                  ;;		push	ax
 18390                                  ;;		call	maperror
 18391                                  ;;		pop	ax	; set errno and return original DOS error	
 18392                                  ;;		xor	ah,ah	; make sure ah is 0
 18393                                  ;;		mov	sp,bp
 18394                                  ;;		pop	bp
 18395                                  ;;		retn
 18396                                  ;
 18397                                  ;_dosretax:
 18398                                  ;		jnc	short DOSnoerror ; no errors	
 18399                                  ;
 18400                                  ;DOSerror:				; **errexit**
 18401                                  ;		call	maperror 	; map error to standard C error	
 18402                                  ;		mov	ax,-1		; return DX:AX = -1L
 18403                                  ;		cwd
 18404                                  ;DOSnoerror:
 18405                                  ;		mov	sp,bp
 18406                                  ;		pop	bp
 18407                                  ;		retn
 18408                                  
 18409                                  ; ----------------------------------------------------------------------------
 18410                                  ;_maperror - map DOS errors to standard XENIX errors
 18411                                  
 18412                                  ; 14/12/2018 (no need to _maperror for FDISK2.COM)
 18413                                  
 18414                                  ;_maperror:
 18415                                  ;		xor	ah,ah	 ; clear ah
 18416                                  ;		;call	maperror ; map the error	
 18417                                  ;		;retn
 18418                                  ;
 18419                                  ;; XENIX error translation can be overridden - AH = new XENIX error code
 18420                                  ;
 18421                                  ;maperror:
 18422                                  ;		mov	byte [_doserrno],al ; save dos error
 18423                                  ;		or	ah,ah	; xenix error code override?	
 18424                                  ;		jnz	short mapover ; yes, map the override values
 18425                                  ;
 18426                                  ;		cmp	byte [_dosvermajor],3 ; is this version 3.0 ?
 18427                                  ;		jb	short chk2	; no, compare to 2.0 max error
 18428                                  ;
 18429                                  ;		;cmp	al,E_maxerr3	; yes, compare to 3.0 max error
 18430                                  ;		cmp	al,22h
 18431                                  ;		jnb	short maxerr2	; set bad error value
 18432                                  ;		;cmp	al,E_sharerr	; is this a legit 3.0 error ?
 18433                                  ;		cmp	al,20h
 18434                                  ;		jb	short chk2	; no, see if 2.0 error
 18435                                  ;
 18436                                  ;; we get here only if we have an error value larger than is legit for
 18437                                  ;; 2.0 (19), and is inrange for 3.0. Currently we only support the sharing
 18438                                  ;; and locking violation errors for 3.0, but this will probably change in
 18439                                  ;; the future. We will always map sharing and locking violations to EACCES
 18440                                  ;; Xenix errors.
 18441                                  ;		;mov	al,E_access	; yes, set for access error
 18442                                  ;		mov	al,5
 18443                                  ;		jmp	short inrange	; map it
 18444                                  ;chk2:
 18445                                  ;		;cmp	al,E_maxerr2	; no, compare to 2.0 max error
 18446                                  ;		cmp	al,13h
 18447                                  ;		jbe	short inrange	; error value ok
 18448                                  ;maxerr2:
 18449                                  ;		;mov	al,E_maxerr2	; error value bad, default to max error
 18450                                  ;		mov	al,13h
 18451                                  ;inrange:
 18452                                  ;		;mov	bx,errtab
 18453                                  ;		mov	bx,err_conv_tbl
 18454                                  ;		xlat
 18455                                  ;mapsave:
 18456                                  ;		cbw
 18457                                  ;		mov	[errno],ax
 18458                                  ;		retn
 18459                                  ;mapover:
 18460                                  ;		mov	al,ah
 18461                                  ;		jmp	short mapsave
 18462                                  
 18463                                  ; _GETBUF.ASM (VCCRT2.ZIP) - Microsoft Visual C++ 1.0 Run-Time Library Sources
 18464                                  ; ----------------------------------------------------------------------------
 18465                                  ; Modified and simplified for NASM syntax by Erdogan Tan (09/12/2018)
 18466                                  
 18467                                  ;***
 18468                                  ;_getbuf() - Allocate a buffer and init stream data bases
 18469                                  ;
 18470                                  ;Purpose:
 18471                                  ;	Allocates a buffer for a stream and inits the stream data bases.
 18472                                  ;
 18473                                  ;	[NOTE  1: This routine assumes the caller has already checked to make
 18474                                  ;	sure the stream needs a buffer.
 18475                                  ;
 18476                                  ;	[NOTE 2: Multi-thread - Assumes caller has acquired stream lock, if
 18477                                  ;	needed.]
 18478                                  ;
 18479                                  ;	[NOTE 3: The code now assumes that _iob[] and _iob2[] are near arrays
 18480                                  ;	of the same element size.]
 18481                                  ;
 18482                                  ;Entry:
 18483                                  ;	FILE *stream = stream to allocate a buffer for
 18484                                  ;
 18485                                  ;Exit:
 18486                                  ;	void
 18487                                  ;
 18488                                  ;Exceptions:
 18489                                  ;
 18490                                  ;*******************************************************************************
 18491                                  
 18492                                  ; 14/12/2018 (no need to _getbuf for FDISK2.COM)
 18493                                  
 18494                                  ;_getbuf:
 18495                                  ;	;%define gb_stream bp+4
 18496                                  ;
 18497                                  ;	; INPUT-> si = offset stream data address [ _getbuf(stream) ]
 18498                                  ;
 18499                                  ;		;push	bp
 18500                                  ;		;mov	bp,sp
 18501                                  ;		;push	si	
 18502                                  ;
 18503                                  ;		;mov	si,[gb_stream]
 18504                                  ;
 18505                                  ;		;mov	ax,BUFSIZ
 18506                                  ;		mov	ax,512
 18507                                  ;		push	ax
 18508                                  ;		call	malloc		; malloc(BUFSIZ)
 18509                                  ;		pop	cx		; clean off arg
 18510                                  ;;**
 18511                                  ;; Set:
 18512                                  ;;	bx = _iob2 entry (aka stream2)
 18513                                  ;; Note that by doing it here/now, we don't have to save/restore bx or di.
 18514                                  ;
 18515                                  ;		mov	bx,si
 18516                                  ;		sub	bx,_iob
 18517                                  ;		add	bx,_iob2
 18518                                  ;;**
 18519                                  ;; Now, check the return from malloc(). If it worked, installed the newly
 18520                                  ;; malloc-ed buffer. Otherwise, install single character buffering.
 18521                                  ;
 18522                                  ;;if sizeD
 18523                                  ;;		or	dx,dx		; NULL return?
 18524                                  ;;else
 18525                                  ;		or	ax,ax		; NULL return?
 18526                                  ;;endif
 18527                                  ;		jz	short _singlechar ;   yes, install single char buffer
 18528                                  ;;**
 18529                                  ;; Set stream->_flag and stream2->_bufsiz fields. Then, branch to code
 18530                                  ;; to set other stream fields.
 18531                                  ;
 18532                                  ;		;or	[si]._flag,_IOMYBUF
 18533                                  ;		or	byte [si+6],8
 18534                                  ;		;mov	[bx]._bufsiz,BUFSIZ
 18535                                  ;		mov	word [bx+2],512
 18536                                  ;		jmp	short setfields
 18537                                  ;_singlechar:
 18538                                  ;		;or	[si]._flag,_IONBF
 18539                                  ;		or	byte [si+6],4
 18540                                  ;		;mov	[bx]._bufsiz,1
 18541                                  ;		mov	word [bx+2],1
 18542                                  ;;if sizeD
 18543                                  ;;		mov	dx,ds
 18544                                  ;;endif
 18545                                  ;		;lea	ax,[bx]._charbuf
 18546                                  ;		lea	ax,[bx+1]
 18547                                  ;;**
 18548                                  ;; Set the _ptr, _base and _cnt fields of stream. Note that, on entry, ax
 18549                                  ;; (dx:ax in large data models) is a pointer to new stream buffer.
 18550                                  ;
 18551                                  ;setfields:
 18552                                  ;
 18553                                  ;;if sizeD
 18554                                  ;;		mov	word ptr [si]._ptr + 2,dx
 18555                                  ;;		mov	word ptr [si]._ptr,ax
 18556                                  ;;		mov	word ptr [si]._base + 2,dx
 18557                                  ;;		mov	word ptr [si]._base,ax
 18558                                  ;;else
 18559                                  ;		;mov	word ptr [si]._ptr,ax
 18560                                  ;		mov	[si],ax
 18561                                  ;		;mov	word ptr [si]._base,ax
 18562                                  ;		mov	[si+4],ax
 18563                                  ;;endif
 18564                                  ;		;mov	word ptr [si]._cnt,0
 18565                                  ;		mov     word [si+2],0
 18566                                  ;done:
 18567                                  ;		;pop	si
 18568                                  ;		;pop	bp
 18569                                  ;		retn
 18570                                  
 18571                                  ; NMALLOC.ASM (VCCRT1.ZIP) - Microsoft Visual C++ 1.0 Run-Time Library Sources
 18572                                  ; ----------------------------------------------------------------------------
 18573                                  ; Modified and simplified for NASM syntax by Erdogan Tan (09/12/2018)
 18574                                  
 18575                                  ; 14/12/2018 (no need to malloc,_nmalloc for FDISK2.COM)
 18576                                  
 18577                                  ;malloc:
 18578                                  ;		;jmp	_nmalloc
 18579                                  
 18580                                  ;***
 18581                                  ;void near *_nmalloc(size) - allocate a memory block in the near heap
 18582                                  ;
 18583                                  ;Purpose:
 18584                                  ;	Allocates a memory block of at least size bytes in the near heap.
 18585                                  ;	The block will be aligned for the storage of any type of object.
 18586                                  ;
 18587                                  ;	[NOTE: This routine assumes that the near heap is already
 18588                                  ;	initialized (at startup).]
 18589                                  ;
 18590                                  ;	[MTHREAD NOTE: Multi-thread libraries do NOT support the
 18591                                  ;	?varstck.obj functionality.  Thus, _STKHQQ can be referenced
 18592                                  ;	directly (i.e., without using the tid data table).
 18593                                  ;
 18594                                  ;Entry:
 18595                                  ;	unsigned size - size of memory block desired
 18596                                  ;
 18597                                  ;	CRTDLL:  ds:bx = near heap descriptor
 18598                                  ;
 18599                                  ;Exit:
 18600                                  ;	returns pointer to allocated space or NULL if fails
 18601                                  ;
 18602                                  ;Uses:
 18603                                  ;
 18604                                  ;Exceptions:
 18605                                  ;
 18606                                  ;*******************************************************************************
 18607                                  
 18608                                  ;_nmalloc:
 18609                                  ;
 18610                                  ;	%define incr	bp+4
 18611                                  ;
 18612                                  ;		push	bp
 18613                                  ;		mov	bp,sp
 18614                                  ;		push	si
 18615                                  ;		push	di
 18616                                  ;		mov	cx,[incr]	; cx = request block size
 18617                                  ;		cmp	cx,0FFE8h ; _HEAP_MAXREQ ; cx > max. legal request size ?
 18618                                  ;		ja	short error_rtn	; nope, try to get the memory
 18619                                  ;
 18620                                  ;; Try to get the requested block from the heap
 18621                                  ;; cx = size
 18622                                  ;getmem:
 18623                                  ;		mov	bx,_nheap_desc	; ds:bx = heap descriptor
 18624                                  ;		call	_searchseg	; get block
 18625                                  ;		jnc	short ndone	; if success, we're all done
 18626                                  ;
 18627                                  ;; Did not find a suitable block in the heap.
 18628                                  ;; Try to grow the heap.
 18629                                  ;; cx = size, ds:bx = heap descriptor
 18630                                  ;
 18631                                  ;		call	_growseg	; try to grow the segment
 18632                                  ;		jc	short error_rtn ; if error, return NULL
 18633                                  ;
 18634                                  ;; We successfully grew the heap. Try the search again.
 18635                                  ;; (Rover pointer should be in a place that makes this search efficient.)
 18636                                  ;; cx = size, ds:bx = heap descriptor
 18637                                  ;
 18638                                  ;		call	_searchseg	; search the heap segment
 18639                                  ;		jnc	short ndone	; if success, take good return
 18640                                  ;; Error return
 18641                                  ;error_rtn:
 18642                                  ;		xor	ax, ax
 18643                                  ;		cwd
 18644                                  ;		;jmp	short $+2
 18645                                  ;; Common exit
 18646                                  ;; (dx:ax = return value)
 18647                                  ;ndone:
 18648                                  ;		pop	di
 18649                                  ;		pop	si
 18650                                  ;		pop	bp
 18651                                  ;		retn
 18652                                  
 18653                                  ; HEAP.INC
 18654                                  ;
 18655                                  ; --- Heap segment descriptor ---
 18656                                  ;
 18657                                  ; [***NOTE*** Some heap routines make assumptions about the layout of the
 18658                                  ; heap descriptor. If this descriptor changes, some routines may break.]
 18659                                  ;
 18660                                  
 18661                                  ; 09/12/2018
 18662                                  
 18663                                  ;struc _heap_seg_desc
 18664                                  ; .checksum:	resw 1	; checksum area
 18665                                  ; .flags:	resw 1	; flags word
 18666                                  ; .segsize:	resw 1	; size of segment
 18667                                  ; .start:	resw 1	; offset of first heap entry
 18668                                  ; .rover:	resw 1	; rover offset
 18669                                  ; .last:	resw 1	; offset to end-of-heap marker
 18670                                  ; .nextseg:	resd 1	; far pointer to next _heap_seg_desc
 18671                                  ; .prevseg:	resd 1	; far pointer to previous _heap_seg_desc
 18672                                  ; .size:
 18673                                  ;endstruc
 18674                                  
 18675                                  ; SEARCHSG.ASM - Microsoft Visual C++ 1.0 Run-Time Library Sources
 18676                                  ; ----------------------------------------------------------------------------
 18677                                  
 18678                                  ;***
 18679                                  ; _searchseg - Search a heap segment
 18680                                  ;
 18681                                  ;Purpose:
 18682                                  ;
 18683                                  ; This routine scans through the supplied heap segment looking for a
 18684                                  ; block big enough to satisfy the size request. Contiguous free blocks
 18685                                  ; are coalesced as necessary.
 18686                                  ;
 18687                                  ; The search is done in two parts:
 18688                                  ;
 18689                                  ;	(1) First, we search from the current rover pointer to the end
 18690                                  ;	of the heap segment.
 18691                                  ;
 18692                                  ;	(2) Second, we search from the start of the heap segment to the
 18693                                  ;	rover pointer (being careful to overlap so that all free blocks
 18694                                  ;	are coalesced as much as possible).
 18695                                  ;
 18696                                  ;Entry:
 18697                                  ;	cx = requested size
 18698                                  ;	     [If requested size = _HEAP_COALESCE, then we simply coalesce
 18699                                  ;	     the heap segment and return with carry set]
 18700                                  ;	ds:bx = address of heap descriptor
 18701                                  ;
 18702                                  ;Exit:
 18703                                  ;	Success:
 18704                                  ;		carry = clear
 18705                                  ;		dx:ax = address of block
 18706                                  ;	Failure:
 18707                                  ;		carry = set
 18708                                  ;
 18709                                  ;Uses:
 18710                                  ;	ax, dx, si, di
 18711                                  ;
 18712                                  ;Preserved:
 18713                                  ;	ds:bx, cx
 18714                                  ;
 18715                                  ;Exceptions:
 18716                                  ;	If we detect an inconsistent heap, we return NULL and set errno
 18717                                  ;	to ***???***.
 18718                                  ;
 18719                                  ;*******************************************************************************
 18720                                  
 18721                                  ; 14/12/2018 (no need to _searchseg for FDISK2.COM)
 18722                                  ;
 18723                                  ;_searchseg:
 18724                                  ;		inc	cx
 18725                                  ;		and	cl,0FEh ; ~1 ; not 1 ; round size up to even number
 18726                                  
 18727                                  ; first_pass -
 18728                                  ; On the first pass through the heap, we will search from the current
 18729                                  ; rover pointer to the end of the heap. Set the 'end-of-search' pointer
 18730                                  ; such that the search will not end until we encounter the _HEAP_END flag.
 18731                                  ;
 18732                                  ; Entry:
 18733                                  ;			BX = heap descriptor
 18734                                  ;			CX = requested size
 18735                                  ;
 18736                                  ; Exit Paths:
 18737                                  ;		check_block
 18738                                  ;			SI = pointer where the heap search should start
 18739                                  ;			DI = 0 (pointer to last free block examinted)
 18740                                  ;			BX = pointer to _HEAP_END (where search should end)
 18741                                  ;			CX = requested size
 18742                                  ;			TOS = heap descriptor
 18743                                  
 18744                                  ;first_pass:
 18745                                  ;		push	bx		; save heap descriptor
 18746                                  ;		cld			; go forward when loading
 18747                                  ;		;mov	si,[bx].rover	; si = pointer to start of search
 18748                                  ;		mov	si,[bx+8]
 18749                                  ;		;mov	bx,[bx].last	; bx = pointer to end-of-heap marker
 18750                                  ;		mov	bx,[bx+10]
 18751                                  ;		xor	di,di		; zero out di
 18752                                  ;		jmp	short check_block ; jump into loop
 18753                                  
 18754                                  ; next_pass -
 18755                                  ; We have completed a pass through the heap.
 18756                                  ;	(1) Update .last pointer if necessary.	The only way this could happen
 18757                                  ;	is if we coalesced the last block with one before it.  Thus, we only
 18758                                  ;	need a pointer to the last free block we examined to determine if
 18759                                  ;	.last must be updated.
 18760                                  ;	(3) Determine which pass has been completed by checking the lower
 18761                                  ;	order bit of the end-of-search pointer.
 18762                                  ;	(3) If we just finished the second pass, return an error.
 18763                                  ;	(4) Else, start up a heap search from the start of the heap to the
 18764                                  ;	rover pointer. Use rover - 1 as the value of the end-of-search pointer
 18765                                  ;	since it works are well as rover does and it makes it easy to
 18766                                  ;	determine which pass we have completed.
 18767                                  ;
 18768                                  ; Entry:
 18769                                  ;			BX = end-of-search pointer = pointer to end-of-heap
 18770                                  ;			     marker (after first pass) or rover - 1 (after
 18771                                  ;			     second pass)
 18772                                  ;			CX = requested size
 18773                                  ;			DI = 0 or pointer to last free block examined + 2
 18774                                  ;			TOS = heap descriptor
 18775                                  ;
 18776                                  ; Exit Paths:
 18777                                  ;		failure1 (end of search, block not found)
 18778                                  ;			TOS = heap descriptor
 18779                                  ;		failure2 (end of search, block not found)
 18780                                  ;			BX = heap descriptor
 18781                                  ;		check_block (start up the second heap search)
 18782                                  ;			SI = pointer where the heap search should start
 18783                                  ;			DI = 0 (pointer to last free block examinted)
 18784                                  ;			BX = end-of-search pointer = rover - 1
 18785                                  ;			CX = requested size
 18786                                  ;			TOS = heap descriptor
 18787                                  
 18788                                  ;next_pass:
 18789                                  ;		mov	ax,bx		; ax = end-of-search pointer
 18790                                  ;		pop	bx		; bx = heap descriptor
 18791                                  
 18792                                  ; see if we need another pass through the heap
 18793                                  
 18794                                  ;check_pass:
 18795                                  ;		test	al,1		; test low order bit on eos pointer
 18796                                  ;		jnz	short failure2	; bit was set, we're done
 18797                                  
 18798                                  ; set up for second pass through the heap
 18799                                  
 18800                                  ;		push	bx			; save heap descriptor
 18801                                  ;		;mov	si,[bx].start		; si = start search ptr = start
 18802                                  ;		mov	si,[bx+6]
 18803                                  ;		;mov	bx,[bx].rover		; bx = end-of-search ptr = rover
 18804                                  ;		mov	bx,[bx+8]
 18805                                  ;		cmp	bx,si			; start == rover ??
 18806                                  ;		je	short failure1		; if so, no need to try another pass
 18807                                  ;		dec	bx			; end-of-search pointer = rover - 1
 18808                                  ;		xor	di,di			; zero out di
 18809                                  ;
 18810                                  ;		jmp	short check_block	; jump into loop
 18811                                  
 18812                                  ; ---------- Start of segment search loop ----------
 18813                                  ;
 18814                                  ; The following registers are not changed by any code in the segment
 18815                                  ; search loop:
 18816                                  ;			BX = end of search pointer
 18817                                  ;			CX = requested size
 18818                                  ;			TOS = heap descriptor
 18819                                  ;
 18820                                  ; next_block -
 18821                                  ; See if we're at the end of the segment search loop. If not, move
 18822                                  ; on to the next block.
 18823                                  ;
 18824                                  ; Entry:
 18825                                  ;			AX = header of last block examined (not free)
 18826                                  ;			SI = pointer to last block examined (not free) + 2
 18827                                  ;			DI = 0 or pointer to last free block examined + 2
 18828                                  ;
 18829                                  ; Exit Paths:
 18830                                  ;		next_pass (first pass through heap failed)
 18831                                  ;			DI = 0 or pointer to last free block examined + 2
 18832                                  ;
 18833                                  ;		check_block (info for next block is loaded into AX and SI)
 18834                                  ;			AX = header for (new) block to be checked
 18835                                  ;			SI = pointer to (new) block to be checked + 2
 18836                                  ;			DI = 0 or pointer to last free block examined + 2
 18837                                  
 18838                                  ;EVEN
 18839                                  
 18840                                  ;align 2
 18841                                  ;
 18842                                  ;next_block:
 18843                                  ;		lea	dx,[si-2]	; get current ptr
 18844                                  ;		cmp	dx,bx		; current ptr >= end-of-search ptr ?
 18845                                  ;		jae	short next_pass	; yes, done with this pass
 18846                                  ;
 18847                                  ;		add	si,ax		; bump pointer to next block
 18848                                  ;		jc	short heap_toast ; *** inconsistent heap ***
 18849                                  ;		;fall thru
 18850                                  
 18851                                  ; check_block -
 18852                                  ; Check to see if the current block is free.
 18853                                  ;
 18854                                  ; Entry:
 18855                                  ;			SI = pointer to current block
 18856                                  ;			DI = 0 or pointer to last free block examined + 2
 18857                                  ;
 18858                                  ; Exit Paths:
 18859                                  ;		next_block (if current block is not free)
 18860                                  ;			AX = current block (not free) header
 18861                                  ;			SI = pointer to current block + 2
 18862                                  ;			DI = 0 or pointer to last free block examined + 2
 18863                                  ;		coal_loop (if current block is free)
 18864                                  ;			AX = current block (free) header
 18865                                  ;			SI, DI = pointers to current block + 2
 18866                                  ;
 18867                                  
 18868                                  ;check_block:
 18869                                  ;		lodsw			; ax = get the first block header
 18870                                  ;		test	al,1		; is it free?
 18871                                  ;		jz	short next_block ; no, go try the next block
 18872                                  ;		mov	di,si
 18873                                  ;	;fall thru
 18874                                  
 18875                                  ; coal_loop -
 18876                                  ; Check to see if current block is big enough. If not, try to
 18877                                  ; coalesce proceeding free block with the current block. Loop until we get
 18878                                  ; get a big enough block or cannot coalesce anymore.
 18879                                  ;
 18880                                  ; Entry:
 18881                                  ;			AX = current block header
 18882                                  ;			SI, DI = pointers to current block + 2
 18883                                  ;
 18884                                  ; Exit Paths:
 18885                                  ;		blockfound (current block is big enough)
 18886                                  ;			AX = size of current block
 18887                                  ;			SI, DI = pointers to current block + 2
 18888                                  ;		next_block (failure)
 18889                                  ;			DX = size of current block
 18890                                  ;			DI = pointer to current block + 2
 18891                                  ;			AX = header of next block (not free)
 18892                                  ;			SI = pointer to next block (not free) + 2
 18893                                  
 18894                                  ;;EVEN
 18895                                  ;
 18896                                  ;coal_loop:
 18897                                  ;		dec	ax		; subtract free flag
 18898                                  ;		cmp	ax,cx		; is it big enough?
 18899                                  ;		jae	short blockfound ;   yep, go finish up
 18900                                  ;		add	si,ax		; point to header of next block
 18901                                  ;		jc	short heap_toast ; *** inconsistent heap ***
 18902                                  ;		mov	dx,ax		; save size of original block in DX
 18903                                  ;		lodsw			; get header of next block into AX
 18904                                  ;		test	al,1		; is it free?
 18905                                  ;		jz	short next_block ;   no, go try the next block
 18906                                  ;		add	ax,dx		; coalesce
 18907                                  ;		add	ax,2		; add in header space
 18908                                  ;		mov	si,di		; reset SI to block + 2
 18909                                  ;		mov	[si-2],ax	; update block size
 18910                                  ;		jmp	short coal_loop
 18911                                  
 18912                                  ; ---------- End of segment search loop ----------
 18913                                  
 18914                                  ; heap_toast -
 18915                                  ; We detected an internal consistency error in the heap.
 18916                                  ; Set errno and return an error to the user.
 18917                                  
 18918                                  ;heap_toast:
 18919                                  ;		mov	ax,ax  ; place where we can place a breakpoint for now...
 18920                                  ;		; fall thru for now
 18921                                  
 18922                                  ; failure1, failure2 -
 18923                                  ; We could not find a big enough block in the heap.
 18924                                  ;
 18925                                  ;    (1) Set the rover pointer to the beginning of the heap since
 18926                                  ;	 the rover block may have been coalesced (i.e., the rover
 18927                                  ;	 pointer may no longer point to valid memory).
 18928                                  ;
 18929                                  ;	*** I THINK THIS IS WHAT THE OLD HEAP IS DOING.
 18930                                  ;	*** DO WE WANT TO DO THIS OR CAN WE SOMEHOW MOVE THE
 18931                                  ;	*** ROVER BACK TO THE MERGED BLOCK, IF NECESSARY.
 18932                                  ;
 18933                                  ;    (2) Return carry set to caller.
 18934                                  ;
 18935                                  ; Entry:
 18936                                  ;		failure1
 18937                                  ;			TOS = heap descriptor
 18938                                  ;
 18939                                  ;		failure2
 18940                                  ;			BX = heap descriptor
 18941                                  ;			CX = requested size
 18942                                  ;
 18943                                  ; Exit Paths:
 18944                                  ;		Return to caller (via done)
 18945                                  ;			Carry = set
 18946                                  ;			DS:BX = heap descriptor
 18947                                  ;			CX = requested size
 18948                                  
 18949                                  ;failure1:
 18950                                  ;		pop	bx		; bx = heap descriptor
 18951                                  ;failure2:
 18952                                  ;		;mov	ax,[bx].start	; set rover = start
 18953                                  ;		mov	ax,[bx+6]
 18954                                  ;		;mov	[bx].rover,ax
 18955                                  ;		mov	[bx+8],ax
 18956                                  ;		stc			; carry set = error
 18957                                  ;		jmp	short _done
 18958                                  
 18959                                  ; blockfound -
 18960                                  ; Found a block that fullfills the caller's request.
 18961                                  ;	(1) Transform the block found into an allocated block that
 18962                                  ;	exactly satisfies the allocation request (in CX) and a leftover,
 18963                                  ;	free block.
 18964                                  ;	(2) Update the rover and end pointers, as needed.
 18965                                  ;	(3) Return pointer to the allocated block to the caller.
 18966                                  ;
 18967                                  ; Entry:
 18968                                  ;			AX = size of (free) block (AX >= CX)
 18969                                  ;			SI, DI = pointers to block + 2
 18970                                  ;			CX = requested size
 18971                                  ;			ZF = 1 iff the block is an exact fit (i.e., AX == CX)
 18972                                  ;			     0 otherwise
 18973                                  ;			TOS = heap descriptor
 18974                                  ;
 18975                                  ; Exit Paths:
 18976                                  ;		Return to caller
 18977                                  ;			Carry = clear
 18978                                  ;			DX:AX = pointer to allocated block
 18979                                  ;			DS:BX = heap descriptor
 18980                                  ;			CX = requested size
 18981                                  
 18982                                  ;blockfound:
 18983                                  ;		pop	bx		; get heap descriptor
 18984                                  ;
 18985                                  ;		mov	[si-2],cx	; update header
 18986                                  ;		je	short set_rover	; jump if block size = request size
 18987                                  ;
 18988                                  ;		add	di,cx		; point to leftover piece
 18989                                  ;		sub	ax,cx		; compute header for leftover piece
 18990                                  ;		dec	ax		; as a free block
 18991                                  ;		mov	[di],ax 	; make it a free block
 18992                                  ;		sub	di,cx		; update rover
 18993                                  ;set_rover:
 18994                                  ;		add	di,cx		; point to leftover piece
 18995                                  ;set_rover1:
 18996                                  ;		;mov	[bx].rover,di	; update rover
 18997                                  ;		mov	[bx+8],di
 18998                                  ;		mov	ax,si		; return pointer to allocated block
 18999                                  ;		mov	dx,ds
 19000                                  ;		clc			; carry clear = success
 19001                                  ;; Common exit
 19002                                  ;_done:
 19003                                  ;		retn			; explicit return
 19004                                  
 19005                                  ; HEAP.INC
 19006                                  
 19007                                  ; _heap_seg_desc.flags bit offsets
 19008                                  
 19009                                  ;_HEAP_MODIFY	equ	01h		; heap segment size can be modified
 19010                                  ;_HEAP_FREE	equ	02h		; heap segment may be freed up to OS
 19011                                  ;_HEAP_NEAR	equ	04h		; heap segment is part of the near heap
 19012                                  ;_HEAP_BASED	equ	08h		; heap segment is part of the based heap
 19013                                  
 19014                                  ; --- General Use Heap Constants ---
 19015                                  
 19016                                  ;_HEAP_END	equ	0FFFEh		; End-of-heap flag
 19017                                  ;_HEAP_COALESCE	equ	0FFFEh		; Coalesce segment value
 19018                                  ;_HEAP_GROWSEG	equ	2000h		; Default heap seg growth increment (8K)
 19019                                  ;;_HEAP_MAXREQ	equ	0FFFCh - (_heap_seg_desc.size)	; Max heap request size
 19020                                  ;_HEAP_MAXREQ	equ	0FFFCh - 14h ; 0FFE8h
 19021                                  ;;_HEAP_MINSEG	equ	((_heap_seg_desc.size) + 4) ; Min size heap segment
 19022                                  ;_HEAP_MINSEG	equ	20+4		; Min size heap segment
 19023                                  
 19024                                  ; GROWSEG.ASM - Microsoft Visual C++ 1.0 Run-Time Library Sources
 19025                                  ; ----------------------------------------------------------------------------
 19026                                  
 19027                                  ;***
 19028                                  ; _growseg - Grow a heap segment
 19029                                  ;
 19030                                  ;Purpose:
 19031                                  ;	Grow a heap segment to increase the amount of space
 19032                                  ;	available for allocations.
 19033                                  ;
 19034                                  ;	Notes:
 19035                                  ;	(1) The caller has already determined that the block size cannot
 19036                                  ;	be allocated in the current heap and heap segment growth is necessary.
 19037                                  ;	(2) The size argument is the block allocation size requested
 19038                                  ;	by the user.  The supplied size is NOT the heap increment.
 19039                                  ;	(that size is determined by this routine).
 19040                                  ;
 19041                                  ;Entry:
 19042                                  ;	ds:bx = heap segment descriptor
 19043                                  ;	cx = size of block requested
 19044                                  ;
 19045                                  ;Exit:
 19046                                  ;	Success:
 19047                                  ;		carry = clear
 19048                                  ;	Failure:
 19049                                  ;		carry = set
 19050                                  ;
 19051                                  ;Uses:
 19052                                  ;	es
 19053                                  ;
 19054                                  ;Preserves:
 19055                                  ;	cx, di
 19056                                  ;
 19057                                  ;*******************************************************************************
 19058                                  
 19059                                  ; 14/12/2018 (no need to _growseg for FDISK2.COM)
 19060                                  
 19061                                  ;_growseg:
 19062                                  ;		push	cx		; save caller's cx
 19063                                  ;		push	di		; save caller's di
 19064                                  
 19065                                  ; First, see if it is legal to grow this segment.
 19066                                  ; ds:bx = heap descriptor
 19067                                  
 19068                                  ;		;test	byte ptr [bx].flags,_HEAP_MODIFY
 19069                                  ;		test	byte [bx+2],1
 19070                                  ;		jz	short grow_error_rtn ; return error if modify bit clear
 19071                                  
 19072                                  ; Calculate how much we need to grow the segment by to satisfy the user's
 19073                                  ; request.
 19074                                  ; cx = size of block requested
 19075                                  
 19076                                  ;		call	_findlast	; si = pointer to last heap entry
 19077                                  ;		mov	di,si		; save pointer in di for later use
 19078                                  ;		mov	ax,[si] 	; length of last entry
 19079                                  ;		test	al,1		; is it free ??
 19080                                  ;		jz	short grow_calc_length ; no
 19081                                  ;		sub	cx,ax		; reduce requested length by free size
 19082                                  ;		dec	cx		; adjust for inc' below (only one dec
 19083                                  ;					; because free bit is set...)
 19084                                  ;grow_calc_length:
 19085                                  ;		inc	cx
 19086                                  ;		inc	cx		; add header field to size
 19087                                  ;
 19088                                  ;		;mov	si,[bx].segsize ; si = current size of segment
 19089                                  ;		mov     si,[bx+4]
 19090                                  ;		or	si,si		; already 64 Kb ??
 19091                                  ;		jz	short grow_error_rtn ; yep, go return an error
 19092                                  ;		add	cx,si		; cx = desired new size of segment
 19093                                  ;					; (not yet rounded by _amblksiz)
 19094                                  ;		jnc	short grow_size_ok ; legal segment size
 19095                                  
 19096                                  ; Special code to handle case of cx = 0 (i.e., requested new segment size is
 19097                                  ; exactly 64 K). This amounts to taking a shortcut to calling _incseg.
 19098                                  
 19099                                  ;		xor	ax,ax		; set newsize request to 64 Kb
 19100                                  ;		mov	dx,0FFF0h	; indicate paragraph increment
 19101                                  ;		jcxz	grow3		; shortcut!
 19102                                  ;		jmp	short grow_error_rtn
 19103                                  
 19104                                  ;	; Determine the optimal heap increment size.
 19105                                  ;grow_size_ok:
 19106                                  ;		push	ss		; es = DGROUP
 19107                                  ;		pop	es
 19108                                  
 19109                                  ;		;mov	ax,[es:_amblksiz] ; get increment size
 19110                                  ;	;;*** OPTIMIZATION: CODE WILL WORK WITHOUT THE FOLLOWING 2 INSTRUCTIONS
 19111                                  ;		;;cmp	ax,_HEAP_GROWSEG ; compare to default increment
 19112                                  ;		;cmp     ax,2000h
 19113                                  ;		;je	short grow1	; if equal, use the default
 19114                                  ;		;;fall thru
 19115                                  ;
 19116                                  ;		mov	ax,2000h ; 09/12/2018
 19117                                  
 19118                                  ; Compute the heap segment increment size.
 19119                                  ; That is, 2**N, where 2**N >= _amblksiz > 2**(N-1).
 19120                                  ; Test the values 2**(N-1), in descending order, until one is found that
 19121                                  ; is less than _amblksiz.  Then, shift the value left to get 2**N.
 19122                                  ; ax = _amblksiz
 19123                                  
 19124                                  ;		mov	dx,8000h	; start by testing 2**15
 19125                                  ;grow_next_size:
 19126                                  ;		cmp	dx,ax		; is current 2**(N-1) smaller?
 19127                                  ;		jb	short grow0	;  yep, dx = 2**(N-1)
 19128                                  ;		shr	dx,1		; di = next lower power of 2
 19129                                  ;		jnz	short grow_next_size ; try again...
 19130                                  ;		jmp	short grow_paragraph ; use increment size = paragraph
 19131                                  
 19132                                  ; --- grow ---
 19133                                  ; Try to grow the segment.
 19134                                  ;  (1) First, try to grow the segment by the optimal size
 19135                                  ;      (rounded up to an _amblksiz boundary).
 19136                                  ;  (2) If that fails, try to grow by just enough to fullfill the request
 19137                                  ;      (rounded up to a paragraph boundary).
 19138                                  ;
 19139                                  ;  [NOTE: We will try to grow the segment twice AT MOST.]
 19140                                  ;
 19141                                  ; cx = grow size necessary to fulfill caller's request
 19142                                  ; si = current size of heap segment
 19143                                  ; dx = 2**(N-1)
 19144                                  
 19145                                  ;;grow0:
 19146                                  ;;		cmp	dx,08h			; will increment be < paragraph ??
 19147                                  ;;		jb	short grow_paragraph	; yes, use paragraph increment
 19148                                  ;;		shl	dx,1			; dx = 2**N (if 0, that's ok)
 19149                                  ;;		mov	ax,dx			; ax = (power of 2)
 19150                                  ;;
 19151                                  
 19152                                  ;		; ax = heap seg increment size
 19153                                  ;grow1:
 19154                                  ;		dec	ax			; ax = (power of 2) - 1
 19155                                  ;		mov	dx,ax			; save for later
 19156                                  ;		add	ax,cx			; round up to next highest multiple
 19157                                  ;						; of (power of 2)
 19158                                  ;		jnc	short grow2		; overflow ??
 19159                                  ;		xor	ax,ax			; yes, grow to max seg size (0 = 64kb)
 19160                                  ;grow2:
 19161                                  ;		not	dx			; make ((power of 2) - 1) a mask
 19162                                  ;		and	ax,dx			; ax is now rounded up
 19163                                  ;grow3:
 19164                                  ;		push	dx			; save increment mask
 19165                                  ;		call	_incseg 		; *** try to grow the segment ***
 19166                                  ;		pop	dx			; restore increment mask
 19167                                  ;		jnc	short grow_good_rtn	; Good return on success
 19168                                  ;
 19169                                  ;		cmp	dx,0FFF0h		; error, was increment == paragraph ??
 19170                                  ;		je	short grow_error_rtn	; yes, no more we can do (return error)
 19171                                  ;
 19172                                  ;grow_paragraph:				; try an increment size of a paragraph
 19173                                  ;		mov	ax,10h			; ax = paragraph size
 19174                                  ;		jmp	short grow1		; try again
 19175                                  
 19176                                  ;  --- Error Return ---
 19177                                  
 19178                                  ;grow_error_rtn:
 19179                                  ;		stc				; carry set = error
 19180                                  ;		jmp	short grow_done		; return the error
 19181                                  
 19182                                  ; --- Good Return ---
 19183                                  ;
 19184                                  ; We successfully grew the heap segment.
 19185                                  ; Link the new free block into the heap and update pointers, _HEAP_END, etc.
 19186                                  ; ax = new segment size
 19187                                  ; ds:bx = heap descriptor
 19188                                  ; di = pointer to previous last heap entry
 19189                                  
 19190                                  ;grow_good_rtn:
 19191                                  ;		mov	dx,ax			; dx = new size
 19192                                  ;		;sub	dx,[bx].segsize 	; dx = segment increment
 19193                                  ;		sub	dx,[bx+4]
 19194                                  ;		;mov	[bx].segsize,ax 	; update segment size field
 19195                                  ;		mov     [bx+4],ax
 19196                                  ;
 19197                                  ;		;mov	[bx].rover,di		; rover = previous last entry (in di)
 19198                                  ;		mov	[bx+8],di
 19199                                  ;
 19200                                  ;		;mov	si,[bx].last		; si = pointer to old _HEAP_END
 19201                                  ;		mov	si,[bx+10]
 19202                                  ;		dec	dx			; dx = length of block marked free
 19203                                  ;		mov	[si],dx 		; put length of new block in heap
 19204                                  ;
 19205                                  ;		inc	dx			; dx = length of new block + header
 19206                                  ;		add	si,dx			; si = points to new end of heap
 19207                                  ;		;mov	[si],_HEAP_END		; mark new end of heap
 19208                                  ;		mov     word [si],0FFFEh
 19209                                  ;		;mov	[bx].last,si		; update .last pointer
 19210                                  ;		mov	[bx+10],si
 19211                                  ;	
 19212                                  ;	;fall thru (not that the carry flag was cleared by the add above!)
 19213                                  
 19214                                  ; Common Return
 19215                                  ; ax = return value
 19216                                  
 19217                                  ;grow_done:
 19218                                  ;		pop	di			; restore caller's di
 19219                                  ;		pop	cx			; restore caller's cx
 19220                                  ;		retn
 19221                                  
 19222                                  ; _incseg - Increment the segment
 19223                                  ;
 19224                                  ;Purpose:
 19225                                  ;	This routine issues the OS call that actually grows/shrinks the
 19226                                  ;	heap segment.
 19227                                  ;
 19228                                  ;	NOTE: This routine is meant for internal use only.
 19229                                  ;
 19230                                  ;	DOS NOTE: The 'segsize' value in the near heap descriptor
 19231                                  ;	indicates the top of the heap, NOT the current size of DGROUP.
 19232                                  ;	Thus, we must check the REAL size of DGROUP to see if we
 19233                                  ;	really need to grow the heap (_asizds).   Also, growing
 19234                                  ;	the near heap must be based on the _psp segment, not DGROUP
 19235                                  ;
 19236                                  ;ifdef	_WINDOWS
 19237                                  ;	WINDOWS NOTE:  Do to a Windows restriction/bug, you should not
 19238                                  ;	grow a segment to exactly 64K in standard mode.
 19239                                  ;endif
 19240                                  ;
 19241                                  ;Entry:
 19242                                  ;	ax = new segment size (0 indicates a segment size of 64 Kb)
 19243                                  ;	     [***NOTE***: This value MUST be rounded up to a paragraph
 19244                                  ;	     boundary by the caller.]
 19245                                  ;	ds:bx = heap descriptor
 19246                                  ;Exit:
 19247                                  ;	Success:
 19248                                  ;		carry = clear
 19249                                  ;		ax = new segment size (0 indicates a segment size of 64 Kb)
 19250                                  ;	Failure:
 19251                                  ;		carry = set
 19252                                  ;
 19253                                  ;Preserves:
 19254                                  ;	ds:bx, cx, di
 19255                                  ;
 19256                                  ;Uses:
 19257                                  ;	ax, dx, si, es
 19258                                  ;
 19259                                  ;Exceptions:
 19260                                  ;
 19261                                  ;*******************************************************************************
 19262                                  
 19263                                  ;_incseg:
 19264                                  ;		mov	dx,ax		; save requested size
 19265                                  ;
 19266                                  ;; --- Special near heap code ---
 19267                                  ;;
 19268                                  ;; Growing:  We don't have to issue a call if there's room between heap and
 19269                                  ;; _asizds.
 19270                                  ;;
 19271                                  ;; Shrinking:  If the new size is less than the current size, issue the call to
 19272                                  ;; shrink the segment.  Also, if the new size is EQUAL to the current size,
 19273                                  ;; issue the call since we want to free up unused DGROUP above the heap but
 19274                                  ;; below _asizds.  [Note: _Minseg() has already determined that an OS call is
 19275                                  ;; necessary in this case.]
 19276                                  ;
 19277                                  ;		;test	byte ptr [bx].flags,_HEAP_NEAR ; near heap descriptor ?
 19278                                  ;		test	byte [bx+2],4
 19279                                  ;		jz	short do_oscall1 ; nope
 19280                                  ;
 19281                                  ;		dec	dx		; dx = new segsize - 1
 19282                                  ;		;mov	si,[bx].segsize ; get current segment size
 19283                                  ;		mov	si, [bx+4]
 19284                                  ;		dec	si		; cx = current segsize - 1
 19285                                  ;		cmp	dx,si		; are we shrinking the segment ??
 19286                                  ;		jbe	short do_oscall	; yes, issue the system call
 19287                                  ;
 19288                                  ;		cmp	[bx-2],dx	; _asizds > current segsize ??
 19289                                  ;		jae	short incseg_ok	; yup, no need to issue system call
 19290                                  ;do_oscall:
 19291                                  ;		inc	dx			; nope, restore dx
 19292                                  ;
 19293                                  ;; Issue the system call
 19294                                  ;; ax = dx = desired size
 19295                                  
 19296                                  ;do_oscall1:
 19297                                  ;		push	bx		; save heap descriptor
 19298                                  ;		push	cx		; save cx value
 19299                                  ;		mov	si,ds		; es = si = heap segment
 19300                                  ;		mov	es,si
 19301                                  ;		mov	cl,4		; cl = shift count
 19302                                  ;		shr	ax,cl		; ax = paragraph count
 19303                                  ;		jnz	short do_oscall2 ; if ax != 0, use it
 19304                                  ;		mov	ax,1000h	; if ax == 0, set it to 1000h
 19305                                  ;					; paragraphs (i.e., 64 KB)
 19306                                  ;do_oscall2:
 19307                                  ;		;test	byte ptr [bx].flags,_HEAP_NEAR ; near heap descriptor ?
 19308                                  ;		test    byte [bx+2],4
 19309                                  ;		jz	short do_oscall3 ; nope, issue the system call
 19310                                  ;
 19311                                  ;		; use _psp segment, not DGROUP
 19312                                  ;		add	ax,si		; yes, add in DGROUP seg
 19313                                  ;		mov	bx,[_psp]	; PSP base
 19314                                  ;		sub	ax,bx		; subtract PSP base
 19315                                  ;		mov	es,bx		; es = PSP base
 19316                                  ;do_oscall3:				; ax = new size (para) / es = heap seg
 19317                                  ;		mov	bx,ax		; bx = new segment size (para)
 19318                                  ;		;callos	setmem		; set the heap segment size
 19319                                  ;
 19320                                  ;		mov	ah,4Ah
 19321                                  ;		int	21h	; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
 19322                                  ;				; ES = segment address of block to change
 19323                                  ;				; BX = new size in paragraphs
 19324                                  ;		pop	cx		; restore cx
 19325                                  ;		pop	bx		; restore heap descriptor
 19326                                  ;		jc	short incseg_done ; error - carry is set
 19327                                  ;		;fall thru
 19328                                  ;
 19329                                  ;; --- Good return ---
 19330                                  ;
 19331                                  ;		mov	ax,dx			; return size
 19332                                  ;		;test	byte ptr [bx].flags,_HEAP_NEAR ; near heap descriptor ?
 19333                                  ;		test	byte [bx+2],4
 19334                                  ;		jz	short incseg_ok	; nope, return
 19335                                  ;
 19336                                  ;		; Near heap so update _asizds.
 19337                                  ;		; Use offset from _nheap_desc so DLL will work
 19338                                  ;		dec	dx			; dx = dgroup - 1
 19339                                  ;		mov	[bx-2],dx		; update _asizds
 19340                                  ;incseg_ok:				; ax = new seg size
 19341                                  ;		clc				; carry clear on success
 19342                                  ;		jmp	short incseg_done	; common return
 19343                                  ;
 19344                                  ;; --- Error return ---
 19345                                  ;
 19346                                  ;incseg_err:
 19347                                  ;		;stc				; carry set on error
 19348                                  ;
 19349                                  ;; --- Common return ---
 19350                                  ;
 19351                                  ;incseg_done:
 19352                                  ;		retn
 19353                                  
 19354                                  ;***
 19355                                  ; _findlast - Find the last entry in a heap descriptor segment
 19356                                  ;
 19357                                  ;Purpose:
 19358                                  ;	Given a heap descriptor, return a pointer to the last
 19359                                  ;	entry in that heap segment.
 19360                                  ;
 19361                                  ;Entry:
 19362                                  ;	ds:bx = heap segment descriptor
 19363                                  ;
 19364                                  ;Exit:
 19365                                  ;	si = pointer to header of last entry in that segment
 19366                                  ;
 19367                                  ;Uses:
 19368                                  ;	ax
 19369                                  ;
 19370                                  ;Preserves:
 19371                                  ;	bx, cx, dx, di, ds, es
 19372                                  ;
 19373                                  ;Exceptions:
 19374                                  ;
 19375                                  ;*******************************************************************************
 19376                                  
 19377                                  ; 14/12/2018 (no need to _findlast for FDISK2.COM)
 19378                                  
 19379                                  ;_findlast:
 19380                                  ;		push	di		; save caller's di
 19381                                  ;
 19382                                  ;		;mov	si,[bx].rover	; si = rover pointer
 19383                                  ;		mov	si,[bx+8]
 19384                                  ;		;cmp	si,[bx].last	; does .rover = .last?
 19385                                  ;		cmp	si,[bx+10]
 19386                                  ;		jne	short lastloop	; no, go begin search
 19387                                  ;		;mov	si,[bx].start	; yes, must begin search at .start
 19388                                  ;		mov	si,[bx+6]
 19389                                  ;lastloop:
 19390                                  ;		lodsw			; ax = size of heap entry
 19391                                  ;		;cmp	ax,_HEAP_END	; end of heap ?
 19392                                  ;		cmp     ax,0FFFEh
 19393                                  ;		je	short lastdone	; yup, finish up
 19394                                  ;		mov	di,si		; save current pointer
 19395                                  ;		;and	al,not 1	; nope, mask off free/use bit
 19396                                  ;		and	al,0FEh
 19397                                  ;		add	si,ax		; si = pointer to next entry
 19398                                  ;		;jc	heaptoast	; *** error, heap is toasty... ***
 19399                                  ;		jmp	short lastloop	; try next one
 19400                                  ;lastdone:				; found the end
 19401                                  ;		dec	di
 19402                                  ;		dec	di		; back up saved pointer to header
 19403                                  ;		mov	si,di		; si = pointer to last heap entry header
 19404                                  ;
 19405                                  ;		pop	di		; restore caller's di
 19406                                  ;		retn
 19407                                  
 19408                                  ; ----------------------------------------------------------------------------
 19409                                  ; input.c (FDISK, MSDOS 6.0, 1991)	
 19410                                  ; ----------------------------------------------------------------------------
 19411                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 09/12/2018)
 19412                                  
 19413                                  ;char get_num_input(input_default,max_num,row,col)
 19414                                  ;
 19415                                  ;char      max_num;
 19416                                  ;unsigned  row;
 19417                                  ;unsigned  col;
 19418                                  ;char	   input_default;
 19419                                  ;
 19420                                  ;BEGIN
 19421                                  ;
 19422                                  ;    char  input;
 19423                                  ;
 19424                                  ;    /* SR;9/25/89; Initialize this on entry */
 19425                                  ;    char  default_used = FALSE;
 19426                                  ;    char  input_value;
 19427                                  ;
 19428                                  ;    char            attribute;
 19429                                  ;    char far        *attribute_ptr = &attribute;
 19430                                  ;    char far *input_ptr = &input;
 19431                                  ;
 19432                                  ;    if (mono_flag == TRUE)
 19433                                  ;       attribute = HIWHITE_ON_BLACK; /*C09*/
 19434                                  ;    else
 19435                                  ;       attribute = HIWHITE_ON_BLUE;  /*C09*/
 19436                                  ;
 19437                                  ;    /* print default entry if there is one */
 19438                                  ;    if (input_default != c(NUL))                                 /* AC000 */
 19439                                  ;
 19440                                  ;       BEGIN
 19441                                  ;        default_used = TRUE;
 19442                                  ;        /* position the cursor */
 19443                                  ;        VIOSETCURPOS(row,col,u(0));                              /* AC000 */
 19444                                  ;
 19445                                  ;        /* Display the default character */
 19446                                  ;
 19447                                  ;        input = c(input_default+'0');
 19448                                  ;        VIOWRTCHARSTRATT(input_ptr,u(1),row,col,attribute_ptr,u(0));
 19449                                  ;       END
 19450                                  ;
 19451                                  ;    /* Assume bad input */
 19452                                  ;    valid_input = FALSE;
 19453                                  ;
 19454                                  ;    /* Loop until we get good stuff */
 19455                                  ;    while (valid_input == FALSE)
 19456                                  ;        BEGIN
 19457                                  ;
 19458                                  ;        /* position the cursor */
 19459                                  ;        VIOSETCURPOS(row,col,u(0));                             /* AC000 */
 19460                                  ;
 19461                                  ;        /* Flush the keyboard buffer and get the next pressed key */
 19462                                  ;        input = get_char_input();
 19463                                  ;
 19464                                  ;        /* Do world trade get country information */
 19465                                  ;        input = dos_upper(input);                          /* AN000 */
 19466                                  ;
 19467                                  ;        /* Go handle different inputs */
 19468                                  ;        switch(input)
 19469                                  ;           BEGIN
 19470                                  ;            case ESC:
 19471                                  ;                BEGIN
 19472                                  ;                 valid_input = TRUE;
 19473                                  ;                 break;
 19474                                  ;                END
 19475                                  ;
 19476                                  ;            case CR:
 19477                                  ;                BEGIN
 19478                                  ;                /* Set the input to the default if there is one there */
 19479                                  ;                if (default_used)
 19480                                  ;                    BEGIN
 19481                                  ;                     if (input_default != c(NUL))
 19482                                  ;                        BEGIN
 19483                                  ;                         input_value = input_default+'0';
 19484                                  ;                        END
 19485                                  ;                     else
 19486                                  ;                        BEGIN
 19487                                  ;                         /* Make the enter look like a blank for error message */
 19488                                  ;                         input_value = c(' ');                 /* AC000 */
 19489                                  ;                        END
 19490                                  ;                    END
 19491                                  ;                /* See if it is digit and less or equal to max */
 19492                                  ;                if ( (isdigit(input_value))         &&
 19493                                  ;                     (input_value <= (max_num+'0')) &&
 19494                                  ;                     (input_value != c('0')) )
 19495                                  ;                    BEGIN
 19496                                  ;                     valid_input = TRUE;
 19497                                  ;                     input = input_value;
 19498                                  ;                    END
 19499                                  ;                else
 19500                                  ;                    BEGIN
 19501                                  ;                    if (isdigit(input_value))
 19502                                  ;                       BEGIN
 19503                                  ;                        /* Setup error message */
 19504                                  ;                        insert[0] = input_value;
 19505                                  ;                        insert[1] = c('1');                    /* AC000 */
 19506                                  ;                        insert[2] = c('-');                    /* AC000 */
 19507                                  ;                        insert[3] = max_num+'0';
 19508                                  ;                        display(error_23);
 19509                                  ;                       END
 19510                                  ;                    else
 19511                                  ;                       BEGIN
 19512                                  ;                        insert[0] = c('1');                    /* AC000 */
 19513                                  ;                        insert[1] = c('-');                    /* AC000 */
 19514                                  ;                        insert[2] = max_num+'0';
 19515                                  ;                        display(error_31);
 19516                                  ;                       END
 19517                                  ;                    END
 19518                                  ;                break;
 19519                                  ;                END
 19520                                  ;
 19521                                  ;            default:
 19522                                  ;               BEGIN
 19523                                  ;                /* SR; 10/2/89; If Ctrl-C, display blank and beep */
 19524                                  ;                if ( (isdigit(input))         &&                        /*C16*/
 19525                                  ;                     (input <= (max_num+'0')) &&                        /*C16*/
 19526                                  ;                     (input != c('0')) )                                /*C16*/
 19527                                  ;                    clear_screen(u(23),u(0),u(23),u(79));               /*C16*/
 19528                                  ;                else                                                    /*C16*/
 19529                                  ;                    {                                                   /*C16*/
 19530                                  ;                    if (isdigit(input))                                 /*C16*/
 19531                                  ;                        {                                               /*C16*/
 19532                                  ;                        /* Setup error message */                       /*C16*/
 19533                                  ;                        insert[0] = input;                              /*C16*/
 19534                                  ;                        insert[1] = c('1');                             /*C16*/
 19535                                  ;                        insert[2] = c('-');                             /*C16*/
 19536                                  ;                        insert[3] = max_num+'0';                        /*C16*/
 19537                                  ;                        display(error_23);                              /*C16*/
 19538                                  ;                        }                                               /*C16*/
 19539                                  ;                    else                                                /*C16*/
 19540                                  ;                        {                                               /*C16*/
 19541                                  ;                        insert[0] = c('1');                             /*C16*/
 19542                                  ;                        insert[1] = c('-');                             /*C16*/
 19543                                  ;                        insert[2] = max_num+'0';                        /*C16*/
 19544                                  ;                        display(error_31);                              /*C16*/
 19545                                  ;                        }                                               /*C16*/
 19546                                  ;                    input = c(' ');                                     /*C16*/
 19547                                  ;                    }                                                   /*C16*/
 19548                                  ;                VIOWRTCHARSTRATT(input_ptr,u(1),row,col,attribute_ptr,u(0)); /*C16*/
 19549                                  ;                default_used = FALSE;
 19550                                  ;                input_value = input;
 19551                                  ;                break;
 19552                                  ;                END
 19553                                  ;            END
 19554                                  ;        END
 19555                                  ;     return(input);
 19556                                  ;END
 19557                                  
 19558                                  get_num_input:
 19559                                  	;char get_num_input(input_default,max_num,row,col)
 19560                                  
 19561                                  	%define input_value	bp-16
 19562                                  	%define gni_attr_ptr	bp-14
 19563                                  	;%define gni_attr_ptr_2 bp-12
 19564                                  	%define default_used	bp-10
 19565                                  	%define gni_input_ptr	bp-8
 19566                                  	;%define gni_input_ptr_2 bp-6
 19567                                  	%define gni_attribute	bp-4
 19568                                  	%define gni_input	bp-2
 19569                                  
 19570                                  	%define input_default	bp+4
 19571                                  	%define gni_max_num	bp+6
 19572                                  	%define gni_row		bp+8
 19573                                  	%define gni_column	bp+10
 19574                                  
 19575 00002A6A 55                      		push	bp
 19576 00002A6B 89E5                    		mov	bp,sp
 19577 00002A6D 83EC10                  		sub	sp,16
 19578                                  
 19579                                  		;/* Initialize this on entry */
 19580 00002A70 C646F600                		mov	byte [default_used],0
 19581                                  		
 19582 00002A74 8D46FC                  		lea	ax,[gni_attribute]
 19583 00002A77 8946F2                  		mov	[gni_attr_ptr],ax
 19584                                  		;mov	[gni_attr_ptr_2],ss
 19585 00002A7A 8C56F4                  		mov	[gni_attr_ptr+2],ss
 19586 00002A7D 8D4EFE                  		lea	cx,[gni_input]
 19587 00002A80 894EF8                  		mov	[gni_input_ptr],cx
 19588                                  		;mov	[gni_input_ptr_2],ss
 19589 00002A83 8C56FA                  		mov	[gni_input_ptr+2],ss
 19590                                  
 19591                                  		;if (mono_flag == TRUE)
 19592                                  		;       attribute = HIWHITE_ON_BLACK;
 19593                                  		;    else
 19594                                  		;       attribute = HIWHITE_ON_BLUE;
 19595                                  
 19596 00002A86 803E[CAC3]01            		cmp	byte [mono_flag],1
 19597 00002A8B 7506                    		jnz	short gni_1
 19598 00002A8D C646FC0F                		mov	byte [gni_attribute],0Fh ; HIWHITE_ON_BLACK
 19599 00002A91 EB04                    		jmp	short gni_2
 19600                                  gni_1:
 19601 00002A93 C646FC1F                		mov	byte [gni_attribute],1Fh ; HIWHITE_ON_BLUE
 19602                                  gni_2:
 19603                                  		;/* print default entry if there is one */
 19604                                  		;if (input_default != c(NUL))  
 19605                                  
 19606 00002A97 807E0400                		cmp	byte [input_default],0
 19607 00002A9B 742E                    		je	short gni_3
 19608 00002A9D C646F601                		mov	byte [default_used],1
 19609                                  
 19610                                  		;/* position the cursor */
 19611                                  		;VIOSETCURPOS(row,col,u(0));   
 19612                                  
 19613                                  		;push	word [gni_row]
 19614                                  		;push	word [gni_column]
 19615                                  		;sub	ax,ax ; 0
 19616                                  		;push	ax
 19617                                  		; 09/12/2018
 19618 00002AA1 8A7608                  		mov	dh,[gni_row]
 19619 00002AA4 8A560A                  		mov	dl,[gni_column]
 19620 00002AA7 E86C01                  		call	VIOSETCURPOS
 19621                                  
 19622                                  		;/* Display the default character */
 19623                                  		;input = c(input_default+'0');
 19624                                  		;VIOWRTCHARSTRATT(input_ptr,u(1),row,col,attribute_ptr,u(0));
 19625                                  
 19626 00002AAA 8A4604                  		mov	al,[input_default]
 19627 00002AAD 0430                    		add	al,'0'
 19628 00002AAF 8846FE                  		mov	[gni_input],al
 19629                                  		;push	word [gni_input_ptr_2]
 19630 00002AB2 FF76FA                  		push	word [gni_input_ptr+2]
 19631 00002AB5 FF76F8                  		push	word [gni_input_ptr]
 19632 00002AB8 B80100                  		mov	ax,1
 19633 00002ABB 50                      		push	ax
 19634 00002ABC FF7608                  		push	word [gni_row]
 19635 00002ABF FF760A                  		push	word [gni_column]
 19636                                  		;push	word [gni_attr_ptr_2]
 19637 00002AC2 FF76F4                  		push	word [gni_attr_ptr+2]
 19638 00002AC5 FF76F2                  		push	word [gni_attr_ptr]
 19639                                  		; 09/12/2018
 19640                                  		;sub	ax,ax ; 0
 19641                                  		;push	ax
 19642 00002AC8 E80EEE                  		call	VIOWRTCHARSTRATT
 19643                                  gni_3:
 19644                                  		;/* Assume bad input */
 19645                                  		; 15/12/2018
 19646 00002ACB C606[DECB]00            		mov	byte [valid_input],0
 19647                                  gni_4:
 19648                                  		;/* Loop until we get good stuff */
 19649                                  		;while (valid_input == FALSE)
 19650                                  
 19651                                  		;/* position the cursor */
 19652                                  		;VIOSETCURPOS(row,col,u(0)); 
 19653                                  
 19654                                  		;push	word [gni_row]
 19655                                  		;push	word [gni_column]
 19656                                  		;sub	ax,ax ; 0
 19657                                  		;push	ax
 19658                                  		; 09/12/2018
 19659 00002AD0 8A7608                  		mov	dh,[gni_row]
 19660 00002AD3 8A560A                  		mov	dl,[gni_column]
 19661 00002AD6 E83D01                  		call	VIOSETCURPOS
 19662                                  
 19663                                  		;/* Flush the keyboard buffer and get the next pressed key */
 19664                                  		;input = get_char_input();
 19665                                  	
 19666 00002AD9 E82D01                  		call	get_char_input
 19667                                  		;mov	[gni_input],al
 19668                                  	
 19669                                  		;/* Do world trade get country information */
 19670                                  		;input = dos_upper(input);
 19671                                  		; 15/12/2018                      
 19672                                  		;push	ax
 19673 00002ADC E84F01                  		call	dos_upper
 19674                                  		;pop	bx
 19675 00002ADF 8846FE                  		mov	[gni_input],al
 19676                                  switch_gni_input:
 19677                                  		;/* Go handle different inputs */	
 19678                                  		;switch(input)
 19679                                  		
 19680                                  		;cbw
 19681                                  		;sub	ax,0Dh  ; CR ?
 19682 00002AE2 2C0D                    		sub	al,0Dh
 19683 00002AE4 743F                    		jz	short case_gni_CR  ; yes
 19684                                  		;sub	ax,0Eh  ; 0Dh+0Eh = 1Bh  ; ESC ? 
 19685 00002AE6 2C0E                    		sub	al,0Eh
 19686 00002AE8 7433                    		jz	short case_gni_ESC ; yes
 19687                                  
 19688                                  		; /* If Ctrl-C, display blank and beep */
 19689                                  		; if ((isdigit(input))  
 19690                                  
 19691                                  		; 02/01/2019
 19692                                  		;mov	al,[gni_input]
 19693                                  		;cbw
 19694                                  		;mov	bx,ax
 19695 00002AEA 30FF                    		xor	bh,bh
 19696 00002AEC 8A5EFE                  		mov	bl,[gni_input]
 19697 00002AEF F687[FC9E]04            		test	byte [isdigit+bx],4
 19698                                  		;jz	short gni_not_digit
 19699 00002AF4 0F84C400                		jz	gni_12 ; 02/01/2019
 19700 00002AF8 8A4606                  		mov	al,[gni_max_num]
 19701 00002AFB 98                      		cbw
 19702 00002AFC 83C030                  		add	ax,'0'
 19703 00002AFF 39D8                    		cmp	ax,bx
 19704 00002B01 7C05                    		jl	short gni_not_digit
 19705                                  		;cmp	byte [gni_input],'0'
 19706 00002B03 80FB30                  		cmp	bl,'0' ; 02/01/2019
 19707 00002B06 7503                    		jne	short gni_5
 19708                                  gni_not_digit:
 19709 00002B08 E99400                  		jmp	gni_11
 19710                                  gni_5:
 19711 00002B0B B84F00                  		mov	ax,79
 19712 00002B0E 50                      		push	ax
 19713 00002B0F B81700                  		mov	ax,23
 19714 00002B12 50                      		push	ax
 19715 00002B13 29C9                    		sub	cx,cx
 19716 00002B15 51                      		push	cx
 19717 00002B16 50                      		push	ax
 19718 00002B17 E87CE9                  		call	clear_screen
 19719                                  		;add	sp,8
 19720 00002B1A E9BD00                  		jmp	gni_14
 19721                                  case_gni_ESC:
 19722 00002B1D C606[DECB]01            		mov	byte [valid_input],1
 19723                                  		;jmp	case_gni_break
 19724 00002B22 E9DB00                  		jmp	gni_15 ; 15/12/2018
 19725                                  case_gni_CR:
 19726                                  		;/* Set the input to the default if there is one there */
 19727                                                  ;if (default_used)
 19728                                  		
 19729 00002B25 807EF600                		cmp	byte [default_used],0
 19730 00002B29 7414                    		je	short gni_7
 19731                                  
 19732                                  		;if (input_default != c(NUL))
 19733                                  
 19734 00002B2B 807E0400                		cmp	byte [input_default],0
 19735 00002B2F 740A                    		je	short gni_6
 19736                                  
 19737                                  		;input_value = input_default+'0';
 19738 00002B31 8A4604                  		mov	al,[input_default]
 19739 00002B34 0430                    		add	al,'0'
 19740 00002B36 8846F0                  		mov	[input_value],al
 19741 00002B39 EB04                    		jmp	short gni_7
 19742                                  gni_6:
 19743                                  		;/* Make the enter look like a blank for error message */
 19744                                  		;input_value = c(' '); 
 19745 00002B3B C646F020                		mov	byte [input_value],' '
 19746                                  gni_7:
 19747                                  		;/* See if it is digit and less or equal to max */
 19748                                                  ;if ( (isdigit(input_value))         &&
 19749                                                  ;     (input_value <= (max_num+'0')) &&
 19750                                                  ;     (input_value != c('0')) )
 19751                                  
 19752                                  		; 02/01/2019
 19753                                  		;mov	al,[input_value]
 19754                                  		;cbw
 19755                                  		;mov	bx,ax
 19756 00002B3F 28FF                    		sub	bh,bh
 19757 00002B41 8A5EF0                  		mov	bl,[input_value]
 19758 00002B44 F687[FC9E]04            		test	byte [isdigit+bx],4
 19759                                  		;jz	short gni_8
 19760 00002B49 7437                    		jz	short gni_9
 19761                                  
 19762 00002B4B 8A4606                  		mov	al,[gni_max_num]
 19763 00002B4E 98                      		cbw
 19764 00002B4F 83C030                  		add	ax,'0'
 19765 00002B52 39D8                    		cmp	ax,bx
 19766 00002B54 7C0F                    		jl	short gni_8
 19767                                  		;cmp	byte [input_value],'0'
 19768 00002B56 80FB30                  		cmp	bl,'0' ; 02/01/2019
 19769 00002B59 740A                    		je	short gni_8
 19770                                  
 19771                                  		;valid_input = TRUE;
 19772                                  		;input = input_value;
 19773                                  
 19774 00002B5B C606[DECB]01            		mov	byte [valid_input],1
 19775                                  		;mov	al,[input_value]
 19776 00002B60 88D8                    		mov	al,bl ; 02/01/2019
 19777                                  		;mov	[gni_input],al
 19778                                  		;jmp	case_gni_break
 19779 00002B62 E99E00                  		jmp	gni_16 ; 15/12/2018
 19780                                  gni_8:
 19781                                  		;if (isdigit(input_value))
 19782                                  
 19783                                  		; 02/01/2019
 19784                                  		;mov	al,[input_value]
 19785                                  		;cbw
 19786                                  		;mov	bx,ax
 19787                                  		;test	byte [isdigit+bx],4
 19788                                  		;jz	short gni_9
 19789                                  
 19790                                  		;/* Setup error message */
 19791                                  		;insert[0] = input;
 19792                                  		;insert[1] = c('1');
 19793                                  		;insert[2] = c('-');
 19794                                  		;insert[3] = max_num+'0';
 19795                                  		;display(error_23);      
 19796                                  		
 19797                                  		;mov	[insert],al
 19798 00002B65 881E[E6CC]              		mov	[insert],bl ; 02/01/2019
 19799 00002B69 C606[E7CC]31            		mov	byte [insert+1],'1'
 19800 00002B6E C606[E8CC]2D            		mov	byte [insert+2],'-'
 19801 00002B73 8A4606                  		mov	al,[gni_max_num]
 19802 00002B76 0430                    		add	al,'0'
 19803 00002B78 A2[E9CC]                		mov	[insert+3],al
 19804                                  		;push	word [error_23_seg]
 19805 00002B7B 1E                      		push	ds
 19806 00002B7C FF36[9E9E]              		push	word [error_23_off]
 19807 00002B80 EB17                    		jmp	short gni_10
 19808                                  gni_9:
 19809                                  		;else 
 19810                                  		 ;insert[0] = c('1');
 19811                                  		 ;insert[1] = c('-');
 19812                                  		 ;insert[2] = max_num+'0';
 19813                                  		 ;display(error_31);
 19814                                  		
 19815 00002B82 C606[E6CC]31            		mov	byte [insert],'1'
 19816 00002B87 C606[E7CC]2D            		mov	byte [insert+1],'-'
 19817 00002B8C 8A4606                  		mov	al,[gni_max_num]
 19818 00002B8F 0430                    		add	al,'0'
 19819 00002B91 A2[E8CC]                		mov	byte [insert+2],al
 19820                                  		;push	word [error_31_seg]
 19821 00002B94 1E                      		push	ds
 19822 00002B95 FF36[AE9E]              		push	word [error_31_off]
 19823                                  gni_10:
 19824 00002B99 E87EEA                  		call	display
 19825                                  		;pop	bx
 19826                                  		;pop	bx
 19827                                  		;jmp	short case_gni_break
 19828 00002B9C E931FF                  		jmp	gni_4 ; 15/12/2018
 19829                                  gni_11:
 19830                                  		;else
 19831                                  		; insert[0] = c('1');
 19832                                  		; insert[1] = c('-');
 19833                                  		; insert[2] = max_num+'0';
 19834                                  		; display(error_31);
 19835                                  
 19836                                  		; 02/01/2019
 19837                                  		;mov	al,[gni_input]
 19838                                  		;cbw
 19839                                  		;mov	bx,ax
 19840                                  		;test	byte [isdigit+bx],4
 19841                                  		;jz	short gni_12
 19842                                  
 19843                                  		;mov	[insert],al
 19844 00002B9F 881E[E6CC]              		mov	[insert],bl ; 02/01/2019
 19845 00002BA3 C606[E7CC]31            		mov	byte [insert+1],'1'
 19846 00002BA8 C606[E8CC]2D            		mov	byte [insert+2],'-'
 19847 00002BAD 8A4606                  		mov	al,[gni_max_num]
 19848 00002BB0 0430                    		add	al,'0'
 19849 00002BB2 A2[E9CC]                		mov	[insert+3],al
 19850                                  		;push	word [error_23_seg]
 19851 00002BB5 1E                      		push	ds
 19852 00002BB6 FF36[9E9E]              		push	word [error_23_off]
 19853 00002BBA EB17                    		jmp	short gni_13
 19854                                  gni_12:
 19855 00002BBC C606[E6CC]31            		mov	byte [insert],'1'
 19856 00002BC1 C606[E7CC]2D            		mov	byte [insert+1],'-'
 19857 00002BC6 8A4606                  		mov	al,[gni_max_num]
 19858 00002BC9 0430                    		add	al,'0'
 19859 00002BCB A2[E8CC]                		mov	[insert+2],al
 19860                                  		;push	word [error_31_seg]
 19861 00002BCE 1E                      		push	ds
 19862 00002BCF FF36[AE9E]              		push	word [error_31_off]
 19863                                  gni_13:
 19864 00002BD3 E844EA                  		call	display
 19865                                  		;pop	bx
 19866                                  		;pop	bx
 19867                                  
 19868                                  		;input = c(' ');  
 19869 00002BD6 C646FE20                		mov	byte [gni_input],' '
 19870                                  gni_14:
 19871                                  		;push	word [gni_input_ptr_2]
 19872 00002BDA FF76FA                  		push	word [gni_input_ptr+2]
 19873 00002BDD FF76F8                  		push	word [gni_input_ptr]
 19874 00002BE0 B80100                  		mov	ax,1
 19875 00002BE3 50                      		push	ax
 19876 00002BE4 FF7608                  		push	word [gni_row]
 19877 00002BE7 FF760A                  		push	word [gni_column]
 19878                                  		;push	word [gni_attr_ptr_2]
 19879 00002BEA FF76F4                  		push	word [gni_attr_ptr+2]
 19880 00002BED FF76F2                  		push	word [gni_attr_ptr]
 19881                                  		; 09/12/2018
 19882                                  		;sub	ax,ax ; 0
 19883                                  		;push	ax
 19884 00002BF0 E8E6EC                  		call	VIOWRTCHARSTRATT
 19885 00002BF3 C646F600                		mov	byte [default_used],0
 19886 00002BF7 8A46FE                  		mov	al,[gni_input]
 19887 00002BFA 8846F0                  		mov	[input_value],al
 19888                                  		; 15/12/2018
 19889                                  ;case_gni_break:
 19890                                  ;		cmp	byte [valid_input],0
 19891                                  ;		jne	short gni_15
 19892 00002BFD E9D0FE                  		jmp	gni_4
 19893                                  gni_15:
 19894 00002C00 8A46FE                  		mov	al,[gni_input]
 19895                                  gni_16:			; 15/12/2018
 19896 00002C03 89EC                    		mov	sp,bp
 19897 00002C05 5D                      		pop	bp
 19898                                  		;retn
 19899 00002C06 C20800                  		retn	8 ; 15/12/2018
 19900                                  
 19901                                  ; input.c - get_char_input
 19902                                  ; ----------------------------------------------------------------------------
 19903                                  
 19904                                  ;/*  */
 19905                                  ;char    get_char_input()
 19906                                  ;
 19907                                  ;BEGIN
 19908                                  ;    regs.h.ah = uc(0x0C);                                           /* AC000 */
 19909                                  ;    regs.h.al = uc(0x07);                                           /* AC000 */
 19910                                  ;    intdos(&regs,&regs);
 19911                                  ;    if (regs.h.al == uc(0))                                         /* AC000 */
 19912                                  ;        BEGIN
 19913                                  ;        DOSBEEP(u(900),u(400));                                     /* AC000 */
 19914                                  ;        END
 19915                                  ;    return(((char)(regs.h.al)));
 19916                                  ;
 19917                                  ;END
 19918                                  
 19919                                  ; 09/12/2018
 19920                                  
 19921                                  get_char_input:
 19922                                  		; Flush STDIN (keyboard) buffer 
 19923                                  		; and then, read character from STDIN (without ECHO)
 19924                                  
 19925                                  		;mov	byte [regs_x_ax+1],0Ch  ;ah = 0Ch
 19926                                  		;mov	byte [regs_x_ax],7 ; al = 7
 19927                                  
 19928                                  		;mov	ax,regs_x_ax
 19929                                  		;push	ax
 19930                                  		;push	ax
 19931                                  		;call	intdos
 19932                                  		;pop	bx
 19933                                  		;pop	bx
 19934                                  
 19935                                  		;cmp	byte [regs_x_ax],0
 19936                                  		;jne	short gci_1
 19937                                  
 19938 00002C09 B8070C                  		mov	ax,0C07h    ; **2018**	
 19939 00002C0C CD21                    		int	21h	    ; **2018**	
 19940                                  
 19941 00002C0E 08C0                    		or	al,al	    ; **2018**
 19942 00002C10 7503                    		jnz	short gci_1 ; **2018**	
 19943                                  
 19944                                  		; 01/01/2019
 19945                                  		;mov	ax,900
 19946                                  		;push	ax
 19947                                  		;mov	ax,400
 19948                                  		;push	ax
 19949 00002C12 E828ED                  		call	DOSBEEP
 19950                                  		; 01/01/2019
 19951                                  		;xor	ax,ax ; 15/12/2018
 19952                                  gci_1:
 19953                                  		;mov	al,[regs_x_ax]
 19954 00002C15 C3                      		retn
 19955                                  
 19956                                  ; video.asm (MSDOS 6.0, 1991)
 19957                                  ; ----------------------------------------------------------------------------
 19958                                  ; 09/12/2018 - Modified for NASM syntax & FDISK subroutines (by Erdogan Tan)
 19959                                  
 19960                                  ;========================================================
 19961                                  ; Modify current cursor position.
 19962                                  ;========================================================
 19963                                  
 19964                                  VideoSetRowCol:
 19965                                  VIOSETCURPOS:
 19966                                  
 19967                                  ; IBM PC-DOS FDISK.COM Segment 3, Offset 0009h
 19968                                  
 19969                                  	;;%define cpos_column bp+8   ; Far Call
 19970                                  	;;%define cpos_row    bp+10
 19971                                  
 19972                                  	;%define cpos_column bp+6   ; Near Call
 19973                                  	;%define cpos_row    bp+8
 19974                                  
 19975                                  		; 09/12/2018
 19976                                  		; DH = Row
 19977                                  		; DL = Column
 19978                                  
 19979                                  		;push	bp
 19980                                  		;mov	bp,sp
 19981                                  		;push	bx
 19982                                  		;push	cx
 19983                                  		;push	dx
 19984                                  		;push	si
 19985                                  		;push	di
 19986                                  		;push	ds
 19987                                  		;push	es
 19988                                  		;push	ss
 19989                                  		;push	bp
 19990                                  		
 19991 00002C16 B700                    		mov	bh,0 ; ScreenPage ; Video Page 0
 19992                                  
 19993                                  		;mov	ax,[cpos_row]
 19994                                  		;cmp	al,25
 19995                                  		;jg	short viosetcpos_0
 19996                                  		;mov	dh,al
 19997                                  		;mov	ax,[cpos_column]
 19998                                  		;cmp	al,80
 19999                                  		;jg	short viosetcpos_0
 20000                                  		;mov	dl,al
 20001                                  
 20002 00002C18 80FE19                  		cmp	dh,25
 20003 00002C1B 7F0D                    		jg	short viosetcpos_0
 20004 00002C1D 80FA50                  		cmp	dl,80
 20005 00002C20 7F08                    		jg	short viosetcpos_0
 20006                                  		
 20007 00002C22 B402                    		mov	ah,2 ; SET_CURS_POS
 20008                                  
 20009                                  		;push	bx
 20010                                  		;push	cx
 20011                                  		;push	dx
 20012                                  		;push	si
 20013                                  		;push	di
 20014                                  		;push	ds
 20015                                  		;push	es
 20016                                  		;push	ss
 20017                                  		;push	bp
 20018                                  		
 20019 00002C24 CD10                    		int	10h	; - VIDEO - SET	CURSOR POSITION
 20020                                  				; DH,DL	= row, column (0,0 = upper left)
 20021                                  				; BH = page number
 20022                                  		;pop	bp
 20023                                  		;pop	ss
 20024                                  		;pop	es
 20025                                  		;pop	ds
 20026                                  		;pop	di
 20027                                  		;pop	si
 20028                                  		;pop	dx
 20029                                  		;pop	cx
 20030                                  		;pop	bx
 20031                                  
 20032 00002C26 29C0                    		sub	ax,ax
 20033 00002C28 EB03                    		jmp	short viosetcpos_1
 20034                                  
 20035                                  		;nop
 20036                                  viosetcpos_0:
 20037 00002C2A B80200                  		mov	ax,2
 20038                                  viosetcpos_1:
 20039                                  		;pop	bp
 20040                                  		;pop	ss
 20041                                  		;pop	es
 20042                                  		;pop	ds
 20043                                  		;pop	di
 20044                                  		;pop	si
 20045                                  		;pop	dx
 20046                                  		;pop	cx
 20047                                  		;pop	bx
 20048                                  		;mov	sp,bp
 20049                                  		;pop	bp
 20050                                  		;retf	6 ; return from far call
 20051                                  		;retn 	6 ; return from near call
 20052 00002C2D C3                      		retn ; 10/12/2018
 20053                                  
 20054                                  ; ----------------------------------------------------------------------------
 20055                                  ; convert.c (FDISK, MSDOS 6.0, 1991)	
 20056                                  ; ----------------------------------------------------------------------------
 20057                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 09/12/2018)
 20058                                  
 20059                                  ;/*  */
 20060                                  ;/***************************************************************************/
 20061                                  ;/*Routine name:  DOS_UPPER                                                 */
 20062                                  ;/***************************************************************************/
 20063                                  ;/*                                                                         */
 20064                                  ;/*Description:   This routine will uppcase a character using get country   */
 20065                                  ;/*               information (65H) with the capitalize single character    */
 20066                                  ;/*               call (20H).                                               */
 20067                                  ;/*                                                                         */
 20068                                  ;/*Called Procedures:                                                       */
 20069                                  ;/*                                                                         */
 20070                                  ;/*                                                                         */
 20071                                  ;/*                                                                         */
 20072                                  ;/*Change History: Updated        5/31/87         DRM                       */
 20073                                  ;/*                                                                         */
 20074                                  ;/*Input: drive_value                                                       */
 20075                                  ;/*                                                                         */
 20076                                  ;/*Output: input_value                                                      */
 20077                                  ;/*                                                                         */
 20078                                  ;/***************************************************************************/
 20079                                  
 20080                                  ;char dos_upper(drive_value)
 20081                                  ;
 20082                                  ;char drive_value;
 20083                                  ;
 20084                                  ;BEGIN
 20085                                  ;
 20086                                  ;   char output;
 20087                                  ;
 20088                                  ;   regs.x.ax = (unsigned)CAPCHAR;   /* Get extended country information */
 20089                                  ;   regs.h.dl = (unsigned char)drive_value; /* Move input_value to register DL */
 20090                                  ;   int86((int)INT21,&regs,&regs);
 20091                                  ;   output  = (char)regs.h.dl;
 20092                                  ;
 20093                                  ;#ifdef DEBUG
 20094                                  ;           output = toupper(drive_value);
 20095                                  ;#endif
 20096                                  ;           return(output);
 20097                                  ;END
 20098                                  
 20099                                  ;dos_upper:
 20100                                  	%define upcase_input bp+4
 20101                                  
 20102                                  		;push	bp
 20103                                  		;mov	bp,sp
 20104                                  		;;sub	sp,2
 20105                                  		
 20106                                  		;country dependant character capitalization
 20107                                  		
 20108                                  		;mov	[regs_x_ax],6520h
 20109                                  		;mov	al,[upcase_input]
 20110                                  		;mov	[regs_x_dx],al
 20111                                  		;mov	ax,[regs_x_ax]
 20112                                  		;push	ax
 20113                                  		;push	ax
 20114                                  		;mov	ax,21h
 20115                                  		;push	ax
 20116                                  		;call	int86
 20117                                  		;mov	al,[regs_x_dx] ; capitalize character
 20118                                  		;mov	sp,bp
 20119                                  		;pop	bp
 20120                                  		;retn
 20121                                  dos_upper:
 20122                                  		; 09/12/2018
 20123                                  		;country dependant character capitalization
 20124                                  		
 20125                                  		;push	dx
 20126 00002C2E 88C2                    		mov	dl,al
 20127 00002C30 B82065                  		mov	ax,6520h
 20128 00002C33 CD21                    		int	21h
 20129 00002C35 88D0                    		mov	al,dl
 20130                                  		;pop	dx
 20131                                  		
 20132 00002C37 C3                      		retn
 20133                                  
 20134                                  
 20135                                  ; WRITE.ASM (VCCRT1.ZIP) - Microsoft Visual C++ 1.0 Run-Time Library Sources
 20136                                  ; ----------------------------------------------------------------------------
 20137                                  ; Modified and simplified for NASM syntax by Erdogan Tan (10/12/2018)
 20138                                  
 20139                                  ;***
 20140                                  ;int _write(fh, buf, cnt) - write bytes to a file handle
 20141                                  ;
 20142                                  ;Purpose:
 20143                                  ;	Writes count bytes from the buffer to the handle specified.
 20144                                  ;	If the file was opened in text mode, each LF is translated to
 20145                                  ;	CR-LF.	This does not affect the return value.	In text
 20146                                  ;	mode ^Z indicates end of file.
 20147                                  ;
 20148                                  ;	Multi-thread notes:
 20149                                  ;	(1) write() - Locks/unlocks file handle
 20150                                  ;	    _write_lk() - Does NOT lock/unlock file handle
 20151                                  ;	(2) It is assumed in this source that MTHREAD can only be
 20152                                  ;	true under OS/2.  Thus, conditional code is contained within
 20153                                  ;	MTHREAD conditionals without additional OS2 conditionals.
 20154                                  ;
 20155                                  ;Entry:
 20156                                  ;	int fh - file handle to write to
 20157                                  ;	char *buf - buffer to write from
 20158                                  ;	unsigned int cnt - number of bytes to write
 20159                                  ;
 20160                                  ;Exit:
 20161                                  ;	returns number of bytes actually written.
 20162                                  ;	This may be less than cnt, for example, if out of disk space.
 20163                                  ;	returns -1 (and set errno) if fails.
 20164                                  ;
 20165                                  ;Uses:
 20166                                  ;
 20167                                  ;Exceptions:
 20168                                  ;
 20169                                  ;*******************************************************************************
 20170                                  
 20171                                  
 20172                                  ; 14/12/2018 (no need to _write for FDISK2.COM)
 20173                                  
 20174                                  ;;--- Non-multithread version of write
 20175                                  ;
 20176                                  ;_write:
 20177                                  ;
 20178                                  ;	;%define oldsp	bp-8
 20179                                  ;	%define oldsp	bp-6
 20180                                  ;	%define lfcnt	bp-4
 20181                                  ;	%define outcnt	bp-2
 20182                                  ;
 20183                                  ;	%define fhndl	bp+4  ; fh
 20184                                  ;	%define buf	bp+6
 20185                                  ;	%define cnt	bp+8
 20186                                  ;
 20187                                  ;		push	bp
 20188                                  ;		mov	bp,sp
 20189                                  ;		;sub	sp,8
 20190                                  ;		sub	sp,6		
 20191                                  ;
 20192                                  ;		; make sure handle is in range
 20193                                  ;
 20194                                  ;		mov	bx,[fhndl]	; get file handle
 20195                                  ;
 20196                                  ;		cmp	bx,[_nfile]	; handle in range ?
 20197                                  ;		jb	short handle_okay ; yes, continue
 20198                                  ;
 20199                                  ;		;mov	ax,EBADF shl 8 + 0 ; file handle is out of range
 20200                                  ;		mov	ax,900h
 20201                                  ;		stc
 20202                                  ;to_dosretax:
 20203                                  ;		jmp	_dosretax	; error on lseek (invalid file handle)
 20204                                  ;		;jmp	DOSerror
 20205                                  ;handle_okay:
 20206                                  ;		;cmp	_aDBswpflg,_aDBdoswp	; See if we should screen swap
 20207                                  ;		cmp	word [_aDBswpflg],0D6D6h
 20208                                  ;		jne	short chk_append ; No -- skip over call
 20209                                  ;		call	_aDBswpchk	; Yes -- try to do the check
 20210                                  ;chk_append:
 20211                                  ;		;test	__osfile[bx],FAPPEND ; check for append
 20212                                  ;		test    byte [_osfile+bx],20h
 20213                                  ;		jz	short noseek1	; not appending, continue
 20214                                  ;
 20215                                  ;;Append mode - seek to end of file
 20216                                  ;
 20217                                  ;		;mov	ax,DOS_lseek shl 8 + 2 ; appending, lseek to end
 20218                                  ;		mov	ax,4202h
 20219                                  ;		xor	cx,cx
 20220                                  ;		mov	dx,cx		; 0L
 20221                                  ;		;callos
 20222                                  ;		int	21h	; DOS - 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)                                       ; AL = method: offset from end of file
 20223                                  ;				; AL = method: offset from end of file
 20224                                  ;		jc	short to_dosretax ; if no error, continue
 20225                                  ;noseek1:
 20226                                  ;		;test	__osfile[bx],FTEXT ; check for text (DOS finds err)
 20227                                  ;		test	byte [_osfile+bx],80h
 20228                                  ;		jz	short writebin0	; do it without translation
 20229                                  ;		;fall thru		; do the cr/lf translation
 20230                                  ;
 20231                                  ;; --- Translate LF => CR/LF ---
 20232                                  ;; We get here if we have to translate LF's to CR/LF's on output
 20233                                  ;
 20234                                  ;translate:
 20235                                  ;
 20236                                  ;;put input buffer address in es:si
 20237                                  ;
 20238                                  ;		mov	dx,[buf]	; get buffer address
 20239                                  ;		push	ds
 20240                                  ;		pop	es		; es = ds
 20241                                  ;
 20242                                  ;		xor	ax,ax
 20243                                  ;		mov	[outcnt],ax	;zero out char counter
 20244                                  ;		mov	[lfcnt],ax	;zero out lf counter, too
 20245                                  ;
 20246                                  ;		cld
 20247                                  ;		push	di		; save di
 20248                                  ;		push	si		; save si
 20249                                  ;		mov	di,dx		; es:di = start of search
 20250                                  ;		mov	si,dx		; ds:si = start of search, too
 20251                                  ;
 20252                                  ;;Scan for LFs in the user's buffer.
 20253                                  ;;(1) If none, write the buffer out in one shot.
 20254                                  ;;(2) If there is an LF, buffer the output doing translation.
 20255                                  ;
 20256                                  ;lfscan:
 20257                                  ;		mov	[oldsp],sp	;save sp
 20258                                  ;		mov	cx,[cnt]	;get char move count
 20259                                  ;		jcxz	j_writedone	;done if count = 0
 20260                                  ;
 20261                                  ;		;mov	al,C_LF		;set up for scan
 20262                                  ;		mov	al,0Ah
 20263                                  ;		repnz	scasb		;scan for LF
 20264                                  ;		jnz	short writebin1	;no LFs - write out in binary mode
 20265                                  ;		;fall thru		;LFs - use the internal buffer
 20266                                  ;
 20267                                  ;;Move chars from input buffer to LF buffer doing translation as needed.
 20268                                  ;;ds:si = start of input buffer
 20269                                  ;
 20270                                  ;		call	_stackavail	;ax = # bytes on stack
 20271                                  ;		;cmp	ax,LFBUFFMIN+STACKSAVE ;is there enough room on stack?
 20272                                  ;		cmp	ax,168
 20273                                  ;		jbe	short stackerr	;nope - return an error
 20274                                  ;	
 20275                                  ;		sub	sp,2		;move sp to first free word
 20276                                  ;		mov	bx,sp		;bx = end of LF buffer
 20277                                  ;		;mov	dx,LFBUFFMAX	;assume max LF buff size
 20278                                  ;		mov	dx,512	
 20279                                  ;		;cmp	ax,LFBUFFMAX+STACKSAVE ;stack space > max LF buff size ??
 20280                                  ;		cmp     ax,552
 20281                                  ;		jae	short lfbuff	;yes, use the max LF buff size
 20282                                  ;		;mov	dx,LFBUFFMIN	;no, use the min LF buff size
 20283                                  ;		mov	dx,128
 20284                                  ;lfbuff:
 20285                                  ;		sub	sp,dx		;move sp past LF buffer
 20286                                  ;		mov	dx,sp		;dx = start of LF buffer
 20287                                  ;		mov	di,dx		;di = start of LF buffer also
 20288                                  ;
 20289                                  ;		push	ss		;es gets LF buffer segment
 20290                                  ;		pop	es
 20291                                  ;
 20292                                  ;		mov	cx,[cnt]	;cx = # of chars to move
 20293                                  ;
 20294                                  ;;Main body of loop
 20295                                  ;;	al = reserved for current character
 20296                                  ;;	bx = end of LF buffer
 20297                                  ;;	cx = count of chars left to write
 20298                                  ;;	dx = beginning of LF buffer
 20299                                  ;;	ds:si = curr position in input buffer
 20300                                  ;;	es:di = curr position in LFBUFF
 20301                                  ;
 20302                                  ;lfloop:
 20303                                  ;		lodsb			;al = next byte from input
 20304                                  ;		;cmp	al,C_LF		;curr char == LF ?
 20305                                  ;		cmp	al,0Ah
 20306                                  ;		je	short foundlf 	;yes - do the translation
 20307                                  ;lfloop1:
 20308                                  ;		cmp	di,bx		;is LF buffer full ?
 20309                                  ;		je	short wrlfbuff1	;if so, write it out
 20310                                  ;storechr:
 20311                                  ;		stosb			;al ->	LFBUFF and bump di
 20312                                  ;		loop	lfloop		;do next char
 20313                                  ;		;fall thru		;no more input (cx = 0)
 20314                                  ;
 20315                                  ;;No more input - write out anything that's in the LF buffer
 20316                                  ;
 20317                                  ;		call	wrlfbuff	;write out the buffer
 20318                                  ;j_writedone:
 20319                                  ;		jmp	short writedone ;all done!
 20320                                  ;
 20321                                  ;;Found an LF - do the translation
 20322                                  ;
 20323                                  ;foundlf:
 20324                                  ;		;mov	al,C_CR		;put a CR in the buffer
 20325                                  ;		mov	al,0Dh
 20326                                  ;		cmp	di,bx		;LF buffer full ?
 20327                                  ;		jne	short foundlf1	;nope - store the CR
 20328                                  ;		call	wrlfbuff	;write out the LF buffer
 20329                                  ;foundlf1:
 20330                                  ;		stosb			;CR -> LFBUFF and bump di
 20331                                  ;		;mov	al,C_LF		;get LF back
 20332                                  ;		mov	al,0Ah
 20333                                  ;		inc	word [lfcnt] 	;bump LF count
 20334                                  ;		jmp	short lfloop1	;store the LF
 20335                                  ;
 20336                                  ;;Call to wrlfbuff used by the lfloop
 20337                                  ;
 20338                                  ;wrlfbuff1:
 20339                                  ;		call	wrlfbuff	;write out the buffer
 20340                                  ;		jmp	short storechr	;back into loop
 20341                                  ;;Bridges
 20342                                  ;
 20343                                  ;writebin1:
 20344                                  ;		pop	si		;restore si/di
 20345                                  ;		pop	di
 20346                                  ;writebin0:
 20347                                  ;		jmp	short writebin	;binary write code
 20348                                  ;
 20349                                  ;;Error - could not get enough stack space
 20350                                  ;
 20351                                  ;stackerr:
 20352                                  ;	; call _chkstk with a value guaranteed to give an error
 20353                                  ;
 20354                                  ;		mov	ax,0FFFCh ; -4
 20355                                  ;		call	_chkstk 	;give stack overflow and die
 20356                                  ;		;never returns
 20357                                  
 20358                                  ; ----------------------------------------------------------------------------
 20359                                  
 20360                                  ;***
 20361                                  ;wrlfbuff - Write out the lfbuffer
 20362                                  ;
 20363                                  ;Purpose:
 20364                                  ;	This routine writes out the lf buffer and resets appropriate
 20365                                  ;	registers.
 20366                                  ;Entry:
 20367                                  ;	Registers still setup from LF/CR translation loop.
 20368                                  ;	Pertinent values for wrlfbuff() are:
 20369                                  ;		dx = beginning of LF buffer
 20370                                  ;		di = current position in LF buffer
 20371                                  ;Exit:
 20372                                  ;	Resets di to the beginning of the LF buffer.
 20373                                  ;
 20374                                  ;Uses:
 20375                                  ;
 20376                                  ;Exceptions:
 20377                                  ;
 20378                                  ;*******************************************************************************
 20379                                  
 20380                                  ; 14/12/2018 (no need to _wrlfbuff for FDISK2.COM)
 20381                                  
 20382                                  ;wrlfbuff:
 20383                                  ;		push	ax		;save current char
 20384                                  ;		push	bx		;save end of buffer pointer
 20385                                  ;		push	cx		;save cx
 20386                                  ;	
 20387                                  ;		;calculate the # of chars to write out
 20388                                  ;
 20389                                  ;		mov	cx,di		;cx = calc # of bytes to write
 20390                                  ;		sub	cx,dx
 20391                                  ;		jcxz	wrlfdone	;if cx == 0, we're done
 20392                                  ;
 20393                                  ;		push	cx		;save char count
 20394                                  ;
 20395                                  ;		;do the write
 20396                                  ;
 20397                                  ;		mov	bx,[fhndl]		;bx = file handle
 20398                                  ;		;mov	ah,DOS_write	;write call
 20399                                  ;		;callos			;do the write
 20400                                  ;		mov	ah,40h
 20401                                  ;		int	21h	; DOS - 2+ - WRITE TO FILE WITH HANDLE
 20402                                  ;				; BX = file handle, CX = number of bytes to write,
 20403                                  ;				; DS:DX -> buffer
 20404                                  ;		pop	cx		;restore chars written
 20405                                  ;		jc	short wrlferror	;error
 20406                                  ;
 20407                                  ;		add	[outcnt],ax	;add chars written to total
 20408                                  ;		cmp	cx,ax		;did we write less than we wanted
 20409                                  ;		ja	short wrlferror	;yes - return error, if we jump, CF=0
 20410                                  ;
 20411                                  ;	;--- no error on the write ---
 20412                                  ;	;Restore/re-initialize registers and return.
 20413                                  ;
 20414                                  ;wrlfdone:
 20415                                  ;		pop	cx		;restore register
 20416                                  ;		pop	bx
 20417                                  ;		pop	ax
 20418                                  ;		mov	di,dx		;make di = beginning of LF buffer
 20419                                  ;		retn			;return to caller
 20420                                  ;
 20421                                  ;;--- error on the write ---
 20422                                  ;;Either the write returned an explicit error or we wrote less than requested.
 20423                                  ;;Either way, we are not returning to the caller.
 20424                                  ;
 20425                                  ;wrlferror:
 20426                                  ;		lahf			;save carry for a sec...
 20427                                  ;		;add	sp,8		;clean off stack (don't change ax)
 20428                                  ;		add	sp,6		;cleans off return address, too
 20429                                  ;		
 20430                                  ;		cmp	word [outcnt],0	;have we written something?
 20431                                  ;		jne	short writedone	;yes, return how much
 20432                                  ;
 20433                                  ;		sahf			;restore carry
 20434                                  ;
 20435                                  ;		jnc	short wrote0	;carry set ?
 20436                                  ;		;mov	ah,EBADF	;yes - error on write
 20437                                  ;		mov	ah,9
 20438                                  ;		jmp	short writeerror ;error return
 20439                                  ;
 20440                                  ;; The write did not return an error but we didn't write anything.
 20441                                  ;; if dev and first byte ^z, just return 0. else return end of media error.
 20442                                  ;; (AX=0)
 20443                                  ;
 20444                                  ;wrote0:
 20445                                  ;		;test	__osfile[bx],FDEV ; device ?
 20446                                  ;		test	byte [_osfile+bx],40h
 20447                                  ;		jz	short wrlferr1	; no, error
 20448                                  ;	
 20449                                  ;		mov	bx,[buf]
 20450                                  ;		;cmp	byte ptr [bx],C_SUB ; ^z ?
 20451                                  ;		cmp	byte [bx],1Ah
 20452                                  ;		jne	short wrlferr1	; no
 20453                                  ;
 20454                                  ;		clc			; no error
 20455                                  ;		jmp	short writeerror ; don't overwrite ax (ax=0)
 20456                                  ;
 20457                                  ;wrlferr1:				; return an error
 20458                                  ;		stc			; carry set for error
 20459                                  ;		;mov	ax,ENOSPC shl 8 + 0 ; return no more disk space error
 20460                                  ;		mov	ax,1C00h
 20461                                  ;		jmp	short writeerror ; return the error
 20462                                  ;
 20463                                  ;writedone:				; good return
 20464                                  ;		mov	ax,[outcnt]	; total # chars written
 20465                                  ;		sub	ax,[lfcnt]	; subtract the # of LFs translated
 20466                                  ;					; clears carry, too
 20467                                  ;writeerror:				; error return
 20468                                  ;		mov	sp,[oldsp]	; restore sp
 20469                                  ;		pop	si		; restore si
 20470                                  ;		pop	di		; restore di
 20471                                  ;justret:
 20472                                  ;		jmp	_dosretax	; return AX if successful
 20473                                  ;
 20474                                  ;;--- Untranslated Writes ---
 20475                                  ;; Just shove the entire buffer out there as fast as possible
 20476                                  ;; ds = dgroup
 20477                                  ;
 20478                                  ;writebin:
 20479                                  ;		mov	cx,[cnt]	; number of bytes to write
 20480                                  ;		or	cx,cx		; are we supposed to write 0 bytes?
 20481                                  ;		jnz	short writegoon	; nope, continue
 20482                                  ;		mov	ax,cx		; yes, ax = byte count = 0
 20483                                  ;		;jmp	__dosretax	; good return
 20484                                  ;		jmp	DOSnoerror ; 10/12/2018
 20485                                  ;writegoon:
 20486                                  ;		mov	dx,[buf]	; buffer address
 20487                                  ;		;callos	write
 20488                                  ;		mov	ah,40h
 20489                                  ;		int	21h	; DOS - 2+ - WRITE TO FILE WITH HANDLE
 20490                                  ;				; BX = file handle, CX = number of bytes to write,
 20491                                  ;				; DS:DX -> buffer
 20492                                  ;		jnc	short writeok4
 20493                                  ;
 20494                                  ;		;mov	ah,EBADF
 20495                                  ;		mov	ah,9
 20496                                  ;		jmp	short justret
 20497                                  ;
 20498                                  ;writeok4:				;no write error  (ax = # bytes written)
 20499                                  ;		or	ax,ax		;did we write 0 bytes ?
 20500                                  ;		jnz	short justret 	;no, just return
 20501                                  ;
 20502                                  ;; Requested non-zero number of bytes to be written and 0 were written.
 20503                                  ;; If device and 1st byte was ^z, just return 0. else end of media
 20504                                  ;
 20505                                  ;		;test	__osfile[bx],FDEV ; device?
 20506                                  ;		test	byte [_osfile+bx],40h
 20507                                  ;		jz	short notdev	; no
 20508                                  ;
 20509                                  ;		mov	bx,dx
 20510                                  ;		;cmp	byte ptr [bx],C_SUB ; ^z ?
 20511                                  ;		cmp	byte [bx],1Ah
 20512                                  ;		jne	short notdev
 20513                                  ;
 20514                                  ;		clc
 20515                                  ;		jmp	short justret	; good return
 20516                                  ;notdev:
 20517                                  ;		stc			; set carry flag to mark error
 20518                                  ;		;mov	ax,ENOSPC shl 8 + 0 ; return no more disk space error
 20519                                  ;		mov     ax,1C00h
 20520                                  ;		jmp	short justret	; return AX
 20521                                  
 20522                                  ; STACKAVA.ASM (VCCRT1.ZIP) - Visual C++ 1.0 Run-Time Library Sources
 20523                                  ; ----------------------------------------------------------------------------
 20524                                  ; 10/12/2018
 20525                                  
 20526                                  ; 14/12/2018 (no need to _stackavail for FDISK2.COM)
 20527                                  
 20528                                  ;_stackavail:
 20529                                  ;		pop	cx		; return offset
 20530                                  ;		;mov	ax,[_STKHQQ]	; bottom of stack
 20531                                  ;		mov	ax,[end_of_bss]
 20532                                  ;
 20533                                  ;		cmp	ax,sp
 20534                                  ;		jae	short stkavl_1
 20535                                  ;
 20536                                  ;		sub	ax,sp
 20537                                  ;		neg	ax
 20538                                  ;stkavl_0:
 20539                                  ;		jmp	cx		;; return to cx
 20540                                  ;stkavl_1:
 20541                                  ;		xor	ax,ax
 20542                                  ;		jmp	short stkavl_0
 20543                                  
 20544                                  ; ----------------------------------------------------------------------------
 20545                                  ; int13.c (FDISK, MSDOS 6.0, 1991)	
 20546                                  ; ----------------------------------------------------------------------------
 20547                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 15/12/2018)
 20548                                  
 20549                                  ;/*  */
 20550                                  ;char write_boot_record(cylinder,which_disk)
 20551                                  ;
 20552                                  ;unsigned    cylinder;
 20553                                  ;unsigned char   which_disk;
 20554                                  ;
 20555                                  ;BEGIN
 20556                                  ;
 20557                                  ;/*C00    char i;  */
 20558                                  ;/*C00    char j;  */
 20559                                  ;    char far *buffer_pointer = boot_record;
 20560                                  ;
 20561                                  ;    /* Setup read, always on a cylinder boundary */
 20562                                  ;    regs.h.ah = uc(WRITE_DISK);                           /* AC000 */
 20563                                  ;    regs.h.al = uc(1);                                    /* AC000 */
 20564                                  ;    regs.h.dh = uc(0);                                    /* AC000 */
 20565                                  ;    regs.h.cl = uc(0x01);                                 /* AC000 */
 20566                                  ;
 20567                                  ;    /* Specify the disk */
 20568                                  ;    regs.h.dl = which_disk + 0x80;
 20569                                  ;
 20570                                  ;    /* Need to scramble CX so that sectors and cyl's are in INT 13 format */
 20571                                  ;
 20572                                  ;    if (cylinder > u(255))                                /* AC000 */
 20573                                  ;       BEGIN
 20574                                  ;        regs.h.cl = regs.h.cl | ((unsigned char)((cylinder /256) << 6));
 20575                                  ;       END
 20576                                  ;    regs.h.ch = (unsigned char)(cylinder & 0xFF);
 20577                                  ;
 20578                                  ;    /* Point at the place to read the boot record */
 20579                                  ;    regs.x.bx = FP_OFF(buffer_pointer);
 20580                                  ;    segregs.es = FP_SEG(buffer_pointer);
 20581                                  ;
 20582                                  ;    /* write the boot record */
 20583                                  ;    DiskIo(&regs,&regs,&segregs);                         /* AC000 */
 20584                                  ;
 20585                                  ;    /* Check for error reading it */
 20586                                  ;    if ((regs.x.cflag & 1) != u(1))                       /* AC000 */
 20587                                  ;       BEGIN
 20588                                  ;        return(TRUE);
 20589                                  ;       END
 20590                                  ;    else
 20591                                  ;       BEGIN
 20592                                  ;        /* Tell user there was an error */
 20593                                  ;        clear_screen(u(0),u(0),u(24),u(79));              /* AC000 */
 20594                                  ;        display(error_2);
 20595                                  ;        no_fatal_error = FALSE;
 20596                                  ;        return(FALSE);
 20597                                  ;       END
 20598                                  ;END
 20599                                  
 20600                                  write_boot_record:
 20601                                  
 20602                                  	;%define w_buf_pointer	bp-4  ; far ptr, dword
 20603                                  
 20604                                  	%define w_cylinder	bp+4  ; unsigned int, word
 20605                                  	%define w_which_disk	bp+6  ; unsigned char, byte	
 20606                                  
 20607 00002C38 55                      		push	bp
 20608 00002C39 89E5                    		mov	bp,sp
 20609                                  		;sub	sp,4 ; 04/01/2019
 20610                                  		
 20611                                  		;mov	word [w_buf_pointer],boot_record
 20612                                  		;mov	[w_buf_pointer2],ds
 20613                                  
 20614 00002C3B BB[D2C9]                		mov	bx,boot_record
 20615                                  		;push	ds
 20616                                  		;pop	es
 20617                                  		
 20618                                  		;mov	byte [regs_x_ax+1],3 ; write
 20619                                  		;mov	byte [regs_x_ax],1   ; 1 sector	
 20620                                  
 20621                                  		;mov	byte [regs_x_dx+1],0
 20622                                  		;mov	byte [regs_x_cx],1
 20623                                  
 20624 00002C3E 28F6                    		sub	dh,dh	; Head 0
 20625 00002C40 B101                    		mov	cl,1	; Sector 1
 20626                                  
 20627                                  		;mov	al,[w_which_disk]
 20628                                  		;add	al,80h
 20629                                  		;mov	byte [regs_x_dx],al
 20630                                  
 20631 00002C42 8A5606                  		mov	dl,[w_which_disk]
 20632 00002C45 80C280                  		add	dl,80h
 20633                                  
 20634 00002C48 8B4604                  		mov	ax,[w_cylinder]
 20635 00002C4B 88C5                    		mov	ch,al
 20636                                  
 20637                                  		;cmp	word [w_cylinder],255
 20638                                  		;cmp	ax,255
 20639                                  		;jbe	short write_bs_1
 20640 00002C4D 08E4                    		or	ah,ah
 20641 00002C4F 7408                    		jz	short write_bs_1
 20642                                  
 20643                                  		;mov	ax,[w_cylinder]
 20644 00002C51 D1E8                    		shr	ax,1
 20645 00002C53 D1E8                    		shr	ax,1
 20646 00002C55 24C0                    		and	al,0C0h
 20647                                  		;or	byte [regs_x_cx],al
 20648 00002C57 08C1                    		or	cl,al
 20649                                  write_bs_1:
 20650                                  		;mov	al,[w_cylinder]
 20651                                  		;mov	byte [regs_x_cx+1],al
 20652                                  
 20653                                  		;mov	ax,[w_buf_pointer]
 20654                                  		;mov	[regs_x_bx],ax
 20655                                  		;mov	ax,[w_buf_pointer2]
 20656                                  		;mov	[segregs_es],ax
 20657                                  		;mov	ax,segregs_es
 20658                                  
 20659                                  		;push	ax
 20660                                  		;mov	ax,regs_x_ax
 20661                                  		;push	ax
 20662                                  		;push	ax
 20663                                  		;call	DiskIo
 20664                                  		;add	sp,6
 20665                                  		;mov	al,[regs_x_cflag]
 20666                                  		;and	al,1
 20667                                  		;cmp	al,1
 20668                                  		;je	short write_bs_2
 20669                                  		;mov	al,1
 20670                                  		;jmp	short write_bs_3
 20671                                  
 20672 00002C59 B80103                  		mov	ax,0301h ; write 1 sector (CHS write)
 20673 00002C5C CD13                    		int	13h
 20674 00002C5E 7204                    		jc	short write_bs_2
 20675                                  
 20676 00002C60 B001                    		mov	al,1 ; TRUE
 20677 00002C62 EB14                    		jmp	short write_bs_3
 20678                                  write_bs_2:
 20679                                  		;mov	ax,79
 20680                                  		;push	ax	 ; Bottom Rigth Column (79)  
 20681                                  		;mov	ax,24
 20682                                  		;push	ax	 ; Bottom Row (24)
 20683                                  		;sub	ax,ax ; 0
 20684                                  		;push	ax	 ; Top Left Column (0)	
 20685                                  		;push	ax	 ; Top Row (0)
 20686                                  		;
 20687                                  		;call	clear_screen
 20688                                  		;add	sp,8
 20689                                  
 20690                                  		; Clear screen (clear whole video page)
 20691 00002C64 E8F7E7                  		call	CLS
 20692                                  
 20693 00002C67 28C0                    		sub	al,al ; FALSE
 20694 00002C69 F9                      		stc	; cf = 1  (error!)
 20695                                  
 20696                                  		;;push	word [error_2_seg] ; read error
 20697                                  		;push	word [error_3_seg] ; write error
 20698 00002C6A 1E                      		push	ds
 20699                                  		;push	word [error_2_off]
 20700 00002C6B FF36[7A9E]              		push	word [error_3_off]
 20701 00002C6F E8A8E9                  		call	display
 20702                                  		;pop	bx
 20703                                  		;pop	bx
 20704                                  
 20705 00002C72 28C0                    		sub	al,al ; FALSE
 20706 00002C74 A2[05C4]                		mov	[no_fatal_error],al ; 0
 20707 00002C77 F9                      		stc	; cf = 1  (error!)
 20708                                  write_bs_3:
 20709                                  		;mov	sp,bp ; 04/01/2019
 20710 00002C78 5D                      		pop	bp
 20711                                  		;retn
 20712 00002C79 C20400                  		retn	4 ; 22/12/2018
 20713                                  
 20714                                  ; ============================================================================
 20715                                  ;  MAIN MENU
 20716                                  ; ============================================================================
 20717                                  ; 15/12/2018
 20718                                  
 20719                                  ; fdisk.msg (MSDOS 6.0)
 20720                                  ;/*************************************************************************************************/
 20721                                  ;/* Screen for DO_MAIN_MENU                                                                       */
 20722                                  ;/*                                                                                               */
 20723                                  ;/*      |00000000001111111111222222222233333333334444444444555555555566666666667777777777|       */
 20724                                  ;/*      |01234567890123456789012345678901234567890123456789012345678901234567890123456789|       */
 20725                                  ;/*    --|--------------------------------------------------------------------------------|       */
 20726                                  ;/*    00|                               MS-DOS Version 6                                 |menu_1 */
 20727                                  ;/*    01|                            Fixed Disk Setup Program                            |menu_1 */
 20728                                  ;/*    02|                    (C)Copyright Microsoft Corp. 1983 - 1993                    |menu_1 */
 20729                                  ;/*    03|                                                                                |       */
 20730                                  ;/*    04|                                 FDISK Options                                  |menu_2 */
 20731                                  ;/*    05|                                                                                |       */
 20732                                  ;/*    06|    Current fixed disk drive: #                                                 |menu_5 */
 20733                                  ;/*    07|                                                                                |       */
 20734                                  ;/*    08|    Choose one of the following:                                                |menu_3 */
 20735                                  ;/*    09|                                                                                |       */
 20736                                  ;/*    10|    1.  Create DOS Partition or Logical DOS Drive                               |menu_2 */
 20737                                  ;/*    11|    2.  Set active partition                                                    |menu_2 */
 20738                                  ;/*    12|    3.  Delete DOS Partition or Logical DOS Drive                               |menu_2 */
 20739                                  ;/*    13|    4.  Display partition information                                           |menu_2 */
 20740                                  ;/*    14|    5.  Change current fixed disk drive                                         |menu_4 */
 20741                                  ;/*    15|                                                                                |       */
 20742                                  ;/*    16|                                                                                |       */
 20743                                  ;/*    17|    Enter choice: [#]                                                           |menu_7 */
 20744                                  ;/*    18|                                                                                |       */
 20745                                  ;/*    19|                                                                                |       */
 20746                                  ;/*    20|    Warning! No partitions are set active - disk 1 is not startable unless      |menu_6 */
 20747                                  ;/*    21|    a partition is set active.                                                  |       */
 20748                                  ;/*    22|                                                                                |       */
 20749                                  ;/*    23|                                                                                |       */
 20750                                  ;/*    24|    Press ESC to exit FDISK                                                     |menu_2 */
 20751                                  ;/*    ------------------------------------------------------------------------------------       */
 20752                                  ;/*                                                                                               */
 20753                                  ;/*************************************************************************************************/
 20754                                  
 20755                                  ; ----------------------------------------------------------------------------
 20756                                  ; mainmenu.c (FDISK, MSDOS 6.0, 1991)	
 20757                                  ; ----------------------------------------------------------------------------
 20758                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 15/12/2018)
 20759                                  
 20760                                  ;/*  */
 20761                                  ;/******************* START OF SPECIFICATIONS *******************/
 20762                                  ;/*                                                             */
 20763                                  ;/* SUBROUTINE NAME: DO_MAIN_MENU                               */
 20764                                  ;/*                                                             */
 20765                                  ;/* DESCRIPTIVE NAME: Main menu display and input routine       */
 20766                                  ;/*                                                             */
 20767                                  ;/* FUNCTION:                                                   */
 20768                                  ;/*    Displays the main FDISK menu, accepts and validates      */
 20769                                  ;/*    input from menu and passes control to requested function */
 20770                                  ;/*                                                             */
 20771                                  ;/* NOTES: The following screen is managed by this routine:     */
 20772                                  ;/*                                                             */
 20773                                  ;/*       |0000000000111111111122222222223333333333|            */
 20774                                  ;/*       |0123456789012345678901234567890123456789|            */
 20775                                  ;/*     --|----------------------------------------|            */
 20776                                  ;/*     00|                                        |            */
 20777                                  ;/*     01|                                        |            */
 20778                                  ;/*     02|                                        |            */
 20779                                  ;/*     03|                                        |            */
 20780                                  ;/*     04|FDISK Options                           |            */
 20781                                  ;/*     05|                                        |            */
 20782                                  ;/*     06|Current Fixed Disk Drive: #             |            */
 20783                                  ;/*     07|                                        |            */
 20784                                  ;/*     08|Choose one of the following:            |            */
 20785                                  ;/*     09|                                        |            */
 20786                                  ;/*     10|    1.  Create DOS partition            |            */
 20787                                  ;/*     11|    2.  Change Active Partition         |            */
 20788                                  ;/*     12|    3.  Delete DOS Partition            |            */
 20789                                  ;/*     13|    4.  Display Partition Data          |            */
 20790                                  ;/*     14|    5.  Select Next Fixed Disk Drive    |            */
 20791                                  ;/*     15|                                        |            */
 20792                                  ;/*     16|                                        |            */
 20793                                  ;/*     17|                                        |            */
 20794                                  ;/*     18|Enter choice: [#]                       |            */
 20795                                  ;/*     19|                                        |            */
 20796                                  ;/*     20|                                        |            */
 20797                                  ;/*     21|WARNING! No partitions marked active    |            */
 20798                                  ;/*     22|                                        |            */
 20799                                  ;/*     23|Press ESC to return to DOS              |            */
 20800                                  ;/*     --------------------------------------------            */
 20801                                  ;/*                                                             */
 20802                                  ;/* ENTRY POINTS: do_main_menu                                  */
 20803                                  ;/*      LINKAGE: do_main_menu();                               */
 20804                                  ;/*               NEAR CALL                                     */
 20805                                  ;/*                                                             */
 20806                                  ;/* INPUT: None                                                 */
 20807                                  ;/*                                                             */
 20808                                  ;/* EXIT-NORMAL: ERROR=FALSE                                    */
 20809                                  ;/*                                                             */
 20810                                  ;/* EXIT-ERROR: ERROR=TRUE                                      */
 20811                                  ;/*             GOTO internal_program_error if case statement   */
 20812                                  ;/*             failure when branching to requested function    */
 20813                                  ;/*                                                             */
 20814                                  ;/* EFFECTS: No data directly modified by this routine, but     */
 20815                                  ;/*          child routines will modify data.                   */
 20816                                  ;/*                                                             */
 20817                                  ;/* INTERNAL REFERENCES:                                        */
 20818                                  ;/*   ROUTINES:                                                 */
 20819                                  ;/*      clear_screen                                           */
 20820                                  ;/*      display                                                */
 20821                                  ;/*      get_num_input                                          */
 20822                                  ;/*      create_partition                                       */
 20823                                  ;/*      change_active_partition                                */
 20824                                  ;/*      delete_partition                                       */
 20825                                  ;/*      display_partition_information                          */
 20826                                  ;/*      find_active_partition                                  */
 20827                                  ;/*      change_drive                                           */
 20828                                  ;/*      internal_program_error                                 */
 20829                                  ;/*                                                             */
 20830                                  ;/* EXTERNAL REFERENCES:                                        */
 20831                                  ;/*   ROUTINES:                                                 */
 20832                                  ;/*                                                             */
 20833                                  ;/******************** END OF SPECIFICATIONS ********************/
 20834                                  
 20835                                  ;/*  */
 20836                                  ;void do_main_menu()
 20837                                  ;
 20838                                  ;BEGIN
 20839                                  ;
 20840                                  ;char   input;
 20841                                  ;char   max_input;
 20842                                  ;
 20843                                  ;FLAG	error_switch;
 20844                                  ;
 20845                                  ;unsigned    temp;
 20846                                  ;unsigned    i;
 20847                                  ;
 20848                                  ;   input = c(NUL);
 20849                                  ;   PercentFlag = (FLAG)FALSE;
 20850                                  ;   /* Initialize cur_disk indicator. It is 0 based for array usage */
 20851                                  ;   /* See if first disk readable */
 20852                                  ;   cur_disk = c(0);
 20853                                  ;   if (!good_disk[0])
 20854                                  ;      BEGIN
 20855                                  ;       cur_disk++;
 20856                                  ;      END
 20857                                  ;
 20858                                  ;   temp = u(0);
 20859                                  ;   for (i=u(0);i<u(number_of_drives);i++)
 20860                                  ;       if (good_disk[i])
 20861                                  ;           temp = u(1);
 20862                                  ;   if (temp == u(1))
 20863                                  ;
 20864                                  ;      BEGIN
 20865                                  ;       clear_screen(u(0),u(0),u(24),u(79));
 20866                                  ;       /* Display the copyright */
 20867                                  ;       display(menu_1);
 20868                                  ;
 20869                                  ;       /* See if we couldn't access drive 1 */
 20870                                  ;		for (i = 0; i < number_of_drives; i++)
 20871                                  ;			BEGIN
 20872                                  ;			 if (!good_disk[i] && (error_switch == FALSE))
 20873                                  ;				{
 20874                                  ;          	insert[0] = c(i+'1');
 20875                                  ;           	display(error_30);
 20876                                  ;			 	error_switch = TRUE;
 20877                                  ;			   }
 20878                                  ;      END
 20879                                  ;
 20880                                  ;      /* Display the menu every time this routine is returned to until ESC */
 20881                                  ;      input = c(NUL);
 20882                                  ;      while (input !=c(ESC))
 20883                                  ;         BEGIN
 20884                                  ;            /* Put up most of the menu */
 20885                                  ;            display(menu_2);
 20886                                  ;            display(menu_3);
 20887                                  ;            display(menu_7);
 20888                                  ;
 20889                                  ;            /* Put correct disk in current disk message */
 20890                                  ;            insert[0]=cur_disk+1+'0';
 20891                                  ;            display(menu_5);
 20892                                  ;
 20893                                  ;            /* Display warning prompt if no active partitions */
 20894                                  ;            /* check to see if there is an avail partition */
 20895                                  ;            temp = u(0);
 20896                                  ;            for (i = u(0); i < u(4);i++)
 20897                                  ;               BEGIN
 20898                                  ;
 20899                                  ;               /* See if any non - zero system id bytes */
 20900                                  ;               temp = temp | part_table[cur_disk][i].sys_id ;
 20901                                  ;              END
 20902                                  ;           /* Any entry that isn't zero means */
 20903                                  ;           if (temp != u(0))
 20904                                  ;              BEGIN
 20905                                  ;               /* If there isn't an active partition and this is disk 1, then yell) */
 20906                                  ;               if ((!find_active_partition()) && (cur_disk == c(0)))
 20907                                  ;                  display(menu_6);
 20908                                  ;              END
 20909                                  ;
 20910                                  ;           /* Get the menu input */
 20911                                  ;
 20912                                  ;           /* See if more than one fixed disk */
 20913                                  ;           if (number_of_drives > uc(1))
 20914                                  ;             BEGIN
 20915                                  ;              display(menu_4);
 20916                                  ;              max_input = c(5);
 20917                                  ;             END
 20918                                  ;           else     /* only 4 options */
 20919                                  ;               max_input = c(4);
 20920                                  ;           /* Setup default and go get input */
 20921                                  ;           input = get_num_input(c(1),max_input,input_row,input_col);
 20922                                  ;           switch(input)
 20923                                  ;              BEGIN
 20924                                  ;               case  '1': create_partition();
 20925                                  ;                          break;
 20926                                  ;
 20927                                  ;               case  '2': change_active_partition();
 20928                                  ;                          break;
 20929                                  ;
 20930                                  ;               case  '3': delete_partition();
 20931                                  ;                          break;
 20932                                  ;
 20933                                  ;               case  '4': display_partition_information();
 20934                                  ;                          break;
 20935                                  ; 
 20936                                  ;               case  '5': change_current_drive();
 20937                                  ;                          break;
 20938                                  ;
 20939                                  ;               case  ESC: break;  /* ESC case */
 20940                                  ;
 20941                                  ;               default:   internal_program_error();
 20942                                  ;              END
 20943                                  ;           END
 20944                                  ;       END
 20945                                  ;   else
 20946                                  ;       BEGIN
 20947                                  ;        /* Can't read any drive, so quit */
 20948                                  ;        no_fatal_error = c(FALSE);
 20949                                  ;        display(error_2);
 20950                                  ;       END
 20951                                  ;   return;
 20952                                  ;END
 20953                                  
 20954                                  do_main_menu:
 20955                                  
 20956                                  	%define mm_err_switch bp-8 ; bp-10
 20957                                  	%define mm_i	      bp-6 ; bp-8
 20958                                  	;%define mm_temp      bp-6
 20959                                  	%define mm_max_input  bp-4
 20960                                  	%define mm_input      bp-2
 20961                                  
 20962 00002C7C 55                      		push	bp
 20963 00002C7D 89E5                    		mov	bp,sp
 20964                                  		;sub	sp,10
 20965 00002C7F 83EC08                  		sub	sp,8
 20966                                  		;sub	al,al ; 0
 20967 00002C82 29C0                    		sub	ax,ax
 20968 00002C84 8846FE                  		mov	[mm_input],al
 20969 00002C87 A2[D2C3]                		mov	[PercentFlag],al
 20970 00002C8A A2[D4CB]                		mov	[cur_disk],al
 20971 00002C8D 8846F8                  		mov	[mm_err_switch],al ; 0
 20972                                  		;cmp	byte [gooddisk+0],0
 20973 00002C90 3806[42A1]              		cmp	[good_disk],al ; 0
 20974 00002C94 7505                    		jne	short mainmenu_01
 20975 00002C96 C606[D4CB]01            		mov	byte [cur_disk],1
 20976                                  mainmenu_01:
 20977 00002C9B 29C0                    		sub	ax,ax ; 0
 20978                                  		;mov	[mm_temp],ax ; FALSE
 20979 00002C9D 8946FA                  		mov	[mm_i],ax
 20980 00002CA0 EB0F                    		jmp	short mainmenu_04
 20981                                  mainmenu_02:
 20982 00002CA2 8B5EFA                  		mov	bx,[mm_i]
 20983 00002CA5 80BF[42A1]00            		cmp	byte [good_disk+bx],0
 20984 00002CAA 7402                    		je	short mainmenu_03
 20985                                  		;mov	byte [mm_temp],1 ; TRUE
 20986 00002CAC FEC4                    		inc	ah ; [mm_temp] = 1
 20987                                  mainmenu_03:
 20988 00002CAE FE46FA                  		inc	byte [mm_i]
 20989                                  mainmenu_04:
 20990 00002CB1 A0[D5C3]                		mov	al,[number_of_drives]
 20991                                  		;sub	ah,ah
 20992                                  		;cmp	ax,[mm_i]
 20993 00002CB4 3A46FA                  		cmp	al,[mm_i]
 20994 00002CB7 77E9                    		ja	short mainmenu_02
 20995                                  		;cmp	byte [mm_temp],1
 20996                                  		;je	short mainmenu_05
 20997 00002CB9 08E4                    		or	ah,ah ; [mm_temp]
 20998 00002CBB 7503                    		jnz	short mainmenu_05
 20999 00002CBD E90F01                  		jmp	mainmenu_27
 21000                                  mainmenu_05:
 21001                                  		;mov	ax,79
 21002                                  		;push	ax
 21003                                  		;mov	ax,24
 21004                                  		;push	ax
 21005                                  		;sub	ax,ax
 21006                                  		;push	ax
 21007                                  		;push	ax
 21008                                  		;call	clear_screen
 21009                                  		;add	sp,8
 21010                                  
 21011 00002CC0 E89BE7                  		call	CLS
 21012                                  
 21013                                  		;push	word [menu_1_segment]
 21014 00002CC3 1E                      		push	ds
 21015 00002CC4 FF36[E79D]              		push	word [menu_1_offset]
 21016 00002CC8 E84FE9                  		call	display
 21017                                  		;pop	bx
 21018                                  		;pop	bx
 21019 00002CCB C646FA00                		mov	byte [mm_i],0
 21020 00002CCF EB25                    		jmp	short mainmenu_08
 21021                                  mainmenu_06:
 21022 00002CD1 8B5EFA                  		mov	bx,[mm_i]
 21023 00002CD4 80BF[42A1]00            		cmp	byte [good_disk+bx],0
 21024 00002CD9 7718                    		ja	short mainmenu_07
 21025 00002CDB 807EF800                		cmp	byte [mm_err_switch],0
 21026 00002CDF 7712                    		ja	short mainmenu_07
 21027 00002CE1 8D4731                  		lea	ax,[bx+'1']
 21028 00002CE4 A2[E6CC]                		mov	[insert],al
 21029                                  		;push	word [error_30_seg]
 21030 00002CE7 1E                      		push	ds
 21031 00002CE8 FF36[AC9E]              		push	word [error_30_off]
 21032 00002CEC E82BE9                  		call	display
 21033                                  		;pop	bx
 21034                                  		;pop	bx
 21035 00002CEF C646F801                		mov	byte [mm_err_switch],1
 21036                                  mainmenu_07:
 21037 00002CF3 FE46FA                  		inc	byte [mm_i]
 21038                                  mainmenu_08:
 21039 00002CF6 A0[D5C3]                		mov	al,[number_of_drives]
 21040 00002CF9 28E4                    		sub	ah,ah
 21041                                  		;cmp	ax,[mm_i]
 21042 00002CFB 3A46FA                  		cmp	al,[mm_i]
 21043 00002CFE 77D1                    		ja	short mainmenu_06
 21044 00002D00 8866FE                  		mov	byte [mm_input],ah ; 0
 21045                                  mainmenu_10:
 21046 00002D03 807EFE1B                		cmp	byte [mm_input],1Bh ; ESC key
 21047 00002D07 7503                    		jne	short mainmenu_11
 21048 00002D09 E9D000                  		jmp	mainmenu_28
 21049                                  mainmenu_11:
 21050                                  		;push	word [menu_2_segment]
 21051 00002D0C 1E                      		push	ds
 21052 00002D0D FF36[E99D]              		push	word [menu_2_offset]
 21053 00002D11 E806E9                  		call	display
 21054                                  		;pop	bx
 21055                                  		;pop	bx
 21056                                  		;push	word [menu_3_segment]
 21057 00002D14 1E                      		push	ds
 21058 00002D15 FF36[EB9D]              		push	word [menu_3_offset]
 21059 00002D19 E8FEE8                  		call	display
 21060                                  		;pop	bx
 21061                                  		;pop	bx
 21062                                  		;push	word [menu_7_segment]
 21063 00002D1C 1E                      		push	ds
 21064 00002D1D FF36[F39D]              		push	word [menu_7_offset]
 21065 00002D21 E8F6E8                  		call	display
 21066                                  		;pop	bx
 21067                                  		;pop	bx
 21068                                  mainmenu_12:
 21069                                  		;mov	al,[cur_disk]
 21070                                  		;add	al,'1'
 21071                                  		;mov	[insert],al
 21072                                  		;;push	word [menu_5_segment]
 21073                                  		;push	ds
 21074                                  		;push	word [menu_5_offset]
 21075                                  		;call	display
 21076                                  		;;pop	bx
 21077                                  		;;pop	bx
 21078                                  
 21079 00002D24 E82C01                  		call	display_menu_5 ; 31/12/2018
 21080                                  		
 21081                                  		;sub	ax,ax ; 0
 21082 00002D27 28C0                    		sub	al,al
 21083                                  		;mov	[mm_temp],ax
 21084                                  		;mov	[mm_temp],al ; 0
 21085                                  		;xor	ch,ch ; [mm_temp]
 21086 00002D29 B92E00                  		mov	cx,46 ; *
 21087                                  		;mov	[mm_i],ax
 21088 00002D2C 8846FA                  		mov	[mm_i],al ; 0
 21089                                  		;jmp	short mainmenu_14
 21090                                  mainmenu_13:
 21091 00002D2F A0[D4CB]                		mov	al,[cur_disk]
 21092                                  		;cbw
 21093                                  		;shl	ax,1
 21094                                  		;shl	ax,1
 21095 00002D32 D0E0                    		shl	al,1
 21096 00002D34 D0E0                    		shl	al,1
 21097                                  		;add	ax,[mm_i]
 21098 00002D36 0246FA                  		add	al,[mm_i]
 21099                                  		;mov	cx,46
 21100                                  		;mul	cx
 21101                                  		;mov	cl,46 ; *
 21102 00002D39 F6E1                    		mul	cl
 21103 00002D3B 89C3                    		mov	bx,ax
 21104 00002D3D 8A87[17C4]              		mov	al,[part_table_sys_id+bx]
 21105                                  		;sub	ah,ah
 21106                                  		;or	[mm_temp],ax
 21107                                  		;or	[mm_temp],al
 21108 00002D41 08C5                    		or	ch,al
 21109 00002D43 FE46FA                  		inc	byte [mm_i]
 21110                                  mainmenu_14:
 21111 00002D46 807EFA04                		cmp	byte [mm_i],4
 21112 00002D4A 72E3                    		jb	short mainmenu_13
 21113                                  		;cmp	byte [mm_temp],0
 21114                                  		;jna	short mainmenu_15
 21115 00002D4C 08ED                    		or	ch,ch ; [mm_temp]
 21116 00002D4E 7413                    		jz	short mainmenu_15
 21117                                  
 21118 00002D50 E8EE05                  		call	find_active_partition
 21119                                  		;or	al,al
 21120                                  		;jnz	short mainmenu_15
 21121 00002D53 750E                    		jnz	short mainmenu_15
 21122                                  		; al = 0
 21123                                  
 21124 00002D55 3806[D4CB]              		cmp	[cur_disk],al ; 0
 21125 00002D59 7508                    		jne	short mainmenu_15
 21126                                  		;push	word [menu_6_segment]
 21127 00002D5B 1E                      		push	ds
 21128 00002D5C FF36[F19D]              		push	word [menu_6_offset]
 21129 00002D60 E8B7E8                  		call	display
 21130                                  		;pop	bx
 21131                                  		;pop	bx
 21132                                  mainmenu_15:
 21133 00002D63 803E[D5C3]01            		cmp	byte [number_of_drives],1
 21134 00002D68 760E                    		jbe	short mainmenu_16
 21135                                  		;push	word [menu_4_segment]
 21136 00002D6A 1E                      		push	ds
 21137 00002D6B FF36[ED9D]              		push	word [menu_4_offset]
 21138 00002D6F E8A8E8                  		call	display
 21139                                  		;pop	bx
 21140                                  		;pop	bx
 21141 00002D72 C646FC05                		mov	byte [mm_max_input],5
 21142 00002D76 EB04                    		jmp	short mainmenu_17
 21143                                  mainmenu_16:
 21144 00002D78 C646FC04                		mov	byte [mm_max_input],4
 21145                                  mainmenu_17:
 21146 00002D7C FF36[9CA0]              		push	word [input_col]
 21147 00002D80 FF36[3EA1]              		push	word [input_row]
 21148 00002D84 8A46FC                  		mov	al,[mm_max_input]
 21149 00002D87 50                      		push	ax
 21150 00002D88 B001                    		mov	al,1
 21151 00002D8A 50                      		push	ax
 21152 00002D8B E8DCFC                  		call	get_num_input
 21153                                  		;add	sp,8 ; 15/12/2018
 21154                                  switch_input1:
 21155 00002D8E 8846FE                  		mov	[mm_input],al
 21156                                  		;cbw
 21157                                  		;cmp	ax,'5'
 21158 00002D91 3C35                    		cmp	al,'5'
 21159 00002D93 7434                    		je	short case_5
 21160 00002D95 7714                    		ja	short case_DEF
 21161 00002D97 2C1B                    		sub	al,1Bh  ; ESC key
 21162                                  		;jnz	short mainmenu_19
 21163                                  		;jmp	mainmenu_10
 21164 00002D99 7441                    		jz	short mainmenu_28
 21165                                  mainmenu_19:
 21166 00002D9B 2C16                    		sub	al,16h ; 1Bh+16h = 31h = '1'
 21167 00002D9D 7412                    		jz	short case_1 ; '1'
 21168 00002D9F FEC8                    		dec	al
 21169 00002DA1 7414                    		jz	short case_2 ; '2'
 21170 00002DA3 FEC8                    		dec	al
 21171 00002DA5 7416                    		jz	short case_3 ; '3'
 21172 00002DA7 FEC8                    		dec	al
 21173 00002DA9 7418                    		jz	short case_4 ; '4'
 21174                                  case_DEF:
 21175 00002DAB E86305                  		call	internal_program_error
 21176                                  mainmenu_21:
 21177 00002DAE E952FF                  		jmp	mainmenu_10
 21178                                  case_1:
 21179 00002DB1 E8861A                  		call	create_partition
 21180 00002DB4 E94CFF                  		jmp	mainmenu_10
 21181                                  case_2:
 21182 00002DB7 E8AE05                  		call	change_active_partition
 21183 00002DBA E946FF                  		jmp	mainmenu_10
 21184                                  case_3:
 21185 00002DBD E8B60C                  		call	delete_partition
 21186 00002DC0 E940FF                  		jmp	mainmenu_10
 21187                                  case_4:
 21188 00002DC3 E81A00                  		call	display_partition_information
 21189 00002DC6 E93AFF                  		jmp	mainmenu_10
 21190                                  case_5:
 21191 00002DC9 E868F2                  		call	change_current_drive
 21192 00002DCC E934FF                  		jmp	mainmenu_10
 21193                                  mainmenu_27:
 21194 00002DCF C606[05C4]00            		mov	byte [no_fatal_error],0
 21195                                  		;push	word [error_2_seg]
 21196 00002DD4 1E                      		push	ds
 21197 00002DD5 FF36[789E]              		push	word [error_2_off]
 21198 00002DD9 E83EE8                  		call	display
 21199                                  		;pop	bx
 21200                                  		;pop	bx
 21201                                  mainmenu_28:
 21202 00002DDC 89EC                    		mov	sp,bp
 21203 00002DDE 5D                      		pop	bp
 21204 00002DDF C3                      		retn
 21205                                  
 21206                                  ; ============================================================================
 21207                                  ;  DISPLAY PARTITION INFORMATION
 21208                                  ; ============================================================================
 21209                                  ; 16/12/2018
 21210                                  
 21211                                  ; fdisk.msg (MSDOS 6.0)
 21212                                  ;/***************************************************************************************************/
 21213                                  ;/*  Screen for DISPLAY_PARTITION_INFORMATION                                                       */
 21214                                  ;/*                                                                                                 */
 21215                                  ;/*     |00000000001111111111222222222233333333334444444444555555555566666666667777777777|          */
 21216                                  ;/*     |01234567890123456789012345678901234567890123456789012345678901234567890123456789|          */
 21217                                  ;/*   --|--------------------------------------------------------------------------------|          */
 21218                                  ;/*   00|                                                                                |          */
 21219                                  ;/*   01|                                                                                |          */
 21220                                  ;/*   02|                                                                                |          */
 21221                                  ;/*   03|                                                                                |          */
 21222                                  ;/*   04|                           Display Partition Information                        |menu_35   */
 21223                                  ;/*   05|                                                                                |          */
 21224                                  ;/*   06|    Current fixed disk drive: #                                                 |menu_5 #  */
 21225                                  ;/*   07|                                                                                |          */
 21226                                  ;/*   08|    Partition Status   Type    Size in Mbytes   Percentage of Disk Used         |menu_14 # */
 21227                                  ;/*   09|     ## #        #   #######       ####         ###%                            |menu_14 # */
 21228                                  ;/*   10|     ## #        #   #######       ####         ###%                            |          */
 21229                                  ;/*   11|     ## #        #   #######       ####         ###%                            |          */
 21230                                  ;/*   12|     ## #        #   #######       ####         ###%                            |          */
 21231                                  ;/*   13|                                                                                |          */
 21232                                  ;/*   14|    Total disk space is #### Mbytes (1 Mbyte = 1048576 bytes)                   |menu_15 # */
 21233                                  ;/*   15|                                                                                |          */
 21234                                  ;/*   16|                                                                                |          */
 21235                                  ;/*   17|    The Extended DOS partition contains Logical DOS Drives.                     |menu_36   */
 21236                                  ;/*   18|    Do you want to display the logical drive information (Y/N)......? [Y]       |menu_36   */
 21237                                  ;/*   19|                                                                                |          */
 21238                                  ;/*   20|                                                                                |          */
 21239                                  ;/*   21|                                                                                |          */
 21240                                  ;/*   22|                                                                                |          */
 21241                                  ;/*   23|                                                                                |          */
 21242                                  ;/*   24|    Press ESC to return to FDISK Options                                        |menu_11   */
 21243                                  ;/*   ------------------------------------------------------------------------------------          */
 21244                                  ;/*                                                                                                 */
 21245                                  ;/***************************************************************************************************/
 21246                                  
 21247                                  ; ----------------------------------------------------------------------------
 21248                                  ; fdisk.c (FDISK, MSDOS 6.0, 1991)	
 21249                                  ; ----------------------------------------------------------------------------
 21250                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 16/12/2018)
 21251                                  
 21252                                  ;/*  */
 21253                                  ;/******************* START OF SPECIFICATIONS *******************/
 21254                                  ;/*                                                             */
 21255                                  ;/* SUBROUTINE NAME: DISPLAY_PARTITION_INFORMATION              */
 21256                                  ;/*                                                             */
 21257                                  ;/* DESCRIPTIVE NAME: Display partition information             */
 21258                                  ;/*                                                             */
 21259                                  ;/* FUNCTION: Displays defined partition information and prompt */
 21260                                  ;/*           user to display disk volumes if they exist        */
 21261                                  ;/*                                                             */
 21262                                  ;/* NOTES:                                                      */
 21263                                  ;/*                                                             */
 21264                                  ;/*        The following screen is managed                      */
 21265                                  ;/*                                                             */
 21266                                  ;/*     |0000000000111111111122222222223333333333|              */
 21267                                  ;/*     |0123456789012345678901234567890123456789|              */
 21268                                  ;/*   --|----------------------------------------|              */
 21269                                  ;/*   00|                                        |              */
 21270                                  ;/*   01|                                        |              */
 21271                                  ;/*   02|                                        |              */
 21272                                  ;/*   03|                                        |              */
 21273                                  ;/*   04|Display Partition Information           |              */
 21274                                  ;/*   05|                                        |              */
 21275                                  ;/*   06|Current Fixed Disk Drive: #             |              */
 21276                                  ;/*   07|                                        |              */
 21277                                  ;/*   08|Partition Status   Type  Start  End Size|              */
 21278                                  ;/*   09|    #        #   #######  #### #### ####|              */
 21279                                  ;/*   10|                                        |              */
 21280                                  ;/*   11|                                        |              */
 21281                                  ;/*   12|                                        |              */
 21282                                  ;/*   13|                                        |              */
 21283                                  ;/*   14|Total disk space is #### cylinders.     |              */
 21284                                  ;/*   15|                                        |              */
 21285                                  ;/*   16|                                        |              */
 21286                                  ;/*   17|                                        |              */
 21287                                  ;/*   18|The EXTENDED DOS partition contains DOS |              */
 21288                                  ;/*   19|disk volumes. Do you want to display    |              */
 21289                                  ;/*   20|the volume information............? [Y] |              */
 21290                                  ;/*   21|                                        |              */
 21291                                  ;/*   22|                                        |              */
 21292                                  ;/*   23|Press ESC to return to FDISK Options    |              */
 21293                                  ;/*   --------------------------------------------              */
 21294                                  ;/*                                                             */
 21295                                  ;/* ENTRY POINTS: Display_Partition_Information                 */
 21296                                  ;/*      LINKAGE: display_partition_information ()              */
 21297                                  ;/*          NEAR CALL                                          */
 21298                                  ;/*                                                             */
 21299                                  ;/* INPUT: None                                                 */
 21300                                  ;/*                                                             */
 21301                                  ;/* EXIT-NORMAL: ERROR=FALSE                                    */
 21302                                  ;/*                                                             */
 21303                                  ;/* EXIT-ERROR: ERROR=TRUE                                      */
 21304                                  ;/*             GOTO internal_program_error if invalid input    */
 21305                                  ;/*             returned to this routine                        */
 21306                                  ;/*                                                             */
 21307                                  ;/* EFFECTS: No data directly modified by this routine, but     */
 21308                                  ;/*          child routines will modify data.                   */
 21309                                  ;/*                                                             */
 21310                                  ;/* INTERNAL REFERENCES:                                        */
 21311                                  ;/*   ROUTINES:                                                 */
 21312                                  ;/*      clear_screen                                           */
 21313                                  ;/*      wait_for_ESC                                           */
 21314                                  ;/*      display                                                */
 21315                                  ;/*      table_display                                          */
 21316                                  ;/*      get_yn_input                                           */
 21317                                  ;/*      find_partition_type                                    */
 21318                                  ;/*      display_volume_information                             */
 21319                                  ;/*      internal_program_error                                 */
 21320                                  ;/*                                                             */
 21321                                  ;/* EXTERNAL REFERENCES:                                        */
 21322                                  ;/*   ROUTINES:                                                 */
 21323                                  ;/*                                                             */
 21324                                  ;/******************** END OF SPECIFICATIONS ********************/
 21325                                  
 21326                                  ;/*  */
 21327                                  ;void display_partition_information()
 21328                                  ;
 21329                                  ;BEGIN
 21330                                  ;
 21331                                  ; char   input;
 21332                                  ;
 21333                                  ;    input = c(NUL);
 21334                                  ;    /* Clear_screen */
 21335                                  ;    clear_screen(u(0),u(0),u(24),u(79));
 21336                                  ;
 21337                                  ;    /* Display Header */
 21338                                  ;    display(menu_35);
 21339                                  ;
 21340                                  ;    /* Setup and print current disk */
 21341                                  ;    insert[0] = cur_disk+1+'0';
 21342                                  ;    display(menu_5);
 21343                                  ;
 21344                                  ;    /* Display information */
 21345                                  ;    if (table_display())
 21346                                  ;       BEGIN
 21347                                  ;
 21348                                  ;	/* Setup and print disk space msg */
 21349                                  ;	number_in_msg((XFLOAT)total_mbytes[cur_disk],u(0));
 21350                                  ;	display(menu_15);
 21351                                  ;
 21352                                  ;	/* See if any logical drive stuff to display */
 21353                                  ;	if (find_partition_type(uc(EXTENDED)))
 21354                                  ;	   BEGIN
 21355                                  ;	    /* See if any logical drives exist */
 21356                                  ;	    if (find_logical_drive())
 21357                                  ;	       BEGIN
 21358                                  ;
 21359                                  ;		/* print ESC prompt */
 21360                                  ;		display(menu_11);
 21361                                  ;
 21362                                  ;		/* Prompt to see if they want to see EXTENDED info */
 21363                                  ;		display(menu_36);
 21364                                  ;
 21365                                  ;		/* Get Y/N input, default is YES */
 21366                                  ;		input = get_yn_input(c(Yes),input_row,input_col);
 21367                                  ;		switch(input)
 21368                                  ;		   BEGIN
 21369                                  ;
 21370                                  ;		    case 1:    display_volume_information();
 21371                                  ;			       break;
 21372                                  ;
 21373                                  ;		    case 0:    break;
 21374                                  ;
 21375                                  ;		    case ESC:  break;
 21376                                  ;
 21377                                  ;		    default:   internal_program_error();
 21378                                  ;			       break;
 21379                                  ;		   END
 21380                                  ;	       END
 21381                                  ;	    else
 21382                                  ;		input = wait_for_ESC();
 21383                                  ;	   END
 21384                                  ;	else
 21385                                  ;	    input = wait_for_ESC();
 21386                                  ;       END
 21387                                  ;    else
 21388                                  ;	input = wait_for_ESC();
 21389                                  ;    /* clear the screen before going back to main menu */
 21390                                  ;    clear_screen(u(0),u(0),u(24),u(79));
 21391                                  ;    return;
 21392                                  ;END
 21393                                  
 21394                                  ; IBM PC-DOS 7.0, FDISK.COM (unpacked) Segment 0, Offset 202Ch
 21395                                  
 21396                                  display_partition_information:
 21397 00002DE0 55                      		push	bp
 21398                                  		;mov	bp,sp
 21399                                  		;sub	sp,2
 21400                                  		
 21401                                  		;mov	ax,79
 21402                                  		;push	ax
 21403                                  		;mov	ax,24
 21404                                  		;push	ax
 21405                                  		;sub	ax,ax
 21406                                  		;push	ax
 21407                                  		;push	ax
 21408                                  		;call	clear_screen
 21409                                  		;add	sp,8
 21410                                  
 21411 00002DE1 E87AE6                  		call	CLS
 21412                                  
 21413                                  		;push	word [menu_35_segment]
 21414 00002DE4 1E                      		push	ds
 21415 00002DE5 FF36[439E]              		push	word [menu_35_offset]
 21416 00002DE9 E82EE8                  		call	display
 21417                                  		;pop	bx
 21418                                  		;pop	bx
 21419                                  
 21420                                  		;mov	al,[cur_disk]
 21421                                  		;add	al,'1'
 21422                                  		;mov	[insert],al
 21423                                  		;;push	word [menu_5_segment]
 21424                                  		;push	ds
 21425                                  		;push	word [menu_5_offset]
 21426                                  		;call	display
 21427                                  		;;pop	bx
 21428                                  		;;pop	bx
 21429                                  
 21430 00002DEC E86400                  		call	display_menu_5 ; 31/12/2018
 21431                                  
 21432 00002DEF E87B00                  		call	table_display
 21433                                  		;or	al,al
 21434                                  		;jz	short disp_wait_for_esc
 21435 00002DF2 7257                    		jc	short disp_wait_for_esc
 21436                                  		
 21437 00002DF4 29C0                    		sub	ax,ax ; 0
 21438 00002DF6 50                      		push	ax
 21439 00002DF7 A0[D4CB]                		mov	al,[cur_disk]
 21440                                  		;cbw
 21441                                  		;mov	bx,ax
 21442                                  		;shl	bx,1
 21443 00002DFA D0E0                    		shl	al,1
 21444 00002DFC 89C3                    		mov	bx,ax
 21445 00002DFE FFB7[C8A0]              		push	word [total_mbytes+bx]
 21446 00002E02 E8EC01                  		call	number_in_msg
 21447                                  		;pop	bx
 21448                                  		;pop	bx
 21449                                  
 21450                                  		;push	word [menu_15_segment]
 21451 00002E05 1E                      		push	ds
 21452 00002E06 FF36[059E]              		push	word [menu_15_offset]
 21453 00002E0A E80DE8                  		call	display
 21454                                  		;pop	bx
 21455                                  		;pop	bx
 21456                                  		
 21457 00002E0D B005                    		mov	al,EXTENDED ; 5
 21458                                  		;push	ax
 21459 00002E0F E8A8EF                  		call	find_partition_type
 21460                                  		;pop	bx
 21461                                  		;or	al,al
 21462                                  		;jz	short disp_wait_for_esc
 21463 00002E12 7237                    		jc	short disp_wait_for_esc
 21464                                  
 21465 00002E14 E80502                  		call	find_logical_drive
 21466                                  		;or	al,al
 21467                                  		;jz	short disp_wait_for_esc
 21468 00002E17 7232                    		jc	short disp_wait_for_esc
 21469                                  
 21470                                  		;;push	word [menu_11_segment]
 21471                                  		;push	ds
 21472                                  		;push	word [menu_11_offset]
 21473                                  		;call	display
 21474                                  		;;pop	bx
 21475                                  		;;pop	bx
 21476                                  
 21477 00002E19 E84800                  		call	display_menu_11 ; 31/12/2018
 21478                                  		
 21479                                  		;push	word [menu_36_segment]
 21480 00002E1C 1E                      		push	ds
 21481 00002E1D FF36[459E]              		push	word [menu_36_offset]
 21482 00002E21 E8F6E7                  		call	display
 21483                                  		;pop	bx
 21484                                  		;pop	bx
 21485                                  		
 21486 00002E24 FF36[9CA0]              		push	word [input_col] ; Column for input
 21487 00002E28 FF36[3EA1]              		push	word [input_row] ; Row for input
 21488 00002E2C A0[CBC3]                		mov	al,[Yes] ; 'Y'	; Default input value/char
 21489 00002E2F 50                      		push	ax
 21490 00002E30 E81102                  		call	get_yn_input  ; Get YES ('Y'), NO ('N') input
 21491                                  		;add	sp,6
 21492                                  switch_input9:
 21493                                  		;cbw
 21494                                  		;cmp	ax,1Bh
 21495 00002E33 3C1B                    		cmp	al,1Bh ; ESC key
 21496 00002E35 7417                    		je	short case_disp_pinf_break
 21497 00002E37 7708                    		ja	short case_disp_pinf_DEF
 21498 00002E39 08C0                    		or	al,al
 21499 00002E3B 7411                    		jz	short case_disp_pinf_break ; NO, 'N'
 21500 00002E3D FEC8                    		dec	al
 21501 00002E3F 7405                    		jz	short case_disp_pinf_1 ; YES, 'Y'
 21502                                  case_disp_pinf_DEF:
 21503 00002E41 E8CD04                  		call	internal_program_error
 21504 00002E44 EB08                    		jmp	short case_disp_pinf_break
 21505                                  case_disp_pinf_1:
 21506 00002E46 E85C03                  		call	display_volume_information
 21507 00002E49 EB03                    		jmp	short case_disp_pinf_break
 21508                                  disp_wait_for_esc:
 21509 00002E4B E81C03                  		call	wait_for_ESC
 21510                                  case_disp_pinf_break:
 21511                                  		;mov	ax,79
 21512                                  		;push	ax
 21513                                  		;mov	ax,24
 21514                                  		;push	ax
 21515                                  		;sub	ax,ax
 21516                                  		;push	ax
 21517                                  		;push	ax
 21518                                  		;call	clear_screen
 21519                                  		
 21520 00002E4E E80DE6                  		call	CLS
 21521                                  
 21522                                  		;mov	sp,bp
 21523 00002E51 5D                      		pop	bp
 21524 00002E52 C3                      		retn
 21525                                  
 21526                                  display_menu_5:
 21527                                  		; 31/12/2018
 21528 00002E53 A0[D4CB]                		mov	al,[cur_disk]
 21529 00002E56 0431                    		add	al,'1'
 21530 00002E58 A2[E6CC]                		mov	[insert],al
 21531                                  		;push	word [menu_5_segment]
 21532 00002E5B 1E                      		push	ds
 21533 00002E5C FF36[EF9D]              		push	word [menu_5_offset]
 21534 00002E60 E8B7E7                  		call	display
 21535                                  		;pop	bx
 21536                                  		;pop	bx
 21537 00002E63 C3                      		retn
 21538                                  
 21539                                  display_menu_11:
 21540                                  		; 31/12/2018
 21541                                  		;push	word [menu_11_segment]
 21542 00002E64 1E                      		push	ds
 21543 00002E65 FF36[FB9D]              		push	word [menu_11_offset]
 21544 00002E69 E8AEE7                  		call	display
 21545                                  		;pop	bx
 21546                                  		;pop	bx
 21547 00002E6C C3                      		retn
 21548                                  
 21549                                  ; ----------------------------------------------------------------------------
 21550                                  ; tdisplay.c (FDISK, MSDOS 6.0, 1991)	
 21551                                  ; ----------------------------------------------------------------------------
 21552                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 16/12/2018)
 21553                                  
 21554                                  ;/*  */
 21555                                  ;char table_display()
 21556                                  ;
 21557                                  ;BEGIN
 21558                                  ;
 21559                                  ;    unsigned    i;
 21560                                  ;    unsigned    io;
 21561                                  ;    char       *ThisPartitionType;
 21562                                  ;    char        ThisPartitionLetter[3];
 21563                                  ;    FLAG        partition_found;
 21564                                  ;    char        partition_num;
 21565                                  ;
 21566                                  ;    memset(insert,c(' '),4*38);
 21567                                  ;    io = u(0);
 21568                                  ;
 21569                                  ;    /* Get current drive letters */
 21570                                  ;    get_letters();
 21571                                  ;
 21572                                  ;    /* Sort the partitions */
 21573                                  ;    sort_part_table(c(4));
 21574                                  ;
 21575                                  ;    /* loop thru the partitions, only print stuff if it is there */
 21576                                  ;    partition_found = FALSE;
 21577                                  ;    partition_num = c(0);
 21578                                  ;
 21579                                  ;    for (i=u(0); i < u(4); i++)
 21580                                  ;        BEGIN
 21581                                  ;
 21582                                  ;        if (part_table[cur_disk][sort[i]].sys_id != uc(0))
 21583                                  ;            BEGIN
 21584                                  ;
 21585                                  ;            partition_found = TRUE;
 21586                                  ;
 21587                                  ;            strcpy(ThisPartitionLetter,"  ");
 21588                                  ;            switch(part_table[cur_disk][sort[i]].sys_id)
 21589                                  ;                BEGIN
 21590                                  ;                case DOSNEW:
 21591                                  ;                case DOS16:
 21592                                  ;                case DOS12:
 21593                                  ;                    ThisPartitionType = DOS_part;
 21594                                  ;                    sprintf(ThisPartitionLetter,"%c%c",
 21595                                  ;                            part_table[cur_disk][sort[i]].drive_letter,
 21596                                  ;                            ( part_table[cur_disk][sort[i]].drive_letter == c(' ') ) ? ' ' : ':');
 21597                                  ;                    break;
 21598                                  ;                case EXTENDED:
 21599                                  ;                    ThisPartitionType = EXTENDED_part;
 21600                                  ;                    break;
 21601                                  ;                case BAD_BLOCK:
 21602                                  ;                    ThisPartitionType = BAD_BLOCK_part;
 21603                                  ;                    break;
 21604                                  ;                case XENIX1:
 21605                                  ;                    ThisPartitionType = XENIX_part;
 21606                                  ;                    break;
 21607                                  ;                case XENIX2:
 21608                                  ;                    ThisPartitionType = XENIX_part;
 21609                                  ;                    break;
 21610                                  ;                case PCIX:
 21611                                  ;                    ThisPartitionType = PCIX_part;
 21612                                  ;                    break;
 21613                                  ;                case HPFS:
 21614                                  ;                    ThisPartitionType = HPFS_part;
 21615                                  ;                    break;
 21616                                  ;                case NOVELL:
 21617                                  ;                    ThisPartitionType = NOVELL_part
 21618                                  ;                    break;
 21619                                  ;                case CPM:
 21620                                  ;                    ThisPartitionType = CPM_part;
 21621                                  ;                    break;
 21622                                  ;                default:
 21623                                  ;                    ThisPartitionType = NON_DOS_part;
 21624                                  ;                    break;
 21625                                  ;                END
 21626                                  ;
 21627                                  ;            io += sprintf(&insert[io],"%-2.2s%c%c%-7.7s%-11.11s%4.0d%-8.8s%3.0d%%",
 21628                                  ;                       ThisPartitionLetter,
 21629                                  ;                       partition_num+'1',
 21630                                  ;                       (part_table[cur_disk][sort[i]].boot_ind == uc(0x80)) ? 'A' : ' ',
 21631                                  ;                       ThisPartitionType,
 21632                                  ;                       part_table[cur_disk][sort[i]].vol_label,
 21633                                  ;                       part_table[cur_disk][sort[i]].mbytes_used,
 21634                                  ;                       part_table[cur_disk][sort[i]].system,
 21635                                  ;                       part_table[cur_disk][sort[i]].percent_used);
 21636                                  ;
 21637                                  ;            partition_num++;
 21638                                  ;
 21639                                  ;            END
 21640                                  ;
 21641                                  ;        END
 21642                                  ;
 21643                                  ;    /* Do a clearscreen to erase previous data */
 21644                                  ;    clear_screen(u(8),u(0),u(12),u(79));
 21645                                  ;
 21646                                  ;    if (partition_found) display(menu_14);
 21647                                  ;        else display(status_8);
 21648                                  ;
 21649                                  ;    /* Return true if partitions exist, false otherwise */
 21650                                  ;    if (partition_found) return(TRUE);
 21651                                  ;
 21652                                  ;    return(FALSE);
 21653                                  ;
 21654                                  ;END
 21655                                  
 21656                                  ; IBM PC-DOS 7.0, FDISK.COM (unpacked) Segment 0, Offset 3D20h
 21657                                  
 21658                                  table_display:
 21659                                  
 21660                                  %define td_i                bp-14 ; unsigned int, word
 21661                                  %define partition_num       bp-12 ; char, byte
 21662                                  %define td_io               bp-10 ; unsigned int, word		
 21663                                  %define partition_found	    bp-8  ; flag, byte
 21664                                  %define ThisPartitionType   bp-6  ; word, near pointer
 21665                                  %define ThisPartitionLetter bp-4  ; 4 chars (array), dword
 21666                                  
 21667 00002E6D 55                      		push	bp
 21668 00002E6E 89E5                    		mov	bp,sp
 21669 00002E70 83EC0E                  		sub	sp,14
 21670                                  		;push	si
 21671                                  
 21672                                  		;mov	ax,152 ; 4*38
 21673                                  		;push	ax
 21674                                  		;mov	ax,' '
 21675                                  		;push	ax
 21676                                  		;mov	ax,insert
 21677                                  		;push	ax
 21678                                  		;call	memset
 21679                                  		;add	sp,6
 21680                                  
 21681                                  		;push	di
 21682 00002E73 B99800                  		mov	cx,152 ; 4*38
 21683 00002E76 BF[E6CC]                		mov	di,insert
 21684 00002E79 B020                    		mov	al,' '
 21685 00002E7B F3AA                    		rep 	stosb
 21686                                  		;pop	di
 21687                                  				
 21688 00002E7D E856F9                  		call	get_letters
 21689                                  
 21690                                  		;mov	al,4
 21691                                  		;push	ax
 21692                                  
 21693 00002E80 B104                    		mov	cl,4
 21694 00002E82 E816FB                  		call	sort_part_table
 21695                                  		;pop	bx
 21696                                  
 21697                                  		;sub	al,al ; 0
 21698 00002E85 29C0                    		sub	ax,ax
 21699 00002E87 8846F8                  		mov	[partition_found],al
 21700 00002E8A 8846F4                  		mov	[partition_num],al
 21701                                  		;sub	ax,ax
 21702 00002E8D 8946F6                  		mov	[td_io],ax ; 0
 21703 00002E90 8946F2                  		mov	[td_i],ax ; 0
 21704                                  		;jmp	td_16
 21705 00002E93 E9A800                  		jmp	td_17
 21706                                  td_ptype_PRIDOS:
 21707 00002E96 A1[CA9E]                		mov	ax,[PRIDOS]
 21708 00002E99 8946FA                  		mov	[ThisPartitionType],ax
 21709                                  
 21710                                  		;;mov	al,[cur_disk]
 21711                                  		;;;cbw
 21712                                  		;;;shl	ax,1
 21713                                  		;;;shl	ax,1
 21714                                  		;;shl	al,1
 21715                                  		;;shl	al,1
 21716                                  		;mov	cl,[cur_disk]
 21717                                  		;shl	cl,1
 21718                                  		;shl	cl,1
 21719                                  		;mov	bx,[td_i]
 21720                                  		;;;mov	cx,ax
 21721                                  		;;mov	cl,al
 21722                                  		;mov	al,[sort+bx]
 21723                                  		;;cbw
 21724                                  		;;add	ax,cx
 21725                                  		;add	al,cl
 21726                                  		;;mov	cx,46
 21727                                  		;;imul	cx
 21728                                  		;mov	cl,46
 21729                                  		;mul	cl
 21730                                  		;;mov	bx,ax
 21731                                  		;
 21732                                  		;mov	si,ax ; *=*
 21733                                  
 21734 00002E9C 89DE                    		mov	si,bx ; *=*
 21735                                  
 21736                                  		;cmp	byte [part_table_drive_letter+bx],' '
 21737 00002E9E 80BC[3FC4]20            		cmp	byte [part_table_drive_letter+si],' '
 21738 00002EA3 7505                    		jne	short td_02
 21739 00002EA5 B82000                  		mov	ax,' '
 21740 00002EA8 EB03                    		jmp	short td_03
 21741                                  td_02:
 21742 00002EAA B83A00                  		mov	ax,':'
 21743                                  td_03:
 21744 00002EAD 50                      		push	ax
 21745 00002EAE 8A87[3FC4]              		mov	al,[part_table_drive_letter+bx]
 21746                                  		;cbw
 21747 00002EB2 50                      		push	ax
 21748 00002EB3 B8[B26F]                		mov	ax,twochars ; "%c%c"
 21749 00002EB6 50                      		push	ax
 21750 00002EB7 8D46FC                  		lea	ax,[ThisPartitionLetter]
 21751 00002EBA 50                      		push	ax
 21752 00002EBB E8FDF3                  		call	sprintf
 21753 00002EBE 83C408                  		add	sp,8
 21754                                  td_04:
 21755                                  		;mov	al,[cur_disk]
 21756                                  		;;cbw
 21757                                  		;;shl	ax,1
 21758                                  		;;shl	ax,1
 21759                                  		;shl	al,1
 21760                                  		;shl	al,1
 21761                                  		;mov	bx,[td_i]
 21762                                  		;;mov	cx,ax
 21763                                  		;mov	cl,al
 21764                                  		;mov	al,[sort+bx]
 21765                                  		;;cbw
 21766                                  		;;add	ax,cx
 21767                                  		;add	al,cl
 21768                                  		;mov	cx,46
 21769                                  		;;imul	cx
 21770                                  		;mul	cl
 21771                                  		;;mov	bx,ax
 21772                                  		;mov	si,ax
 21773                                  
 21774 00002EC1 89F3                    		mov	bx,si ; *=*
 21775                                  td_05:
 21776 00002EC3 FFB7[28C4]              		push	word [part_table_percent_used+bx]
 21777 00002EC7 81C3[36C4]              		add	bx,part_table_system
 21778 00002ECB 53                      		push	bx
 21779                                  		;mov	bx,ax
 21780                                  		;push	word [part_table_mbytes_used+bx]
 21781 00002ECC FFB4[26C4]              		push	word [part_table_mbytes_used+si]
 21782                                  		;add	ax,part_table_vol_label
 21783                                  		;push	ax
 21784 00002ED0 89F0                    		mov	ax,si
 21785 00002ED2 05[2AC4]                		add	ax,part_table_vol_label
 21786 00002ED5 50                      		push	ax
 21787 00002ED6 FF76FA                  		push	word [ThisPartitionType]
 21788                                  		;cmp	byte [part_table_boot_ind+bx],80h
 21789 00002ED9 80BC[12C4]80            		cmp	byte [part_table_boot_ind+si],80h
 21790 00002EDE 752D                    		jne	short td_13
 21791 00002EE0 B84100                  		mov	ax,'A'
 21792 00002EE3 EB2B                    		jmp	short td_14
 21793                                  td_ptype_EXTENDED:
 21794 00002EE5 A1[CE9E]                		mov	ax,[EXTDOS]
 21795                                  td_06:
 21796 00002EE8 8946FA                  		mov	[ThisPartitionType],ax
 21797 00002EEB 89DE                    		mov	si,bx ; *=* ; 16/12/2018
 21798                                  		;jmp	short td_04
 21799 00002EED EBD4                    		jmp	short td_05 ; 17/12/2018
 21800                                  td_ptype_TABLE:
 21801 00002EEF A1[D09E]                		mov	ax,[TABLE]
 21802 00002EF2 EBF4                    		jmp	short td_06
 21803                                  td_ptype_XENIX:
 21804 00002EF4 A1[CC9E]                		mov	ax,[XENIX]
 21805 00002EF7 EBEF                    		jmp	short td_06
 21806                                  td_ptype_PCIX:
 21807 00002EF9 A1[D29E]                		mov	ax,[PCIX]
 21808 00002EFC EBEA                    		jmp	short td_06
 21809                                  ;td_ptype_HPFS:
 21810                                  td_ptype_NTFS:
 21811                                  		;mov	ax,[HPFS]
 21812 00002EFE A1[D49E]                		mov	ax,[NTFS] ; 16/12/2018
 21813 00002F01 EBE5                    		jmp	short td_06
 21814                                  td_ptype_NOVELL:
 21815 00002F03 A1[D69E]                		mov	ax,[NOVELL]
 21816 00002F06 EBE0                    		jmp	short td_06
 21817                                  td_ptype_CPM:
 21818 00002F08 A1[D89E]                		mov	ax,[CPM]
 21819 00002F0B EBDB                    		jmp	short td_06
 21820                                  td_13:
 21821 00002F0D B82000                  		mov	ax,' '
 21822                                  td_14:
 21823 00002F10 50                      		push	ax
 21824 00002F11 8A46F4                  		mov	al,[partition_num]
 21825                                  		;cbw
 21826                                  		;add	ax,'1'
 21827 00002F14 0431                    		add	al,'1'
 21828 00002F16 50                      		push	ax
 21829 00002F17 8D46FC                  		lea	ax,[ThisPartitionLetter]
 21830 00002F1A 50                      		push	ax
 21831 00002F1B B8[B76F]                		mov	ax,ptbl_row_format ; "%-2.2s%c%c%-7.7s%-11.11s%4.1d%-8.8s%3.1"...
 21832 00002F1E 50                      		push	ax
 21833 00002F1F 8B46F6                  		mov	ax,[td_io]
 21834 00002F22 05[E6CC]                		add	ax,insert
 21835 00002F25 50                      		push	ax
 21836 00002F26 E892F3                  		call	sprintf
 21837 00002F29 83C414                  		add	sp,20
 21838 00002F2C 0146F6                  		add	[td_io],ax
 21839                                  
 21840 00002F2F FE46F4                  		inc	byte [partition_num]
 21841                                  td_15:
 21842 00002F32 FE46F2                  		inc	byte [td_i]
 21843                                  td_16:
 21844 00002F35 807EF204                		cmp	byte [td_i],4
 21845 00002F39 7203                    		jb	short td_17
 21846 00002F3B E98300                  		jmp	td_29
 21847                                  td_17:
 21848                                  		;mov	al,[cur_disk]
 21849                                  		;;cbw
 21850                                  		;;shl	ax,1
 21851                                  		;;shl	ax,1
 21852                                  		;shl	al,1
 21853                                  		;shl	al,1
 21854                                  		;mov	bx,[td_i]
 21855                                  		;;mov	cx,ax
 21856                                  		;mov	cl,al
 21857 00002F3E 8A0E[D4CB]              		mov	cl,[cur_disk]
 21858 00002F42 D0E1                    		shl	cl,1
 21859 00002F44 D0E1                    		shl	cl,1
 21860 00002F46 8B5EF2                  		mov	bx,[td_i]
 21861 00002F49 8A87[E2C3]              		mov	al,[sort+bx]
 21862                                  		;cbw
 21863                                  		;add	ax,cx
 21864 00002F4D 00C8                    		add	al,cl
 21865 00002F4F B92E00                  		mov	cx,46
 21866                                  		;imul	cx
 21867 00002F52 F6E1                    		mul	cl
 21868                                  		;mov	si,ax ; *=*
 21869                                  		;mov	bx,si ; *=*
 21870 00002F54 89C3                    		mov	bx,ax ; *=*
 21871                                  
 21872                                  		;cmp	byte [part_table_sys_id+si],0
 21873 00002F56 80BF[17C4]00            		cmp	byte [part_table_sys_id+bx],0
 21874 00002F5B 74D5                    		je	short td_15
 21875                                  
 21876 00002F5D C646F801                		mov	byte [partition_found],1
 21877                                  		
 21878                                  		;;mov	ax,twospace ; "	 "
 21879                                  		;;push	ax
 21880                                  		;;lea	ax,[ThisPartitionLetter]
 21881                                  		;;push	ax
 21882                                  		;;call	strcpy
 21883                                  		;;pop	bx
 21884                                  		;;pop	bx
 21885                                  
 21886 00002F61 BE[AF6F]                		mov	si,twospace
 21887 00002F64 8D7EFC                  		lea	di,[ThisPartitionLetter]
 21888 00002F67 E8B9ED                  		call	strcpy
 21889                                  
 21890                                  		;mov	al,[cur_disk]
 21891                                  		;;cbw
 21892                                  		;;shl	ax,1
 21893                                  		;;shl	ax,1
 21894                                  		;shl	al,1
 21895                                  		;shl	al,1
 21896                                  		;mov	bx,[td_i]
 21897                                  		;;mov	cx,ax
 21898                                  		;mov	cl,al
 21899                                  		;mov	al,[sort+bx]
 21900                                  		;;cbw
 21901                                  		;;add	ax,cx
 21902                                  		;add	al,cl
 21903                                  		;mov	cx,46
 21904                                  		;;imul	cx
 21905                                  		;mul	cl
 21906                                  		;mov	bx,ax
 21907                                  
 21908 00002F6A 8A87[17C4]              		mov	al,[part_table_sys_id+bx]
 21909                                  		;sub	ah,ah
 21910                                  		;dec	ax
 21911 00002F6E FEC8                    		dec	al
 21912 00002F70 7503                    		jnz	short td_18	; > 01h
 21913 00002F72 E921FF                  		jmp	td_ptype_PRIDOS
 21914                                  td_18:
 21915                                  		;dec	ax
 21916 00002F75 FEC8                    		dec	al
 21917 00002F77 7503                    		jnz	short td_19	; > 02h
 21918 00002F79 E978FF                  		jmp	td_ptype_XENIX
 21919                                  td_19:
 21920                                  		;dec	ax
 21921 00002F7C FEC8                    		dec	al
 21922 00002F7E 7503                    		jnz	short td_20	; > 03h
 21923 00002F80 E971FF                  		jmp	td_ptype_XENIX
 21924                                  td_20:
 21925                                  		;dec	ax
 21926 00002F83 FEC8                    		dec	al
 21927 00002F85 7503                    		jnz	short td_21	; > 04h
 21928 00002F87 E90CFF                  		jmp	td_ptype_PRIDOS
 21929                                  td_21:
 21930                                  		;dec	ax
 21931 00002F8A FEC8                    		dec	al
 21932 00002F8C 7503                    		jnz	short td_22	; > 05h
 21933 00002F8E E954FF                  		jmp	td_ptype_EXTENDED
 21934                                  td_22:
 21935                                  		;dec	ax
 21936 00002F91 FEC8                    		dec	al
 21937 00002F93 7503                    		jnz	short td_23	; > 06h
 21938 00002F95 E9FEFE                  		jmp	td_ptype_PRIDOS
 21939                                  td_23:
 21940                                  		;dec	ax
 21941 00002F98 FEC8                    		dec	al
 21942 00002F9A 7503                    		jnz	short td_24	; > 07h
 21943                                  		;jmp	td_ptype_HPFS
 21944 00002F9C E95FFF                  		jmp	td_ptype_NTFS ; 16/12/2018
 21945                                  td_24:
 21946                                  		;sub	ax,5Dh
 21947 00002F9F 2C5D                    		sub	al,5Dh
 21948 00002FA1 7503                    		jnz	short td_25	; > 64h
 21949                                  		;jb	short td_28
 21950                                  		;ja	short td_25
 21951 00002FA3 E95DFF                  		jmp	td_ptype_NOVELL
 21952                                  td_25:
 21953                                  		;sub	ax,11h
 21954 00002FA6 2C11                    		sub	al,11h
 21955 00002FA8 7503                    		jnz	short td_26	; > 75h
 21956                                  		;jb	short td_28
 21957                                  		;ja	short td_26
 21958 00002FAA E94CFF                  		jmp	td_ptype_PCIX
 21959                                  td_26:
 21960                                  		;sub	ax,66h
 21961 00002FAD 2C66                    		sub	al,66h
 21962 00002FAF 7503                    		jnz	short td_27	; > DBh
 21963                                  		;jb	short td_28
 21964                                  		;ja	short td_27
 21965 00002FB1 E954FF                  		jmp	td_ptype_CPM
 21966                                  td_27:
 21967                                  		;sub	ax,24h
 21968 00002FB4 2C24                    		sub	al,24h
 21969 00002FB6 7503                    		jnz	short td_28	; <> FFh
 21970 00002FB8 E934FF                  		jmp	td_ptype_TABLE
 21971                                  td_28:
 21972 00002FBB A1[DA9E]                		mov	ax,[NONDOS]
 21973 00002FBE E927FF                  		jmp	td_06
 21974                                  td_29:
 21975 00002FC1 B84F00                  		mov	ax,79
 21976 00002FC4 50                      		push	ax
 21977 00002FC5 B80C00                  		mov	ax,12
 21978 00002FC8 50                      		push	ax
 21979 00002FC9 29C0                    		sub	ax,ax
 21980 00002FCB 50                      		push	ax
 21981 00002FCC B80800                  		mov	ax,8
 21982 00002FCF 50                      		push	ax
 21983 00002FD0 E8C3E4                  		call	clear_screen
 21984                                  		;add	sp,8
 21985                                  
 21986 00002FD3 807EF800                		cmp	byte [partition_found],0
 21987 00002FD7 7407                    		je	short td_30
 21988                                  		
 21989                                  		;push	word [menu_14_segment]
 21990 00002FD9 1E                      		push	ds
 21991 00002FDA FF36[039E]              		push	word [menu_14_offset]
 21992 00002FDE EB05                    		jmp	short td_31
 21993                                  td_30:
 21994                                  		;push	word [status_8_seg]
 21995 00002FE0 1E                      		push	ds
 21996 00002FE1 FF36[6B9E]              		push	word [status_8_off]
 21997                                  td_31:
 21998 00002FE5 E832E6                  		call	display
 21999                                  		;pop	bx
 22000                                  		;pop	bx
 22001                                  
 22002                                  		;cmp	byte [partition_found],0
 22003                                  		;je	short td_32
 22004                                  		;mov	al,1
 22005                                  		;jmp	short td_33
 22006                                  ;td_32:
 22007                                  		;sub	al,al ; 0
 22008                                  
 22009 00002FE8 8A46F8                  		mov	al,[partition_found]
 22010 00002FEB 3C01                    		cmp	al,1	
 22011                                  ;td_33:
 22012                                  		;pop	si
 22013 00002FED 89EC                    		mov	sp,bp
 22014 00002FEF 5D                      		pop	bp
 22015 00002FF0 C3                      		retn
 22016                                  
 22017                                  ; ----------------------------------------------------------------------------
 22018                                  ; display.c (FDISK, MSDOS 6.0, 1991)	
 22019                                  ; ----------------------------------------------------------------------------
 22020                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 16/12/2018)
 22021                                  
 22022                                  ;void number_in_msg(number,start)
 22023                                  ;
 22024                                  ;XFLOAT      number;
 22025                                  ;unsigned    start;
 22026                                  ;
 22027                                  ;BEGIN
 22028                                  ;
 22029                                  ;char    mbytes[32];
 22030                                  ;
 22031                                  ;        /* Divide the space down and get it into decimal */
 22032                                  ;        sprintf(mbytes,"%4.0d",number);
 22033                                  ;        insert[start+0] = mbytes[0];
 22034                                  ;        insert[start+1] = mbytes[1];
 22035                                  ;        insert[start+2] = mbytes[2];
 22036                                  ;        insert[start+3] = mbytes[3];
 22037                                  ;
 22038                                  ;        return;
 22039                                  ;
 22040                                  ;END
 22041                                  
 22042                                  number_in_msg:
 22043                                  		; 16/12/2018
 22044                                  
 22045                                  	;%define numinmsg_mb	bp-32
 22046                                  	%define numinmsg_mb	bp-4	
 22047                                  
 22048                                  	%define numinmsg_num	bp+4
 22049                                  	%define numinmsg_start	bp+6
 22050                                  
 22051 00002FF1 55                      		push	bp
 22052 00002FF2 89E5                    		mov	bp,sp
 22053                                  		;sub	sp,32
 22054 00002FF4 83EC04                  		sub	sp,4
 22055                                  
 22056 00002FF7 FF7604                  		push	word [numinmsg_num]
 22057 00002FFA B8[846F]                		mov	ax,numinmsg_format ; "%4.1d"
 22058 00002FFD 50                      		push	ax
 22059 00002FFE 8D46FC                  		lea	ax,[numinmsg_mb]
 22060 00003001 50                      		push	ax
 22061 00003002 E8B6F2                  		call	sprintf
 22062                                  		;add	sp,6
 22063                                  
 22064 00003005 8B5E06                  		mov	bx,[numinmsg_start]
 22065                                  
 22066                                  		;mov	al,[numinmsg_mb]
 22067                                  		;mov	[insert+bx],al
 22068                                  		;mov	al,[numinmsg_mb+1]
 22069                                  		;mov	[insert+1+bx],al
 22070                                  		;mov	al,[numinmsg_mb+2]
 22071                                  		;mov	[insert+2+bx],al
 22072                                  		;mov	al,[numinmsg_mb+3]
 22073                                  		;mov	[insert+3+bx],al
 22074                                  
 22075 00003008 8B46FC                  		mov	ax,[numinmsg_mb]
 22076 0000300B 8987[E6CC]              		mov	[bx+insert],ax
 22077 0000300F 8B46FE                  		mov	ax,[numinmsg_mb+2]
 22078 00003012 8987[E8CC]              		mov	[bx+insert+2],ax
 22079                                  
 22080 00003016 89EC                    		mov	sp,bp
 22081 00003018 5D                      		pop	bp
 22082                                  		;retn
 22083 00003019 C20400                  		retn	4 ; 17/12/2018
 22084                                  
 22085                                  ; ----------------------------------------------------------------------------
 22086                                  ; partinfo.c (FDISK, MSDOS 6.0, 1991)	
 22087                                  ; ----------------------------------------------------------------------------
 22088                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 16/12/2018)
 22089                                  
 22090                                  ;char find_logical_drive()
 22091                                  ;
 22092                                  ;BEGIN
 22093                                  ;
 22094                                  ;unsigned  char  i;
 22095                                  ;
 22096                                  ;       /* See if there is a logical drive defined in Extended Partition */
 22097                                  ;       for (i = uc(0); i < uc(23);i++)
 22098                                  ;          BEGIN
 22099                                  ;
 22100                                  ;           /* See if we find a sys id that is not 0 */
 22101                                  ;           if (ext_table[cur_disk][i].sys_id != uc(0))
 22102                                  ;              BEGIN
 22103                                  ;               return(TRUE);
 22104                                  ;               break;
 22105                                  ;              END
 22106                                  ;          END
 22107                                  ;        return(FALSE);
 22108                                  ;END
 22109                                  
 22110                                  find_logical_drive:
 22111                                  		; 16/12/2018
 22112                                  
 22113                                  	;%define findlogdrv_i bp-2
 22114                                  	
 22115                                  		;push	bp
 22116                                  		;mov	bp,sp
 22117                                  		;sub	sp,2
 22118                                  		
 22119                                  		;mov	word [findlogdrv_i],0
 22120                                  		;jmp	short findlogdrv_2
 22121                                  		
 22122 0000301C 31D2                    		xor	dx,dx
 22123 0000301E EB07                    		jmp	short findlogdrv_3		
 22124                                  findlogdrv_1:
 22125                                  		;inc	byte [findlogdrv_i]
 22126 00003020 FEC2                    		inc	dl
 22127                                  findlogdrv_2:
 22128                                  		;cmp	byte [findlogdrv_i],23
 22129 00003022 80FA17                  		cmp	dl,23
 22130 00003025 7319                    		jnb	short findlogdrv_4
 22131                                  findlogdrv_3:
 22132 00003027 B018                    		mov	al,24
 22133                                  		;imul	byte [cur_disk]
 22134 00003029 F626[D4CB]              		mul	byte [cur_disk]
 22135                                  		;mov	cl,[findlogdrv_i]
 22136                                  		;;sub	ch,ch
 22137                                  		;;add	ax,cx
 22138                                  		;add	al,cl
 22139                                  		
 22140 0000302D 00D0                    		add	al,dl
 22141                                  		
 22142                                  		;mov	cx,46
 22143                                  		;imul	cx
 22144                                  		
 22145 0000302F B12E                    		mov	cl,46
 22146 00003031 F6E1                    		mul	cl
 22147 00003033 89C3                    		mov	bx,ax
 22148 00003035 80BF[4FA1]00            		cmp	byte [ext_table_sys_id+bx],0
 22149 0000303A 74E4                    		je	short findlogdrv_1
 22150 0000303C B001                    		mov	al,1
 22151 0000303E EB03                    		jmp	short findlogdrv_5 ; cf = 0
 22152                                  findlogdrv_4:
 22153 00003040 28C0                    		sub	al,al
 22154 00003042 F9                      		stc
 22155                                  findlogdrv_5:
 22156                                  		;mov	sp,bp
 22157                                  		;pop	bp
 22158 00003043 C3                      		retn
 22159                                  
 22160                                  ; ----------------------------------------------------------------------------
 22161                                  ; input.c (FDISK, MSDOS 6.0, 1991)	
 22162                                  ; ----------------------------------------------------------------------------
 22163                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 16/12/2018)
 22164                                  
 22165                                  ;/*  */
 22166                                  ;
 22167                                  ;char get_yn_input(input_default,row,col)
 22168                                  ;
 22169                                  ;unsigned        row;
 22170                                  ;unsigned        col;
 22171                                  ;char            input_default;
 22172                                  ;
 22173                                  ;BEGIN
 22174                                  ;
 22175                                  ;    char   input;
 22176                                  ;    char   default_used;
 22177                                  ;    char   input_value;
 22178                                  ;
 22179                                  ;    char   attribute;
 22180                                  ;    char far *attribute_ptr = &attribute;
 22181                                  ;    char far *input_ptr = &input;
 22182                                  
 22183                                  ;    if (mono_flag == TRUE)
 22184                                  ;/*C09   attribute = GRAY_ON_BLACK;  */
 22185                                  ;        attribute = HIWHITE_ON_BLACK; /*C09*/
 22186                                  ;    else
 22187                                  ;/*C09   attribute = WHITE_ON_BLUE;  */
 22188                                  ;        attribute = HIWHITE_ON_BLUE;  /*C09*/
 22189                                  ;
 22190                                  ;    /* print default entry if there is one */
 22191                                  ;    if (input_default != c(NUL))
 22192                                  ;
 22193                                  ;        BEGIN
 22194                                  ;        default_used = TRUE;
 22195                                  ;        /* position the cursor */
 22196                                  ;        VIOSETCURPOS(row,col,u(0));
 22197                                  ;
 22198                                  ;        /* Display the default character */
 22199                                  ;		 input = input_default;
 22200                                  ;		 VIOWRTCHARSTRATT(input_ptr,u(1),row,col,attribute_ptr,u(0));
 22201                                  ;        END
 22202                                  ;
 22203                                  ;    /* Assume bad input */
 22204                                  ;    valid_input = FALSE;
 22205                                  ;
 22206                                  ;    /* Loop until we get good stuff */
 22207                                  ;    while (valid_input == FALSE)
 22208                                  ;        BEGIN
 22209                                  ;
 22210                                  ;        /* position the cursor */
 22211                                  ;        VIOSETCURPOS(row,col,u(0));
 22212                                  ;
 22213                                  ;        /* Flush the keyboard buffer and get the next pressed key */
 22214                                  ;        input = get_char_input();
 22215                                  ;        input = dos_upper(input);
 22216                                  ;
 22217                                  ;        /* Go handle different inputs */
 22218                                  ;        switch(input)
 22219                                  ;            BEGIN
 22220                                  ;            case ESC:
 22221                                  ;                BEGIN
 22222                                  ;                valid_input = TRUE;
 22223                                  ;                break;
 22224                                  ;                END
 22225                                  ;
 22226                                  ;            case  CR:
 22227                                  ;                BEGIN
 22228                                  ;                /* Set the input to the default if there is one there */
 22229                                  ;                if (default_used)
 22230                                  ;                    BEGIN
 22231                                  ;                    if (input_default != c(NUL))
 22232                                  ;                        BEGIN
 22233                                  ;                        input_value = input_default;
 22234                                  ;                        END
 22235                                  ;                    else
 22236                                  ;                        BEGIN
 22237                                  ;                        internal_program_error();
 22238                                  ;                        END
 22239                                  ;                    END
 22240                                  ;
 22241                                  ;                /* See if YES or NO */
 22242                                  ;
 22243                                  ;                /* Do world trade get country information */
 22244                                  ;                input = check_yn_input(input_value);
 22245                                  ;
 22246                                  ;                if ((input == c(1)) || (input == c(0)))
 22247                                  ;                    BEGIN
 22248                                  ;                    valid_input = TRUE;
 22249                                  ;                    END
 22250                                  ;                else
 22251                                  ;                    BEGIN
 22252                                  ;                    /* Setup error message */
 22253                                  ;                    insert[0] = c(Yes);
 22254                                  ;                    insert[1] = c('-');
 22255                                  ;                    insert[2] = c(No);
 22256                                  ;                    display(error_31);
 22257                                  ;                    END
 22258                                  ;                break;
 22259                                  ;                END
 22260                                  ;
 22261                                  ;            default:
 22262                                  ;                BEGIN
 22263                                  ;                if ((check_yn_input(input) == c(1)) ||             /*C16*/
 22264                                  ;                    (check_yn_input(input) == c(0)))               /*C16*/
 22265                                  ;                    clear_screen(u(23),u(0),u(23),u(79));          /*C16*/
 22266                                  ;                else                                               /*C16*/
 22267                                  ;                    {                                              /*C16*/
 22268                                  ;                    /* Setup error message */                      /*C16*/
 22269                                  ;                    insert[0] = c(Yes);                            /*C16*/
 22270                                  ;                    insert[1] = c('-');                            /*C16*/
 22271                                  ;                    insert[2] = c(No);                             /*C16*/
 22272                                  ;                    display(error_31);                             /*C16*/
 22273                                  ;                    input = c(' ');                                /*C16*/
 22274                                  ;                    }                                              /*C16*/
 22275                                  ;                VIOWRTCHARSTRATT(input_ptr,u(1),row,col,attribute_ptr,u(0)); /*C16*/
 22276                                  ;                default_used = FALSE;
 22277                                  ;                input_value = input;
 22278                                  ;                break;
 22279                                  ;                END
 22280                                  ;            END
 22281                                  ;         END
 22282                                  ;     return(input);
 22283                                  ;END
 22284                                  
 22285                                  get_yn_input:
 22286                                  		; 16/12/2018
 22287                                  
 22288                                  	%define gyn_input_val	bp-16 ; byte, char 
 22289                                  	%define gyn_attr_ptr	bp-14 ; dword, far ptr
 22290                                  	%define gyn_def_used	bp-10 ; byte, char
 22291                                  	%define gyn_input_ptr	bp-8  ; dword, far ptr
 22292                                  	%define gyn_attribute	bp-4  ; byte, char
 22293                                  	%define gyn_input	bp-2  ; byte, char
 22294                                  	%define gyn_input_def	bp+4  ; byte, char 
 22295                                  	%define gyn_row		bp+6  ; word, unsigned int
 22296                                  	%define gyn_column	bp+8  ; word, unsigned int
 22297                                  
 22298 00003044 55                      		push	bp
 22299 00003045 89E5                    		mov	bp,sp
 22300 00003047 83EC10                  		sub	sp,16
 22301                                  
 22302 0000304A 8D46FC                  		lea	ax,[gyn_attribute]
 22303 0000304D 8946F2                  		mov	[gyn_attr_ptr],ax
 22304 00003050 8C56F4                  		mov	[gyn_attr_ptr+2],ss
 22305 00003053 8D4EFE                  		lea	cx,[gyn_input]
 22306 00003056 894EF8                  		mov	[gyn_input_ptr],cx
 22307 00003059 8C56FA                  		mov	[gyn_input_ptr+2],ss
 22308                                  
 22309 0000305C 803E[CAC3]01            		cmp	byte [mono_flag],1 ; TRUE
 22310 00003061 7506                    		jne	short gyni_1
 22311 00003063 C646FC0F                		mov	byte[gyn_attribute],0Fh  ; HIWHITE_ON_BLACK
 22312 00003067 EB04                    		jmp	short gyni_2
 22313                                  gyni_1:
 22314 00003069 C646FC1F                		mov	byte [gyn_attribute],1Fh ; HIWHITE_ON_BLUE
 22315                                  gyni_2:
 22316 0000306D 807E0400                		cmp	byte [gyn_input_def],0
 22317 00003071 7428                    		je	short gyni_3
 22318                                  
 22319                                  		;mov	[gyn_def_used],1
 22320                                  
 22321                                  		;push	word [gyn_row]
 22322                                  		;push	word [gyn_column]
 22323                                  		;sub	ax,ax
 22324                                  		;push	ax
 22325 00003073 8A7606                  		mov	dh,[gyn_row]
 22326 00003076 8A5608                  		mov	dl,[gyn_column]
 22327 00003079 E89AFB                  		call	VIOSETCURPOS
 22328                                  
 22329 0000307C 8A4604                  		mov	al,[gyn_input_def]
 22330 0000307F 8846FE                  		mov	[gyn_input],al
 22331 00003082 FF76FA                  		push	word [gyn_input_ptr+2]
 22332 00003085 FF76F8                  		push	word [gyn_input_ptr]
 22333 00003088 B80100                  		mov	ax,1
 22334 0000308B 50                      		push	ax
 22335 0000308C FF7606                  		push	word [gyn_row]
 22336 0000308F FF7608                  		push	word [gyn_column]
 22337 00003092 FF76F4                  		push	word [gyn_attr_ptr+2]
 22338 00003095 FF76F2                  		push	word [gyn_attr_ptr]
 22339                                  		;sub	ax,ax
 22340                                  		;push	ax
 22341 00003098 E83EE8                  		call	VIOWRTCHARSTRATT
 22342                                  gyni_3:
 22343 0000309B C606[DECB]00            		mov	byte [valid_input],0
 22344                                  gyni_4:
 22345                                  		;push	word [gyn_row]
 22346                                  		;push	word [gyn_column]
 22347                                  		;sub	ax,ax
 22348                                  		;push	ax
 22349 000030A0 8A7606                  		mov	dh,[gyn_row]
 22350 000030A3 8A5608                  		mov	dl,[gyn_column]
 22351 000030A6 E86DFB                  		call	VIOSETCURPOS
 22352                                  
 22353 000030A9 E85DFB                  		call	get_char_input
 22354                                  		;mov	[gyn_input], al
 22355                                  		
 22356                                  		;push	ax
 22357 000030AC E87FFB                  		call	dos_upper
 22358                                  		;pop	bx
 22359 000030AF 8846FE                  		mov	[gyn_input],al
 22360                                  switch_input11:
 22361                                  		;cbw
 22362                                  		;sub	ax,0Dh
 22363 000030B2 2C0D                    		sub	al,0Dh
 22364 000030B4 741D                    		jz	short case_gyni_CR
 22365                                  		;sub	ax,0Eh
 22366 000030B6 2C0E                    		sub	al,0Eh
 22367 000030B8 743B                    		jz	short case_gyni_ESC
 22368                                  case_gyni_DEF:
 22369                                  		; Check if character represents country relative
 22370                                  		; Yes or No response 
 22371                                  
 22372                                  		;mov	al,[gyn_input]
 22373                                  		;push	ax
 22374                                  		;call	check_yn_input
 22375                                  		;pop	bx
 22376                                  		;dec	al
 22377                                  		;jz	short gyni_7  ; al = 1 = YES
 22378                                  
 22379                                  		;cmp	al,1
 22380                                  		;ja	short gyni_13 ; al = 2 = not a valid YES or NO character
 22381                                  
 22382                                  		;mov	al,[gyn_input]
 22383                                  		;;push	ax
 22384                                  		;call	check_yn_input
 22385                                  		;;pop	bx
 22386                                  		;or	al,al
 22387                                  		;jnz	short gyni_13
 22388                                  
 22389 000030BA 8A56FE                  		mov	dl,[gyn_input]
 22390 000030BD E8D600                  		call	check_yn_input
 22391 000030C0 7255                    		jc	short gyni_13
 22392                                  gyni_7:
 22393 000030C2 B84F00                  		mov	ax,79
 22394 000030C5 50                      		push	ax
 22395 000030C6 B81700                  		mov	ax,23
 22396 000030C9 50                      		push	ax
 22397 000030CA 29C9                    		sub	cx,cx
 22398 000030CC 51                      		push	cx
 22399 000030CD 50                      		push	ax
 22400 000030CE E8C5E3                  		call	clear_screen
 22401                                  		;add	sp,8
 22402 000030D1 EB61                    		jmp	short gyni_14
 22403                                  case_gyni_CR:
 22404 000030D3 807EF600                		cmp	byte [gyn_def_used],0
 22405 000030D7 7411                    		je	short gyni_10
 22406 000030D9 807E0400                		cmp	byte [gyn_input_def],0
 22407 000030DD 7408                    		je	short gyni_9
 22408 000030DF 8A4604                  		mov	al,[gyn_input_def]
 22409 000030E2 8846F0                  		mov	[gyn_input_val],al
 22410 000030E5 EB03                    		jmp	short gyni_10
 22411                                  gyni_9:
 22412 000030E7 E82702                  		call	internal_program_error
 22413                                  gyni_10:
 22414                                  		;mov	al,[gyn_input_val]
 22415                                  		;push	ax
 22416                                  		;call	check_yn_input
 22417                                  		;pop	bx
 22418                                  		;mov	[gyn_input],al
 22419                                  		;cmp	al,1
 22420                                  		;je	short case_gyni_ESC
 22421                                  		;or	al,al
 22422                                  		;jnz	short gyni_12
 22423                                  		
 22424 000030EA 8A56F0                  		mov	dl,[gyn_input_val]
 22425 000030ED E8A600                  		call	check_yn_input
 22426 000030F0 720A                    		jc	short gyni_12
 22427 000030F2 8846FE                  		mov	[gyn_input],al
 22428                                  case_gyni_ESC:
 22429 000030F5 C606[DECB]01            		mov	byte [valid_input],1
 22430                                  		;jmp	short gyni_15
 22431 000030FA EB65                    		jmp	short gyni_16
 22432                                  gyni_12:
 22433 000030FC A0[CBC3]                		mov	al,[Yes]
 22434 000030FF A2[E6CC]                		mov	[insert],al
 22435 00003102 C606[E7CC]2D            		mov	byte [insert+1],'-'
 22436 00003107 A0[9EA0]                		mov	al,[No]
 22437 0000310A A2[E8CC]                		mov	[insert+2],al
 22438                                  		;push	word [error_31_seg]
 22439 0000310D 1E                      		push	ds
 22440 0000310E FF36[AE9E]              		push	word [error_31_off]
 22441 00003112 E805E5                  		call	display
 22442                                  		;pop	bx
 22443                                  		;pop	bx
 22444                                  		
 22445                                  		;jmp	short gyni_15
 22446 00003115 EB89                    		jmp	short gyni_4
 22447                                  gyni_13:
 22448 00003117 A0[CBC3]                		mov	al,[Yes]
 22449 0000311A A2[E6CC]                		mov	[insert],al
 22450 0000311D C606[E7CC]2D            		mov	byte [insert+1],'-'
 22451 00003122 A0[9EA0]                		mov	al,[No]
 22452 00003125 A2[E8CC]                		mov	[insert+2],al
 22453                                  		;push	word [error_31_seg]
 22454 00003128 1E                      		push	ds
 22455 00003129 FF36[AE9E]              		push	word [error_31_off]
 22456 0000312D E8EAE4                  		call	display
 22457                                  		;pop	bx
 22458                                  		;pop	bx
 22459 00003130 C646FE20                		mov	byte [gyn_input],' ' ; 20h
 22460                                  gyni_14:
 22461 00003134 FF76FA                  		push	word [gyn_input_ptr+2]
 22462 00003137 FF76F8                  		push	word [gyn_input_ptr]
 22463 0000313A B80100                  		mov	ax,1
 22464 0000313D 50                      		push	ax
 22465 0000313E FF7606                  		push	word [gyn_row]
 22466 00003141 FF7608                  		push	word [gyn_column]
 22467 00003144 FF76F4                  		push	word [gyn_attr_ptr+2]
 22468 00003147 FF76F2                  		push	word [gyn_attr_ptr]
 22469                                  		;sub	ax,ax
 22470                                  		;push	ax
 22471 0000314A E88CE7                  		call	VIOWRTCHARSTRATT
 22472                                  		
 22473 0000314D C646F600                		mov	byte [gyn_def_used],0
 22474 00003151 8A46FE                  		mov	al,[gyn_input]
 22475 00003154 8846F0                  		mov	[gyn_input_val],al
 22476                                  gyni_15:
 22477 00003157 803E[DECB]00            		cmp	byte [valid_input],0
 22478 0000315C 7503                    		jne	short gyni_16
 22479 0000315E E93FFF                  		jmp	gyni_4
 22480                                  gyni_16:
 22481 00003161 8A46FE                  		mov	al,[gyn_input]
 22482 00003164 89EC                    		mov	sp,bp
 22483 00003166 5D                      		pop	bp
 22484                                  		;retn
 22485 00003167 C20600                  		retn	6 ; 17/12/2018
 22486                                  
 22487                                  ; input.c - wait_for_ESC
 22488                                  ; ----------------------------------------------------------------------------
 22489                                  
 22490                                  ;char wait_for_ESC()
 22491                                  ;
 22492                                  ;BEGIN
 22493                                  ;    char  input;
 22494                                  ;
 22495                                  ;    clear_screen(u(24),u(0),u(24),u(79));
 22496                                  ;    display(menu_46);
 22497                                  ;    while (input != c(ESC))
 22498                                  ;        BEGIN
 22499                                  ;        /* position the cursor at the end of the ESC prompt */
 22500                                  ;        VIOSETCURPOS(input_row,input_col,u(0));
 22501                                  ;
 22502                                  ;        /* Get input */
 22503                                  ;        input = get_char_input();
 22504                                  ;        END
 22505                                  ;    return(c(ESC));
 22506                                  ;END
 22507                                  
 22508                                  wait_for_ESC:
 22509                                  		; 16/12/2018
 22510                                  
 22511                                  		;%define wfesc_input bp-2
 22512                                  
 22513                                  		;push	bp
 22514                                  		;mov	bp,sp
 22515                                  		;sub	sp,2
 22516                                  
 22517                                  		; 17/12/2018
 22518 0000316A B84F00                  		mov	ax,79
 22519 0000316D 50                      		push	ax	; Bottom Rigth Column (79)  
 22520 0000316E B81800                  		mov	ax,24
 22521 00003171 50                      		push	ax	; Bottom Row (24)
 22522 00003172 29C9                    		sub	cx,cx
 22523 00003174 51                      		push	cx	; Top Left Column (0)	
 22524 00003175 50                      		push	ax	; Top Row (24)
 22525 00003176 E81DE3                  		call	clear_screen  ;	clear row
 22526                                  		;add	sp,8
 22527                                  
 22528                                  		;push	word [menu_46_segment]
 22529 00003179 1E                      		push	ds
 22530 0000317A FF36[0F9E]              		push	word [menu_46_offset]
 22531 0000317E E899E4                  		call	display
 22532                                  		;pop	bx
 22533                                  		;pop	bx
 22534 00003181 EB0E                    		jmp	short wfesc_2
 22535                                  wfesc_1:
 22536                                  		;push	word [input_row]
 22537                                  		;push	word [input_col]
 22538                                  		;sub	ax,ax
 22539                                  		;push	ax
 22540 00003183 8A36[3EA1]              		mov	dh,[input_row]
 22541 00003187 8A16[9CA0]              		mov	dl,[input_col]
 22542 0000318B E888FA                  		call	VIOSETCURPOS
 22543                                  		
 22544 0000318E E878FA                  		call	get_char_input
 22545                                  		;mov	[wfesc_input],al
 22546                                  wfesc_2:
 22547                                  		;cmp	[wfesc_input],1Bh ; ESC key
 22548                                  		;jne	short wfesc_1
 22549                                  		;mov	al,1Bh
 22550                                  
 22551 00003191 3C1B                    		cmp	al,1Bh ; ESC key
 22552 00003193 75EE                    		jne	short wfesc_1
 22553                                  
 22554                                  		;mov	sp,bp
 22555                                  		;pop	bp
 22556                                  		
 22557 00003195 C3                      		retn
 22558                                  
 22559                                  ; ----------------------------------------------------------------------------
 22560                                  ; convert.c (FDISK, MSDOS 6.0, 1991)	
 22561                                  ; ----------------------------------------------------------------------------
 22562                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 16/12/2018)
 22563                                  
 22564                                  ;/***************************************************************************/
 22565                                  ;/*Routine name:  CHECK_YN_INPUT                                            */
 22566                                  ;/***************************************************************************/
 22567                                  ;/*                                                                         */
 22568                                  ;/*Description:   Get single character input, which must be a country       */
 22569                                  ;/*               dependent (Y/N). Will be verified using new uppercase     */
 22570                                  ;/*               table function calls. Will accept default value.          */
 22571                                  ;/*                                                                         */
 22572                                  ;/*Called Procedures:                                                       */
 22573                                  ;/*                                                                         */
 22574                                  ;/*                                                                         */
 22575                                  ;/*Change History: Updated        5/31/87         DRM                       */
 22576                                  ;/*                                                                         */
 22577                                  ;/*Input: input_value                                                       */
 22578                                  ;/*                                                                         */
 22579                                  ;/*Output: input                                                            */
 22580                                  ;/*        valid_input                                                      */
 22581                                  ;/*                                                                         */
 22582                                  ;/***************************************************************************/
 22583                                  
 22584                                  ;char check_yn_input(input_value)
 22585                                  ;
 22586                                  ;        char   input_value;
 22587                                  ;
 22588                                  ;BEGIN
 22589                                  ;        char   input;
 22590                                  ;
 22591                                  ;        /* Get extended country information */
 22592                                  ;        regs.x.ax = (unsigned)CAP_YN;
 22593                                  ;        /* Move input_value to register DL  */
 22594                                  ;        regs.h.dl = (unsigned char)input_value;
 22595                                  ;        int86((int)INT21,&regs,&regs);
 22596                                  ;
 22597                                  ;        /* check carry flag for error */
 22598                                  ;        if ((regs.x.cflag & CARRY_FLAG) == CARRY_FLAG)
 22599                                  ;        /* input will be 0 for NO and 1 for YES in AX */
 22600                                  ;           input = c(NO_GOOD);    /* input will equal not 0 or 1 */
 22601                                  ;        else
 22602                                  ;           input = c(regs.x.ax);
 22603                                  ;
 22604                                  ;        return(input);
 22605                                  ;END
 22606                                  
 22607                                  check_yn_input:
 22608                                  		; 16/12/2018
 22609                                  
 22610                                  	%define	yn_input bp-2
 22611                                  	%define yn_input_value bp+4
 22612                                  
 22613                                  		;push	bp
 22614                                  		;mov	bp,sp
 22615                                  		;sub	sp,2
 22616                                  
 22617                                  		;mov	[regs_x_ax],6523h
 22618                                  		;mov	al,[yn_input_value]
 22619                                  		;mov	[regs_x_dx],al
 22620                                  		;mov	ax,regs
 22621                                  		;push	ax
 22622                                  		;push	ax
 22623                                  		;mov	ax,21h
 22624                                  		;push	ax
 22625                                  		;call	int86
 22626                                  		;add	sp,6
 22627                                  		;mov	al,[regs_x_cflag]
 22628                                  		;and	al,1
 22629                                  		;cmp	al,1
 22630                                  		;jnz	short cyni_1
 22631                                  		;mov	byte [yn_input],2
 22632                                  		;jmp	short cyni_2
 22633                                  ;cyni_1:
 22634                                  		;mov	al,[regs_x_ax]
 22635                                  		;mov	[yn_input],al
 22636                                  ;cyni_2:	
 22637                                  		;mov	al,[yn_input]
 22638                                  		;mov	sp,bp
 22639                                  		;pop	bp
 22640                                  		;retn
 22641                                  
 22642                                  		; INT 21h
 22643                                  		;   INPUT:
 22644                                  		;      AH = 65h 
 22645                                  		;	    Get Extended Country Information (DOS 3.3+)
 22646                                  		;      AL = 23h
 22647                                  		;	    Determine if character represents 
 22648                                  		;	    country relative Yes or No response (DOS 4+)
 22649                                  		;
 22650                                  		;      DL = Character to be tested
 22651                                  		;			
 22652                                  		;   OUTPUT:
 22653                                  		;      AX = error code if CF is set
 22654                                  	  	;	  = 00h : NO response
 22655                                  	   	;	  = 01h : YES response
 22656                                  	  	;	  = 02h : not a yes or no response
 22657                                  
 22658                                  		;mov	dl,al
 22659                                  
 22660 00003196 B82365                  		mov	ax,6523h
 22661 00003199 CD21                    		int	21h
 22662 0000319B 7207                    		jc	short cyni_1
 22663 0000319D 08C0                    		or	al,al
 22664 0000319F 7403                    		jz	short cyni_1
 22665 000031A1 3C02                    		cmp	al,2
 22666 000031A3 F5                      		cmc	
 22667                                  cyni_1:
 22668 000031A4 C3                      		retn
 22669                                  
 22670                                  ; ============================================================================
 22671                                  ;  DISPLAY VOLUME INFORMATION
 22672                                  ; ============================================================================
 22673                                  ; 16/12/2018
 22674                                  
 22675                                  ; fdisk.msg (MSDOS 6.0)
 22676                                  ;/***************************************************************************************************/
 22677                                  ;/*  Screen for DISPLAY_VOLUME_INFORMATION                                                          */
 22678                                  ;/*                                                                                                 */
 22679                                  ;/*     |00000000001111111111222222222233333333334444444444555555555566666666667777777777|          */
 22680                                  ;/*     |01234567890123456789012345678901234567890123456789012345678901234567890123456789|          */
 22681                                  ;/*   --|--------------------------------------------------------------------------------|          */
 22682                                  ;/*   00|                                                                                |          */
 22683                                  ;/*   01|                     Display Logical DOS Drive Information                      |menu_37   */
 22684                                  ;/*   02|                                                                                |          */
 22685                                  ;/*   03|Drv Volume Label  Mbytes  System  Usage  Drv Volume Label  Mbytes  System  Usage|menu_19/20*/
 22686                                  ;/*   04|##  #############  ####  ########  ###%  ##  #############  ####  ########  ###%|          */
 22687                                  ;/*   05|##  #############  ####  ########  ###%  ##  #############  ####  ########  ###%|          */
 22688                                  ;/*   16|##  #############  ####  ########  ###%  ##  #############  ####  ########  ###%|          */
 22689                                  ;/*   17|##  #############  ####  ########  ###%  ##  #############  ####  ########  ###%|          */
 22690                                  ;/*   18|##  #############  ####  ########  ###%  ##  #############  ####  ########  ###%|          */
 22691                                  ;/*   19|##  #############  ####  ########  ###%  ##  #############  ####  ########  ###%|          */
 22692                                  ;/*   10|##  #############  ####  ########  ###%  ##  #############  ####  ########  ###%|          */
 22693                                  ;/*   11|##  #############  ####  ########  ###%  ##  #############  ####  ########  ###%|          */
 22694                                  ;/*   12|##  #############  ####  ########  ###%  ##  #############  ####  ########  ###%|          */
 22695                                  ;/*   13|##  #############  ####  ########  ###%  ##  #############  ####  ########  ###%|          */
 22696                                  ;/*   14|##  #############  ####  ########  ###%  ##  #############  ####  ########  ###%|          */
 22697                                  ;/*   15|##  #############  ####  ########  ###%                                         |          */
 22698                                  ;/*   16|                                                                                |          */
 22699                                  ;/*   17|    Total Extended DOS partition size is #### Mbytes (1 Mbyte = 1048576 bytes)  |menu_17   */
 22700                                  ;/*   18|                                                                                |          */
 22701                                  ;/*   19|                                                                                |          */
 22702                                  ;/*   20|                                                                                |          */
 22703                                  ;/*   21|                                                                                |          */
 22704                                  ;/*   22|                                                                                |          */
 22705                                  ;/*   23|                                                                                |          */
 22706                                  ;/*   24|    Press ESC to return to FDISK Options                                        |menu_11   */
 22707                                  ;/*   ------------------------------------------------------------------------------------          */
 22708                                  ;/*                                                                                                 */
 22709                                  ;/***************************************************************************************************/
 22710                                  
 22711                                  ; ----------------------------------------------------------------------------
 22712                                  ; fdisk.c (FDISK, MSDOS 6.0, 1991)	
 22713                                  ; ----------------------------------------------------------------------------
 22714                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 17/12/2018)
 22715                                  
 22716                                  ;/*  */
 22717                                  ;/******************* START OF SPECIFICATIONS *******************/
 22718                                  ;/*                                                             */
 22719                                  ;/* SUBROUTINE NAME: DISPLAY_VOLUME_INFORMATION                 */
 22720                                  ;/*                                                             */
 22721                                  ;/* DESCRIPTIVE NAME: Display DOS disk Volume Information       */
 22722                                  ;/*                                                             */
 22723                                  ;/* FUNCTION: Displays disk volume size and existence           */
 22724                                  ;/*                                                             */
 22725                                  ;/* NOTES:                                                      */
 22726                                  ;/*                                                             */
 22727                                  ;/*        The following screen is managed                      */
 22728                                  ;/*                                                             */
 22729                                  ;/*     |0000000000111111111122222222223333333333|              */
 22730                                  ;/*     |0123456789012345678901234567890123456789|              */
 22731                                  ;/*   --|----------------------------------------|              */
 22732                                  ;/*   01|Display DOS Disk Volume Information     |              */
 22733                                  ;/*   02|                                        |              */
 22734                                  ;/*   03|Vol Start End  Size  Vol Start End  Size|              */
 22735                                  ;/*   04| #  ####  #### ####   #  ####  #### ####|              */
 22736                                  ;/*   05|                                        |              */
 22737                                  ;/*   06|                                        |              */
 22738                                  ;/*   07|                                        |              */
 22739                                  ;/*   08|                                        |              */
 22740                                  ;/*   09|                                        |              */
 22741                                  ;/*   10|                                        |              */
 22742                                  ;/*   11|                                        |              */
 22743                                  ;/*   12|                                        |              */
 22744                                  ;/*   13|                                        |              */
 22745                                  ;/*   14|                                        |              */
 22746                                  ;/*   15|                                        |              */
 22747                                  ;/*   16|                                        |              */
 22748                                  ;/*   17|                                        |              */
 22749                                  ;/*   18|                                        |              */
 22750                                  ;/*   19|                                        |              */
 22751                                  ;/*   20|                                        |              */
 22752                                  ;/*   21|                                        |              */
 22753                                  ;/*   22|                                        |              */
 22754                                  ;/*   23|Press ESC to return to FDISK Options    |              */
 22755                                  ;/*   --------------------------------------------              */
 22756                                  ;/*                                                             */
 22757                                  ;/* ENTRY POINTS: Display_Volume_Information                    */
 22758                                  ;/*      LINKAGE: display_volume_information ()                 */
 22759                                  ;/*          NEAR CALL                                          */
 22760                                  ;/*                                                             */
 22761                                  ;/* INPUT: None                                                 */
 22762                                  ;/*                                                             */
 22763                                  ;/* EXIT-NORMAL: ERROR=FALSE                                    */
 22764                                  ;/*                                                             */
 22765                                  ;/* EXIT-ERROR: ERROR=TRUE                                      */
 22766                                  ;/*                                                             */
 22767                                  ;/* EFFECTS: No data directly modified by this routine, but     */
 22768                                  ;/*          child routines will modify data.                   */
 22769                                  ;/*                                                             */
 22770                                  ;/* INTERNAL REFERENCES:                                        */
 22771                                  ;/*   ROUTINES:                                                 */
 22772                                  ;/*      clear_screen                                           */
 22773                                  ;/*      wait_for_ESC                                           */
 22774                                  ;/*      display                                                */
 22775                                  ;/*      volume_display                                         */
 22776                                  ;/*                                                             */
 22777                                  ;/* EXTERNAL REFERENCES:                                        */
 22778                                  ;/*   ROUTINES:                                                 */
 22779                                  ;/*                                                             */
 22780                                  ;/******************** END OF SPECIFICATIONS ********************/
 22781                                  
 22782                                  ;void display_volume_information()
 22783                                  ;
 22784                                  ;BEGIN
 22785                                  ;
 22786                                  ;    char   input;
 22787                                  ;    char    temp;
 22788                                  ;
 22789                                  ;    input = c(NUL);
 22790                                  ;    /* clear the screen */
 22791                                  ;    clear_screen(u(0),u(0),u(24),u(79));
 22792                                  ;
 22793                                  ;    /* Display Header */
 22794                                  ;    display(menu_37);
 22795                                  ;
 22796                                  ;    /* Display information */
 22797                                  ;    temp = volume_display();
 22798                                  ;
 22799                                  ;    /* Set up partition size message */
 22800                                  ;    sprintf(insert,"%4.0d",get_partition_size( uc(EXTENDED) ) );
 22801                                  ;    display(menu_21);
 22802                                  ;
 22803                                  ;    /* print ESC prompt */
 22804                                  ;    display(menu_11);
 22805                                  ;
 22806                                  ;    /* Wait to exit */
 22807                                  ;    input = wait_for_ESC();
 22808                                  ;    return;
 22809                                  ;END
 22810                                  
 22811                                  ; IBM PC-DOS 7.0 FDISK.COM (unpacked) /// Segment 0, Offset 20FCh 
 22812                                  
 22813                                  display_volume_information:
 22814                                  		; 17/12/2018	
 22815                                  		;mov	ax,79
 22816                                  		;push	ax
 22817                                  		;mov	ax,24
 22818                                  		;push	ax
 22819                                  		;sub	ax,ax
 22820                                  		;push	ax
 22821                                  		;push	ax
 22822                                  		;call	clear_screen
 22823                                  		;add	sp,8
 22824                                  
 22825 000031A5 E8B6E2                  		call	CLS ; 18/02/2018
 22826                                  
 22827                                  		;push	word [menu_37_segment]
 22828 000031A8 1E                      		push	ds
 22829 000031A9 FF36[479E]              		push    word [menu_37_offset]
 22830 000031AD E86AE4                  		call    display
 22831                                  		;pop	bx
 22832                                  		;pop	bx
 22833                                  
 22834 000031B0 E82500                  		call    volume_display
 22835                                  
 22836                                  		;;mov	al,5
 22837                                  		;;push	ax
 22838                                  		;mov	dh,5
 22839                                  		;call	get_partition_size
 22840                                  		;;pop	bx
 22841                                  		;push 	ax
 22842                                  		;mov	ax,p_size_format ; "%4.1d"
 22843                                  		;push	ax
 22844                                  		;mov     ax,insert
 22845                                  		;push    ax
 22846                                  		;call    sprintf
 22847                                  		;add	sp,6
 22848                                  		;
 22849                                  		;;push	word [menu_21_segment]
 22850                                  		;push	ds
 22851                                  		;push	word [menu_21_offset]
 22852                                  		;call	display
 22853                                  		;;pop	bx
 22854                                  		;;pop	bx
 22855                                  
 22856 000031B3 E80500                  		call	display_ext_partition_size ; 31/12/2018
 22857                                  
 22858                                  		;;push	word [menu_11_segment]
 22859                                  		;push	ds
 22860                                  		;push	word [menu_11_offset]
 22861                                  		;call	display
 22862                                  		;;pop	bx
 22863                                  		;;pop	bx
 22864                                  
 22865 000031B6 E8ABFC                  		call	display_menu_11 ; 31/12/2018
 22866                                  
 22867 000031B9 EBAF                    		jmp     wait_for_ESC
 22868                                  
 22869                                  ; 31/12/2018
 22870                                  display_ext_partition_size:
 22871                                  		;mov	al,5
 22872                                  		;push	ax
 22873 000031BB B605                    		mov	dh,5
 22874 000031BD E85E01                  		call	get_partition_size
 22875                                  		;pop	bx
 22876 000031C0 50                      		push    ax
 22877 000031C1 B8[846F]                		mov	ax,p_size_format ; "%4.1d"
 22878 000031C4 50                      		push	ax
 22879 000031C5 B8[E6CC]                		mov     ax,insert
 22880 000031C8 50                      		push    ax
 22881 000031C9 E8EFF0                  		call    sprintf
 22882 000031CC 83C406                  		add	sp,6
 22883                                  
 22884                                  		;push	word [menu_21_segment]
 22885 000031CF 1E                      		push	ds
 22886 000031D0 FF36[1B9E]              		push	word [menu_21_offset]
 22887 000031D4 E843E4                  		call	display
 22888                                  		;pop	bx
 22889                                  		;pop	bx
 22890                                  
 22891 000031D7 C3                      		retn
 22892                                  
 22893                                  ; ----------------------------------------------------------------------------
 22894                                  ; vdisplay.c (FDISK, MSDOS 6.0, 1991)	
 22895                                  ; ----------------------------------------------------------------------------
 22896                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 18/12/2018)
 22897                                  
 22898                                  ;/*  */
 22899                                  ;char volume_display()
 22900                                  ;
 22901                                  ;BEGIN
 22902                                  ;
 22903                                  ;    unsigned    i;
 22904                                  ;
 22905                                  ;    char        drive_found;
 22906                                  ;    char        drive_letter;
 22907                                  ;    char        drive_num;
 22908                                  ;
 22909                                  ;    char        first_display;
 22910                                  ;    char        second_display;
 22911                                  ;    char        third_display;
 22912                                  ;    char        fourth_display;
 22913                                  ;    unsigned    insert_offset;
 22914                                  ;
 22915                                  ;    first_display = FALSE;
 22916                                  ;
 22917                                  ;    /* get the current drive letters */
 22918                                  ;    get_letters();
 22919                                  ;
 22920                                  ;    /* loop thru the partitions, only print stuff if it is there */
 22921                                  ;
 22922                                  ;    /* Get the drives in order by location on disk */
 22923                                  ;    sort_ext_table(c(23));
 22924                                  ;
 22925                                  ;    /* initialize all the inserts to blanks */
 22926                                  ;    memset(insert,c(' '),(24*29));
 22927                                  ;
 22928                                  ;    drive_num = c(0);
 22929                                  ;    drive_found = FALSE;
 22930                                  ;    first_display = TRUE;
 22931                                  ;    insert_offset = 0;
 22932                                  ;
 22933                                  ;    for (i=u(0); i < u(23); i++)
 22934                                  ;       BEGIN
 22935                                  ;
 22936                                  ;        /* See if entry exists */
 22937                                  ;        if ( (ext_table[cur_disk][sort[i]].sys_id == uc(DOS12)) ||
 22938                                  ;             (ext_table[cur_disk][sort[i]].sys_id == uc(DOS16)) ||
 22939                                  ;             (ext_table[cur_disk][sort[i]].sys_id == uc(DOSNEW)) )
 22940                                  ;           BEGIN
 22941                                  ;
 22942                                  ;            /* We found one, now get the info */
 22943                                  ;            drive_found = TRUE;
 22944                                  ;
 22945                                  ;            insert_offset += sprintf(&insert[insert_offset],"%c%c%-11.11s%4.0d%-8.8s%3.0d%%",
 22946                                  ;                    ext_table[cur_disk][sort[i]].drive_letter,
 22947                                  ;                    ( ext_table[cur_disk][sort[i]].drive_letter == c(' ') ) ? ' ' : ':',
 22948                                  ;                    ext_table[cur_disk][sort[i]].vol_label,
 22949                                  ;                    ext_table[cur_disk][sort[i]].mbytes_used,
 22950                                  ;                    ext_table[cur_disk][sort[i]].system,
 22951                                  ;                    ext_table[cur_disk][sort[i]].percent_used );
 22952                                  ;
 22953                                  ;            drive_letter = ext_table[cur_disk][sort[i]].drive_letter;
 22954                                  ;            drive_num++;
 22955                                  ;
 22956                                  ;           END
 22957                                  ;       END
 22958                                  ;
 22959                                  ;    /* Display the column of drives */
 22960                                  ;    if (drive_found)
 22961                                  ;       BEGIN
 22962                                  ;
 22963                                  ;        clear_screen(u(2),u(0),u(15),u(79));
 22964                                  ;
 22965                                  ;        if ( drive_num > 0 )
 22966                                  ;            BEGIN
 22967                                  ;            pinsert = &insert[0];
 22968                                  ;            display(menu_19);
 22969                                  ;            END
 22970                                  ;
 22971                                  ;        if ( drive_num > 6 )
 22972                                  ;            BEGIN
 22973                                  ;            pinsert = &insert[6*29];
 22974                                  ;            display(menu_43);
 22975                                  ;            END
 22976                                  ;
 22977                                  ;        if ( drive_num > 12 )
 22978                                  ;            BEGIN
 22979                                  ;            pinsert = &insert[12*29];
 22980                                  ;            display(menu_20);
 22981                                  ;            END
 22982                                  ;
 22983                                  ;        if ( drive_num > 18 )
 22984                                  ;            BEGIN
 22985                                  ;            pinsert = &insert[18*29];
 22986                                  ;            display(menu_44);
 22987                                  ;            END
 22988                                  ;        pinsert = &insert[0];
 22989                                  ;        END
 22990                                  ;    else
 22991                                  ;       BEGIN
 22992                                  ;        /* Didn't find any */
 22993                                  ;        if (first_display)
 22994                                  ;           BEGIN
 22995                                  ;            /* Wipe out display and put up message */
 22996                                  ;            clear_screen(u(2),u(0),u(15),u(79));
 22997                                  ;            display(status_9);
 22998                                  ;           END
 22999                                  ;       END
 23000                                  ;    /* Return the highest drive letter found */
 23001                                  ;    return(drive_letter);
 23002                                  ;END
 23003                                  
 23004                                  volume_display:
 23005                                  		; 18/12/2018
 23006                                  
 23007                                  	;%define vd_first_display bp-18
 23008                                  	;%define vd_insert_offset bp-14
 23009                                  	;%define vd_i		  bp-12
 23010                                  	;%define vd_drive_letter  bp-10
 23011                                  	;%define vd_drive_num	  bp-8
 23012                                  	;%define vd_drive_found	  bp-6
 23013                                  
 23014                                  	%define vd_drive_letter   bp-12 ; 25/12/2018
 23015                                  	%define vd_first_display  bp-10
 23016                                  	%define vd_insert_offset  bp-8
 23017                                  	%define vd_i		  bp-6
 23018                                  	%define vd_drive_num	  bp-4
 23019                                  	%define vd_drive_found	  bp-2
 23020                                  
 23021 000031D8 55                      		push	bp
 23022 000031D9 89E5                    		mov	bp,sp
 23023                                  		;sub	sp,18
 23024 000031DB 83EC0C                  		sub	sp,12 ; 02/01/2019
 23025 000031DE 56                      		push	si ; *
 23026                                  
 23027 000031DF E8F4F5                  		call	get_letters
 23028                                  
 23029                                  		;mov	al,23
 23030                                  		;push	ax
 23031 000031E2 B117                    		mov	cl,23
 23032 000031E4 E81EF8                  		call	sort_ext_table
 23033                                  		;pop	bx
 23034                                  
 23035                                  		;mov	ax,696 ; 24*29
 23036                                  		;push	ax
 23037                                  		;mov	ax,' '
 23038                                  		;push	ax
 23039                                  		;mov	ax,insert
 23040                                  		;push	ax
 23041                                  		;call	memset
 23042                                  		;add	sp,6
 23043                                  
 23044 000031E7 B020                    		mov	al,' '
 23045 000031E9 B9B802                  		mov	cx,696 ; 24*29
 23046 000031EC BF[E6CC]                		mov	di,insert
 23047                                  		;push	ds
 23048                                  		;pop	es
 23049 000031EF F3AA                    		rep	stosb
 23050                                  
 23051                                  		;sub	al,al
 23052 000031F1 29C0                    		sub	ax,ax
 23053 000031F3 8846FC                  		mov	[vd_drive_num],al ; 0
 23054 000031F6 8846FE                  		mov	[vd_drive_found],al ; 0
 23055                                  
 23056                                  		;mov	byte [vd_first_display],1 ; TRUE
 23057                                  
 23058                                  		;sub	ax,ax ; 0
 23059 000031F9 8946F8                  		mov	[vd_insert_offset],ax ; 0
 23060 000031FC 8946FA                  		mov	[vd_i],ax ; 0
 23061 000031FF EB30                    		jmp	short vd_05
 23062                                  vd_01:
 23063 00003201 B83A00                  		mov	ax,':'
 23064                                  vd_02:
 23065 00003204 50                      		push	ax
 23066 00003205 8A84[77A1]              		mov	al,[ext_table_drive_letter+si]
 23067                                  		;cbw
 23068 00003209 50                      		push	ax
 23069 0000320A B8[E26F]                		mov	ax,eptbl_row_format ; "%c%c%-11.11s%4.1d%-8.8s%3.1d%%"
 23070 0000320D 50                      		push	ax
 23071 0000320E 8B46F8                  		mov	ax,[vd_insert_offset]
 23072 00003211 05[E6CC]                		add	ax,insert
 23073 00003214 50                      		push	ax
 23074 00003215 E8A3F0                  		call	sprintf
 23075 00003218 83C410                  		add	sp,16
 23076 0000321B 0146F8                  		add	[vd_insert_offset],ax
 23077                                  		
 23078                                  		;mov	al,24
 23079                                  		;;imul	byte [cur_disk]
 23080                                  		;mul	byte [cur_disk]
 23081                                  		;mov	bx,[vd_i]
 23082                                  		;;mov	cx,ax
 23083                                  		;;mov	al,[sort+bx]
 23084                                  		;;cbw
 23085                                  		;mov	cl,[sort+bx]
 23086                                  		;add	al,cl
 23087                                  		;;mov	cx,46
 23088                                  		;;imul	cx
 23089                                  		;mov	cl,46
 23090                                  		;mul	cl
 23091                                  		;mov	bx,ax
 23092                                  		
 23093                                  		;mov	al,[ext_table_drive_letter+bx]
 23094 0000321E 8A84[77A1]              		mov	al,[ext_table_drive_letter+si]
 23095                                  vd_03:
 23096 00003222 8846F4                  		mov	[vd_drive_letter],al ; 25/12/2018
 23097 00003225 FE46FC                  		inc	byte [vd_drive_num]
 23098                                  vd_04:
 23099 00003228 FE46FA                  		inc	byte [vd_i]
 23100                                  ;vd_05:
 23101 0000322B 807EFA17                		cmp	byte [vd_i],23
 23102 0000322F 734E                    		jnb	short vd_08
 23103                                  vd_05:
 23104 00003231 B018                    		mov	al,24
 23105                                  		;imul	byte [cur_disk]
 23106 00003233 F626[D4CB]              		mul	byte [cur_disk]
 23107 00003237 8B5EFA                  		mov	bx,[vd_i]
 23108                                  		;mov	cx,ax
 23109                                  		;mov	al,[sort+bx]
 23110                                  		;cbw
 23111                                  		;add	ax,cx
 23112                                  		;mov	cl,[sort+bx]
 23113                                  		;add	al,cl
 23114 0000323A 0287[E2C3]              		add	al,[sort+bx] ; 06/01/2019
 23115                                  		;mov	cx,46
 23116                                  		;imul	cx
 23117 0000323E B12E                    		mov	cl,46
 23118 00003240 F6E1                    		mul	cl
 23119 00003242 89C3                    		mov	bx,ax
 23120 00003244 80BF[4FA1]01            		cmp	byte [ext_table_sys_id+bx],1
 23121 00003249 740E                    		je	short vd_06
 23122 0000324B 80BF[4FA1]04            		cmp	byte [ext_table_sys_id+bx],4
 23123 00003250 7407                    		je	short vd_06
 23124 00003252 80BF[4FA1]06            		cmp	byte [ext_table_sys_id+bx],6
 23125 00003257 75CF                    		jne	short vd_04
 23126                                  vd_06:
 23127 00003259 C646FE01                		mov	byte [vd_drive_found],1
 23128                                  		
 23129                                  		;mov	al,24
 23130                                  		;imul	byte [cur_disk]
 23131                                  		;mov	bx,[vd_i]
 23132                                  		;;mov	cx,ax
 23133                                  		;;mov	al,[sort+bx]
 23134                                  		;;cbw
 23135                                  		;;add	ax,cx
 23136                                  		;mov	cl,[sort+bx]
 23137                                  		;add	al,cl
 23138                                  		;;mov	cx,46
 23139                                  		;;imul	cx
 23140                                  		;mov	cl,46
 23141                                  		;mul	cl
 23142                                  		;mov	si,ax ; -*-
 23143                                  
 23144 0000325D 89DE                    		mov	si,bx ; -*-		
 23145                                  
 23146                                  		;push	word [ext_table_percent_used+si]
 23147                                  		;add	si,ext_table_system
 23148                                  		;push	si
 23149                                  		;mov	si,ax
 23150 0000325F FFB7[60A1]              		push	word [ext_table_percent_used+bx]
 23151 00003263 81C3[6EA1]              		add	bx,ext_table_system
 23152 00003267 53                      		push	bx
 23153                                  		;mov	bx,ax ; -*-
 23154 00003268 89F3                    		mov	bx,si ; -*-
 23155                                  		;push	word [ext_table_mbytes_used+si]
 23156 0000326A FFB7[5EA1]              		push	word [ext_table_mbytes_used+bx]
 23157                                  		;add	ax,ext_table_vol_label
 23158                                  		;push	ax
 23159 0000326E 81C3[62A1]              		add	bx,ext_table_vol_label
 23160 00003272 53                      		push	bx
 23161 00003273 80BC[77A1]20            		cmp	byte [ext_table_drive_letter+si],' '
 23162                                  		;je	short vd_07
 23163                                  		;jmp	vd_01
 23164 00003278 7587                    		jne	short vd_01
 23165                                  vd_07:
 23166 0000327A B82000                  		mov	ax,' '
 23167 0000327D EB85                    		jmp	vd_02
 23168                                  vd_08:
 23169 0000327F 807EFE00                		cmp	byte [vd_drive_found],0
 23170                                  		;jne	short vd_09
 23171                                  		;jmp	vd_14
 23172 00003283 746A                    		je	short vd_14
 23173                                  vd_09:
 23174 00003285 B84F00                  		mov	ax,79
 23175 00003288 50                      		push	ax
 23176 00003289 B80F00                  		mov	ax,15
 23177 0000328C 50                      		push	ax
 23178 0000328D 29C0                    		sub	ax,ax
 23179 0000328F 50                      		push	ax
 23180 00003290 B80200                  		mov	ax,2
 23181 00003293 50                      		push	ax
 23182 00003294 E8FFE1                  		call	clear_screen
 23183                                  		;add	sp,8
 23184                                  		
 23185 00003297 807EFC00                		cmp	byte [vd_drive_num],0
 23186                                  		;jle	short vd_10
 23187 0000329B 764A                    		jna	short vd_13
 23188                                  		
 23189 0000329D C706[8A70][E6CC]        		mov	word [pinsert],insert
 23190                                  		;push	word [menu_19_segment]
 23191 000032A3 1E                      		push	ds
 23192 000032A4 FF36[139E]              		push	word [menu_19_offset]
 23193 000032A8 E86FE3                  		call	display
 23194                                  		;pop	bx
 23195                                  		;pop	bx
 23196                                  vd_10:
 23197 000032AB 807EFC06                		cmp	byte [vd_drive_num],6
 23198                                  		;jle	short vd_11
 23199 000032AF 7E36                    		jle	short vd_13
 23200                                  
 23201 000032B1 C706[8A70][94CD]        		mov	word [pinsert],insert+174 ; 6*29
 23202                                  		;push	word [menu_43_segment]
 23203 000032B7 1E                      		push	ds
 23204 000032B8 FF36[159E]              		push	word [menu_43_offset]
 23205 000032BC E85BE3                  		call	display
 23206                                  		;pop	bx
 23207                                  		;pop	bx
 23208                                  vd_11:
 23209 000032BF 807EFC0C                		cmp	byte [vd_drive_num],12
 23210                                  		;jle	short vd_12
 23211 000032C3 7E22                    		jle	short vd_13
 23212                                  
 23213 000032C5 C706[8A70][42CE]        		mov	word [pinsert],insert+348 ; 12*129
 23214                                  		;push	word [menu_20_segment]
 23215 000032CB 1E                      		push	ds
 23216 000032CC FF36[179E]              		push	word [menu_20_offset]
 23217 000032D0 E847E3                  		call	display
 23218                                  		;pop	bx
 23219                                  		;pop	bx
 23220                                  vd_12:
 23221 000032D3 807EFC12                		cmp	byte [vd_drive_num],18
 23222 000032D7 7E0E                    		jle	short vd_13
 23223                                  
 23224 000032D9 C706[8A70][F0CE]        		mov	word [pinsert],insert+522 ; 18*129
 23225                                  		;push	word [menu_44_segment]
 23226 000032DF 1E                      		push	ds
 23227 000032E0 FF36[199E]              		push	word [menu_44_offset]
 23228 000032E4 E833E3                  		call	display
 23229                                  		;pop	bx
 23230                                  		;pop	bx
 23231                                  vd_13:
 23232 000032E7 C706[8A70][E6CC]        		mov	word [pinsert],insert
 23233 000032ED EB1A                    		jmp	short vd_15
 23234                                  vd_14:
 23235                                  		;cmp	[vd_first_display],0
 23236                                  		;je	short vd_15
 23237                                  
 23238 000032EF B84F00                  		mov	ax,79
 23239 000032F2 50                      		push	ax
 23240 000032F3 B80F00                  		mov	ax,15
 23241 000032F6 50                      		push	ax
 23242 000032F7 29C0                    		sub	ax,ax
 23243 000032F9 50                      		push	ax
 23244 000032FA B80200                  		mov	ax,2
 23245 000032FD 50                      		push	ax
 23246 000032FE E895E1                  		call	clear_screen
 23247                                  		;add	sp,8
 23248                                  
 23249                                  		;push	word [status_9_seg]
 23250 00003301 1E                      		push	ds
 23251 00003302 FF36[6D9E]              		push	word [status_9_off]
 23252 00003306 E811E3                  		call	display
 23253                                  		;pop	bx
 23254                                  		;pop	bx
 23255                                  vd_15:
 23256 00003309 8A46F4                  		mov	al,[vd_drive_letter] ; 25/12/2018
 23257                                  		
 23258 0000330C 5E                      		pop	si ; *
 23259 0000330D 89EC                    		mov	sp,bp
 23260 0000330F 5D                      		pop	bp
 23261 00003310 C3                      		retn
 23262                                  
 23263                                  ; ----------------------------------------------------------------------------
 23264                                  ; fdisk.c (FDISK, MSDOS 6.0, 1991)	
 23265                                  ; ----------------------------------------------------------------------------
 23266                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 18/12/2018)
 23267                                  
 23268                                  ;/*  */
 23269                                  ;void internal_program_error()
 23270                                  ;
 23271                                  ;BEGIN
 23272                                  ;   display(internal_error);
 23273                                  ;   DOSEXIT(u(0),u(0));
 23274                                  ;   return;
 23275                                  ;END
 23276                                  
 23277                                  internal_program_error:
 23278                                  
 23279                                  		; 18/12/2018
 23280                                  
 23281                                  		;push	word [inter_err_seg]
 23282 00003311 1E                      		push	ds
 23283 00003312 FF36[C29E]              		push	word [inter_err_off]
 23284 00003316 E801E3                  		call	display
 23285                                  		;pop	bx
 23286                                  		;pop	bx
 23287                                  		
 23288                                  		;sub	ax,ax
 23289                                  		;push	ax
 23290                                  		;push	ax
 23291                                  		;call	DOSEXIT
 23292                                  		;retn
 23293                                  
 23294 00003319 29C0                    		sub	ax,ax
 23295 0000331B E94ACD                  		jmp	DOSEXIT
 23296                                  
 23297                                  ; ----------------------------------------------------------------------------
 23298                                  ; partinfo.c (FDISK, MSDOS 6.0, 1991)	
 23299                                  ; ----------------------------------------------------------------------------
 23300                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 17/12/2018)
 23301                                  
 23302                                  ;XFLOAT get_partition_size(type) 
 23303                                  ;
 23304                                  ;unsigned char type;
 23305                                  ;
 23306                                  ;BEGIN
 23307                                  ; char  i;
 23308                                  ;
 23309                                  ; /*  Look at all four partition entries for system id byte that matches */
 23310                                  ; for (i = c(0); i < c(4);i++)
 23311                                  ;    BEGIN
 23312                                  ;
 23313                                  ;     /* if we find a match, get the size */
 23314                                  ;     if (part_table[cur_disk][i].sys_id == type)
 23315                                  ;        BEGIN
 23316                                  ;         /* Get the size of the partition from the array */
 23317                                  ;         return(part_table[cur_disk][i].mbytes_used);
 23318                                  ;        END
 23319                                  ;    END
 23320                                  ; /* Did not find one, something bad wrong happened */
 23321                                  ; internal_program_error();
 23322                                  ;END
 23323                                  
 23324                                  get_partition_size:
 23325                                  		; 17/12/2018
 23326                                  
 23327                                  	;%define gpz_i	 bp-2
 23328                                  	;%define gpz_type bp+4
 23329                                  
 23330                                  		; DH = [gpz_type]
 23331                                  
 23332                                  		;push	bp
 23333                                  		;mov	bp,sp
 23334                                  		;;sub	sp,2
 23335                                  		;xor	ax,ax
 23336                                  		;mov	word [gpz_i],ax ; 0
 23337                                  		;push	ax
 23338                                  		;xor	dx,dx
 23339                                  		;xor	dl,dl
 23340                                  		;jmp	short gpz_2
 23341 0000331E B2FF                    		mov	dl,0FFh ; 19/12/2018
 23342                                  gpz_1:	
 23343                                  		;inc	byte [gpz_i]
 23344 00003320 FEC2                    		inc	dl
 23345                                  ;gpz_2:
 23346                                  		;cmp	byte [gpz_i],4
 23347 00003322 80FA04                  		cmp	dl,4
 23348                                  		;jge	short gpz_3
 23349 00003325 7DEA                    		jge	short internal_program_error ; 19/12/2018
 23350                                  gpz_2:
 23351                                  		;mov	al,[cur_disk]
 23352                                  		;cbw
 23353                                  		;shl	ax,1
 23354                                  		;shl	ax,1
 23355                                  		;mov	cx,ax
 23356                                  
 23357                                  		;mov	cl,[cur_disk]
 23358                                  		;shl	cl,1
 23359                                  		;shl	cl,1
 23360                                  		
 23361                                  		;mov	al,[gpz_i]
 23362                                  		;;cbw
 23363                                  		;;add	ax,cx
 23364                                  		;add	al,cl		
 23365                                  		
 23366 00003327 A0[D4CB]                		mov	al,[cur_disk]
 23367 0000332A D0E0                    		shl	al,1
 23368 0000332C D0E0                    		shl	al,1
 23369 0000332E 00D0                    		add	al,dl ; [gpz_i]		
 23370                                  
 23371                                  		;mov	cx,46
 23372                                  		;imul	cx
 23373 00003330 B12E                    		mov	cl,46
 23374 00003332 F6E1                    		mul	cl
 23375 00003334 89C3                    		mov	bx,ax
 23376                                  
 23377                                  		;mov	al,[gpz_type]
 23378                                  		;cmp	[part_table_sys_id+bx],al
 23379 00003336 38B7[17C4]              		cmp	[part_table_sys_id+bx],dh ; [gpz_type]
 23380 0000333A 75E4                    		jne	short gpz_1
 23381 0000333C 8B87[26C4]              		mov	ax,[part_table_mbytes_used+bx]
 23382                                  		;jmp	short gpz_4
 23383 00003340 C3                      		retn	; 19/12/2018
 23384                                  ;gpz_3:
 23385                                  		;;call	internal_program_error
 23386                                  		;jmp	internal_program_error ; 19/12/2018
 23387                                  ;gpz_4:
 23388                                  		;mov	sp,bp
 23389                                  		;pop	bp
 23390                                  		;retn
 23391                                  
 23392                                  ; ----------------------------------------------------------------------------
 23393                                  ; 18/12/2018
 23394                                  
 23395                                  ;char find_active_partition()
 23396                                  ;
 23397                                  ;BEGIN
 23398                                  ;
 23399                                  ;unsigned  char   i;
 23400                                  ;
 23401                                  ;       /* See if there is an active partition */
 23402                                  ;       for (i = uc(0); i < uc(4);i++)
 23403                                  ;         BEGIN
 23404                                  ;          /* if we find an active one, TRUE return */
 23405                                  ;          if (part_table[cur_disk][i].boot_ind == uc(ACTIVE))
 23406                                  ;             BEGIN
 23407                                  ;              return(TRUE);
 23408                                  ;              break;
 23409                                  ;             END
 23410                                  ;         END
 23411                                  ;       /* Did not find one, return FALSE */
 23412                                  ;       return(FALSE);
 23413                                  ;END
 23414                                  
 23415                                  find_active_partition:
 23416                                  		; 18/12/2018
 23417                                  
 23418                                  		;%define fap_i bp-2
 23419                                  
 23420                                  		;push	bp
 23421                                  		;mov	bp,sp
 23422                                  
 23423                                  		;sub	sp,2
 23424                                  		;mov	word [fap_i],0
 23425                                  		;xor	dx,dx
 23426                                  		;xor	dl,dl
 23427                                  		;jmp	short fap_2
 23428 00003341 B2FF                    		mov	dl,0FFh ; 19/12/2018
 23429                                  fap_1:
 23430                                  		;inc	byte [fap_i]
 23431 00003343 FEC2                    		inc	dl
 23432                                  fap_2:
 23433                                  		;cmp	byte [fap_i],4
 23434 00003345 80FA04                  		cmp	dl,4
 23435 00003348 731B                    		jnb	short fap_3
 23436                                  		
 23437 0000334A A0[D4CB]                		mov	al,[cur_disk]
 23438                                  		;cbw
 23439                                  		;shl	ax,1
 23440                                  		;shl	ax,1
 23441 0000334D D0E0                    		shl	al,1
 23442 0000334F D0E0                    		shl	al,1
 23443                                  		;mov	cl,[fap_i]
 23444                                  		;;sub	ch,ch
 23445                                  		;;add	ax,cx
 23446                                  		;add	al,cl
 23447 00003351 00D0                    		add	al,dl
 23448                                  		;mov	cx,46
 23449                                  		;imul	cx
 23450 00003353 B12E                    		mov	cl,46		
 23451 00003355 F6E1                    		mul	cl
 23452 00003357 89C3                    		mov	bx,ax
 23453                                  
 23454 00003359 80BF[12C4]80            		cmp	byte [part_table_boot_ind+bx],80h
 23455 0000335E 75E3                    		jne	short fap_1
 23456                                  		;mov	al,1
 23457                                  		;jmp	short fap_4
 23458                                  
 23459 00003360 30C0                    		xor	al,al
 23460 00003362 FEC0                    		inc	al
 23461                                  
 23462                                  		; DL = 0  to 3 (active partition number)
 23463                                  		; zf = 0
 23464                                  		; AL = 1
 23465                                  
 23466 00003364 C3                      		retn
 23467                                  fap_3:
 23468 00003365 28C0                    		sub	al,al
 23469                                  
 23470                                  		; DL = 4
 23471                                  		; zf = 1
 23472                                  		; AL = 0
 23473                                  fap_4:
 23474                                  		;mov	sp,bp
 23475                                  		;pop	bp
 23476                                  
 23477 00003367 C3                      		retn
 23478                                  
 23479                                  ; ============================================================================
 23480                                  ;  CHANGE ACTIVE INFORMATION
 23481                                  ; ============================================================================
 23482                                  ; 19/12/2018
 23483                                  
 23484                                  ; fdisk.msg (MSDOS 6.0)
 23485                                  ;/***************************************************************************************************/
 23486                                  ;/*  Screen for CHANGE_ACTIVE_PARTITION                                                             */
 23487                                  ;/*                                                                                                 */
 23488                                  ;/*     |00000000001111111111222222222233333333334444444444555555555566666666667777777777|          */
 23489                                  ;/*     |01234567890123456789012345678901234567890123456789012345678901234567890123456789|          */
 23490                                  ;/*   --|--------------------------------------------------------------------------------|          */
 23491                                  ;/*   00|                                                                                |          */
 23492                                  ;/*   01|                              Set Active Partition                              |menu_23   */
 23493                                  ;/*   02|                                                                                |          */
 23494                                  ;/*   03|                                                                                |          */
 23495                                  ;/*   04|                                                                                |          */
 23496                                  ;/*   05|                                                                                |          */
 23497                                  ;/*   06|    Current fixed disk drive: #                                                 |menu_5 #  */
 23498                                  ;/*   07|                                                                                |          */
 23499                                  ;/*   08|    Partition Status   Type    Size in Mbytes   Percentage of Disk Used         |menu_14 # */
 23500                                  ;/*   09|     ## #        #   #######       ####         ###%                            |          */
 23501                                  ;/*   10|     ## #        #   #######       ####         ###%                            |          */
 23502                                  ;/*   11|     ## #        #   #######       ####         ###%                            |          */
 23503                                  ;/*   12|     ## #        #   #######       ####         ###%                            |          */
 23504                                  ;/*   13|                                                                                |          */
 23505                                  ;/*   14|    Total disk space is #### Mbytes (1 Mbyte = 1048576 bytes)                   |menu_15 # */
 23506                                  ;/*   15|                                                                                |          */
 23507                                  ;/*   16|    Enter the number of the partition you want to make active............:[#]   |menu_24   */
 23508                                  ;/*   17|                                                                                |          */
 23509                                  ;/*   18|                                                                                |          */
 23510                                  ;/*   19|                                                                                |          */
 23511                                  ;/*   20|                                                                                |          */
 23512                                  ;/*   21|                                                                                |          */
 23513                                  ;/*   22|                                                                                |          */
 23514                                  ;/*   23|                                                                                |          */
 23515                                  ;/*   24|    Press ESC to return to FDISK Options                                        |menu_11   */
 23516                                  ;/*   ------------------------------------------------------------------------------------          */
 23517                                  ;/*                                                                                                 */
 23518                                  ;/***************************************************************************************************/
 23519                                  
 23520                                  ; ----------------------------------------------------------------------------
 23521                                  ; fdisk.c (FDISK, MSDOS 6.0, 1991)	
 23522                                  ; ----------------------------------------------------------------------------
 23523                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 19/12/2018)
 23524                                  
 23525                                  ;/*  */
 23526                                  ;/******************* START OF SPECIFICATIONS *******************/
 23527                                  ;/*                                                             */
 23528                                  ;/* SUBROUTINE NAME: CHANGE_ACTIVE_PARTITION                    */
 23529                                  ;/*                                                             */
 23530                                  ;/* DESCRIPTIVE NAME: Change bootable partition                 */
 23531                                  ;/*                                                             */
 23532                                  ;/* FUNCTION: Will allow user to select the partition that will */
 23533                                  ;/*           recieve control when system is IPL'd. This is     */
 23534                                  ;/*           only for the first hardfile as far as booting is  */
 23535                                  ;/*           concerned, although partitions can be set active  */
 23536                                  ;/*           the second. There are reserved partitions that may*/
 23537                                  ;/*           not be set active and this routine will enforce   */
 23538                                  ;/*           that.                                             */
 23539                                  ;/*                                                             */
 23540                                  ;/* NOTES: If no valid partition is specified, then the active  */
 23541                                  ;/*        partition setting is left unchanged. Screen can be   */
 23542                                  ;/*        exited via the ESC command before active partition   */
 23543                                  ;/*        is changed and no action will take place             */
 23544                                  ;/*                                                             */
 23545                                  ;/*        The following screen is managed                      */
 23546                                  ;/*                                                             */
 23547                                  ;/*     |0000000000111111111122222222223333333333|              */
 23548                                  ;/*     |0123456789012345678901234567890123456789|              */
 23549                                  ;/*   --|----------------------------------------|              */
 23550                                  ;/*   00|                                        |              */
 23551                                  ;/*   01|                                        |              */
 23552                                  ;/*   02|                                        |              */
 23553                                  ;/*   03|                                        |              */
 23554                                  ;/*   04|Change Active Partition                 |              */
 23555                                  ;/*   05|                                        |              */
 23556                                  ;/*   06|Current Fixed Disk Drive: #             |              */
 23557                                  ;/*   07|                                        |              */
 23558                                  ;/*   08|Partition Status   Type  Start  End Size|              */
 23559                                  ;/*   09|    #        #   #######  #### #### ####|              */
 23560                                  ;/*   10|                                        |              */
 23561                                  ;/*   11|                                        |              */
 23562                                  ;/*   12|                                        |              */
 23563                                  ;/*   13|                                        |              */
 23564                                  ;/*   14|Total disk space is #### cylinders.     |              */
 23565                                  ;/*   15|                                        |              */
 23566                                  ;/*   16|                                        |              */
 23567                                  ;/*   17|                                        |              */
 23568                                  ;/*   18|Enter the number of the partition you   |              */
 23569                                  ;/*   19|want to make active...............: [#] |              */
 23570                                  ;/*   20|                                        |              */
 23571                                  ;/*   21|                                        |              */
 23572                                  ;/*   22|                                        |              */
 23573                                  ;/*   23|Press ESC to return to FDISK Options    |              */
 23574                                  ;/*   --------------------------------------------              */
 23575                                  ;/*                                                             */
 23576                                  ;/* ENTRY POINTS: Change_Active_Partition                       */
 23577                                  ;/*      LINKAGE: change_active_partition ()                    */
 23578                                  ;/*           NEAR CALL                                         */
 23579                                  ;/*                                                             */
 23580                                  ;/* INPUT: None                                                 */
 23581                                  ;/*                                                             */
 23582                                  ;/* EXIT-NORMAL: ERROR=FALSE                                    */
 23583                                  ;/*                                                             */
 23584                                  ;/* EXIT-ERROR: ERROR=TRUE                                      */
 23585                                  ;/*             GOTO internal_program_error if invalid num      */
 23586                                  ;/*             input is returned to this level                 */
 23587                                  ;/*                                                             */
 23588                                  ;/* EFFECTS: Display prompts needed to guide user input, and    */
 23589                                  ;/*          gets input from user.                              */
 23590                                  ;/*                                                             */
 23591                                  ;/* INTERNAL REFERENCES:                                        */
 23592                                  ;/*   ROUTINES:                                                 */
 23593                                  ;/*      clear_screen                                           */
 23594                                  ;/*      display                                                */
 23595                                  ;/*      get_num_input                                          */
 23596                                  ;/*      table_display                                          */
 23597                                  ;/*      wait_for_ESC                                           */
 23598                                  ;/*      internal_program_error                                 */
 23599                                  ;/*                                                             */
 23600                                  ;/* EXTERNAL REFERENCES:                                        */
 23601                                  ;/*   ROUTINES:                                                 */
 23602                                  ;/*                                                             */
 23603                                  ;/******************** END OF SPECIFICATIONS ********************/
 23604                                  
 23605                                  ;void change_active_partition()
 23606                                  ;
 23607                                  ;BEGIN
 23608                                  ;
 23609                                  ;    char   input;
 23610                                  ;    unsigned i;
 23611                                  ;    unsigned x;
 23612                                  ;    char   num_partitions;
 23613                                  ;    char   valid_partitions;
 23614                                  ;    char   num_of_bootable_partitions;
 23615                                  ;    char   valid_input;
 23616                                  ;    char   input_default;
 23617                                  ;
 23618                                  ;    input = c(NUL);
 23619                                  ;    /* Clear screen */
 23620                                  ;    clear_screen(u(0),u(0),u(24),u(79));
 23621                                  ;
 23622                                  ;    /* Display header */
 23623                                  ;    display(menu_23);
 23624                                  ;
 23625                                  ;    /* Setup and print current disk */
 23626                                  ;    insert[0] = cur_disk+1+'0';
 23627                                  ;    display(menu_5);
 23628                                  ;
 23629                                  ;    /* Only allow active partitions on the first (and bootable) disk */
 23630                                  ;    if (cur_disk == c(0))
 23631                                  ;
 23632                                  ;       BEGIN
 23633                                  ;	/* Display partition info and see if any partitions exist*/
 23634                                  ;	if (table_display())
 23635                                  ;
 23636                                  ;	   BEGIN
 23637                                  ;	    /* See if active partition is bootable */
 23638                                  ;	    for (i=u(0); i < u(4); i++)
 23639                                  ;	       BEGIN
 23640                                  ;		if (part_table[cur_disk][i].sys_id != uc(0) &&
 23641                                  ;		    part_table[cur_disk][i].boot_ind == uc(0x80))
 23642                                  ;		   BEGIN
 23643                                  ;		    if ((part_table[cur_disk][i].sys_id == uc(BAD_BLOCK)) ||
 23644                                  ;			(part_table[cur_disk][i].sys_id==uc(EXTENDED)))
 23645                                  ;		       BEGIN
 23646                                  ;			/* The active partition is not bootable, so warn user */
 23647                                  ;			display(error_24);
 23648                                  ;		       END
 23649                                  ;		   END
 23650                                  ;	       END
 23651                                  ;
 23652                                  ;	    /* Check to see if only one partition */
 23653                                  ;	    num_partitions = c(0) ;
 23654                                  ;	    num_of_bootable_partitions = c(0);
 23655                                  ;	    for (i=u(0); i < u(4); i++)
 23656                                  ;
 23657                                  ;	       BEGIN
 23658                                  ;		if (part_table[cur_disk][i].sys_id != uc(0))
 23659                                  ;		   BEGIN
 23660                                  ;		    /* Get a count of partitions */
 23661                                  ;		    num_partitions++;
 23662                                  ;
 23663                                  ;		    /* Get a count of the number of defined partitions but don't*/
 23664                                  ;		    /* count those we know aren't bootable */
 23665                                  ;		    if ((part_table[cur_disk][i].sys_id != uc(BAD_BLOCK)) &&
 23666                                  ;			(part_table[cur_disk][i].sys_id != uc(EXTENDED)))
 23667                                  ;		       BEGIN
 23668                                  ;			num_of_bootable_partitions++;
 23669                                  ;		       END
 23670                                  ;		   END
 23671                                  ;	       END
 23672                                  ;	    /* If only one partition found, see if it is active already */
 23673                                  ;	    if (num_of_bootable_partitions == c(1))
 23674                                  ;	       BEGIN
 23675                                  ;
 23676                                  ;		/* Find the partition and see if it is already active */
 23677                                  ;		for (i=u(0); i < u(4); i++)
 23678                                  ;
 23679                                  ;		   BEGIN
 23680                                  ;		    if (part_table[cur_disk][i].sys_id !=uc(0) &&
 23681                                  ;			part_table[cur_disk][i].boot_ind == uc(0x80))
 23682                                  ;
 23683                                  ;		       BEGIN
 23684                                  ;			/* Make sure it is not unbootable partition again*/
 23685                                  ;			if ((part_table[cur_disk][i].sys_id != uc(BAD_BLOCK)) &&
 23686                                  ;			    (part_table[cur_disk][i].sys_id!=uc(EXTENDED)))
 23687                                  ;
 23688                                  ;			   BEGIN
 23689                                  ;			    /* Once it is found, put out the message */
 23690                                  ;			    display(error_15);
 23691                                  ;
 23692                                  ;			    /* Wait for ESC, then get out */
 23693                                  ;			    wait_for_ESC();
 23694                                  ;
 23695                                  ;			    /* clear the screen before going back to main menu*/
 23696                                  ;			    clear_screen(u(0),u(0),u(24),u(79));
 23697                                  ;			    return;
 23698                                  ;			   END
 23699                                  ;		       END
 23700                                  ;		   END
 23701                                  ;	       END
 23702                                  ;	    /* See if any bootable partitions exist */
 23703                                  ;	    if (num_of_bootable_partitions == c(0))
 23704                                  ;	       BEGIN
 23705                                  ;		/* At this point, we know at least one partition does exist due to*/
 23706                                  ;		/* getting past the table_display call, so the only ones around   */
 23707                                  ;		/* must be unbootable  */
 23708                                  ;
 23709                                  ;		/* Display this fact then get out of here */
 23710                                  ;		display(error_25);
 23711                                  ;	       END
 23712                                  ;	    else
 23713                                  ;	       BEGIN
 23714                                  ;		/* All is okay to go and set one, do display prompts */
 23715                                  ;		number_in_msg((XFLOAT)total_mbytes[cur_disk],u(0));
 23716                                  ;		display(menu_15);
 23717                                  ;
 23718                                  ;		/* print ESC prompt */
 23719                                  ;		display(menu_11);
 23720                                  ;
 23721                                  ;		/* Put up input prompt */
 23722                                  ;		display(menu_24);
 23723                                  ;
 23724                                  ;		/* Assume bad input until proven otherwise */
 23725                                  ;		valid_input = FALSE;
 23726                                  ;		valid_partitions = num_partitions;
 23727                                  ;		input_default = c(NUL);
 23728                                  ;
 23729                                  ;		while (!valid_input)
 23730                                  ;		   BEGIN
 23731                                  ;		    /* Go get partition to make active */
 23732                                  ;		    input = get_num_input(input_default,num_partitions,input_row,input_col);
 23733                                  ;
 23734                                  ;		    /* Save the input for next time in case CR pressed */
 23735                                  ;		    input_default = input-'0';
 23736                                  ;
 23737                                  ;		    clear_screen(u(18),u(0),u(23),u(79));
 23738                                  ;
 23739                                  ;		    if (input != c(ESC))
 23740                                  ;		       BEGIN
 23741                                  ;			/* See if known unbootable partition */
 23742                                  ;			/* Set the new one */
 23743                                  ;			valid_partitions = c(0);
 23744                                  ;
 23745                                  ;			/* Make sure the partitions are in physical order */
 23746                                  ;			sort_part_table(c(4));
 23747                                  ;
 23748                                  ;			/* Go find existing partitions */
 23749                                  ;			for (i=u(0);i < u(4); i++)
 23750                                  ;			   BEGIN
 23751                                  ;			    /* First we have to find it */
 23752                                  ;			    if (part_table[cur_disk][sort[i]].sys_id != uc(0))
 23753                                  ;			       BEGIN
 23754                                  ;				/* If this is the 'input'th one, then we got it */
 23755                                  ;				if (valid_partitions == (input-'1'))
 23756                                  ;				   BEGIN
 23757                                  ;				    /* See if it is an unbootable partition */
 23758                                  ;				    if ((part_table[cur_disk][sort[i]].sys_id != uc(BAD_BLOCK)) &&
 23759                                  ;				     (part_table[cur_disk][sort[i]].sys_id !=  uc(EXTENDED)))
 23760                                  ;
 23761                                  ;				       BEGIN
 23762                                  ;					/* Its bootable, so we have good input */
 23763                                  ;					valid_input = c(TRUE);
 23764                                  ;
 23765                                  ;					/* Remove the active indicator from the old partition */
 23766                                  ;					for (x=u(0); x < u(4); x++)
 23767                                  ;					   BEGIN
 23768                                  ;
 23769                                  ;					    if (part_table[cur_disk][x].boot_ind == uc(0x80))
 23770                                  ;					       BEGIN
 23771                                  ;						part_table[cur_disk][x].changed = TRUE;
 23772                                  ;						part_table[cur_disk][x].boot_ind = uc(0);
 23773                                  ;					       END
 23774                                  ;					   END
 23775                                  ;
 23776                                  ;					/* Put in new active indicator */
 23777                                  ;					part_table[cur_disk][sort[i]].boot_ind = uc(0x80);
 23778                                  ;
 23779                                  ;					/* Indicate that it is changed */
 23780                                  ;					part_table[cur_disk][sort[i]].changed = TRUE;
 23781                                  ;
 23782                                  ;					/* Set the reboot flag */
 23783                                  ;					reboot_flag = (FLAG)TRUE;
 23784                                  ;
 23785                                  ;					/* Update the partition info display */
 23786                                  ;					table_display();
 23787                                  ;
 23788                                  ;					/* Clear off the old prompts */
 23789                                  ;					clear_screen(u(16),u(0),u(21),u(79));
 23790                                  ;
 23791                                  ;					/* Say you did it */
 23792                                  ;					insert[0] = input;
 23793                                  ;					display(status_4);
 23794                                  ;					break;
 23795                                  ;				       END
 23796                                  ;				    else
 23797                                  ;				       BEGIN
 23798                                  ;					/* It is, so setup message and tell user */
 23799                                  ;					insert[0] = input;
 23800                                  ;					display(error_17);
 23801                                  ;					break;
 23802                                  ;				       END
 23803                                  ;				   END
 23804                                  ;				else
 23805                                  ;				   BEGIN
 23806                                  ;				    /* Indicate we found one but keep going */
 23807                                  ;				    valid_partitions++;
 23808                                  ;				   END
 23809                                  ;			       END
 23810                                  ;			   END
 23811                                  ;		       END
 23812                                  ;		    else
 23813                                  ;		       BEGIN
 23814                                  ;			/* Mark ESC as ok input so we can get out of here */
 23815                                  ;			valid_input = c(TRUE);
 23816                                  ;		       END
 23817                                  ;		   END /* While loop */
 23818                                  ;	       END
 23819                                  ;	   END /* table display test endif */
 23820                                  ;	else
 23821                                  ;	   BEGIN
 23822                                  ;	    /* No partitions to make active */
 23823                                  ;	    display(error_16);
 23824                                  ;	   END
 23825                                  ;       END
 23826                                  ;    else
 23827                                  ;       BEGIN
 23828                                  ;	display(error_26);
 23829                                  ;       END
 23830                                  ;    /* clear the screen before going back to main menu */
 23831                                  ;    if (input != c(ESC))
 23832                                  ;       BEGIN
 23833                                  ;	wait_for_ESC();
 23834                                  ;       END
 23835                                  ;    clear_screen(u(0),u(0),u(24),u(79));
 23836                                  ;    return;
 23837                                  ;END
 23838                                  
 23839                                  change_active_partition:
 23840                                  		; 19/12/2018
 23841                                  
 23842                                  	%define cap_valid_input		bp-16
 23843                                  	%define cap_num_partitions	bp-14
 23844                                  	%define cap_valid_partitions	bp-12
 23845                                  	%define cap_i			bp-10
 23846                                  	%define cap_x			bp-8
 23847                                  	%define cap_num_boot_partitions bp-6
 23848                                  	%define cap_input_default	bp-4
 23849                                  	%define cap_input		bp-2
 23850                                  
 23851 00003368 55                      		push	bp
 23852 00003369 89E5                    		mov	bp,sp
 23853 0000336B 83EC10                  		sub	sp,16
 23854                                  		
 23855 0000336E C646FE00                		mov	byte [cap_input],0
 23856                                  		
 23857                                  		;/* Clear screen */
 23858                                  
 23859                                  		;mov	ax,79
 23860                                  		;push	ax
 23861                                  		;mov	ax,24
 23862                                  		;push	ax
 23863                                  		;sub	ax,ax
 23864                                  		;push	ax
 23865                                  		;push	ax
 23866                                  		;call	clear_screen
 23867                                  		;add	sp,8
 23868                                  
 23869 00003372 E8E9E0                  		call	CLS
 23870                                  
 23871                                  		;/* Display header */
 23872                                  
 23873                                  		;push	word [menu_23_segment]
 23874 00003375 1E                      		push	ds
 23875 00003376 FF36[219E]              		push	word [menu_23_offset]
 23876 0000337A E89DE2                  		call	display
 23877                                  		;pop	bx
 23878                                  		;pop	bx
 23879                                  
 23880                                  		;/* Setup and print current disk */	
 23881                                  		
 23882                                  		;mov	al,[cur_disk]
 23883                                  		;add	al,'1'
 23884                                  		;mov	[insert],al
 23885                                  		;
 23886                                  		;;push	word [menu_5_segment]
 23887                                  		;push	ds
 23888                                  		;push	word [menu_5_offset]
 23889                                  		;call	display
 23890                                  		;;pop	bx
 23891                                  		;;pop	bx
 23892                                  
 23893 0000337D E8D3FA                  		call	display_menu_5 ; 31/12/2018
 23894                                  
 23895                                  	;/* Only allow active partitions on the first (and bootable) disk */
 23896                                  cap_if1:
 23897 00003380 803E[D4CB]00            		cmp	byte [cur_disk],0
 23898 00003385 7403                    		je	short cap_01_if2
 23899 00003387 E9DA00                  		jmp	cap_29
 23900                                  
 23901                                  	;/* Display partition info and see if any partitions exist*/
 23902                                  cap_01_if2:
 23903 0000338A E8E0FA                  		call	table_display
 23904                                  		;or	al,al
 23905                                  		;jnz	short cap_02_for1
 23906 0000338D 7303                    		jnc	short cap_02_for1
 23907 0000338F E9CB00                  		jmp	cap_28
 23908                                  
 23909                                  		;/* See if active partition is bootable */	
 23910                                  cap_02_for1:
 23911 00003392 C746F60000              		mov	word [cap_i],0
 23912                                  cap_03_for1_next2:
 23913 00003397 A0[D4CB]                		mov	al,[cur_disk]
 23914                                  		;cbw
 23915                                  		;shl	ax,1
 23916                                  		;shl	ax,1
 23917                                  		;add	ax,[cap_i]
 23918 0000339A D0E0                    		shl	al,1
 23919 0000339C D0E0                    		shl	al,1
 23920 0000339E 0246F6                  		add	al,[cap_i]
 23921                                  		;mov	cx,46
 23922                                  		;mul	cx
 23923 000033A1 B12E                    		mov	cl,46
 23924 000033A3 F6E1                    		mul	cl
 23925 000033A5 89C3                    		mov	bx,ax
 23926                                  cap_if3:
 23927 000033A7 80BF[17C4]00            		cmp	byte [part_table_sys_id+bx],0
 23928 000033AC 741D                    		je	short cap_05_for1_next1
 23929 000033AE 80BF[12C4]80            		cmp	byte [part_table_boot_ind+bx],80h ; Active  partition indicator
 23930 000033B3 7516                    		jne	short cap_05_for1_next1
 23931                                  cap_if4:
 23932 000033B5 80BF[17C4]FF            		cmp	byte [part_table_sys_id+bx],0FFh ; (xenix) Bad Block TABLE
 23933 000033BA 7407                    		je	short cap_04
 23934 000033BC 80BF[17C4]05            		cmp	byte [part_table_sys_id+bx],5 ; EXTENDED DOS partition
 23935 000033C1 7508                    		jne	short cap_05_for1_next1
 23936                                  
 23937                                  	;/* The active partition is not bootable, so warn user */	
 23938                                  cap_04:
 23939                                  		;push	word [error_24_seg]
 23940 000033C3 1E                      		push	ds
 23941 000033C4 FF36[A09E]              		push	word [error_24_off]
 23942 000033C8 E84FE2                  		call	display
 23943                                  		;pop	bx
 23944                                  		;pop	bx
 23945                                  cap_05_for1_next1:
 23946 000033CB FE46F6                  		inc	byte [cap_i]
 23947 000033CE 807EF604                		cmp	byte [cap_i],4
 23948 000033D2 72C3                    		jb	short cap_03_for1_next2
 23949                                  
 23950                                  		;/* Check to see if only one partition */
 23951 000033D4 28C0                    		sub	al,al ; 0
 23952 000033D6 8846F2                  		mov	[cap_num_partitions],al	; reset
 23953 000033D9 8846FA                  		mov	[cap_num_boot_partitions],al ; reset
 23954                                  cap_for2:
 23955 000033DC C646F600                		mov	byte [cap_i],0
 23956                                  cap_06_for2_next2:
 23957 000033E0 A0[D4CB]                		mov	al,[cur_disk]
 23958                                  		;cbw
 23959                                  		;shl	ax,1
 23960                                  		;shl	ax,1
 23961                                  		;add	ax,[cap_i]
 23962                                  		;mov	cx,46
 23963                                  		;mul	cx
 23964 000033E3 D0E0                    		shl	al,1
 23965 000033E5 D0E0                    		shl	al,1
 23966 000033E7 0246F6                  		add	al,[cap_i]
 23967 000033EA B12E                    		mov	cl,46
 23968 000033EC F6E1                    		mul	cl
 23969 000033EE 89C3                    		mov	bx,ax
 23970                                  cap_if5:
 23971 000033F0 80BF[17C4]00            		cmp	byte [part_table_sys_id+bx],0 ; Partition ID (0 = Empty)	
 23972 000033F5 7414                    		je	short cap_07_for2_next1
 23973                                  
 23974                                  		;/* Get a count of partitions */
 23975 000033F7 FE46F2                  		inc	byte [cap_num_partitions]  ; number of partitions (in PT)
 23976                                  cap_if6:
 23977                                  	;/* Get a count of the number of defined partitions but don't*/
 23978                                  	;/* count those we know aren't bootable */
 23979 000033FA 80BF[17C4]FF            		cmp	byte [part_table_sys_id+bx],0FFh ; (xenix) Bad Block TABLE
 23980 000033FF 740A                    		je	short cap_07_for2_next1
 23981 00003401 80BF[17C4]05            		cmp	byte [part_table_sys_id+bx],5  ; EXTENDED DOS partition
 23982 00003406 7403                    		je	short cap_07_for2_next1
 23983 00003408 FE46FA                  		inc	byte [cap_num_boot_partitions] ; num of bootable partitions
 23984                                  cap_07_for2_next1:
 23985 0000340B FE46F6                  		inc	byte [cap_i]
 23986 0000340E 807EF604                		cmp	byte [cap_i],4
 23987 00003412 72CC                    		jb	short cap_06_for2_next2
 23988                                  
 23989                                  	;/* If only one partition found, see if it is active already *
 23990                                  cap_if7:
 23991 00003414 807EFA01                		cmp	byte [cap_num_boot_partitions],1
 23992 00003418 7562                    		jne	short cap_12_if10
 23993                                  
 23994                                  	;/* Find the partition and see if it is already active */
 23995                                  cap_for3:
 23996 0000341A C646F600                		mov	byte [cap_i],0
 23997 0000341E EB09                    		jmp	short cap_09_for3_next1
 23998                                  cap_08_for3_next2:
 23999 00003420 FE46F6                  		inc	byte [cap_i]
 24000                                  ;cap_09_for3_next1:
 24001 00003423 807EF604                		cmp	byte [cap_i],4
 24002 00003427 7353                    		jnb	short cap_12_if10
 24003                                  cap_09_for3_next1:
 24004 00003429 A0[D4CB]                		mov	al,[cur_disk]
 24005                                  		;cbw
 24006                                  		;shl	ax,1
 24007                                  		;shl	ax,1
 24008                                  		;add	ax,[cap_i]
 24009                                  		;mul	cx
 24010 0000342C D0E0                    		shl	al,1
 24011 0000342E D0E0                    		shl	al,1
 24012 00003430 0246F6                  		add	al,[cap_i]
 24013 00003433 F6E1                    		mul	cl	
 24014 00003435 89C3                    		mov	bx,ax
 24015                                  cap_if8:
 24016 00003437 80BF[17C4]00            		cmp	byte [part_table_sys_id+bx],0 ; empty pt entry
 24017 0000343C 74E2                    		je	short cap_08_for3_next2
 24018 0000343E 80BF[12C4]80            		cmp	byte [part_table_boot_ind+bx],80h ; Active partition
 24019 00003443 75DB                    		jne	short cap_08_for3_next2
 24020                                  
 24021                                  	;/* Make sure it is not unbootable partition again*/
 24022                                  cap_if9:
 24023 00003445 80BF[17C4]FF            		cmp	byte [part_table_sys_id+bx],0FFh ; (xenix) Bad Block TABLE
 24024 0000344A 74D4                    		je	short cap_08_for3_next2
 24025 0000344C 80BF[17C4]05            		cmp	byte [part_table_sys_id+bx],5  ; EXTENDED DOS partition	
 24026 00003451 74CD                    		je	short cap_08_for3_next2
 24027                                  
 24028                                  		;/* Once it is found, put out the message */	
 24029                                  
 24030                                  		;push	word [error_15_seg]
 24031 00003453 1E                      		push	ds
 24032 00003454 FF36[909E]              		push	word [error_15_off]
 24033 00003458 E8BFE1                  		call	display
 24034                                  		;pop	bx
 24035                                  		;pop	bx
 24036                                  
 24037 0000345B EB15                    		jmp	short cap_10 ; 19/12/2018
 24038                                  
 24039                                  		;/* No partitions to make active */
 24040                                  cap_28:
 24041                                  		;push	word [error_16_seg]
 24042 0000345D 1E                      		push	ds
 24043 0000345E FF36[929E]              		push	word [error_16_off]
 24044 00003462 EB05                    		jmp	short cap_30
 24045                                  cap_29:
 24046                                  		;push	word [error_26_seg]
 24047 00003464 1E                      		push	ds
 24048 00003465 FF36[A49E]              		push	word [error_26_off]
 24049                                  cap_30:
 24050 00003469 E8AEE1                  		call	display
 24051                                  		;pop	bx
 24052                                  		;pop	bx
 24053                                  
 24054                                  		;jmp	cap_31 ; 19/12/2018
 24055                                  
 24056                                  		;/* clear the screen before going back to main menu */
 24057                                  cap_31:
 24058 0000346C 807EFE1B                		cmp	byte [cap_input],1Bh  ; ESC key
 24059                                  		;jne	short cap_32
 24060                                  		;jmp	cap_11
 24061 00003470 7403                    		je	short cap_11
 24062                                  ;cap_32:
 24063                                  		;jmp	cap_10
 24064                                  
 24065                                  		;/* Wait for ESC, then get out */
 24066                                  cap_10:
 24067 00003472 E8F5FC                  		call	wait_for_ESC
 24068                                  
 24069                                  	 ;/* clear the screen before going back to main menu*/
 24070                                  cap_11:
 24071                                  		;mov	ax,79
 24072                                  		;push	ax
 24073                                  		;mov	ax,24
 24074                                  		;push	ax
 24075                                  		;sub	ax,ax
 24076                                  		;push	ax
 24077                                  		;push	ax
 24078                                  		;call	clear_screen
 24079                                  		;add	sp,8
 24080                                  
 24081 00003475 E8E6DF                  		call	CLS
 24082                                  
 24083                                  		;jmp	cap_33
 24084                                  cap_33:
 24085 00003478 89EC                    		mov	sp,bp
 24086 0000347A 5D                      		pop	bp
 24087 0000347B C3                      		retn
 24088                                  
 24089                                  	;/* See if any bootable partitions exist */
 24090                                  cap_12_if10:
 24091 0000347C 807EFA00                		cmp	byte [cap_num_boot_partitions],0
 24092 00003480 7507                    		jne	short cap_13_if10_else
 24093                                  
 24094                                  	;/* At this point, we know at least one partition does exist due to*/
 24095                                  	;/* getting past the table_display call, so the only ones around   */
 24096                                  	;/* must be unbootable  */
 24097                                  cap_12:
 24098                                  		;/* Display this fact then get out of here */
 24099                                  
 24100                                  		;push	word [error_25_seg]
 24101 00003482 1E                      		push	ds
 24102 00003483 FF36[A29E]              		push	word [error_25_off]
 24103 00003487 EBE0                    		jmp	cap_30
 24104                                  
 24105                                  	;/* All is okay to go and set one, do display prompts */	
 24106                                  cap_13_if10_else:
 24107 00003489 29C0                    		sub	ax,ax
 24108 0000348B 50                      		push	ax
 24109 0000348C A0[D4CB]                		mov	al,[cur_disk]
 24110                                  		;cbw
 24111 0000348F 89C3                    		mov	bx,ax
 24112                                  		;shl	bx,1
 24113 00003491 D0E3                    		shl	bl,1
 24114 00003493 FFB7[C8A0]              		push	word [total_mbytes+bx]
 24115 00003497 E857FB                  		call	number_in_msg
 24116                                  		;pop	bx
 24117                                  		;pop	bx
 24118                                  
 24119                                  		;push	word [menu_15_segment]
 24120 0000349A 1E                      		push	ds
 24121 0000349B FF36[059E]              		push	word [menu_15_offset]
 24122 0000349F E878E1                  		call	display
 24123                                  		;pop	bx
 24124                                  		;pop	bx
 24125                                  
 24126                                  		;/* print ESC prompt */
 24127                                  
 24128                                  		;;push	word [menu_11_segment]
 24129                                  		;push	ds
 24130                                  		;push	word [menu_11_offset]
 24131                                  		;call	display
 24132                                  		;;pop	bx
 24133                                  		;;pop	bx
 24134                                  
 24135 000034A2 E8BFF9                  		call	display_menu_11 ; 31/12/2018
 24136                                  
 24137                                  		;/* Put up input prompt */
 24138                                  
 24139                                  		;push	word [menu_24_segment]
 24140 000034A5 1E                      		push	ds
 24141 000034A6 FF36[239E]              		push	word [menu_24_offset]
 24142 000034AA E86DE1                  		call	display
 24143                                  		;pop	bx
 24144                                  		;pop	bx
 24145                                  
 24146                                  		;/* Assume bad input until proven otherwise */
 24147                                  
 24148 000034AD 8A46F2                  		mov	al,[cap_num_partitions]
 24149 000034B0 8846F4                  		mov	[cap_valid_partitions],al
 24150 000034B3 28C0                    		sub	al,al ; 0
 24151 000034B5 8846F0                  		mov	[cap_valid_input],al
 24152 000034B8 8846FC                  		mov	[cap_input_default],al
 24153                                  		;jmp	cap_26_while
 24154                                  
 24155                                  cap_26_while:
 24156 000034BB 807EF000                		cmp	byte [cap_valid_input],0 ; FALSE ?
 24157                                  		;;jne	short cap_27
 24158                                  		;jne	short cap_31
 24159                                  		;jmp	cap_14
 24160 000034BF 75AB                    		jne	short cap_31
 24161                                  
 24162                                  		;/* Go get partition to make active */
 24163                                  cap_14:
 24164 000034C1 FF36[9CA0]              		push	word [input_col]
 24165 000034C5 FF36[3EA1]              		push	word [input_row]
 24166 000034C9 8A46F2                  		mov	al,[cap_num_partitions]
 24167 000034CC 50                      		push	ax
 24168 000034CD 8A46FC                  		mov	al,[cap_input_default]
 24169 000034D0 50                      		push	ax
 24170 000034D1 E896F5                  		call	get_num_input
 24171                                  		;add	sp,8
 24172 000034D4 8846FE                  		mov	[cap_input],al
 24173                                  
 24174                                  	;/* Save the input for next time in case CR pressed */
 24175                                  
 24176 000034D7 2C30                    		sub	al,'0'
 24177 000034D9 8846FC                  		mov	[cap_input_default],al
 24178                                  
 24179 000034DC B84F00                  		mov	ax,79
 24180 000034DF 50                      		push	ax
 24181 000034E0 B81700                  		mov	ax,23
 24182 000034E3 50                      		push	ax
 24183 000034E4 29C0                    		sub	ax,ax
 24184 000034E6 50                      		push	ax
 24185 000034E7 B91200                  		mov	cx,18
 24186 000034EA 51                      		push	cx
 24187 000034EB E8A8DF                  		call	clear_screen
 24188                                  		;add	sp,8
 24189                                  cap_if11:
 24190 000034EE 807EFE1B                		cmp	byte [cap_input],1Bh ; ESC key
 24191 000034F2 7503                    		jne	short cap_15
 24192 000034F4 E9DD00                  		jmp	cap_25_if11_else
 24193                                  
 24194                                  		;/* See if known unbootable partition */
 24195                                  		;/* Set the new one */
 24196                                  cap_15:
 24197 000034F7 C646F400                		mov	byte [cap_valid_partitions],0
 24198                                  
 24199                                  		;/* Make sure the partitions are in physical order */
 24200                                  
 24201                                  		;mov	al,4
 24202                                  		;push	ax
 24203 000034FB B104                    		mov	cl,4
 24204 000034FD E89BF4                  		call	sort_part_table
 24205                                  		;pop	bx
 24206                                  
 24207                                  		;/* Go find existing partitions */
 24208                                  cap_15_for4:
 24209 00003500 C646F600                		mov	byte [cap_i],0
 24210                                  		;jmp	short cap_20_for4_next1
 24211 00003504 EB1E                    		jmp	short cap_21_for4_next2
 24212                                  
 24213                                  		;/* It is, so setup message and tell user */
 24214                                  cap_16_if14_else:
 24215 00003506 8A46FE                  		mov	al,[cap_input]
 24216 00003509 A2[E6CC]                		mov	[insert],al
 24217                                  		;push	word [error_17_seg]
 24218 0000350C 1E                      		push	ds
 24219 0000350D FF36[949E]              		push	word [error_17_off]
 24220                                  cap_17:
 24221 00003511 E806E1                  		call	display
 24222                                  		;pop	bx
 24223                                  		;pop	bx
 24224 00003514 EBA5                    		jmp	short cap_26_while  ; /* While loop */
 24225                                  
 24226                                  		;/* Indicate we found one but keep going */
 24227                                  cap_18:
 24228 00003516 FE46F4                  		inc	byte [cap_valid_partitions]
 24229                                  cap_19:
 24230 00003519 FE46F6                  		inc	byte [cap_i]
 24231                                  cap_20_for4_next1:
 24232 0000351C 807EF604                		cmp	byte [cap_i],4
 24233 00003520 7202                    		jb	short cap_21_for4_next2
 24234 00003522 EB97                    		jmp	short cap_26_while  ; /* While loop */
 24235                                  cap_21_for4_next2:
 24236 00003524 A0[D4CB]                		mov	al,[cur_disk]
 24237                                  		;cbw
 24238                                  		;shl	ax,1
 24239                                  		;shl	ax,1
 24240 00003527 D0E0                    		shl	al,1
 24241 00003529 D0E0                    		shl	al,1
 24242 0000352B 8B5EF6                  		mov	bx,[cap_i]
 24243                                  		;mov	cx,ax
 24244                                  		;mov	al,[sort+bx]
 24245                                  		;cbw
 24246                                  		;add	ax,cx
 24247 0000352E 8A8F[E2C3]              		mov	cl,[sort+bx]
 24248 00003532 00C8                    		add	al,cl
 24249                                  		;mov	cx,46
 24250                                  		;imul	cx
 24251 00003534 B12E                    		mov	cl,46
 24252 00003536 F6E1                    		mul	cl
 24253 00003538 89C3                    		mov	bx,ax
 24254                                  
 24255                                  		;/* First we have to find it */	
 24256                                  cap_if12:
 24257 0000353A 80BF[17C4]00            		cmp	byte [part_table_sys_id+bx],0  ; Partition ID (0 = empty)
 24258 0000353F 74D8                    		je	short cap_19
 24259                                  
 24260                                  		;/* If this is the 'input'th one, then we got it */
 24261                                  cap_if13:
 24262                                  		;mov	al,[cap_valid_partitions]
 24263                                  		;cbw
 24264                                  		;mov	cx,ax
 24265 00003541 8A4EF4                  		mov	cl,[cap_valid_partitions]
 24266 00003544 8A46FE                  		mov	al,[cap_input]
 24267                                  		;cbw
 24268                                  		;sub	ax,cx
 24269 00003547 28C8                    		sub	al,cl
 24270                                  		;cmp	ax,'1'
 24271 00003549 3C31                    		cmp	al,'1'
 24272 0000354B 75C9                    		jne	short cap_18
 24273                                  
 24274                                  		;/* See if it is an unbootable partition */
 24275                                  cap_if14:
 24276 0000354D 80BF[17C4]FF            		cmp	byte [part_table_sys_id+bx],0FFh ; (xenix) Bad Block TABLE
 24277 00003552 74B2                    		je	short cap_16_if14_else
 24278 00003554 80BF[17C4]05            		cmp	byte [part_table_sys_id+bx],5  ; EXTENDED DOS partition	
 24279 00003559 74AB                    		je	short cap_16_if14_else
 24280                                  
 24281                                  		;/* Its bootable, so we have good input */
 24282                                  		
 24283 0000355B C646F001                		mov	byte [cap_valid_input],1 ; TRUE
 24284                                  
 24285                                  	;/* Remove the active indicator from the old partition */
 24286                                  cap_for5:
 24287 0000355F C646F800                		mov	byte [cap_x],0
 24288                                  cap_22_for5_next2:
 24289 00003563 A0[D4CB]                		mov	al,[cur_disk]
 24290                                  		;cbw
 24291                                  		;shl	ax,1
 24292                                  		;shl	ax,1
 24293 00003566 D0E0                    		shl	al,1
 24294 00003568 D0E0                    		shl	al,1
 24295                                  		;add	ax,[cap_x]
 24296 0000356A 0246F8                  		add	al,[cap_x]
 24297                                  		;mov	cx,46
 24298                                  		;mul	cx
 24299 0000356D B12E                    		mov	cl,46
 24300 0000356F F6E1                    		mul	cl
 24301 00003571 89C3                    		mov	bx,ax
 24302                                  cap_if15:
 24303 00003573 80BF[12C4]80            		cmp	byte [part_table_boot_ind+bx],80h ; Active partition indicator
 24304 00003578 750A                    		jne	short cap_24_for5_next1
 24305 0000357A C687[25C4]01            		mov	byte [part_table_changed+bx],1  ; Partion table changed flag
 24306 0000357F C687[12C4]00            		mov	byte [part_table_boot_ind+bx],0 ; non-active partition
 24307                                  cap_24_for5_next1:
 24308 00003584 FE46F8                  		inc	byte [cap_x]
 24309 00003587 807EF804                		cmp	byte [cap_x],4
 24310 0000358B 72D6                    		jb	short cap_22_for5_next2
 24311                                  		
 24312                                  		;/* Put in new active indicator */
 24313                                  
 24314 0000358D A0[D4CB]                		mov	al,[cur_disk]
 24315                                  		;cbw
 24316                                  		;shl	ax,1
 24317                                  		;shl	ax,1
 24318 00003590 D0E0                    		shl	al,1
 24319 00003592 D0E0                    		shl	al,1
 24320 00003594 8B5EF6                  		mov	bx,[cap_i]
 24321                                  		;mov	cx,ax
 24322                                  		;mov	al,[sort+bx]
 24323                                  		;cbw
 24324                                  		;add	ax,cx
 24325 00003597 8A8F[E2C3]              		mov	cl,[sort+bx]
 24326 0000359B 00C8                    		add	al,cl
 24327                                  		;mov	cx,46
 24328                                  		;imul	cx
 24329 0000359D B12E                    		mov	cl,46
 24330 0000359F F6E1                    		mul	cl
 24331 000035A1 89C3                    		mov	bx,ax
 24332 000035A3 C687[12C4]80            		mov	byte [part_table_boot_ind+bx],80h  ; Set as Active partition
 24333                                  		
 24334                                  		;/* Indicate that it is changed */
 24335                                  
 24336 000035A8 B001                    		mov	al,1
 24337 000035AA 8887[25C4]              		mov	[part_table_changed+bx],al ;  TRUE
 24338                                  
 24339                                  		;/* Set the reboot flag */
 24340                                  
 24341 000035AE A2[6AA0]                		mov	[reboot_flag],al ; TRUE
 24342                                  
 24343                                  		;/* Update the partition info display */
 24344                                  
 24345 000035B1 E8B9F8                  		call	table_display
 24346                                  
 24347                                  		;/* Clear off the old prompts */
 24348                                  
 24349 000035B4 B84F00                  		mov	ax,79
 24350 000035B7 50                      		push	ax
 24351 000035B8 B81500                  		mov	ax,21
 24352 000035BB 50                      		push	ax
 24353 000035BC 29C0                    		sub	ax,ax
 24354 000035BE 50                      		push	ax
 24355 000035BF B81000                  		mov	ax,16
 24356 000035C2 50                      		push	ax
 24357 000035C3 E8D0DE                  		call	clear_screen
 24358                                  		;add	sp,8
 24359                                  
 24360                                  		;/* Say you did it */
 24361                                  
 24362 000035C6 8A46FE                  		mov	al,[cap_input]
 24363 000035C9 A2[E6CC]                		mov	[insert],al
 24364                                  		;push	word [status_4_seg]
 24365 000035CC 1E                      		push	ds
 24366 000035CD FF36[639E]              		push	word [status_4_off]
 24367                                  
 24368 000035D1 E93DFF                  		jmp	cap_17
 24369                                  
 24370                                  	;/* Mark ESC as ok input so we can get out of here */
 24371                                  cap_25_if11_else:
 24372 000035D4 C646F001                		mov	byte [cap_valid_input],1 ; TRUE
 24373 000035D8 E99AFE                  		jmp	cap_11 ; 19/12/2018
 24374                                  
 24375                                  ;cap_26_while:
 24376                                  ;		cmp	byte [cap_valid_input],0 ; FALSE ?
 24377                                  ;		;jne	short cap_27
 24378                                  ;		jne	short cap_31
 24379                                  ;		jmp	cap_14
 24380                                  ;cap_27:
 24381                                  		;jmp	short cap_31
 24382                                  
 24383                                  ;		;/* No partitions to make active */
 24384                                  ;cap_28:
 24385                                  ;		;push	word [error_16_seg]
 24386                                  ;		push	ds
 24387                                  ;		push	word [error_16_off]
 24388                                  ;		jmp	short cap_30
 24389                                  ;cap_29:
 24390                                  ;		;push	word [error_26_seg]
 24391                                  ;		push	ds
 24392                                  ;		push	word [error_26_off]
 24393                                  ;cap_30:
 24394                                  ;		call	display
 24395                                  ;		;pop	bx
 24396                                  ;		;pop	bx
 24397                                  ;
 24398                                  ;		jmp	cap_31 ; 19/12/2018
 24399                                  
 24400                                  ;		;/* clear the screen before going back to main menu */
 24401                                  ;cap_31:
 24402                                  ;		cmp	byte [cap_input],1Bh  ; ESC key
 24403                                  ;		;jne	short cap_32
 24404                                  ;		;jmp	cap_11
 24405                                  ;		je	cap_11
 24406                                  ;cap_32:
 24407                                  ;		jmp	cap_10
 24408                                  ;cap_33:
 24409                                  ;		mov	sp,bp
 24410                                  ;		pop	bp
 24411                                  ;		retn
 24412                                  
 24413                                  ; ----------------------------------------------------------------------------
 24414                                  ; fdisk.c (FDISK, MSDOS 6.0, 1991)	
 24415                                  ; ----------------------------------------------------------------------------
 24416                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 19/12/2018)
 24417                                  
 24418                                  ;/*  */
 24419                                  ;void reboot_system()
 24420                                  ;BEGIN
 24421                                  ;
 24422                                  ;    char far *boot_drive;
 24423                                  ;    char     boot_letter;
 24424                                  ;    char     i,j;
 24425                                  ;    FLAG     boot_changed;
 24426                                  ;
 24427                                  ;    clear_screen(u(0),u(0),u(24),u(79));
 24428                                  ;    if (quiet_flag == FALSE)
 24429                                  ;	BEGIN
 24430                                  ;	regs.h.ah = 0x52;
 24431                                  ;	intdosx(&regs,&regs,&segregs);
 24432                                  ;	FP_SEG(boot_drive) = segregs.es;
 24433                                  ;	FP_OFF(boot_drive) = regs.x.bx + u(0x43);
 24434                                  ;	boot_letter = *boot_drive + c(0x40);
 24435                                  ;	if (boot_letter != 'A')
 24436                                  ;	    {
 24437                                  ;	    boot_changed = TRUE;
 24438                                  ;	    for (i=0; i<number_of_drives; i++)
 24439                                  ;		for (j=0; j<4; j++)
 24440                                  ;		    if (part_table[i][j].drive_letter == boot_letter)
 24441                                  ;			boot_changed = part_table[i][j].changed;
 24442                                  ;	    if (boot_changed == FALSE)
 24443                                  ;		display(menu_60);
 24444                                  ;	    else
 24445                                  ;		display(menu_38);
 24446                                  ;	    } 
 24447                                  ;	else/
 24448                                  ;	    display(menu_38);
 24449                                  ;	getch();
 24450                                  ;	reboot();
 24451                                  ;	END
 24452                                  ;   else
 24453                                  ;	BEGIN
 24454                                  ;	cur_disk = c(0);
 24455                                  ;	reset_video_information();
 24456                                  ;	if ( (find_partition_type(uc(DOS12))) ||
 24457                                  ;	     (find_partition_type(uc(DOS16))) ||
 24458                                  ;	     (find_partition_type(uc(DOSNEW))) )
 24459                                  ;	    exit(ERR_LEVEL_0);
 24460                                  ;	else
 24461                                  ;	    exit(ERR_LEVEL_1);
 24462                                  ;	END
 24463                                  ;END
 24464                                  
 24465                                  reboot_system:
 24466                                  		; 19/12/2018
 24467                                  
 24468                                  	%define r_boot_drive	bp-12 ; far ptr, dword
 24469                                  	%define r_boot_changed	bp-8  ; flag, byte
 24470                                  	%define r_i		bp-6  ; char, byte	
 24471                                  	%define r_j		bp-4  ; char, byte
 24472                                  	%define r_boot_letter	bp-2  ; char, byte 
 24473                                  
 24474                                  		;push	bp
 24475 000035DB 89E5                    		mov	bp,sp
 24476 000035DD 83EC0C                  		sub	sp,12
 24477                                  
 24478 000035E0 B84F00                  		mov	ax,79
 24479 000035E3 50                      		push	ax
 24480 000035E4 B81800                  		mov	ax,24
 24481 000035E7 50                      		push	ax
 24482 000035E8 29C0                    		sub	ax,ax
 24483 000035EA 50                      		push	ax
 24484 000035EB 50                      		push	ax
 24485 000035EC E8A7DE                  		call	clear_screen
 24486 000035EF 83C408                  		add	sp,8
 24487 000035F2 803E[40A1]00            		cmp	byte [quiet_flag],0
 24488 000035F7 7402                    		je	short rebootsys_0
 24489 000035F9 EB75                    		jmp	rebootsys_8
 24490                                  rebootsys_0:
 24491                                  		;Get Pointer to DOS SYSVARS
 24492 000035FB 06                      		push	es
 24493 000035FC B452                    		mov	ah,52h
 24494 000035FE CD21                    		int	21h
 24495                                  			; ES:BX = pointer to DOS "sysvars", 
 24496                                  			;	  a table of pointers used by DOS
 24497 00003600 268A07                  		mov	al,[es:bx]
 24498 00003603 07                      		pop	es
 24499 00003604 0440                    		add	al,40h
 24500 00003606 8846FE                  		mov	[r_boot_letter],al
 24501 00003609 3C41                    		cmp	al,'A'
 24502 0000360B 7456                    		je	short rebootsys_6
 24503 0000360D C646F801                		mov	byte [r_boot_changed],1
 24504 00003611 C646FC00                		mov	byte [r_j],0
 24505 00003615 EB2E                    		jmp	short rebootsys_4
 24506                                  rebootsys_1:
 24507 00003617 FE46FA                  		inc	byte [r_i]
 24508                                  rebootsys_2:
 24509 0000361A 807EFA04                		cmp	byte [r_i],4
 24510 0000361E 7D22                    		jge	short rebootsys_3
 24511 00003620 8A46FC                  		mov	al,[r_j]
 24512                                  		;cbw
 24513                                  		;shl	ax,1
 24514                                  		;shl	ax,1
 24515 00003623 D0E0                    		shl	al,1
 24516 00003625 D0E0                    		shl	al,1
 24517                                  		;mov	cx,ax
 24518                                  		;mov	al,[r_i]
 24519                                  		;cbw
 24520                                  		;add	ax,cx
 24521 00003627 0246FA                  		add	al,[r_i]
 24522                                  		;mov	cx,46
 24523                                  		;imul	cx
 24524 0000362A B12E                    		mov	cl,46
 24525 0000362C F6E1                    		mul	cl
 24526 0000362E 89C3                    		mov	bx,ax
 24527 00003630 8A46FE                  		mov	al,[r_boot_letter]
 24528 00003633 3887[3FC4]              		cmp	byte [part_table_drive_letter+bx],al
 24529 00003637 75DE                    		jne	short rebootsys_1
 24530 00003639 8A87[25C4]              		mov	al,[part_table_changed+bx]
 24531 0000363D 8846F8                  		mov	[r_boot_changed],al
 24532 00003640 EBD5                    		jmp	short rebootsys_1
 24533                                  rebootsys_3:
 24534 00003642 FE46FC                  		inc	byte [r_j]
 24535                                  rebootsys_4:
 24536 00003645 8A46FC                  		mov	al,[r_j]
 24537                                  		;cbw
 24538 00003648 8A0E[D5C3]              		mov	cl,[number_of_drives]
 24539                                  		;sub	ch,ch
 24540                                  		;cmp	ax,cx
 24541 0000364C 38C8                    		cmp	al,cl
 24542 0000364E 7D06                    		jge	short rebootsys_5
 24543                                  		;mov	[r_i],ch
 24544 00003650 C646FA00                		mov	byte [r_i],0
 24545 00003654 EBC4                    		jmp	short rebootsys_2
 24546                                  rebootsys_5:
 24547 00003656 807EF800                		cmp	byte [r_boot_changed],0
 24548 0000365A 7507                    		jne	short rebootsys_6
 24549                                  		;push	word [menu_60_segment]
 24550 0000365C 1E                      		push	ds
 24551 0000365D FF36[5B9E]              		push	word [menu_60_offset]
 24552 00003661 EB05                    		jmp	short rebootsys_7
 24553                                  rebootsys_6:
 24554                                  		;push	word [menu_38_segment]
 24555 00003663 1E                      		push	ds
 24556 00003664 FF36[599E]              		push	word [menu_38_offset]
 24557                                  rebootsys_7:
 24558 00003668 E8AFDF                  		call	display
 24559                                  		;pop	bx
 24560                                  		;pop	bx
 24561 0000366B E82900                  		call	getch
 24562                                  		;call	reboot
 24563                                  		;jmp	short rebootsys_12
 24564                                  		; 19/12/2018
 24565                                  		;mov	sp,bp
 24566                                  		;pop	bp
 24567 0000366E EB2C                    		jmp	short reboot
 24568                                  rebootsys_8:
 24569 00003670 C606[D4CB]00            		mov	byte [cur_disk],0
 24570 00003675 E8C9DD                  		call	reset_video_information
 24571 00003678 B001                    		mov	al,1
 24572                                  		;push	ax
 24573 0000367A E83DE7                  		call	find_partition_type
 24574                                  		;pop	bx
 24575                                  		;or	al,al
 24576                                  		;jnz	short rebootsys_9
 24577 0000367D 730E                    		jnc	short rebootsys_9
 24578 0000367F B004                    		mov	al,4
 24579                                  		;push	ax
 24580 00003681 E836E7                  		call	find_partition_type
 24581                                  		;pop	bx
 24582                                  		;or	al,al
 24583                                  		;jnz	short rebootsys_9
 24584 00003684 7307                    		jnc	short rebootsys_9
 24585 00003686 B006                    		mov	al,6
 24586                                  		;push	ax
 24587 00003688 E82FE7                  		call	find_partition_type
 24588                                  		;pop	bx
 24589                                  		;or	al,al
 24590                                  		;jz	short rebootsys_10
 24591 0000368B 7204                    		jc	short rebootsys_10
 24592                                  rebootsys_9:
 24593 0000368D 29C0                    		sub	ax,ax
 24594 0000368F EB03                    		jmp	short rebootsys_11
 24595                                  rebootsys_10:
 24596 00003691 B80100                  		mov	ax,1
 24597                                  rebootsys_11:
 24598                                  		;push	ax
 24599                                  		;call	_exit
 24600                                  		;pop	bx
 24601 00003694 E9D1C9                  		jmp	_exit
 24602                                  ;rebootsys_12:
 24603                                  ;		mov	sp,bp
 24604                                  ;		pop	bp
 24605                                  ;		retn
 24606                                  
 24607                                  ; getch
 24608                                  ; ----------------------------------------------------------------------------
 24609                                  ; 19/12/2018
 24610                                  
 24611                                  getch:
 24612 00003697 30E4                    		xor	ah,ah
 24613 00003699 CD16                    		int	16h
 24614 0000369B C3                      		retn
 24615                                  
 24616                                  ; reboot (MSDOS 6.0, reboot.asm)
 24617                                  ; ----------------------------------------------------------------------------
 24618                                  ; IBM PC-DOS FDISK.COM (unpacked) /// Segment 0, Offset 2E0Ah [ 19/12/2018 ]
 24619                                  
 24620                                  reboot:
 24621 0000369C B84000                  		mov	ax,40h ; BIOS DATA segment
 24622 0000369F 8ED8                    		mov	ds,ax
 24623 000036A1 C70672003412            		mov	word [72h],1234h ; mov word [WarmBootFlag],WARM_BOOT_CODE
 24624 000036A7 B81535                  		mov	ax,3515h
 24625 000036AA CD21                    		int	21h	; DOS -	2+ - GET INTERRUPT VECTOR
 24626                                  				; AL = interrupt number
 24627                                  				; Return: ES:BX	= value	of interrupt vector
 24628 000036AC 8CC0                    		mov	ax,es
 24629 000036AE 09D8                    		or	ax,bx
 24630 000036B0 740A                    		jz	short reboot_0
 24631                                  
 24632                                  		;mov	ax,40h
 24633                                  		;mov	ds,ax
 24634                                  
 24635 000036B2 C60617000C              		mov	byte [17h],0Ch ; mov byte [KB_FLAG],ALT_SHIFT|SHIFT
 24636 000036B7 B8534F                  		mov	ax,4F53h ; (KB_INTERCEPT SHL 8) OR DEL_KEY
 24637 000036BA CD15                    		int	15h	; OS HOOK - KEYBOARD INTERCEPT
 24638                                  				;	 (AT model 3x9,XT2,XT286,CONV,PS)
 24639                                  				; AL = scan code, CF set
 24640                                  				; Return: CF set - AL =	scan code
 24641                                  				; CF clear - scan code should be ignored
 24642                                  
 24643                                  reboot_0:	; Jump to the processor power-on address FFFF:0000h
 24644 000036BC EA0000FFFF              		jmp	0FFFFh:0
 24645                                  
 24646                                  ; ----------------------------------------------------------------------------
 24647                                  ; diskout.c (FDISK, MSDOS 6.0, 1991)	
 24648                                  ; ----------------------------------------------------------------------------
 24649                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 20/12/2018)
 24650                                  
 24651                                  ;/*  */
 24652                                  ;void write_info_to_disk()
 24653                                  ;
 24654                                  ;BEGIN
 24655                                  ;
 24656                                  ;    char     i;
 24657                                  ;    unsigned char j;
 24658                                  ;    unsigned extended_location;
 24659                                  ;    char     extended_index;
 24660                                  ;    char     temp;
 24661                                  ;    char     changed_flag;
 24662                                  ;    char     temp_disk;
 24663                                  ;
 24664                                  ;    /* Change invalid value for temp to 0xff. NUL is a valid value for
 24665                                  ;       the index and cannot be used */
 24666                                  ;
 24667                                  ;    temp = 0xff;
 24668                                  ;    temp_disk = cur_disk;
 24669                                  ;    /* See if need to update the master boot record */
 24670                                  ;    for (j = uc(0); j < number_of_drives; j++)
 24671                                  ;       BEGIN
 24672                                  ;
 24673                                  ;        /* Save disk number */
 24674                                  ;        cur_disk = ((char)(j));
 24675                                  ;
 24676                                  ;        /* See if there were any errors on that drive */
 24677                                  ;        if (good_disk[j])
 24678                                  ;           BEGIN
 24679                                  ;            for (i=c(0); i < c(4); i++)
 24680                                  ;               BEGIN
 24681                                  ;                if (part_table[j][i].changed)
 24682                                  ;                   BEGIN
 24683                                  ;                    write_master_boot_to_disk(j);
 24684                                  ;                    break;
 24685                                  ;                   END
 24686                                  ;               END
 24687                                  ;            /* See if the extended partition exists - if not, don't fool with the logical */
 24688                                  ;            /* drives - there is nothing to point to their structures. Otherwise you get into */
 24689                                  ;            /* a chicken and the egg situation, where you are trying to write out 'deletes' of */
 24690                                  ;            /* the logical drive based on the start of the extended partition, but there isn't one */
 24691                                  ;            /* because it has already been deleted already. Bad things happen - PTM P941 */
 24692                                  ;
 24693                                  ;            /* SR; 9/26/89; Removed semi-colon at the end of the if
 24694                                  ;               statement that caused the block of code to always execute */
 24695                                  ;
 24696                                  ;            if (find_partition_type(uc(EXTENDED)))
 24697                                  ;               BEGIN
 24698                                  ;                /* See if any extended partitions need to be updated */
 24699                                  ;                changed_flag = FALSE;
 24700                                  ;
 24701                                  ;                for (i=c(0);i < c(23); i++)
 24702                                  ;                   BEGIN
 24703                                  ;                    if (ext_table[j][i].changed)
 24704                                  ;                       BEGIN
 24705                                  ;                        changed_flag = TRUE;
 24706                                  ;                        break;
 24707                                  ;                       END
 24708                                  ;                   END
 24709                                  ;                if (changed_flag)
 24710                                  ;                   BEGIN
 24711                                  ;                    /* First,get them in order - drive letters are assigned in the order */
 24712                                  ;                    /* that they exist on the disk */
 24713                                  ;                    sort_ext_table(c(23));
 24714                                  ;
 24715                                  ;                    for (i=c(0);i < c(23); i++)
 24716                                  ;
 24717                                  ;                       BEGIN
 24718                                  ;                        /* If there is a valid drive existing, write it out */
 24719                                  ;                        if (ext_table[j][sort[i]].sys_id != uc(0))
 24720                                  ;                           BEGIN
 24721                                  ;                            write_ext_boot_to_disk(i,j);
 24722                                  ;                           END
 24723                                  ;                       END
 24724                                  ;
 24725                                  ;                    /* Find start of extended partition */
 24726                                  ;                    extended_index = find_partition_location(uc(EXTENDED));
 24727                                  ;                    extended_location = part_table[j][extended_index].start_cyl;
 24728                                  ;
 24729                                  ;                    /* See if the first entry in EXTENDED DOS partition will be written out */
 24730                                  ;                    /* Need to find the first drive in the sorted list */
 24731                                  ;                    for (i=c(0);i < c(23); i++)
 24732                                  ;                       BEGIN
 24733                                  ;                        if (ext_table[j][sort[i]].sys_id != uc(0))
 24734                                  ;                           BEGIN
 24735                                  ;                            temp = sort[i];
 24736                                  ;                            break;
 24737                                  ;                           END
 24738                                  ;                       END
 24739                                  ;                    /* See if drive written out */
 24740                                  ;                    /* SR; 9/28/89; Check for the special case when the
 24741                                  ;                       volume is deleted and write out only a pointer
 24742                                  ;                       for it */
 24743                                  ;
 24744                                  ;                    if ((temp == c(0xff)) ||
 24745                                  ;                        (extended_location != ext_table[j][temp].start_cyl))
 24746                                  ;                       BEGIN
 24747                                  ;                        /* If not, make a special case and go do it */
 24748                                  ;                        /* Use the 24 entry in the array to set up a dummy entry */
 24749                                  ;                        /* This one isn't used for anything else */
 24750                                  ;                        /* Indicate this is special by passing along a deleted entry - the subroutine will catch it and handle correctly */
 24751                                  ;                        ext_table[j][23].sys_id = uc(0);
 24752                                  ;                        ext_table[j][23].start_cyl = part_table[j][extended_index].start_cyl;
 24753                                  ;                        ext_table[j][23].start_head = uc(0);
 24754                                  ;                        ext_table[j][23].start_sector = uc(1);
 24755                                  ;
 24756                                  ;                        /* Write out our modified first location - only pointer info will be sent to the disk */
 24757                                  ;                        write_ext_boot_to_disk(c(23),j);
 24758                                  ;                       END
 24759                                  ;                   END
 24760                                  ;               END
 24761                                  ;           END
 24762                                  ;       END
 24763                                  ;    cur_disk = temp_disk;
 24764                                  ;    return;
 24765                                  ;END
 24766                                  
 24767                                  write_info_to_disk:
 24768                                  		; 04/01/2019
 24769                                  		; 20/12/2018
 24770                                  	
 24771                                  	%define witd_j		   bp-10 ; bp-14
 24772                                  	%define witd_i		   bp-8  ; bp-12
 24773                                  	%define witd_extd_location bp-6	 ; bp-10
 24774                                  	%define witd_extd_index    bp-4	 ; bp-8
 24775                                  	%define witd_temp	   bp-12 ; bp-6
 24776                                  	;%define witd_changed_flag       ; bp-4
 24777                                  	%define witd_temp_disk	   bp-2  ; bp-2
 24778                                  
 24779                                  		;push	bp
 24780 000036C1 89E5                    		mov	bp,sp
 24781                                  		;;sub	sp,14
 24782                                  		;sub	sp,10
 24783 000036C3 83EC0C                  		sub	sp,12 ; 04/01/2019
 24784                                  
 24785                                  		;push	si
 24786                                  
 24787 000036C6 C646F4FF                		mov	byte [witd_temp],0FFh ; 04/01/2019
 24788                                  
 24789 000036CA A0[D4CB]                		mov	al,[cur_disk]
 24790 000036CD 8846FE                  		mov	[witd_temp_disk],al
 24791 000036D0 C746F60000              		mov	word [witd_j],0
 24792 000036D5 E93E01                  		jmp	witd_16
 24793                                  witd_1:
 24794 000036D8 FE46F8                  		inc	byte [witd_i]
 24795                                  ;witd_2:
 24796 000036DB 807EF804                		cmp	byte [witd_i],4
 24797 000036DF 7D20                    		jge	short witd_3
 24798                                  witd_2:
 24799 000036E1 8A46F8                  		mov	al,[witd_i] ; Partition number
 24800                                  		;cbw
 24801 000036E4 8A4EF6                  		mov	cl,[witd_j] ; Disk number
 24802                                  		;sub	ch,ch
 24803                                  		;shl	cx,1
 24804                                  		;shl	cx,1
 24805 000036E7 D0E1                    		shl	cl,1
 24806 000036E9 D0E1                    		shl	cl,1
 24807                                  		;add	ax,cx
 24808 000036EB 00C8                    		add	al,cl
 24809                                  		;mov	cx,46
 24810                                  		;imul	cx
 24811 000036ED B12E                    		mov	cl,46
 24812 000036EF F6E1                    		mul	cl
 24813 000036F1 89C3                    		mov	bx,ax
 24814 000036F3 80BF[25C4]00            		cmp	byte [part_table_changed+bx],0
 24815 000036F8 74DE                    		je	short witd_1
 24816 000036FA 8A46F6                  		mov	al,[witd_j]
 24817 000036FD 50                      		push	ax
 24818 000036FE E83101                  		call	write_master_boot_to_disk
 24819                                  		;pop	bx
 24820                                  
 24821                                  		;/* See if the extended partition exists - if not, 
 24822                                  		;   don't fool with the logical drives */
 24823                                  witd_3:
 24824 00003701 B005                    		mov	al,5 ; EXTENDED
 24825                                  		;push	ax
 24826 00003703 E8B4E6                  		call	find_partition_type
 24827                                  			 ; CL = Partition number if CF = 0
 24828                                  		;pop	bx
 24829                                  		;or	al, al
 24830                                  		;jnz	short witd_4
 24831 00003706 7303                    		jnc	short witd_4
 24832 00003708 E90001                  		jmp	witd_15
 24833                                  witd_4:
 24834 0000370B 884EFC                  		mov	[witd_extd_index],cl ; *==
 24835                                  
 24836                                   		;/* See if any extended partitions need to be updated */
 24837                                  
 24838                                  		;sub	al,al
 24839                                  		;sub	ax,ax
 24840                                  		;mov	[witd_changed_flag],al ; 0  ; FALSE
 24841                                  		;;mov	[witd_i],al ; reset
 24842                                  		;mov	[witd_i],ax ; 0
 24843 0000370E C746F80000              		mov	word [witd_i],0
 24844 00003713 EB0B                    		jmp	short witd_6
 24845                                  witd_5:
 24846 00003715 FE46F8                  		inc	byte [witd_i]
 24847                                  ;witd_6:
 24848 00003718 807EF817                		cmp	byte [witd_i],23
 24849                                  		;jge	short witd_7
 24850 0000371C 0F8DEB00                		jge	witd_15
 24851                                  witd_6:
 24852                                  		;mov	al,[witd_i]
 24853                                  		;cbw
 24854                                  		;mov	cx,ax
 24855 00003720 8A4EF8                  		mov	cl,[witd_i]
 24856 00003723 B018                    		mov	al,24
 24857 00003725 F666F6                  		mul	byte [witd_j]
 24858                                  		;add	ax,cx
 24859 00003728 00C8                    		add	al,cl
 24860                                  		;mov	cx,46
 24861                                  		;imul	cx
 24862 0000372A B12E                    		mov	cl,46
 24863 0000372C F6E1                    		mul	cl
 24864 0000372E 89C3                    		mov	bx,ax
 24865 00003730 80BF[5DA1]00            		cmp	byte [ext_table_changed+bx],0
 24866 00003735 74DE                    		je	short witd_5
 24867                                  
 24868                                  		;mov	byte [witd_changed_flag],1 ; TRUE
 24869                                  ;witd_7:
 24870                                  ;		cmp	byte [witd_changed_flag],0
 24871                                  ;		jne	short witd_8
 24872                                  ;		jmp	witd_15
 24873                                  
 24874                                   	;/* First,get them in order - drive letters are assigned in the order */
 24875                                  	;/* that they exist on the disk */
 24876                                  witd_8:
 24877                                  		;mov	al,23
 24878                                  		;push	ax
 24879 00003737 B117                    		mov	cl,23
 24880 00003739 E8C9F2                  		call	sort_ext_table
 24881                                  		;pop	bx
 24882                                  		
 24883 0000373C C646F800                		mov	byte [witd_i],0
 24884                                  witd_9:
 24885 00003740 B018                    		mov	al,24
 24886 00003742 F666F6                  		mul	byte [witd_j] ; Disk (0 to 7)
 24887                                  		;mov	cx,ax
 24888                                  		;mov	al,[witd_i]
 24889                                  		;cbw
 24890                                  		;mov	bx,ax
 24891 00003745 8B5EF8                  		mov	bx,[witd_i] ; Logical drive (0 to 22)	
 24892                                  		;mov	al,[sort+bx]
 24893                                  		;cbw
 24894                                  		;add	ax,cx
 24895 00003748 0287[E2C3]              		add	al,[sort+bx]	
 24896                                  		;mov	cx,46
 24897                                  		;imul	cx
 24898 0000374C B12E                    		mov	cl,46
 24899 0000374E F6E1                    		mul	cl
 24900 00003750 89C3                    		mov	bx,ax
 24901                                  
 24902 00003752 80BF[4FA1]00            		cmp	byte [ext_table_sys_id+bx],0
 24903 00003757 740B                    		je	short witd_10 ; Empty partition
 24904                                  
 24905 00003759 8A46F6                  		mov	al,[witd_j]
 24906 0000375C 50                      		push	ax
 24907 0000375D 8A46F8                  		mov	al,[witd_i]
 24908 00003760 50                      		push	ax
 24909 00003761 E86801                  		call	write_ext_boot_to_disk
 24910                                  		;pop	bx
 24911                                  		;pop	bx
 24912                                  witd_10:
 24913 00003764 FE46F8                  		inc	byte [witd_i]
 24914 00003767 807EF817                		cmp	byte [witd_i],23
 24915 0000376B 72D3                    		jb	short witd_9 ; 04/01/2019
 24916                                  
 24917                                  		;/* Find start of extended partition */
 24918                                  
 24919                                  		;mov	al,5
 24920                                  		;push	ax
 24921                                  		;call	find_partition_location
 24922                                  		;pop	bx
 24923                                  		;mov	[witd_extd_index],al ; *==
 24924                                  		
 24925                                  		;cbw
 24926                                  		;mov	cl,[witd_j]
 24927                                  		;sub	ch,ch
 24928                                  		;shl	cx,1
 24929                                  		;shl	cx,1
 24930                                  		;add	ax,cx
 24931                                  
 24932 0000376D 8A46F6                  		mov	al,[witd_j]
 24933 00003770 D0E0                    		shl	al,1
 24934 00003772 D0E0                    		shl	al,1
 24935 00003774 0246FC                  		add	al,[witd_extd_index] ; *==		
 24936                                  
 24937                                  		;mov	cx,46
 24938                                  		;imul	cx
 24939 00003777 B12E                    		mov	cl,46
 24940 00003779 F6E1                    		mul	cl		
 24941 0000377B 89C3                    		mov	bx,ax
 24942                                  
 24943 0000377D 8B87[15C4]              		mov	ax,[part_table_start_cyl+bx]
 24944 00003781 8946FA                  		mov	[witd_extd_location],ax
 24945                                  
 24946                                  	;/* See if the first entry in EXTENDED DOS partition will be written out */
 24947                                  	;/* Need to find the first drive in the sorted list */
 24948                                  
 24949 00003784 C646F800                		mov	byte [witd_i],0
 24950 00003788 EB09                    		jmp	short witd_12
 24951                                  witd_11:
 24952 0000378A FE46F8                  		inc	byte [witd_i]
 24953                                  ;witd_12:
 24954 0000378D 807EF817                		cmp	byte [witd_i],23
 24955 00003791 7D1E                    		jge	short witd_13 ; 04/01/2019
 24956                                  witd_12:
 24957 00003793 B018                    		mov	al,24
 24958 00003795 F666F6                  		mul	byte [witd_j]
 24959                                  		;mov	cx,ax
 24960                                  		;mov	al,[witd_i]
 24961                                  		;cbw
 24962 00003798 8B5EF8                  		mov	bx,[witd_i]
 24963                                  		;mov	al,[sort+bx]
 24964 0000379B 8A97[E2C3]              		mov	dl,[sort+bx] ; 04/01/2019
 24965                                  		;mov	dx,ax
 24966                                  		;cbw
 24967                                  		;add	ax,cx
 24968 0000379F 00D0                    		add	al,dl ; 04/01/2019	
 24969                                  
 24970                                  		;mov	cx,46
 24971                                  		;mov	bx,dx
 24972                                  		;imul	cx
 24973                                  		;mov	cl,46
 24974 000037A1 F6E1                    		mul	cl
 24975                                  		;mov	si,ax
 24976 000037A3 89C3                    		mov	bx,ax
 24977                                  		;cmp	byte [ext_table_sys_id+si],0
 24978 000037A5 80BF[4FA1]00            		cmp	byte [ext_table_sys_id+bx],0
 24979 000037AA 74DE                    		je	short witd_11
 24980                                  
 24981                                  		; 04/01/2019	
 24982                                  		;mov	[witd_temp],bl
 24983 000037AC 8856F4                  		mov	[witd_temp],dl
 24984                                  
 24985 000037AF EB12                    		jmp	short witd_18 ; 20/12/2018
 24986                                  
 24987                                  		;/* See if drive written out */
 24988                                  
 24989                                  		;/* Check for the special case when the
 24990                                                  ;   volume is deleted and write out only a pointer for it */
 24991                                  
 24992                                  		; 21/12/2018
 24993                                  witd_13:	; 04/01/2019	
 24994 000037B1 807EF4FF                		cmp	byte [witd_temp],0FFh ; 255
 24995 000037B5 7415                    		je	short witd_14
 24996                                  
 24997                                  		;;mov	al,[witd_temp]
 24998                                  		;;cbw
 24999                                  		;;mov	cx,ax
 25000                                  		;mov	dl,[witd_temp]	
 25001                                  ;witd_18:	
 25002                                  		; 04/01/2019	
 25003 000037B7 B018                    		mov	al,24
 25004 000037B9 F666F6                  		mul	byte [witd_j]
 25005                                  		;;add	ax,cx
 25006                                  		;add	al,dl
 25007 000037BC 0246F4                  		add	al,[witd_temp]
 25008                                  		;;mov	cx,46
 25009                                  		;;imul	cx
 25010                                  		;mov	cl,46
 25011 000037BF F6E1                    		mul	cl
 25012 000037C1 89C3                    		mov	bx,ax
 25013                                  
 25014                                  witd_18:	; 04/01/2019
 25015 000037C3 8B46FA                  		mov	ax,[witd_extd_location]
 25016 000037C6 3987[4DA1]              		cmp	[ext_table_start_cyl+bx],ax
 25017 000037CA 743F                    		je	short witd_15
 25018                                  witd_14:
 25019 000037CC 8A46F6                  		mov	al,[witd_j]
 25020 000037CF 28E4                    		sub	ah,ah ; 04/01/2019
 25021 000037D1 B95004                  		mov	cx,1104 ; 46*24
 25022                                  		;mov	bx,ax
 25023 000037D4 88C3                    		mov	bl,al
 25024                                  		;imul	cx
 25025 000037D6 F7E1                    		mul	cx
 25026 000037D8 89C6                    		mov	si,ax
 25027 000037DA C684[71A5]00            		mov	byte [ep0_lp23_sys_id+si],0
 25028 000037DF 8A46FC                  		mov	al,[witd_extd_index]
 25029                                  		;cbw
 25030                                  		;shl	bx,1
 25031                                  		;shl	bx,1
 25032 000037E2 D0E3                    		shl	bl,1
 25033 000037E4 D0E3                    		shl	bl,1
 25034                                  		;add	ax,bx
 25035 000037E6 00D8                    		add	al,bl
 25036 000037E8 B92E00                  		mov	cx,46
 25037                                  		;imul	cx
 25038 000037EB F6E1                    		mul	cl
 25039 000037ED 89C3                    		mov	bx,ax
 25040                                  
 25041                                  		;/* If not, make a special case and go do it */
 25042                                  		;/* Use the 24 entry in the array to set up a dummy entry */
 25043                                  		;/* This one isn't used for anything else */
 25044                                  
 25045 000037EF 8B87[15C4]              		mov	ax,[part_table_start_cyl+bx]
 25046 000037F3 8984[6FA5]              		mov	[ep0_lp23_start_cyl+si],ax
 25047 000037F7 C684[6DA5]00            		mov	byte [ep0_lp23_start_head+si],0
 25048 000037FC C684[6EA5]01            		mov	byte [ep0_lp23_start_sector+si],1
 25049                                  		
 25050                                   		;/* Write out our modified first location -
 25051                                  		;   only pointer info will be sent to the disk */
 25052                                  
 25053 00003801 8A46F6                  		mov	al,[witd_j] ; 04/01/2019
 25054 00003804 50                      		push	ax
 25055 00003805 B017                    		mov	al,23	; Logical drive	(23)
 25056 00003807 50                      		push	ax
 25057 00003808 E8C100                  		call	write_ext_boot_to_disk
 25058                                  		;pop	bx
 25059                                  		;pop	bx
 25060                                  witd_15:
 25061 0000380B FE46F6                  		inc	byte [witd_j]  ; next disk
 25062                                  ;witd_16:
 25063                                  		;/* See if need to update the master boot record */
 25064                                  
 25065 0000380E A0[D5C3]                		mov	al,[number_of_drives]
 25066 00003811 3846F6                  		cmp	byte [witd_j],al
 25067 00003814 7313                    		jnb	short witd_17
 25068                                  witd_16:
 25069                                  		;mov	al,[witd_j]
 25070                                  		;mov	[cur_disk],al
 25071                                  		;mov	bl,al
 25072                                  		;sub	bh,bh
 25073 00003816 8B5EF6                  		mov	bx,[witd_j]
 25074 00003819 881E[D4CB]              		mov	[cur_disk],bl		
 25075                                  
 25076                                  		;/* See if there were any errors on that drive */
 25077                                  
 25078 0000381D 38BF[42A1]              		cmp	byte [good_disk+bx],bh ; 0
 25079 00003821 74E8                    		je	short witd_15
 25080 00003823 887EF8                  		mov	[witd_i],bh ; 0
 25081 00003826 E9B8FE                  		jmp	witd_2
 25082                                  witd_17:
 25083 00003829 8A46FE                  		mov	al,[witd_temp_disk]
 25084 0000382C A2[D4CB]                		mov	[cur_disk],al
 25085                                  
 25086                                  		;pop	si
 25087                                  		
 25088 0000382F 89EC                    		mov	sp,bp
 25089                                  		;pop	bp
 25090 00003831 C3                      		retn
 25091                                  
 25092                                  ; ----------------------------------------------------------------------------
 25093                                  
 25094                                  ;/*  */
 25095                                  ;char write_master_boot_to_disk(disk)
 25096                                  ;
 25097                                  ;unsigned char   disk;
 25098                                  ;
 25099                                  ;BEGIN
 25100                                  ;
 25101                                  ;    unsigned char i;
 25102                                  ;    unsigned j;
 25103                                  ;    unsigned long long_temp;
 25104                                  ;    unsigned index;
 25105                                  ;
 25106                                  ;    /* Clean out the boot_record */
 25107                                  ;    for (j=u(0);j < u(BYTES_PER_SECTOR); j++)
 25108                                  ;       BEGIN
 25109                                  ;        boot_record[j] = uc(0);
 25110                                  ;       END
 25111                                  ;
 25112                                  ;    /* Copy the master boot record to boot_record */
 25113                                  ;    for (j=u(0); j < u(BYTES_PER_SECTOR); j++)
 25114                                  ;       BEGIN
 25115                                  ;        boot_record[j] = master_boot_record[disk][j];
 25116                                  ;       END
 25117                                  ;
 25118                                  ;    /* Copy the partition tables over - only bother with the changed ones */
 25119                                  ;    for (i=uc(0); i < uc(4); i++)
 25120                                  ;       BEGIN
 25121                                  ;        index = ((unsigned)i)*16;
 25122                                  ;        if (part_table[disk][i].changed)
 25123                                  ;           BEGIN
 25124                                  ;            /* Get boot ind */
 25125                                  ;            boot_record[0x1BE+(index)] = part_table[disk][i].boot_ind;
 25126                                  ;
 25127                                  ;            /* Start head */
 25128                                  ;            boot_record[0x1BF+(index)] = part_table[disk][i].start_head;
 25129                                  ;
 25130                                  ;            /* Start sector - scramble it to INT 13 format*/
 25131                                  ;            boot_record[0x1C0+(index)] = (part_table[disk][i].start_sector & 0x3F)  |
 25132                                  ;                                           ((unsigned char)((part_table[disk][i].start_cyl/256) << 6));
 25133                                  ;
 25134                                  ;            /* Start cyl - scramble it to INT 13 format */
 25135                                  ;            boot_record[0x1C1+(index)] = ((unsigned char)(part_table[disk][i].start_cyl%256));
 25136                                  ;
 25137                                  ;            /* System id */
 25138                                  ;            boot_record[0x1C2+(index)] = part_table[disk][i].sys_id;
 25139                                  ;
 25140                                  ;            /* End head */
 25141                                  ;            boot_record[0x1C3+(index)] = part_table[disk][i].end_head;
 25142                                  ;
 25143                                  ;            /* End sector - scramble it to INT 13 format*/
 25144                                  ;            boot_record[0x1C4+(index)] = (part_table[disk][i].end_sector & 0x3F)  |
 25145                                  ;                                            ((unsigned char)((part_table[disk][i].end_cyl/256) << 6));
 25146                                  ;
 25147                                  ;            /* End cyl - scramble it to INT 13 format*/
 25148                                  ;            boot_record[0x1C5+(index)] = ((unsigned char)(part_table[disk][i].end_cyl%256));
 25149                                  ;
 25150                                  ;            /* Relative sectors */
 25151                                  ;            long_temp = part_table[disk][i].rel_sec;
 25152                                  ;            boot_record[0x1C9+(index)] = uc((long_temp >> 24));
 25153                                  ;            boot_record[0x1C8+(index)] = uc(((long_temp & 0x00FF0000l) >> 16));
 25154                                  ;            boot_record[0x1C7+(index)] = uc(((long_temp & 0x0000FF00l) >> 8));
 25155                                  ;            boot_record[0x1C6+(index)] = uc((long_temp & 0x000000FFl));
 25156                                  ;
 25157                                  ;
 25158                                  ;            /* Number of sectors */
 25159                                  ;            long_temp = part_table[disk][i].num_sec;
 25160                                  ;            boot_record[0x1CD+(index)] = uc(long_temp >> 24);
 25161                                  ;            boot_record[0x1CC+(index)] = uc((long_temp & 0x00FF0000l) >> 16);
 25162                                  ;            boot_record[0x1CB+(index)] = uc((long_temp & 0x0000FF00l) >> 8);
 25163                                  ;            boot_record[0x1CA+(index)] = uc(long_temp & 0x000000FFl);
 25164                                  ;          END
 25165                                  ;       END
 25166                                  ;    boot_record[510] = uc(0x55);
 25167                                  ;    boot_record[511] = uc(0xAA);
 25168                                  ;
 25169                                  ;    return(write_boot_record(u(0),disk));
 25170                                  ;END
 25171                                  
 25172                                  write_master_boot_to_disk:
 25173                                  		; 21/12/2018
 25174                                  
 25175                                  	;%define wmbr_long_temp	bp-12 ; bp-14
 25176                                  	%define wmbr_j		bp-8  ; bp-10	
 25177                                  	%define wmbr_i		bp-6  ; bp-8
 25178                                  	%define wmbr_index	bp-4  ; bp-6
 25179                                  	
 25180                                  	%define wmbr_disk	bp+4
 25181                                  
 25182 00003832 55                      		push	bp
 25183 00003833 89E5                    		mov	bp,sp
 25184                                  		;;sub	sp,14
 25185                                  		;sub	sp,12
 25186 00003835 83EC08                  		sub	sp,8
 25187                                  
 25188                                  		;push	di
 25189                                  		;push	si
 25190                                  
 25191 00003838 C746F80000              		mov	word [wmbr_j],0
 25192                                  
 25193                                  		;/* Clean out the boot_record */
 25194                                  ;wmbr_0:
 25195                                  		;;mov	bx,[wmbr_j]
 25196                                  		;;mov	byte [boot_record+bx],0
 25197                                  		;;inc	word [wmbr_j]
 25198                                  		;;cmp	word [wmbr_j],512
 25199                                  		;;jb	short wmbr_0
 25200                                  		;;mov	word [wmbr_j],0
 25201                                  		
 25202                                  		;xor	ax,ax
 25203                                  		;mov	di,boot_record
 25204                                  		;mov	cx,256
 25205                                  		;;push	ds
 25206                                  		;;pop	es
 25207                                  		;rep	stosw
 25208                                  
 25209                                  		;/* Copy the master boot record to boot_record */
 25210                                  wmbr_1:
 25211                                  		;mov	cl,9
 25212                                  		;mov	al,[wmbr_disk]
 25213                                  		;sub	ah,ah
 25214                                  		;mov	si,ax
 25215                                  		;shl	si,cl
 25216                                  		;mov	bx,[wmbr_j]
 25217                                  		;mov	al,[master_boot_record+bx+si]
 25218                                  		;mov	[boot_record+bx],al
 25219                                  		;inc	word [wmbr_j]
 25220                                  		;cmp	word [wmbr_j],512
 25221                                  		;jb	short wmbr_1
 25222                                  
 25223 0000383D 8A4604                  		mov	al,[wmbr_disk]
 25224 00003840 30E4                    		xor	ah,ah
 25225 00003842 89C6                    		mov	si,ax
 25226 00003844 B109                    		mov	cl,9
 25227 00003846 D3E6                    		shl	si,cl ; * 512
 25228 00003848 81C6[845F]              		add	si,master_boot_record
 25229 0000384C BF[D2C9]                		mov	di,boot_record		
 25230 0000384F B90001                  		mov	cx,256
 25231 00003852 F3A5                    		rep	movsw
 25232                                  
 25233                                  	;/* Copy the partition tables over - only bother with the changed ones */
 25234                                  
 25235                                  		;mov	byte [wmbr_i],ah ; 0
 25236 00003854 894EFA                  		mov	word [wmbr_i],cx ; 0
 25237                                  wmbr_2:
 25238 00003857 B104                    		mov	cl,4
 25239                                  		;mov	al,[wmbr_i]
 25240                                  		;sub	ah,ah
 25241                                  		;mov	dx,ax
 25242                                  		;shl	ax,cl
 25243                                  		
 25244                                  		;mov	ax,[wmbr_i]
 25245                                  		;mov	bx,ax
 25246 00003859 8B5EFA                  		mov	bx,[wmbr_i]
 25247 0000385C 88D8                    		mov	al,bl
 25248                                  		;shl	bx,cl ; * 16
 25249 0000385E D2E3                    		shl	bl,cl
 25250                                  		;mov	[wmbr_index],ax
 25251 00003860 895EFC                  		mov	[wmbr_index],bx ; Partition table entry offset
 25252                                  		;mov	al,[wmbr_disk]
 25253                                  		;sub	ah,ah
 25254                                  		;shl	ax,1
 25255                                  		;shl	ax,1
 25256                                  		;add	ax,dx
 25257 00003863 8A4E04                  		mov	cl,[wmbr_disk]
 25258 00003866 D0E1                    		shl	cl,1
 25259 00003868 D0E1                    		shl	cl,1
 25260 0000386A 00C8                    		add	al,cl	; FDISK Partititon data index	
 25261                                  		;mov	cx,46
 25262                                  		;imul	cx
 25263 0000386C B12E                    		mov	cl,46
 25264 0000386E F6E1                    		mul	cl
 25265 00003870 89C3                    		mov	bx,ax	; FDISK Partition data offset
 25266 00003872 80BF[25C4]00            		cmp	byte [part_table_changed+bx],0
 25267                                  		;jne	short wmbr_3
 25268                                  		;jmp	wmbr_4
 25269 00003877 7434                    		je	short wmbr_4
 25270                                  wmbr_3:
 25271                                  		;mov	al,[part_table_boot_ind+bx]
 25272                                  		;mov	si,[wmbr_index]
 25273                                  		;mov	[boot_record+1BEh+si],al
 25274                                  		;mov	al,[part_table_start_head+bx]
 25275                                  		;mov	[boot_record+1BFh+si],al
 25276                                  		;mov	ax,[part_table_start_cyl+bx]
 25277                                  		;;mov	cx,ax
 25278                                  		;mov	ch,al
 25279                                  		;shr	ax,1
 25280                                  		;shr	ax,1
 25281                                  		;;mov	dx,ax
 25282                                  		;and	al,0C0h
 25283                                  		;;xor	al,[part_table_start_sector+bx]
 25284                                  		;;and	al,3Fh
 25285                                  		;;xor	dl,al
 25286                                  		;;mov	[boot_record+1C0h+si],dl
 25287                                  		;;mov	[boot_record+1C1h+si],cl  ; Start cylinder
 25288                                  		;mov	cl,[part_table_start_sector+bx]
 25289                                  		;;and	cl,3Fh
 25290                                  		;or	cl,al
 25291                                  		;mov	[boot_record+1C0h+si],cl  ; Start sector
 25292                                  		;mov	[boot_record+1C1h+si],ch  ; Start cylinder		
 25293                                  		;
 25294                                  		;mov	al,[part_table_sys_id+bx]
 25295                                  		;mov	[boot_record+1C2h+si],al
 25296                                  		;mov	al,[part_table_end_head+bx]
 25297                                  		;mov	[boot_record+1C3h+si],al
 25298                                  		;mov	ax,[part_table_end_cyl+bx]
 25299                                  		;;mov	cx,ax
 25300                                  		;shr	ax,1
 25301                                  		;shr	ax,1
 25302                                  		;;mov	dx,ax
 25303                                  		;and	al,0C0h
 25304                                  		;;xor	al,[part_table_end_sector+bx]
 25305                                  		;;and	al,3Fh
 25306                                  		;;xor	dl,al
 25307                                  		;;mov	[boot_record+1C4h+si],dl
 25308                                  		;;mov	[boot_record+1C5h+si],cl
 25309                                  		;mov	cl,[part_table_end_sector+bx]
 25310                                  		;;and	cl,3Fh
 25311                                  		;or	cl,al		
 25312                                  		;mov	[boot_record+1C4h+si],cl  ; End sector
 25313                                  		;mov	[boot_record+1C5h+si],ch  ; End cylinder
 25314                                  
 25315 00003879 8DB7[12C4]              		lea	si,[part_table_boot_ind+bx]
 25316                                  		;es = ds = cs = ss
 25317 0000387D 8B7EFC                  		mov	di,[wmbr_index]
 25318 00003880 81C7[90CB]              		add	di,boot_record+1BEh
 25319                                  		
 25320 00003884 A5                      		movsw	; boot indicator & start head
 25321                                  		
 25322 00003885 AC                      		lodsb
 25323 00003886 88C1                    		mov	cl,al ; start sector
 25324 00003888 AD                      		lodsw	; start cylinder
 25325 00003889 88C5                    		mov	ch,al ; 04/01/2019
 25326 0000388B D1E8                    		shr	ax,1
 25327 0000388D D1E8                    		shr	ax,1
 25328 0000388F 24C0                    		and	al,0C0h
 25329 00003891 08C8                    		or	al,cl ; sector bits 0 to 5, cylinder bits 8 & 9 (6 and 7)
 25330 00003893 88EC                    		mov	ah,ch
 25331 00003895 AB                      		stosw	; start sector & start cylinder
 25332                                  
 25333 00003896 A5                      		movsw	; system ID & end head
 25334                                  
 25335 00003897 AC                      		lodsb
 25336 00003898 88C1                    		mov	cl,al ; end sector
 25337 0000389A AD                      		lodsw	; end cylinder
 25338 0000389B 88C5                    		mov	ch,al ; 04/01/2019
 25339 0000389D D1E8                    		shr	ax,1
 25340 0000389F D1E8                    		shr	ax,1
 25341 000038A1 24C0                    		and	al,0C0h
 25342 000038A3 08C8                    		or	al,cl ; sector bits 0 to 5, cylinder bits 8 & 9 (6 and 7)
 25343 000038A5 88EC                    		mov	ah,ch
 25344 000038A7 AB                      		stosw	; end sector & end cylinder
 25345                                   		
 25346                                  		;; Microsoft C compiler code/output for
 25347                                  		;; /* Relative sectors */
 25348                                  		;;long_temp = part_table[disk][i].rel_sec;
 25349                                  		;;boot_record[0x1C9+(index)] = uc((long_temp >> 24));
 25350                                  		;;boot_record[0x1C8+(index)] = uc(((long_temp & 0x00FF0000l) >> 16));
 25351                                  		;;boot_record[0x1C7+(index)] = uc(((long_temp & 0x0000FF00l) >> 8));
 25352                                  		;;boot_record[0x1C6+(index)] = uc((long_temp & 0x000000FFl));
 25353                                  
 25354                                  		;;mov	ax,[part_table_rec_sec_lw+bx]
 25355                                  		;;mov	dx,[part_table_rel_sec_hw+bx]
 25356                                  		;;mov	cx,ax
 25357                                  		;;mov	di,dx
 25358                                  		;;mov	dl,dh
 25359                                  		;;sub	dh,dh
 25360                                  		;;mov	[boot_record+1C9h+si],dl
 25361                                  		;;mov	si,di
 25362                                  		;;mov	ax,si
 25363                                  		;;mov	di,[wmbr_index]
 25364                                  		;;mov	[boot_record+1C8h+di],al
 25365                                  		;;mov	ax,cx
 25366                                  		;;mov	dx,si
 25367                                  		;;mov	cl,8
 25368                                  		;;mov	si,bx
 25369                                  		;;mov	[wmbr_long_temp],ax
 25370                                  		;;call	shr32
 25371                                  		;;mov	bx,[wmbr_index]
 25372                                  		;;mov	[boot_record+1C7h+bx],al
 25373                                  		;;mov	al,[wmbr_long_temp]
 25374                                  		;;mov	[boot_record+1C6h+bx],al
 25375                                  
 25376                                  		; 21/12/2018
 25377                                  		; Direct assembly language code for
 25378                                  		; /* Relative sectors */
 25379                                  		
 25380                                  		;mov	ax,[part_table_rec_sec_lw+bx]
 25381                                  		;mov	dx,[part_table_rel_sec_hw+bx]
 25382                                  		;mov	[boot_record+1C6h+di],ax		
 25383                                  		;mov	[boot_record+1C8h+di],dx
 25384                                  
 25385                                  		;; Microsoft C compiler code/output for
 25386                                  		;; /* Number of sectors */
 25387                                  		;;long_temp = part_table[disk][i].num_sec;
 25388                                  		;;boot_record[0x1CD+(index)] = uc(long_temp >> 24);
 25389                                  		;;boot_record[0x1CC+(index)] = uc((long_temp & 0x00FF0000l) >> 16);
 25390                                  		;;boot_record[0x1CB+(index)] = uc((long_temp & 0x0000FF00l) >> 8);
 25391                                  		;;boot_record[0x1CA+(index)] = uc(long_temp & 0x000000FFl);
 25392                                  
 25393                                  		;;mov	ax,[part_table_num_sec_lw+si]
 25394                                  		;;mov	dx,[part_table_num_sec_hw+si]
 25395                                  		;;mov	cx,ax
 25396                                  		;;mov	si,dx
 25397                                  		;;mov	dl,dh
 25398                                  		;;sub	dh,dh
 25399                                  		;;mov	[boot_record+1CDh+bx],dl
 25400                                  		;;mov	di,si
 25401                                  		;;mov	ax,di
 25402                                  		;;mov	[boot_record+1CCh+bx],al
 25403                                  		;;mov	ax,cx
 25404                                  		;;mov	dx,si
 25405                                  		;;mov	cl,8
 25406                                  		;;mov	si,ax
 25407                                  		;;call	shr32
 25408                                  		;;mov	bx,[wmbr_index]
 25409                                  		;;mov	[boot_record+1CBh+bx],al
 25410                                  		;;mov	ax,si
 25411                                  		;;mov	[boot_record+1CAh+bx],al
 25412                                  
 25413                                  		; 21/12/2018
 25414                                  		; Direct assembly language code for
 25415                                  		; /* Number of sectors */
 25416                                  		
 25417                                  		;mov	ax,[part_table_num_sec_lw+si]
 25418                                  		;mov	dx,[part_table_num_sec_hw+si]
 25419                                  		;mov	[boot_record+1CAh+bx],ax
 25420                                  		;mov	[boot_record+1CCh+bx],dx
 25421                                  
 25422 000038A8 B90400                  		mov	cx,4
 25423 000038AB F3A5                    		rep	movsw
 25424                                  wmbr_4:
 25425 000038AD FE46FA                  		inc	byte [wmbr_i]
 25426 000038B0 807EFA04                		cmp	byte [wmbr_i],4
 25427                                  		;jnb	short wmbr_5
 25428                                  		;jmp	wmbr_2
 25429 000038B4 72A1                    		jb	short wmbr_2
 25430                                  wmbr_5:
 25431                                  		;mov	byte [boot_record+1FEh],55h
 25432                                  		;mov	byte [boot_record+1FFh],0AAh
 25433 000038B6 C706[D0CB]55AA          		mov	word [boot_record+1FEh],0AA55h
 25434                                  
 25435 000038BC 8A4604                  		mov	al,[wmbr_disk] ; disk (0 to 7)
 25436 000038BF 50                      		push	ax
 25437 000038C0 29C0                    		sub	ax,ax  ; cylinder = 0
 25438 000038C2 50                      		push	ax
 25439 000038C3 E872F3                  		call	write_boot_record
 25440                                  		;pop	bx
 25441                                  		;pop	bx ; 22/12/2018
 25442                                  
 25443                                  		;pop	si
 25444                                  		;pop	di
 25445                                  		
 25446 000038C6 89EC                    		mov	sp,bp
 25447 000038C8 5D                      		pop	bp
 25448                                  		;retn
 25449 000038C9 C20200                  		retn	2 ; 21/12/2018
 25450                                  
 25451                                  ; ----------------------------------------------------------------------------
 25452                                  
 25453                                  ;/*  */
 25454                                  ;char write_ext_boot_to_disk(entry,disk)
 25455                                  ;
 25456                                  ;char entry;
 25457                                  ;unsigned char disk;
 25458                                  ;BEGIN
 25459                                  ;
 25460                                  ;    char            i;
 25461                                  ;    unsigned        j;
 25462                                  ;    unsigned long   long_temp;
 25463                                  ;    char            location;
 25464                                  ;    char            next_drive;
 25465                                  ;    char            pointer;
 25466                                  ;    char            write;
 25467                                  ;
 25468                                  ;    /* Clean out the boot_record */
 25469                                  ;    for (j=u(0);j < u(BYTES_PER_SECTOR); j++)
 25470                                  ;       BEGIN
 25471                                  ;        boot_record[j] = uc(0);
 25472                                  ;       END
 25473                                  ;
 25474                                  ;    /* First - setup the logical devices */
 25475                                  ;    /* See if it has been deleted - if so, leave entries as zero */
 25476                                  ;    /* Otherwise - go unscramble everything out of the arrays */
 25477                                  ;
 25478                                  ;    /* SR; 9/28/89; If entry=23, then sort[entry] is undefined and we
 25479                                  ;       can have unpredictable results. Check for this special case */
 25480                                  ;
 25481                                  ;    if (entry != 23 && ext_table[disk][sort[entry]].sys_id != uc(0))
 25482                                  ;       BEGIN
 25483                                  ;        /* Get boot ind */
 25484                                  ;        boot_record[0x1BE] = ext_table[disk][sort[entry]].boot_ind;
 25485                                  ;
 25486                                  ;        /* Start head */
 25487                                  ;        boot_record[0x1BF] = ext_table[disk][sort[entry]].start_head;
 25488                                  ;
 25489                                  ;        /* Start sector - scramble it to INT 13 format */
 25490                                  ;        boot_record[0x1C0] = (ext_table[disk][sort[entry]].start_sector & 0x3F) |
 25491                                  ;                ((ext_table[disk][sort[entry]].start_cyl/256) << 6);
 25492                                  ;
 25493                                  ;        /* Start cyl - scramble it to INT 13 format*/
 25494                                  ;        boot_record[0x1C1] = ((unsigned char)(ext_table[disk][sort[entry]].start_cyl%256));
 25495                                  ;
 25496                                  ;        /* System id */
 25497                                  ;        boot_record[0x1C2]= ext_table[disk][sort[entry]].sys_id;
 25498                                  ;
 25499                                  ;        /* End head */
 25500                                  ;        boot_record[0x1C3] = ext_table[disk][sort[entry]].end_head;
 25501                                  ;
 25502                                  ;        /* End sector - scramble it to INT 13 format */
 25503                                  ;        boot_record[0x1C4] = (ext_table[disk][sort[entry]].end_sector & 0x3F) |
 25504                                  ;             ((ext_table[disk][sort[entry]].end_cyl/256) << 6);
 25505                                  ;
 25506                                  ;        /* End cyl - scramble it to INT 13 format*/
 25507                                  ;        boot_record[0x1C5] = ((unsigned char)(ext_table[disk][sort[entry]].end_cyl%256));
 25508                                  ;
 25509                                  ;        /* Relative sectors */
 25510                                  ;        long_temp = ext_table[disk][sort[entry]].rel_sec;
 25511                                  ;        boot_record[0x1C9] = uc((long_temp >> 24));
 25512                                  ;        boot_record[0x1C8] = uc(((long_temp & 0x00FF0000l) >> 16));
 25513                                  ;        boot_record[0x1C7] = uc(((long_temp & 0x0000FF00l) >> 8));
 25514                                  ;        boot_record[0x1C6] = uc((long_temp & 0x000000FFl));
 25515                                  ;
 25516                                  ;        /* Number of sectors */
 25517                                  ;        long_temp = ext_table[disk][sort[entry]].num_sec;
 25518                                  ;        boot_record[0x1CD] = uc((long_temp >> 24));
 25519                                  ;        boot_record[0x1CC] = uc(((long_temp & 0x00FF0000l) >> 16));
 25520                                  ;        boot_record[0x1CB] = uc(((long_temp & 0x0000FF00l) >> 8));
 25521                                  ;        boot_record[0x1CA] = uc((long_temp & 0x000000FFl));
 25522                                  ;       END
 25523                                  ;
 25524                                  ;    /* set up pointer to next logical drive unless this is # 23 */
 25525                                  ;    if (entry != c(22))
 25526                                  ;       BEGIN
 25527                                  ;        /* Find the drive to be pointed to */
 25528                                  ;        pointer = entry+1;
 25529                                  ;
 25530                                  ;        /* Handle the special case of a deleted or empty first entry in partition */
 25531                                  ;        if (entry == c(23))
 25532                                  ;           BEGIN
 25533                                  ;            pointer = c(0);
 25534                                  ;           END
 25535                                  ;        for (i = pointer; i <c(23); i++)
 25536                                  ;           BEGIN
 25537                                  ;            next_drive = ((char)(INVALID));
 25538                                  ;
 25539                                  ;            /* Go look for the next valid drive */
 25540                                  ;            if (ext_table[disk][sort[i]].sys_id != uc(0))
 25541                                  ;               BEGIN
 25542                                  ;                next_drive = sort[i];
 25543                                  ;                break;
 25544                                  ;               END
 25545                                  ;           END
 25546                                  ;        if (next_drive != ((char)(INVALID)))
 25547                                  ;           BEGIN
 25548                                  ;            /* Get boot ind */
 25549                                  ;            boot_record[0x1CE] = uc(0);
 25550                                  ;
 25551                                  ;            /* Start head */
 25552                                  ;            boot_record[0x1CF] = uc(0);
 25553                                  ;
 25554                                  ;            /* Start sector - scramble it to INT 13 format*/
 25555                                  ;            boot_record[0x1D0] = uc(0x01) | ((ext_table[disk][next_drive].start_cyl/256) << 6);
 25556                                  ;
 25557                                  ;            /* System id */
 25558                                  ;            boot_record[0x1D2]= uc(EXTENDED);
 25559                                  ;
 25560                                  ;            /* End head */
 25561                                  ;            boot_record[0x1D3] = uc(max_head[disk] -1);
 25562                                  ;
 25563                                  ;            /* End sector - scramble it to INT 13 format*/
 25564                                  ;            boot_record[0x1D4] =(max_sector[disk] & 0x3F) | ((ext_table[disk][next_drive].end_cyl/256) << 6);
 25565                                  ;
 25566                                  ;            /* Start cyl - scramble it to INT 13 format*/
 25567                                  ;            boot_record[0x1D1] = ((unsigned char)(ext_table[disk][next_drive].start_cyl%256));
 25568                                  ;
 25569                                  ;            /* End cyl - scramble it to INT 13 format*/
 25570                                  ;            boot_record[0x1D5] = ((unsigned char)(ext_table[disk][next_drive].end_cyl%256));
 25571                                  ;
 25572                                  ;            /* Relative sectors - this is from the front of the extended volume */
 25573                                  ;            /* Find the extended partition */
 25574                                  ;            location = find_partition_location(uc(EXTENDED));
 25575                                  ;            long_temp = ((unsigned long)(ext_table[disk][next_drive].start_cyl - part_table[disk][location].start_cyl))
 25576                                  ;                          * max_head[disk] *  max_sector[disk];
 25577                                  ;            boot_record[0x1D9] = uc((long_temp >> 24));
 25578                                  ;            boot_record[0x1D8] = uc(((long_temp & 0x00FF0000l) >> 16));
 25579                                  ;            boot_record[0x1D7] = uc(((long_temp & 0x0000FF00l) >> 8));
 25580                                  ;            boot_record[0x1D6] = uc((long_temp & 0x000000FFl));
 25581                                  ;
 25582                                  ;            /* Number of sectors in the next volume*/
 25583                                  ;            long_temp = ((unsigned long)(ext_table[disk][next_drive].end_cyl - ext_table[disk][next_drive].start_cyl+1))
 25584                                  ;                        * max_head[disk] * max_sector[disk];
 25585                                  ;            boot_record[0x1DD] = uc((long_temp >> 24));
 25586                                  ;            boot_record[0x1DC] = uc(((long_temp & 0x00FF0000l) >> 16));
 25587                                  ;            boot_record[0x1DB] = uc(((long_temp & 0x0000FF00l) >> 8));
 25588                                  ;            boot_record[0x1DA] = uc((long_temp & 0x000000FFl));
 25589                                  ;           END
 25590                                  ;       END
 25591                                  ;    boot_record[510] = uc(0x55);
 25592                                  ;    boot_record[511] = uc(0xAA);
 25593                                  ;
 25594                                  ;    /* Write the boot record out */
 25595                                  ;    if (entry != c(23))
 25596                                  ;       BEGIN
 25597                                  ;        write = write_boot_record(ext_table[disk][sort[entry]].start_cyl,disk);
 25598                                  ;       END
 25599                                  ;    else
 25600                                  ;       BEGIN
 25601                                  ;        /* Write the special case of the first entry only having a pointer */
 25602                                  ;        write = write_boot_record(ext_table[disk][23].start_cyl,disk);
 25603                                  ;       END
 25604                                  ;    return(write);
 25605                                  ;END
 25606                                  
 25607                                  write_ext_boot_to_disk:
 25608                                  
 25609                                  %define webr_temp3	bp-22h
 25610                                  %define webr_multiplicand_lw bp-1Eh
 25611                                  %define webr_multiplicand_hw bp-1Ch
 25612                                  %define webr_multiplier_lw bp-1Ah
 25613                                  %define webr_multiplier_hw bp-18h
 25614                                  %define webr_temp2	bp-16h
 25615                                  %define webr_temp1	bp-14h
 25616                                  %define webr_j		bp-0Eh
 25617                                  %define webr_i		bp-0Ch
 25618                                  %define webr_location	bp-0Ah
 25619                                  %define webr_next_drive	bp-8
 25620                                  %define webr_longtemp	bp-6
 25621                                  %define webr_longtemp_2	bp-4
 25622                                  %define webr_pointer	bp-2
 25623                                  %define webr_entry	bp+4
 25624                                  %define webr_disk	bp+6
 25625                                  
 25626 000038CC 55                      		push	bp
 25627 000038CD 89E5                    		mov	bp, sp
 25628 000038CF 83EC22                  		sub	sp, 34
 25629 000038D2 57                      		push	di
 25630 000038D3 56                      		push	si
 25631 000038D4 C746F20000              		mov	word [webr_j], 0
 25632                                  webr_1:
 25633                                  		;/* Clean out the boot_record */
 25634                                  
 25635                                  		;mov	bx,[webr_j]
 25636                                  		;mov	byte [boot_record+bx],0
 25637                                  		;inc	word [webr_j]
 25638                                  		;cmp	word [webr_j],512
 25639                                  		;jb	short webr_1
 25640                                  
 25641 000038D9 31C0                    		xor	ax,ax
 25642 000038DB BF[D2C9]                		mov	di,boot_record
 25643 000038DE B90001                  		mov	cx,256
 25644                                  		;push	ds
 25645                                  		;pop	es
 25646 000038E1 F3AB                    		rep	stosw
 25647                                  
 25648                                  	; /* First - setup the logical devices */
 25649                                  	; /* See if it has been deleted - if so, leave entries as zero */
 25650                                  	; /* Otherwise - go unscramble everything out of the arrays */
 25651                                  	;
 25652                                  	; /* SR; 9/28/89; If entry=23, then sort[entry] is undefined and we
 25653                                  	;    can have unpredictable results. Check for this special case */
 25654                                  
 25655 000038E3 807E0417                		cmp	byte [webr_entry],23
 25656                                  		;jne	short webr_2
 25657                                  		;jmp	webr_4
 25658 000038E7 744B                    		je	short webr_4 ; 22/12/2018
 25659                                  webr_2:
 25660 000038E9 B018                    		mov	al,24
 25661 000038EB F66606                  		mul	byte [webr_disk]
 25662                                  		;mov	cx,ax
 25663                                  		;mov	al,[webr_entry]
 25664                                  		;cbw
 25665                                  		;mov	bx,ax
 25666 000038EE 8A5E04                  		mov	bl,[webr_entry]
 25667 000038F1 30FF                    		xor	bh,bh
 25668                                  		;mov	al,[sort+bx]
 25669                                  		;cbw
 25670                                  		;add	ax,cx
 25671 000038F3 0287[E2C3]              		add	al,[sort+bx]
 25672                                  		;mov	cx,46
 25673                                  		;imul	cx
 25674 000038F7 B12E                    		mov	cl,46
 25675 000038F9 F6E1                    		mul	cl ; 06/01/2019
 25676 000038FB 89C3                    		mov	bx,ax
 25677 000038FD 80BF[4FA1]00            		cmp	byte [ext_table_sys_id+bx],0
 25678                                  		;jne	short webr_3
 25679                                  		;jmp	webr_4
 25680 00003902 7430                    		je	short webr_4 ; 22/12/2018
 25681                                  webr_3:
 25682                                  		;/* Get boot ind */
 25683                                  		;mov	al,[ext_table_boot_ind+bx]
 25684                                  		;mov	[boot_record+1BEh],al  ; boot indicator
 25685                                  		;/* Start head */
 25686                                  		;mov	al,[ext_table_start_head+bx]
 25687                                  		;mov	[boot_record+1BFh],al  ;start head
 25688                                  		;/* Start sector - scramble it to INT 13 format */
 25689                                  		;/* Start cyl - scramble it to INT 13 format*/
 25690                                  		;mov	ax,[ext_table_start_cyl+bx]
 25691                                  		;mov	cx,ax
 25692                                  		;shr	ax,1
 25693                                  		;shr	ax,1
 25694                                  		;mov	dx,ax
 25695                                  		;xor	al,[ext_table_start_sector+bx]
 25696                                  		;and	al,3Fh
 25697                                  		;xor	dl,al
 25698                                  		;mov	[boot_record+1C0h],dl ; start sector
 25699                                  		;mov	[boot_record+1C1h],cl ; start cylinder
 25700                                  	
 25701 00003904 8DB7[4AA1]              		lea	si,[ext_table_boot_ind+bx]
 25702                                  		;es = ds = cs = ss
 25703 00003908 BF[90CB]                		mov	di,boot_record+1BEh
 25704 0000390B A5                      		movsw	; boot indicator & start head
 25705                                  		
 25706 0000390C AC                      		lodsb
 25707 0000390D 88C1                    		mov	cl,al ; start sector
 25708 0000390F AD                      		lodsw	; start cylinder
 25709 00003910 88C5                    		mov	ch,al ; 04/01/2019
 25710 00003912 D1E8                    		shr	ax,1
 25711 00003914 D1E8                    		shr	ax,1
 25712 00003916 24C0                    		and	al,0C0h
 25713 00003918 08C8                    		or	al,cl ; sector bits 0 to 5, cylinder bits 8 & 9 (6 and 7)
 25714 0000391A 88EC                    		mov	ah,ch
 25715 0000391C AB                      		stosw	; start sector & start cylinder
 25716                                  
 25717 0000391D A5                      		movsw	; system ID & end head
 25718                                  
 25719                                  		;/* System id */
 25720                                  		;mov	al,[ext_table_sys_id+bx]
 25721                                  		;mov	[boot_record+1C2h],al ; system ID
 25722                                  		;/* End head */
 25723                                  		;mov	al,[ext_table_end_head+bx]  ;end head
 25724                                  		;mov	[boot_record+1C3h],al ; end head
 25725                                  		;/* End sector - scramble it to INT 13 format */
 25726                                  		;/* End cyl - scramble it to INT 13 format*/
 25727                                  		;mov	ax,[ext_table_end_cyl+bx]
 25728                                  		;mov	cx,ax
 25729                                  		;shr	ax,1
 25730                                  		;shr	ax,1
 25731                                  		;mov	dx,ax
 25732                                  		;xor	al,[ext_table_end_sector+bx]
 25733                                  		;and	al,3Fh
 25734                                  		;xor	dl,al
 25735                                  		;mov	[boot_record+1C4h],dl ; end sector
 25736                                  		;mov	[boot_record+1C5h],cl ; end cylinder
 25737                                  
 25738 0000391E AC                      		lodsb
 25739 0000391F 88C1                    		mov	cl,al ; end sector
 25740 00003921 AD                      		lodsw	; end cylinder
 25741 00003922 88C5                    		mov	ch,al ; 04/01/2019
 25742 00003924 D1E8                    		shr	ax,1
 25743 00003926 D1E8                    		shr	ax,1
 25744 00003928 24C0                    		and	al,0C0h
 25745 0000392A 08C8                    		or	al,cl ; sector bits 0 to 5, cylinder bits 8 & 9 (6 and 7)
 25746 0000392C 88EC                    		mov	ah,ch
 25747 0000392E AB                      		stosw	; end sector & end cylinder
 25748                                  
 25749                                   		;;/* Relative sectors */
 25750                                  		;;mov	ax,[ext_table_rel_sec_lw+bx]
 25751                                  		;;mov	dx,[ext_table_rel_sec_hw+bx]
 25752                                  		;;mov	cx,ax
 25753                                  		;;mov	si,dx
 25754                                  		;;mov	dl,dh
 25755                                  		;;sub	dh,dh
 25756                                  		;;mov	[boot_record+1C9h],dl
 25757                                  		;;mov	di,si
 25758                                  		;;mov	ax,si
 25759                                  		;;mov	[boot_record+1C8h],al
 25760                                  		;;mov	ax,cx
 25761                                  		;;mov	dx,di
 25762                                  		;;mov	cl,8
 25763                                  		;;mov	si,bx
 25764                                  		;;mov	[webr_temp],ax
 25765                                  		;;call	shr32
 25766                                  		;;mov	[boot_record+1C7h],al
 25767                                  		;;mov	al,[webr_temp]
 25768                                  		;;mov	[boot_record+1C6h],al
 25769                                  
 25770                                  		;mov	ax,[ext_table_rec_sec_lw+bx]
 25771                                  		;mov	dx,[ext_table_rel_sec_hw+bx]
 25772                                  		;mov	[boot_record+1C6h+di],ax		
 25773                                  		;mov	[boot_record+1C8h+di],dx
 25774                                  
 25775                                  		;;/* Number of sectors */
 25776                                  		;;mov	ax,[ext_table_num_sec_lw+si]
 25777                                  		;;mov	dx,[ext_table_num_sec_hw+si]
 25778                                  		;;mov	[webr_longtemp],ax
 25779                                  		;;mov	[webr_longtemp+2],dx
 25780                                  		;;mov	cx,ax
 25781                                  		;;mov	bx,dx
 25782                                  		;;mov	dl,dh
 25783                                  		;;sub	dh,dh
 25784                                  		;;mov	[boot_record+1CDh],dl
 25785                                  		;;mov	si,bx
 25786                                  		;;mov	[boot_record+1CCh],bl
 25787                                  		;;mov	dx,bx
 25788                                  		;;mov	cl,8
 25789                                  		;;mov	di,ax
 25790                                  		;;call	shr32
 25791                                  		;;mov	[boot_record+1CBh],al
 25792                                  		;;mov	ax,di
 25793                                  		;;mov	[boot_record+1CAh],al
 25794                                  
 25795                                  		;mov	ax,[ext_table_num_sec_lw+si]
 25796                                  		;mov	dx,[ext_table_num_sec_hw+si]
 25797                                  		;mov	[boot_record+1CAh+bx],ax
 25798                                  		;mov	[boot_record+1CCh+bx],dx
 25799                                  
 25800 0000392F B90400                  		mov	cx,4
 25801 00003932 F3A5                    		rep	movsw
 25802                                  
 25803                                  	;/* set up pointer to next logical drive unless this is # 23 */
 25804                                  webr_4:
 25805 00003934 8A4604                  		mov	al,[webr_entry] ; 21/12/2018
 25806                                  
 25807                                  		;cmp	byte [webr_entry],22
 25808 00003937 3C16                    		cmp	al,22
 25809 00003939 7503                    		jne	short webr_5
 25810 0000393B E9F500                  		jmp	webr_11
 25811                                  
 25812                                  	;/* Find the drive to be pointed to */	
 25813                                  webr_5:
 25814                                  		; 21/12/2018
 25815 0000393E 3C17                    		cmp	al,23
 25816 00003940 7407                    		je	short webr_14
 25817                                  
 25818                                  		;mov	al,[webr_entry]
 25819 00003942 FEC0                    		inc	al
 25820 00003944 8846FE                  		mov	[webr_pointer],al
 25821 00003947 EB05                    		jmp	short webr_6
 25822                                  
 25823                                  	;/* Handle the special case of a deleted or empty first entry in partition */
 25824                                  
 25825                                  		;cmp	[webr_entry],23
 25826                                  		;jne	short webr_6
 25827                                  webr_14:
 25828 00003949 28C0                    		sub	al,al ; 0 ; 21/12/2018
 25829                                  		;mov	byte [webr_pointer],0
 25830                                  
 25831 0000394B 8846FE                  		mov	[webr_pointer],al ; 0
 25832                                  ;webr_6:
 25833                                  		;mov	al,[webr_pointer]
 25834                                  
 25835                                  		;for (i = pointer; i < c(23); i++)
 25836                                  webr_6:
 25837 0000394E 8846F4                  		mov	[webr_i],al ; al = [webr_pointer]
 25838                                  		;jmp	short webr_8
 25839 00003951 EB0B                    		jmp	short webr_15
 25840                                  webr_7:
 25841 00003953 FE46F4                  		inc	byte [webr_i] ; i++
 25842                                  
 25843                                  webr_8:
 25844 00003956 807EF417                		cmp	byte [webr_i],23 ; i < c(23)
 25845                                  		;jge	short webr_9
 25846 0000395A 0F8DD500                		jge	webr_11
 25847                                  webr_15:
 25848                                  		; next_drive = ((char)(INVALID));
 25849                                  
 25850                                  		;mov	byte [webr_next_drive],0FFh ; 255
 25851                                  
 25852                                  	;/* Go look for the next valid drive */
 25853                                  
 25854 0000395E B018                    		mov	al,24
 25855 00003960 F66606                  		mul	byte [webr_disk]
 25856                                  		;mov	cx,ax
 25857                                  		;mov	al,[webr_i]
 25858                                  		;cbw
 25859                                  		;mov	bx,ax
 25860 00003963 8A5EF4                  		mov	bl,[webr_i]
 25861 00003966 30FF                    		xor	bh,bh
 25862                                  		;mov	al,[sort+bx]
 25863                                  		;mov	dx,ax
 25864 00003968 8A97[E2C3]              		mov	dl,[sort+bx]
 25865                                  		;cbw
 25866                                  		;add	ax,cx
 25867 0000396C 00D0                    		add	al,dl
 25868                                  		;mov	cx,46
 25869                                  		;mov	bx,dx
 25870                                  		;imul	cx
 25871 0000396E B12E                    		mov	cl,46
 25872 00003970 F6E1                    		mul	cl
 25873 00003972 89C6                    		mov	si,ax
 25874                                  
 25875                                  		;if (ext_table[disk][sort[i]].sys_id != uc(0))
 25876                                  
 25877 00003974 80BC[4FA1]00            		cmp	byte [ext_table_sys_id+si],0
 25878 00003979 74D8                    		je	short webr_7 ; next for
 25879                                  
 25880                                  		; next_drive = sort[i];
 25881                                  
 25882                                  		;;mov	[webr_next_drive],bl
 25883                                  		;mov	[webr_next_drive],dl
 25884                                  
 25885                                  		; break;   ; exit for
 25886                                  webr_9:
 25887                                  		; condition check inside 'for'
 25888                                  
 25889                                  		; if (next_drive != ((char)(INVALID)))
 25890                                  
 25891                                  ;		cmp	byte [webr_next_drive],0FFh ; 255
 25892                                  ;		jne	short webr_10
 25893                                  ;		jmp	webr_11  ; next_drive = 0FFh ; exit from 'for'
 25894                                  
 25895                                  webr_10:	; next_drive != 0FFh
 25896                                  
 25897                                  		;sub	al,al
 25898                                  		;mov	[boot_record+1CEh],al ; boot (active) indicator
 25899                                  		;mov	[boot_record+1CFh],al ; start head (= 0)
 25900                                  
 25901 0000397B 29C0                    		sub	ax,ax
 25902 0000397D A3[A0CB]                		mov	[boot_record+1CEh],ax ; 0 
 25903                                  
 25904                                  		;mov	al,[webr_next_drive]
 25905                                  		;cbw
 25906                                  		;mov	cx,24
 25907 00003980 B118                    		mov	cl,24
 25908                                  		;mov	dx,ax
 25909 00003982 8A4606                  		mov	al,[webr_disk]
 25910                                  		;sub	ah,ah
 25911                                  		;mov	bx,dx
 25912                                  		;mov	si,46
 25913 00003985 89C7                    		mov	di,ax ; *!*!"
 25914                                  		;imul	cx
 25915 00003987 F6E1                    		mul	cl ; [webr_disk]*24
 25916                                  		;add	ax,bx
 25917                                  		;add	al,[webr_next_drive] ; 06/01/2019
 25918 00003989 00D0                    		add	al,dl  ; add al,[webr_next_drive]
 25919                                  		;imul	si
 25920 0000398B B12E                    		mov	cl,46
 25921 0000398D F6E1                    		mul	cl
 25922 0000398F 89C3                    		mov	bx,ax ; **
 25923                                  
 25924 00003991 8B87[4DA1]              		mov	ax,[ext_table_start_cyl+bx]
 25925 00003995 88C5                    		mov	ch,al ; 04/01/2019
 25926 00003997 D1E8                    		shr	ax,1
 25927 00003999 D1E8                    		shr	ax,1
 25928                                  		;and	al,0C1h
 25929 0000399B 24C0                    		and	al,0C0h
 25930 0000399D 0C01                    		or	al,1
 25931 0000399F 88EC                    		mov	ah,ch
 25932                                  		;mov	[boot_record+1D0h],al ; start sector (= 1) 
 25933                                  					      ;	and cylinders bits 8 and 9
 25934                                  		;mov	[boot_record+1D1h],ch ; start cylinder (bits 0 to 7)
 25935 000039A1 A3[A2CB]                		mov	[boot_record+1D0h],ax ; start sector & start cylinder
 25936 000039A4 C606[A4CB]05            		mov	byte [boot_record+1D2h],5 ; EXTENDED  ; system ID
 25937                                  		
 25938                                  		;mov	ax,di ;disk (0 to 7)
 25939 000039A9 89FE                    		mov	si,di ; *!*!
 25940 000039AB D1E7                    		shl	di,1
 25941 000039AD 8A95[A8A0]              		mov	dl,[max_head+di] ;*!*!*
 25942 000039B1 FECA                    		dec	dl
 25943 000039B3 8816[A5CB]              		mov	[boot_record+1D3h],dl ; end head
 25944                                  
 25945 000039B7 8B97[52A1]              		mov	dx,[ext_table_end_cyl+bx]
 25946 000039BB 88D5                    		mov	ch,dl ; end cylinder, low 8 bits
 25947 000039BD D1EA                    		shr	dx,1
 25948 000039BF D1EA                    		shr	dx,1
 25949 000039C1 80E2C0                  		and	dl,0C0h
 25950 000039C4 895EEC                  		mov	[webr_temp1],bx ; **
 25951                                  		;mov	bx,ax
 25952                                  		;mov	[webr_temp2],dx
 25953                                  		;xor	dl,[max_sector+bx]
 25954                                  		;and	dl,3Fh
 25955                                  		;xor	dl,[webr_temp2]
 25956 000039C7 8A8C[A0A0]              		mov	cl,[max_sector+si] ; *!*!
 25957                                  		;and	cl,3Fh
 25958 000039CB 08D1                    		or	cl,dl ; scramble end sector (bit 0 to bit 5) to 
 25959                                  			      ; end cylinder bits 8 & 9 (end sector bits 6 & 7)
 25960                                  		
 25961                                  		;mov	[boot_record+1D4h],dl ; end sector
 25962                                  		;mov	[boot_record+1D1h],cl
 25963                                  		;mov	cx,si
 25964                                  		;mov	[boot_record+1D5h],cl ; end cylinder
 25965                                  		;mov	cl,5
 25966                                  		;mov	[boot_record+1D2h],cl
 25967                                  
 25968 000039CD 890E[A6CB]              		mov	[boot_record+1D4h],cx ; end sector & end cylinder	
 25969                                  
 25970                                  		;/* Find the extended partition */
 25971                                  
 25972                                  		;push	cx
 25973                                  		
 25974                                  		;mov	si,bx
 25975                                  		;call	find_partition_location
 25976                                  		;pop	bx
 25977                                  		;mov	[webr_location],al
 25978                                  
 25979                                  		;mov	al,5  ; EXTENDED
 25980                                  		;mov	[boot_record+1D2h],al
 25981                                  
 25982 000039D1 B005                    		mov	al,5 ; EXTENDED
 25983                                  		;push	ax
 25984 000039D3 E8E4E3                  		call	find_partition_type
 25985                                  			 ; CH = 0 ; *
 25986                                  			 ; CL = Partition number if CF = 0
 25987                                  		;pop	bx
 25988                                  
 25989 000039D6 884EF6                  		mov	[webr_location],cl
 25990                                  
 25991                                  	;/* Relative sectors - this is from the front of the extended volume */
 25992                                  
 25993 000039D9 8B85[A8A0]              		mov	ax,[max_head+di] ; *!*!* (di = disk number * 2)
 25994                                  		;sub	dx,dx
 25995                                  		;push	dx ; 0		     ; dx_h	
 25996                                  		;push	ax ; max_head[disk]  ; ax_h	
 25997 000039DD 8A8C[A0A0]              		mov	cl,[max_sector+si] ; *!*! (si = disk number)
 25998                                  		;;sub	ch,ch ; *
 25999                                  		;sub	bx,bx
 26000                                  		;push	bx ; 0
 26001                                  		;push	cx ; max_sector[disk]
 26002 000039E1 BF2E00                  		mov	di,46
 26003 000039E4 D1E6                    		shl	si,1
 26004 000039E6 D1E6                    		shl	si,1 ; disk number * 4
 26005                                  		
 26006                                  		; 22/12/2018
 26007 000039E8 F7E1                    		mul	cx ; mx_sector[disk]*max_head[disk]
 26008                                  		
 26009 000039EA 8946E6                  		mov	[webr_multiplier_lw],ax
 26010 000039ED 8956E8                  		mov	[webr_multiplier_hw],dx
 26011                                  
 26012                                  		; 22/12/2018
 26013 000039F0 52                      		push	dx ; DX_h*s
 26014 000039F1 50                      		push	ax ; AX_h*s
 26015                                  
 26016 000039F2 8A46F6                  		mov	al,[webr_location]
 26017 000039F5 98                      		cbw
 26018 000039F6 01F0                    		add	ax,si
 26019                                  		;imul	di
 26020 000039F8 F7E7                    		mul	di ; * 46
 26021 000039FA 89C6                    		mov	si,ax ; [disk][location]
 26022                                  
 26023 000039FC 8B7EEC                  		mov	di,[webr_temp1] ; ** ; [disk][next_drive]
 26024                                  
 26025 000039FF 8B85[4DA1]              		mov	ax,[ext_table_start_cyl+di]
 26026                                  
 26027                                  		;mov	dx,ax
 26028 00003A03 89C7                    		mov	di,ax ; ext_table[disk][next_drive].start_cyl ; ***
 26029                                  
 26030 00003A05 2B84[15C4]              		sub	ax,[part_table_start_cyl+si]
 26031                                  
 26032                                  	; ax = ext_table[disk][next_drive].start_cyl - part_table[disk][location].start_cyl
 26033                                  
 26034                                  		;mov	si,dx  
 26035                                  		;sub	dx,dx
 26036                                  		
 26037 00003A09 52                      		push	dx ; 0
 26038 00003A0A 50                      		push	ax
 26039                                  		
 26040                                  		;mov	di,cx
 26041                                  		;mov	[webr_multiplicand_lw],di
 26042                                  		;mov	[webr_multiplicand_hw],bx
 26043                                  
 26044                                  		;; stack: ; Microsoft C compiler's multiplication code
 26045                                  		;	;sp+5 -> dx_head = 0
 26046                                  		;	;sp+4 -> ax_head = max_head[disk]
 26047                                  		;	;sp+3 -> bx = 0
 26048                                  		;	;sp+2 -> cx = max_sector[disk]
 26049                                  		;	;sp+1 -> dx = 0
 26050                                  		;	;sp -> ax = next_drive's start cyl - extended partition's start cyl
 26051                                  		;call	mul_32 ; [bx:cx]*[dx:ax]
 26052                                  		;	; result:
 26053                                  		;	;   dx:ax = start cylinder difference * max_sector[disk]
 26054                                  		;push	dx
 26055                                  		;push	ax
 26056                                  		;	;sp+3 -> dx_head = 0
 26057                                  		;	;sp+2 -> ax_head = max_head[disk]
 26058                                  		;	;sp+1 -> dx = high word of previous multiplication result
 26059                                  		;	;sp -> ax = low word of previous multiplication result
 26060                                  		;call	mul32
 26061                                  		;	; result:
 26062                                  		;	;   dx:ax = start cyl diff. * max_sector[disk] * max_head[disk]
 26063                                  			;         = relative start sector of next logical drv in ext part.
 26064                                  		
 26065                                  		; stack: ; Erdogan Tan - 22/12/2018
 26066                                  		;	;sp+3 -> DX_h*s = high word of max_sector[disk]*max_head[disk]
 26067                                  		;	;sp+2 -> AX_h*s = low word of max_sector[disk]*max_head[disk]
 26068                                  		;	;sp+1 -> DX = 0
 26069                                  		;	;sp -> AX = next_drive's start cyl - extended partition's start cyl
 26070 00003A0B E8C3DB                  		call	mul32
 26071                                  			; result:
 26072                                  			;   dx:ax = relative start sector of next logical drive in ext part.
 26073                                  
 26074                                  		;mov	cx,ax
 26075                                  		;mov	bx,dx
 26076                                  		;mov	dl,dh
 26077                                  		;sub	dh,dh
 26078                                  		;mov	[boot_record+1D9h],dl
 26079                                  		;mov	di,bx
 26080                                  		;mov	[boot_record+1D8h],bl
 26081                                  		;mov	dx,di
 26082                                  		;mov	cl,8
 26083                                  		;mov	[webr_temp3],ax
 26084                                  		;call	shr32
 26085                                  		;mov	[boot_record+1D7h],al
 26086                                  		;mov	al,[webr_temp3]
 26087                                  		;mov	[boot_record+1D6h],al
 26088                                  
 26089                                  		; 22/12/2018
 26090 00003A0E A3[A8CB]                		mov	[boot_record+1D6h],ax
 26091 00003A11 8916[AACB]              		mov	[boot_record+1D8h],dx
 26092                                  
 26093                                  	;/* Number of sectors in the next volume */
 26094                                  
 26095                                  		;push	word [webr_multiplier_hw]   ; 0	
 26096                                  		;push	word [webr_multiplier_lw]   ; max_head[disk] 	
 26097                                  		;push	word [webr_multiplicand_hw] ; 0
 26098                                  		;push	word [webr_multiplicand_lw] ; max_sector[disk]
 26099                                  		;mov	bx,[webr_temp]
 26100                                  		;sub	si,[ext_table_end_cyl+bx]
 26101                                  		;neg	si
 26102                                  		;inc	si
 26103                                  		;sub	cx,cx
 26104                                  		;push	cx ; 0
 26105                                  		;push	si ; cylinder count of the next logical drive
 26106                                  		;call	mul32
 26107                                  		;push	dx ;high word of cylinders * sectors (per track)	
 26108                                  		;push	ax ;low word of cylinders * sectors (per track)
 26109                                  		;call	mul32
 26110                                  		
 26111                                  		; 22/12/2018
 26112 00003A15 FF76E8                  		push	word [webr_multiplier_hw] ; hw of mx_sector[disk]*max_head[disk]
 26113 00003A18 FF76E6                  		push	word [webr_multiplier_lw] ; lw of mx_sector[disk]*max_head[disk]
 26114                                  		
 26115                                  		; di = ext_table[disk][next_drive].start_cyl ; ***
 26116                                  
 26117 00003A1B 8B5EEC                  		mov	bx,[webr_temp1]
 26118 00003A1E 2BBF[52A1]              		sub	di,[ext_table_end_cyl+bx]
 26119 00003A22 F7DF                    		neg	di
 26120 00003A24 47                      		inc	di
 26121 00003A25 31DB                    		xor	bx,bx
 26122 00003A27 53                      		push	bx ; 0
 26123 00003A28 57                      		push	di ; cylinder count of the next logical drive
 26124 00003A29 E8A5DB                  		call	mul32
 26125                                  			; result:
 26126                                  			;   dx:ax = number of sectors in the next logical drive	
 26127                                  
 26128                                  		;mov	[webr_longtemp],ax
 26129                                  		;mov	[webr_longtemp+2],dx
 26130                                  		;mov	dl,dh
 26131                                  		;sub	dh,dh
 26132                                  		;mov	[boot_record+1DDh],dl
 26133                                  		;mov	al,[webr_longtemp_2]
 26134                                  		;mov	[boot_record+1DCh],al
 26135                                  		;mov	ax,[webr_longtemp]
 26136                                  		;mov	dx,[webr_longtemp+2]
 26137                                  		;mov	cl,8
 26138                                  		;call	shr32
 26139                                  		;mov	[boot_record+1DBh],al
 26140                                  		;mov	al,[webr_longtemp]
 26141                                  		;mov	[boot_record+1DAh],al
 26142                                  
 26143                                  		; 22/12/2018
 26144 00003A2C A3[ACCB]                		mov	[boot_record+1DAh],ax
 26145 00003A2F 8916[AECB]              		mov	[boot_record+1DCh],dx
 26146                                  webr_11:
 26147                                  		;mov	byte [boot_record+1FEh],55h
 26148                                  		;mov	byte [boot_record+1FFh],0AAh
 26149 00003A33 C706[D0CB]55AA          		mov	word [boot_record+1FEh],0AA55h
 26150                                  
 26151 00003A39 807E0417                		cmp	byte [webr_entry],23
 26152 00003A3D 741D                    		je	short webr_12
 26153                                  
 26154                                  		;/* Write the boot record out */
 26155                                  
 26156 00003A3F 8A4606                  		mov	al,[webr_disk]
 26157 00003A42 50                      		push	ax
 26158 00003A43 B118                    		mov	cl,24
 26159 00003A45 F6E1                    		mul	cl
 26160                                  		;mov	cx,ax
 26161                                  		;mov	al,[webr_entry]
 26162                                  		;cbw
 26163                                  		;mov	bx,ax
 26164                                  
 26165 00003A47 8A5E04                  		mov	bl,[webr_entry]
 26166 00003A4A 30FF                    		xor	bh,bh
 26167                                  		;;mov	al,[sort+bx]
 26168                                  		;mov	cl,[sort+bx]
 26169                                  		;;cbw
 26170                                  		;;add	ax,cx
 26171                                  		;add	al,cl
 26172 00003A4C 0287[E2C3]              		add	al,[sort+bx]
 26173                                  		;mov	cx,46
 26174                                  		;imul	cx
 26175 00003A50 B12E                    		mov	cl,46
 26176 00003A52 F6E1                    		mul	cl
 26177 00003A54 89C3                    		mov	bx,ax
 26178 00003A56 FFB7[4DA1]              		push	word [ext_table_start_cyl+bx]
 26179 00003A5A EB11                    		jmp	short webr_13
 26180                                  
 26181                                  	;/* Write the special case of the first entry only having a pointer */
 26182                                  webr_12:
 26183 00003A5C 8A4606                  		mov	al,[webr_disk]
 26184 00003A5F 28E4                    		sub	ah,ah
 26185 00003A61 50                      		push	ax	; Disk (0 to 7)
 26186 00003A62 B95004                  		mov	cx,1104 ; 24*46
 26187                                  		;imul	cx
 26188 00003A65 F7E1                    		mul	cx
 26189 00003A67 89C3                    		mov	bx,ax
 26190 00003A69 FFB7[6FA5]              		push	word [ep0_lp23_start_cyl+bx]  ; Cylinder
 26191                                  webr_13:
 26192 00003A6D E8C8F1                  		call	write_boot_record
 26193                                  		;pop	bx
 26194                                  		;pop	bx ; 22/12/2018
 26195                                  
 26196                                  		;pop	si
 26197                                  		;pop	di
 26198                                  
 26199 00003A70 89EC                    		mov	sp,bp
 26200 00003A72 5D                      		pop	bp
 26201                                  		
 26202                                  		;retn
 26203 00003A73 C20400                  		retn	4 ; 05/01/2019
 26204                                  
 26205                                  ; ============================================================================
 26206                                  ;  DELETE PARTITION
 26207                                  ; ============================================================================
 26208                                  ; 23/12/2018
 26209                                  
 26210                                  ; fdisk.msg (MSDOS 6.0)
 26211                                  ;/***************************************************************************************************/
 26212                                  ;/*  Screen for DELETE_PARTITION                                                                    */
 26213                                  ;/*                                                                                                 */
 26214                                  ;/*     |00000000001111111111222222222233333333334444444444555555555566666666667777777777|          */
 26215                                  ;/*     |01234567890123456789012345678901234567890123456789012345678901234567890123456789|          */
 26216                                  ;/*   --|--------------------------------------------------------------------------------|          */
 26217                                  ;/*   00|                                                                                |          */
 26218                                  ;/*   01|                                                                                |          */
 26219                                  ;/*   02|                                                                                |          */
 26220                                  ;/*   03|                                                                                |          */
 26221                                  ;/*   04|                   Delete DOS Partition or Logical DOS Drive                    |menu_25   */
 26222                                  ;/*   05|                                                                                |          */
 26223                                  ;/*   06|    Current fixed disk drive: #                                                 |menu_5 #  */
 26224                                  ;/*   07|                                                                                |          */
 26225                                  ;/*   08|    Choose one of the following:                                                |menu_3 #  */
 26226                                  ;/*   09|                                                                                |          */
 26227                                  ;/*   10|    1.  Delete Primary DOS Partition                                            |menu_26   */
 26228                                  ;/*   11|    2.  Delete Extended DOS Partition                                           |menu_26   */
 26229                                  ;/*   12|    3.  Delete Logical DOS Drive(s) in the Extended DOS Partition               |menu_27   */
 26230                                  ;/*   13|    4.  Delete Non-DOS Partition                                                |menu_57   */
 26231                                  ;/*   14|                                                                                |          */
 26232                                  ;/*   15|                                                                                |          */
 26233                                  ;/*   16|                                                                                |          */
 26234                                  ;/*   17|    Enter choice: [ ]                                                           |menu_7 #  */
 26235                                  ;/*   18|                                                                                |          */
 26236                                  ;/*   19|                                                                                |          */
 26237                                  ;/*   20|                                                                                |          */
 26238                                  ;/*   21|                                                                                |          */
 26239                                  ;/*   22|                                                                                |          */
 26240                                  ;/*   23|                                                                                |          */
 26241                                  ;/*   24|    Press ESC to return to FDISK Options                                        |menu_11   */
 26242                                  ;/*   ------------------------------------------------------------------------------------          */
 26243                                  ;/*                                                                                                 */
 26244                                  ;/***************************************************************************************************/
 26245                                  ; ----------------------------------------------------------------------------
 26246                                  ; d_menus.c (FDISK, MSDOS 6.0, 1991)	
 26247                                  ; ----------------------------------------------------------------------------
 26248                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 23/12/2018)
 26249                                  
 26250                                  ;/*  */
 26251                                  ;/******************* START OF SPECIFICATIONS *******************/
 26252                                  ;/*                                                             */
 26253                                  ;/* SUBROUTINE NAME: DELETE_PARTITION                           */
 26254                                  ;/*                                                             */
 26255                                  ;/* DESCRIPTIVE NAME: Delete partition selection menu           */
 26256                                  ;/*                                                             */
 26257                                  ;/* FUNCTION: User is prompted as to what type of DOS partition */
 26258                                  ;/*           he wishes to delete.                              */
 26259                                  ;/*                                                             */
 26260                                  ;/* NOTES: The delete volume option is only displayed if some   */
 26261                                  ;/*        disk volumes exist                                   */
 26262                                  ;/*                                                             */
 26263                                  ;/*        The following screen is managed                      */
 26264                                  ;/*                                                             */
 26265                                  ;/*     |0000000000111111111122222222223333333333|              */
 26266                                  ;/*     |0123456789012345678901234567890123456789|              */
 26267                                  ;/*   --|----------------------------------------|              */
 26268                                  ;/*   00|                                        |              */
 26269                                  ;/*   01|                                        |              */
 26270                                  ;/*   02|                                        |              */
 26271                                  ;/*   03|                                        |              */
 26272                                  ;/*   04|Delete DOS Partition                    |              */
 26273                                  ;/*   05|                                        |              */
 26274                                  ;/*   06|Current Fixed Disk Drive: #             |              */
 26275                                  ;/*   07|                                        |              */
 26276                                  ;/*   08|Enter the type of DOS partition you     |              */
 26277                                  ;/*   09|wish to delete..............?           |              */
 26278                                  ;/*   10|                                        |              */
 26279                                  ;/*   11|    1.  Normal DOS partition            |              */
 26280                                  ;/*   12|    2.  EXTENDED DOS Partition          |              */
 26281                                  ;/*   13|    3.  Disk volume in the EXTENDED     |              */
 26282                                  ;/*   14|        DOS Partition                   |              */
 26283                                  ;/*   15|                                        |              */
 26284                                  ;/*   16|                                        |              */
 26285                                  ;/*   17|                                        |              */
 26286                                  ;/*   18|Enter choice: [#]                       |              */
 26287                                  ;/*   19|                                        |              */
 26288                                  ;/*   20|                                        |              */
 26289                                  ;/*   21|                                        |              */
 26290                                  ;/*   22|                                        |              */
 26291                                  ;/*   23|Press ESC to return to FDISK Options    |              */
 26292                                  ;/*   --------------------------------------------              */
 26293                                  ;/*                                                             */
 26294                                  ;/* ENTRY POINTS: Delete_Partition                              */
 26295                                  ;/*      LINKAGE: delete_partition()                            */
 26296                                  ;/*           NEAR CALL                                         */
 26297                                  ;/*                                                             */
 26298                                  ;/* INPUT: None                                                 */
 26299                                  ;/*                                                             */
 26300                                  ;/* EXIT-NORMAL: ERROR=FALSE                                    */
 26301                                  ;/*                                                             */
 26302                                  ;/* EXIT-ERROR: ERROR=TRUE                                      */
 26303                                  ;/*             GOTO internal_program_error if case statement   */
 26304                                  ;/*             failure when branching to requested function    */
 26305                                  ;/*                                                             */
 26306                                  ;/* EFFECTS: No data directly modified by this routine, but     */
 26307                                  ;/*          child routines will modify data.                   */
 26308                                  ;/*                                                             */
 26309                                  ;/* INTERNAL REFERENCES:                                        */
 26310                                  ;/*   ROUTINES:                                                 */
 26311                                  ;/*      clear_screen                                           */
 26312                                  ;/*      wait_for_ESC                                           */
 26313                                  ;/*      get_num_input                                          */
 26314                                  ;/*      internal_program_error                                 */
 26315                                  ;/*      dos_delete                                             */
 26316                                  ;/*      ext_delete                                             */
 26317                                  ;/*      vol_delete                                             */
 26318                                  ;/*                                                             */
 26319                                  ;/* EXTERNAL REFERENCES:                                        */
 26320                                  ;/*   ROUTINES:                                                 */
 26321                                  ;/*                                                             */
 26322                                  ;/******************** END OF SPECIFICATIONS ********************/
 26323                                  
 26324                                  ;/*  */
 26325                                  ;void delete_partition()
 26326                                  ;
 26327                                  ;BEGIN
 26328                                  ;
 26329                                  ;    unsigned i;
 26330                                  ;    char input;
 26331                                  ;    char temp;
 26332                                  ;    char max_input;
 26333                                  ;
 26334                                  ;    input = c(NUL);
 26335                                  ;    /* clear_screen */
 26336                                  ;    clear_screen(u(0),u(0),u(24),u(79));
 26337                                  ;
 26338                                  ;    /* Display header */
 26339                                  ;    display(menu_25);
 26340                                  ;
 26341                                  ;    /* Setup and print current disk */
 26342                                  ;    insert[0] = cur_disk+1+'0';
 26343                                  ;    display(menu_5);
 26344                                  ;
 26345                                  ;    /* check to see if there is an avail partition */
 26346                                  ;    temp = c(0);
 26347                                  ;    for (i = u(0); i < u(4);i++)
 26348                                  ;       BEGIN
 26349                                  ;
 26350                                  ;        /* See if any non - zero system id bytes */
 26351                                  ;        temp = temp | part_table[cur_disk][i].sys_id ;
 26352                                  ;       END
 26353                                  ;    /* Any entry that isn't zero means */
 26354                                  ;    if (temp != c(0))
 26355                                  ;       BEGIN
 26356                                  ;
 26357                                  ;        /* Display enter prompts */
 26358                                  ;        /* display dos delete menu without input prompt */
 26359                                  ;        display(menu_3);
 26360                                  ;        display(menu_25);
 26361                                  ;        display(menu_26);
 26362                                  ;        display(menu_7);
 26363                                  ;
 26364                                  ;        /* print ESC prompt */
 26365                                  ;        display(menu_11);
 26366                                  ;
 26367                                  ;        display(menu_27);
 26368                                  ;        display(menu_57);
 26369                                  ;        max_input = c(4);
 26370                                  ;
 26371                                  ;        input = get_num_input(c(NUL),max_input,input_row,input_col);
 26372                                  ;        /* Go branch to the requested function */
 26373                                  ;        switch(input)
 26374                                  ;           BEGIN
 26375                                  ;            case '1':
 26376                                  ;                if (find_partition_type(uc(DOS12)) ||
 26377                                  ;                    find_partition_type(uc(DOS16)) ||
 26378                                  ;                    find_partition_type(uc(DOSNEW)))
 26379                                  ;                    dos_delete();
 26380                                  ;                else
 26381                                  ;                    BEGIN
 26382                                  ;                    /* No Pri partition to delete */
 26383                                  ;                    clear_screen(u(17),u(0),u(17),u(79));
 26384                                  ;                    display(error_6);
 26385                                  ;                    wait_for_ESC();
 26386                                  ;                    END
 26387                                  ;                break;
 26388                                  ;
 26389                                  ;            case '2':
 26390                                  ;                if (find_partition_type(uc(EXTENDED)))
 26391                                  ;                    ext_delete();
 26392                                  ;                else
 26393                                  ;                    BEGIN
 26394                                  ;                    /* No Ext partition to delete */
 26395                                  ;                    clear_screen(u(17),u(0),u(17),u(79));
 26396                                  ;                    display(error_7);
 26397                                  ;                    wait_for_ESC();
 26398                                  ;                    END
 26399                                  ;                break;
 26400                                  ;
 26401                                  ;            case '3':
 26402                                  ;                if ((find_partition_type(uc(EXTENDED))) && (find_logical_drive()))
 26403                                  ;                    volume_delete();
 26404                                  ;                else
 26405                                  ;                    BEGIN
 26406                                  ;                    clear_screen(u(17),u(0),u(17),u(79));
 26407                                  ;                    display(error_36);
 26408                                  ;                    wait_for_ESC();
 26409                                  ;                    END
 26410                                  ;                break;
 26411                                  ;
 26412                                  ;            case '4':
 26413                                  ;                if (find_non_dos_partition())
 26414                                  ;                    non_dos_delete();
 26415                                  ;                else
 26416                                  ;                    BEGIN
 26417                                  ;                    clear_screen(u(17),u(0),u(17),u(79));
 26418                                  ;                    display(error_38);
 26419                                  ;                    wait_for_ESC();
 26420                                  ;                    END
 26421                                  ;                break;
 26422                                  ;
 26423                                  ;            case ESC:
 26424                                  ;                break;
 26425                                  ;
 26426                                  ;            default :
 26427                                  ;                internal_program_error();
 26428                                  ;                 break;
 26429                                  ;           END
 26430                                  ;       END
 26431                                  ;    else
 26432                                  ;       BEGIN
 26433                                  ;        display(error_14);
 26434                                  ;        wait_for_ESC();
 26435                                  ;       END
 26436                                  ;    /* clear the screen before going back to main menu */
 26437                                  ;    clear_screen(u(0),u(0),u(24),u(79));
 26438                                  ;    return;
 26439                                  ;END
 26440                                  
 26441                                  delete_partition:
 26442                                  		; 23/12/2018
 26443                                  
 26444                                  	%define dp_i	bp-4
 26445                                  	%define dp_temp	bp-2
 26446                                  
 26447 00003A76 55                      		push	bp
 26448 00003A77 89E5                    		mov	bp,sp
 26449 00003A79 83EC04                  		sub	sp,4
 26450                                  
 26451                                  		;/* clear_screen */
 26452                                  
 26453                                  		;mov	ax,79
 26454                                  		;push	ax
 26455                                  		;mov	ax,24
 26456                                  		;push	ax
 26457                                  		;sub	ax,ax
 26458                                  		;push	ax
 26459                                  		;push	ax
 26460                                  		;call	clear_screen
 26461                                  		;add	sp,8
 26462                                  
 26463 00003A7C E8DFD9                  		call	CLS
 26464                                  
 26465                                  		;/* Display header */
 26466                                  
 26467                                  		;push	word [menu_25_segment]
 26468 00003A7F 1E                      		push	ds
 26469 00003A80 FF36[259E]              		push	word [menu_25_offset]
 26470 00003A84 E893DB                  		call	display
 26471                                  		;pop	bx
 26472                                  		;pop	bx
 26473                                  
 26474                                  		;/* Setup and print current disk */
 26475                                  
 26476                                  		;mov	al,[cur_disk]
 26477                                  		;add	al,'1'
 26478                                  		;mov	[insert],al
 26479                                  		;;push	word [menu_5_segment]
 26480                                  		;push	ds
 26481                                  		;push	word [menu_5_offset]
 26482                                  		;call	display
 26483                                  		;;pop	bx
 26484                                  		;;pop	bx
 26485                                  
 26486 00003A87 E8C9F3                  		call	display_menu_5 ; 31/12/2018
 26487                                  
 26488                                  		;/* check to see if there is an avail partition */
 26489                                  		
 26490 00003A8A 28C0                    		sub	al,al ; 0
 26491 00003A8C 8846FE                  		mov	[dp_temp],al
 26492 00003A8F 8846FC                  		mov	[dp_i],al ; 0
 26493                                  dp_1:
 26494 00003A92 A0[D4CB]                		mov	al,[cur_disk]
 26495                                  		;cbw
 26496                                  		;shl	ax,1
 26497                                  		;shl	ax,1
 26498 00003A95 D0E0                    		shl	al,1
 26499 00003A97 D0E0                    		shl	al,1
 26500                                  		;add	ax,[dp_i]
 26501 00003A99 0246FC                  		add	al,[dp_i]
 26502                                  		;mov	cx,46
 26503                                  		;mul	cx
 26504 00003A9C B12E                    		mov	cl,46
 26505 00003A9E F6E1                    		mul	cl
 26506 00003AA0 89C3                    		mov	bx,ax
 26507                                  
 26508                                  		;/* See if any non-zero system id bytes */
 26509                                  		
 26510 00003AA2 8A87[17C4]              		mov	al,[part_table_sys_id+bx]
 26511 00003AA6 0846FE                  		or	[dp_temp],al
 26512 00003AA9 FE46FC                  		inc	byte [dp_i]
 26513 00003AAC 807EFC04                		cmp	byte [dp_i],4
 26514 00003AB0 72E0                    		jb	short dp_1
 26515                                  
 26516                                  		;/* Any entry that isn't zero means */
 26517                                  
 26518 00003AB2 807EFE00                		cmp	byte [dp_temp],0
 26519 00003AB6 7503                    		jne	short dp_2
 26520 00003AB8 E9C500                  		jmp	dp_16
 26521                                  dp_2:
 26522                                  		;/* Display enter prompts */
 26523                                  		;/* display dos delete menu without input prompt */
 26524                                  
 26525                                  		;push	word [menu_3_segment]
 26526 00003ABB 1E                      		push	ds
 26527 00003ABC FF36[EB9D]              		push	word [menu_3_offset]
 26528 00003AC0 E857DB                  		call	display
 26529                                  		;pop	bx
 26530                                  		;pop	bx
 26531                                  		
 26532                                  		;;push	word [menu_25_segment]
 26533                                  		;push	ds
 26534                                  		;push	word [menu_25_offset]
 26535                                  		;call	display
 26536                                  		;;pop	bx
 26537                                  		;;pop	bx
 26538                                  		
 26539                                  		;push	word [menu_26_segment]
 26540 00003AC3 1E                      		push	ds
 26541 00003AC4 FF36[279E]              		push	word [menu_26_offset]
 26542 00003AC8 E84FDB                  		call	display
 26543                                  		;pop	bx
 26544                                  		;pop	bx
 26545                                  		
 26546                                  		;push	word [menu_7_segment]
 26547 00003ACB 1E                      		push	ds
 26548 00003ACC FF36[F39D]              		push	word [menu_7_offset]
 26549 00003AD0 E847DB                  		call	display
 26550                                  		;pop	bx
 26551                                  		;pop	bx
 26552                                  		
 26553                                  		;/* print ESC prompt */
 26554                                  
 26555                                  		;;push	word [menu_11_segment]
 26556                                  		;push	ds
 26557                                  		;push	word [menu_11_offset]
 26558                                  		;call	display
 26559                                  		;;pop	bx
 26560                                  		;;pop	bx
 26561                                  
 26562 00003AD3 E88EF3                  		call	display_menu_11 ; 31/12/2018
 26563                                  		
 26564                                  		;push	word [menu_27_segment]
 26565 00003AD6 1E                      		push	ds
 26566 00003AD7 FF36[299E]              		push	word [menu_27_offset]
 26567 00003ADB E83CDB                  		call	display
 26568                                  		;pop	bx
 26569                                  		;pop	bx
 26570                                  
 26571                                  		;push	word [menu_57_segment]
 26572 00003ADE 1E                      		push	ds
 26573 00003ADF FF36[2B9E]              		push	word [menu_57_offset]
 26574 00003AE3 E834DB                  		call	display
 26575                                  		;pop	bx
 26576                                  		;pop	bx
 26577                                  
 26578 00003AE6 FF36[9CA0]              		push	word [input_col]
 26579 00003AEA FF36[3EA1]              		push	word [input_row]
 26580 00003AEE B004                    		mov	al,4  ; Maximum input = 4	
 26581 00003AF0 50                      		push	ax
 26582 00003AF1 28C0                    		sub	al,al ; Default input = 0
 26583 00003AF3 50                      		push	ax
 26584 00003AF4 E873EF                  		call	get_num_input
 26585                                  		;add	sp,8
 26586                                  
 26587                                  		;/* Go branch to the requested function */
 26588                                  switch_input2:
 26589                                  		;cbw
 26590                                  		;cmp	ax,'4'
 26591 00003AF7 3C34                    		cmp	al,'4'
 26592 00003AF9 7502                    		jne	short dp_4
 26593 00003AFB EB6F                    		jmp	case_delete_4
 26594                                  dp_4:
 26595 00003AFD 7713                    		ja	short dp_6
 26596 00003AFF 2C1B                    		sub	al,1Bh  ; ESC key
 26597 00003B01 7503                    		jnz	short dp_5
 26598 00003B03 E98500                  		jmp	case_delete_ESC
 26599                                  dp_5:
 26600 00003B06 2C16                    		sub	al,16h  ; 1Bh+16h = 31h = '1'
 26601 00003B08 740D                    		jz	short case_delete_1
 26602 00003B0A FEC8                    		dec	al		  ; 32h = '2'
 26603 00003B0C 742D                    		jz	short case_delete_2
 26604 00003B0E FEC8                    		dec	al		  ; 33h = '3'	
 26605 00003B10 743F                    		jz	short case_delete_3
 26606                                  dp_6:
 26607 00003B12 E8FCF7                  		call	internal_program_error
 26608 00003B15 EB74                    		jmp	case_delete_ESC
 26609                                  case_delete_1:
 26610 00003B17 B001                    		mov	al,1  ; DOS12 (FAT12)
 26611                                  		;push	ax
 26612 00003B19 E89EE2                  		call	find_partition_type
 26613                                  		;pop	bx
 26614                                  		;or	al,al
 26615                                  		;jnz	short dp_8
 26616 00003B1C 730E                    		jnc	short dp_8
 26617                                  
 26618 00003B1E B004                    		mov	al,4  ; DOS16 (FAT16)
 26619                                  		;push	ax
 26620 00003B20 E897E2                  		call	find_partition_type
 26621                                  		;pop	bx
 26622                                  		;or	al,al
 26623                                  		;jnz	short dp_8
 26624 00003B23 7307                    		jnc	short dp_8
 26625                                  		
 26626 00003B25 B006                    		mov	al,6  ; DOSNEW (FAT16 big)
 26627                                  		;push	ax
 26628 00003B27 E890E2                  		call	find_partition_type
 26629                                  		;pop	bx
 26630                                  		;or	al,al
 26631                                  		;jz	short dp_9
 26632 00003B2A 7205                    		jc	short dp_9
 26633                                  dp_8:
 26634 00003B2C E87300                  		call	dos_delete
 26635 00003B2F EB5A                    		jmp	case_delete_ESC
 26636                                  dp_9:
 26637                                  		;mov	ax,79
 26638                                  		;push	ax
 26639                                  		;mov	ax,17
 26640                                  		;push	ax
 26641                                  		;sub	cx,cx
 26642                                  		;push	cx
 26643                                  		;push	ax
 26644                                  		;call	clear_screen
 26645                                  		;;add	sp,8
 26646                                  
 26647 00003B31 E85E00                  		call	CLS_R17 ; 23/12/2018
 26648                                  
 26649                                  		;push	word [error_6_seg]
 26650 00003B34 1E                      		push	ds
 26651 00003B35 FF36[809E]              		push	word [error_6_off]
 26652 00003B39 EB4A                    		jmp	dp_17
 26653                                  case_delete_2:
 26654 00003B3B B005                    		mov	al,5 ; EXTENDED partition
 26655                                  		;push	ax
 26656 00003B3D E87AE2                  		call	find_partition_type
 26657                                  		;pop	bx
 26658                                  		;or	al,al
 26659                                  		;jz	short dp_11
 26660 00003B40 7205                    		jc	short dp_11
 26661                                  
 26662 00003B42 E83702                  		call	ext_delete
 26663 00003B45 EB44                    		jmp	case_delete_ESC
 26664                                  dp_11:
 26665                                  		;mov	ax,79
 26666                                  		;push	ax
 26667                                  		;mov	ax,17
 26668                                  		;push	ax
 26669                                  		;sub	cx,cx
 26670                                  		;push	cx
 26671                                  		;push	ax
 26672                                  		;call	clear_screen
 26673                                  		;;add	sp,8
 26674                                  
 26675 00003B47 E84800                  		call	CLS_R17 ; 23/12/2018
 26676                                  
 26677                                  		;push	word [error_7_seg]
 26678 00003B4A 1E                      		push	ds
 26679 00003B4B FF36[829E]              		push	word [error_7_off]
 26680 00003B4F EB34                    		jmp	short dp_17
 26681                                  case_delete_3:
 26682 00003B51 B005                    		mov	al,5
 26683                                  		;push	ax
 26684 00003B53 E864E2                  		call	find_partition_type
 26685                                  		;pop	bx
 26686                                  		;or	al, al
 26687                                  		;jz	short dp_13
 26688 00003B56 720A                    		jc	short dp_13
 26689 00003B58 E8C1F4                  		call	find_logical_drive
 26690                                  		;or	al,al
 26691                                  		;jz	short dp_13
 26692 00003B5B 7205                    		jc	short dp_13
 26693 00003B5D E8C802                  		call	volume_delete
 26694 00003B60 EB29                    		jmp	short case_delete_ESC
 26695                                  dp_13:
 26696                                  		;mov	ax,79
 26697                                  		;push	ax
 26698                                  		;mov	ax,17
 26699                                  		;push	ax
 26700                                  		;sub	cx,cx
 26701                                  		;push	cx
 26702                                  		;push	ax
 26703                                  		;call	clear_screen
 26704                                  		;;add	sp,8
 26705                                  
 26706 00003B62 E82D00                  		call	CLS_R17 ; 23/12/2018
 26707                                  
 26708                                  		;push	word [error_36_seg]
 26709 00003B65 1E                      		push	ds
 26710 00003B66 FF36[B89E]              		push	word [error_36_off]
 26711 00003B6A EB19                    		jmp	short dp_17
 26712                                  case_delete_4:
 26713 00003B6C E8A007                  		call	find_non_dos_partition
 26714                                  		;or	al,al
 26715                                  		;jz	short dp_15
 26716 00003B6F 7205                    		jc	short dp_15
 26717 00003B71 E85306                  		call	non_dos_delete
 26718 00003B74 EB15                    		jmp	short case_delete_ESC
 26719                                  dp_15:
 26720                                  		;mov	ax,79
 26721                                  		;push	ax
 26722                                  		;mov	ax,17
 26723                                  		;push	ax
 26724                                  		;sub	cx,cx
 26725                                  		;push	cx
 26726                                  		;push	ax
 26727                                  		;call	clear_screen
 26728                                  		;;add	sp,8
 26729                                  
 26730 00003B76 E81900                  		call	CLS_R17 ; 23/12/2018
 26731                                  
 26732                                  		;push	word [error_38_seg]
 26733 00003B79 1E                      		push	ds
 26734 00003B7A FF36[BC9E]              		push	word [error_38_off]
 26735 00003B7E EB05                    		jmp	short dp_17
 26736                                  dp_16:
 26737                                  		;push	word [error_14_seg]
 26738 00003B80 1E                      		push	ds
 26739 00003B81 FF36[8E9E]              		push	word [error_14_off]
 26740                                  dp_17:
 26741 00003B85 E892DA                  		call	display
 26742                                  		;pop	bx
 26743                                  		;pop	bx
 26744                                  
 26745 00003B88 E8DFF5                  		call	wait_for_ESC
 26746                                  case_delete_ESC:
 26747                                  		;/* clear the screen before going back to main menu */
 26748                                  
 26749                                  		;mov	ax,79
 26750                                  		;push	ax
 26751                                  		;mov	ax,24
 26752                                  		;push	ax
 26753                                  		;sub	ax,ax
 26754                                  		;push	ax
 26755                                  		;push	ax
 26756                                  		;call	clear_screen
 26757                                  
 26758 00003B8B E8D0D8                  		call	CLS
 26759                                  		
 26760 00003B8E 89EC                    		mov	sp,bp
 26761 00003B90 5D                      		pop	bp
 26762 00003B91 C3                      		retn
 26763                                  
 26764                                  CLS_R17:
 26765                                  		; 23/12/2018 (Clear row 17)
 26766 00003B92 B84F00                  		mov	ax,79
 26767 00003B95 50                      		push	ax
 26768 00003B96 B81100                  		mov	ax,17
 26769 00003B99 50                      		push	ax
 26770 00003B9A 29C9                    		sub	cx,cx
 26771 00003B9C 51                      		push	cx
 26772 00003B9D 50                      		push	ax
 26773 00003B9E E8F5D8                  		call	clear_screen
 26774                                  		;add	sp,8
 26775 00003BA1 C3                      		retn
 26776                                  
 26777                                  ; fdisk.msg (MSDOS 6.0)
 26778                                  ;/***************************************************************************************************/
 26779                                  ;/*  Screen for DOS_DELETE                                                                          */
 26780                                  ;/*                                                                                                 */
 26781                                  ;/*     |00000000001111111111222222222233333333334444444444555555555566666666667777777777|          */
 26782                                  ;/*     |01234567890123456789012345678901234567890123456789012345678901234567890123456789|          */
 26783                                  ;/*   --|--------------------------------------------------------------------------------|          */
 26784                                  ;/*   00|                                                                                |          */
 26785                                  ;/*   01|                                                                                |          */
 26786                                  ;/*   02|                                                                                |          */
 26787                                  ;/*   03|                                                                                |          */
 26788                                  ;/*   04|                           Delete Primary DOS Partition                         |menu_28   */
 26789                                  ;/*   05|                                                                                |          */
 26790                                  ;/*   06|    Current fixed disk drive: #                                                 |menu_5 #  */
 26791                                  ;/*   07|                                                                                |          */
 26792                                  ;/*   08|    Partition Status   Type    Size in Mbytes   Percentage of Disk Used         |menu_14 # */
 26793                                  ;/*   09|     ## #        #   #######       ####         ###%                            |menu_14 # */
 26794                                  ;/*   10|     ## #        #   #######       ####         ###%                            |          */
 26795                                  ;/*   11|     ## #        #   #######       ####         ###%                            |          */
 26796                                  ;/*   12|     ## #        #   #######       ####         ###%                            |          */
 26797                                  ;/*   13|                                                                                |          */
 26798                                  ;/*   14|    Total disk space is #### Mbytes (1 Mbyte = 1048576 bytes)                   |menu_15 # */
 26799                                  ;/*   15|                                                                                |          */
 26800                                  ;/*   16|    Warning! Data in the deleted Primary DOS Partition will be lost.            |menu_29   */
 26801                                  ;/*   17|    What Primary DOS Partition do you want to delete? [ ]                       |          */
 26802                                  ;/*   18|                                                                                |          */
 26803                                  ;/*   19|    Do you wish to continue (Y/N).................? [N]                         |menu_56   */
 26804                                  ;/*   20|                                                                                |          */
 26805                                  ;/*   21|                                                                                |          */
 26806                                  ;/*   22|                                                                                |          */
 26807                                  ;/*   23|                                                                                |          */
 26808                                  ;/*   24|    Press ESC to return to FDISK Options                                        |menu_11   */
 26809                                  ;/*   ------------------------------------------------------------------------------------          */ 
 26810                                  ;/*                                                                                                 */
 26811                                  ;/***************************************************************************************************/
 26812                                  
 26813                                  ; d_menus.c (MSDOS 6.0)
 26814                                  ;/*  */
 26815                                  ;/******************* START OF SPECIFICATIONS *******************/
 26816                                  ;/*                                                             */
 26817                                  ;/* SUBROUTINE NAME: DOS_DELETE                                 */
 26818                                  ;/*                                                             */
 26819                                  ;/* DESCRIPTIVE NAME: Delete DOS partition                      */
 26820                                  ;/*                                                             */
 26821                                  ;/* FUNCTION: Delete the DOS partition. Prompt user with dire   */
 26822                                  ;/*           warning first. Default entry on prompt is (N)     */
 26823                                  ;/*                                                             */
 26824                                  ;/* NOTES: Screen can be exited via the ESC command before      */
 26825                                  ;/*        partition is deleted and nothing will change         */
 26826                                  ;/*                                                             */
 26827                                  ;/*        The following screen is managed                      */
 26828                                  ;/*                                                             */
 26829                                  ;/*     |0000000000111111111122222222223333333333|              */
 26830                                  ;/*     |0123456789012345678901234567890123456789|              */
 26831                                  ;/*   --|----------------------------------------|              */
 26832                                  ;/*   00|                                        |              */
 26833                                  ;/*   01|                                        |              */
 26834                                  ;/*   02|                                        |              */
 26835                                  ;/*   03|                                        |              */
 26836                                  ;/*   04|Delete DOS Partition                    |              */
 26837                                  ;/*   05|                                        |              */
 26838                                  ;/*   06|Current Fixed Disk Drive: #             |              */
 26839                                  ;/*   07|                                        |              */
 26840                                  ;/*   08|Partition Status   Type  Start  End Size|              */
 26841                                  ;/*   09|    #        #   #######  #### #### ####|              */
 26842                                  ;/*   10|                                        |              */
 26843                                  ;/*   11|                                        |              */
 26844                                  ;/*   12|                                        |              */
 26845                                  ;/*   13|                                        |              */
 26846                                  ;/*   14|Total disk space is #### cylinders.     |              */
 26847                                  ;/*   15|                                        |              */
 26848                                  ;/*   16|                                        |              */
 26849                                  ;/*   17|                                        |              */
 26850                                  ;/*   18|Warning! Data in the DOS partition      |              */
 26851                                  ;/*   19|will be lost. Do you wish to            |              */
 26852                                  ;/*   20|continue..........................? [N] |              */
 26853                                  ;/*   21|                                        |              */
 26854                                  ;/*   22|                                        |              */
 26855                                  ;/*   23|Press ESC to return to FDISK Options    |              */
 26856                                  ;/*   --------------------------------------------              */
 26857                                  ;/*                                                             */
 26858                                  ;/* ENTRY POINTS: DOS_Delete                                    */
 26859                                  ;/*      LINKAGE: dos_delete                                    */
 26860                                  ;/*          NEAR CALL                                          */
 26861                                  ;/*                                                             */
 26862                                  ;/* INPUT: None                                                 */
 26863                                  ;/*                                                             */
 26864                                  ;/* EXIT-NORMAL: ERROR=FALSE                                    */
 26865                                  ;/*                                                             */
 26866                                  ;/* EXIT-ERROR: ERROR=TRUE                                      */
 26867                                  ;/*             GOTO internal_program_error if invalid input    */
 26868                                  ;/*             returned to this level                          */
 26869                                  ;/*                                                             */
 26870                                  ;/* EFFECTS: No data directly modified by this routine, but     */
 26871                                  ;/*          child routines will modify data.                   */
 26872                                  ;/*                                                             */
 26873                                  ;/* INTERNAL REFERENCES:                                        */
 26874                                  ;/*   ROUTINES                                                  */
 26875                                  ;/*      table_display                                          */
 26876                                  ;/*      clear_screen                                           */
 26877                                  ;/*      wait_for_ESC                                           */
 26878                                  ;/*      get_yn_input                                           */
 26879                                  ;/*      display                                                */
 26880                                  ;/*      Write_Boot_Record                                      */
 26881                                  ;/*      find_part_free_space                                   */
 26882                                  ;/*                                                             */
 26883                                  ;/* EXTERNAL REFERENCES:                                        */
 26884                                  ;/*   ROUTINES:                                                 */
 26885                                  ;/*                                                             */
 26886                                  ;/******************** END OF SPECIFICATIONS ********************/
 26887                                  
 26888                                  ;/*  */
 26889                                  ;void dos_delete()
 26890                                  ;
 26891                                  ;BEGIN
 26892                                  ;
 26893                                  ;    char input;
 26894                                  ;    unsigned i;
 26895                                  ;    unsigned char string_input[12];
 26896                                  ;
 26897                                  ;    int     j;
 26898                                  ;    int     pri;
 26899                                  ;    int     ext;
 26900                                  ;    int     cnt;
 26901                                  ;    int     pnum;
 26902                                  ;
 26903                                  ;    input = c(NUL);
 26904                                  ;    /* clear screen */
 26905                                  ;    clear_screen(u(0),u(0),u(24),u(79));
 26906                                  ;
 26907                                  ;    /* Display header */
 26908                                  ;    display(menu_28);
 26909                                  ;
 26910                                  ;    /* Setup and print current disk */
 26911                                  ;    insert[0] = cur_disk+1+'0';
 26912                                  ;    display(menu_5);
 26913                                  ;
 26914                                  ;    /* print ESC prompt */
 26915                                  ;    display(menu_11);
 26916                                  ;
 26917                                  ;    /* Display partition data and double check if partition exists*/
 26918                                  ;    if (table_display())
 26919                                  ;       BEGIN
 26920                                  ;
 26921                                  ;        sprintf(insert,"%4.0d",total_mbytes[cur_disk]);
 26922                                  ;        display(menu_15);
 26923                                  ;
 26924                                  ;        /* See if drive 1 and extended partition exists */
 26925                                  ;
 26926                                  ;        cnt = 0;
 26927                                  ;        pri = 0;
 26928                                  ;        ext = 0;
 26929                                  ;
 26930                                  ;        /* Find the total number of partitions, the number of normal
 26931                                  ;        /* partitions, and whether there is an extended partition on the
 26932                                  ;        /* current hard disk
 26933                                  ;
 26934                                  ;        for (i = u(0); i < u(4); i++)
 26935                                  ;            if (part_table[cur_disk][i].sys_id != uc(0))
 26936                                  ;               {
 26937                                  ;                cnt++;
 26938                                  ;                if ((part_table[cur_disk][i].sys_id == uc(DOS12)) ||
 26939                                  ;                    (part_table[cur_disk][i].sys_id == uc(DOS16)) ||
 26940                                  ;                    (part_table[cur_disk][i].sys_id == uc(DOSNEW))  )
 26941                                  ;                   {
 26942                                  ;                    pri++;
 26943                                  ;                   }
 26944                                  ;                else if (part_table[cur_disk][i].sys_id == uc(LOGICAL))
 26945                                  ;                   {
 26946                                  ;                    ext = 1;
 26947                                  ;                   }
 26948                                  ;               }
 26949                                  ;
 26950                                  ;        /* The partition can be deleted if the the number of normal          */
 26951                                  ;        /* partitions is greater than one or if there is only one but it is  */
 26952                                  ;        /* not the first hard disk or if there is only one normal partition  */
 26953                                  ;        /* on the first hard disk but no extended partition.                 */
 26954                                  ;
 26955                                  ;        if ((pri > 1) ||
 26956                                  ;            (pri == 1 && cur_disk != c(0)) ||
 26957                                  ;            (pri == 1 && cur_disk == c(0) && !ext))
 26958                                  ;           BEGIN
 26959                                  ;            /* Display partition number prompt */
 26960                                  ;            display(menu_55);
 26961                                  ;
 26962                                  ;            /* Get the partition number from the user */
 26963                                  ;            input = get_num_input(c(1),c(cnt),input_row,input_col);
 26964                                  ;
 26965                                  ;            if (input != ESC)
 26966                                  ;               {
 26967                                  ;                pnum = (int)input - '0';
 26968                                  ;
 26969                                  ;                /* The number that the user has entered is the sorted numbering  */
 26970                                  ;                /* of the partition table. We have to retrieve the actual        */
 26971                                  ;                /* position of this partition in the partition table             */
 26972                                  ;
 26973                                  ;                j = 0;
 26974                                  ;                for (i = 0; i < 4; i++)
 26975                                  ;                   {
 26976                                  ;                    if (part_table[cur_disk][sort[i]].sys_id != 0)
 26977                                  ;                       {
 26978                                  ;                        j++;
 26979                                  ;                        if (j == pnum)
 26980                                  ;                            break;
 26981                                  ;                       }
 26982                                  ;                   };
 26983                                  ;                i = sort[i];
 26984                                  ;
 26985                                  ;                /* Verify selected partition is a primary partition */
 26986                                  ;
 26987                                  ;                if ((part_table[cur_disk][i].sys_id==uc(DOS12)) ||
 26988                                  ;                    (part_table[cur_disk][i].sys_id==uc(DOS16)) ||
 26989                                  ;                    (part_table[cur_disk][i].sys_id==uc(DOSNEW)) )
 26990                                  ;                   {
 26991                                  ;                    /* delete previous volume mismatch message */
 26992                                  ;                    string_input[0] = uc(NUL);
 26993                                  ;
 26994                                  ;                    /* Get input volume label */
 26995                                  ;                    display(menu_41);
 26996                                  ;                    get_string_input(input_row,input_col,string_input);
 26997                                  ;                    if (string_input[0] != uc(ESC))
 26998                                  ;                       {
 26999                                  ;                        /* See if the volume id matches the drive */
 27000                                  ;                        if (strcmp(part_table[cur_disk][i].vol_label,
 27001                                  ;                            string_input) == (int)ZERO)
 27002                                  ;                           {
 27003                                  ;                            /* Display Y/N prompt */
 27004                                  ;                            display(menu_34);
 27005                                  ;
 27006                                  ;                            /* Get yes/no prompt */
 27007                                  ;                            input = get_yn_input(c(No),input_row,input_col);
 27008                                  ;                            switch(input)
 27009                                  ;                               BEGIN
 27010                                  ;                                case 1:
 27011                                  ;                                   BEGIN
 27012                                  ;                                    /* Set Partition entry to zero */
 27013                                  ;                                    remove_partition(cur_disk,i);
 27014                                  ;
 27015                                  ;                                    /* Redisplay the partition info */
 27016                                  ;                                    table_display();
 27017                                  ;
 27018                                  ;                                    /* clear the prompt off */
 27019                                  ;                                    clear_screen(u(16),u(0),u(23),u(79));
 27020                                  ;
 27021                                  ;                                    /* Set the reboot flag */
 27022                                  ;                                    reboot_flag = (FLAG)TRUE;
 27023                                  ;
 27024                                  ;                                    /* Say that you deleted it */
 27025                                  ;                                    display(status_1);
 27026                                  ;
 27027                                  ;                                    wait_for_ESC();
 27028                                  ;                                    break;
 27029                                  ;                                   END
 27030                                  ;
 27031                                  ;                                case 0:
 27032                                  ;                                    break;
 27033                                  ;
 27034                                  ;                                case ESC:
 27035                                  ;                                    break;
 27036                                  ;
 27037                                  ;                                default:
 27038                                  ;                                   BEGIN
 27039                                  ;                                    internal_program_error();
 27040                                  ;                                    break;
 27041                                  ;                                   END
 27042                                  ;                               END
 27043                                  ;                           }
 27044                                  ;                        else
 27045                                  ;                           {
 27046                                  ;                            /* Tell user volume name was incorrect */
 27047                                  ;                            display(error_34);
 27048                                  ;                            wait_for_ESC();
 27049                                  ;                           }
 27050                                  ;                       }
 27051                                  ;                   }
 27052                                  ;                else
 27053                                  ;                   {
 27054                                  ;                    /* Tell user he can only delete primary partition */
 27055                                  ;                    display(error_37);
 27056                                  ;                    wait_for_ESC();
 27057                                  ;                   }
 27058                                  ;               }
 27059                                  ;           END
 27060                                  ;        else
 27061                                  ;           BEGIN
 27062                                  ;            /* Tell user he can't do it while extended exists on drive 1 */
 27063                                  ;            display(error_32);
 27064                                  ;            wait_for_ESC();
 27065                                  ;           END
 27066                                  ;       END
 27067                                  ;
 27068                                  ;    else
 27069                                  ;       BEGIN
 27070                                  ;        internal_program_error();
 27071                                  ;       END
 27072                                  ;    clear_screen(u(0),u(0),u(24),u(79));
 27073                                  ;    return;
 27074                                  ;END
 27075                                  
 27076                                  dos_delete:
 27077                                  		; 23/12/2018
 27078                                  
 27079                                  	%define ddp_pri	      bp-24 ;bp-26
 27080                                  	%define ddp_j	      bp-22 ;bp-24
 27081                                  	%define ddp_i	      bp-20 ;bp-22
 27082                                  	%define ddp_str_input bp-18 ;bp-20
 27083                                  	%define ddp_cnt	      bp-6  ;bp-8
 27084                                  	%define ddp_ext	      bp-4  ;bp-6
 27085                                  	%define ddp_input     	    ;bp-4
 27086                                  	%define ddp_pnum      bp-2  ;bp-2
 27087                                  
 27088 00003BA2 55                      		push	bp
 27089 00003BA3 89E5                    		mov	bp,sp
 27090                                  		;sub	sp,26
 27091 00003BA5 83EC18                  		sub	sp,24 ; 24/12/2018
 27092                                  
 27093                                  		;mov	word [ddp_input],0
 27094                                  		
 27095                                  		;/* clear screen */
 27096                                  
 27097                                  		;mov	ax,79
 27098                                  		;push	ax
 27099                                  		;mov	ax,24
 27100                                  		;push	ax
 27101                                  		;sub	ax,ax
 27102                                  		;push	ax
 27103                                  		;push	ax
 27104                                  		;call	clear_screen
 27105                                  		;add	sp,8
 27106                                  
 27107 00003BA8 E8B3D8                  		call	CLS
 27108                                  
 27109                                  		;/* Display header */
 27110                                  
 27111                                  		;push	word [menu_28_segment]
 27112 00003BAB 1E                      		push	ds
 27113 00003BAC FF36[2D9E]              		push	word [menu_28_offset]
 27114 00003BB0 E867DA                  		call	display
 27115                                  		;pop	bx
 27116                                  		;pop	bx
 27117                                  
 27118                                  		;/* Setup and print current disk */
 27119                                  
 27120                                  		;mov	al,[cur_disk]
 27121                                  		;add	al,'1'
 27122                                  		;mov	[insert],al
 27123                                  		;;push	word [menu_5_segment]
 27124                                  		;push	ds
 27125                                  		;push	word [menu_5_offset]
 27126                                  		;call	display
 27127                                  		;;pop	bx
 27128                                  		;;pop	bx
 27129                                  
 27130 00003BB3 E89DF2                  		call	display_menu_5 ; 31/12/2018
 27131                                  		
 27132                                  		;/* print ESC prompt */
 27133                                  
 27134                                  		;;push	word [menu_11_segment]
 27135                                  		;push	ds
 27136                                  		;push	word [menu_11_offset]
 27137                                  		;call	display
 27138                                  		;;pop	bx
 27139                                  		;;pop	bx
 27140                                  
 27141 00003BB6 E8ABF2                  		call	display_menu_11 ; 31/12/2018
 27142                                  
 27143                                  	;/* Display partition data and double check if partition exists */
 27144                                  
 27145 00003BB9 E8B1F2                  		call	table_display
 27146                                  		;or	al,al
 27147                                  		;jnz	short ddp_1
 27148 00003BBC 7303                    		jnc	short ddp_1
 27149 00003BBE E99601                  		jmp	case_dos_del_DEF
 27150                                  ddp_1:
 27151                                  		;;mov	al,[cur_disk]
 27152                                  		;;cbw
 27153                                  		;;mov	bx,ax
 27154                                  		;mov	bl,[cur_disk]
 27155                                  		;xor	bh,bh
 27156                                  		;shl	bx,1
 27157                                  		;push	word [total_mbytes+bx]
 27158                                  		;mov	ax,disk_size_format ; "%4.1d"
 27159                                  		;push	ax
 27160                                  		;mov	ax,insert
 27161                                  		;push	ax
 27162                                  		;call	sprintf
 27163                                  		;add	sp,6
 27164                                  
 27165 00003BC1 E89D01                  		call	sprintf_total_mbytes ; 24/12/2018
 27166                                  
 27167                                  		;push	word [menu_15_segment]
 27168 00003BC4 1E                      		push	ds
 27169 00003BC5 FF36[059E]              		push	word [menu_15_offset]
 27170 00003BC9 E84EDA                  		call	display
 27171                                  		;pop	bx
 27172                                  		;pop	bx
 27173                                  
 27174                                  		;/* See if drive 1 and extended partition exists */
 27175                                  
 27176 00003BCC 29C0                    		sub	ax,ax
 27177 00003BCE 8846FA                  		mov	[ddp_cnt],al ; 0
 27178 00003BD1 8846E8                  		mov	[ddp_pri],al ; 0
 27179 00003BD4 8846FC                  		mov	[ddp_ext],al ; 0
 27180                                  
 27181                                  	;/* Find the total number of partitions, the number of normal */
 27182                                  	;/* partitions, and whether there is an extended partition on the */
 27183                                  	;/* current hard disk */
 27184                                  
 27185 00003BD7 8946EC                  		mov	[ddp_i],ax ; 0
 27186 00003BDA EB11                    		jmp	short ddp_4
 27187                                  ddp_2:
 27188                                  		;mov	al,[cur_disk]
 27189                                  		;;cbw
 27190                                  		;;shl	ax,1
 27191                                  		;;shl	ax,1
 27192                                  		;;add	ax,[ddp_i]
 27193                                  		;shl	al,1
 27194                                  		;shl	al,1
 27195                                  		;add	al,[ddp_i]
 27196                                  		;;mul	cx
 27197                                  		;mul	cl
 27198                                  		;;mov	bx,ax
 27199                                  		
 27200                                  		;mov	al,[part_table_sys_id+bx]
 27201                                  		;cmp	byte [part_table_sys_id+bx],5 ; EXTENTED
 27202 00003BDC 3C05                    		cmp	al,5
 27203 00003BDE 7504                    		jne	short ddp_3 
 27204 00003BE0 C646FC01                		mov	byte [ddp_ext],1 ;  TRUE
 27205                                  ddp_3:
 27206 00003BE4 FE46EC                  		inc	byte [ddp_i]
 27207                                  ;ddp_4:
 27208 00003BE7 807EEC04                		cmp	byte [ddp_i],4
 27209 00003BEB 732C                    		jnb	short ddp_6
 27210                                  ddp_4:
 27211 00003BED A0[D4CB]                		mov	al,[cur_disk]
 27212                                  		;cbw
 27213                                  		;shl	ax,1
 27214                                  		;shl	ax,1
 27215 00003BF0 D0E0                    		shl	al,1
 27216 00003BF2 D0E0                    		shl	al,1
 27217                                  		;add	ax,[ddp_i]
 27218 00003BF4 0246EC                  		add	al,[ddp_i]
 27219                                  		;mov	cx,46
 27220                                  		;mul	cx
 27221 00003BF7 B12E                    		mov	cl,46
 27222 00003BF9 F6E1                    		mul	cl
 27223 00003BFB 89C3                    		mov	bx,ax
 27224                                  		
 27225 00003BFD 8A87[17C4]              		mov	al,[part_table_sys_id+bx]
 27226                                  		;cmp	byte [part_table_sys_id+bx],0
 27227                                  		;je	short ddp_3
 27228 00003C01 20C0                    		and	al,al
 27229 00003C03 74DF                    		jz	short ddp_3
 27230 00003C05 FE46FA                  		inc	byte [ddp_cnt]
 27231                                  		;cmp	byte [part_table_sys_id+bx],1
 27232 00003C08 3C01                    		cmp	al,1
 27233 00003C0A 7408                    		je	short ddp_5
 27234                                  		;cmp	byte [part_table_sys_id+bx],4
 27235 00003C0C 3C04                    		cmp	al,4
 27236 00003C0E 7404                    		je	short ddp_5
 27237                                  		;cmp	byte [part_table_sys_id+bx],6
 27238 00003C10 3C06                    		cmp	al,6
 27239 00003C12 75C8                    		jne	short ddp_2
 27240                                  ddp_5:
 27241 00003C14 FE46E8                  		inc	byte [ddp_pri]
 27242 00003C17 EBCB                    		jmp	short ddp_3
 27243                                  ddp_6:
 27244                                  	;/* The partition can be deleted if the the number of normal */
 27245                                  	;/* partitions is greater than one or if there is only one but it is */
 27246                                  	;/* not the first hard disk or if there is only one normal partition */
 27247                                  	;/* on the first hard disk but no extended partition. */
 27248                                  
 27249 00003C19 807EE801                		cmp	byte [ddp_pri],1
 27250 00003C1D 7F11                    		jg	short ddp_10
 27251                                  		;jne	short ddp_7
 27252 00003C1F 0F858600                		jne	ddp_21
 27253 00003C23 803E[D4CB]00            		cmp	byte [cur_disk],0
 27254 00003C28 7506                    		jne	short ddp_10
 27255                                  ;ddp_7:
 27256                                  		;cmp	byte [ddp_pri],1
 27257                                  		;;je	short ddp_8
 27258                                  		;;jmp	short ddp_21
 27259                                  		;jne	short ddp_21
 27260                                  ;ddp_8:
 27261                                  		;cmp	byte [cur_disk],0
 27262                                  		;;jne	short ddp_9
 27263                                  		;jne	short ddp_21
 27264 00003C2A 807EFC00                		cmp	byte [ddp_ext],0
 27265                                  		;je	short ddp_10
 27266 00003C2E 7579                    		jne	short ddp_21
 27267                                  ;ddp_9:
 27268                                  		;jmp	short ddp_21
 27269                                  ddp_10:
 27270                                  		;/* Display partition number prompt */
 27271                                  
 27272                                  		;push	word [menu_55_segment]
 27273 00003C30 1E                      		push	ds
 27274 00003C31 FF36[2F9E]              		push	word [menu_55_offset]
 27275 00003C35 E8E2D9                  		call	display
 27276                                  		;pop	bx
 27277                                  		;pop	bx
 27278                                  
 27279                                  		;/* Get the partition number from the user */
 27280                                  
 27281 00003C38 FF36[9CA0]              		push	word [input_col]
 27282 00003C3C FF36[3EA1]              		push	word [input_row]
 27283 00003C40 8A46FA                  		mov	al,[ddp_cnt] ; Maximum input number
 27284 00003C43 50                      		push	ax
 27285 00003C44 B001                    		mov	al,1	; Default input number	
 27286 00003C46 50                      		push	ax
 27287 00003C47 E820EE                  		call	get_num_input
 27288                                  		;add	sp,8
 27289                                  		;mov	[ddp_input],al
 27290                                  
 27291 00003C4A 3C1B                    		cmp	al,1Bh	; ESCape key
 27292 00003C4C 7503                    		jne	short ddp_11
 27293 00003C4E E90901                  		jmp	dos_del_break
 27294                                  ddp_11:
 27295                                  		;cbw
 27296                                  		;sub	ax,'0'
 27297 00003C51 2C30                    		sub	al,'0'
 27298                                  		;mov	[ddp_pnum],ax
 27299 00003C53 8846FE                  		mov	[ddp_pnum],al
 27300                                  
 27301                                  	;/* The number that the user has entered is the sorted numbering */
 27302                                  	;/* of the partition table. We have to retrieve the actual */
 27303                                  	;/* position of this partition in the partition table */
 27304                                  
 27305 00003C56 C646EA00                		mov	byte [ddp_j],0
 27306 00003C5A C646EC00                		mov	byte [ddp_i],0
 27307 00003C5E B12E                    		mov	cl,46 ; 24/12/2018
 27308 00003C60 EB0B                    		jmp	short ddp_13
 27309                                  ddp_12:
 27310 00003C62 FE46EC                  		inc	byte [ddp_i]
 27311                                  ;ddp_13:
 27312 00003C65 807EEC04                		cmp	byte [ddp_i],4
 27313                                  		;jnb	short ddp_14
 27314 00003C69 0F83E300                		jnb	ddp_20 ; 24/12/2018 
 27315                                  ddp_13:
 27316 00003C6D A0[D4CB]                		mov	al,[cur_disk]
 27317                                  		;cbw
 27318                                  		;shl	ax,1
 27319                                  		;shl	ax,1
 27320 00003C70 D0E0                    		shl	al,1
 27321 00003C72 D0E0                    		shl	al,1
 27322 00003C74 8B5EEC                  		mov	bx,[ddp_i]
 27323                                  		;mov	cx,ax
 27324                                  		;mov	al,[sort+bx]
 27325                                  		;cbw
 27326 00003C77 8A97[E2C3]              		mov	dl,[sort+bx]  ; *--*
 27327                                  		;add	ax,cx
 27328 00003C7B 00D0                    		add	al,dl
 27329                                  		;mov	cx,46
 27330                                  		;mul	cx
 27331                                  		;mov	cl,46
 27332 00003C7D F6E1                    		mul	cl
 27333 00003C7F 89C3                    		mov	bx,ax
 27334                                  
 27335 00003C81 80BF[17C4]00            		cmp	byte [part_table_sys_id+bx],0
 27336 00003C86 74DA                    		je	short ddp_12
 27337                                  		;mov	ax,[ddp_pnum]
 27338 00003C88 8A46FE                  		mov	al,[ddp_pnum]
 27339 00003C8B FE46EA                  		inc	byte [ddp_j]
 27340                                  		;cmp	[ddp_j],ax
 27341 00003C8E 3846EA                  		cmp	[ddp_j],al
 27342 00003C91 75CF                    		jne	short ddp_12
 27343                                  ;ddp_14:
 27344                                  		;mov	al,[cur_disk]
 27345                                  		;;cbw
 27346                                  		;;shl	ax,1
 27347                                  		;;shl	ax,1
 27348                                  		;shl	al,1
 27349                                  		;shl	al,1
 27350                                  		;mov	bx,[ddp_i]
 27351                                  		;;mov	cx,ax
 27352                                  		;;mov	al,[sort+bx]
 27353                                  		;;cbw
 27354                                  		;;mov	[ddp_i],ax
 27355                                  		;;add	ax,cx
 27356                                  		;mov	dl,[sort+bx]
 27357                                  		;add	al,dl
 27358                                  		;;mov	cx,46
 27359                                  		;;mul	cx
 27360                                  		;mov	cl,46
 27361                                  		;mul	cl
 27362                                  		;mov	bx,ax
 27363                                  		
 27364                                  		; i = sort[i]
 27365 00003C93 8856EC                  		mov	[ddp_i],dl ; *--*
 27366                                  
 27367                                  		;/* Verify selected partition is a primary partition */
 27368                                  
 27369 00003C96 8A87[17C4]              		mov	al,[part_table_sys_id+bx]
 27370                                  		;cmp	byte [part_table_sys_id+bx],1
 27371 00003C9A 3C01                    		cmp	al,1 ; DOS12
 27372 00003C9C 7413                    		je	short ddp_15
 27373                                  		;cmp	byte [part_table_sys_id+bx],4
 27374 00003C9E 3C04                    		cmp	al,4 ; DOS16
 27375 00003CA0 740F                    		je	short ddp_15
 27376                                  		;cmp	byte [part_table_sys_id+bx],6
 27377 00003CA2 3C06                    		cmp	al,6 ; DOSNEW
 27378 00003CA4 740B                    		je	short ddp_15
 27379 00003CA6 E9A700                  		jmp	ddp_20
 27380                                  ddp_21:
 27381                                  		;/* Tell user he can't do it while extended exists on drive 1 */
 27382                                  
 27383                                  		;push	word [error_32_seg]
 27384 00003CA9 1E                      		push	ds
 27385 00003CAA FF36[B09E]              		push	word [error_32_off]
 27386 00003CAE E99000                  		jmp	ddp_18
 27387                                  ddp_15:
 27388                                  		;/* delete privious volume mismatch message */
 27389                                  
 27390 00003CB1 C646EE00                		mov	byte [ddp_str_input],0
 27391                                  
 27392                                  		;/* Get input volume label */
 27393                                  
 27394                                  		;push	word [menu_41_segment]
 27395 00003CB5 1E                      		push	ds
 27396 00003CB6 FF36[3D9E]              		push	word [menu_41_offset]
 27397 00003CBA E85DD9                  		call	display
 27398                                  		;pop	bx
 27399                                  		;pop	bx
 27400                                  		
 27401 00003CBD 8D46EE                  		lea	ax,[ddp_str_input]
 27402 00003CC0 16                      		push	ss
 27403 00003CC1 50                      		push	ax
 27404 00003CC2 FF36[9CA0]              		push	word [input_col]
 27405 00003CC6 FF36[3EA1]              		push	word [input_row]
 27406 00003CCA E8CC06                  		call	get_string_input
 27407                                  		;add	sp,8
 27408 00003CCD 807EEE1B                		cmp	byte [ddp_str_input],1Bh ; ESC key
 27409 00003CD1 7503                    		jne	short ddp_16
 27410 00003CD3 E98400                  		jmp	dos_del_break
 27411                                  ddp_16:
 27412                                  		;/* See if the volume id matches the drive */
 27413                                  
 27414                                  		;lea	ax,[ddp_str_input]
 27415                                  		;push	ax
 27416                                  	
 27417 00003CD6 8D7EEE                  		lea	di,[ddp_str_input] ; dst
 27418                                  
 27419 00003CD9 A0[D4CB]                		mov	al,[cur_disk]
 27420                                  		;cbw
 27421                                  		;shl	ax,1
 27422                                  		;shl	ax,1
 27423 00003CDC D0E0                    		shl	al,1
 27424 00003CDE D0E0                    		shl	al,1
 27425                                  		;add	ax,[ddp_i]
 27426 00003CE0 0246EC                  		add	al,[ddp_i]
 27427                                  		;mov	cx,46
 27428                                  		;mul	cx
 27429 00003CE3 B12E                    		mov	cl,46
 27430 00003CE5 F6E1                    		mul	cl
 27431 00003CE7 89C6                    		mov	si,ax
 27432                                  
 27433                                  		;add	ax,part_table_vol_label
 27434                                  		;push	ax
 27435 00003CE9 81C6[2AC4]              		add	si,part_table_vol_label ; src
 27436                                  
 27437 00003CED E89406                  		call	strcmp
 27438                                  		;pop	bx
 27439                                  		;pop	bx
 27440 00003CF0 09C0                    		or	ax,ax
 27441 00003CF2 7555                    		jnz	short ddp_19
 27442                                  		
 27443                                  		;/* Display Y/N prompt */
 27444                                  
 27445                                  		;push	word [menu_34_segment]
 27446 00003CF4 1E                      		push	ds
 27447 00003CF5 FF36[3B9E]              		push	word [menu_34_offset]
 27448 00003CF9 E81ED9                  		call	display
 27449                                  		;pop	bx
 27450                                  		;pop	bx
 27451                                  
 27452                                  		;/* Get yes/no prompt */
 27453                                  
 27454 00003CFC FF36[9CA0]              		push	word [input_col]
 27455 00003D00 FF36[3EA1]              		push	word [input_row]
 27456 00003D04 A0[9EA0]                		mov	al,[No] ; 'N'	; Default input value/char
 27457 00003D07 50                      		push	ax
 27458 00003D08 E839F3                  		call	get_yn_input	; Get YES ('Y'), NO ('N') input
 27459                                  		;add	sp,6
 27460                                  ddp_17:
 27461                                  		;mov	[ddp_input],al  ; 1 = Yes, 0 = No
 27462                                  		;cbw
 27463                                  		;cmp	ax,1Bh  ; ESC key
 27464 00003D0B 3C1B                    		cmp	al,1Bh
 27465 00003D0D 744B                    		je	short dos_del_break
 27466 00003D0F 7746                    		ja	short case_dos_del_DEF
 27467 00003D11 08C0                    		or	al,al
 27468 00003D13 7445                    		jz	short dos_del_break ; 'N'
 27469 00003D15 FEC8                    		dec	al
 27470 00003D17 753E                    		jnz	short case_dos_del_DEF ; neither 'Y' or 'N'
 27471                                  		; 'Y'
 27472                                  case_dos_del_1:
 27473                                  		;/* Set Partition entry to zero */
 27474                                  
 27475                                  		;push	word [ddp_i]
 27476                                  		; 02/01/2019
 27477 00003D19 8A66EC                  		mov	ah,[ddp_i] ; Partition entry number
 27478 00003D1C A0[D4CB]                		mov	al,[cur_disk]
 27479                                  		;push	ax
 27480 00003D1F E83C0A                  		call	remove_partition
 27481                                  		;pop	bx
 27482                                  		;pop	bx
 27483                                  
 27484                                  		;/* Redisplay the partition info */
 27485                                  
 27486 00003D22 E848F1                  		call	table_display
 27487                                  		
 27488                                  		;/* clear the prompt off */
 27489                                  
 27490 00003D25 B84F00                  		mov	ax,79
 27491 00003D28 50                      		push	ax
 27492 00003D29 B81700                  		mov	ax,23
 27493 00003D2C 50                      		push	ax
 27494 00003D2D 29C0                    		sub	ax,ax
 27495 00003D2F 50                      		push	ax
 27496 00003D30 B81000                  		mov	ax,16
 27497 00003D33 50                      		push	ax
 27498 00003D34 E85FD7                  		call	clear_screen
 27499                                  		;add	sp,8
 27500                                  
 27501                                  		;/* Set the reboot flag */
 27502                                  
 27503 00003D37 C606[6AA0]01            		mov	byte [reboot_flag],1  ; TRUE
 27504                                  
 27505                                  		;/* Say that you deleted it */
 27506                                  
 27507                                  		;push	word [status_1_seg]
 27508 00003D3C 1E                      		push	ds
 27509 00003D3D FF36[5D9E]              		push	word [status_1_off]
 27510                                  ddp_18:
 27511 00003D41 E8D6D8                  		call	display
 27512                                  		;pop	bx
 27513                                  		;pop	bx
 27514 00003D44 E823F4                  		call	wait_for_ESC
 27515 00003D47 EB11                    		jmp	short dos_del_break
 27516                                  ddp_19:
 27517                                  		;/* Tell user volume name was incorrect */
 27518                                  
 27519                                  		;push	word [error_34_seg]
 27520 00003D49 1E                      		push	ds
 27521 00003D4A FF36[B49E]              		push	word [error_34_off]
 27522 00003D4E EBF1                    		jmp	short ddp_18
 27523                                  ddp_20:
 27524                                  		;/* Tell user he can only delete primary partition */
 27525                                  	
 27526                                  		;push	word [error_37_seg]
 27527 00003D50 1E                      		push	ds
 27528 00003D51 FF36[BA9E]              		push	word [error_37_off]
 27529 00003D55 EBEA                    		jmp	short ddp_18
 27530                                  ;ddp_21:
 27531                                  ;		;push	word [error_32_seg]
 27532                                  ;		push	ds
 27533                                  ;		push	word [error_32_off]
 27534                                  ;		jmp	short ddp_18
 27535                                  case_dos_del_DEF:
 27536 00003D57 E8B7F5                  		call	internal_program_error
 27537                                  dos_del_break:
 27538                                  		;mov	ax,79
 27539                                  		;push	ax
 27540                                  		;mov	ax,24
 27541                                  		;push	ax
 27542                                  		;sub	ax,ax
 27543                                  		;push	ax
 27544                                  		;push	ax
 27545                                  		;call	clear_screen
 27546                                  
 27547 00003D5A E801D7                  		call	CLS
 27548                                  
 27549 00003D5D 89EC                    		mov	sp,bp
 27550 00003D5F 5D                      		pop	bp
 27551 00003D60 C3                      		retn
 27552                                  
 27553                                  sprintf_total_mbytes:
 27554                                  		; 24/12/2018
 27555                                  
 27556                                  		;mov	al,[cur_disk]
 27557                                  		;cbw
 27558                                  		;mov	bx,ax
 27559 00003D61 8A1E[D4CB]              		mov	bl,[cur_disk]
 27560 00003D65 30FF                    		xor	bh,bh
 27561 00003D67 D1E3                    		shl	bx,1
 27562 00003D69 FFB7[C8A0]              		push	word [total_mbytes+bx]
 27563 00003D6D B8[846F]                		mov	ax,disk_size_format ; "%4.1d"
 27564 00003D70 50                      		push	ax
 27565 00003D71 B8[E6CC]                		mov	ax,insert
 27566 00003D74 50                      		push	ax
 27567 00003D75 E843E5                  		call	sprintf
 27568 00003D78 83C406                  		add	sp,6
 27569 00003D7B C3                      		retn
 27570                                  
 27571                                  ; fdisk.msg (MSDOS 6.0)
 27572                                  ;/***************************************************************************************************/
 27573                                  ;/*  Screen for EXT_DELETE                                                                          */
 27574                                  ;/*                                                                                                 */
 27575                                  ;/*     |00000000001111111111222222222233333333334444444444555555555566666666667777777777|          */
 27576                                  ;/*     |01234567890123456789012345678901234567890123456789012345678901234567890123456789|          */
 27577                                  ;/*   --|--------------------------------------------------------------------------------|          */
 27578                                  ;/*   00|                                                                                |          */
 27579                                  ;/*   01|                                                                                |          */
 27580                                  ;/*   02|                                                                                |          */
 27581                                  ;/*   03|                                                                                |          */
 27582                                  ;/*   04|                           Delete Extended DOS Partition                        |menu_30   */
 27583                                  ;/*   05|                                                                                |          */
 27584                                  ;/*   06|    Current fixed disk drive: #                                                 |menu_5 #  */
 27585                                  ;/*   07|                                                                                |          */
 27586                                  ;/*   08|    Partition Status   Type    Size in Mbytes   Percentage of Disk Used         |menu_14 # */
 27587                                  ;/*   09|     ## #        #   #######       ####         ###%                            |menu_14 # */
 27588                                  ;/*   10|     ## #        #   #######       ####         ###%                            |          */
 27589                                  ;/*   11|     ## #        #   #######       ####         ###%                            |          */
 27590                                  ;/*   12|     ## #        #   #######       ####         ###%                            |          */
 27591                                  ;/*   13|                                                                                |          */
 27592                                  ;/*   14|    Total disk space is #### Mbytes (1 Mbyte = 1048576 bytes)                   |menu_15 # */
 27593                                  ;/*   15|                                                                                |          */
 27594                                  ;/*   16|    Warning! Data in the deleted Extended DOS partition will be lost.           |menu_31   */
 27595                                  ;/*   17|    Do you wish to continue (Y/N).................? [N]                         |menu_31   */
 27596                                  ;/*   18|                                                                                |          */
 27597                                  ;/*   19|                                                                                |          */
 27598                                  ;/*   20|                                                                                |          */
 27599                                  ;/*   21|                                                                                |          */
 27600                                  ;/*   22|                                                                                |          */
 27601                                  ;/*   23|                                                                                |          */
 27602                                  ;/*   24|    Press ESC to return to FDISK Options                                        |menu_11   */
 27603                                  ;/*   ------------------------------------------------------------------------------------          */ 
 27604                                  ;/*                                                                                                 */
 27605                                  ;/***************************************************************************************************/
 27606                                  
 27607                                  ; d_menus.c (MSDOS 6.0)
 27608                                  ;/*  */
 27609                                  ;/******************* START OF SPECIFICATIONS *******************/
 27610                                  ;/*                                                             */
 27611                                  ;/* SUBROUTINE NAME: EXT_DELETE                                 */
 27612                                  ;/*                                                             */
 27613                                  ;/* DESCRIPTIVE NAME: Delete EXTENDED DOS partition             */
 27614                                  ;/*                                                             */
 27615                                  ;/* FUNCTION: Delete the EXTENDED DOS partition. Prompt with    */
 27616                                  ;/*           warning first. Default entry on prompt is (N)     */
 27617                                  ;/*                                                             */
 27618                                  ;/* NOTES: Screen can be exited via the ESC command before      */
 27619                                  ;/*        partition is deleted and nothing will change         */
 27620                                  ;/*                                                             */
 27621                                  ;/*        The following screen is managed                      */
 27622                                  ;/*                                                             */
 27623                                  ;/*     |0000000000111111111122222222223333333333|              */
 27624                                  ;/*     |0123456789012345678901234567890123456789|              */
 27625                                  ;/*   --|----------------------------------------|              */
 27626                                  ;/*   00|                                        |              */
 27627                                  ;/*   01|                                        |              */
 27628                                  ;/*   02|                                        |              */
 27629                                  ;/*   03|                                        |              */
 27630                                  ;/*   04|Delete EXTENDED DOS Partition           |              */
 27631                                  ;/*   05|                                        |              */
 27632                                  ;/*   06|Current Fixed Disk Drive: #             |              */
 27633                                  ;/*   07|                                        |              */
 27634                                  ;/*   08|Partition Status   Type  Start  End Size|              */
 27635                                  ;/*   09|    #        #   #######  #### #### ####|              */
 27636                                  ;/*   10|                                        |              */
 27637                                  ;/*   11|                                        |              */
 27638                                  ;/*   12|                                        |              */
 27639                                  ;/*   13|                                        |              */
 27640                                  ;/*   14|Total disk space is #### cylinders.     |              */
 27641                                  ;/*   15|                                        |              */
 27642                                  ;/*   16|                                        |              */
 27643                                  ;/*   17|                                        |              */
 27644                                  ;/*   18|Warning! Data in the EXTENDED DOS       |              */
 27645                                  ;/*   19|partition will be lost. Do you wish     |              */
 27646                                  ;/*   20|to continue.......................? [N] |              */
 27647                                  ;/*   21|                                        |              */
 27648                                  ;/*   22|                                        |              */
 27649                                  ;/*   23|Press ESC to return to FDISK Options    |              */
 27650                                  ;/*   --------------------------------------------              */
 27651                                  ;/*                                                             */
 27652                                  ;/* ENTRY POINTS: Ext_Delete                                    */
 27653                                  ;/*      LINKAGE: ext_delete ()                                 */
 27654                                  ;/*          NEAR CALL                                          */
 27655                                  ;/*                                                             */
 27656                                  ;/* INPUT: None                                                 */
 27657                                  ;/*                                                             */
 27658                                  ;/* EXIT-NORMAL: ERROR=FALSE                                    */
 27659                                  ;/*                                                             */
 27660                                  ;/* EXIT-ERROR: ERROR=TRUE                                      */
 27661                                  ;/*             GOTO internal_program_error if invalid input    */
 27662                                  ;/*             returned to this routine                        */
 27663                                  ;/*                                                             */
 27664                                  ;/* EFFECTS: No data directly modified by this routine, but     */
 27665                                  ;/*          child routines will modify data.                   */
 27666                                  ;/*                                                             */
 27667                                  ;/* INTERNAL REFERENCES:                                        */
 27668                                  ;/*   ROUTINES:                                                 */
 27669                                  ;/*      table_display                                          */
 27670                                  ;/*      clear_screen                                           */
 27671                                  ;/*      wait_for_ESC                                           */
 27672                                  ;/*      get_yn_input                                           */
 27673                                  ;/*      display                                                */
 27674                                  ;/*      Write_Boot_Record                                      */
 27675                                  ;/*      Internal_Program_Error                                 */
 27676                                  ;/*      Find_Free_Space                                        */
 27677                                  ;/*                                                             */
 27678                                  ;/* EXTERNAL REFERENCES:                                        */
 27679                                  ;/*   ROUTINES:                                                 */
 27680                                  ;/*                                                             */
 27681                                  ;/******************** END OF SPECIFICATIONS ********************/
 27682                                  
 27683                                  ;/*  */
 27684                                  ;void ext_delete()
 27685                                  ;
 27686                                  ;BEGIN
 27687                                  ;
 27688                                  ;    char   input;
 27689                                  ;    unsigned i;
 27690                                  ;
 27691                                  ;    input = c(NUL);
 27692                                  ;    /* Clear the screen */
 27693                                  ;    clear_screen(u(0),u(0),u(24),u(79));
 27694                                  ;
 27695                                  ;    /* Display header */
 27696                                  ;    display(menu_30);
 27697                                  ;
 27698                                  ;    /* Setup and print current disk */
 27699                                  ;    insert[0] = cur_disk+1+'0';
 27700                                  ;    display(menu_5);
 27701                                  ;
 27702                                  ;    /* print ESC prompt */
 27703                                  ;    display(menu_11);
 27704                                  ;
 27705                                  ;    /* Display partition data and double check if partition exists*/
 27706                                  ;    table_display();
 27707                                  ;    sprintf(insert,"%4.0d",total_mbytes[cur_disk]);
 27708                                  ;    display(menu_15);
 27709                                  ;
 27710                                  ;       BEGIN
 27711                                  ;        /* See if there are still volumes */
 27712                                  ;        if (!find_logical_drive())
 27713                                  ;           BEGIN
 27714                                  ;            /* Display Y/N prompt */
 27715                                  ;            display(menu_31);
 27716                                  ;
 27717                                  ;            /* Get yes/no prompt */
 27718                                  ;            input = get_yn_input(c(No),input_row,input_col);
 27719                                  ;            switch(input)
 27720                                  ;               BEGIN
 27721                                  ;                case 1:
 27722                                  ;                   BEGIN
 27723                                  ;                    for (i=u(0); i < u(4); i++)
 27724                                  ;                    /* Note: This will delete all occurances of EXTENDED DOS partitions found */
 27725                                  ;                       BEGIN
 27726                                  ;                        if (part_table[cur_disk][i].sys_id == uc(EXTENDED))
 27727                                  ;                           BEGIN
 27728                                  ;                            /* Set Partition entry to zero */
 27729                                  ;                            remove_partition(cur_disk,i);
 27730                                  ;
 27731                                  ;                            /* Redisplay the partition info */
 27732                                  ;                            table_display();
 27733                                  ;
 27734                                  ;                            /* clear the prompt off */
 27735                                  ;                            clear_screen(u(17),u(0),u(23),u(79));
 27736                                  ;
 27737                                  ;                            /* Say that you deleted it */
 27738                                  ;                            display(status_2);
 27739                                  ;
 27740                                  ;                            /* Set the reboot flag */
 27741                                  ;                            reboot_flag = (FLAG)TRUE;
 27742                                  ;                           END
 27743                                  ;                       END
 27744                                  ;                    wait_for_ESC();
 27745                                  ;                    break;
 27746                                  ;                   END
 27747                                  ;
 27748                                  ;                case 0:
 27749                                  ;                    break;
 27750                                  ;
 27751                                  ;                case ESC:
 27752                                  ;
 27753                                  ;                     break;
 27754                                  ;
 27755                                  ;                default:
 27756                                  ;                     internal_program_error();
 27757                                  ;                     break;
 27758                                  ;               END
 27759                                  ;           END
 27760                                  ;        else
 27761                                  ;           BEGIN
 27762                                  ;            /* Logical drives still exist, can't delete partition */
 27763                                  ;            display(error_21);
 27764                                  ;            wait_for_ESC();
 27765                                  ;           END
 27766                                  ;       END
 27767                                  ;    clear_screen(u(0),u(0),u(24),u(79));
 27768                                  ;    return;
 27769                                  ;END
 27770                                  
 27771                                  ext_delete:
 27772                                  		; 24/12/2018
 27773                                  
 27774                                  	;%define ed_i	bp-2 ;bp-4
 27775                                  
 27776 00003D7C 55                      		push	bp
 27777                                  		;mov	bp,sp
 27778                                  		;;sub	sp,4
 27779                                  		;sub	sp,2
 27780                                  
 27781                                  		;/* Clear the screen */
 27782                                  
 27783                                  		;mov	ax,79
 27784                                  		;push	ax
 27785                                  		;mov	ax,24
 27786                                  		;push	ax
 27787                                  		;sub	ax,ax
 27788                                  		;push	ax
 27789                                  		;push	ax
 27790                                  		;call	clear_screen
 27791                                  		;add	sp,8
 27792                                  
 27793 00003D7D E8DED6                  		call	CLS
 27794                                  
 27795                                  		;/* Display header */
 27796                                  
 27797                                  		;push	word [menu_30_segment]
 27798 00003D80 1E                      		push	ds
 27799 00003D81 FF36[339E]              		push	word [menu_30_offset]
 27800 00003D85 E892D8                  		call	display
 27801                                  		;pop	bx
 27802                                  		;pop	bx
 27803                                  
 27804                                  		;/* Setup and print current disk */
 27805                                  
 27806                                  		;mov	al,[cur_disk]
 27807                                  		;add	al,'1'
 27808                                  		;mov	[insert],al
 27809                                  		;;push	word [menu_5_segment]
 27810                                  		;push	ds
 27811                                  		;push	word [menu_5_offset]
 27812                                  		;call	display
 27813                                  		;;pop	bx
 27814                                  		;;pop	bx
 27815                                  
 27816 00003D88 E8C8F0                  		call	display_menu_5 ; 31/12/2018
 27817                                  
 27818                                  		;/* print ESC prompt */
 27819                                  
 27820                                  		;;push	word [menu_11_segment]
 27821                                  		;push	ds
 27822                                  		;push	word [menu_11_offset]
 27823                                  		;call	display
 27824                                  		;;pop	bx
 27825                                  		;;pop	bx
 27826                                  
 27827 00003D8B E8D6F0                  		call	display_menu_11 ; 31/12/2018
 27828                                  
 27829                                  	;/* Display partition data and double check if partition exists*/
 27830                                  		
 27831 00003D8E E8DCF0                  		call	table_display
 27832                                  		
 27833                                  		;;mov	al,[cur_disk]
 27834                                  		;;cbw
 27835                                  		;;mov	bx,ax
 27836                                  		;mov	bl,[cur_disk]
 27837                                  		;xor	bh,bh
 27838                                  		;shl	bx,1
 27839                                  		;push	word [total_mbytes+bx]
 27840                                  		;mov	ax,disk_size_format ; "%4.1d"
 27841                                  		;push	ax
 27842                                  		;mov	ax,insert
 27843                                  		;push	ax
 27844                                  		;call	sprintf
 27845                                  		;add	sp,6
 27846                                  
 27847 00003D91 E8CDFF                  		call	sprintf_total_mbytes ; 24/12/2018
 27848                                  		
 27849                                  		;push	word [menu_15_segment]
 27850 00003D94 1E                      		push	ds
 27851 00003D95 FF36[059E]              		push	word [menu_15_offset]
 27852 00003D99 E87ED8                  		call	display
 27853                                  		;pop	bx
 27854                                  		;pop	bx
 27855                                  
 27856                                  		;/* See if there are still volumes */
 27857                                  
 27858 00003D9C E87DF2                  		call	find_logical_drive
 27859                                  		;or	al,al
 27860                                  		;jz	short ed_1
 27861 00003D9F 720A                    		jc	short ed_1
 27862                                  		;jmp	ed_7
 27863                                  ;ed_7:
 27864                                  	;/* Logical drives still exist, can't delete partition */
 27865                                  
 27866                                  		;push	word [error_21_seg]
 27867 00003DA1 1E                      		push	ds
 27868 00003DA2 FF36[9A9E]              		push	word [error_21_off]
 27869 00003DA6 E871D8                  		call	display
 27870                                  		;pop	bx
 27871                                  		;pop	bx
 27872 00003DA9 EB75                    		jmp	short ed_8
 27873                                  ed_1:
 27874                                  		;/* Display Y/N prompt */
 27875                                  
 27876                                  		;push	word [menu_31_segment]
 27877 00003DAB 1E                      		push	ds
 27878 00003DAC FF36[359E]              		push	word [menu_31_offset]
 27879 00003DB0 E867D8                  		call	display
 27880                                  		;pop	bx
 27881                                  		;pop	bx
 27882                                  		
 27883                                  		;/* Get yes/no prompt */
 27884                                  
 27885 00003DB3 FF36[9CA0]              		push	word [input_col]
 27886 00003DB7 FF36[3EA1]              		push	word [input_row]
 27887 00003DBB A0[9EA0]                		mov	al,[No] ; 'N' ; Default input
 27888 00003DBE 50                      		push	ax
 27889 00003DBF E882F2                  		call	get_yn_input
 27890                                  		;add	sp,6
 27891                                  switch_input4:
 27892                                  		;cbw
 27893                                  		;cmp	ax,1Bh
 27894 00003DC2 3C1B                    		cmp	al,1Bh ; ESCape key
 27895 00003DC4 745D                    		je	short case_ext_del_break
 27896 00003DC6 7708                    		ja	short ed_3
 27897 00003DC8 08C0                    		or	al,al
 27898 00003DCA 7457                    		jz	short case_ext_del_break  ; 'N'
 27899 00003DCC FEC8                    		dec	al
 27900 00003DCE 7405                    		jz	short case_ext_del_1 ; 'Y'
 27901                                  ed_3:
 27902 00003DD0 E83EF5                  		call	internal_program_error
 27903 00003DD3 EB4E                    		jmp	short case_ext_del_break
 27904                                  case_ext_del_1:
 27905                                  		;mov	byte [ed_i],0
 27906 00003DD5 31ED                    		xor	bp,bp ; 01/01/2019
 27907                                  ed_5:
 27908                                  
 27909                                  	;/* Note: This will delete all occurances of EXTENDED DOS partitions found */
 27910                                  
 27911 00003DD7 A0[D4CB]                		mov	al,[cur_disk]
 27912                                  		;cbw
 27913                                  		;shl	ax,1
 27914                                  		;shl	ax,1
 27915 00003DDA D0E0                    		shl	al,1
 27916 00003DDC D0E0                    		shl	al,1
 27917                                  		;;add	ax,[ed_i]
 27918                                  		;add	al,[ed_i]
 27919 00003DDE 01E8                    		add	ax,bp ; 01/01/2019
 27920                                  		;mov	cx,46
 27921                                  		;mul	cx
 27922 00003DE0 B12E                    		mov	cl,46
 27923 00003DE2 F6E1                    		mul	cl
 27924 00003DE4 89C3                    		mov	bx,ax
 27925                                  
 27926 00003DE6 80BF[17C4]05            		cmp	byte [part_table_sys_id+bx],5  ; EXTENDED partition
 27927 00003DEB 752D                    		jne	short ed_6
 27928                                  
 27929                                  		;/* Set Partition entry to zero */
 27930                                  
 27931                                  		;push	word [ed_i]
 27932                                  		;push	bp ; 01/01/2019
 27933 00003DED 89E8                    		mov	ax,bp ; 02/01/2019
 27934                                  		;mov	al,[cur_disk]
 27935                                  		;push	ax
 27936 00003DEF 8A26[D4CB]              		mov	ah,[cur_disk]
 27937 00003DF3 86C4                    		xchg	al,ah
 27938 00003DF5 E86609                  		call	remove_partition
 27939                                  		;pop	bx
 27940                                  		;pop	bx
 27941                                  
 27942                                  		;/* Redisplay the partition info */
 27943                                  
 27944 00003DF8 E872F0                  		call	table_display
 27945                                  
 27946                                  		;/* clear the prompt off */
 27947                                  		
 27948 00003DFB B84F00                  		mov	ax,79
 27949 00003DFE 50                      		push	ax
 27950 00003DFF B81700                  		mov	ax,23
 27951 00003E02 50                      		push	ax
 27952 00003E03 29C0                    		sub	ax,ax
 27953 00003E05 50                      		push	ax
 27954 00003E06 B81100                  		mov	ax,17
 27955 00003E09 50                      		push	ax
 27956 00003E0A E889D6                  		call	clear_screen
 27957                                  		;add	sp,8
 27958                                  
 27959                                  		;/* Say that you deleted it */
 27960                                  
 27961                                  		;push	word [status_2_seg]
 27962 00003E0D 1E                      		push	ds
 27963 00003E0E FF36[5F9E]              		push	word [status_2_off]
 27964 00003E12 E805D8                  		call	display
 27965                                  		;pop	bx
 27966                                  		;pop	bx
 27967                                  
 27968                                  		;/* Set the reboot flag */
 27969                                  
 27970 00003E15 C606[6AA0]01            		mov	byte [reboot_flag],1 ; TRUE
 27971                                  ed_6:
 27972                                  		;inc	byte [ed_i]
 27973 00003E1A 45                      		inc	bp ; 01/01/2019
 27974                                  		;cmp	byte [ed_i],4
 27975 00003E1B 83FD04                  		cmp	bp,4
 27976 00003E1E 72B7                    		jb	short ed_5
 27977                                  		;jmp	short ed_8
 27978                                  ;ed_7:
 27979                                  ;		;push	word [error_21_seg]
 27980                                  ;		push	ds
 27981                                  ;		push	word [error_21_off]
 27982                                  ;		call	display
 27983                                  ;		;pop	bx
 27984                                  ;		;pop	bx
 27985                                  ed_8:
 27986 00003E20 E847F3                  		call	wait_for_ESC
 27987                                  
 27988                                  case_ext_del_break:
 27989                                  		;mov	ax,79
 27990                                  		;push	ax
 27991                                  		;mov	ax,24
 27992                                  		;push	ax
 27993                                  		;sub	ax,ax
 27994                                  		;push	ax
 27995                                  		;push	ax
 27996                                  		;call	clear_screen
 27997                                  
 27998 00003E23 E838D6                  		call	CLS		
 27999                                  
 28000                                  		;mov	sp,bp
 28001 00003E26 5D                      		pop	bp
 28002 00003E27 C3                      		retn
 28003                                  
 28004                                  ; fdisk.msg (MSDOS 6.0)
 28005                                  ;/******************************************************************************************************/
 28006                                  ;/*  Screen for VOL_DELETE                                                                             */
 28007                                  ;/*                                                                                                    */
 28008                                  ;/*     |00000000001111111111222222222233333333334444444444555555555566666666667777777777|             */
 28009                                  ;/*     |01234567890123456789012345678901234567890123456789012345678901234567890123456789|             */
 28010                                  ;/*   --|--------------------------------------------------------------------------------|             */
 28011                                  ;/*   00|                                                                                |             */
 28012                                  ;/*   01|            Delete Logical DOS Drive(s) in the Extended DOS Partition           |menu_32      */
 28013                                  ;/*   02|                                                                                |             */
 28014                                  ;/*   03|Drv Volume Label  MBytes  System  Usage  Drv Volume Label  MBytes  System  Usage|menu_19/20 # */
 28015                                  ;/*   04|##  #############  ####  ########  ###%  ##  #############  ####  ########  ###%|             */
 28016                                  ;/*   05|##  #############  ####  ########  ###%  ##  #############  ####  ########  ###%|             */
 28017                                  ;/*   06|##  #############  ####  ########  ###%  ##  #############  ####  ########  ###%|             */
 28018                                  ;/*   07|##  #############  ####  ########  ###%  ##  #############  ####  ########  ###%|             */
 28019                                  ;/*   08|##  #############  ####  ########  ###%  ##  #############  ####  ########  ###%|             */
 28020                                  ;/*   09|##  #############  ####  ########  ###%  ##  #############  ####  ########  ###%|             */
 28021                                  ;/*   10|##  #############  ####  ########  ###%  ##  #############  ####  ########  ###%|             */
 28022                                  ;/*   11|##  #############  ####  ########  ###%  ##  #############  ####  ########  ###%|             */
 28023                                  ;/*   12|##  #############  ####  ########  ###%  ##  #############  ####  ########  ###%|             */
 28024                                  ;/*   13|##  #############  ####  ########  ###%  ##  #############  ####  ########  ###%|             */
 28025                                  ;/*   14|##  #############  ####  ########  ###%  ##  #############  ####  ########  ###%|             */
 28026                                  ;/*   15|##  #############  ####  ########  ###%                                         |             */
 28027                                  ;/*   16|                                                                                |             */
 28028                                  ;/*   17|    Total Extended DOS Partition size is #### Mbytes (1 Mbyte = 1048576 bytes)  |menu_21      */
 28029                                  ;/*   18|                                                                                |             */
 28030                                  ;/*   19|    Warning! Data in a deleted Logical DOS Drive will be lost.                  |menu_33      */
 28031                                  ;/*   20|    What drive do you want to delete...........................? [ ]            |menu_33      */
 28032                                  ;/*   21|    Enter Volume Label.............................? [             ]            |menu_41      */
 28033                                  ;/*   22|    Are you sure (Y/N).............................? [N]                        |menu_34      */
 28034                                  ;/*   23|                                                                                |             */
 28035                                  ;/*   24|    Press ESC to return to FDISK Options                                        |menu_11      */
 28036                                  ;/*   ------------------------------------------------------------------------------------             */
 28037                                  ;/*                                                                                                    */
 28038                                  ;/******************************************************************************************************/
 28039                                  
 28040                                  ; d_menus.c (MSDOS 6.0)
 28041                                  ;/*  */
 28042                                  ;/******************* START OF SPECIFICATIONS *******************/
 28043                                  ;/*                                                             */
 28044                                  ;/* SUBROUTINE NAME: VOL_DELETE                                 */
 28045                                  ;/*                                                             */
 28046                                  ;/* DESCRIPTIVE NAME: Delete DOS disk Volume                    */
 28047                                  ;/*                                                             */
 28048                                  ;/* FUNCTION: Prompts user to delete a DOS disk volume          */
 28049                                  ;/*                                                             */
 28050                                  ;/* NOTES: Screen can be exited via the ESC command before      */
 28051                                  ;/*        partition is deleted and nothing will change         */
 28052                                  ;/*                                                             */
 28053                                  ;/*        The following screen is managed                      */
 28054                                  ;/*                                                             */
 28055                                  ;/*     |0000000000111111111122222222223333333333|              */
 28056                                  ;/*     |0123456789012345678901234567890123456789|              */
 28057                                  ;/*   --|----------------------------------------|              */
 28058                                  ;/*   00|Delete DOS Disk Volume                  |              */
 28059                                  ;/*   01|                                        |              */
 28060                                  ;/*   02|Vol Start End  Size                     |              */
 28061                                  ;/*   03| #  ####  #### ####                     |              */
 28062                                  ;/*   04|                                        |              */
 28063                                  ;/*   05|                                        |              */
 28064                                  ;/*   06|                                        |              */
 28065                                  ;/*   07|                                        |              */
 28066                                  ;/*   08|                                        |              */
 28067                                  ;/*   09|                                        |              */
 28068                                  ;/*   10|                                        |              */
 28069                                  ;/*   11|                                        |              */
 28070                                  ;/*   12|                                        |              */
 28071                                  ;/*   13|                                        |              */
 28072                                  ;/*   14|                                        |              */
 28073                                  ;/*   15|                                        |              */
 28074                                  ;/*   16|Total partition size is #### cylinders. |              */
 28075                                  ;/*   17|                                        |              */
 28076                                  ;/*   18|Warning! Data in the DOS disk volume    |              */
 28077                                  ;/*   19|will be lost. What volume do you wish   |              */
 28078                                  ;/*   20|to delete.........................? [#] |              */
 28079                                  ;/*   21|                                        |              */
 28080                                  ;/*   22|Are you sure......................? [N] |              */
 28081                                  ;/*   23|Press ESC to return to FDISK Options    |              */
 28082                                  ;/*   --------------------------------------------              */
 28083                                  ;/*                                                             */
 28084                                  ;/* ENTRY POINTS: Vol_Delete                                    */
 28085                                  ;/*      LINKAGE: vol_delete ()                                 */
 28086                                  ;/*          NEAR CALL                                          */
 28087                                  ;/*                                                             */
 28088                                  ;/* INPUT: None                                                 */
 28089                                  ;/*                                                             */
 28090                                  ;/* EXIT-NORMAL: ERROR=FALSE                                    */
 28091                                  ;/*                                                             */
 28092                                  ;/* EXIT-ERROR: ERROR=TRUE                                      */
 28093                                  ;/*             GOTO internal_program_error if invalid input    */
 28094                                  ;/*             returned to this routine                        */
 28095                                  ;/*                                                             */
 28096                                  ;/* EFFECTS: No data directly modified by this routine, but     */
 28097                                  ;/*          child routines will modify data.                   */
 28098                                  ;/*                                                             */
 28099                                  ;/* INTERNAL REFERENCES:                                        */
 28100                                  ;/*   ROUTINES:                                                 */
 28101                                  ;/*      clear_screen                                           */
 28102                                  ;/*      display                                                */
 28103                                  ;/*      volume_display                                         */
 28104                                  ;/*      get_num_input                                          */
 28105                                  ;/*      wait_for_ESC                                           */
 28106                                  ;/*      get_yn_input                                           */
 28107                                  ;/*      Write_Boot_Record                                      */
 28108                                  ;/*      Find_Free_Space                                        */
 28109                                  ;/*      Internal_Program_Error                                 */
 28110                                  ;/*                                                             */
 28111                                  ;/* EXTERNAL REFERENCES:                                        */
 28112                                  ;/*   ROUTINES:                                                 */
 28113                                  ;/*                                                             */
 28114                                  ;/******************** END OF SPECIFICATIONS ********************/
 28115                                  
 28116                                  ;/*  */
 28117                                  ;void volume_delete()
 28118                                  ;
 28119                                  ;BEGIN
 28120                                  ;
 28121                                  ;    char   input;
 28122                                  ;    char   drive_input;
 28123                                  ;    char   high_drive;
 28124                                  ;    char   low_drive;
 28125                                  ;    char   error_low_drive;
 28126                                  ;    char   error_high_drive;
 28127                                  ;    char   drives_reassigned;
 28128                                  ;    int    list_index;
 28129                                  ;    int    i;
 28130                                  ;    int    j;
 28131                                  ;    int    point;
 28132                                  ;    FLAG   delete_drive;
 28133                                  ;    unsigned char   drive_list[23][2];
 28134                                  ;    int    column;
 28135                                  ;    int    row;
 28136                                  ;    FLAG   drives_exist;
 28137                                  ;    FLAG   vol_matches;
 28138                                  ;    char   temp;
 28139                                  ;    unsigned char drive_temp;
 28140                                  ;    char far *s;
 28141                                  ;    unsigned char   string_input[12];
 28142                                  ;
 28143                                  ;    input = c(NUL);
 28144                                  ;    string_input[0] = uc(NUL);
 28145                                  ;
 28146                                  ;    /* Clear screen */
 28147                                  ;    clear_screen(u(0),u(0),u(24),u(79));
 28148                                  ;
 28149                                  ;    /* Display header */
 28150                                  ;    display(menu_32);
 28151                                  ;
 28152                                  ;    /* print ESC prompt */
 28153                                  ;    display(menu_11);
 28154                                  ;
 28155                                  ;    /* Display logical drives and get the highest drive letter assigned*/
 28156                                  ;    high_drive = volume_display();
 28157                                  ;
 28158                                  ;    /* Get the first avail drive letter to be deleted */
 28159                                  ;    low_drive = (high_drive - get_num_logical_dos_drives()+1);
 28160                                  ;
 28161                                  ;    if (low_drive <= c('Z'))
 28162                                  ;    {
 28163                                  ;    if (high_drive > c('Z'))
 28164                                  ;        high_drive = c('Z');
 28165                                  ;
 28166                                  ;    temp = low_drive;
 28167                                  ;
 28168                                  ;    /* Initialize array of drive letters that exist at this point */
 28169                                  ;    for (i=(int)0; i < (int)23; i++)
 28170                                  ;        BEGIN
 28171                                  ;        /* See if we've exceeded the drive letter range */
 28172                                  ;        if (temp <= high_drive)
 28173                                  ;            BEGIN
 28174                                  ;            /* Put in drive letter */
 28175                                  ;            drive_list[i][0] = ((unsigned char)(temp));
 28176                                  ;            /* Initialize the offsets into the array to something harmless */
 28177                                  ;            drive_list[i][1] = uc(INVALID);
 28178                                  ;            END
 28179                                  ;        else
 28180                                  ;            BEGIN
 28181                                  ;            /* No drive there, put in NUL */
 28182                                  ;            drive_list[i][0] = uc(NUL);
 28183                                  ;            drive_list[i][1] = uc(INVALID);
 28184                                  ;            END
 28185                                  ;
 28186                                  ;        /* Check for next drive */
 28187                                  ;        temp++;
 28188                                  ;        END
 28189                                  ;
 28190                                  ;    /* Set up partition size message */
 28191                                  ;    sprintf(insert,"%4.0d",get_partition_size( uc(EXTENDED) ) );
 28192                                  ;    display(menu_21);
 28193                                  ;
 28194                                  ;    /* Assume no drives deleted */
 28195                                  ;    drives_reassigned = (FLAG)FALSE;
 28196                                  ;
 28197                                  ;    /* Loop until ESC or all deleted */
 28198                                  ;    while (input != c(ESC))
 28199                                  ;        BEGIN
 28200                                  ;
 28201                                  ;        /* Are there any drives left?*/
 28202                                  ;        drives_exist = (FLAG)FALSE;
 28203                                  ;        error_low_drive = ((char)(NUL));
 28204                                  ;        error_high_drive = ((char)(NUL));
 28205                                  ;
 28206                                  ;        for (i=(int)0;i < (int)23; i++)
 28207                                  ;            BEGIN
 28208                                  ;            drive_temp = drive_list[i][0];
 28209                                  ;            if ((drive_temp != uc(NUL)) && (drive_list[i][1] != uc(DELETED)))
 28210                                  ;                BEGIN
 28211                                  ;                drives_exist = (FLAG)TRUE;
 28212                                  ;
 28213                                  ;                /* Find last existing drive letter */
 28214                                  ;                error_high_drive = ((char)(drive_temp));
 28215                                  ;
 28216                                  ;                /* See if we've found the first drive yet */
 28217                                  ;                if (error_low_drive == ((char)(NUL)))
 28218                                  ;                    error_low_drive = ((char)(drive_temp));
 28219                                  ;                END
 28220                                  ;            END
 28221                                  ;
 28222                                  ;        /* If there are drives, go let user try to delete them */
 28223                                  ;        if (drives_exist)
 28224                                  ;            BEGIN
 28225                                  ;
 28226                                  ;            /* Get input until given a correct drive */
 28227                                  ;            valid_input = (FLAG)FALSE;
 28228                                  ;            while ( (!valid_input) && (input != c(ESC)) )
 28229                                  ;                BEGIN
 28230                                  ;
 28231                                  ;                /* Prompt for input */
 28232                                  ;                display(menu_33);
 28233                                  ;
 28234                                  ;                /* Get input between first and highest drive letters */
 28235                                  ;                clear_screen( u(21), u(0), u(21), u(79) );
 28236                                  ;                input = get_alpha_input(low_drive,high_drive,input_row,input_col,error_low_drive,error_high_drive);
 28237                                  ;                drive_input = input;
 28238                                  ;
 28239                                  ;                /* See if it has been deleted already or ESC pressed */
 28240                                  ;                drives_exist = FALSE;
 28241                                  ;                for (i=(int)0;i < (int)23; i++) 
 28242                                  ;                    BEGIN
 28243                                  ;                    if (drive_list[i][0] == ((unsigned char)(drive_input)) &&
 28244                                  ;                       (drive_list[i][1] != ((unsigned char) DELETED)))
 28245                                  ;                        BEGIN
 28246                                  ;                        drives_exist = TRUE;
 28247                                  ;                        list_index = i;
 28248                                  ;                        END
 28249                                  ;                    if (ext_table[cur_disk][i].drive_letter == c(drive_input) )
 28250                                  ;                        point = i;
 28251                                  ;                    END
 28252                                  ;                END
 28253                                  ;
 28254                                  ;            /* Input volume string to confirm delete */
 28255                                  ;            vol_matches = FALSE;
 28256                                  ;            if (input != c(ESC))
 28257                                  ;                BEGIN
 28258                                  ;                if (drives_exist)
 28259                                  ;                    BEGIN
 28260                                  ;                    /* delete privious volume mismatch message */
 28261                                  ;                    string_input[0] = uc(NUL);
 28262                                  ;                    clear_screen( u(22), u(0), u(23), u(79) );
 28263                                  ;                    /* Get input volume label */
 28264                                  ;                    display(menu_41);
 28265                                  ;                    get_string_input(input_row,input_col,string_input);
 28266                                  ;                    if (string_input[0] == uc(ESC)) input = c(ESC);
 28267                                  ;
 28268                                  ;                    /* See if the volume id matches the selected drive */
 28269                                  ;                    if (strcmp(ext_table[cur_disk][point].vol_label,string_input) == (int)ZERO)
 28270                                  ;                           vol_matches = TRUE;
 28271                                  ;                    else if (input != c(ESC)) display(error_34);
 28272                                  ;                    END
 28273                                  ;                 else
 28274                                  ;                    BEGIN
 28275                                  ;                    /* Tell user the drive has already been deleted */
 28276                                  ;                    insert[0] = dos_upper(drive_input);
 28277                                  ;                    insert[1] = c(DRIVE_INDICATOR);
 28278                                  ;                    clear_screen( u(21), u(0), u(22), u(79) );
 28279                                  ;                    display(error_29);
 28280                                  ;                    END
 28281                                  ;                END
 28282                                  ;
 28283                                  ;                /* If it is a valid drive indicate that the input was ok */
 28284                                  ;                if ( (input != c(ESC)) && (drives_exist) && (vol_matches) )
 28285                                  ;                    BEGIN
 28286                                  ;                    valid_input = TRUE;
 28287                                  ;
 28288                                  ;                    /* At this point we have a valid drive letter to delete */
 28289                                  ;
 28290                                  ;                    /* Get the offset into the array for the drive to be deleted */
 28291                                  ;                    delete_drive = find_ext_drive(drive_input - low_drive);
 28292                                  ;
 28293                                  ;                    /* Got a drive letter - prompt are you sure */
 28294                                  ;                    display(menu_34);
 28295                                  ;
 28296                                  ;                    /* Get Y/N input, default is NO */
 28297                                  ;                    input = get_yn_input(c(No),input_row,input_col);
 28298                                  ;
 28299                                  ;                    /* Clear everything out on screen in prompt area */
 28300                                  ;                    clear_screen(u(23),u(0),u(23),u(79));
 28301                                  ;
 28302                                  ;                    /* Go handle the delete */
 28303                                  ;                    switch(input)
 28304                                  ;                        BEGIN
 28305                                  ;                        case 1:
 28306                                  ;                            BEGIN
 28307                                  ;                            /* Go ahead and mark it deleted in list array */
 28308                                  ;
 28309                                  ;                            /* Throw up a flag to indicate we need to delete this one for real later */
 28310                                  ;                            /* This is because if we change the ext_table array now, we lose the ability */
 28311                                  ;                            /* to match up drive letters with locations, or at least it become more */
 28312                                  ;                            /* complicated than I felt like figuring out, so mark it now and do it later */
 28313                                  ;                            drive_list[list_index][1] = (unsigned char)DELETED;
 28314                                  ;
 28315                                  ;                            drives_reassigned = TRUE;
 28316                                  ;
 28317                                  ;                            /* Put prompt up on screen */
 28318                                  ;                            for (i=(int)0; i < (int)23; i++)
 28319                                  ;                                BEGIN
 28320                                  ;                                /* See if drive deleted */
 28321                                  ;                                if (drive_list[i][1] == uc(DELETED))
 28322                                  ;                                    BEGIN
 28323                                  ;                                    /* Wipe out the drive info and print deleted message */
 28324                                  ;                                    /* See what column it is in */
 28325                                  ;                                    if (i < (int)12)
 28326                                  ;                                        BEGIN
 28327                                  ;                                        column = (int)4;
 28328                                  ;                                        row = (int)(4 + i - (int)0);
 28329                                  ;                                        clear_screen( (unsigned)row, (unsigned)column,
 28330                                  ;                                                      (unsigned)row, (unsigned)39 );
 28331                                  ;                                        END
 28332                                  ;                                    else
 28333                                  ;                                        BEGIN
 28334                                  ;                                        column = (int)45;
 28335                                  ;                                        row = (int)(4 + i - (int)12);
 28336                                  ;                                        clear_screen( (unsigned)row, (unsigned)column,
 28337                                  ;                                                      (unsigned)row, (unsigned)79 );
 28338                                  ;                                        END
 28339                                  ;
 28340                                  ;                                    /* Put the start row,col of message in the message string */
 28341                                  ;                                    s=status_3;
 28342                                  ;                                    s++;
 28343                                  ;                                    *s++ = ((char)(row/10))+'0';
 28344                                  ;                                    *s++ = ((char)(row%10))+'0';
 28345                                  ;                                    *s++ = ((char)(column/10))+'0';
 28346                                  ;                                    *s = ((char)(column%10))+'0';
 28347                                  ;                                    display(status_3);
 28348                                  ;                                    END
 28349                                  ;                                END
 28350                                  ;                            /* Set the reboot flag */
 28351                                  ;                            reboot_flag = TRUE;
 28352                                  ;                            clear_screen( u(21), u(0), u(23), u(79) );
 28353                                  ;                            break;
 28354                                  ;                            END
 28355                                  ;
 28356                                  ;                        case ESC:
 28357                                  ;                        case 0:
 28358                                  ;                            clear_screen( u(21), u(0), u(23), u(79) );
 28359                                  ;                            break;
 28360                                  ;
 28361                                  ;                        default:
 28362                                  ;                            internal_program_error();
 28363                                  ;                            break;
 28364                                  ;                        END
 28365                                  ;                    END
 28366                                  ;            END
 28367                                  ;         else     /* drives do not exist! */
 28368                                  ;            BEGIN
 28369                                  ;            /* No more logical drives to delete */
 28370                                  ;            clear_screen(u(16),u(0),u(21),u(79));
 28371                                  ;            display(error_22);
 28372                                  ;            input = wait_for_ESC();
 28373                                  ;            END
 28374                                  ;        END /* while input != esc */
 28375                                  ;
 28376                                  ;    if (drives_reassigned)
 28377                                  ;        BEGIN
 28378                                  ;        /* If anything got deleted, lets go do it for real */
 28379                                  ;        for (i=(int)0; i < (int)23;i++)
 28380                                  ;            BEGIN
 28381                                  ;            if (drive_list[i][1] == uc(DELETED))
 28382                                  ;                BEGIN
 28383                                  ;                for (j=(int)0; j < (int)23;j++)
 28384                                  ;                    BEGIN
 28385                                  ;                    if (drive_list[i][0] == ext_table[cur_disk][j].drive_letter)
 28386                                  ;                        BEGIN
 28387                                  ;                        /* Zero sys id and show it changed */
 28388                                  ;                        remove_volume(cur_disk,i);
 28389                                  ;                        END
 28390                                  ;                    END
 28391                                  ;                END
 28392                                  ;            END
 28393                                  ;
 28394                                  ;        /* Show new drive letters */
 28395                                  ;        volume_display();
 28396                                  ;
 28397                                  ;        /* Say that drive letters changed */
 28398                                  ;        clear_screen(u(16),u(0),u(23),u(79));
 28399                                  ;        display(status_10);
 28400                                  ;        wait_for_ESC();
 28401                                  ;        END
 28402                                  ;    }
 28403                                  ;    else     /* drives do not exist! */
 28404                                  ;    {
 28405                                  ;        /* No more logical drives to delete */
 28406                                  ;        clear_screen(u(16),u(0),u(21),u(79));
 28407                                  ;        display(error_36);
 28408                                  ;        wait_for_ESC();
 28409                                  ;    }
 28410                                  ;    clear_screen(u(0),u(0),u(24),u(79));
 28411                                  ;
 28412                                  ;    return;
 28413                                  ;
 28414                                  ;END
 28415                                  
 28416                                  volume_delete:
 28417                                  		; 04/01/2018
 28418                                  		; 03/01/2019
 28419                                  		; 24/12/2018
 28420                                  
 28421                                  	%define vdel_drv_temp	  bp-92 ;bp-94	;bp-98
 28422                                  	;%define vdel_column	  bp-92	;bp-96
 28423                                  	%define vdel_del_drive	  bp-90	;bp-94
 28424                                  	%define vdel_low_drive	  bp-88	;bp-92
 28425                                  	%define vdel_j		  bp-86	;bp-90
 28426                                  	%define vdel_point	  bp-84	;bp-88
 28427                                  	%define vdel_drive_input  bp-82	;bp-86
 28428                                  	%define vdel_high_drive	  bp-80	;bp-84
 28429                                  	%define vdel_i		  bp-78	;bp-82
 28430                                  	%define vdel_drives_exist bp-76	;bp-80
 28431                                  	%define vdel_row	  bp-74	;bp-78
 28432                                  	;%define vdel_temp	  bp-72	;bp-76
 28433                                  	%define vdel_column	  bp-72	;bp-96
 28434                                  	%define vdel_string_input bp-70	;bp-74
 28435                                  	%define vdel_drive_list	  bp-58	;bp-62
 28436                                  	;%define vdel_drive_list1 bp-57	;bp-61
 28437                                  	%define vdel_vol_matches  bp-12	;bp-16
 28438                                  	%define error_low_drive	  bp-10	;bp-14
 28439                                  	%define vdel_list_index	  bp-8	;bp-12
 28440                                  	;%define vdel_s		        ;bp-10
 28441                                  	%define error_high_drive  bp-6	;bp-6
 28442                                  	%define drives_reassigned bp-4	;bp-4
 28443                                  	%define vdel_input	  bp-2	;bp-2
 28444                                  
 28445 00003E28 55                      		push	bp
 28446 00003E29 89E5                    		mov	bp,sp
 28447                                  		;sub	sp,98
 28448                                  		;sub	sp,94 ; 31/12/2018
 28449 00003E2B 83EC5C                  		sub	sp,92 ; 04/01/2019
 28450                                  
 28451                                  		;push	si ;*
 28452                                  
 28453 00003E2E C646FE00                		mov	byte [vdel_input],0
 28454 00003E32 C646BA00                		mov	byte [vdel_string_input],0
 28455                                  
 28456                                  		;/* Clear screen */
 28457                                  		
 28458                                  		;mov	ax,79
 28459                                  		;push	ax
 28460                                  		;mov	ax,24
 28461                                  		;push	ax
 28462                                  		;sub	ax,ax
 28463                                  		;push	ax
 28464                                  		;push	ax
 28465                                  		;call	clear_screen
 28466                                  		;add	sp,8
 28467                                  
 28468 00003E36 E825D6                  		call	CLS ; 03/01/2019
 28469                                  
 28470                                  		;/* Display header */
 28471                                  
 28472                                  		;push	word [menu_32_segment]
 28473 00003E39 1E                      		push	ds ; 02/01/2019
 28474 00003E3A FF36[379E]              		push	word [menu_32_offset]
 28475 00003E3E E8D9D7                  		call	display
 28476                                  		;pop	bx
 28477                                  		;pop	bx
 28478                                  
 28479                                  		;/* print ESC prompt */
 28480                                  
 28481                                  		;;push	word [menu_11_segment]
 28482                                  		;push	ds
 28483                                  		;push	word [menu_11_offset]
 28484                                  		;call	display
 28485                                  		;;pop	bx
 28486                                  		;;pop	bx
 28487                                  
 28488 00003E41 E820F0                  		call	display_menu_11 ; 31/12/2018
 28489                                  
 28490                                  	;/* Display logical drives and get the highest drive letter assigned */
 28491                                  
 28492 00003E44 E891F3                  		call	volume_display
 28493 00003E47 8846B0                  		mov	[vdel_high_drive],al
 28494                                  
 28495                                  		;/* Get the first avail drive letter to be deleted */
 28496                                  
 28497 00003E4A E8C109                  		call	get_num_logical_dos_drives
 28498 00003E4D 2A46B0                  		sub	al,[vdel_high_drive]
 28499 00003E50 F6D8                    		neg	al
 28500 00003E52 FEC0                    		inc	al
 28501 00003E54 8846A8                  		mov	[vdel_low_drive],al
 28502                                  
 28503 00003E57 3C5A                    		cmp	al,'Z'
 28504 00003E59 7E03                    		jle	short vdel_1
 28505 00003E5B E94503                  		jmp	vdel_47
 28506                                  vdel_1:
 28507 00003E5E 807EB05A                		cmp	byte [vdel_high_drive],'Z'
 28508 00003E62 7E04                    		jle	short vdel_2
 28509 00003E64 C646B05A                		mov	byte [vdel_high_drive],'Z'
 28510                                  vdel_2:
 28511                                  		;mov	al,[vdel_low_drive] ; 31/12/2018
 28512                                  		;mov	[vdel_temp],al ; 03/01/2019
 28513                                  
 28514                                  	;/* Initialize array of drive letters that exist at this point */
 28515                                  
 28516                                  		;mov	word [vdel_i],0
 28517                                  		; 03/01/2019
 28518 00003E68 31F6                    		xor	si,si ; 0
 28519 00003E6A 8976B2                  		mov	[vdel_i],si ; 0
 28520 00003E6D EB18                    		jmp	short vdel_5
 28521                                  vdel_3:
 28522                                  		;/* No drive there, put in NUL */
 28523                                  
 28524                                  		;mov	si,[vdel_i] ; 31/12/2018
 28525                                  		;shl	si,1
 28526 00003E6F C642C600                		mov	byte [si+vdel_drive_list],0
 28527                                  vdel_4:
 28528                                  	;/* Initialize the offsets into the array to something harmless */
 28529                                  
 28530 00003E73 C642C7FF                		mov	byte [si+vdel_drive_list+1],0FFh ; INVALID
 28531                                  
 28532                                  		;/* Check for next drive */
 28533                                  
 28534                                  		;inc	byte [vdel_temp] ; 03/01/2019
 28535 00003E77 FEC0                    		inc	al ; 03/01/2019
 28536                                  		
 28537 00003E79 FE46B2                  		inc	byte [vdel_i]
 28538                                  ;vdel_5:
 28539 00003E7C 807EB217                		cmp	byte [vdel_i],23
 28540 00003E80 730F                    		jnb	short vdel_6
 28541                                  
 28542                                  		;/* See if we've exceeded the drive letter range */
 28543                                  
 28544                                  		;mov	al,[vdel_temp] ; 03/01/2019
 28545                                  
 28546                                  		; 31/12/2018
 28547 00003E82 8B76B2                  		mov	si,[vdel_i]
 28548 00003E85 D1E6                    		shl	si,1
 28549                                  
 28550                                  vdel_5: 	; 03/01/2019
 28551 00003E87 3846B0                  		cmp	[vdel_high_drive],al ; [vdel_temp]
 28552 00003E8A 72E3                    		jb	short vdel_3
 28553                                  		
 28554                                  		;/* Put in drive letter */
 28555                                  
 28556                                  		;mov	si,[vdel_i]
 28557                                  		;shl	si,1
 28558                                  
 28559 00003E8C 8842C6                  		mov	[si+vdel_drive_list],al
 28560 00003E8F EBE2                    		jmp	short vdel_4
 28561                                  vdel_6:
 28562                                  		;/* Set up partition size message */
 28563                                  
 28564                                  		;mov	al,5
 28565                                  		;;push	ax
 28566                                  		;mov	dh,5
 28567                                  		;call	get_partition_size
 28568                                  		;;pop	bx
 28569                                  		;push	ax
 28570                                  		;mov	ax,ld_p_size_format ; "%4.1d"
 28571                                  		;push	ax
 28572                                  		;mov	ax,insert
 28573                                  		;push	ax
 28574                                  		;call	sprintf
 28575                                  		;add	sp,6
 28576                                  		;	
 28577                                  		;;push	word [menu_21_segment]
 28578                                  		;push	ds
 28579                                  		;push	word [menu_21_offset]
 28580                                  		;call	display
 28581                                  		;;pop	bx
 28582                                  		;;pop	bx
 28583                                  
 28584 00003E91 E827F3                  		call	display_ext_partition_size ; 31/12/2018
 28585                                  
 28586                                  		;/* Assume no drives deleted */
 28587                                  
 28588 00003E94 C646FC00                		mov	byte [drives_reassigned],0 ; FALSE
 28589                                  		;jmp	vdel_39 ; 03/01/2019
 28590                                  
 28591                                  		;/* while input != esc */
 28592                                  vdel_7:		
 28593                                  		;/* Are there any drives left?*/
 28594                                  	
 28595 00003E98 28C0                    		sub	al,al ; 0
 28596 00003E9A 8846B4                  		mov	[vdel_drives_exist],al ; 0
 28597 00003E9D 8846F6                  		mov	[error_low_drive],al ; 0
 28598 00003EA0 8846FA                  		mov	[error_high_drive],al ; 0
 28599 00003EA3 8846B2                  		mov	[vdel_i],al ; 0
 28600                                  vdel_8:
 28601 00003EA6 8B76B2                  		mov	si,[vdel_i]
 28602 00003EA9 D1E6                    		shl	si,1
 28603 00003EAB 8A42C6                  		mov	al,[si+vdel_drive_list]
 28604 00003EAE 8846A4                  		mov	[vdel_drv_temp],al
 28605                                  
 28606 00003EB1 08C0                    		or	al,al
 28607 00003EB3 7416                    		jz	short vdel_9
 28608 00003EB5 807AC7FE                		cmp	byte [si+vdel_drive_list+1],0FEh ; DELETED
 28609 00003EB9 7410                    		je	short vdel_9
 28610 00003EBB C646B401                		mov	byte [vdel_drives_exist],1 ; TRUE
 28611                                  
 28612                                  		;/* Find last existing drive letter */
 28613                                  
 28614 00003EBF 8846FA                  		mov	[error_high_drive],al
 28615                                  
 28616                                  		;/* See if we've found the first drive yet */
 28617                                  
 28618 00003EC2 807EF600                		cmp	byte [error_low_drive],0
 28619 00003EC6 7503                    		jne	short vdel_9
 28620 00003EC8 8846F6                  		mov	[error_low_drive],al
 28621                                  vdel_9:
 28622 00003ECB FE46B2                  		inc	byte [vdel_i]
 28623 00003ECE 807EB217                		cmp	byte [vdel_i],23
 28624 00003ED2 72D2                    		jb	short vdel_8
 28625                                  
 28626                                  		;/* If there are drives, go let user try to delete them */
 28627                                  
 28628 00003ED4 807EB400                		cmp	byte [vdel_drives_exist],0
 28629 00003ED8 7503                    		jne	short vdel_10
 28630 00003EDA E92B02                  		jmp	vdel_38
 28631                                  
 28632                                  		;/* Get input until given a correct drive */
 28633                                  vdel_10:
 28634 00003EDD C606[DECB]00            		mov	byte [valid_input],0
 28635                                  vdel_11:
 28636 00003EE2 807EFE1B                		cmp	byte [vdel_input],1Bh ; ESCape
 28637 00003EE6 7503                    		jne	short vdel_12
 28638 00003EE8 E98900                  		jmp	vdel_16
 28639                                  	
 28640                                  		;/* Prompt for input */
 28641                                  vdel_12:
 28642                                  		;push	word [menu_33_segment]
 28643 00003EEB 1E                      		push	ds
 28644 00003EEC FF36[399E]              		push	word [menu_33_offset]
 28645 00003EF0 E827D7                  		call	display
 28646                                  		;pop	bx
 28647                                  		;pop	bx
 28648                                  
 28649                                  		;/* Get input between first and highest drive letters */
 28650                                  
 28651 00003EF3 B84F00                  		mov	ax,79
 28652 00003EF6 50                      		push	ax
 28653 00003EF7 B81500                  		mov	ax,21
 28654 00003EFA 50                      		push	ax
 28655 00003EFB 29C9                    		sub	cx,cx
 28656 00003EFD 51                      		push	cx
 28657 00003EFE 50                      		push	ax
 28658 00003EFF E894D5                  		call	clear_screen
 28659                                  		;add	sp,8
 28660                                  
 28661 00003F02 8A46FA                  		mov	al,[error_high_drive]
 28662 00003F05 50                      		push	ax
 28663 00003F06 8A46F6                  		mov	al,[error_low_drive]
 28664 00003F09 50                      		push	ax
 28665 00003F0A FF36[9CA0]              		push	word [input_col]
 28666 00003F0E FF36[3EA1]              		push	word [input_row]
 28667 00003F12 8A46B0                  		mov	al,[vdel_high_drive]
 28668 00003F15 50                      		push	ax
 28669 00003F16 8A46A8                  		mov	al,[vdel_low_drive]
 28670 00003F19 50                      		push	ax
 28671 00003F1A E80607                  		call	get_alpha_input
 28672                                  		;add	sp,12
 28673                                  
 28674 00003F1D 8846FE                  		mov	[vdel_input],al
 28675 00003F20 8846AE                  		mov	[vdel_drive_input],al
 28676                                  		
 28677                                  		;/* See if it has been deleted already or ESC pressed */
 28678                                  
 28679                                  		;mov	byte [vdel_drives_exist],0
 28680                                  		;mov	byte [vdel_i],0
 28681                                  
 28682 00003F23 30C0                    		xor	al,al ; 0
 28683 00003F25 8846B4                  		mov	[vdel_drives_exist],al
 28684 00003F28 8846B2                  		mov	[vdel_i],al
 28685                                  vdel_13:
 28686 00003F2B 8A46AE                  		mov	al,[vdel_drive_input]
 28687 00003F2E 8B76B2                  		mov	si,[vdel_i]
 28688 00003F31 89F2                    		mov	dx,si ; 03/01/2019
 28689 00003F33 D1E6                    		shl	si,1
 28690 00003F35 3842C6                  		cmp	[si+vdel_drive_list],al
 28691 00003F38 750D                    		jne	short vdel_14
 28692 00003F3A 807AC7FE                		cmp	byte [si+vdel_drive_list+1],0FEh ; DELETED
 28693 00003F3E 7407                    		je	short vdel_14
 28694 00003F40 C646B401                		mov	byte [vdel_drives_exist],1 ; TRUE
 28695                                  		;mov	ax,[vdel_i]
 28696                                  		;mov	[vdel_list_index],ax
 28697                                  		;mov	dx,[vdel_i]
 28698 00003F44 8956F8                  		mov	[vdel_list_index],dx
 28699                                  vdel_14:
 28700 00003F47 B018                    		mov	al,24
 28701                                  		;imul	byte [cur_disk]
 28702 00003F49 F626[D4CB]              		mul	byte [cur_disk]
 28703                                  		;add	ax,[vdel_i]
 28704                                  		;add	al,[vdel_i]
 28705 00003F4D 00D0                    		add	al,dl ; 03/01/2019
 28706                                  		;mov	cx,46
 28707                                  		;imul	cx
 28708 00003F4F B12E                    		mov	cl,46
 28709 00003F51 F6E1                    		mul	cl
 28710 00003F53 89C3                    		mov	bx,ax
 28711 00003F55 8A46AE                  		mov	al,[vdel_drive_input]
 28712 00003F58 3887[77A1]              		cmp	byte [ext_table_drive_letter+bx],al
 28713 00003F5C 7503                    		jne	short vdel_15
 28714                                  		;mov	ax,[vdel_i]
 28715                                  		;mov	[vdel_point],ax
 28716 00003F5E 8956AC                  		mov	[vdel_point],dx ; [vdel_i]
 28717                                  vdel_15:
 28718 00003F61 FE46B2                  		inc	byte [vdel_i]
 28719 00003F64 807EB217                		cmp	byte [vdel_i],23
 28720 00003F68 7CC1                    		jl	short vdel_13
 28721 00003F6A 803E[DECB]00            		cmp	byte [valid_input],0
 28722 00003F6F 7503                    		jne	short vdel_16
 28723 00003F71 E96EFF                  		jmp	vdel_11
 28724                                  
 28725                                  		;/* Input volume string to confirm delete */
 28726                                  vdel_16:
 28727 00003F74 C646F400                		mov	byte [vdel_vol_matches],0 ; FALSE
 28728 00003F78 807EFE1B                		cmp	byte [vdel_input],1Bh ; ESC
 28729 00003F7C 7503                    		jne	short vdel_17
 28730                                  		;jmp	vdel_22
 28731 00003F7E E9B001                  		jmp	vdel_40 ; 31/12/2018
 28732                                  vdel_17:
 28733 00003F81 807EB400                		cmp	byte [vdel_drives_exist],0
 28734 00003F85 7464                    		je	short vdel_20
 28735                                  
 28736                                  		;/* delete previous volume mismatch message */
 28737                                  
 28738 00003F87 C646BA00                		mov	byte [vdel_string_input],0
 28739 00003F8B B84F00                  		mov	ax,79
 28740 00003F8E 50                      		push	ax
 28741 00003F8F B81700                  		mov	ax,23
 28742 00003F92 50                      		push	ax
 28743 00003F93 29C0                    		sub	ax,ax
 28744 00003F95 50                      		push	ax
 28745 00003F96 B81600                  		mov	ax,22
 28746 00003F99 50                      		push	ax
 28747 00003F9A E8F9D4                  		call	clear_screen
 28748                                  		;add	sp,8
 28749                                  
 28750                                  		;/* Get input volume label */
 28751                                  
 28752                                  		;push	word [menu_41_segment]
 28753 00003F9D 1E                      		push	ds
 28754 00003F9E FF36[3D9E]              		push	word [menu_41_offset]
 28755 00003FA2 E875D6                  		call	display
 28756                                  		;pop	bx
 28757                                  		;pop	bx
 28758                                  		
 28759 00003FA5 8D46BA                  		lea	ax,[vdel_string_input]
 28760 00003FA8 16                      		push	ss
 28761 00003FA9 50                      		push	ax
 28762 00003FAA FF36[9CA0]              		push	word [input_col]
 28763 00003FAE FF36[3EA1]              		push	word [input_row]
 28764 00003FB2 E8E403                  		call	get_string_input
 28765                                  		;add	sp,8
 28766 00003FB5 807EBA1B                		cmp	byte [vdel_string_input],1Bh ; ESC
 28767 00003FB9 7503                    		jne	short vdel_18  ; [vdel_drives_exist] > 0
 28768                                  
 28769                                  		;mov	byte [vdel_input],1Bh
 28770                                  		; 31/12/2018 (modification)
 28771 00003FBB E97301                  		jmp	vdel_40
 28772                                  
 28773                                  		;/* See if the volume id matches the selected drive */
 28774                                  vdel_18:
 28775                                  		;lea	ax,[vdel_string_input]
 28776                                  		;push	ax
 28777                                  
 28778 00003FBE 8D7EBA                  		lea	di,[vdel_string_input] ; dst
 28779                                  
 28780 00003FC1 B018                    		mov	al,24
 28781                                  		;imul	byte [cur_disk]
 28782 00003FC3 F626[D4CB]              		mul	byte [cur_disk]
 28783                                  		;add	ax,[vdel_point]
 28784 00003FC7 0246AC                  		add	al,[vdel_point]
 28785                                  		;mov	cx,46
 28786                                  		;imul	cx
 28787 00003FCA B12E                    		mov	cl,46
 28788 00003FCC F6E1                    		mul	cl
 28789 00003FCE 05[62A1]                		add	ax,ext_table_vol_label
 28790                                  		;push	ax
 28791                                  
 28792 00003FD1 89C6                    		mov	si,ax  ;src
 28793                                  
 28794 00003FD3 E8AE03                  		call	strcmp
 28795                                  		;pop	bx
 28796                                  		;pop	bx
 28797 00003FD6 09C0                    		or	ax,ax
 28798 00003FD8 7506                    		jnz	short vdel_19
 28799                                  
 28800 00003FDA C646F401                		mov	byte [vdel_vol_matches],1
 28801                                  		;jmp	short vdel_22
 28802                                  
 28803                                  		; [vdel_drives_exist] > 0
 28804                                  		;jmp	short vdel_23 ; 31/12/2018
 28805 00003FDE EB36                    		jmp	short vdel_25
 28806                                  vdel_19:
 28807                                  		;cmp	byte [vdel_input],1Bh
 28808                                  		;je	short vdel_22
 28809                                  
 28810                                  		;push	word [error_34_seg]
 28811 00003FE0 1E                      		push	ds
 28812 00003FE1 FF36[B49E]              		push	word [error_34_off]
 28813                                  		;jmp	short vdel_21
 28814                                  
 28815                                  		; 31/12/2018
 28816 00003FE5 E832D6                  		call	display
 28817                                  		;pop	bx
 28818                                  		;pop	bx
 28819 00003FE8 E9ADFE                  		jmp	vdel_7
 28820                                  
 28821                                  vdel_20:
 28822                                  		;/* Tell user the drive has already been deleted */
 28823                                  
 28824 00003FEB 8A46AE                  		mov	al,[vdel_drive_input]
 28825                                  		;push	ax
 28826 00003FEE E83DEC                  		call	dos_upper
 28827                                  		;pop	bx
 28828 00003FF1 A2[E6CC]                		mov	[insert],al
 28829 00003FF4 C606[E7CC]3A            		mov	byte [insert+1],':' ; 3Ah
 28830                                  		
 28831 00003FF9 B84F00                  		mov	ax,79
 28832 00003FFC 50                      		push	ax
 28833 00003FFD B81600                  		mov	ax,22
 28834 00004000 50                      		push	ax
 28835 00004001 29C0                    		sub	ax,ax
 28836 00004003 50                      		push	ax
 28837 00004004 B81500                  		mov	ax,21
 28838 00004007 50                      		push	ax
 28839 00004008 E88BD4                  		call	clear_screen
 28840                                  		;add	sp,8
 28841                                  
 28842                                  		;push	word [error_29_seg]
 28843 0000400B 1E                      		push	ds
 28844 0000400C FF36[AA9E]              		push	word [error_29_off]
 28845                                  vdel_21:
 28846 00004010 E807D6                  		call	display
 28847                                  		;pop	bx
 28848                                  		;pop	bx
 28849                                  vdel_22:
 28850                                  		;cmp	[vdel_input],1Bh ; ESC
 28851                                  		;jne	short vdel_23
 28852                                  		
 28853                                  		;;jmp	vdel_39
 28854                                  		;jmp	vdel_40
 28855                                  vdel_23:
 28856                                  		;cmp	[vdel_drives_exist], 0
 28857                                  		;je	short vdel_24
 28858                                  		;cmp	[vdel_vol_matches], 0
 28859                                  		;jne	short vdel_25
 28860                                  vdel_24:
 28861                                  		;jmp	vdel_39
 28862 00004013 E982FE                  		jmp	vdel_7
 28863                                  
 28864                                  	;/* At this point we have a valid drive letter to delete */
 28865                                  
 28866                                  	;/* Get the offset into the array for the drive to be deleted */
 28867                                  vdel_25:
 28868 00004016 C606[DECB]01            		mov	byte [valid_input],1 ; TRUE
 28869                                  		;mov	al,[vdel_drive_input]
 28870                                  		;sub	al,[vdel_low_drive]
 28871 0000401B 8A56AE                  		mov	dl,[vdel_drive_input]
 28872 0000401E 2A56A8                  		sub	dl,[vdel_low_drive]
 28873                                  		;push	ax
 28874 00004021 E82A03                  		call	find_ext_drive
 28875                                  		;pop	bx
 28876                                  		;mov	[vdel_del_drive],al
 28877 00004024 884EA6                  		mov	[vdel_del_drive],cl
 28878                                  
 28879                                  		;/* Got a drive letter - prompt are you sure */
 28880                                  
 28881                                  		;push	word [menu_34_segment]
 28882 00004027 1E                      		push	ds
 28883 00004028 FF36[3B9E]              		push	word [menu_34_offset]
 28884 0000402C E8EBD5                  		call	display
 28885                                  		;pop	bx
 28886                                  		;pop	bx
 28887                                  
 28888                                  		;/* Get Y/N input, default is NO */
 28889                                  
 28890 0000402F FF36[9CA0]              		push	word [input_col]
 28891 00004033 FF36[3EA1]              		push	word [input_row]
 28892 00004037 A0[9EA0]                		mov	al,[No]
 28893 0000403A 50                      		push	ax
 28894 0000403B E806F0                  		call	get_yn_input
 28895                                  		;add	sp,6
 28896 0000403E 8846FE                  		mov	[vdel_input],al
 28897                                  	
 28898                                  		;/* Clear everything out on screen in prompt area */
 28899                                  
 28900 00004041 B84F00                  		mov	ax,79
 28901 00004044 50                      		push	ax
 28902 00004045 B81700                  		mov	ax,23
 28903 00004048 50                      		push	ax
 28904 00004049 29C9                    		sub	cx,cx
 28905 0000404B 51                      		push	cx
 28906 0000404C 50                      		push	ax
 28907 0000404D E846D4                  		call	clear_screen
 28908                                  		;add	sp,8
 28909                                  switch_input5:
 28910                                  		;/* Go handle the delete */
 28911                                  
 28912 00004050 8A46FE                  		mov	al,[vdel_input]
 28913                                  		;cbw
 28914                                  		;cmp	ax,1Bh
 28915 00004053 3C1B                    		cmp	al,1Bh ; ESC key
 28916 00004055 7503                    		jne	short vdel_27
 28917 00004057 E99A00                  		jmp	case_vol_del_break ; case ESC
 28918                                  vdel_27:
 28919 0000405A 770B                    		ja	short case_vol_del_DEF
 28920 0000405C 08C0                    		or	al,al
 28921 0000405E 7503                    		jnz	short vdel_28
 28922 00004060 E99100                  		jmp	case_vol_del_break ; Case 0
 28923                                  vdel_28:
 28924 00004063 FEC8                    		dec	al
 28925 00004065 7406                    		jz	short case_vol_del_1 ; 'Y'
 28926                                  case_vol_del_DEF:
 28927 00004067 E8A7F2                  		call	internal_program_error
 28928                                  		;jmp	vdel_39
 28929 0000406A E92BFE                  		jmp	vdel_7 ; 02/01/2019
 28930                                  
 28931                                  		;/* Go ahead and mark it deleted in list array */
 28932                                  
 28933                                  	;/* Throw up a flag to indicate we need to delete this one for real later */
 28934                                  	;/* This is because if we change the ext_table array now, we lose the ability */
 28935                                  	;/* to match up drive letters with locations, or at least it become more */
 28936                                  	;/* complicated than I felt like figuring out, so mark it now and do it later */
 28937                                  
 28938                                  case_vol_del_1:
 28939 0000406D 8B76F8                  		mov	si,[vdel_list_index]
 28940 00004070 D1E6                    		shl	si,1
 28941 00004072 C642C7FE                		mov	byte [si+vdel_drive_list+1],0FEh ; DELETED
 28942 00004076 C646FC01                		mov	byte [drives_reassigned],1 ; TRUE
 28943 0000407A C646B200                		mov	byte [vdel_i],0
 28944 0000407E EB48                    		jmp	short vdel_34
 28945                                  vdel_31:
 28946 00004080 C746B82D00              		mov	word [vdel_column],45
 28947 00004085 8B46B2                  		mov	ax,[vdel_i]
 28948                                  		;sub	ax,8
 28949 00004088 2C08                    		sub	al,8 ; 12-4 ; 04/01/2019
 28950 0000408A 8946B6                  		mov	[vdel_row],ax
 28951 0000408D B94F00                  		mov	cx,79
 28952 00004090 51                      		push	cx
 28953 00004091 50                      		push	ax
 28954 00004092 B92D00                  		mov	cx,45
 28955                                  vdel_32:
 28956 00004095 51                      		push	cx
 28957 00004096 50                      		push	ax
 28958 00004097 E8FCD3                  		call	clear_screen
 28959                                  		;add	sp,8
 28960                                  
 28961                                  		;/* Put the start row,col of message in the message string */
 28962                                  
 28963                                  		;mov	ax,[vdel_row]
 28964                                  		;mov	cx,10
 28965                                  		;cwd
 28966                                  		;idiv	cx
 28967                                  		;add	al,'0'
 28968                                  		;les	bx,[status_3_off]
 28969                                  		;inc	bx
 28970                                  		;mov	[vdel_s],bx
 28971                                  		;mov	[vdel_s+2],es
 28972                                  		;mov	[es:bx],al
 28973                                  
 28974                                  		; 26/12/2018
 28975 0000409A 8B1E[619E]              		mov	bx,[status_3_off]
 28976 0000409E 43                      		inc	bx
 28977 0000409F 8B46B6                  		mov	ax,[vdel_row]
 28978 000040A2 B10A                    		mov	cl,10
 28979 000040A4 F6F1                    		div	cl
 28980 000040A6 053030                  		add	ax,'00'
 28981 000040A9 8907                    		mov	[bx],ax
 28982 000040AB 43                      		inc	bx		
 28983                                  
 28984                                  		;mov	ax,[vdel_row]
 28985                                  		;cwd
 28986                                  		;;idiv	cx
 28987                                  		;div	cx
 28988                                  		;add	dl,'0'
 28989                                  		;inc	word [vdel_s]
 28990                                  		;;les	bx,[vdel_s]
 28991                                  		;mov	bx,[vdel_s]
 28992                                  		;;mov	es:[bx],dl
 28993                                  		;mov	[bx],dl
 28994                                  
 28995                                  		;mov	ax,[vdel_column]
 28996                                  		;cwd
 28997                                  		;idiv	cx
 28998                                  		;add	al,'0'
 28999                                  		;inc	bx
 29000                                  		;mov	[vdel_s],bx
 29001                                  		;mov	[vdel_s+2],es
 29002                                  		;mov	[es:bx],al
 29003                                  		
 29004                                  		; 26/12/2018
 29005 000040AC 8B46B8                  		mov	ax,[vdel_column]
 29006 000040AF F6F1                    		div	cl ; 10
 29007 000040B1 053030                  		add	ax,'00'
 29008 000040B4 43                      		inc	bx
 29009 000040B5 8907                    		mov	[bx],ax
 29010                                  
 29011                                  		;mov	ax,[vdel_column]
 29012                                  		;cwd
 29013                                  		;idiv	cx
 29014                                  		;add	dl,'0'
 29015                                  		;inc	bx
 29016                                  		;mov	[vdel_s],bx
 29017                                  		;mov	[vdel_s+2],es
 29018                                  		;mov	[es:bx],dl
 29019                                  		
 29020                                  		;push	word [status_3_seg]
 29021 000040B7 1E                      		push	ds
 29022 000040B8 FF36[619E]              		push	word [status_3_off]
 29023 000040BC E85BD5                  		call	display
 29024                                  		;pop	bx
 29025                                  		;pop	bx
 29026                                  vdel_33:
 29027 000040BF FE46B2                  		inc	byte [vdel_i]
 29028                                  
 29029                                  		;/* Put prompt up on screen */
 29030                                  ;vdel_34:
 29031 000040C2 807EB217                		cmp	byte [vdel_i],23
 29032 000040C6 7D27                    		jge	short vdel_36
 29033                                  vdel_34:
 29034 000040C8 8B76B2                  		mov	si,[vdel_i]
 29035 000040CB D1E6                    		shl	si,1
 29036 000040CD 807AC7FE                		cmp	byte [si+vdel_drive_list+1],0FEh ; DELETED
 29037 000040D1 75EC                    		jne	short vdel_33
 29038                                  
 29039                                  		;/* Wipe out the drive info and print deleted message */
 29040                                  		;/* See what column it is in */
 29041                                  
 29042 000040D3 807EB20C                		cmp	byte [vdel_i],12
 29043                                  		;jl	short vdel_35
 29044                                  		;jmp	short vdel_31
 29045 000040D7 73A7                    		jnb	short vdel_31	
 29046                                  vdel_35:
 29047 000040D9 C746B80400              		mov	word [vdel_column],4
 29048 000040DE 8B46B2                  		mov	ax,[vdel_i]
 29049                                  		;add	ax,4
 29050 000040E1 0404                    		add	al,4
 29051 000040E3 8946B6                  		mov	[vdel_row],ax
 29052 000040E6 B92700                  		mov	cx,39
 29053 000040E9 51                      		push	cx
 29054 000040EA 50                      		push	ax
 29055                                  		;mov	cx,4
 29056 000040EB B104                    		mov	cl,4
 29057 000040ED EBA6                    		jmp	short vdel_32
 29058                                  
 29059                                  		;/* Set the reboot flag */
 29060                                  vdel_36:
 29061 000040EF C606[6AA0]01            		mov	byte [reboot_flag],1
 29062                                  
 29063                                  case_vol_del_break:
 29064 000040F4 B84F00                  		mov	ax,79
 29065 000040F7 50                      		push	ax
 29066 000040F8 B81700                  		mov	ax,23
 29067 000040FB 50                      		push	ax
 29068 000040FC 29C0                    		sub	ax,ax
 29069 000040FE 50                      		push	ax
 29070 000040FF B81500                  		mov	ax,21
 29071 00004102 50                      		push	ax
 29072 00004103 E890D3                  		call	clear_screen
 29073                                  		;add	sp,8
 29074 00004106 EB20                    		jmp	short vdel_39
 29075                                  
 29076                                  		;/* No more logical drives to delete */
 29077                                  vdel_38:
 29078 00004108 B84F00                  		mov	ax,79
 29079 0000410B 50                      		push	ax
 29080 0000410C B81500                  		mov	ax,21
 29081 0000410F 50                      		push	ax
 29082 00004110 29C0                    		sub	ax,ax
 29083 00004112 50                      		push	ax
 29084 00004113 B81000                  		mov	ax,16
 29085 00004116 50                      		push	ax
 29086 00004117 E87CD3                  		call	clear_screen
 29087                                  		;add	sp,8
 29088                                  		
 29089                                  		;push	word [error_22_seg]
 29090 0000411A 1E                      		push	ds
 29091 0000411B FF36[9C9E]              		push	word [error_22_off]
 29092 0000411F E8F8D4                  		call	display
 29093                                  		;pop	bx
 29094                                  		;pop	bx
 29095                                  
 29096 00004122 E845F0                  		call	wait_for_ESC
 29097 00004125 8846FE                  		mov	[vdel_input],al
 29098                                  
 29099                                  		;/* Loop until ESC or all deleted */
 29100                                  vdel_39:
 29101 00004128 807EFE1B                		cmp	byte [vdel_input],1Bh  ; ESC
 29102 0000412C 7403                    		je	short vdel_40
 29103 0000412E E967FD                  		jmp	vdel_7
 29104                                  vdel_40:
 29105 00004131 807EFC00                		cmp	byte [drives_reassigned],0
 29106 00004135 7503                    		jne	short vol_del_for_1
 29107                                  		
 29108                                  		;/* drives do not exist! */		
 29109                                  		
 29110 00004137 E98600                  		jmp	vdel_49
 29111                                  vol_del_for_1:
 29112                                  		;/* If anything got deleted, lets go do it for real */
 29113                                  		
 29114 0000413A C646B200                		mov	byte [vdel_i],0
 29115                                  
 29116                                  vol_del_for_1_next:
 29117 0000413E 8B76B2                  		mov	si,[vdel_i]
 29118 00004141 D1E6                    		shl	si,1
 29119 00004143 807AC7FE                		cmp	byte [si+vdel_drive_list+1],0FEh ; DELETED
 29120 00004147 7535                    		jne	short vol_del_for_1_condition
 29121                                  
 29122                                  vol_del_for_2:
 29123 00004149 C646AA00                		mov	byte [vdel_j],0
 29124                                  vol_del_for_2_next:
 29125 0000414D B018                    		mov	al,24
 29126                                  		;imul	byte [cur_disk]
 29127 0000414F F626[D4CB]              		mul	byte [cur_disk]
 29128                                  		;add	ax,[vdel_j]
 29129 00004153 0246AA                  		add	al,[vdel_j] ; 04/01/2019
 29130                                  		;mov	cx,46
 29131 00004156 B12E                    		mov	cl,46
 29132                                  		;imul	cx
 29133 00004158 F6E1                    		mul	cl
 29134 0000415A 89C3                    		mov	bx,ax
 29135 0000415C 8A87[77A1]              		mov	al,[ext_table_drive_letter+bx]
 29136                                  		;cbw
 29137 00004160 8B76B2                  		mov	si,[vdel_i]
 29138 00004163 D1E6                    		shl	si,1
 29139 00004165 8A4AC6                  		mov	cl,[si+vdel_drive_list]
 29140                                  		;sub	ch,ch
 29141                                  		;cmp	ax,cx
 29142 00004168 38C8                    		cmp	al,cl
 29143 0000416A 7509                    		jne	short vol_del_for_2_condition
 29144                                  		
 29145                                  		;/* Zero sys id and show it changed */
 29146                                  
 29147                                  		;push	word [vdel_i]
 29148 0000416C 8A4EB2                  		mov	cl,[vdel_i] ; Partition entry number
 29149 0000416F A0[D4CB]                		mov	al,[cur_disk]
 29150                                  		;push	ax
 29151 00004172 E83F06                  		call	remove_volume
 29152                                  		;pop	bx
 29153                                  		;pop	bx
 29154                                  
 29155                                  vol_del_for_2_condition:
 29156 00004175 FE46AA                  		inc	byte [vdel_j]
 29157                                  
 29158 00004178 807EAA17                		cmp	byte [vdel_j],23
 29159 0000417C 7CCF                    		jl	short vol_del_for_2_next
 29160                                  vol_del_for_1_condition:
 29161 0000417E FE46B2                  		inc	byte [vdel_i]
 29162 00004181 807EB217                		cmp	byte [vdel_i],23
 29163 00004185 7CB7                    		jl	short vol_del_for_1_next
 29164                                  
 29165                                  		;/* Show new drive letters */
 29166                                  
 29167 00004187 E84EF0                  		call	volume_display
 29168                                  
 29169 0000418A B84F00                  		mov	ax,79
 29170 0000418D 50                      		push	ax
 29171 0000418E B81700                  		mov	ax,23
 29172 00004191 50                      		push	ax
 29173 00004192 29C0                    		sub	ax,ax
 29174 00004194 50                      		push	ax
 29175 00004195 B81000                  		mov	ax,16
 29176 00004198 50                      		push	ax
 29177 00004199 E8FAD2                  		call	clear_screen
 29178                                  		;add	sp,8
 29179                                  
 29180                                  		;/* Say that drive letters changed */
 29181                                  
 29182                                  		; 04/01/2019
 29183                                  
 29184                                  		;push	word [status_10_seg]
 29185 0000419C 1E                      		push	ds
 29186 0000419D FF36[6F9E]              		push	word [status_10_off]
 29187 000041A1 EB17                    		jmp	short vdel_48
 29188                                  vdel_47:
 29189 000041A3 B84F00                  		mov	ax,79
 29190 000041A6 50                      		push	ax
 29191 000041A7 B81500                  		mov	ax,21
 29192 000041AA 50                      		push	ax
 29193 000041AB 29C0                    		sub	ax,ax
 29194 000041AD 50                      		push	ax
 29195 000041AE B81000                  		mov	ax,16
 29196 000041B1 50                      		push	ax
 29197 000041B2 E8E1D2                  		call	clear_screen
 29198                                  		;add	sp,8
 29199                                  
 29200                                  		;push	word [error_36_seg]
 29201 000041B5 1E                      		push	ds
 29202 000041B6 FF36[B89E]              		push	word [error_36_off]
 29203                                  vdel_48:
 29204 000041BA E85DD4                  		call	display
 29205                                  		;pop	bx
 29206                                  		;pop	bx
 29207                                  		
 29208 000041BD E8AAEF                  		call	wait_for_ESC
 29209                                  vdel_49:
 29210                                  		;mov	ax,79
 29211                                  		;push	ax
 29212                                  		;mov	ax,24
 29213                                  		;push	ax
 29214                                  		;sub	ax,ax
 29215                                  		;push	ax
 29216                                  		;push	ax
 29217                                  		;call	clear_screen
 29218                                  		;add	sp,8
 29219                                  
 29220 000041C0 E89BD2                  		call	CLS
 29221                                  
 29222                                  		;pop	si *
 29223                                  
 29224 000041C3 89EC                    		mov	sp,bp
 29225 000041C5 5D                      		pop	bp
 29226 000041C6 C3                      		retn
 29227                                  
 29228                                  ; fdisk.msg (MSDOS 6.0)
 29229                                  ;/***************************************************************************************************/
 29230                                  ;/*  Screen for NON_DOS_DELETE                                                                      */
 29231                                  ;/*                                                                                                 */
 29232                                  ;/*     |00000000001111111111222222222233333333334444444444555555555566666666667777777777|          */
 29233                                  ;/*     |01234567890123456789012345678901234567890123456789012345678901234567890123456789|          */
 29234                                  ;/*   --|--------------------------------------------------------------------------------|          */
 29235                                  ;/*   00|                                                                                |          */
 29236                                  ;/*   01|                                                                                |          */
 29237                                  ;/*   02|                                                                                |          */
 29238                                  ;/*   03|                                                                                |          */
 29239                                  ;/*   04|                            Delete Non-DOS Partition                            |menu_58   */
 29240                                  ;/*   05|                                                                                |          */
 29241                                  ;/*   06|    Current fixed disk drive: #                                                 |menu_5 #  */
 29242                                  ;/*   07|                                                                                |          */
 29243                                  ;/*   08|    Partition Status   Type    Size in Mbytes   Percentage of Disk Used         |menu_14 # */
 29244                                  ;/*   09|     ## #        #   #######       ####         ###%                            |menu_14 # */
 29245                                  ;/*   10|     ## #        #   #######       ####         ###%                            |          */
 29246                                  ;/*   11|     ## #        #   #######       ####         ###%                            |          */
 29247                                  ;/*   12|     ## #        #   #######       ####         ###%                            |          */
 29248                                  ;/*   13|                                                                                |          */
 29249                                  ;/*   14|    Total disk space is #### Mbytes (1 Mbyte = 1048576 bytes)                   |menu_15 # */
 29250                                  ;/*   15|                                                                                |          */
 29251                                  ;/*   16|    Warning! Data in the deleted Non-DOS Partition will be lost.                |menu_59   */
 29252                                  ;/*   17|    What Non-DOS partition do you want to delete..? [ ]                         |          */
 29253                                  ;/*   18|                                                                                |          */
 29254                                  ;/*   19|    Do you wish to continue (Y/N).................? [N]                         |menu_56   */
 29255                                  ;/*   20|                                                                                |          */
 29256                                  ;/*   21|                                                                                |          */
 29257                                  ;/*   22|                                                                                |          */
 29258                                  ;/*   23|                                                                                |          */
 29259                                  ;/*   24|    Press ESC to return to FDISK Options                                        |menu_11   */
 29260                                  ;/*   ------------------------------------------------------------------------------------          */
 29261                                  ;/*                                                                                                 */
 29262                                  ;/***************************************************************************************************/
 29263                                  
 29264                                  ; d_menus.c (MSDOS 6.0)
 29265                                  ;/*  */
 29266                                  ;/******************* START OF SPECIFICATIONS *******************/
 29267                                  ;/*                                                             */
 29268                                  ;/* SUBROUTINE NAME: NON_DOS_DELETE                             */
 29269                                  ;/*                                                             */
 29270                                  ;/* DESCRIPTIVE NAME: Delete Non-DOS partition                  */
 29271                                  ;/*                                                             */
 29272                                  ;/* FUNCTION: Delete the Non-DOS partition. Prompt user with    */
 29273                                  ;/*           warning first. Default entry on prompt is (N)     */
 29274                                  ;/*                                                             */
 29275                                  ;/* NOTES: Screen can be exited via the ESC command before      */
 29276                                  ;/*        partition is deleted and nothing will change         */
 29277                                  ;/*                                                             */
 29278                                  ;/*        The following screen is managed                      */
 29279                                  ;/*                                                             */
 29280                                  ;/*     |0000000000111111111122222222223333333333|              */
 29281                                  ;/*     |0123456789012345678901234567890123456789|              */
 29282                                  ;/*   --|----------------------------------------|              */
 29283                                  ;/*   00|                                        |              */
 29284                                  ;/*   01|                                        |              */
 29285                                  ;/*   02|                                        |              */
 29286                                  ;/*   03|                                        |              */
 29287                                  ;/*   04|Delete Non-DOS Partition                |              */
 29288                                  ;/*   05|                                        |              */
 29289                                  ;/*   06|Current Fixed Disk Drive: #             |              */
 29290                                  ;/*   07|                                        |              */
 29291                                  ;/*   08|Partition Status   Type  Start  End Size|              */
 29292                                  ;/*   09|    #        #   #######  #### #### ####|              */
 29293                                  ;/*   10|                                        |              */
 29294                                  ;/*   11|                                        |              */
 29295                                  ;/*   12|                                        |              */
 29296                                  ;/*   13|                                        |              */
 29297                                  ;/*   14|Total disk space is #### cylinders.     |              */
 29298                                  ;/*   15|                                        |              */
 29299                                  ;/*   16|                                        |              */
 29300                                  ;/*   17|                                        |              */
 29301                                  ;/*   18|Warning! Data in the Non-DOS partition  |              */
 29302                                  ;/*   19|will be lost. Do you wish to            |              */
 29303                                  ;/*   20|continue..........................? [N] |              */
 29304                                  ;/*   21|                                        |              */
 29305                                  ;/*   22|                                        |              */
 29306                                  ;/*   23|Press ESC to return to FDISK Options    |              */
 29307                                  ;/*   --------------------------------------------              */
 29308                                  ;/*                                                             */
 29309                                  ;/* ENTRY POINTS: Non_DOS_Delete                                */
 29310                                  ;/*      LINKAGE: non_dos_delete                                */
 29311                                  ;/*          NEAR CALL                                          */
 29312                                  ;/*                                                             */
 29313                                  ;/* INPUT: None                                                 */
 29314                                  ;/*                                                             */
 29315                                  ;/* EXIT-NORMAL: ERROR=FALSE                                    */
 29316                                  ;/*                                                             */
 29317                                  ;/* EXIT-ERROR: ERROR=TRUE                                      */
 29318                                  ;/*             GOTO internal_program_error if invalid input    */
 29319                                  ;/*             returned to this level                          */
 29320                                  ;/*                                                             */
 29321                                  ;/* EFFECTS: No data directly modified by this routine, but     */
 29322                                  ;/*          child routines will modify data.                   */
 29323                                  ;/*                                                             */
 29324                                  ;/* INTERNAL REFERENCES:                                        */
 29325                                  ;/*   ROUTINES                                                  */
 29326                                  ;/*      table_display                                          */
 29327                                  ;/*      clear_screen                                           */
 29328                                  ;/*      wait_for_ESC                                           */
 29329                                  ;/*      get_yn_input                                           */
 29330                                  ;/*      display                                                */
 29331                                  ;/*      Write_Boot_Record                                      */
 29332                                  ;/*      find_part_free_space                                   */
 29333                                  ;/*                                                             */
 29334                                  ;/* EXTERNAL REFERENCES:                                        */
 29335                                  ;/*   ROUTINES:                                                 */
 29336                                  ;/*                                                             */
 29337                                  ;/******************** END OF SPECIFICATIONS ********************/
 29338                                                                                                     
 29339                                  ;/*  */                                                              
 29340                                  ;void non_dos_delete()                                                
 29341                                  ;                                                                     
 29342                                  ;BEGIN                                                                
 29343                                  ;                                                                     
 29344                                  ;    char input;                                                      
 29345                                  ;    unsigned i;                                                      
 29346                                  ;    int     j;                                                       
 29347                                  ;    int     cnt;                                                     
 29348                                  ;    int     pnum;                                                    
 29349                                  ;                                                                     
 29350                                  ;    input = c(NUL);                                                  
 29351                                  ;    /* clear screen */                                               
 29352                                  ;    clear_screen(u(0),u(0),u(24),u(79));                             
 29353                                  ;                                                                     
 29354                                  ;    /* Display header */                                             
 29355                                  ;    display(menu_58);                                                
 29356                                  ;                                                                     
 29357                                  ;    /* Setup and print current disk */                               
 29358                                  ;    insert[0] = cur_disk+1+'0';                                      
 29359                                  ;    display(menu_5);                                                 
 29360                                  ;                                                                     
 29361                                  ;    /* print ESC prompt */                                           
 29362                                  ;    display(menu_11);                                                
 29363                                  ;                                                                     
 29364                                  ;    /* Display partition data and double check if partition exists*/ 
 29365                                  ;    if (table_display())                                             
 29366                                  ;       BEGIN                                                         
 29367                                  ;                                                                     
 29368                                  ;        sprintf(insert,"%4.0d",total_mbytes[cur_disk]);              
 29369                                  ;        display(menu_15);                                            
 29370                                  ;                                                                     
 29371                                  ;        /* count the number of partitions */                         
 29372                                  ;        cnt = 0;                                                     
 29373                                  ;        for (i = u(0); i < u(4); i++)                                
 29374                                  ;            if (part_table[cur_disk][i].sys_id != uc(0))             
 29375                                  ;                cnt++;                                               
 29376                                  ;                                                                     
 29377                                  ;        /* Display partition number prompt */                        
 29378                                  ;        display(menu_59);                                            
 29379                                  ;                                                                     
 29380                                  ;        /* Get the partition number from the user */                 
 29381                                  ;        input = get_num_input(c(1),c(cnt),input_row,input_col);      
 29382                                  ;                                                                     
 29383                                  ;        if (input != ESC)                                            
 29384                                  ;           BEGIN                                                     
 29385                                  ;            pnum = (int)input - '0';                                 
 29386                                  ;                                                                     
 29387                                  ;            /* The number that the user has entered is the sorted */ 
 29388                                  ;            /* numbering of the partition table.  We have to      */ 
 29389                                  ;            /* retrieve the actual position of this partition in  */ 
 29390                                  ;            /* the partition table.                               */ 
 29391                                  ;                                                                     
 29392                                  ;            j = 0;                                                   
 29393                                  ;            for (i = 0; i < 4; i++)                                  
 29394                                  ;               BEGIN                                                 
 29395                                  ;                if (part_table[cur_disk][sort[i]].sys_id != 0)       
 29396                                  ;                   BEGIN                                             
 29397                                  ;                    j++;                                             
 29398                                  ;                    if (j == pnum)                                   
 29399                                  ;                        break;                                       
 29400                                  ;                   END                                               
 29401                                  ;               END                                                   
 29402                                  ;            i = sort[i];                                             
 29403                                  ;                                                                     
 29404                                  ;            /* Verify selected partition is a non-DOS partition */   
 29405                                  ;                                                                     
 29406                                  ;            if ((part_table[cur_disk][i].sys_id!=uc(DOS12))  &&      
 29407                                  ;                (part_table[cur_disk][i].sys_id!=uc(DOS16))  &&      
 29408                                  ;                (part_table[cur_disk][i].sys_id!=uc(DOSNEW)) &&      
 29409                                  ;                (part_table[cur_disk][i].sys_id!=uc(EXTENDED)) )     
 29410                                  ;               BEGIN                                                 
 29411                                  ;                /* Display Y/N prompt */                             
 29412                                  ;                display(menu_56);                                    
 29413                                  ;                                                                     
 29414                                  ;                /* Get yes/no prompt */                              
 29415                                  ;                input = get_yn_input(c(No),input_row,input_col);     
 29416                                  ;                switch(input)                                        
 29417                                  ;                   BEGIN                                             
 29418                                  ;                    case 1:                                          
 29419                                  ;                       BEGIN                                         
 29420                                  ;                        /* Set Partition entry to zero */            
 29421                                  ;                        remove_partition(cur_disk,i);
 29422                                  ;                                                                  
 29423                                  ;                        /* Redisplay the partition info */           
 29424                                  ;                        table_display();                             
 29425                                  ;                                                                     
 29426                                  ;                        /* clear the prompt off */                   
 29427                                  ;                        clear_screen(u(16),u(0),u(23),u(79));        
 29428                                  ;                                                                     
 29429                                  ;                        /* Set the reboot flag */                    
 29430                                  ;                        reboot_flag = (FLAG)TRUE;                    
 29431                                  ;                                                                     
 29432                                  ;                        /* Say that you deleted it */                
 29433                                  ;                        display(status_13);                          
 29434                                  ;                                                                     
 29435                                  ;                        wait_for_ESC();                              
 29436                                  ;                        break;                                       
 29437                                  ;                       END                                           
 29438                                  ;                                                                     
 29439                                  ;                    case 0:                                          
 29440                                  ;                        break;                                       
 29441                                  ;                                                                     
 29442                                  ;                    case ESC:                                        
 29443                                  ;                        break;                                       
 29444                                  ;                                                                     
 29445                                  ;                    default:                                         
 29446                                  ;                       BEGIN                                         
 29447                                  ;                        internal_program_error();                    
 29448                                  ;                        break;                                       
 29449                                  ;                       END                                           
 29450                                  ;                   END                                               
 29451                                  ;               END                                                   
 29452                                  ;            else                                                     
 29453                                  ;               BEGIN                                                 
 29454                                  ;                /* Tell user he can only delete non-DOS partition */ 
 29455                                  ;                display(error_39);                                   
 29456                                  ;                wait_for_ESC();                                      
 29457                                  ;               END                                                   
 29458                                  ;           END                                                       
 29459                                  ;       END                                                           
 29460                                  ;    else                                                             
 29461                                  ;       BEGIN                                                         
 29462                                  ;        internal_program_error();                                    
 29463                                  ;       END                                                           
 29464                                  ;    clear_screen(u(0),u(0),u(24),u(79));                             
 29465                                  ;    return;                                                          
 29466                                  ;END 
 29467                                  
 29468                                  non_dos_delete:
 29469                                  		; 31/12/2018
 29470                                  
 29471                                  	%define ndd_j	 bp-10
 29472                                  	%define ndd_i	 bp-8
 29473                                  	%define ndd_cnt	 bp-6
 29474                                  	%define ndd_pnum bp-2
 29475                                  
 29476 000041C7 55                      		push	bp
 29477 000041C8 89E5                    		mov	bp,sp
 29478 000041CA 83EC0A                  		sub	sp,10
 29479                                  
 29480                                  		;/* clear screen */
 29481                                  
 29482                                  		;mov	ax,79
 29483                                  		;push	ax
 29484                                  		;mov	ax,24
 29485                                  		;push	ax
 29486                                  		;sub	ax,ax
 29487                                  		;push	ax
 29488                                  		;push	ax
 29489                                  		;call	clear_screen
 29490                                  		;add	sp,8
 29491                                  
 29492 000041CD E88ED2                  		call	CLS
 29493                                  
 29494                                  		;/* Display header */
 29495                                  
 29496                                  		;push	word [menu_58_segment]
 29497 000041D0 1E                      		push	ds
 29498 000041D1 FF36[3F9E]              		push	word [menu_58_offset]
 29499 000041D5 E842D4                  		call	display
 29500                                  		;pop	bx
 29501                                  		;pop	bx
 29502                                  
 29503                                  		;/* Setup and print current disk */
 29504                                  		
 29505                                  		;mov	al,[cur_disk]
 29506                                  		;add	al,'1'
 29507                                  		;mov	[insert],al
 29508                                  		;;push	word [menu_5_segment]
 29509                                  		;push	ds
 29510                                  		;push	word [menu_5_offset]
 29511                                  		;call	display
 29512                                  		;;pop	bx
 29513                                  		;;pop	bx
 29514                                  
 29515 000041D8 E878EC                  		call	display_menu_5 ; 31/12/2018
 29516                                  
 29517                                  		;/* print ESC prompt */   
 29518                                  
 29519                                  		;;push	word [menu_11_segment]
 29520                                  		;push	ds
 29521                                  		;push	word [menu_11_offset]
 29522                                  		;call	display
 29523                                  		;;pop	bx
 29524                                  		;;pop	bx
 29525                                  
 29526 000041DB E886EC                  		call	display_menu_11 ; 31/12/2018
 29527                                  
 29528                                  		;/* Display partition data and double check if partition exists*/ 
 29529                                  
 29530 000041DE E88CEC                  		call	table_display
 29531                                  		;or	al, al
 29532                                  		;jnz	short ndd_1
 29533 000041E1 7303                    		jnc	short ndd_1
 29534 000041E3 E91F01                  		jmp	case_nondos_del_DEF
 29535                                  ndd_1:
 29536 000041E6 A0[D4CB]                		mov	al,[cur_disk]
 29537 000041E9 98                      		cbw
 29538 000041EA 89C3                    		mov	bx,ax
 29539 000041EC D1E3                    		shl	bx,1
 29540 000041EE FFB7[C8A0]              		push	word [total_mbytes+bx]
 29541 000041F2 B8[846F]                		mov	ax,nd_p_size_format ; "%4.1d"
 29542 000041F5 50                      		push	ax
 29543 000041F6 B8[E6CC]                		mov	ax,insert
 29544 000041F9 50                      		push	ax
 29545 000041FA E8BEE0                  		call	sprintf
 29546 000041FD 83C406                  		add	sp,6
 29547                                  
 29548                                  		;push	word [menu_15_segment]
 29549 00004200 1E                      		push	ds
 29550 00004201 FF36[059E]              		push	word [menu_15_offset]
 29551 00004205 E812D4                  		call	display
 29552                                  		;pop	bx
 29553                                  		;pop	bx
 29554                                  
 29555                                  		;/* count the number of partitions */   
 29556                                  
 29557 00004208 31D2                    		xor	dx,dx
 29558 0000420A 8956FA                  		mov	[ndd_cnt],dx ; 0
 29559 0000420D 8956F8                  		mov	[ndd_i],dx ;0
 29560                                  ndd_2:
 29561 00004210 A0[D4CB]                		mov	al,[cur_disk]
 29562                                  		;cbw
 29563                                  		;shl	ax,1
 29564                                  		;shl	ax,1
 29565                                  		;add	ax,[ndd_i]
 29566 00004213 D0E0                    		shl	al,1
 29567 00004215 D0E0                    		shl	al,1
 29568 00004217 0246F8                  		add	al,[ndd_i]		
 29569                                  		;mov	cx,46
 29570                                  		;mul	cx
 29571 0000421A 89C3                    		mov	bx,ax
 29572 0000421C 80BF[17C4]00            		cmp	byte [part_table_sys_id+bx],0
 29573 00004221 7403                    		je	short ndd_3
 29574 00004223 FE46FA                  		inc	byte [ndd_cnt]
 29575                                  ndd_3:
 29576 00004226 FE46F8                  		inc	byte [ndd_i]
 29577 00004229 807EF804                		cmp	byte [ndd_i],4
 29578 0000422D 72E1                    		jb	short ndd_2
 29579                                  
 29580                                  		;/* Display partition number prompt */  
 29581                                  
 29582                                  		;push	word [menu_59_segment]
 29583 0000422F 1E                      		push	ds
 29584 00004230 FF36[419E]              		push	word [menu_59_offset]
 29585 00004234 E8E3D3                  		call	display
 29586                                  		;pop	bx
 29587                                  		;pop	bx
 29588 00004237 FF36[9CA0]              		push	word [input_col]
 29589 0000423B FF36[3EA1]              		push	word [input_row]
 29590 0000423F 8A46FA                  		mov	al,[ndd_cnt]  ; maximum
 29591 00004242 50                      		push	ax
 29592 00004243 B001                    		mov	al,1  ; default
 29593 00004245 50                      		push	ax
 29594 00004246 E821E8                  		call	get_num_input
 29595                                  		;add	sp,8
 29596                                  
 29597 00004249 3C1B                    		cmp	al,1Bh
 29598 0000424B 7503                    		jne	short ndd_4
 29599 0000424D E9B800                  		jmp	case_nondos_del_break
 29600                                  ndd_4:
 29601 00004250 98                      		cbw
 29602                                  		;sub	ax,'0'
 29603 00004251 2C30                    		sub	al,'0'
 29604 00004253 8946FE                  		mov	[ndd_pnum],ax
 29605                                  
 29606                                  	;/* The number that the user has entered is the sorted */ 
 29607                                          ;/* numbering of the partition table.  We have to      */ 
 29608                                          ;/* retrieve the actual position of this partition in  */ 
 29609                                          ;/* the partition table.                               */ 
 29610                                  
 29611 00004256 C646F600                		mov	byte [ndd_j],0
 29612 0000425A C646F800                		mov	byte [ndd_i],0
 29613 0000425E EB03                    		jmp	short ndd_6
 29614                                  ndd_5:
 29615 00004260 FE46F8                  		inc	byte [ndd_i]
 29616                                  ndd_6:
 29617 00004263 A0[D4CB]                		mov	al,[cur_disk]
 29618                                  		;cbw
 29619                                  		;shl	ax,1
 29620                                  		;shl	ax,1
 29621 00004266 D0E0                    		shl	al,1
 29622 00004268 D0E0                    		shl	al,1
 29623 0000426A 8B5EF8                  		mov	bx,[ndd_i]
 29624                                  		;mov	cx,ax
 29625                                  		;mov	al,[sort+bx]
 29626 0000426D 8A97[E2C3]              		mov	dl,[sort+bx] ; *=*
 29627                                  		;cbw
 29628                                  		;add	ax,cx
 29629 00004271 00D0                    		add	al,dl
 29630                                  		;mov	cx,46
 29631                                  		;imul	cx
 29632 00004273 B12E                    		mov	cl,46
 29633 00004275 F6E1                    		mul	cl
 29634 00004277 89C3                    		mov	bx,ax
 29635                                  
 29636 00004279 807EF804                		cmp	byte [ndd_i],4
 29637 0000427D 7313                    		jnb	short ndd_7
 29638                                  
 29639                                  		;mov	al,[cur_disk]
 29640                                  		;;cbw
 29641                                  		;;shl	ax,1
 29642                                  		;;shl	ax,1
 29643                                  		;shl	al,1
 29644                                  		;shl	al,1
 29645                                  		;mov	bx,[ndd_i]
 29646                                  		;;mov	cx,ax
 29647                                  		;;mov	al,[sort+bx]
 29648                                  		;mov	cl,[sort+bx]
 29649                                  		;;cbw
 29650                                  		;;add	ax,cx
 29651                                  		;add	al,cl
 29652                                  		;;mov	cx,46
 29653                                  		;;imul	cx
 29654                                  		;mov	cl,46
 29655                                  		;mul	cl
 29656                                  		;mov	bx,ax
 29657                                  
 29658 0000427F 8AB7[17C4]              		mov	dh,[part_table_sys_id+bx]  ; *==*
 29659                                  
 29660                                  		;cmp	byte [part_table_sys_id+bx],0
 29661                                  		;je	short ndd_5
 29662                                  
 29663 00004283 08F6                    		or	dh,dh
 29664 00004285 74D9                    		jz	short ndd_5
 29665                                  
 29666                                  		;mov	ax,[ndd_pnum]
 29667 00004287 8A46FE                  		mov	al,[ndd_pnum]
 29668 0000428A FE46F6                  		inc	byte [ndd_j]
 29669                                  		;cmp	[ndd_j],ax
 29670 0000428D 3846F6                  		cmp	[ndd_j],al
 29671 00004290 75CE                    		jne	short ndd_5
 29672                                  ndd_7:
 29673                                  		;mov	al,[cur_disk]
 29674                                  		;cbw
 29675                                  		;shl	ax,1
 29676                                  		;shl	ax,1
 29677                                  		;mov	bx,[ndd_i]
 29678                                  		;mov	cx,ax
 29679                                  		;mov	al,[sort+bx]
 29680                                  		;cbw
 29681                                  		;mov	[ndd_i],ax
 29682                                  
 29683 00004292 8856F8                  		mov	[ndd_i],dl ; *=*
 29684                                  
 29685                                  		;add	ax,cx
 29686                                  		;mov	cx,46
 29687                                  		;mul	cx
 29688                                  		;mov	bx,ax
 29689                                  
 29690                                  		;/* Verify selected partition is a non-DOS partition */  
 29691                                  		
 29692                                  		; dh = [part_table_sys_id+bx] ; *==*
 29693                                  
 29694                                  		;cmp	byte [part_table_sys_id+bx],1
 29695 00004295 80FE01                  		cmp	dh,1
 29696 00004298 7464                    		je	short ndd_11
 29697                                  		;cmp	byte [part_table_sys_id+bx],4
 29698 0000429A 80FE04                  		cmp	dh,4
 29699 0000429D 745F                    		je	short ndd_11
 29700                                  		;cmp	byte [part_table_sys_id+bx],6
 29701 0000429F 80FE06                  		cmp	dh,6
 29702 000042A2 745A                    		je	short ndd_11
 29703                                  		;cmp	byte [part_table_sys_id+bx],5
 29704 000042A4 80FE05                  		cmp	dh,5
 29705 000042A7 7455                    		je	short ndd_11
 29706                                  
 29707                                  		;/* Display Y/N prompt */
 29708                                  
 29709                                  		;push	word [menu_56_segment]
 29710 000042A9 1E                      		push	ds
 29711 000042AA FF36[319E]              		push	word [menu_56_offset]
 29712 000042AE E869D3                  		call	display
 29713                                  		;pop	bx
 29714                                  		;pop	bx
 29715                                  
 29716                                  		;/* Get yes/no prompt */ 
 29717                                  		
 29718 000042B1 FF36[9CA0]              		push	word [input_col]
 29719 000042B5 FF36[3EA1]              		push	word [input_row]
 29720 000042B9 A0[9EA0]                		mov	al,[No] ; default input, 'N'
 29721 000042BC 50                      		push	ax
 29722 000042BD E884ED                  		call	get_yn_input
 29723                                  		;add	sp,6
 29724                                  switch_input6:
 29725                                  		;cbw
 29726                                  		;cmp	ax,1Bh
 29727 000042C0 3C1B                    		cmp	al,1Bh
 29728 000042C2 7444                    		je	short case_nondos_del_break
 29729 000042C4 773F                    		ja	short case_nondos_del_DEF
 29730 000042C6 08C0                    		or	al,al
 29731 000042C8 743E                    		jz	short case_nondos_del_break
 29732 000042CA FEC8                    		dec	al
 29733 000042CC 7537                    		jnz	short case_nondos_del_DEF
 29734                                  
 29735                                  case_nondos_del_1:
 29736                                  		;/* Set Partition entry to zero */
 29737                                  
 29738                                  		;push	word [ndd_i]
 29739 000042CE 8A66F8                  		mov	ah,[ndd_i] ; 02/01/2019
 29740 000042D1 A0[D4CB]                		mov	al,[cur_disk]
 29741                                  		;push	ax
 29742 000042D4 E88704                  		call	remove_partition
 29743                                  		;pop	bx
 29744                                  		;pop	bx
 29745                                  
 29746                                  		;/* Redisplay the partition info */ 
 29747                                  		
 29748 000042D7 E893EB                  		call	table_display
 29749                                  
 29750                                  		;/* clear the prompt off */    
 29751                                  		
 29752 000042DA B84F00                  		mov	ax,79
 29753 000042DD 50                      		push	ax
 29754 000042DE B81700                  		mov	ax,23
 29755 000042E1 50                      		push	ax
 29756 000042E2 29C0                    		sub	ax,ax
 29757 000042E4 50                      		push	ax
 29758 000042E5 B81000                  		mov	ax,16
 29759 000042E8 50                      		push	ax
 29760 000042E9 E8AAD1                  		call	clear_screen
 29761                                  		;add	sp,8
 29762                                  
 29763                                  		;/* Set the reboot flag */ 
 29764                                  
 29765 000042EC C606[6AA0]01            		mov	byte [reboot_flag],1
 29766                                  
 29767                                  		;/* Say that you deleted it */
 29768                                  
 29769                                  		;push	word [status_13_seg]
 29770 000042F1 1E                      		push	ds
 29771 000042F2 FF36[739E]              		push	word [status_13_off]
 29772                                  ndd_10:
 29773 000042F6 E821D3                  		call	display
 29774                                  		;pop	bx
 29775                                  		;pop	bx
 29776 000042F9 E86EEE                  		call	wait_for_ESC
 29777 000042FC EB0A                    		jmp	short case_nondos_del_break
 29778                                  ndd_11:
 29779                                  		;/* Tell user he can only delete non-DOS partition */ 
 29780                                  
 29781                                  		;push	word [error_39_seg]
 29782 000042FE 1E                      		push	ds
 29783 000042FF FF36[BE9E]              		push	word [error_39_off]
 29784 00004303 EBF1                    		jmp	short ndd_10
 29785                                  case_nondos_del_DEF:
 29786 00004305 E809F0                  		call	internal_program_error
 29787                                  case_nondos_del_break:
 29788                                  		;mov	ax,79
 29789                                  		;push	ax
 29790                                  		;mov	ax,24
 29791                                  		;push	ax
 29792                                  		;sub	ax,ax
 29793                                  		;push	ax
 29794                                  		;push	ax
 29795                                  		;call	clear_screen
 29796                                  		
 29797 00004308 E853D1                  		call	CLS
 29798                                  
 29799 0000430B 89EC                    		mov	sp,bp
 29800 0000430D 5D                      		pop	bp
 29801 0000430E C3                      		retn
 29802                                  
 29803                                  ; ----------------------------------------------------------------------------
 29804                                  ; partinfo.c (FDISK, MSDOS 6.0, 1991)	
 29805                                  ; ----------------------------------------------------------------------------
 29806                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 23/12/2018)
 29807                                  
 29808                                  ;char find_non_dos_partition()
 29809                                  ;
 29810                                  ;BEGIN
 29811                                  ; char  i;
 29812                                  ;
 29813                                  ; /* Look at all four partition entries for system id byte that is */
 29814                                  ; /* not NUL, DOS12, DOS16, DOSNEW, or EXTENDED. */
 29815                                  ; for (i = c(0); i < c(4);i++)
 29816                                  ;    BEGIN
 29817                                  ;
 29818                                  ;     /* if we find a match, do a TRUE return */
 29819                                  ;     if ((part_table[cur_disk][i].sys_id != NUL)    &&
 29820                                  ;         (part_table[cur_disk][i].sys_id != DOS12)  &&
 29821                                  ;         (part_table[cur_disk][i].sys_id != DOS16)  &&
 29822                                  ;         (part_table[cur_disk][i].sys_id != DOSNEW) &&
 29823                                  ;         (part_table[cur_disk][i].sys_id != EXTENDED))
 29824                                  ;        BEGIN
 29825                                  ;         return(TRUE);
 29826                                  ;         break;
 29827                                  ;        END
 29828                                  ;    END
 29829                                  ; /* Did not find one, return FALSE */
 29830                                  ; return(FALSE);
 29831                                  ;END
 29832                                  
 29833                                  find_non_dos_partition:
 29834                                  		; 23/12/2018
 29835                                  
 29836                                  	;%define fndp_i	bp-2
 29837                                  
 29838                                  		;push	bp
 29839                                  		;mov	bp,sp
 29840                                  		;sub	sp,2
 29841                                  		
 29842                                  		;mov	byte [fndp_i],0
 29843 0000430F 30D2                    		xor	dl,dl
 29844 00004311 EB07                    		jmp	short fndp_2
 29845                                  fndp_1:
 29846                                  		;inc	byte [fndp_i]
 29847 00004313 FEC2                    		inc	dl
 29848                                  ;fndp_2:
 29849                                  		;cmp	byte [fndp_i],4
 29850 00004315 80FA04                  		cmp	dl,4
 29851 00004318 7D2F                    		jge	short fndp_3
 29852                                  fndp_2:
 29853 0000431A A0[D4CB]                		mov	al,[cur_disk]
 29854                                  		;cbw
 29855                                  		;shl	ax,1
 29856                                  		;shl	ax,1
 29857 0000431D D0E0                    		shl	al,1
 29858 0000431F D0E0                    		shl	al,1
 29859                                  		;mov	cx,ax
 29860                                  		;mov	al,[fndp_i]
 29861                                  		;cbw
 29862                                  		;add	ax,cx
 29863 00004321 00D0                    		add	al,dl
 29864                                  		;mov	cx,46
 29865                                  		;imul	cx
 29866 00004323 B12E                    		mov	cl,46
 29867 00004325 F6E1                    		mul	cl
 29868 00004327 89C3                    		mov	bx,ax
 29869                                  		
 29870 00004329 8A8F[17C4]              		mov	cl,[part_table_sys_id+bx]
 29871                                  		
 29872                                  		;cmp	byte [part_table_sys_id+bx],0
 29873                                  		;je	short fndp_1
 29874 0000432D 08C9                    		or	cl,cl
 29875 0000432F 74E2                    		jz	short fndp_1
 29876                                  
 29877                                  		;cmp	byte [part_table_sys_id+bx],1
 29878                                  		;je	short fndp_1
 29879 00004331 80F901                  		cmp	cl,1
 29880 00004334 74DD                    		je	short fndp_1
 29881                                  
 29882                                  		;cmp	byte [part_table_sys_id+bx],4
 29883                                  		;je	short fndp_1
 29884 00004336 80F904                  		cmp	cl,4
 29885 00004339 74D8                    		je	short fndp_1
 29886                                  		
 29887                                  		;cmp	byte [part_table_sys_id+bx],6
 29888                                  		;je	short fndp_1
 29889 0000433B 80F906                  		cmp	cl,6
 29890 0000433E 74D3                    		je	short fndp_1		
 29891                                  
 29892                                  		;cmp	byte [part_table_sys_id+bx],5
 29893                                  		;je	short fndp_1
 29894 00004340 80F905                  		cmp	cl,5
 29895 00004343 74CE                    		je	short fndp_1
 29896                                  
 29897 00004345 B001                    		mov	al,1
 29898 00004347 EB02                    		jmp	short fndp_4
 29899                                  fndp_3:
 29900 00004349 28C0                    		sub	al,al
 29901                                  fndp_4:
 29902 0000434B 3C01                    		cmp	al,1
 29903                                  
 29904                                  		;mov	sp,bp
 29905                                  		;pop	bp
 29906                                  
 29907 0000434D C3                      		retn
 29908                                  
 29909                                  ; ----------------------------------------------------------------------------
 29910                                  
 29911                                  ;char find_ext_drive(offset)
 29912                                  ;
 29913                                  ;char offset;
 29914                                  ;
 29915                                  ;BEGIN
 29916                                  ;
 29917                                  ;char number_found;
 29918                                  ;char i;
 29919                                  ;
 29920                                  ;    number_found = c(0);
 29921                                  ;
 29922                                  ;    /* Go look for the nth extended drive */
 29923                                  ;    for (i=c(0); i < c(23); i++)
 29924                                  ;      BEGIN
 29925                                  ;       /* See if there is a drive we know about */
 29926                                  ;       if ((ext_table[cur_disk][i].sys_id == uc(DOS12)) || (ext_table[cur_disk][i].sys_id == uc(DOS16)) ||
 29927                                  ;          (ext_table[cur_disk][i].sys_id == uc(DOSNEW)))
 29928                                  ;          BEGIN
 29929                                  ;           /* Is this the one we were looking for ? */
 29930                                  ;           if (number_found == offset)
 29931                                  ;              BEGIN
 29932                                  ;               /* Yes it is, return where we found it */
 29933                                  ;               return(i);
 29934                                  ;               break;
 29935                                  ;              END
 29936                                  ;              /* Show we found one and go look for the next */
 29937                                  ;              number_found++;
 29938                                  ;          END
 29939                                  ;      END
 29940                                  ;      /* We should never get here */
 29941                                  ;      internal_program_error();
 29942                                  ;      return(c(INVALID));
 29943                                  ;END
 29944                                  
 29945                                  find_ext_drive:
 29946                                  		; 26/12/2018
 29947                                  	;%define fed_number_found bp-4
 29948                                  	;%define fed_i		 bp-2
 29949                                  	;%define fed_offset	 bp+4
 29950                                  
 29951                                  		;push	bp
 29952                                  		;mov	bp,sp
 29953                                  		;sub	sp,4
 29954                                  
 29955                                  		; INPUT: DL = Logical dos drive offset/index
 29956                                  		; 06/01/2019
 29957                                  		; OUTPUT: CL = Extended drive index of (that) logical DOS drive 
 29958                                  		;	      (including count of non-dos drives before it) 
 29959                                  		;	  CL = 0FFh -> invalid (not found)		
 29960                                  
 29961                                  		;/* Go look for the nth extended drive */
 29962                                  
 29963                                  		;sub	al,al ; 0
 29964                                  		;mov	[fed_i],al ; 0
 29965                                  		;mov	[fed_number_found],al ; 0
 29966 0000434E 31C9                    		xor	cx,cx
 29967                                  		;mov	[fed_i],cl
 29968                                  		;mov	[fed_number_found],cl
 29969 00004350 EB09                    		jmp	short fed_3
 29970                                  fed_1:
 29971                                  		;inc	byte [fed_i]
 29972 00004352 FEC5                    		inc	ch
 29973                                  fed_2:
 29974                                  		;/* Show we found one and go look for the next */
 29975                                  
 29976                                  		;inc	byte [fed_number_found]
 29977 00004354 FEC1                    		inc	cl
 29978                                  ;fed_3:
 29979                                  		;cmp	byte [fed_number_found],23
 29980 00004356 80F917                  		cmp	cl,23	
 29981 00004359 7D23                    		jge	short fed_5
 29982                                  		;mov	al,[fed_number_found]
 29983                                  		;mov	cl,[fed_number_found]
 29984                                  fed_3:
 29985                                  		;/* See if there is a drive we know about */
 29986                                  
 29987                                  		;cbw
 29988                                  		;mov	cx,ax
 29989 0000435B B018                    		mov	al,24
 29990                                  		;imul	byte [cur_disk]
 29991 0000435D F626[D4CB]              		mul	byte [cur_disk]
 29992                                  		;add	ax,cx
 29993 00004361 00C8                    		add	al,cl
 29994                                  		;mov	cx,46
 29995                                  		;imul	cx
 29996 00004363 B32E                    		mov	bl,46
 29997 00004365 F6E3                    		mul	bl
 29998 00004367 89C3                    		mov	bx,ax
 29999                                  
 30000 00004369 8A87[4FA1]              		mov	al,[ext_table_sys_id+bx]
 30001                                  		;cmp	byte [ext_table_sys_id+bx],1
 30002 0000436D 3C01                    		cmp	al,1
 30003 0000436F 7408                    		je	short fed_4
 30004                                  		;cmp	byte [ext_table_sys_id+bx],4
 30005 00004371 3C04                    		cmp	al,4
 30006 00004373 7404                    		je	short fed_4
 30007                                  		;cmp	byte [ext_table_sys_id+bx],6
 30008 00004375 3C06                    		cmp	al,6
 30009 00004377 75DB                    		jne	short fed_2
 30010                                  fed_4:		
 30011                                  		;/* Is this the one we were looking for ? */
 30012                                  
 30013                                  		;mov	al,[fed_offset]
 30014                                  		;cmp	[fed_i],al
 30015 00004379 38D5                    		cmp	ch,dl
 30016 0000437B 75D5                    		jne	short fed_1
 30017                                  
 30018                                  		;/* Yes it is, return where we found it */
 30019                                  
 30020                                  		;mov	al,[fed_number_found]
 30021                                  		;jmp	short fed_6
 30022                                  		;mov	al,cl
 30023                                  		;xor	ch,ch
 30024                                  		; cl = Extended drive index number
 30025 0000437D C3                      		retn
 30026                                  fed_5:
 30027                                  		;/* We should never get here */
 30028                                  
 30029 0000437E E890EF                  		call	internal_program_error
 30030                                  		;mov	al,0FFh
 30031                                  		;mov	cx,0FFh
 30032                                  		;stc
 30033 00004381 B1FF                    		mov	cl,0FFh
 30034                                  fed_6:
 30035                                  		;mov	sp,bp
 30036                                  		;pop	bp
 30037 00004383 C3                      		retn
 30038                                  
 30039                                  
 30040                                  ; fdisk.msg (MSDOS 6.0)
 30041                                  ;/***************************************************************************************************/
 30042                                  ;/*  Screen for SYSTEM_REBOOT                                                                       */
 30043                                  ;/*                                                                                                 */
 30044                                  ;/*     |00000000001111111111222222222233333333334444444444555555555566666666667777777777|          */
 30045                                  ;/*     |01234567890123456789012345678901234567890123456789012345678901234567890123456789|          */
 30046                                  ;/*   --|--------------------------------------------------------------------------------|          */
 30047                                  ;/*   00|                                                                                |          */
 30048                                  ;/*   01|                                                                                |          */
 30049                                  ;/*   02|                                                                                |          */
 30050                                  ;/*   03|                                                                                |          */
 30051                                  ;/*   04|                                                                                |          */
 30052                                  ;/*   05|                                                                                |          */
 30053                                  ;/*   06|                                                                                |          */
 30054                                  ;/*   07|                                                                                |          */
 30055                                  ;/*   08|                                                                                |          */
 30056                                  ;/*   09|                                                                                |          */
 30057                                  ;/*   10|                                                                                |          */
 30058                                  ;/*   11|                                                                                |          */
 30059                                  ;/*   12|                                                                                |          */
 30060                                  ;/*   13|    System will now restart                                                     |menu_38   */
 30061                                  ;/*   14|                                                                                |          */
 30062                                  ;/*   15|    Insert DOS diskette in drive A:                                             |menu_38   */
 30063                                  ;/*   16|    Press any key when ready . . .                                              |menu_38   */
 30064                                  ;/*   17|                                                                                |          */
 30065                                  ;/*   18|                                                                                |          */
 30066                                  ;/*   19|                                                                                |          */
 30067                                  ;/*   20|                                                                                |          */
 30068                                  ;/*   21|                                                                                |          */
 30069                                  ;/*   22|                                                                                |          */
 30070                                  ;/*   23|                                                                                |          */
 30071                                  ;/*   24|                                                                                |          */
 30072                                  ;/*   ------------------------------------------------------------------------------------          */
 30073                                  ;/*                                                                                                 */
 30074                                  ;/***************************************************************************************************/
 30075                                  
 30076                                  ; strcmp (Microsoft C 6.0 runtime library, MSDOS 6.0, 1991)	
 30077                                  ; ============================================================================
 30078                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 23/12/2018)
 30079                                  
 30080                                  ; STRCMP.ASM
 30081                                  ;*************
 30082                                  ;strcmp - compare two strings, returning less than, equal to, or greater than
 30083                                  ;
 30084                                  ;Purpose:
 30085                                  ;	Compares two string, determining their lexical order.  Unsigned
 30086                                  ;	comparison is used.
 30087                                  ;
 30088                                  ;	Algorithm:
 30089                                  ;	   int strcmp ( src , dst )
 30090                                  ;		   unsigned char *src;
 30091                                  ;		   unsigned char *dst;
 30092                                  ;	   {
 30093                                  ;		   int ret = 0 ;
 30094                                  ;
 30095                                  ;		   while( ! (ret = *src - *dst) && *dst)
 30096                                  ;			   ++src, ++dst;
 30097                                  ;
 30098                                  ;		   if ( ret < 0 )
 30099                                  ;			   ret = -1 ;
 30100                                  ;		   else if ( ret > 0 )
 30101                                  ;			   ret = 1 ;
 30102                                  ;
 30103                                  ;		   return( ret );
 30104                                  ;	   }
 30105                                  ;
 30106                                  ;Entry:
 30107                                  ;	const char * src - string for left-hand side of comparison
 30108                                  ;	const char * dst - string for right-hand side of comparison
 30109                                  ;
 30110                                  ;Exit:
 30111                                  ;	AX < 0, 0, or >0, indicating whether the first string is
 30112                                  ;	Less than, Equal to, or Greater than the second string.
 30113                                  ;
 30114                                  ;Uses:
 30115                                  ;	BX, CX, DX
 30116                                  ;
 30117                                  ;Exceptions:
 30118                                  ;
 30119                                  ;*******************************************************************************
 30120                                  
 30121                                  ; IBM PC-DOS FDISK.COM (upacked) - Segment 0, Offset 6FA4h
 30122                                  
 30123                                  strcmp:
 30124                                  		; 23/12/2018
 30125                                  
 30126                                  	%define strcmp_src bp+4
 30127                                  	%define strcmp_dst bp+6
 30128                                  
 30129                                  		;push	bp
 30130                                  		;mov	bp,sp
 30131                                  	
 30132                                  		;mov	dx,di	; preserve SI and DI
 30133                                  		;mov	bx,si
 30134                                  	
 30135                                  		;mov	ax,ds
 30136                                  		;mov	es,ax	; ES = DS = DGROUP
 30137                                  		;mov	si,[strcmp_src]	; DS:SI = src
 30138                                  		;mov	di,[strcmp_dst]	; ES:DI = dst
 30139                                  
 30140 00004384 31C0                    		xor	ax,ax
 30141 00004386 B9FFFF                  		mov	cx,-1
 30142 00004389 F2AE                    		repne	scasb	; compute length of "dst"
 30143 0000438B F7D1                    		not	cx	; CX = strlen(dst)+1
 30144 0000438D 29CF                    		sub	di,cx	; restore ES:DI = dst
 30145 0000438F F3A6                    		repe	cmpsb	; compare while equal, at most length of "dst"
 30146 00004391 7405                    		je	short toend ; dst == src?  (AX = 0)
 30147                                  				; dst < src	dst > src
 30148 00004393 19C0                    		sbb	ax,ax	; AX=-1, CY=1	AX=0, CY=0
 30149 00004395 83D8FF                  		sbb	ax,-1	; AX=-1		AX=1
 30150                                  toend:
 30151                                  		;mov	si,bx		; restore SI and DI
 30152                                  		;mov	di,dx
 30153                                  
 30154                                  		;pop	bp
 30155 00004398 C3                      		retn
 30156                                  
 30157                                  ; ----------------------------------------------------------------------------
 30158                                  ; input.c (FDISK, MSDOS 6.0, 1991)	
 30159                                  ; ----------------------------------------------------------------------------
 30160                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 01/01/2019)
 30161                                  
 30162                                  ;/*  */ 
 30163                                  ;
 30164                                  ;void get_string_input(StartRow,StartCol,string_ptr)
 30165                                  ;                                  
 30166                                  ;unsigned        StartRow;                                         /* AN000 */
 30167                                  ;unsigned        StartCol;                                         /* AN000 */
 30168                                  ;char far        *string_ptr;                                      /* AN000 */
 30169                                  ;                                                                  /* AN000 */
 30170                                  ;BEGIN                                                             /* AN000 */
 30171                                  ;
 30172                                  ;    #define MAX_STRING_INPUT_LENGTH 11
 30173                                  ;                                                                  /* AN000 */
 30174                                  ;    unsigned char   input;                                        /* AN000 */
 30175                                  ;    char   far *WorkingPtr;                                       /* AN000 */
 30176                                  ;    char   far *DeletePtr;                                        /* AN000 */
 30177                                  ;    char   Done;                                                  /* AN000 */
 30178                                  ;    unsigned        Row;                                          /* AN000 */
 30179                                  ;    unsigned        Col;                                          /* AN000 */
 30180                                  ;
 30181                                  ;    char            attribute;
 30182                                  ;    char far        *attribute_ptr = &attribute;
 30183                                  ;    char far *input_ptr = &input;
 30184                                  ;
 30185                                  ;    if (mono_flag == TRUE)
 30186                                  ;        attribute = HIWHITE_ON_BLACK; /*C09*/
 30187                                  ;    else
 30188                                  ;        attribute = HIWHITE_ON_BLUE;  /*C09*/
 30189                                  ;
 30190                                  ;    WorkingPtr = string_ptr;                                      /* AN000 */
 30191                                  ;
 30192                                  ;    Row = StartRow;                                               /* AN000 */
 30193                                  ;    Col = StartCol;                                               /* AN000 */
 30194                                  ;    VIOSETCURPOS(Row,Col,u(0));                                   /* AN000 */
 30195                                  ;
 30196                                  ;    while(*WorkingPtr != c(NUL))                                  /* AN000 */
 30197                                  ;        BEGIN                                                     /* AN000 */
 30198                                  ;        VIOWRTCHARSTRATT(WorkingPtr,u(1),Row,Col,attribute_ptr,u(0));
 30199                                  ;        WorkingPtr++;
 30200                                  ;        Col++;                                                    /* AN000 */
 30201                                  ;        VIOSETCURPOS(Row,Col,u(0));                               /* AN000 */
 30202                                  ;        END                                                       /* AN000 */
 30203                                  ;
 30204                                  ;    regs.h.ah = uc(12);                                           /* AN000 */
 30205                                  ;    regs.h.al = uc(7); /*C03*/
 30206                                  ;    intdos(&regs,&regs);                                          /* AN000 */
 30207                                  ;    input = regs.h.al;                                            /* AN000 */
 30208                                  ;
 30209                                  ;    /* Loop until we get good stuff */                            /* AN000 */
 30210                                  ;    Done = FALSE;                                                 /* AN000 */
 30211                                  ;    while (!Done)                                                 /* AN000 */
 30212                                  ;        BEGIN                                                     /* AN000 */
 30213                                  ;
 30214                                  ;        /* Go handle different inputs */
 30215                                  ;
 30216                                  ;        if (input < 32)                                           /* AN000 */
 30217                                  ;            BEGIN                                                 /* AN000 */
 30218                                  ;            switch(input)                                         /* AN000 */
 30219                                  ;                BEGIN                                             /* AN000 */
 30220                                  ;                case ESC:                                         /* AN000 */
 30221                                  ;                    Done=TRUE;                                    /* AN000 */
 30222                                  ;                    *string_ptr++ = c(ESC);                       /* AN000 */
 30223                                  ;                    *string_ptr++ = c('\0');                      /* AN000 */
 30224                                  ;                   break;                                         /* AN000 */
 30225                                  ;
 30226                                  ;                case  CR:                                         /* AN000 */
 30227                                  ;                    Done=TRUE;                                    /* AN000 */
 30228                                  ;                    break;                                        /* AN000 */
 30229                                  ;
 30230                                  ;                case 8: /* backspace */                           /* AN000 */
 30231                                  ;                    if (Col > StartCol)                           /* AN000 */
 30232                                  ;                        BEGIN                                     /* AN000 */
 30233                                  ;                        WorkingPtr--;                             /* AN000 */
 30234                                  ;                        Col--;                                    /* AN000 */
 30235                                  ;                        VIOSETCURPOS(Row,Col,u(0));               /* AN000 */
 30236                                  ;			  input = c(' ');
 30237                                  ;                        VIOWRTCHARSTRATT(input_ptr,u(1),Row,Col,attribute_ptr,u(0));
 30238                                  ;                        VIOSETCURPOS(Row,Col,u(0));               /* AN000 */
 30239                                  ;                        DeletePtr = WorkingPtr;                   /* AN000 */
 30240                                  ;                        while ( *(DeletePtr+1) != c('\0')  )      /* AN000 */
 30241                                  ;                            BEGIN                                 /* AN000 */
 30242                                  ;                            *DeletePtr = *(DeletePtr+1);          /* AN000 */
 30243                                  ;                            VIOWRTCHARSTRATT(DeletePtr,u(1),Row,Col,attribute_ptr,u(0));
 30244                                  ;                            DeletePtr++;                          /* AN000 */
 30245                                  ;                            END                                   /* AN000 */
 30246                                  ;                        *DeletePtr = c('\0');                     /* AN000 */
 30247                                  ;			  input = c(' ');
 30248                                  ;                        VIOWRTCHARSTRATT(input_ptr,u(1),Row,Col+1,attribute_ptr,u(0));
 30249                                  ;                        VIOSETCURPOS(Row,Col,u(0));               /* AN000 */
 30250                                  ;                        END                                       /* AN000 */
 30251                                  ;                    else DOSBEEP(u(900),u(400));                  /* AN000 */
 30252                                  ;                break;                                            /* AN000 */
 30253                                  ;
 30254                                  ;                case  0:                                          /* AN000 */
 30255                                  ;                    regs.h.ah = uc(0x07); /*C03*/
 30256                                  ;                    intdos(&regs,&regs);                          /* AN000 */
 30257                                  ;                    input = regs.h.al;                            /* AN000 */
 30258                                  ;                    switch(input)                                 /* AN000 */
 30259                                  ;                        BEGIN                                     /* AN000 */
 30260                                  ;                        case 71: /* HOME */                       /* AN000 */
 30261                                  ;                            WorkingPtr = string_ptr;              /* AN000 */
 30262                                  ;                            Row = StartRow;                       /* AN000 */
 30263                                  ;                            Col = StartCol;                       /* AN000 */
 30264                                  ;                            VIOSETCURPOS(Row,Col,u(0));           /* AN000 */
 30265                                  ;                            break;                                /* AN000 */
 30266                                  ;
 30267                                  ;                        case 79: /* END  */                       /* AN000 */
 30268                                  ;                            while (*WorkingPtr != c('\0') )       /* AN000 */
 30269                                  ;                                BEGIN                             /* AN000 */
 30270                                  ;                                WorkingPtr++;                     /* AN000 */
 30271                                  ;                                Col++;                            /* AN000 */
 30272                                  ;                                VIOSETCURPOS(Row,Col,u(0));       /* AN000 */
 30273                                  ;                                END                               /* AN000 */
 30274                                  ;                            break;                                /* AN000 */
 30275                                  ;
 30276                                  ;                        case 75: /* Cursor Left */                /* AN000 */
 30277                                  ;                            if (Col > StartCol)                   /* AN000 */
 30278                                  ;                                BEGIN                             /* AN000 */
 30279                                  ;                                WorkingPtr--;                     /* AN000 */
 30280                                  ;                                Col--;                            /* AN000 */
 30281                                  ;                                VIOSETCURPOS(Row,Col,u(0));       /* AN000 */
 30282                                  ;                                END                               /* AN000 */
 30283                                  ;                            else DOSBEEP(u(900),u(400));          /* AN000 */
 30284                                  ;                            break;                                /* AN000 */
 30285                                  ;
 30286                                  ;                        case 77: /* Cursor Right */               /* AN000 */
 30287                                  ;                            if ( *WorkingPtr != c('\0') )         /* AN000 */
 30288                                  ;                                BEGIN                             /* AN000 */
 30289                                  ;                                WorkingPtr++;                     /* AN000 */
 30290                                  ;                                Col++;                            /* AN000 */
 30291                                  ;                                VIOSETCURPOS(Row,Col,u(0));       /* AN000 */
 30292                                  ;                                END                               /* AN000 */
 30293                                  ;                            else DOSBEEP(u(900),u(400));          /* AN000 */
 30294                                  ;                            break;                                /* AN000 */
 30295                                  ;
 30296                                  ;                        default:                                  /* AN000 */
 30297                                  ;                            DOSBEEP(u(900),u(400));               /* AN000 */
 30298                                  ;                            break;                                /* AN000 */
 30299                                  ;
 30300                                  ;                        END                                       /* AN000 */
 30301                                  ;                    break;                                        /* AN000 */
 30302                                  ;
 30303                                  ;                default:                                          /* AN000 */
 30304                                  ;                        DOSBEEP(u(900),u(400));                   /* AN000 */
 30305                                  ;                        break;                                    /* AN000 */
 30306                                  ;                END                                               /* AN000 */
 30307                                  ;
 30308                                  ;            END                                                   /* AN000 */
 30309                                  ;         else     /* input is >= 32 */                            /* AN000 */
 30310                                  ;            BEGIN                                                 /* AN000 */
 30311                                  ;            input = dos_upper(input);                             /* AN000 */
 30312                                  ;            if ( (strchr(".\"/\\[]:|<>+=;,",input) == NULL) &&
 30313                                  ;                 (Col < StartCol + MAX_STRING_INPUT_LENGTH)    )  /* AN000 */
 30314                                  ;                BEGIN                                             /* AN000 */
 30315                                  ;                /* SR; 10/2/89; If Ctrl-C, display blank and beep */
 30316                                  ;                if ( input != 0x03 )
 30317                                  ;                    VIOWRTCHARSTRATT(input_ptr,u(1),Row,Col,attribute_ptr,u(0));
 30318                                  ;                else
 30319                                  ;                    {
 30320                                  ;                    DOSBEEP( 900, 400 );
 30321                                  ;                    input = c(' ');
 30322                                  ;                    VIOWRTCHARSTRATT(input_ptr,u(1),Row,Col,attribute_ptr,u(0));
 30323                                  ;                    }
 30324                                  ;                *WorkingPtr = input;                              /* AN000 */
 30325                                  ;                *(WorkingPtr+1) = c('\0');                        /* AN000 */
 30326                                  ;                if (Col < (StartCol + MAX_STRING_INPUT_LENGTH - 1)) /* AN000 */
 30327                                  ;                    BEGIN                                         /* AN000 */
 30328                                  ;                    Col++;                                        /* AN000 */
 30329                                  ;                    WorkingPtr++;                                 /* AN000 */
 30330                                  ;                    END                                           /* AN000 */
 30331                                  ;                VIOSETCURPOS(Row,Col,u(0));                       /* AN000 */
 30332                                  ;                END                                               /* AN000 */
 30333                                  ;            else DOSBEEP(u(900),u(400));                          /* AN000 */
 30334                                  ;            END                                                   /* AN000 */
 30335                                  ;
 30336                                  ;        if (!Done)                                                /* AN000 */
 30337                                  ;            BEGIN                                                 /* AN000 */
 30338                                  ;            /* Get a character */                                 /* AN000 */
 30339                                  ;            regs.h.ah = uc(0x07); /*C03*/
 30340                                  ;            intdos(&regs,&regs);                                  /* AN000 */
 30341                                  ;            input = regs.h.al;                                    /* AN000 */
 30342                                  ;            END                                                   /* AN000 */
 30343                                  ;        END                                                       /* AN000 */
 30344                                  ;
 30345                                  ;    return;                                                       /* AN000 */
 30346                                  ;END                                                                 
 30347                                  
 30348                                  get_string_input:
 30349                                  
 30350                                  		; 01/01/2019
 30351                                  
 30352                                  	%define gsi_endcol	bp-28 ; modification 
 30353                                  
 30354                                  	%define gsi_col		bp-26
 30355                                  	%define gsi_deleteptr	bp-24
 30356                                  	%define gsi_attribute_ptr bp-20
 30357                                  	;%define gsi_attribute_ptr2 bp-18
 30358                                  	%define gsi_row		bp-16
 30359                                  	%define gsi_workingptr	bp-14
 30360                                  	%define gsi_done	bp-10
 30361                                  	%define gsi_input_ptr	bp-8
 30362                                  	;%define gsi_input_ptr2	bp-6
 30363                                  	%define gsi_attribute	bp-4
 30364                                  	%define gsi_input	bp-2
 30365                                  
 30366                                  	%define gs_i_startrow	bp+4
 30367                                  	%define gs_i_startcol	bp+6
 30368                                  	%define gs_i_stringptr	bp+8
 30369                                  
 30370 00004399 55                      		push	bp
 30371 0000439A 89E5                    		mov	bp,sp
 30372                                  		;sub	sp,26
 30373 0000439C 83EC1C                  		sub	sp,28
 30374                                  
 30375 0000439F 8D46FC                  		lea	ax,[gsi_attribute]
 30376 000043A2 8946EC                  		mov	[gsi_attribute_ptr],ax
 30377 000043A5 8C56EE                  		mov	[gsi_attribute_ptr+2],ss
 30378 000043A8 8D4EFE                  		lea	cx,[gsi_input]
 30379 000043AB 894EF8                  		mov	[gsi_input_ptr],cx
 30380 000043AE 8C56FA                  		mov	[gsi_input_ptr+2],ss
 30381                                  		
 30382 000043B1 803E[CAC3]01            		cmp	byte [mono_flag],1
 30383 000043B6 7506                    		jne	short gsi_1
 30384 000043B8 C646FC0F                		mov	byte [gsi_attribute],0Fh ;HIWHITE_ON_BLACK
 30385 000043BC EB04                    		jmp	short gsi_2
 30386                                  gsi_1:
 30387 000043BE C646FC1F                		mov	byte [gsi_attribute],1Fh ;HIWHITE_ON_BLUE
 30388                                  gsi_2:
 30389 000043C2 8B4608                  		mov	ax,[gs_i_stringptr]
 30390 000043C5 8B560A                  		mov	dx,[gs_i_stringptr+2]
 30391 000043C8 8946F2                  		mov	[gsi_workingptr],ax
 30392 000043CB 8956F4                  		mov	[gsi_workingptr+2],dx
 30393 000043CE 8B4604                  		mov	ax,[gs_i_startrow]
 30394 000043D1 8946F0                  		mov	[gsi_row],ax
 30395 000043D4 8B4E06                  		mov	cx,[gs_i_startcol]
 30396 000043D7 894EE6                  		mov	[gsi_col],cx
 30397                                  
 30398                                  		; modification
 30399 000043DA 83C10B                  		add	cx,11 ; MAX_STRING_INPUT_LENGTH = 11
 30400 000043DD 894EE4                  		mov	[gsi_endcol],cx
 30401                                  		
 30402                                  		;push	ax
 30403                                  		;push	cx
 30404 000043E0 EB1B                    		jmp	short gsi_4
 30405                                  gsi_3:
 30406                                  		;VIOWRTCHARSTRATT(WorkingPtr,u(1),Row,Col,attribute_ptr,u(0));
 30407                                  
 30408 000043E2 06                      		push	es
 30409 000043E3 53                      		push	bx
 30410 000043E4 B80100                  		mov	ax,1
 30411 000043E7 50                      		push	ax
 30412 000043E8 FF76F0                  		push	word [gsi_row]
 30413 000043EB FF76E6                  		push	word [gsi_col]
 30414 000043EE FF76EE                  		push	word [gsi_attribute_ptr+2]
 30415 000043F1 FF76EC                  		push	word [gsi_attribute_ptr]
 30416                                  		;sub	cx,cx
 30417                                  		;push	cx
 30418 000043F4 E8E2D4                  		call	VIOWRTCHARSTRATT
 30419                                  		
 30420                                  		;WorkingPtr++;
 30421                                  		;Col++;
 30422                                  		
 30423                                  		;VIOSETCURPOS(Row,Col,u(0));         
 30424                                  
 30425 000043F7 FF46F2                  		inc	word [gsi_workingptr]
 30426                                  		;push	word [gsi_row]
 30427 000043FA FE46E6                  		inc	byte [gsi_col]
 30428                                  		;push	word [gsi_col]
 30429                                  gsi_4:
 30430                                  		;sub	ax,ax
 30431                                  		;push	ax
 30432                                  
 30433 000043FD 8A76F0                  		mov	dh,[gsi_row]
 30434 00004400 8A56E6                  		mov	dl,[gsi_col]
 30435                                  
 30436 00004403 E810E8                  		call	VIOSETCURPOS
 30437                                  		
 30438                                  		;while(*WorkingPtr != c(NUL))     	
 30439                                  
 30440 00004406 C45EF2                  		les	bx,[gsi_workingptr]
 30441 00004409 26803F00                		cmp	byte [es:bx],0
 30442 0000440D 75D3                    		jne	short gsi_3
 30443                                  
 30444                                  		;mov	byte [regs_x_ax+1],0Ch
 30445                                  		;mov	byte [regs_x_ax],7
 30446                                  		;mov	ax,regs_x_ax
 30447                                  		;push	ax
 30448                                  		;push	ax
 30449                                  		;call	intdos
 30450                                  		;pop	bx
 30451                                  		;pop	bx
 30452                                  		;mov	al,[regs_x_ax]
 30453                                  
 30454                                  		;DOS function
 30455                                  		;FLUSH BUFFER AND READ STANDARD INPUT		
 30456                                  		;mov	ah,0Ch
 30457                                  		;mov	al,7  ; DIRECT CHARACTER INPUT, WITHOUT ECHO
 30458 0000440F B8070C                  		mov	ax,0C07h
 30459 00004412 CD21                    		int	21h
 30460                                  
 30461 00004414 8846FE                  		mov	byte [gsi_input],al
 30462                                  
 30463                                  		;/* Loop until we get good stuff */ 
 30464                                  
 30465 00004417 C646F600                		mov	byte [gsi_done],0  ; Done = FALSE;
 30466                                  gsi_5:
 30467                                  		;/* Go handle different inputs */
 30468                                  
 30469                                  		;if (input < 32)
 30470 0000441B 807EFE20                		cmp	byte [gsi_input],20h ; 32 ; SPACE character
 30471 0000441F 7203                    		jb	short gsi_6 ; one of control characters
 30472 00004421 E96D01                  		jmp	gsi_26	; TEXT character
 30473                                  gsi_6:
 30474                                  		;switch(input)  
 30475                                  
 30476 00004424 8A46FE                  		mov	al,[gsi_input]
 30477                                  		;sub	ah,ah
 30478                                  		;cmp	ax,1Bh
 30479 00004427 3C1B                    		cmp	al,1Bh ; ESCape key
 30480 00004429 7417                    		je	short gsi_9
 30481 0000442B 7203                    		jb	short gsi_7
 30482 0000442D E9C801                  		jmp	gsi_29
 30483                                  gsi_7:
 30484 00004430 08C0                    		or	al,al
 30485 00004432 7503                    		jnz	short gsi_8
 30486 00004434 E9CD00                  		jmp	gsi_15
 30487                                  gsi_8:
 30488 00004437 2C08                    		sub	al,8
 30489 00004439 7426                    		jz	short gsi_11  ; 8, /* backspace */
 30490 0000443B 2C05                    		sub	al,5
 30491 0000443D 741B                    		jz	short gsi_10  ; 13, CR
 30492 0000443F E9B601                  		jmp	gsi_29 ; one of other (control) keys, invalid
 30493                                  gsi_9:
 30494                                  		;case ESC:
 30495 00004442 C646F601                		mov	byte [gsi_done],1 ; Done = TRUE
 30496 00004446 C45E08                  		les	bx,[gs_i_stringptr]
 30497 00004449 FF4608                  		inc	word [gs_i_stringptr]
 30498                                  		;mov	byte [es:bx],1Bh
 30499 0000444C 268807                  		mov	[es:bx],al ; 1Bh
 30500                                  		;les	bx,[gs_i_stringptr]
 30501 0000444F 43                      		inc	bx
 30502 00004450 FF4608                  		inc	word [gs_i_stringptr]
 30503 00004453 26C60700                		mov	byte [es:bx],0
 30504 00004457 E9A101                  		jmp	gsi_30
 30505                                  gsi_10:	
 30506                                  		;case CR: ; 0Dh ; ENTER (Carriage Return) key
 30507 0000445A C646F601                		mov	byte [gsi_done],1 ; TRUE
 30508 0000445E E99A01                  		jmp	gsi_30 ; break;
 30509                                  gsi_11:
 30510                                  		; case 8: ; /* backspace */ 
 30511 00004461 8B4606                  		mov	ax,[gs_i_startcol]
 30512 00004464 3946E6                  		cmp	[gsi_col],ax
 30513 00004467 7703                    		ja	short gsi_12 ; if (Col > StartCol) 
 30514 00004469 E98C01                  		jmp	gsi_29 ; beep!
 30515                                  gsi_12:
 30516                                  		;push	word [gsi_row]
 30517 0000446C FE4EE6                  		dec	byte [gsi_col]
 30518                                  		;mov	ax,[gsi_col]
 30519                                  		;push	ax
 30520                                  		;sub	cx,cx
 30521                                  		;push	cx
 30522 0000446F 8A76F0                  		mov	dh,[gsi_row]
 30523 00004472 8A56E6                  		mov	dl,[gsi_col]
 30524 00004475 E89EE7                  		call	VIOSETCURPOS
 30525 00004478 C646FE20                		mov	byte [gsi_input],' '
 30526 0000447C FF76FA                  		push	word [gsi_input_ptr+2]
 30527 0000447F FF76F8                  		push	word [gsi_input_ptr]
 30528 00004482 B80100                  		mov	ax,1
 30529 00004485 50                      		push	ax
 30530 00004486 FF76F0                  		push	word [gsi_row]
 30531 00004489 FF76E6                  		push	word [gsi_col]
 30532 0000448C FF76EE                  		push	word [gsi_attribute_ptr+2]
 30533 0000448F FF76EC                  		push	word [gsi_attribute_ptr]
 30534                                  		;sub	ax,ax
 30535                                  		;push	ax
 30536 00004492 E844D4                  		call	VIOWRTCHARSTRATT
 30537                                  		;push	[gsi_row]
 30538                                  		;push	[gsi_col]
 30539                                  		;sub	ax,ax
 30540                                  		;push	ax
 30541 00004495 8A76F0                  		mov	dh,[gsi_row]
 30542 00004498 8A56E6                  		mov	dl,[gsi_col]
 30543 0000449B E878E7                  		call	VIOSETCURPOS
 30544 0000449E FF4EF2                  		dec	word [gsi_workingptr]
 30545 000044A1 8B46F2                  		mov	ax,[gsi_workingptr]
 30546 000044A4 8B56F4                  		mov	dx,[gsi_workingptr+2]
 30547 000044A7 8946E8                  		mov	[gsi_deleteptr],ax
 30548 000044AA 8956EA                  		mov	[gsi_deleteptr+2],dx
 30549 000044AD EB26                    		jmp	short gsi_14
 30550                                  gsi_13:	
 30551 000044AF 268A4701                		mov	al,[es:bx+1]
 30552 000044B3 268807                  		mov	[es:bx],al
 30553 000044B6 06                      		push	es
 30554 000044B7 53                      		push	bx
 30555 000044B8 B80100                  		mov	ax,1
 30556 000044BB 50                      		push	ax
 30557 000044BC FF76F0                  		push	word [gsi_row]
 30558 000044BF FF76E6                  		push	word [gsi_col]
 30559 000044C2 FF76EE                  		push	word [gsi_attribute_ptr+2]
 30560 000044C5 FF76EC                  		push	word [gsi_attribute_ptr]
 30561                                  		;sub	ax,ax
 30562                                  		;push	ax
 30563 000044C8 E80ED4                  		call	VIOWRTCHARSTRATT
 30564 000044CB 8B46E8                  		mov	ax,[gsi_deleteptr]
 30565 000044CE 8B56EA                  		mov	dx,[gsi_deleteptr+2]
 30566 000044D1 40                      		inc	ax
 30567 000044D2 8946E8                  		mov	[gsi_deleteptr],ax
 30568                                  
 30569                                  gsi_14:
 30570                                  		;while ( *(DeletePtr+1) != c('\0')  ) 
 30571                                  
 30572 000044D5 C45EE8                  		les	bx,[gsi_deleteptr]
 30573 000044D8 26807F0100              		cmp	byte [es:bx+1],0
 30574 000044DD 75D0                    		jne	short gsi_13
 30575                                  	
 30576 000044DF 26C60700                		mov	byte [es:bx],0
 30577 000044E3 C646FE20                		mov	byte [gsi_input],' '
 30578 000044E7 FF76FA                  		push	word [gsi_input_ptr+2]
 30579 000044EA FF76F8                  		push	word [gsi_input_ptr]
 30580 000044ED B80100                  		mov	ax,1
 30581 000044F0 50                      		push	ax
 30582 000044F1 FF76F0                  		push	word [gsi_row]
 30583 000044F4 0346E6                  		add	ax,[gsi_col]
 30584 000044F7 50                      		push	ax
 30585 000044F8 FF76EE                  		push	word [gsi_attribute_ptr+2]
 30586 000044FB FF76EC                  		push	word [gsi_attribute_ptr]
 30587                                  		;sub	ax,ax
 30588                                  		;push	ax
 30589 000044FE E8D8D3                  		call	VIOWRTCHARSTRATT
 30590 00004501 E9F100                  		jmp	gsi_28
 30591                                  gsi_15:		
 30592                                  		;case  0: 
 30593                                   
 30594                                  		;mov	byte [regs_x_ax+1],7
 30595                                  		;mov	ax,regs_x_ax
 30596                                  		;push	ax
 30597                                  		;push	ax
 30598                                  		;call	intdos
 30599                                  		;pop	bx
 30600                                  		;pop	bx
 30601                                  		;mov	al,[regs_x_ax]
 30602                                  
 30603                                  		;DOS function
 30604                                  		;DIRECT CHARACTER INPUT, WITHOUT ECHO
 30605 00004504 B407                    		mov	ah,07h
 30606 00004506 CD21                    		int	21h
 30607 00004508 8846FE                  		mov	byte [gsi_input],al
 30608                                  
 30609                                  		;switch(input)
 30610                                  
 30611                                  		;sub	ah,ah
 30612 0000450B 83F84F                  		cmp	ax,79  
 30613 0000450E 7438                    		je	short gsi_19  ; /* END */
 30614 00004510 7203                    		jb	short gsi_16
 30615 00004512 E9E300                  		jmp	gsi_29
 30616                                  gsi_16:
 30617 00004515 2C47                    		sub	al,71
 30618 00004517 740B                    		je	short gsi_17 ; /* HOME */    
 30619 00004519 2C04                    		sub	al,4
 30620 0000451B 7448                    		je	short gsi_21 ; 75, /* Cursor Left */	
 30621 0000451D 2C02                    		sub	al,2
 30622 0000451F 745A                    		je	short gsi_23 ; 77, /* Cursor Right */ 
 30623 00004521 E9D400                  		jmp	gsi_29	; one of other (control) keys, invalid
 30624                                  gsi_17:
 30625                                  		;case 71: /* HOME */    
 30626                                  
 30627 00004524 8B4608                  		mov	ax,[gs_i_stringptr]
 30628 00004527 8B560A                  		mov	dx,[gs_i_stringptr+2]
 30629 0000452A 8946F2                  		mov	[gsi_workingptr],ax
 30630 0000452D 8956F4                  		mov	[gsi_workingptr+2],dx
 30631                                  		
 30632 00004530 8B4604                  		mov	ax,[gs_i_startrow]
 30633 00004533 8946F0                  		mov	[gsi_row],ax
 30634 00004536 8B4E06                  		mov	cx,[gs_i_startcol]
 30635 00004539 894EE6                  		mov	[gsi_col],cx
 30636                                  		;push	ax
 30637                                  		;push	cx
 30638                                  gsi_18:
 30639                                  		;sub	ax,ax
 30640                                  		;push	ax
 30641 0000453C 8A76F0                  		mov	dh,[gsi_row]
 30642 0000453F 8A56E6                  		mov	dl,[gsi_col]
 30643 00004542 E8D1E6                  		call	VIOSETCURPOS
 30644 00004545 E9B300                  		jmp	gsi_30
 30645                                  gsi_19:
 30646                                  		;case 79: ; /* END */   
 30647                                  		
 30648                                  		;while (*WorkingPtr != c('\0') ) 
 30649 00004548 C45EF2                  		les	bx,[gsi_workingptr]
 30650 0000454B 26803F00                		cmp	byte [es:bx],0
 30651 0000454F 7503                    		jne	short gsi_20
 30652 00004551 E9A700                  		jmp	gsi_30
 30653                                  gsi_20:	
 30654 00004554 FF46F2                  		inc	word [gsi_workingptr]
 30655                                  		;push	word [gsi_row]
 30656 00004557 FE46E6                  		inc	byte [gsi_col]
 30657                                  		;push	word [gsi_col]
 30658                                  		;sub	ax,ax
 30659                                  		;push	ax
 30660 0000455A 8A76F0                  		mov	dh,[gsi_row]
 30661 0000455D 8A56E6                  		mov	dl,[gsi_col]
 30662 00004560 E8B3E6                  		call	VIOSETCURPOS
 30663 00004563 EBE3                    		jmp	short gsi_19
 30664                                  gsi_21:
 30665                                  		;case 75: ; /* Cursor Left */
 30666                                  
 30667 00004565 8B4606                  		mov	ax,[gs_i_startcol]
 30668 00004568 3946E6                  		cmp	[gsi_col],ax
 30669 0000456B 7703                    		ja	short gsi_22  ; if (Col > StartCol)
 30670 0000456D E98800                  		jmp	gsi_29
 30671                                  gsi_22:	
 30672 00004570 FF4EF2                  		dec	word [gsi_workingptr]
 30673 00004573 FF76F0                  		push	word [gsi_row]
 30674 00004576 FE4EE6                  		dec	byte [gsi_col]
 30675                                  		;jmp	short gsi_25
 30676 00004579 EBC1                    		jmp	short gsi_18 ; 02/01/2019
 30677                                  gsi_23:
 30678                                  		;case 77: ; /* Cursor Right */ 
 30679                                  
 30680 0000457B C45EF2                  		les	bx,[gsi_workingptr]
 30681 0000457E 26803F00                		cmp	byte [es:bx],0
 30682 00004582 7502                    		jne	short gsi_24 ; if ( *WorkingPtr != c('\0') )
 30683 00004584 EB72                    		jmp	gsi_29
 30684                                  gsi_24:
 30685 00004586 FF46F2                  		inc	word [gsi_workingptr]
 30686 00004589 FF76F0                  		push	word [gsi_row]
 30687 0000458C FE46E6                  		inc	byte [gsi_col]
 30688                                  ;gsi_25:
 30689                                  		;push	word [gsi_col]
 30690 0000458F EBAB                    		jmp	short gsi_18
 30691                                  gsi_26:
 30692                                  		;else	/* input is >= 32 */
 30693                                  
 30694                                  		;input = dos_upper(input);
 30695 00004591 8A46FE                  		mov	al,[gsi_input]
 30696                                  		;push	ax
 30697 00004594 E897E6                  		call	dos_upper
 30698                                  		;pop	bx
 30699 00004597 8846FE                  		mov	[gsi_input],al
 30700                                  	
 30701                                  		;if ( (strchr(".\"/\\[]:|<>+=;,",input) == NULL) &&
 30702                                  		;   (Col < StartCol + MAX_STRING_INPUT_LENGTH))
 30703                                  
 30704                                  		;sub	ah,ah
 30705                                  		;push	ax
 30706                                  		;mov	ax,invstrchars ; ".\"/\\[]:|<>+=;,"
 30707                                  		;push	ax
 30708                                  		;call	strchr
 30709                                  		;pop	bx
 30710                                  		;pop	bx
 30711                                  
 30712                                  		; 01/01/2019
 30713 0000459A BE[9F6F]                		mov	si,invstrchars ; ".\"/\\[]:|<>+=;,"
 30714                                  		;al = character to be searched in invstrchars		
 30715 0000459D E87100                  		call	strchr
 30716                                  
 30717 000045A0 09C0                    		or	ax,ax
 30718 000045A2 7554                    		jnz	short gsi_29
 30719                                  
 30720                                  		;mov	ax,[gs_i_startcol]
 30721                                  		;add	ax,11	; MAX_STRING_INPUT_LENGTH = 11
 30722 000045A4 8B46E4                  		mov	ax,[gsi_endcol]
 30723 000045A7 3B46E6                  		cmp	ax,[gsi_col]		
 30724 000045AA 764C                    		jbe	short gsi_29
 30725                                  
 30726 000045AC 807EFE03                		cmp	byte [gsi_input],3
 30727 000045B0 7507                    		jne	short gsi_27
 30728                                  		
 30729                                  		;mov	ax,900
 30730                                  		;push	ax
 30731                                  		;mov	ax,400
 30732                                  		;push	ax
 30733 000045B2 E888D3                  		call	DOSBEEP  ; 01/01/2019
 30734                                  
 30735 000045B5 C646FE20                		mov	byte [gsi_input],' '
 30736                                  gsi_27:
 30737                                  		;VIOWRTCHARSTRATT(input_ptr,u(1),Row,Col,attribute_ptr,u(0));
 30738                                  
 30739 000045B9 FF76FA                  		push	word [gsi_input_ptr+2]
 30740 000045BC FF76F8                  		push	word [gsi_input_ptr]
 30741 000045BF B80100                  		mov	ax,1
 30742 000045C2 50                      		push	ax
 30743 000045C3 FF76F0                  		push	word [gsi_row]
 30744 000045C6 FF76E6                  		push	word [gsi_col]
 30745 000045C9 FF76EE                  		push	word [gsi_attribute_ptr+2]
 30746 000045CC FF76EC                  		push	word [gsi_attribute_ptr]
 30747                                  		;sub	ax,ax
 30748                                  		;push	ax
 30749 000045CF E807D3                  		call	VIOWRTCHARSTRATT
 30750                                  
 30751 000045D2 8A46FE                  		mov	al,[gsi_input]
 30752 000045D5 C45EF2                  		les	bx,[gsi_workingptr]
 30753 000045D8 268807                  		mov	[es:bx],al
 30754 000045DB 26C6470100              		mov	byte [es:bx+1],0
 30755                                  		;mov	ax,[gs_i_startcol]
 30756                                  		;add	ax,10
 30757 000045E0 8B46E4                  		mov	ax,[gsi_endcol]  ; modification
 30758 000045E3 48                      		dec	ax
 30759 000045E4 3B46E6                  		cmp	ax,[gsi_col]
 30760 000045E7 760C                    		jbe	short gsi_28
 30761 000045E9 FE46E6                  		inc	byte [gsi_col]
 30762 000045EC 8D4701                  		lea	ax,[bx+1]
 30763 000045EF 8946F2                  		mov	[gsi_workingptr],ax
 30764 000045F2 8C46F4                  		mov	[gsi_workingptr+2],es
 30765                                  gsi_28:
 30766                                  		;push	word [gsi_row]
 30767                                  		;jmp	gsi_25
 30768 000045F5 E944FF                  		jmp	gsi_18
 30769                                  gsi_29:
 30770                                  		;mov	ax,900
 30771                                  		;push	ax
 30772                                  		;mov	ax,400
 30773                                  		;push	ax
 30774 000045F8 E842D3                  		call	DOSBEEP  ; 01/01/2019
 30775                                  gsi_30:
 30776                                  		;if (!Done) 
 30777 000045FB 807EF600                		cmp	byte [gsi_done],0
 30778                                  		;jne	short gsi_31
 30779 000045FF 750A                    		jne	short gsi_32
 30780                                  
 30781                                  		;/* Get a character */
 30782                                  		;regs.h.ah = uc(0x07);
 30783                                  		;intdos(&regs,&regs);
 30784                                  		;input = regs.h.al;       
 30785                                  
 30786                                  		;mov	byte [regs_x_ax+1],7
 30787                                  		;mov	ax,regs_x_ax
 30788                                  		;push	ax
 30789                                  		;push	ax
 30790                                  		;call	intdos
 30791                                  		;pop	bx
 30792                                  		;pop	bx
 30793                                  		;mov	al,[regs_x_ax]
 30794                                  
 30795                                  		;DOS function
 30796                                  		;DIRECT CHARACTER INPUT, WITHOUT ECHO
 30797 00004601 B407                    		mov	ah,07h
 30798 00004603 CD21                    		int	21h		
 30799                                  
 30800 00004605 8846FE                  		mov	[gsi_input],al
 30801                                  ;gsi_31:
 30802                                  		;while (!Done)
 30803                                  		;cmp	[gsi_done],0
 30804                                  		;jne	short gsi_32
 30805                                  	
 30806                                  		;/* Go handle different inputs */
 30807 00004608 E910FE                  		jmp	gsi_5
 30808                                  gsi_32:
 30809 0000460B 89EC                    		mov	sp,bp
 30810 0000460D 5D                      		pop	bp
 30811                                  		;retn
 30812 0000460E C20800                  		retn	8
 30813                                  
 30814                                  ; STRCHR.ASM (VCCRT2.ZIP) - Microsoft Visual C++ 1.0 Run-Time Library Sources
 30815                                  ; ----------------------------------------------------------------------------
 30816                                  ; Modified and simplified for NASM syntax by Erdogan Tan (01/01/2019)
 30817                                  
 30818                                  ;********
 30819                                  ;char *strchr(string, c) - search a string for a character
 30820                                  ;
 30821                                  ;Purpose:
 30822                                  ;	Searches a string for a given character, which may be the
 30823                                  ;	null character '\0'.
 30824                                  ;
 30825                                  ;	Algorithm:
 30826                                  ;	char *
 30827                                  ;	strchr (string, ch)
 30828                                  ;	      char *string, ch;
 30829                                  ;	      {
 30830                                  ;	      while (*string && *string != ch)
 30831                                  ;		      string++;
 30832                                  ;	      if (*string == ch)
 30833                                  ;		      return(string);
 30834                                  ;	      return((char *)0);
 30835                                  ;	      }
 30836                                  ;
 30837                                  ;Entry:
 30838                                  ;	char *string - string to search in
 30839                                  ;	char c - character to search for
 30840                                  ;
 30841                                  ;Exit:
 30842                                  ;	returns pointer to the first occurence of c in string
 30843                                  ;	returns NULL if c does not occur in string
 30844                                  ;
 30845                                  ;Uses:
 30846                                  ;
 30847                                  ;Exceptions:
 30848                                  ;
 30849                                  ;*******************************************************************************
 30850                                  
 30851                                  ; IBM PC-DOS 7.0 FDISDK.COM (unpacked) - Segfment 0, Offset 7264h
 30852                                  
 30853                                  strchr:
 30854                                  ;	%define strchr_string bp+4
 30855                                  ;	%define strchr_chr    bp+6	
 30856                                  ;
 30857                                  ;		push	bp
 30858                                  ;		mov	bp,sp
 30859                                  ;		;push	di 
 30860                                  ;
 30861                                  ;		mov	di,[strchr_string] ; di=pointer to string
 30862                                  ;		push	ds	; fix es for small/middle model
 30863                                  ;		pop	es
 30864                                  ;	
 30865                                  ;		mov	bx,di	; bx saves string pointer
 30866                                  ;		xor	ax,ax	; null byte to search for
 30867                                  ;		mov	cx,-1	; count bytes negatively in cx
 30868                                  ;		repne	scasb	; find string length by scanning for null
 30869                                  ;		not	cx	; cx=strlen+1
 30870                                  ;		mov	al,[str_chr] ; al=byte to search for
 30871                                  ;		mov	di,bx	; restore from saved string pointer
 30872                                  ;		repne	scasb	; find that byte (if it exists)!
 30873                                  ;
 30874                                  ;; if the repne scasb above terminates with the zero flag set, a match has
 30875                                  ;; been found and di points to the byte FOLLOWING the matching byte. if
 30876                                  ;; the zero flag is NOT set and the character being scanned for was NOT
 30877                                  ;; a null ('\0'), then the scan has failed. in the remaining case, which
 30878                                  ;; can only occur in large data models, the string must be exactly 0x10000
 30879                                  ;; bytes long (counting the terminal null character) and the very last byte
 30880                                  ;; is the match.
 30881                                  ;
 30882                                  ;		je	short retsuccess ; have a match, go do the return
 30883                                  ;
 30884                                  ;		xor	ax,ax	; no match, return NULL
 30885                                  ;		jmp	short toend
 30886                                  ;retsuccess:
 30887                                  ;		lea	ax,[di-1] ; ret value: pointer to matching byte
 30888                                  ;toend:
 30889                                  ;		;pop	di
 30890                                  ;		pop	bp
 30891                                  ;		retn
 30892                                  
 30893                                  		; INPUT:
 30894                                  		;   ds:si = address of string to search in 
 30895                                  		;   al = character to search for
 30896                                  		; OUTPUT:
 30897                                  		;   ax = pointer to the first occurence of chr in string
 30898                                  		;      = 0 if character does not occur in string	 	
 30899                                  
 30900                                  		;push	si
 30901                                  
 30902 00004611 88C4                    		mov	ah,al
 30903                                  strchr_0:
 30904 00004613 AC                      		lodsb
 30905 00004614 38E0                    		cmp	al,ah
 30906 00004616 7407                    		je	short strchr_2
 30907 00004618 20C0                    		and	al,al
 30908 0000461A 75F7                    		jnz	short strchr_0
 30909 0000461C 30E4                    		xor	ah,ah
 30910                                  strchr_1:
 30911                                  		;pop	si
 30912 0000461E C3                      		retn
 30913                                  strchr_2:
 30914 0000461F 8D44FF                  		lea	ax,[si-1]
 30915                                  		;jmp	shott shrchr_1
 30916 00004622 C3                      		retn
 30917                                  
 30918                                  ; ----------------------------------------------------------------------------
 30919                                  ; input.c (FDISK, MSDOS 6.0, 1991)	
 30920                                  ; ----------------------------------------------------------------------------
 30921                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 02/01/2019)
 30922                                  
 30923                                  ;/*  */
 30924                                  ;char get_alpha_input(low_letter,high_letter,row,col,error_low_letter,error_high_letter)
 30925                                  ;
 30926                                  ;unsigned     row;
 30927                                  ;unsigned     col;
 30928                                  ;char         low_letter;
 30929                                  ;char         high_letter;
 30930                                  ;char         error_low_letter;
 30931                                  ;char         error_high_letter;
 30932                                  ;
 30933                                  ;BEGIN
 30934                                  ;
 30935                                  ;    char   input;
 30936                                  ;    char   default_used;
 30937                                  ;    char   input_value;
 30938                                  ;
 30939                                  ;    char            attribute;
 30940                                  ;    char far        *attribute_ptr = &attribute;
 30941                                  ;    char far *input_ptr = &input;
 30942                                  ;
 30943                                  ;    if (mono_flag == TRUE)
 30944                                  ;        attribute = HIWHITE_ON_BLACK; /*C09*/
 30945                                  ;    else
 30946                                  ;        attribute = HIWHITE_ON_BLUE;  /*C09*/
 30947                                  ;
 30948                                  ;    /* Assume bad input */
 30949                                  ;    valid_input = FALSE;
 30950                                  ;
 30951                                  ;    /* Init input_value to something non-alpha */
 30952                                  ;    input_value = c(0);                                              /* AC000 */
 30953                                  ;
 30954                                  ;    /* Loop until we get good stuff */
 30955                                  ;    while (valid_input == FALSE)
 30956                                  ;        BEGIN
 30957                                  ;
 30958                                  ;        /* position the cursor */
 30959                                  ;        VIOSETCURPOS(row,col,u(0));                                  /* AC000 */
 30960                                  ;
 30961                                  ;        /* Flush the keyboard buffer and get the next pressed key */
 30962                                  ;        input = get_char_input();
 30963                                  ;        input = dos_upper(input);
 30964                                  ;
 30965                                  ;        /* Go handle different inputs */
 30966                                  ;        switch(input)
 30967                                  ;            BEGIN
 30968                                  ;            case ESC:
 30969                                  ;                BEGIN
 30970                                  ;                valid_input = TRUE;
 30971                                  ;                break;
 30972                                  ;                END
 30973                                  ;
 30974                                  ;            case  CR:
 30975                                  ;                BEGIN
 30976                                  ;                /* See if it is digit and between given letters*/
 30977                                  ;                /* Do world trade get country information */
 30978                                  ;                input = dos_upper(input_value);                      /* AN000 */
 30979                                  ;                if ((isalpha(input))       &&
 30980                                  ;                    (input >= low_letter)  &&
 30981                                  ;                    (input <= high_letter) &&
 30982                                  ;                    (isalpha(input_value)))
 30983                                  ;                    BEGIN
 30984                                  ;                    valid_input = TRUE;
 30985                                  ;                    END
 30986                                  ;                else
 30987                                  ;                    BEGIN
 30988                                  ;                    if (isalpha(input_value))
 30989                                  ;                        BEGIN
 30990                                  ;                        /* Setup error message */
 30991                                  ;                        insert[0] = input;
 30992                                  ;                        insert[1] = error_low_letter;
 30993                                  ;                        insert[2] = c('-');                          /* AC000 */
 30994                                  ;                        insert[3] = error_high_letter;
 30995                                  ;                        display(error_23);
 30996                                  ;                        END
 30997                                  ;                    else
 30998                                  ;                        BEGIN
 30999                                  ;                        insert[0] = error_low_letter;
 31000                                  ;                        insert[1] = c('-');                          /* AC000 */
 31001                                  ;                        insert[2] = error_high_letter;
 31002                                  ;                        display(error_31);
 31003                                  ;                        END
 31004                                  ;                    END
 31005                                  ;                break;
 31006                                  ;                END
 31007                                  ;
 31008                                  ;            default:
 31009                                  ;                BEGIN
 31010                                  ;
 31011                                  ;                if ((isalpha(input))       &&                           /*C16*/
 31012                                  ;                    (dos_upper(input) >= low_letter)  &&                /*C16*/
 31013                                  ;                    (dos_upper(input) <= high_letter))                  /*C16*/
 31014                                  ;                    clear_screen(u(23),u(0),u(23),u(79));               /*C16*/
 31015                                  ;                else                                                    /*C16*/
 31016                                  ;                    {                                                   /*C16*/
 31017                                  ;                    if (isalpha(input))                                 /*C16*/
 31018                                  ;                        {                                               /*C16*/
 31019                                  ;                        /* Setup error message */                       /*C16*/
 31020                                  ;                        insert[0] = input;                              /*C16*/
 31021                                  ;                        insert[1] = error_low_letter;                   /*C16*/
 31022                                  ;                        insert[2] = c('-');                             /*C16*/
 31023                                  ;                        insert[3] = error_high_letter;                  /*C16*/
 31024                                  ;                        display(error_23);                              /*C16*/
 31025                                  ;                        }                                               /*C16*/
 31026                                  ;                    else                                                /*C16*/
 31027                                  ;                        {                                               /*C16*/
 31028                                  ;                        insert[0] = error_low_letter;                   /*C16*/
 31029                                  ;                        insert[1] = c('-');                             /*C16*/
 31030                                  ;                        insert[2] = error_high_letter;                  /*C16*/
 31031                                  ;                        display(error_31);                              /*C16*/
 31032                                  ;                        }                                               /*C16*/
 31033                                  ;                    input = c(' ');                                     /*C16*/
 31034                                  ;                    }                                                   /*C16*/
 31035                                  ;                VIOWRTCHARSTRATT(input_ptr,u(1),row,col,attribute_ptr,u(0)); /*C16*/
 31036                                  ;                default_used = FALSE;
 31037                                  ;                input_value = input;
 31038                                  ;                break;
 31039                                  ;                END
 31040                                  ;            END
 31041                                  ;        END
 31042                                  ;    return(input);
 31043                                  ;END
 31044                                  		
 31045                                  get_alpha_input:
 31046                                  		; 02/01/2019
 31047                                  
 31048                                  	;%define gai_input_value   bp-16
 31049                                  	%define gai_attributeptr   bp-14
 31050                                  	;%define gai_attributeptr2 bp-12
 31051                                  	%define gai_input_value    bp-10
 31052                                  	;%define gai_default_used  bp-10
 31053                                  	%define gai_input_ptr	   bp-8
 31054                                  	;%define gai_input_ptr2	   bp-6
 31055                                  	%define gai_attribute	   bp-4
 31056                                  	%define gai_input	   bp-2
 31057                                  
 31058                                  	%define ga_i_low_letter	   bp+4
 31059                                  	%define ga_i_high_letter   bp+6
 31060                                  	%define ga_i_row	   bp+8
 31061                                  	%define ga_i_col	   bp+10
 31062                                  	%define ga_i_err_low_lett  bp+12
 31063                                  	%define ga_i_err_high_lett bp+14
 31064                                  
 31065 00004623 55                      		push	bp
 31066 00004624 89E5                    		mov	bp,sp
 31067                                  		;sub	sp,16
 31068 00004626 83EC0E                  		sub	sp,14
 31069                                  
 31070 00004629 8D46FC                  		lea	ax,[gai_attribute]
 31071 0000462C 8946F2                  		mov	[gai_attributeptr],ax
 31072 0000462F 8C56F4                  		mov	[gai_attributeptr+2],ss
 31073 00004632 8D4EFE                  		lea	cx,[gai_input]
 31074 00004635 894EF8                  		mov	[gai_input_ptr],cx
 31075 00004638 8C56FA                  		mov	[gai_input_ptr+2],ss
 31076                                  		
 31077 0000463B 803E[CAC3]01            		cmp	byte [mono_flag],1 ; TRUE
 31078 00004640 7506                    		jne	short gai_1
 31079 00004642 C646FC0F                		mov	byte [gai_attribute],0Fh ;HIWHITE_ON_BLACK
 31080 00004646 EB04                    		jmp	short gai_2
 31081                                  gai_1:
 31082 00004648 C646FC1F                		mov	byte [gai_attribute],1Fh ;HIWHITE_ON_BLUE
 31083                                  gai_2:
 31084 0000464C 28C0                    		sub	al,al  ;0
 31085                                  
 31086                                  		;/* Assume bad input */
 31087                                  
 31088 0000464E A2[DECB]                		mov	[valid_input],al ; 0
 31089                                  gai_3:
 31090                                  		;/* Init input_value to something non-alpha */
 31091                                  
 31092 00004651 8846F6                  		mov	[gai_input_value],al ; 0
 31093                                  gai_4:
 31094                                  		;/* Loop until we get good stuff */
 31095                                  
 31096 00004654 803E[DECB]00            		cmp	byte [valid_input],0 ; FALSE
 31097                                  		;je	short gai_5
 31098                                  		;jmp	gai_17 
 31099 00004659 7544                    		jne	short gai_17 ; 03/01/2019
 31100                                  gai_5:
 31101                                  		;/* position the cursor */
 31102                                  
 31103                                  		;push	word [ga_i_row]
 31104                                  		;push	word [ga_i_col]
 31105                                  		;sub	ax,ax
 31106                                  		;push	ax
 31107                                  
 31108 0000465B 8A7608                  		mov	dh,[ga_i_row]
 31109 0000465E 8A560A                  		mov	dl,[ga_i_col]
 31110                                  
 31111 00004661 E8B2E5                  		call	VIOSETCURPOS
 31112                                  
 31113                                  	;/* Flush the keyboard buffer and get the next pressed key */
 31114                                  
 31115 00004664 E8A2E5                  		call	get_char_input
 31116                                  		;mov	[gai_input],al
 31117                                  		;push	ax
 31118 00004667 E8C4E5                  		call	dos_upper ; ***
 31119                                  		;pop	bx
 31120 0000466A 8846FE                  		mov	[gai_input],al
 31121                                  		
 31122                                  		;/* Go handle different inputs */
 31123                                  
 31124 0000466D 98                      		cbw
 31125 0000466E 89C3                    		mov	bx,ax ; bl = [gai_input]
 31126                                  
 31127                                  		;switch(input)
 31128                                  
 31129                                  		;cbw
 31130                                  		;sub	ax,0Dh
 31131 00004670 2C0D                    		sub	al,0Dh ; sub al,13
 31132 00004672 7431                    		jz	short gai_9 ; 13, CR
 31133                                  		;sub	ax,0Eh
 31134 00004674 2C0E                    		sub	al,0Eh ; sub al,14
 31135 00004676 744B                    		jz	short gai_8 ; 27, ESC 
 31136                                  
 31137                                  		;mov	al,[gai_input]
 31138                                  		;cbw
 31139                                  		;mov	bx,ax
 31140                                  
 31141 00004678 F687[FC9E]03            		test	byte [isdigit+bx],3
 31142                                  		;jz	short gai_6
 31143 0000467D 0F84A100                		jz	gai_14
 31144                                  
 31145                                  		;;push	ax
 31146                                  		;call	dos_upper
 31147                                  		;;pop	bx
 31148                                  		
 31149                                  		;cmp	al,[ga_i_low_letter]
 31150 00004681 3A5E04                  		cmp	bl,[ga_i_low_letter]
 31151 00004684 7C05                    		jl	short gai_6
 31152                                  		;;mov	al,[gai_input]
 31153                                  		;;push	ax
 31154                                  		;call	dos_upper
 31155                                  		;;pop	bx
 31156                                  		;cmp	al,[ga_i_high_letter]
 31157 00004686 3A5E06                  		cmp	bl,[ga_i_high_letter]
 31158 00004689 7E02                    		jle	short gai_7
 31159                                  gai_6:
 31160 0000468B EB79                    		jmp	gai_13
 31161                                  gai_7:
 31162 0000468D B84F00                  		mov	ax,79
 31163 00004690 50                      		push	ax
 31164 00004691 B81700                  		mov	ax,23
 31165 00004694 50                      		push	ax
 31166 00004695 29C9                    		sub	cx,cx
 31167 00004697 51                      		push	cx
 31168 00004698 50                      		push	ax
 31169 00004699 E8FACD                  		call	clear_screen
 31170                                  		;add	sp,8
 31171                                  		
 31172 0000469C E9A000                  		jmp	gai_16
 31173                                  		
 31174                                  		; 03/01/2019
 31175                                  gai_17:
 31176                                  		;mov	al,[gai_input]
 31177 0000469F 89EC                    		mov	sp,bp
 31178 000046A1 5D                      		pop	bp
 31179                                  		;retn
 31180 000046A2 C20C00                  		retn	12
 31181                                  
 31182                                  ;gai_8:
 31183                                  ;		mov	byte [valid_input],1
 31184                                  ;		;jmp	short gai_4
 31185                                  ;		mov	al,bl ; mov al,[gai_input]
 31186                                  ;		jmp	short gai_17
 31187                                  gai_9:
 31188                                  		;/* See if it is digit and between given letters*/
 31189                                  		;/* Do world trade get country information */
 31190                                  
 31191 000046A5 8A46F6                  		mov	al,[gai_input_value]
 31192                                  
 31193                                  		; (AL has already uppercase character) ; ***
 31194                                  		; (gai_5 -> gai_7 -> gai_16 -> gai_3 -> gai_5 -> gai_9)
 31195                                  		;;push	ax
 31196                                  		;call	dos_upper
 31197                                  		;;pop	bx
 31198                                  
 31199                                  		;if (isalpha(input))
 31200                                  
 31201 000046A8 8846FE                  		mov	[gai_input],al ; the char just prior to CR
 31202 000046AB 98                      		cbw
 31203 000046AC 89C3                    		mov	bx,ax
 31204 000046AE F687[FC9E]03            		test	byte [isdigit+bx],3
 31205                                  		;jz	short gai_10
 31206 000046B3 7435                    		jz	short gai_11
 31207                                  
 31208 000046B5 8A4604                  		mov	al,[ga_i_low_letter]
 31209                                  		;cmp	[gai_input],al
 31210 000046B8 38C3                    		cmp	bl,al
 31211 000046BA 7C10                    		jl	short gai_10
 31212 000046BC 8A4606                  		mov	al,[ga_i_high_letter]
 31213                                  		;cmp	[gai_input],al	
 31214 000046BF 38C3                    		cmp	bl,al
 31215 000046C1 7F09                    		jg	short gai_10
 31216                                  		
 31217                                  		;mov	al,[gai_input_value]
 31218                                  		;cbw
 31219                                  		;mov	bx,ax
 31220                                  		;test	[isdigit+bx],3
 31221                                  		;jnz	short gai_8
 31222                                  
 31223                                  		;jmp	short gai_8
 31224                                  gai_8:
 31225 000046C3 C606[DECB]01            		mov	byte [valid_input],1 ; TRUE
 31226                                  		;jmp	short gai_4
 31227 000046C8 88D8                    		mov	al,bl ; mov al,[gai_input]
 31228 000046CA EBD3                    		jmp	short gai_17 ; 03/01/2019
 31229                                  gai_10:
 31230                                  		;/* Setup error message */    
 31231                                  
 31232                                  		;mov	al,[gai_input_value]
 31233                                  		;cbw
 31234                                  		;mov	bx,ax
 31235                                  		;test	[isdigit+bx],3
 31236                                  		;jz	short gai_11
 31237                                  		
 31238 000046CC 8A46FE                  		mov	al,[gai_input]
 31239 000046CF A2[E6CC]                		mov	[insert],al
 31240 000046D2 8A460C                  		mov	al,[ga_i_err_low_lett]
 31241 000046D5 A2[E7CC]                		mov	[insert+1],al
 31242 000046D8 C606[E8CC]2D            		mov	byte [insert+2],'-'
 31243 000046DD 8A460E                  		mov	al, [ga_i_err_high_lett]
 31244 000046E0 A2[E9CC]                		mov	[insert+3],al
 31245                                  		;push	word [error_23_seg]
 31246 000046E3 1E                      		push	ds
 31247 000046E4 FF36[9E9E]              		push	word [error_23_off]
 31248 000046E8 EB16                    		jmp	short gai_12
 31249                                  gai_11:
 31250 000046EA 8A460C                  		mov	al,[ga_i_err_low_lett]
 31251 000046ED A2[E6CC]                		mov	[insert],al
 31252 000046F0 C606[E7CC]2D            		mov	byte [insert+1],'-'
 31253 000046F5 8A460E                  		mov	al,[ga_i_err_high_lett]
 31254 000046F8 A2[E8CC]                		mov	[insert+2],al
 31255                                  		;push	word [error_31_seg]
 31256 000046FB 1E                      		push	ds
 31257 000046FC FF36[AE9E]              		push	word [error_31_off]
 31258                                  gai_12:
 31259 00004700 E817CF                  		call	display
 31260                                  		;pop	bx
 31261                                  		;pop	bx
 31262                                  		; 03/01/2019
 31263                                  		;jmp	gai_4
 31264 00004703 E955FF                  		jmp	gai_5 ; [valid_input] = 0
 31265                                  gai_13:
 31266                                  		;;mov	al,[gai_input]
 31267                                  		;;cbw
 31268                                  		;;mov	bx,ax
 31269                                  		;mov	bl,[gai_input]
 31270                                  		;xor	bh,bh
 31271                                  		;test	byte [isdigit+bx],3
 31272                                  		;jz	short gai_14
 31273                                  
 31274                                  		;/* Setup error message */        
 31275                                  
 31276                                  		;mov	[insert],al
 31277 00004706 881E[E6CC]              		mov	[insert],bl
 31278 0000470A 8A460C                  		mov	al,[ga_i_err_low_lett]
 31279 0000470D A2[E7CC]                		mov	[insert+1],al
 31280 00004710 C606[E8CC]2D            		mov	byte [insert+2],'-'
 31281 00004715 8A460E                  		mov	al,[ga_i_err_high_lett]
 31282 00004718 A2[E9CC]                		mov	[insert+3],al
 31283                                  		;push	word [error_23_seg]
 31284 0000471B 1E                      		push	ds
 31285 0000471C FF36[9E9E]              		push	word [error_23_off]
 31286 00004720 EB16                    		jmp	short gai_15
 31287                                  gai_14:
 31288 00004722 8A460C                  		mov	al,[ga_i_err_low_lett]
 31289 00004725 A2[E6CC]                		mov	[insert],al
 31290 00004728 C606[E7CC]2D            		mov	byte [insert+1],'-'
 31291 0000472D 8A460E                  		mov	al,[ga_i_err_high_lett]
 31292 00004730 A2[E8CC]                		mov	[insert+2],al
 31293                                  		;push	word [error_31_seg]
 31294 00004733 1E                      		push	ds
 31295 00004734 FF36[AE9E]              		push	word [error_31_off]
 31296                                  gai_15:
 31297 00004738 E8DFCE                  		call	display
 31298                                  		;pop	bx
 31299                                  		;pop	bx
 31300 0000473B C646FE20                		mov	byte [gai_input],' '
 31301                                  gai_16:
 31302                                  	;VIOWRTCHARSTRATT(input_ptr,u(1),row,col,attribute_ptr,u(0));
 31303                                  
 31304 0000473F FF76FA                  		push	word [gai_input_ptr+2]
 31305 00004742 FF76F8                  		push	word [gai_input_ptr]
 31306 00004745 B80100                  		mov	ax,1
 31307 00004748 50                      		push	ax
 31308 00004749 FF7608                  		push	word [ga_i_row]
 31309 0000474C FF760A                  		push	word [ga_i_col]
 31310 0000474F FF76F4                  		push	word [gai_attributeptr+2]
 31311 00004752 FF76F2                  		push	word [gai_attributeptr]
 31312                                  		;sub	ax,ax
 31313                                  		;push	ax
 31314 00004755 E881D1                  		call	VIOWRTCHARSTRATT
 31315                                  		;mov	byte [gai_default_used],0  ;FALSE
 31316 00004758 8A46FE                  		mov	al,[gai_input]
 31317 0000475B E9F3FE                  		jmp	gai_3
 31318                                  ;gai_17:
 31319                                  ;		;mov	al,[gai_input]
 31320                                  ;		mov	sp,bp
 31321                                  ;		pop	bp
 31322                                  ;		;retn
 31323                                  ;		retn	12
 31324                                  
 31325                                  ; ----------------------------------------------------------------------------
 31326                                  ; rempart.c (FDISK, MSDOS 6.0, 1991)	
 31327                                  ; ----------------------------------------------------------------------------
 31328                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 02/01/2019)
 31329                                  
 31330                                  ;void remove_partition(drive,entry)
 31331                                  ;
 31332                                  ;char        drive;
 31333                                  ;unsigned    entry;
 31334                                  ;
 31335                                  ;BEGIN
 31336                                  ;
 31337                                  ;    /* Set Partition entry to zero */
 31338                                  ;    part_table[drive][entry].boot_ind = uc(0);
 31339                                  ;    part_table[drive][entry].start_head = uc(0);
 31340                                  ;    part_table[drive][entry].start_sector = uc(0);
 31341                                  ;    part_table[drive][entry].start_cyl = u(0);
 31342                                  ;    part_table[drive][entry].sys_id = uc(0);
 31343                                  ;    part_table[drive][entry].end_head = uc(0);
 31344                                  ;    part_table[drive][entry].end_sector = uc(0);
 31345                                  ;    part_table[drive][entry].end_cyl = u(0);
 31346                                  ;    part_table[drive][entry].rel_sec = ul(0);
 31347                                  ;    part_table[drive][entry].num_sec = ul(0);
 31348                                  ;    part_table[drive][entry].changed = (FLAG)TRUE;
 31349                                  ;    part_table[drive][entry].mbytes_used = f(0);
 31350                                  ;    part_table[drive][entry].percent_used = u(0);
 31351                                  ;
 31352                                  ;    strcpy(part_table[drive][entry].system,c(NUL));
 31353                                  ;    strcpy(part_table[drive][entry].vol_label,c(NUL));
 31354                                  ;
 31355                                  ;    return;
 31356                                  ;END
 31357                                  
 31358                                  remove_partition:
 31359                                  		; 02/01/2019
 31360                                  
 31361                                  	;%define rmp_drive bp+4
 31362                                  	;%define rmp_entry bp+6
 31363                                  
 31364                                  		;push	bp
 31365                                  		;mov	bp,sp
 31366                                  		;push	si
 31367                                  
 31368                                  		; INPUT:
 31369                                  		;   AL = Disk number (0 to 7)
 31370                                  		;   AH = Partition entry number (0 to 3)
 31371                                  
 31372                                  		;mov	al,[rmp_drive]
 31373                                  		;cbw
 31374                                  		;shl	ax,1
 31375                                  		;shl	ax,1
 31376                                  		;add	ax,[rmp_entry]
 31377                                  
 31378 0000475E D0E0                    		shl	al,1
 31379 00004760 D0E0                    		shl	al,1
 31380 00004762 00E0                    		add	al,ah
 31381                                  
 31382                                  		;mov	cx,46
 31383                                  		;mul	cx
 31384                                  
 31385 00004764 B12E                    		mov	cl,46
 31386 00004766 F6E1                    		mul	cl		
 31387 00004768 89C3                    		mov	bx,ax
 31388                                  		;sub	al,al
 31389 0000476A 29C0                    		sub	ax,ax
 31390 0000476C 8887[12C4]              		mov	[part_table_boot_ind+bx],al
 31391 00004770 8887[13C4]              		mov	[part_table_start_head+bx],al
 31392 00004774 8887[14C4]              		mov	[part_table_start_sector+bx],al
 31393 00004778 8987[15C4]              		mov	[part_table_start_cyl+bx],ax ; 0
 31394 0000477C 8887[17C4]              		mov	[part_table_sys_id+bx],al
 31395 00004780 8887[18C4]              		mov	[part_table_end_head+bx],al
 31396 00004784 8887[19C4]              		mov	[part_table_end_sector+bx],al
 31397 00004788 8987[1AC4]              		mov	[part_table_end_cyl+bx],ax ; 0
 31398                                  		;sub	ax,ax
 31399 0000478C 8987[1EC4]              		mov	[part_table_rel_sec_hw+bx],ax
 31400 00004790 8987[1CC4]              		mov	[part_table_rel_sec_lw+bx],ax
 31401 00004794 8987[22C4]              		mov	[part_table_num_sec_hw+bx],ax
 31402 00004798 8987[20C4]              		mov	[part_table_num_sec_lw+bx],ax
 31403 0000479C C687[25C4]01            		mov	byte [part_table_changed+bx],1
 31404 000047A1 8987[26C4]              		mov	[part_table_mbytes_used+bx],ax
 31405 000047A5 8987[28C4]              		mov	[part_table_percent_used+bx],ax
 31406                                  
 31407                                  		;push	ax
 31408                                  		;mov	cx,bx
 31409                                  		;add	bx,part_table_system
 31410                                  		;push	bx
 31411                                  		;mov	si,cx
 31412                                  		;call	strcpy
 31413                                  		;pop	bx
 31414                                  		;pop	bx
 31415                                  
 31416                                  		;sub	ax,ax
 31417                                  		;push	ax
 31418                                  		;add	si,part_table_vol_label
 31419                                  		;push	si
 31420                                  		;call	strcpy
 31421                                  		;pop	bx
 31422                                  		;pop	bx
 31423                                  
 31424                                  		; 02/01/2019
 31425                                  		;xor	al,al
 31426                                  		;push	ds
 31427                                  		;pop	es
 31428 000047A9 BF[2AC4]                		mov	di,part_table_vol_label
 31429 000047AC 01DF                    		add	di,bx
 31430 000047AE B91500                  		mov	cx,12+9 ; 21
 31431 000047B1 F3AA                    		rep	stosb
 31432 000047B3 C3                      		retn		
 31433                                  
 31434                                  		;pop	si
 31435                                  		;mov	sp,bp
 31436                                  		;pop	bp
 31437                                  		;retn
 31438                                  		;retn	4
 31439                                  
 31440                                  ; ----------------------------------------------------------------------------
 31441                                  		
 31442                                  ;void remove_volume(drive,entry)
 31443                                  ;
 31444                                  ;char        drive;
 31445                                  ;unsigned    entry;
 31446                                  ;
 31447                                  ;BEGIN
 31448                                  ;
 31449                                  ;    /* Set volume entry to zero */
 31450                                  ;    ext_table[drive][entry].boot_ind = uc(0);
 31451                                  ;    ext_table[drive][entry].start_head = uc(0);
 31452                                  ;    ext_table[drive][entry].start_sector = uc(0);
 31453                                  ;    ext_table[drive][entry].start_cyl = u(0);
 31454                                  ;    ext_table[drive][entry].sys_id = uc(0);
 31455                                  ;    ext_table[drive][entry].end_head = uc(0);
 31456                                  ;    ext_table[drive][entry].end_sector = uc(0);
 31457                                  ;    ext_table[drive][entry].end_cyl = u(0);
 31458                                  ;    ext_table[drive][entry].rel_sec = ul(0);
 31459                                  ;    ext_table[drive][entry].num_sec = ul(0);
 31460                                  ;    ext_table[drive][entry].mbytes_used = f(0);
 31461                                  ;    ext_table[drive][entry].percent_used = u(0);
 31462                                  ;    ext_table[drive][entry].changed = TRUE;
 31463                                  ;    ext_table[drive][entry].drive_letter = NUL;
 31464                                  ;
 31465                                  ;    strcpy(ext_table[drive][entry].system,c(NUL));
 31466                                  ;    strcpy(ext_table[drive][entry].vol_label,c(NUL));
 31467                                  ;
 31468                                  ;    return;
 31469                                  ;END
 31470                                  
 31471                                  remove_volume:
 31472                                  		; 02/01/2019
 31473                                  
 31474                                  	;%define rmv_drive bp+4
 31475                                  	;%define rmv_entry bp+6
 31476                                  
 31477                                  		;push	bp
 31478                                  		;mov	bp,sp
 31479                                  		;push	si
 31480                                  
 31481                                  		; INPUT:
 31482                                  		;   AL = Disk number (0 to 7)
 31483                                  		;   CL = Partition entry number (0 to 3)
 31484                                  
 31485                                  		;mov	al,24
 31486                                  		;imul	byte [rmv_drive]
 31487                                  
 31488 000047B4 B418                    		mov	ah,24
 31489 000047B6 F6E4                    		mul	ah
 31490 000047B8 00C8                    		add	al,cl
 31491                                  		
 31492                                  		;mov	cx,46
 31493                                  		;mul	cx
 31494 000047BA B12E                    		mov	cl,46
 31495 000047BC F6E1                    		mul	cl
 31496 000047BE 89C3                    		mov	bx,ax
 31497                                  		;sub	al,al
 31498 000047C0 29C0                    		sub	ax,ax
 31499 000047C2 8887[4AA1]              		mov	[ext_table_boot_ind+bx],al
 31500 000047C6 8887[4BA1]              		mov	[ext_table_start_head+bx],al
 31501 000047CA 8887[4CA1]              		mov	[ext_table_start_sector+bx],al
 31502 000047CE 8987[4DA1]              		mov	[ext_table_start_cyl+bx],ax ; 0
 31503 000047D2 8887[4FA1]              		mov	[ext_table_sys_id+bx],al
 31504 000047D6 8887[50A1]              		mov	[ext_table_end_head+bx],al
 31505 000047DA 8887[51A1]              		mov	[ext_table_end_sector+bx],al
 31506 000047DE 8987[52A1]              		mov	[ext_table_end_cyl+bx],ax ; 0
 31507                                  		;sub	ax,ax
 31508 000047E2 8987[56A1]              		mov	[ext_table_rel_sec_hw+bx],ax
 31509 000047E6 8987[54A1]              		mov	[ext_table_rel_sec_lw+bx],ax
 31510 000047EA 8987[5AA1]              		mov	[ext_table_num_sec_hw+bx],ax
 31511 000047EE 8987[58A1]              		mov	[ext_table_num_sec_lw+bx],ax
 31512 000047F2 8987[5EA1]              		mov	[ext_table_mbytes_used+bx],ax
 31513 000047F6 8987[60A1]              		mov	[ext_table_percent_used+bx],ax
 31514 000047FA C687[5DA1]01            		mov	byte [ext_table_changed+bx],1
 31515 000047FF 8987[77A1]              		mov	[ext_table_drive_letter+bx],ax ; 0
 31516                                  		
 31517                                  		;push	ax
 31518                                  		;mov	cx,bx
 31519                                  		;add	bx,ext_table_system
 31520                                  		;push	bx
 31521                                  		;mov	si,cx
 31522                                  		;call	strcpy
 31523                                  		;pop	bx
 31524                                  		;pop	bx
 31525                                  
 31526                                  		;sub	ax,ax
 31527                                  		;push	ax
 31528                                  		;add	si,ext_table_vol_label
 31529                                  		;push	si
 31530                                  		;call	strcpy
 31531                                  		;pop	bx
 31532                                  		;pop	bx
 31533                                  
 31534                                  		; 02/01/2019
 31535                                  		;xor	al,al
 31536                                  		;push	ds
 31537                                  		;pop	es
 31538 00004803 BF[62A1]                		mov	di,ext_table_vol_label
 31539 00004806 01DF                    		add	di,bx
 31540 00004808 B91500                  		mov	cx,12+9 ; 21
 31541 0000480B F3AA                    		rep	stosb
 31542 0000480D C3                      		retn		
 31543                                  
 31544                                  		;pop	si
 31545                                  		;mov	sp,bp
 31546                                  		;pop	bp
 31547                                  		;retn
 31548                                  		;retn	4
 31549                                  
 31550                                  ; ----------------------------------------------------------------------------
 31551                                  ; partinfo.c (FDISK, MSDOS 6.0, 1991)	
 31552                                  ; ----------------------------------------------------------------------------
 31553                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 02/01/2019)
 31554                                  
 31555                                  ;char get_num_logical_dos_drives()
 31556                                  ;BEGIN
 31557                                  ;
 31558                                  ;char   i;
 31559                                  ;char number;
 31560                                  ;
 31561                                  ;   number = c(0);
 31562                                  ;   /* See if there is a logical drive defined in Extended Partition */
 31563                                  ;   for (i = c(0); i < c(23);i++)
 31564                                  ;      BEGIN
 31565                                  ;        /* See if we find a sys id that is DOS */
 31566                                  ;       if ((ext_table[cur_disk][i].sys_id == uc(DOS12)) || (ext_table[cur_disk][i].sys_id == uc(DOS16)) ||
 31567                                  ;          (ext_table[cur_disk][i].sys_id == uc(DOSNEW))) 
 31568                                  ;          BEGIN
 31569                                  ;           number++;
 31570                                  ;          END
 31571                                  ;      END
 31572                                  ;    return(number);
 31573                                  ;END
 31574                                  
 31575                                  get_num_logical_dos_drives:
 31576                                  		
 31577                                  		; 02/01/2019
 31578                                  
 31579                                  	;%define gnldd_i      bp-4
 31580                                  	;%define gnldd_number bp-2
 31581                                  
 31582                                  		;push	bp
 31583                                  		;mov	bp,sp
 31584                                  		;sub	sp,4
 31585                                  
 31586                                  		;sub	al,al
 31587                                  		;mov	[gnldd_number],al
 31588                                  		;mov	[gnldd_i], al
 31589                                  		
 31590 0000480E 31D2                    		xor	dx,dx  ; 0
 31591                                  		;jmp	short gnldd_4
 31592                                  gnldd_1:
 31593                                  		;mov	al,[gnldd_i]
 31594                                  ;gnldd_4:
 31595                                  		;cbw
 31596                                  		;mov	cx,ax
 31597 00004810 B018                    		mov	al,24
 31598                                  		;imul	byte [cur_disk]
 31599 00004812 F626[D4CB]              		mul	byte [cur_disk]
 31600                                  		;add	ax,cx
 31601 00004816 00D0                    		add	al,dl ; [gnldd_i]
 31602                                  		;mov	cx,46
 31603                                  		;imul	cx
 31604 00004818 B12E                    		mov	cl,46
 31605 0000481A F6E1                    		mul	cl
 31606 0000481C 89C3                    		mov	bx,ax
 31607 0000481E 8A87[4FA1]              		mov	al,[ext_table_sys_id+bx]
 31608                                  		;cmp	byte [ext_table_sys_id+bx],1 ; DOS12
 31609 00004822 3C01                    		cmp	al,1
 31610 00004824 7408                    		je	short gnldd_2
 31611                                  		;cmp	byte [ext_table_sys_id+bx],4 ; DOS16
 31612 00004826 3C04                    		cmp	al,4
 31613 00004828 7404                    		je	short gnldd_2
 31614                                  		;cmp	byte [ext_table_sys_id+bx],6 ; DOSNEW (FAT16 big)
 31615 0000482A 3C06                    		cmp	al,6
 31616 0000482C 7502                    		jne	short gnldd_3
 31617                                  gnldd_2:
 31618                                  		;inc	byte [gnldd_number]
 31619 0000482E FEC6                    		inc	dh
 31620                                  gnldd_3:
 31621                                  		;inc	byte [gnldd_i]
 31622 00004830 FEC2                    		inc	dl
 31623                                  ;gnldd_4:
 31624                                  		;cmp	byte [gnldd_i],23
 31625 00004832 80FA17                  		cmp	dl,23
 31626 00004835 7CD9                    		jl	short gnldd_1
 31627                                  
 31628                                  		;mov	al,[gnldd_number]
 31629                                  
 31630 00004837 88F0                    		mov	al,dh ; [gnldd_number]
 31631                                  
 31632                                  		;xor	dx,dx
 31633                                  
 31634                                  		;mov	sp,bp
 31635                                  		;pop	bp
 31636                                  
 31637 00004839 C3                      		retn
 31638                                  
 31639                                  ; ============================================================================
 31640                                  ;  CREATE PARTITION
 31641                                  ; ============================================================================
 31642                                  ; 13/01/2019
 31643                                  
 31644                                  ; fdisk.msg (MSDOS 6.0)
 31645                                  ;/***************************************************************************************************/
 31646                                  ;/* Screen for CREATE_PARTITION                                                                     */
 31647                                  ;/*                                                                                                 */
 31648                                  ;/*     |00000000001111111111222222222233333333334444444444555555555566666666667777777777|          */
 31649                                  ;/*     |01234567890123456789012345678901234567890123456789012345678901234567890123456789|          */
 31650                                  ;/*   --|--------------------------------------------------------------------------------|          */
 31651                                  ;/*   00|                                                                                |          */
 31652                                  ;/*   01|                                                                                |          */
 31653                                  ;/*   02|                                                                                |          */
 31654                                  ;/*   03|                                                                                |          */
 31655                                  ;/*   04|                  Create DOS Partition or Logical DOS Drive                     |menu_8    */
 31656                                  ;/*   05|                                                                                |          */
 31657                                  ;/*   06|    Current fixed disk drive: #                                                 |menu_5 #  */
 31658                                  ;/*   07|                                                                                |          */
 31659                                  ;/*   08|    Choose one of the following:                                                |menu_3 #  */
 31660                                  ;/*   09|                                                                                |          */
 31661                                  ;/*   10|    1.  Create Primary DOS Partition                                            |menu_9    */
 31662                                  ;/*   11|    2.  Create Extended DOS Partition                                           |menu_9    */
 31663                                  ;/*   12|    3.  Create logical DOS Drive(s) in the Extended DOS Partition               |menu_10   */
 31664                                  ;/*   13|                                                                                |          */
 31665                                  ;/*   14|                                                                                |          */
 31666                                  ;/*   15|                                                                                |          */
 31667                                  ;/*   16|                                                                                |          */
 31668                                  ;/*   17|    Enter choice: [ ]                                                           |menu_7 #  */
 31669                                  ;/*   18|                                                                                |          */
 31670                                  ;/*   19|                                                                                |          */
 31671                                  ;/*   20|                                                                                |          */
 31672                                  ;/*   21|                                                                                |          */
 31673                                  ;/*   22|                                                                                |          */
 31674                                  ;/*   23|                                                                                |          */
 31675                                  ;/*   24|    Press ESC to return to FDISK Options                                        |menu_11   */
 31676                                  ;/*   ------------------------------------------------------------------------------------          */
 31677                                  ;/*                                                                                                 */
 31678                                  ;/***************************************************************************************************/
 31679                                  
 31680                                  ; ----------------------------------------------------------------------------
 31681                                  ; c_menus.c (FDISK, MSDOS 6.0, 1991)	
 31682                                  ; ----------------------------------------------------------------------------
 31683                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 13/01/2019)
 31684                                  
 31685                                  ;/*  */
 31686                                  ;/******************* START OF SPECIFICATIONS *******************/
 31687                                  ;/*                                                             */
 31688                                  ;/* SUBROUTINE NAME: CREATE_PARTITION                           */
 31689                                  ;/*                                                             */
 31690                                  ;/* DESCRIPTIVE NAME: Create DOS related partition(s)           */
 31691                                  ;/*                                                             */
 31692                                  ;/* FUNCTION:                                                   */
 31693                                  ;/*      This routine verifies if there are free partitions,    */
 31694                                  ;/*      posts an status message if there is not, otherwise     */
 31695                                  ;/*      prints a screen asking what type of partition to       */
 31696                                  ;/*      be created, and passes control to the requested        */
 31697                                  ;/*      function.                                              */
 31698                                  ;/*                                                             */
 31699                                  ;/* NOTES: This is a screen control module only, no data is     */
 31700                                  ;/*        modified. Routine also will only allow 1 DOS and     */
 31701                                  ;/*        1 Ext DOS partitions per disk, if one already exists,*/
 31702                                  ;/*        then status message is displayed when the create     */
 31703                                  ;/*        option for that type partition is selected           */
 31704                                  ;/*                                                             */
 31705                                  ;/*        The following screen in managed                      */
 31706                                  ;/*                                                             */
 31707                                  ;/*       |0000000000111111111122222222223333333333|            */
 31708                                  ;/*       |0123456789012345678901234567890123456789|            */
 31709                                  ;/*     --|----------------------------------------|            */
 31710                                  ;/*     00|                                        |            */
 31711                                  ;/*     01|                                        |            */
 31712                                  ;/*     02|                                        |            */
 31713                                  ;/*     03|                                        |            */
 31714                                  ;/*     04|Create DOS Partition                    |            */
 31715                                  ;/*     05|                                        |            */
 31716                                  ;/*     06|Current Fixed Disk Drive: #             |            */
 31717                                  ;/*     07|                                        |            */
 31718                                  ;/*     08|Choose one of the following:            |            */
 31719                                  ;/*     09|                                        |            */
 31720                                  ;/*     10|    1.  Create Primary DOS partition    |            */
 31721                                  ;/*     11|    2.  Create EXTENDED DOS partition   |            */
 31722                                  ;/*     12|    3.  Create logical DOS drive(s) in  |            */
 31723                                  ;/*     13|        the EXTENDED DOS partition      |            */
 31724                                  ;/*     14|                                        |            */
 31725                                  ;/*     15|                                        |            */
 31726                                  ;/*     16|                                        |            */
 31727                                  ;/*     17|                                        |            */
 31728                                  ;/*     18|Enter choice: [ ]                       |            */
 31729                                  ;/*     19|                                        |            */
 31730                                  ;/*     20|                                        |            */
 31731                                  ;/*     21|                                        |            */
 31732                                  ;/*     22|                                        |            */
 31733                                  ;/*     23|Press ESC to return to FDISK Options    |            */
 31734                                  ;/*     --------------------------------------------            */
 31735                                  ;/*                                                             */
 31736                                  ;/* ENTRY POINTS: create_partition                              */
 31737                                  ;/*      LINKAGE: create_partition();                           */
 31738                                  ;/*                                                             */
 31739                                  ;/* INPUT: None                                                 */
 31740                                  ;/*                                                             */
 31741                                  ;/* EXIT-NORMAL: ERROR=FALSE                                    */
 31742                                  ;/*                                                             */
 31743                                  ;/* EXIT-ERROR: ERROR=TRUE                                      */
 31744                                  ;/*             GOTO internal_program_error if case statement   */
 31745                                  ;/*             failure when branching to requested function    */
 31746                                  ;/*                                                             */
 31747                                  ;/* EFFECTS: No data directly modified by this routine, but     */
 31748                                  ;/*          child routines will modify data.                   */
 31749                                  ;/*                                                             */
 31750                                  ;/* INTERNAL REFERENCES:                                        */
 31751                                  ;/*   ROUTINES:                                                 */
 31752                                  ;/*      find_free_partition                                    */
 31753                                  ;/*      dos_create_partition                                   */
 31754                                  ;/*      ext_create_partition                                   */
 31755                                  ;/*      volume_create                                          */
 31756                                  ;/*      internal_program_error                                 */
 31757                                  ;/*      find_partition_type                                    */
 31758                                  ;/*      get_num_input                                          */
 31759                                  ;/*      display                                                */
 31760                                  ;/*      wait_for_ESC                                           */
 31761                                  ;/*      clear_screen                                           */
 31762                                  ;/*                                                             */
 31763                                  ;/* EXTERNAL REFERENCES:                                        */
 31764                                  ;/*   ROUTINES:                                                 */
 31765                                  ;/*                                                             */
 31766                                  ;/******************** END OF SPECIFICATIONS ********************/
 31767                                  
 31768                                  ;/*  */
 31769                                  ;void create_partition()
 31770                                  ;
 31771                                  ;BEGIN
 31772                                  ;
 31773                                  ;char   input;
 31774                                  ;char   default_value;
 31775                                  ;char   max_input;
 31776                                  ;
 31777                                  ;    input = c(NUL);                                                    /* AC000 */
 31778                                  ;    clear_screen(u(0),u(0),u(24),u(79));                               /* AC000 */
 31779                                  ;    /* put up heading and ESC */
 31780                                  ;    display(menu_8);
 31781                                  ;    display(menu_11);
 31782                                  ;
 31783                                  ;    /* Setup current drive msg */
 31784                                  ;    insert[0]=cur_disk+1+'0';
 31785                                  ;    display(menu_5);
 31786                                  ;
 31787                                  ;    /* See if there are free partitions */
 31788                                  ;    /* SR; 9/26/89; This check should be done only if the user asks to
 31789                                  ;       create a primary or extended partition and not for logical volumes */
 31790                                  ;
 31791                                  ;        /* display menu */
 31792                                  ;        display(menu_3);                                               /* AN000 */
 31793                                  ;        display(menu_9);
 31794                                  ;
 31795                                  ;        /* ############# ADD CODE HERE FOR THIS FUNCTION ############## */
 31796                                  ;        /* Do something about highlighting the available options and    */
 31797                                  ;        /* setting up defaults                                          */
 31798                                  ;        default_value = c(1);                                          /* AC000 */
 31799                                  ;        /* ############################################################ */
 31800                                  ;        /* setup default for prompt */
 31801                                  ;        insert[0] = c('1');                                            /* AC000 */
 31802                                  ;        display(menu_7);
 31803                                  ;        display(menu_10);
 31804                                  ;
 31805                                  ;        max_input = c(3);                                              /* AC000 */
 31806                                  ;
 31807                                  ;        input = get_num_input(default_value,max_input,input_row,input_col);
 31808                                  ;
 31809                                  ;        /* SR; 9/26/89; We check here for the extended volume creation case
 31810                                  ;           and remove it from the switch statement */
 31811                                  ;
 31812                                  ;        if (input == '3')
 31813                                  ;           {       /* Create a volume */
 31814                                  ;            if (find_partition_type(uc(EXTENDED)))
 31815                                  ;                volume_create();
 31816                                  ;            else
 31817                                  ;               {
 31818                                  ;                display(error_35);
 31819                                  ;                clear_screen(u(17),u(0),u(17),u(79));
 31820                                  ;                wait_for_ESC();
 31821                                  ;               }
 31822                                  ;           }
 31823                                  ;        else if (find_free_partition() != ((char)(NOT_FOUND)))
 31824                                  ;           {
 31825                                  ;            /* Go branch to the requested function */
 31826                                  ;            switch(input)
 31827                                  ;               BEGIN
 31828                                  ;                case '1':
 31829                                  ;                    dos_create_partition();
 31830                                  ;                    break;
 31831                                  ;
 31832                                  ;            	case '2':
 31833                                  ;                    if ((cur_disk >= c(1)) || (find_partition_type(uc(DOS12))) || (find_partition_type(uc(DOS16))) ||
 31834                                  ;                        (find_partition_type(uc(DOSNEW))))                   /* AN000 */             /* AC000 */
 31835                                  ;                    	ext_create_partition();
 31836                                  ;                    else
 31837                                  ;                       BEGIN                                               /* AN000 */
 31838                                  ;                    	/* don't have a primary partition yet, can't create an ext */
 31839                                  ;                    	display(error_19);                                  /* AN000 */
 31840                                  ;                    	clear_screen(u(17),u(0),u(17),u(79));               /* AN000 */
 31841                                  ;                    	wait_for_ESC();                                     /* AN000 */
 31842                                  ;                       END                                                 /* AN000 */
 31843                                  ;                    break;
 31844                                  ;
 31845                                  ;                case ESC:
 31846                                  ;                    break;
 31847                                  ;
 31848                                  ;                default:
 31849                                  ;                    internal_program_error();
 31850                                  ;                    break;
 31851                                  ;
 31852                                  ;               END
 31853                                  ;           }
 31854                                  ;        else
 31855                                  ;           {
 31856                                  ;            /* Display prompt telling there is no avail partition */
 31857                                  ;            display(error_10);
 31858                                  ;            input = wait_for_ESC();
 31859                                  ;           }
 31860                                  ;    /* clear the screen before going back to main menu */
 31861                                  ;    clear_screen(u(0),u(0),u(24),u(79));                               /* AC000 */
 31862                                  ;    return;
 31863                                  ;END
 31864                                  
 31865                                  create_partition:
 31866                                  		; 13/01/2019
 31867                                  
 31868                                  		;push	bp
 31869                                  		;mov	bp,sp
 31870                                  		;sub	sp,6
 31871                                  
 31872                                  		;mov	ax,79
 31873                                  		;push	ax
 31874                                  		;mov	ax,24
 31875                                  		;push	ax
 31876                                  		;sub	ax,ax
 31877                                  		;push	ax
 31878                                  		;push	ax
 31879                                  		;call	clear_screen
 31880                                  		;add	sp,8
 31881                                  
 31882 0000483A E821CC                  		call	CLS
 31883                                  
 31884                                  		;/* put up heading and ESC */
 31885                                  		
 31886                                  		;push	word [menu_8_segment]
 31887 0000483D 1E                      		push	ds
 31888 0000483E FF36[F59D]              		push	word [menu_8_offset]
 31889 00004842 E8D5CD                  		call	display
 31890                                  		;pop	bx
 31891                                  		;pop	bx
 31892                                  
 31893                                  		;push	word [menu_11_segment]
 31894 00004845 1E                      		push	ds
 31895 00004846 FF36[FB9D]              		push	word [menu_11_offset]
 31896 0000484A E8CDCD                  		call	display
 31897                                  		;pop	bx
 31898                                  		;pop	bx
 31899                                  
 31900                                  		;/* Setup current drive msg */
 31901                                  
 31902 0000484D A0[D4CB]                		mov	al,[cur_disk]
 31903 00004850 0431                    		add	al,'1'
 31904 00004852 A2[E6CC]                		mov	byte [insert],al
 31905                                  		
 31906                                  		;push	word [menu_5_segment]
 31907 00004855 1E                      		push	ds
 31908 00004856 FF36[EF9D]              		push	word [menu_5_offset]
 31909 0000485A E8BDCD                  		call	display
 31910                                  		;pop	bx
 31911                                  		;pop	bx
 31912                                  
 31913                                  		;push	word [menu_3_segment]
 31914 0000485D 1E                      		push	ds
 31915 0000485E FF36[EB9D]              		push	word [menu_3_offset]
 31916 00004862 E8B5CD                  		call	display
 31917                                  		;pop	bx
 31918                                  		;pop	bx
 31919                                  		
 31920                                  		;push	word [menu_9_segment]
 31921 00004865 1E                      		push	ds
 31922 00004866 FF36[F79D]              		push	word [menu_9_offset]
 31923 0000486A E8ADCD                  		call	display
 31924                                  		;pop	bx
 31925                                  		;pop	bx
 31926                                  
 31927                                  		;/* setup default for prompt */
 31928                                  
 31929 0000486D C606[E6CC]31            		mov	byte [insert],'1'
 31930                                  		
 31931                                  		;push	word [menu_7_segment]
 31932 00004872 1E                      		push	ds
 31933 00004873 FF36[F39D]              		push	word [menu_7_offset]
 31934 00004877 E8A0CD                  		call	display
 31935                                  		;pop	bx
 31936                                  		;pop	bx
 31937                                  
 31938                                  		;push	word [menu_10_segment]
 31939 0000487A 1E                      		push	ds
 31940 0000487B FF36[F99D]              		push	word [menu_10_offset]
 31941 0000487F E898CD                  		call	display
 31942                                  		;pop	bx
 31943                                  		;pop	bx
 31944                                  
 31945                                  	;input = get_num_input(default_value,max_input,input_row,input_col);
 31946                                  
 31947 00004882 FF36[9CA0]              		push	word [input_col]
 31948 00004886 FF36[3EA1]              		push	word [input_row]
 31949 0000488A B003                    		mov	al,3
 31950 0000488C 50                      		push	ax
 31951 0000488D B001                    		mov	al,1
 31952 0000488F 50                      		push	ax
 31953 00004890 E8D7E1                  		call	get_num_input
 31954                                  		;add	sp,8
 31955                                  		;mov	[cp_input],al
 31956                                  		
 31957 00004893 A2[10D0]                		mov	[_input],al
 31958                                  
 31959                                  		;if (input == '3')
 31960                                  
 31961 00004896 3C33                    		cmp	al,'3'
 31962 00004898 7513                    		jne	short cp_2
 31963                                  
 31964                                  		;/* Create a volume */
 31965                                  
 31966 0000489A B005                    		mov	al,5 ; EXTENDED
 31967                                  		;push	ax
 31968 0000489C E81BD5                  		call	find_partition_type
 31969                                  		;pop	bx
 31970                                  		;or	al, al
 31971                                  		;jz	short cp_1
 31972 0000489F 7205                    		jc	short cp_1		
 31973                                  
 31974 000048A1 E8AC05                  		call	volume_create
 31975 000048A4 EB6E                    		jmp	case_crea_part_break
 31976                                  cp_1:
 31977                                  		;push	word [error_35_seg]
 31978 000048A6 1E                      		push	ds
 31979 000048A7 FF36[B69E]              		push	word [error_35_off]
 31980 000048AB EB48                    		jmp	short cp_9
 31981                                  
 31982                                  	;else if (find_free_partition() != ((char)(NOT_FOUND)))
 31983                                  cp_2:
 31984 000048AD E8740E                  		call	find_free_partition
 31985 000048B0 FEC0                    		inc	al
 31986 000048B2 7455                    		jz	short cp_10 ; NOT FOUND
 31987                                  
 31988                                  		;/* Go branch to the requested function */
 31989                                  switch_input7:
 31990                                  		;mov	al,[cp_input]
 31991 000048B4 A0[10D0]                		mov	al,[_input]
 31992                                  		;cbw
 31993                                  		;cmp	ax,'2'
 31994 000048B7 3C32                    		cmp	al,'2'
 31995 000048B9 7414                    		je	short case_crea_part_2 ; Create EXTENDED DOS partition
 31996 000048BB 7708                    		ja	short case_crea_part_DEF
 31997                                  
 31998 000048BD 2C1B                    		sub	al,1Bh ; ESC
 31999 000048BF 7453                    		jz	short case_crea_part_break ; ESCape key
 32000                                  
 32001 000048C1 2C16                    		sub	al,16h ; '1'
 32002 000048C3 7405                    		jz	short case_crea_part_1 ; Create primary DOS partition
 32003                                  case_crea_part_DEF:
 32004 000048C5 E849EA                  		call	internal_program_error
 32005 000048C8 EB4A                    		jmp	short case_crea_part_break
 32006                                  case_crea_part_1:
 32007 000048CA E84A00                  		call	dos_create_partition
 32008 000048CD EB45                    		jmp	short case_crea_part_break
 32009                                  case_crea_part_2:
 32010                                  cp_6:  ; 25/01/2019
 32011 000048CF 803E[D4CB]01            		cmp	byte [cur_disk],1
 32012                                  		;jge	short cp_7
 32013 000048D4 7315                    		jnb	short cp_7
 32014                                  		
 32015 000048D6 B001                    		mov	al,1 ; DOS12  ; FAT 12
 32016                                  		;push	ax
 32017 000048D8 E8DFD4                  		call	find_partition_type
 32018                                  		;pop	bx
 32019                                  		;or	al,al
 32020                                  		;jnz	short cp_7
 32021 000048DB 730E                    		jnc	short cp_7		
 32022                                  
 32023 000048DD B004                    		mov	al,4 ; DOS16  ; FAT 16
 32024                                  		;push	ax
 32025 000048DF E8D8D4                  		call	find_partition_type
 32026                                  		;pop	bx
 32027                                  		;or	al,al
 32028                                  		;jnz	short cp_7
 32029 000048E2 7307                    		jnc	short cp_7		
 32030                                   
 32031 000048E4 B006                    		mov	al,6 ; DOSNEW  ; FAT 16 big
 32032                                  		;push	ax
 32033 000048E6 E8D1D4                  		call	find_partition_type
 32034                                  		;pop	bx
 32035                                  		;or	al, al
 32036                                  		;jz	short cp_8
 32037 000048E9 7205                    		jc	short cp_8
 32038                                  cp_7:
 32039 000048EB E89C03                  		call	ext_create_partition
 32040 000048EE EB24                    		jmp	short case_crea_part_break
 32041                                  cp_8:
 32042                                  	;/* don't have a primary partition yet, can't create an ext */	
 32043                                  		;push	word [error_19_seg]
 32044 000048F0 1E                      		push	ds
 32045 000048F1 FF36[969E]              		push	word [error_19_off]
 32046                                  cp_9:
 32047 000048F5 E822CD                  		call	display
 32048                                  		;pop	bx
 32049                                  		;pop	bx
 32050                                  
 32051 000048F8 B84F00                  		mov	ax,79
 32052 000048FB 50                      		push	ax
 32053 000048FC B81100                  		mov	ax,17
 32054 000048FF 50                      		push	ax
 32055 00004900 29C9                    		sub	cx,cx
 32056 00004902 51                      		push	cx
 32057 00004903 50                      		push	ax
 32058 00004904 E88FCB                  		call	clear_screen
 32059                                  		;add	sp,8
 32060                                  
 32061 00004907 EB08                    		jmp	short cp_11
 32062                                  cp_10:
 32063                                  	;/* Display prompt telling there is no avail partition */
 32064                                  
 32065                                  		;push	word [error_10_seg]
 32066 00004909 1E                      		push	ds
 32067 0000490A FF36[889E]              		push	word [error_10_off]
 32068 0000490E E809CD                  		call	display
 32069                                  		;pop	bx
 32070                                  		;pop	bx
 32071                                  cp_11:
 32072 00004911 E856E8                  		call	wait_for_ESC
 32073                                  
 32074                                  case_crea_part_break:
 32075                                  	;/* clear the screen before going back to main menu */
 32076                                  
 32077                                  		;mov	ax,79
 32078                                  		;push	ax
 32079                                  		;mov	ax,24
 32080                                  		;push	ax
 32081                                  		;sub	ax,ax
 32082                                  		;push	ax
 32083                                  		;push	ax
 32084                                  		;call	clear_screen
 32085                                  
 32086                                  		;call	CLS
 32087                                  
 32088                                  		;mov	sp,bp
 32089                                  		;pop	bp
 32090                                  		;retn
 32091                                  
 32092 00004914 E947CB                  		jmp	CLS
 32093                                  
 32094                                  ;/***************************************************************************************************/
 32095                                  ;/*  Screen for DOS_CREATE_PARTITION                                                                */
 32096                                  ;/*                                                                                                 */
 32097                                  ;/*     |00000000001111111111222222222233333333334444444444555555555566666666667777777777|          */
 32098                                  ;/*     |01234567890123456789012345678901234567890123456789012345678901234567890123456789|          */
 32099                                  ;/*   --|--------------------------------------------------------------------------------|          */
 32100                                  ;/*   00|                                                                                |          */
 32101                                  ;/*   01|                                                                                |          */
 32102                                  ;/*   02|                                                                                |          */
 32103                                  ;/*   03|                                                                                |          */
 32104                                  ;/*   04|                           Create Primary DOS Partition                         |menu_12   */
 32105                                  ;/*   05|                                                                                |          */
 32106                                  ;/*   06|    Current fixed disk drive: #                                                 |menu_5 #  */
 32107                                  ;/*   07|                                                                                |          */
 32108                                  ;/*   08|    Do you wish to use the maximum available size for a Primary DOS Partition   |menu_13   */
 32109                                  ;/*   09|    and make the partition active (Y/N).....................? [Y]               |menu_13   */
 32110                                  ;/*   10|                                                                                |          */
 32111                                  ;/*   11|                                                                                |          */
 32112                                  ;/*   12|                                                                                |          */
 32113                                  ;/*   13|                                                                                |          */
 32114                                  ;/*   14|                                                                                |          */
 32115                                  ;/*   15|                                                                                |          */
 32116                                  ;/*   16|                                                                                |          */
 32117                                  ;/*   17|                                                                                |          */
 32118                                  ;/*   18|                                                                                |          */
 32119                                  ;/*   19|                                                                                |          */
 32120                                  ;/*   20|                                                                                |          */
 32121                                  ;/*   21|                                                                                |          */
 32122                                  ;/*   22|                                                                                |          */
 32123                                  ;/*   23|                                                                                |          */
 32124                                  ;/*   24|    Press ESC to return to FDISK Options                                        |menu_11   */
 32125                                  ;/*   ------------------------------------------------------------------------------------          */
 32126                                  ;/*                                                                                                 */
 32127                                  ;/***************************************************************************************************/
 32128                                  
 32129                                  ; c_menus.c (MSDOS 6.0)
 32130                                  ;/*  */
 32131                                  ;/******************* START OF SPECIFICATIONS *******************/
 32132                                  ;/*                                                             */
 32133                                  ;/* SUBROUTINE NAME: DOS_CREATE_PARTITION                       */
 32134                                  ;/*                                                             */
 32135                                  ;/* DESCRIPTIVE NAME: Create default DOS partition on disk      */
 32136                                  ;/*                                                             */
 32137                                  ;/* FUNCTION: User is prompted to see if he wishes to use to    */
 32138                                  ;/*           set up a DOS partition in the maximum available   */
 32139                                  ;/*           size (limited to 32mb). If option is selected     */
 32140                                  ;/*           than partition is created and marked active. The  */
 32141                                  ;/*           partition is scanned to insure there are enough   */
 32142                                  ;/*           contiguous good sectors for DOS.                  */
 32143                                  ;/*                                                             */
 32144                                  ;/* NOTES: Screen can be exited via the ESC command before      */
 32145                                  ;/*        partition is created and nothing will change         */
 32146                                  ;/*                                                             */
 32147                                  ;/*        The following screen is managed:                     */
 32148                                  ;/*                                                             */
 32149                                  ;/*       |0000000000111111111122222222223333333333|            */
 32150                                  ;/*       |0123456789012345678901234567890123456789|            */
 32151                                  ;/*     --|----------------------------------------|            */
 32152                                  ;/*     00|                                        |            */
 32153                                  ;/*     01|                                        |            */
 32154                                  ;/*     02|                                        |            */
 32155                                  ;/*     03|                                        |            */
 32156                                  ;/*     04|Create DOS Partition                    |            */
 32157                                  ;/*     05|                                        |            */
 32158                                  ;/*     06|Current Fixed Disk Drive: #             |            */
 32159                                  ;/*     07|                                        |            */
 32160                                  ;/*     08|Do you wish to use the maximum size     |            */
 32161                                  ;/*     09|for a DOS partition and make the DOS    |            */
 32162                                  ;/*     10|partition active (Y/N).........? [Y]    |            */
 32163                                  ;/*     11|                                        |            */
 32164                                  ;/*     12|                                        |            */
 32165                                  ;/*     13|                                        |            */
 32166                                  ;/*     14|                                        |            */
 32167                                  ;/*     15|                                        |            */
 32168                                  ;/*     16|                                        |            */
 32169                                  ;/*     17|                                        |            */
 32170                                  ;/*     18|                                        |            */
 32171                                  ;/*     19|                                        |            */
 32172                                  ;/*     20|                                        |            */
 32173                                  ;/*     21|                                        |            */
 32174                                  ;/*     22|                                        |            */
 32175                                  ;/*     23|Press ESC to return to FDISK Options    |            */
 32176                                  ;/*     --------------------------------------------            */
 32177                                  ;/*                                                             */
 32178                                  ;/* ENTRY POINTS: dos_create_partition                          */
 32179                                  ;/*      LINKAGE: dos_create_partition();                       */
 32180                                  ;/*               NEAR CALL                                     */
 32181                                  ;/*                                                             */
 32182                                  ;/* INPUT: None                                                 */
 32183                                  ;/*                                                             */
 32184                                  ;/* EXIT-NORMAL: ERROR=FALSE                                    */
 32185                                  ;/*                                                             */
 32186                                  ;/* EXIT-ERROR: ERROR=TRUE                                      */
 32187                                  ;/*             GOTO internal_program_error if case statement   */
 32188                                  ;/*             failure when branching to requested function    */
 32189                                  ;/*                                                             */
 32190                                  ;/* EFFECTS: No data directly modified by this routine, but     */
 32191                                  ;/*          child routines will modify data.                   */
 32192                                  ;/*                                                             */
 32193                                  ;/* INTERNAL REFERENCES:                                        */
 32194                                  ;/*   ROUTINES:                                                 */
 32195                                  ;/*      clear_screen                                           */
 32196                                  ;/*      display                                                */
 32197                                  ;/*      get_yn_input                                           */
 32198                                  ;/*      wait_for_ESC                                           */
 32199                                  ;/*      input_dos_create                                       */
 32200                                  ;/*      make_partition                                         */
 32201                                  ;/*      check_bad_tracks                                       */
 32202                                  ;/*                                                             */
 32203                                  ;/*                                                             */
 32204                                  ;/* EXTERNAL REFERENCES:                                        */
 32205                                  ;/*   ROUTINES:                                                 */
 32206                                  ;/*                                                             */
 32207                                  ;/******************** END OF SPECIFICATIONS ********************/
 32208                                  
 32209                                  ;/*  */
 32210                                  ;void dos_create_partition()
 32211                                  ;
 32212                                  ;BEGIN
 32213                                  ;
 32214                                  ;    char   input;
 32215                                  ;    char   temp;
 32216                                  ;    char   second_disk_flag;                                            /* AN000 */
 32217                                  ;
 32218                                  ;    /* SR; 9/26/89; These variables are added for the various fixes */
 32219                                  ;
 32220                                  ;    unsigned long total_sectors;
 32221                                  ;    unsigned char  i;
 32222                                  ;    char  defined_drives;
 32223                                  ;    char  temp_cur_disk;
 32224                                  ;
 32225                                  ;    second_disk_flag = (FLAG)FALSE;                                     /* AN000 */
 32226                                  ;    input = c(NUL);                                                     /* AC000 */
 32227                                  ;    /* clear off screen */
 32228                                  ;    clear_screen(u(0),u(0),u(24),u(79));                                /* AC000 */
 32229                                  ;
 32230                                  ;    /* Put up header */
 32231                                  ;    display(menu_12);
 32232                                  ;
 32233                                  ;    /* Set up current disk message */
 32234                                  ;    insert[0] = cur_disk+1+'0';
 32235                                  ;    display(menu_5);
 32236                                  ;
 32237                                  ;    /* Display ESC prompt */
 32238                                  ;    display(menu_11);
 32239                                  ;
 32240                                  ;    /* See if already exists */
 32241                                  ;    if ((!find_partition_type(uc(DOS12))) && (!find_partition_type(uc(DOS16))) && (!find_partition_type(uc(DOSNEW))))  /* AC000 */
 32242                                  ;
 32243                                  ;       BEGIN
 32244                                  ;
 32245                                  ;        /* SR; 9/26/89; Ported from Olivetti fix. The min. no. of sectors
 32246                                  ;           in a partition must be >64 for BIOS to recognize the drive */
 32247                                  ;
 32248                                  ;       temp = find_part_free_space(c(PRIMARY));
 32249                                  ;       total_sectors = (long)free_space[temp].space * max_sector[cur_disk] * max_head[cur_disk];
 32250                                  ;       if (total_sectors < 64)
 32251                                  ;          {
 32252                                  ;           display(error_10);      /**** No room on disk */
 32253                                  ;           input = wait_for_ESC();
 32254                                  ;           return;  /*C06*/
 32255                                  ;          }
 32256                                  ;        /* SR; 9/26/89; We do not allow creation of a drive on the second
 32257                                  ;           hard disk if there are already 23 drives on the 1st hard disk */
 32258                                  ;        else                   /*C07*/
 32259                                  ;           {
 32260                                  ;            defined_drives = c(0);
 32261                                  ;            temp_cur_disk = cur_disk;
 32262                                  ;
 32263                                  ;            /* Search both drives for defined drives */
 32264                                  ;            for (i = 0; i < number_of_drives; i++)
 32265                                  ;               {
 32266                                  ;                cur_disk = (c(i));
 32267                                  ;
 32268                                  ;                /* See if there is a primary drive letter */
 32269                                  ;                if ((find_partition_type(uc(DOS12))) ||
 32270                                  ;                    (find_partition_type(uc(DOS16))) ||
 32271                                  ;                    (find_partition_type(uc(DOSNEW))))
 32272                                  ;                    defined_drives++;
 32273                                  ;
 32274                                  ;                /* See if extended partition on disk */
 32275                                  ;                if (find_partition_type(uc(EXTENDED)))
 32276                                  ;                    /* Get number of logical drives */
 32277                                  ;                    defined_drives += get_num_logical_dos_drives();
 32278                                  ;               }
 32279                                  ;            /* Restore cur_disk to original */
 32280                                  ;            cur_disk = temp_cur_disk;
 32281                                  ;
 32282                                  ;            /* See if 26 or less drives total */
 32283                                  ;            if (defined_drives > c(23))
 32284                                  ;               /* Reached the maximum */
 32285                                  ;               {
 32286                                  ;                clear_screen(u(16),u(0),u(23),u(79));
 32287                                  ;                display(error_27);
 32288                                  ;                input = wait_for_ESC();
 32289                                  ;                return;
 32290                                  ;               }
 32291                                  ;           }
 32292                                  ;
 32293                                  ;        /* Display prompt, depending on what disk */
 32294                                  ;        if (cur_disk == c(0))                                           /* AC000 */
 32295                                  ;            /* Put up make active partition message */
 32296                                  ;            display(menu_13);
 32297                                  ;        else
 32298                                  ;            BEGIN
 32299                                  ;            /* Second disk, so dont put up prompt mentioning active partition */
 32300                                  ;            second_disk_flag = (FLAG)TRUE;                              /* AN000 */
 32301                                  ;            display(menu_45);                                           /* AC000 */
 32302                                  ;            END
 32303                                  ;        /* Get Y/N input */
 32304                                  ;        input = get_yn_input(c(Yes),input_row,input_col);               /* AC000 AC011 */
 32305                                  ;
 32306                                  ;        /* Go handle input */
 32307                                  ;        switch(input)
 32308                                  ;            BEGIN
 32309                                  ;            case 1:                                                     /* AC000 */
 32310                                  ;                if ( second_disk_flag == (FLAG)FALSE)
 32311                                  ;                    BEGIN
 32312                                  ;                    /* Go get the biggest area left */
 32313                                  ;                    temp = find_part_free_space(c(PRIMARY));            /* AC000 */
 32314                                  ;                    make_partition(free_space[temp].space,temp,uc(ACTIVE),c(PRIMARY)); /* AC000 */
 32315                                  ;                    reboot_flag = (FLAG)TRUE;                           /* AC000 */
 32316                                  ;                    if (number_of_drives == uc(1))                      /* AN000 */
 32317                                  ;                        BEGIN                                           /* AN000 */
 32318                                  ;                        write_info_to_disk();
 32319                                  ;                        reboot_system();                                /* AC000 */
 32320                                  ;                        END                                             /* AN000 */
 32321                                  ;                    clear_screen(u(16),u(0),u(23),u(79));               /* AN000 */
 32322                                  ;
 32323                                  ;                    display(status_12);                                 /* AN000 */
 32324                                  ;                    wait_for_ESC();
 32325                                  ;                    break;
 32326                                  ;                    END
 32327                                  ;                else
 32328                                  ;                    BEGIN                                               /* AN000 */
 32329                                  ;                    /* Go get the biggest area left */                  /* AN000 */
 32330                                  ;                    temp = find_part_free_space(c(PRIMARY));            /* AN000 */
 32331                                  ;                    make_partition(free_space[temp].space,temp,uc(NUL),c(PRIMARY)); /* AN000 */
 32332                                  ;                    reboot_flag = (FLAG)TRUE;                           /* AN000 */
 32333                                  ;                    clear_screen(u(16),u(0),u(23),u(79));               /* AN000 */
 32334                                  ;
 32335                                  ;                    display(status_12);                                 /* AN000 */
 32336                                  ;                    wait_for_ESC();
 32337                                  ;                    break;
 32338                                  ;                    END
 32339                                  ;
 32340                                  ;            case  0:
 32341                                  ;                input_dos_create();                               /* AC000 */
 32342                                  ;                break;
 32343                                  ;
 32344                                  ;            case ESC:
 32345                                  ;                break;   /* take no action */
 32346                                  ;
 32347                                  ;            default:
 32348                                  ;                internal_program_error();
 32349                                  ;            END
 32350                                  ;        END
 32351                                  ;    else
 32352                                  ;        BEGIN
 32353                                  ;        /* Display partition table-it will return if no partitions there */
 32354                                  ;        table_display();
 32355                                  ;
 32356                                  ;        /* Primary partition already exists message */
 32357                                  ;        display(error_8);
 32358                                  ;        wait_for_ESC();
 32359                                  ;        END
 32360                                  ;   return;
 32361                                  ;END
 32362                                  
 32363                                  ; 13/01/2019
 32364                                  struc f
 32365 00000000 <res 00000002>          .space: resw 1
 32366 00000002 <res 00000002>          .start: resw 1
 32367 00000004 <res 00000002>          .end:   resw 1
 32368                                  endstruc
 32369                                  
 32370                                  dos_create_partition:
 32371                                  		; 13/01/2019
 32372                                  
 32373                                  	%define second_disk_flag bp-16
 32374                                  	%define defined_drives	 bp-14
 32375                                  	%define cdp_i		 bp-12
 32376                                  	%define temp_cur_disk	 bp-10
 32377                                  	%define cdp_temp	 bp-8
 32378                                  
 32379 00004917 55                      		push	bp
 32380 00004918 89E5                    		mov	bp,sp
 32381 0000491A 83EC10                  		sub	sp,16
 32382 0000491D 56                      		push	si
 32383 0000491E 28C0                    		sub	al,al
 32384 00004920 8846F0                  		mov	[second_disk_flag],al
 32385                                  
 32386                                  		;/* clear off screen */		
 32387                                  
 32388                                  		;mov	ax,79
 32389                                  		;push	ax
 32390                                  		;mov	ax,24
 32391                                  		;push	ax
 32392                                  		;sub	ax,ax
 32393                                  		;push	ax
 32394                                  		;push	ax
 32395                                  		;call	clear_screen
 32396                                  		;add	sp,8
 32397                                  
 32398 00004923 E838CB                  		call	CLS
 32399                                  
 32400                                  		;/* Put up header */
 32401                                  
 32402                                  		;push	word [menu_12_segment]
 32403 00004926 1E                      		push	ds
 32404 00004927 FF36[FD9D]              		push	word [menu_12_offset]
 32405 0000492B E8ECCC                  		call	display
 32406                                  		;pop	bx
 32407                                  		;pop	bx
 32408                                  
 32409                                  		;/* Set up current disk message */
 32410                                  
 32411 0000492E A0[D4CB]                		mov	al,[cur_disk]
 32412 00004931 0431                    		add	al,'1'
 32413 00004933 A2[E6CC]                		mov	[insert],al
 32414                                  
 32415                                  		;push	word [menu_5_segment]
 32416 00004936 1E                      		push	ds
 32417 00004937 FF36[EF9D]              		push	word [menu_5_offset]
 32418 0000493B E8DCCC                  		call	display
 32419                                  		;pop	bx
 32420                                  		;pop	bx
 32421                                  
 32422                                  		;/* Display ESC prompt */
 32423                                  
 32424                                  		;push	word [menu_11_segment]
 32425 0000493E 1E                      		push	ds
 32426 0000493F FF36[FB9D]              		push	word [menu_11_offset]
 32427 00004943 E8D4CC                  		call	display
 32428                                  		;pop	bx
 32429                                  		;pop	bx
 32430                                  
 32431                                  		;/* See if already exists */
 32432                                  
 32433 00004946 B001                    		mov	al,1 ; DOS12 ; FAT12
 32434                                  		;push	ax
 32435 00004948 E86FD4                  		call	find_partition_type
 32436                                  		;pop	bx
 32437                                  		;or	al,al
 32438                                  		;jnz	short cdp_1
 32439 0000494B 730E                    		jnc	short cdp_1
 32440                                  
 32441 0000494D B004                    		mov	al,4 ; DOS16 ; FAT16
 32442                                  		;push	ax
 32443 0000494F E868D4                  		call	find_partition_type
 32444                                  		;pop	bx
 32445                                  		;or	al,al
 32446                                  		;jnz	short cdp_1
 32447 00004952 7307                    		jnc	short cdp_1
 32448                                  
 32449 00004954 B006                    		mov	al,6 ; DOSNEW ; FAT16 big
 32450                                  		;push	ax
 32451 00004956 E861D4                  		call	find_partition_type
 32452                                  		;pop	bx
 32453                                  		;or	al,al
 32454                                  		;jz	short cdp_2
 32455 00004959 7203                    		jc	short cdp_2
 32456                                  cdp_1:
 32457 0000495B E94A01                  		jmp	cdp_19
 32458                                  cdp_2:
 32459                                  ;	temp = find_part_free_space(c(PRIMARY));
 32460                                  ;       total_sectors = (long)free_space[temp].space * max_sector[cur_disk] * max_head[cur_disk];
 32461                                  
 32462 0000495E 30C0                    		xor	al,al ; 14/01/2019
 32463                                  		;push	ax
 32464 00004960 E83107                  		call	find_part_free_space
 32465                                  		;pop	bx
 32466 00004963 8846F8                  		mov	[cdp_temp],al
 32467                                  
 32468 00004966 A0[D4CB]                		mov	al,[cur_disk]
 32469 00004969 98                      		cbw
 32470 0000496A 89C3                    		mov	bx,ax
 32471 0000496C 8A87[A0A0]              		mov	al,[max_sector+bx]
 32472 00004970 28E4                    		sub	ah,ah
 32473 00004972 29D2                    		sub	dx,dx
 32474 00004974 52                      		push	dx  ; multiplier_hw	
 32475 00004975 50                      		push	ax  ; multiplier_lw
 32476                                  		;mov	al,22
 32477 00004976 B00A                    		mov	al,10 ; 14/01/2019
 32478                                  		;imul	byte [cdp_temp]
 32479 00004978 F666F8                  		mul	byte [cdp_temp]
 32480 0000497B 89C6                    		mov	si,ax
 32481 0000497D 8B84[E2CB]              		mov	ax,[free_space.space+si]
 32482 00004981 D1E3                    		shl	bx,1
 32483 00004983 F7A7[A8A0]              		mul	word [max_head+bx]
 32484 00004987 52                      		push	dx ; multiplicand_hw
 32485 00004988 50                      		push	ax ; multiplicand_lw
 32486 00004989 E845CC                  		call	mul32
 32487                                  			; DX:AX =  Total (available partition) sectors (of free space)
 32488                                  
 32489                                  		; if (total_sectors < 64)
 32490                                  
 32491 0000498C 09D2                    		or	dx,dx
 32492 0000498E 750D                    		jnz	short cdp_3
 32493                                  
 32494 00004990 83F840                  		cmp	ax,64
 32495 00004993 7308                    		jnb	short cdp_3
 32496                                  
 32497                                  		;/**** No room on disk */
 32498                                  
 32499                                  		;push	word [error_10_seg]
 32500 00004995 1E                      		push	ds
 32501 00004996 FF36[889E]              		push	word [error_10_off]
 32502 0000499A E91301                  		jmp	cdp_20
 32503                                  cdp_3:
 32504 0000499D C646F200                		mov	byte [defined_drives],0
 32505 000049A1 A0[D4CB]                		mov	al,[cur_disk]
 32506 000049A4 8846F6                  		mov	[temp_cur_disk],al
 32507 000049A7 C646F400                		mov	byte [cdp_i],0
 32508 000049AB EB2E                    		jmp	short cdp_8
 32509                                  cdp_4:
 32510                                  		;/* See if there is a primary drive letter */
 32511                                  
 32512 000049AD 8A46F4                  		mov	al,[cdp_i]
 32513 000049B0 A2[D4CB]                		mov	[cur_disk],al
 32514 000049B3 B001                    		mov	al,1 ; DOS12
 32515                                  		;push	ax
 32516 000049B5 E802D4                  		call	find_partition_type
 32517                                  		;pop	bx
 32518                                  		;or	al, al
 32519                                  		;jnz	short cdp_5
 32520 000049B8 730E                    		jnc	short cdp_5
 32521                                  
 32522 000049BA B004                    		mov	al, 4 ; DOS16
 32523                                  		;push	ax
 32524 000049BC E8FBD3                  		call	find_partition_type
 32525                                  		;pop	bx
 32526                                  		;or	al, al
 32527                                  		;jnz	short cdp_5
 32528 000049BF 7307                    		jnc	short cdp_5
 32529                                  		
 32530 000049C1 B006                    		mov	al,6
 32531                                  		;push	ax
 32532 000049C3 E8F4D3                  		call	find_partition_type
 32533                                  		;pop	bx
 32534                                  		;or	al, al
 32535                                  		;jz	short cdp_6
 32536 000049C6 7203                    		jc	short cdp_6
 32537                                  cdp_5:
 32538 000049C8 FE46F2                  		inc	byte [defined_drives]
 32539                                  cdp_6:
 32540                                  		; /* See if extended partition on disk */
 32541                                  
 32542 000049CB B005                    		mov	al,5 ; EXTENDED
 32543                                  		;push	ax
 32544 000049CD E8EAD3                  		call	find_partition_type
 32545                                  		;pop	bx
 32546                                  		;or	al, al
 32547                                  		;jz	short cdp_7
 32548 000049D0 7206                    		jc	short cdp_7
 32549                                  
 32550 000049D2 E839FE                  		call	get_num_logical_dos_drives
 32551 000049D5 0046F2                  		add	[defined_drives],al
 32552                                  cdp_7:
 32553 000049D8 FE46F4                  		inc	byte [cdp_i]
 32554                                  cdp_8:
 32555                                  		;/* Search both drives for defined drives */
 32556                                  
 32557 000049DB A0[D5C3]                		mov	al,[number_of_drives]
 32558 000049DE 3846F4                  		cmp	[cdp_i],al
 32559 000049E1 72CA                    		jb	short cdp_4
 32560                                  
 32561                                  		;/* Restore cur_disk  to original */
 32562                                  
 32563 000049E3 8A46F6                  		mov	al,[temp_cur_disk]
 32564 000049E6 A2[D4CB]                		mov	[cur_disk],al
 32565                                  
 32566                                  	; We do not allow creation of a drive on the second
 32567                                  	; hard disk if there are already 23 drives on the 1st hard disk */
 32568                                  
 32569                                    		;/* See if 26 or less drives total */
 32570                                              	; if (defined_drives > c(23))
 32571                                  
 32572 000049E9 807EF217                		cmp	byte [defined_drives],23
 32573 000049ED 7E1A                    		jle	short cdp_9
 32574                                  
 32575                                  		;/* Reached the maximum */
 32576                                  
 32577 000049EF B84F00                  		mov	ax,79
 32578 000049F2 50                      		push	ax
 32579 000049F3 B81700                  		mov	ax,23
 32580 000049F6 50                      		push	ax
 32581 000049F7 29C0                    		sub	ax,ax
 32582 000049F9 50                      		push	ax
 32583 000049FA B81000                  		mov	ax,16
 32584 000049FD 50                      		push	ax
 32585 000049FE E895CA                  		call	clear_screen
 32586                                  		;add	sp,8
 32587                                  
 32588                                  		;push	word [error_27_seg]
 32589 00004A01 1E                      		push	ds
 32590 00004A02 FF36[A69E]              		push	word [error_27_off]
 32591 00004A06 E9A700                  		jmp	cdp_20
 32592                                  cdp_9:
 32593                                  		;/* Display prompt, depending on what disk */
 32594                                  
 32595 00004A09 803E[D4CB]00            		cmp	byte [cur_disk],0
 32596 00004A0E 7507                    		jne	short cdp_10
 32597                                  		;push	word [menu_13_segment]
 32598 00004A10 1E                      		push	ds
 32599 00004A11 FF36[FF9D]              		push	word [menu_13_offset]
 32600 00004A15 EB09                    		jmp	short cdp_11
 32601                                  cdp_10:
 32602                                  		; /* Second disk, so dont put up prompt mentioning active partition */
 32603                                  
 32604 00004A17 C646F001                		mov	byte [second_disk_flag],1
 32605                                  		;push	word [menu_45_segment]
 32606 00004A1B 1E                      		push	ds
 32607 00004A1C FF36[019E]              		push	word [menu_45_offset]
 32608                                  cdp_11:
 32609 00004A20 E8F7CB                  		call	display
 32610                                  		;pop	bx
 32611                                  		;pop	bx
 32612                                  
 32613                                  		;/* Get Y/N input */
 32614                                   	; input = get_yn_input(c(Yes),input_row,input_col); 
 32615                                  
 32616 00004A23 FF36[9CA0]              		push	word [input_col]
 32617 00004A27 FF36[3EA1]              		push	word [input_row]
 32618 00004A2B A0[CBC3]                		mov	al,[Yes]
 32619 00004A2E 50                      		push	ax
 32620 00004A2F E812E6                  		call	get_yn_input
 32621                                  		;add	sp,6
 32622                                  switch_input8:
 32623                                  		;/* Go handle input */
 32624                                  
 32625                                  		;cbw
 32626                                  		;cmp	ax,1Bh
 32627 00004A32 3C1B                    		cmp	al,1Bh ; ESCape key
 32628 00004A34 7502                    		jne	short cdp_13
 32629 00004A36 EB7E                    		jmp	case_dos_create_break  ; /* take no action */
 32630                                  cdp_13:
 32631 00004A38 770A                    		ja	short case_dos_create_DEF
 32632 00004A3A 08C0                    		or	al,al
 32633 00004A3C 7502                    		jnz	short cdp_14 ; 'Y'es or invalid
 32634 00004A3E EB63                    		jmp	case_dos_create_0 ; 'N'o
 32635                                  cdp_14:
 32636 00004A40 FEC8                    		dec	al
 32637 00004A42 7405                    		jz	short case_dos_create_1 ; 'Y'es
 32638                                  case_dos_create_DEF:
 32639 00004A44 E8CAE8                  		call	internal_program_error
 32640 00004A47 EB6D                    		jmp	case_dos_create_break
 32641                                  case_dos_create_1:
 32642                                  		; /* Go get the biggest area left */
 32643                                  
 32644 00004A49 28C0                    		sub	al,al
 32645                                  		;push	ax
 32646 00004A4B E84606                  		call	find_part_free_space
 32647                                  		;pop	bx
 32648                                  		;mov	[cdp_temp],al
 32649 00004A4E 88C2                    		mov	dl,al
 32650                                  		
 32651 00004A50 28C0                    		sub	al,al   ; PRIMARY
 32652 00004A52 50                      		push	ax	; mp_type (byte) - PRIMARY -
 32653                                  
 32654                                  		;mov	al,[cdp_temp]
 32655                                  		;mov	dl,al		
 32656                                  		;mov	cl,22
 32657 00004A53 B10A                    		mov	cl,10 ; 14/01/2019
 32658 00004A55 F6E1                    		mul	cl
 32659 00004A57 89C3                    		mov	bx,ax
 32660 00004A59 8B8F[E2CB]              		mov	cx,[free_space.space+bx]
 32661                                  
 32662 00004A5D 807EF000                		cmp	byte [second_disk_flag],0
 32663 00004A61 751C                    		jne	short cdp_17
 32664                                  
 32665                                  		;sub	al,al
 32666                                  		;push	ax
 32667                                  		;call	find_part_free_space
 32668                                  		;pop	bx
 32669                                  		;mov	[cdp_temp],al
 32670                                  		;sub	al,al
 32671                                  		;push	ax
 32672                                  
 32673 00004A63 B080                    		mov	al,80h  ; BOOTABLE
 32674 00004A65 50                      		push	ax	; mp_bootable (byte) - BOOTABLE -
 32675                                  
 32676                                  		;mov	al,[cdp_temp]
 32677                                  		;push	ax
 32678                                  		;mov	cl,22
 32679                                  		;imul	cl
 32680                                  		;mov	bx,ax
 32681                                  		;push	word [free_space.space+bx]
 32682                                  
 32683 00004A66 52                      		push	dx  ; dl = [cdp_temp]  ; mp_free_ptr (byte)
 32684 00004A67 51                      		push	cx  ; cx = [free_space.space+bx] ; mp_size (word)			
 32685                                  
 32686 00004A68 E8DB0A                  		call	make_partition
 32687                                  		;add	sp,8
 32688                                  
 32689 00004A6B C606[6AA0]01            		mov	byte [reboot_flag],1
 32690 00004A70 803E[D5C3]01            		cmp	byte [number_of_drives],1
 32691 00004A75 7513                    		jne	short cdp_18
 32692 00004A77 E847EC                  		call	write_info_to_disk
 32693 00004A7A E85EEB                  		call	reboot_system
 32694 00004A7D EB0B                    		jmp	short cdp_18
 32695                                  cdp_17:
 32696                                  		;sub	al,al
 32697                                  		;push	ax
 32698                                  		;call	find_part_free_space
 32699                                  		;pop	bx
 32700                                  		;mov	[cdp_temp],al
 32701                                  		;sub	al,al
 32702                                  		;push	ax
 32703                                  
 32704 00004A7F 50                      		push	ax  ; al = 0 ; mp_bootable - not bootable -
 32705                                   		
 32706                                  		;mov	al,[cdp_temp]
 32707                                  		;push	ax
 32708                                  		;mov	cl,22
 32709                                  		;imul	cl
 32710                                  		;mov	bx,ax
 32711                                  		;push	word [free_space.space+bx]
 32712                                  
 32713 00004A80 52                      		push	dx  ; dl = [cdp_temp]  ; mp_free_ptr
 32714 00004A81 51                      		push	cx  ; cx = [free_space.space+bx] ; mp_size		
 32715                                  
 32716 00004A82 E8C10A                  		call	make_partition
 32717                                  		;add	sp,8
 32718                                  
 32719 00004A85 C606[6AA0]01            		mov	byte [reboot_flag],1
 32720                                  cdp_18:
 32721 00004A8A B84F00                  		mov	ax,79
 32722 00004A8D 50                      		push	ax
 32723 00004A8E B81700                  		mov	ax,23
 32724 00004A91 50                      		push	ax
 32725 00004A92 29C0                    		sub	ax,ax
 32726 00004A94 50                      		push	ax
 32727 00004A95 B81000                  		mov	ax,16
 32728 00004A98 50                      		push	ax
 32729 00004A99 E8FAC9                  		call	clear_screen
 32730                                  		;add	sp,8
 32731                                  		
 32732                                  		;push	word [status_12_seg]
 32733 00004A9C 1E                      		push	ds
 32734 00004A9D FF36[719E]              		push	word [status_12_off]
 32735 00004AA1 EB0D                    		jmp	short cdp_20
 32736                                  
 32737                                  case_dos_create_0:
 32738 00004AA3 E81500                  		call	input_dos_create
 32739 00004AA6 EB0E                    		jmp	short case_dos_create_break
 32740                                  cdp_19:
 32741                                  	;/* Display partition table - it will return if no partitions there */
 32742                                  
 32743 00004AA8 E8C2E3                  		call	table_display
 32744                                  
 32745                                  		;/* Primary partition already exists message */
 32746                                  
 32747                                  		;push	word [error_8_seg]
 32748 00004AAB 1E                      		push	ds
 32749 00004AAC FF36[849E]              		push	word [error_8_off]
 32750                                  cdp_20:
 32751 00004AB0 E867CB                  		call	display
 32752                                  		;pop	bx
 32753                                  		;pop	bx
 32754                                  
 32755 00004AB3 E8B4E6                  		call	wait_for_ESC
 32756                                  
 32757                                  case_dos_create_break:
 32758 00004AB6 5E                      		pop	si
 32759 00004AB7 89EC                    		mov	sp,bp
 32760 00004AB9 5D                      		pop	bp
 32761 00004ABA C3                      		retn
 32762                                  
 32763                                  ; fdisk.msg (MSDOS 6.0)
 32764                                  ;/***************************************************************************************************/
 32765                                  ;/*  Screen for INPUT_DOS_CREATE                                                                    */
 32766                                  ;/*                                                                                                 */
 32767                                  ;/*     |00000000001111111111222222222233333333334444444444555555555566666666667777777777|          */
 32768                                  ;/*     |01234567890123456789012345678901234567890123456789012345678901234567890123456789|          */
 32769                                  ;/*   --|--------------------------------------------------------------------------------|          */
 32770                                  ;/*   00|                                                                                |          */
 32771                                  ;/*   01|                                                                                |          */
 32772                                  ;/*   02|                                                                                |          */
 32773                                  ;/*   03|                                                                                |          */
 32774                                  ;/*   04|                           Create Primary DOS Partition                         |menu_12 # */
 32775                                  ;/*   05|                                                                                |          */
 32776                                  ;/*   06|    Current fixed disk drive: #                                                 |menu_5 #  */
 32777                                  ;/*   07|                                                                                |          */
 32778                                  ;/*   08|    Partition Status   Type    Size in Mbytes   Percentage of Disk Used         |menu_14   */
 32779                                  ;/*   09|     ## #        #    #######       ####        ###%                            |          */
 32780                                  ;/*   10|     ## #        #    #######       ####        ###%                            |          */
 32781                                  ;/*   11|     ## #        #    #######       ####        ###%                            |          */
 32782                                  ;/*   12|     ## #        #    #######       ####        ###%                            |          */
 32783                                  ;/*   13|                                                                                |          */
 32784                                  ;/*   14|    Total disk space is #### Mbytes (1 Mbyte = 1048576 bytes)                   |menu_15   */
 32785                                  ;/*   15|    Maximum space available for partition is #### Mbytes (###%)                 |menu_16   */
 32786                                  ;/*   16|                                                                                |          */
 32787                                  ;/*   17|                                                                                |          */
 32788                                  ;/*   18|    Enter partition size in Mbytes or percent of disk space (%) to              |menu_39   */
 32789                                  ;/*   19|    create a Primary DOS Partition..................................[####]      |          */
 32790                                  ;/*   20|                                                                                |          */
 32791                                  ;/*   21|                                                                                |          */
 32792                                  ;/*   22|                                                                                |          */
 32793                                  ;/*   23|                                                                                |          */
 32794                                  ;/*   24|    Press ESC to return to FDISK Options                                        |menu_11   */
 32795                                  ;/*   ------------------------------------------------------------------------------------          */ 
 32796                                  ;/*                                                                                                 */
 32797                                  ;/***************************************************************************************************/
 32798                                  
 32799                                  ; c_menus.c (MSDOS 6.0)
 32800                                  ;/*  */
 32801                                  ;/******************* START OF SPECIFICATIONS *******************/
 32802                                  ;/*                                                             */
 32803                                  ;/* SUBROUTINE NAME: INPUT_DOS_CREATE                           */
 32804                                  ;/*                                                             */
 32805                                  ;/* DESCRIPTIVE NAME: Create DOS partition on disk              */
 32806                                  ;/*                                                             */
 32807                                  ;/* FUNCTION: Gets user specified size for partition (maximum   */
 32808                                  ;/*           is 32mb or largest contiguous freespace, which-   */
 32809                                  ;/*           ever is smaller). Default is largest avail free   */
 32810                                  ;/*           space. Partition is created to default size,unless*/
 32811                                  ;/*           user enters different size, but is not marked     */
 32812                                  ;/*           active. User specified size must be smaller or    */
 32813                                  ;/*           equal to the default size                         */
 32814                                  ;/*                                                             */
 32815                                  ;/* NOTES: Screen can be exited via the ESC command before      */
 32816                                  ;/*        partition is created and nothing will change         */
 32817                                  ;/*                                                             */
 32818                                  ;/*        The following screen is managed                      */
 32819                                  ;/*                                                             */
 32820                                  ;/*       |0000000000111111111122222222223333333333|            */
 32821                                  ;/*       |0123456789012345678901234567890123456789|            */
 32822                                  ;/*     --|----------------------------------------|            */
 32823                                  ;/*     00|                                        |            */
 32824                                  ;/*     01|                                        |            */
 32825                                  ;/*     02|                                        |            */
 32826                                  ;/*     03|                                        |            */
 32827                                  ;/*     04|Create DOS partition                    |            */
 32828                                  ;/*     05|                                        |            */
 32829                                  ;/*     06|Current Fixed Disk Drive: #             |            */
 32830                                  ;/*     07|                                        |            */
 32831                                  ;/*     08|Partition Status   Type  Start  End Size|            */
 32832                                  ;/*     09|                                        |            */
 32833                                  ;/*     10|                                        |            */
 32834                                  ;/*     11|                                        |            */
 32835                                  ;/*     12|                                        |            */
 32836                                  ;/*     13|                                        |            */
 32837                                  ;/*     14|Total disk space is #### cylinders.     |            */
 32838                                  ;/*     15|Maximum space available for partition   |            */
 32839                                  ;/*     16|is #### cylinders.                      |            */
 32840                                  ;/*     17|                                        |            */
 32841                                  ;/*     18|Enter partition size............: [####]|            */
 32842                                  ;/*     19|                                        |            */
 32843                                  ;/*     20|                                        |            */
 32844                                  ;/*     21|                                        |            */
 32845                                  ;/*     22|                                        |            */
 32846                                  ;/*     23|Press ESC to return to FDISK Options    |            */
 32847                                  ;/*     --------------------------------------------            */
 32848                                  ;/*                                                             */
 32849                                  ;/* ENTRY POINTS: input_dos_create                              */
 32850                                  ;/*      LINKAGE: input_dos_create();                           */
 32851                                  ;/*               NEAR CALL                                     */
 32852                                  ;/*                                                             */
 32853                                  ;/* INPUT: None                                                 */
 32854                                  ;/*                                                             */
 32855                                  ;/* EXIT-NORMAL: ERROR=FALSE                                    */
 32856                                  ;/*                                                             */
 32857                                  ;/* EXIT-ERROR: ERROR=TRUE                                      */
 32858                                  ;/*             GOTO internal_program_error if case statement   */
 32859                                  ;/*             failure when branching to requested function    */
 32860                                  ;/*                                                             */
 32861                                  ;/* EFFECTS: No data directly modified by this routine, but     */
 32862                                  ;/*          child routines will modify data.                   */
 32863                                  ;/*                                                             */
 32864                                  ;/* INTERNAL REFERENCES:                                        */
 32865                                  ;/*   ROUTINES:                                                 */
 32866                                  ;/*      clear_screen                                           */
 32867                                  ;/*      table_display                                          */
 32868                                  ;/*      get_num_input                                          */
 32869                                  ;/*      display                                                */
 32870                                  ;/*      wait_for_ESC                                           */
 32871                                  ;/*      make_partition                                         */
 32872                                  ;/*      check_bad_tracks                                       */
 32873                                  ;/*                                                             */
 32874                                  ;/* EXTERNAL REFERENCES:                                        */
 32875                                  ;/*   ROUTINES:                                                 */
 32876                                  ;/*                                                             */
 32877                                  ;/******************** END OF SPECIFICATIONS ********************/
 32878                                  
 32879                                  ;/*  */
 32880                                  ;void input_dos_create()
 32881                                  ;
 32882                                  ;BEGIN
 32883                                  ;
 32884                                  ;    unsigned  input;
 32885                                  ;    unsigned  default_entry;
 32886                                  ;    char      temp;
 32887                                  ;
 32888                                  ;    input = u(NUL);                                                    /* AC000 */
 32889                                  ;    /* clear off screen */
 32890                                  ;    clear_screen(u(0),u(0),u(24),u(79));                               /* AC000 */
 32891                                  ;
 32892                                  ;    /* Put up heading */
 32893                                  ;    display(menu_12);
 32894                                  ;
 32895                                  ;    /* Setup and print current disk */
 32896                                  ;    insert[0] = cur_disk+1+'0';
 32897                                  ;    display(menu_5);
 32898                                  ;
 32899                                  ;    /* Print ESC prompt */
 32900                                  ;    display(menu_11);
 32901                                  ;
 32902                                  ;    /* Display partition table-it will return if no partitions there */
 32903                                  ;    table_display();
 32904                                  ;
 32905                                  ;    sprintf(insert,"%4.0d",total_mbytes[cur_disk]);
 32906                                  ;    display(menu_15);
 32907                                  ;
 32908                                  ;    /* Get the free space */
 32909                                  ;    temp = find_part_free_space(c(PRIMARY));                           /* AC000 */
 32910                                  ;
 32911                                  ;    /* Is there any ?*/
 32912                                  ;    if (free_space[temp].mbytes_unused != u(0))                        /* AC000 */
 32913                                  ;
 32914                                  ;        BEGIN
 32915                                  ;        /* Display disk space */
 32916                                  ;        sprintf(insert,"%4.0d",total_mbytes[cur_disk]);
 32917                                  ;        display(menu_15);
 32918                                  ;
 32919                                  ;        /* Setup and print max partition size */
 32920                                  ;
 32921                                  ;        sprintf(insert,"%4.0d%3.0d%%",
 32922                                  ;                free_space[temp].mbytes_unused,
 32923                                  ;                free_space[temp].percent_unused);
 32924                                  ;        display(menu_16);
 32925                                  ;
 32926                                  ;        /* Force repeats on the input until something valid (Non-Zero return) */
 32927                                  ;        default_entry = (unsigned)free_space[temp].mbytes_unused;      /* AC000 */
 32928                                  ;        valid_input = (FLAG)FALSE;                                     /* AC000 */
 32929                                  ;
 32930                                  ;        while (!valid_input)
 32931                                  ;
 32932                                  ;            BEGIN
 32933                                  ;            /* Display prompt */
 32934                                  ;            sprintf(insert,"%4.0d",default_entry);
 32935                                  ;            display(menu_39);
 32936                                  ;
 32937                                  ;            input = get_large_num_input(default_entry,free_space[temp].mbytes_unused,free_space[temp].percent_unused,menu_39,u(0),error_13);       /* AC000 */
 32938                                  ;
 32939                                  ;            /* Update default in case of error, so it gets displayed and used */
 32940                                  ;            /* if user presses CR only */
 32941                                  ;
 32942                                  ;            default_entry = input;
 32943                                  ;            clear_screen(u(19),u(0),u(23),u(79));                     /* AC000 */
 32944                                  ;            END
 32945                                  ;
 32946                                  ;        if (input != ((unsigned)(ESC_FLAG)))                          /* AC000 */
 32947                                  ;
 32948                                  ;            BEGIN
 32949                                  ;            /* Change input to cylinders */
 32950                                  ;            /* check to see if input was in percent or mbytes */
 32951                                  ;
 32952                                  ;            if (PercentFlag)                                          /* AN000 */
 32953                                  ;                BEGIN                                                 /* AN000 */
 32954                                  ;                if (input == free_space[temp].percent_unused)
 32955                                  ;                    input = free_space[temp].space;                   /* AN000 */
 32956                                  ;                else                                                  /* AN000 */
 32957                                  ;                    input = percent_to_cylinders(input,total_disk[cur_disk]);
 32958                                  ;                END                                                   /* AN000 */
 32959                                  ;            else                                                      /* AN000 */
 32960                                  ;                BEGIN                                                 /* AN000 */
 32961                                  ;                if (input == free_space[temp].mbytes_unused)
 32962                                  ;                    input = free_space[temp].space;                   /* AN000 */
 32963                                  ;                else                                                  /* AN000 */
 32964                                  ;                    input = (unsigned)mbytes_to_cylinders(input,
 32965                                  ;                                                          cur_disk);  /* AN004 */
 32966                                  ;                END                                                   /* AN000 */
 32967                                  ;
 32968                                  ;            /* Initialize PecentFlag back to FALSE */
 32969                                  ;            PercentFlag = (FLAG)FALSE;                                /* AN000 */
 32970                                  ;
 32971                                  ;            /* SR; 9/26/89; Display error message if input value = 0 */
 32972                                  ;
 32973                                  ;            if (input == 0)
 32974                                  ;               {
 32975                                  ;                display(error_28);
 32976                                  ;                wait_for_ESC();
 32977                                  ;               }
 32978                                  ;            else
 32979                                  ;               {
 32980                                  ;            	/* Go create the partition */
 32981                                  ;            	make_partition(input,temp,uc(NUL),c(PRIMARY));         /* AC000 */
 32982                                  ;
 32983                                  ;            	/* clear off the old prompt */
 32984                                  ;            	clear_screen(u(13),u(0),u(19),u(79));                  /* AC000 */
 32985                                  ;
 32986                                  ;            	/* Reissue the partition info */
 32987                                  ;            	table_display();
 32988                                  ;
 32989                                  ;            	/* display the "okay, we did it" msg */
 32990                                  ;            	if (number_of_drives == uc(1))                         /* AN000 */
 32991                                  ;                	display(status_5);
 32992                                  ;            	else
 32993                                  ;                    BEGIN                                             /* AN000 */
 32994                                  ;                    clear_screen(u(16),u(0),u(23),u(79));             /* AN000 */
 32995                                  ;                    display(status_12);                               /* AN000 */
 32996                                  ;                    END                                               /* AN000 */
 32997                                  ;
 32998                                  ;            	wait_for_ESC();
 32999                                  ;
 33000                                  ;            	reboot_flag = TRUE;
 33001                                  ;               }
 33002                                  ;
 33003                                  ;            END
 33004                                  ;        END
 33005                                  ;    /* SR; 9/26/89; Display error if insufficient space for partition */
 33006                                  ;    else
 33007                                  ;        {
 33008                                  ;        display(error_10);
 33009                                  ;        wait_for_ESC();
 33010                                  ;        }
 33011                                  ;    return;
 33012                                  ;END
 33013                                  
 33014                                  input_dos_create:
 33015                                  		; 14/01/2019
 33016                                  
 33017                                  	%define idc_def_entry	bp-6
 33018                                  	%define	idc_temp	bp-4
 33019                                  	%define idc_input	bp-2
 33020                                  
 33021 00004ABB 55                      		push	bp
 33022 00004ABC 89E5                    		mov	bp,sp
 33023 00004ABE 83EC06                  		sub	sp,6
 33024                                  
 33025                                  		;push	si
 33026                                  
 33027                                  		;/* clear off screen */
 33028                                  		
 33029                                  		;mov	ax,79
 33030                                  		;push	ax
 33031                                  		;mov	ax,24
 33032                                  		;push	ax
 33033                                  		;sub	ax,ax
 33034                                  		;mov	[idc_input],ax
 33035                                  		;push	ax
 33036                                  		;push	ax
 33037                                  		;call	clear_screen
 33038                                  		;add	sp,8
 33039                                  
 33040 00004AC1 E89AC9                  		call	CLS
 33041                                  
 33042 00004AC4 C746FE0000              		mov	word [idc_input],0
 33043                                  
 33044                                  		;/* Put up heading */
 33045                                  
 33046                                  		;push	word [menu_12_segment]
 33047 00004AC9 1E                      		push	ds
 33048 00004ACA FF36[FD9D]              		push	word [menu_12_offset]
 33049 00004ACE E849CB                  		call	display
 33050                                  		;pop	bx
 33051                                  		;pop	bx
 33052                                  
 33053                                  		;/* Setup and print current disk */
 33054                                  
 33055 00004AD1 A0[D4CB]                		mov	al,[cur_disk]
 33056 00004AD4 0431                    		add	al,'1'
 33057 00004AD6 A2[E6CC]                		mov	[insert],al
 33058                                  		;push	word [menu_5_segment]
 33059 00004AD9 1E                      		push	ds
 33060 00004ADA FF36[EF9D]              		push	word [menu_5_offset]
 33061 00004ADE E839CB                  		call	display
 33062                                  		;pop	bx
 33063                                  		;pop	bx
 33064                                  
 33065                                  		;/* Print ESC prompt */
 33066                                  
 33067                                  		;push	word [menu_11_segment]
 33068 00004AE1 1E                      		push	ds
 33069 00004AE2 FF36[FB9D]              		push	word [menu_11_offset]
 33070 00004AE6 E831CB                  		call	display
 33071                                  		;pop	bx
 33072                                  		;pop	bx
 33073                                  
 33074                                  	;/* Display partition table - it will return if no partitions there */
 33075                                  
 33076 00004AE9 E881E3                  		call	table_display
 33077                                  
 33078 00004AEC A0[D4CB]                		mov	al,[cur_disk]
 33079 00004AEF 98                      		cbw
 33080 00004AF0 89C3                    		mov	bx,ax
 33081 00004AF2 D1E3                    		shl	bx,1
 33082 00004AF4 FFB7[C8A0]              		push	word [total_mbytes+bx]
 33083 00004AF8 B8[846F]                		mov	ax,idc_tot_mb_format ; "%4.1d"
 33084 00004AFB 50                      		push	ax
 33085 00004AFC B8[E6CC]                		mov	ax,insert
 33086 00004AFF 50                      		push	ax
 33087 00004B00 E8B8D7                  		call	sprintf
 33088 00004B03 83C406                  		add	sp,6
 33089                                  
 33090                                  		;push	word [menu_15_segment]
 33091 00004B06 1E                      		push	ds
 33092 00004B07 FF36[059E]              		push	word [menu_15_offset]
 33093 00004B0B E80CCB                  		call	display
 33094                                  		;pop	bx
 33095                                  		;pop	bx
 33096                                  
 33097                                  		;/* Get the free space */
 33098                                  
 33099 00004B0E 28C0                    		sub	al,al ; 0
 33100                                  		;push	ax
 33101 00004B10 E88105                  		call	find_part_free_space
 33102                                  		;pop	bx
 33103 00004B13 8846FC                  		mov	[idc_temp],al
 33104                                  
 33105                                  		;mov	cl,22
 33106 00004B16 B10A                    		mov	cl,10 ; 14/01/2019
 33107                                  		;imul	cl
 33108 00004B18 F6E1                    		mul	cl
 33109 00004B1A 89C3                    		mov	bx,ax
 33110                                  
 33111                                  		;/* Is there any ?*/
 33112                                  
 33113 00004B1C 83BF[E8CB]00            		cmp	word [free_space.mbytes_unused+bx],0
 33114 00004B21 7503                    		jne	short idc_1
 33115 00004B23 E95501                  		jmp	idc_12
 33116                                  idc_1:
 33117                                  		; /* Display disk space */
 33118                                  
 33119 00004B26 A0[D4CB]                		mov	al,[cur_disk]
 33120 00004B29 98                      		cbw
 33121 00004B2A 89C6                    		mov	si,ax
 33122 00004B2C D1E6                    		shl	si,1
 33123 00004B2E FFB4[C8A0]              		push	word [total_mbytes+si]
 33124 00004B32 B8[846F]                		mov	ax,idc_tot_mb_format ; "%4.1d"
 33125 00004B35 50                      		push	ax
 33126 00004B36 B8[E6CC]                		mov	ax,insert
 33127 00004B39 50                      		push	ax
 33128 00004B3A 89DE                    		mov	si,bx
 33129 00004B3C E87CD7                  		call	sprintf
 33130 00004B3F 83C406                  		add	sp,6
 33131                                  
 33132                                  		;push	word [menu_15_segment]
 33133 00004B42 1E                      		push	ds
 33134 00004B43 FF36[059E]              		push	word [menu_15_offset]
 33135 00004B47 E8D0CA                  		call	display
 33136                                  		;pop	bx
 33137                                  		;pop	bx
 33138                                  
 33139                                  		;/* Setup and print max partition size */
 33140                                  
 33141 00004B4A FFB4[EACB]              		push	word [free_space.percent_unused+si]
 33142 00004B4E FFB4[E8CB]              		push	word [free_space.mbytes_unused+si]
 33143 00004B52 B8[8A6F]                		mov	ax,idc_mb_pcent_format ; "%4.1d%3.1d%%"
 33144 00004B55 50                      		push	ax
 33145 00004B56 B8[E6CC]                		mov	ax, insert
 33146 00004B59 50                      		push	ax
 33147 00004B5A E85ED7                  		call	sprintf
 33148 00004B5D 83C408                  		add	sp,8
 33149                                  
 33150                                  		;push	word [menu_16_segment]
 33151 00004B60 1E                      		push	ds
 33152 00004B61 FF36[079E]              		push	word [menu_16_offset]
 33153 00004B65 E8B2CA                  		call	display
 33154                                  		;pop	bx
 33155                                  		;pop	bx
 33156                                  
 33157 00004B68 8B84[E8CB]              		mov	ax,[free_space.mbytes_unused+si]
 33158 00004B6C 8946FA                  		mov	[idc_def_entry],ax
 33159 00004B6F C606[DECB]00            		mov	byte  [valid_input],0
 33160                                  idc_2:
 33161                                  		;/* Display prompt */
 33162                                  
 33163 00004B74 FF76FA                  		push	word [idc_def_entry]
 33164 00004B77 B8[846F]                		mov	ax,idc_def_entry_format ; "%4.1d"
 33165 00004B7A 50                      		push	ax
 33166 00004B7B B8[E6CC]                		mov	ax,insert
 33167 00004B7E 50                      		push	ax
 33168 00004B7F E839D7                  		call	sprintf
 33169 00004B82 83C406                  		add	sp,6
 33170                                  
 33171                                  		;push	word [menu_39_segment]
 33172 00004B85 1E                      		push	ds
 33173 00004B86 FF36[099E]              		push	word [menu_39_offset]
 33174 00004B8A E88DCA                  		call	display
 33175                                  		;pop	bx
 33176                                  		;pop	bx
 33177                                  
 33178                                  		;push	word [error_13_seg]   	
 33179 00004B8D 1E                      		push	ds		       ; glni_err_msg_seg	
 33180 00004B8E FF36[8C9E]              		push	word [error_13_off]    ; glni_err_msg
 33181 00004B92 29C0                    		sub	ax,ax
 33182 00004B94 50                      		push	ax		       ; glni_prompt_loc	
 33183                                  		;push	word [menu_39_segment]
 33184 00004B95 1E                      		push	ds		       ; glni_input_msg_seg	
 33185 00004B96 FF36[099E]              		push	word [menu_39_offset]  ; glni_input_msg
 33186                                  		;mov	al,22
 33187 00004B9A B00A                    		mov	al,10 ; 14/01/2019
 33188                                  		;imul	byte [idc_temp]
 33189 00004B9C F666FC                  		mul	byte [idc_temp]
 33190 00004B9F 89C3                    		mov	bx,ax
 33191 00004BA1 FFB7[EACB]              		push	word [free_space.percent_unused+bx] ; glni_max_pc
 33192 00004BA5 FFB7[E8CB]              		push	word [free_space.mbytes_unused+bx]  ; glni_max_num
 33193 00004BA9 FF76FA                  		push	word [idc_def_entry]	; glni_input_def
 33194 00004BAC E8CC07                  		call	get_large_num_input
 33195                                  		;add	sp,16
 33196                                  
 33197                                  	;/* Update default in case of error, so it gets displayed and used */
 33198                                  	;/* if user presses CR only */
 33199                                  
 33200 00004BAF 8946FE                  		mov	[idc_input],ax
 33201 00004BB2 8946FA                  		mov	[idc_def_entry],ax
 33202                                  
 33203 00004BB5 B84F00                  		mov	ax,79
 33204 00004BB8 50                      		push	ax
 33205 00004BB9 B81700                  		mov	ax,23
 33206 00004BBC 50                      		push	ax
 33207 00004BBD 29C0                    		sub	ax,ax
 33208 00004BBF 50                      		push	ax
 33209 00004BC0 B81300                  		mov	ax,19
 33210 00004BC3 50                      		push	ax
 33211 00004BC4 E8CFC8                  		call	clear_screen
 33212                                  		;add	sp,8
 33213                                  
 33214                                  	;/* Force repeats on the input until something valid (Non-Zero return) */
 33215                                  
 33216 00004BC7 803E[DECB]00            		cmp	byte [valid_input],0
 33217 00004BCC 74A6                    		je	short idc_2
 33218                                  
 33219 00004BCE 837EFEFE                		cmp	word [idc_input],0FFFEh ; -2 ; ESC flag?
 33220 00004BD2 7503                    		jne	short idc_3
 33221 00004BD4 E9AF00                  		jmp	idc_14
 33222                                  
 33223                                  idc_3:
 33224                                  		;/* Change input to cylinders */
 33225                                  		;/* check to see if input was in percent or mbytes */
 33226                                  
 33227                                  		;mov	al,22
 33228 00004BD7 B00A                    		mov	al,10 ; 14/01/2019
 33229                                  		;imul	byte [idc_temp]
 33230 00004BD9 F666FC                  		mul	byte [idc_temp]
 33231 00004BDC 89C3                    		mov	bx,ax
 33232 00004BDE 8B46FE                  		mov	ax,[idc_input]
 33233                                  
 33234 00004BE1 803E[D2C3]00            		cmp	byte [PercentFlag],0
 33235 00004BE6 741B                    		je	short idc_6
 33236                                  
 33237                                  		;mov	al,22
 33238                                  		;;imul	byte [idc_temp]
 33239                                  		;mul	byte [idc_temp]
 33240                                  		;mov	bx,ax
 33241                                  		;mov	ax,[idc_input]
 33242                                  
 33243 00004BE8 3987[EACB]              		cmp	[free_space.percent_unused+bx],ax
 33244 00004BEC 7506                    		jne	short idc_5 ; < 100
 33245                                  idc_4:
 33246 00004BEE 8B87[E2CB]              		mov	ax,[free_space.space+bx]
 33247 00004BF2 EB1F                    		jmp	short idc_8
 33248                                  idc_5:
 33249                                  		; 19/01/2019
 33250                                  
 33251                                  		;mov	al,[cur_disk]
 33252                                  		;cbw
 33253                                  		;mov	bx,ax
 33254                                  		;shl	bx,1
 33255                                  		
 33256 00004BF4 8A1E[D4CB]              		mov	bl,[cur_disk]
 33257                                  		;xor	bh,bh ; bh = 0
 33258 00004BF8 D0E3                    		shl	bl,1
 33259                                  
 33260                                  		; ax = [idc_input]  ; percent in
 33261                                  		
 33262                                  		;push	word [total_disk+bx]
 33263 00004BFA 8B8F[B8A0]              		mov	cx,[total_disk+bx] ; total cylinders
 33264                                  		;push	word [idc_input]
 33265                                  		;mov	ax,[idc_input] ; < 100
 33266 00004BFE E8150B                  		call	percent_to_cylinders
 33267 00004C01 EB10                    		jmp	short idc_7
 33268                                  idc_6:
 33269                                  		;mov	al,22
 33270                                  		;imul	byte [idc_temp]
 33271                                  		;mul	byte [idc_temp]
 33272                                  		;mov	bx,ax
 33273                                  		;mov	ax,[idc_input]
 33274                                  
 33275 00004C03 3987[E8CB]              		cmp	[free_space.mbytes_unused+bx],ax
 33276 00004C07 74E5                    		jz	short idc_4
 33277                                  
 33278 00004C09 A0[D4CB]                		mov	al,[cur_disk]
 33279 00004C0C 50                      		push	ax
 33280 00004C0D FF76FE                  		push	word [idc_input]
 33281 00004C10 E8AC0A                  		call	mbytes_to_cylinders
 33282                                  idc_7:
 33283                                  		;pop	bx
 33284                                  		;pop	bx
 33285                                  idc_8:
 33286 00004C13 8946FE                  		mov	[idc_input],ax
 33287                                  
 33288                                  		;/* Initialize PecentFlag back to FALSE */
 33289                                  
 33290 00004C16 C606[D2C3]00            		mov	byte [PercentFlag],0
 33291                                  
 33292                                  		; Display error message if input value = 0 */
 33293                                  
 33294 00004C1B 09C0                    		or	ax,ax
 33295 00004C1D 7507                    		jnz	short idc_9
 33296                                  		
 33297                                  		;push	word [error_28_seg]
 33298 00004C1F 1E                      		push	ds
 33299 00004C20 FF36[A89E]              		push	word [error_28_off]
 33300 00004C24 EB5A                    		jmp	short idc_13
 33301                                  idc_9:
 33302                                  		;/* Go create the partition */
 33303                                  		;make_partition(input,temp,uc(NUL),c(PRIMARY));
 33304                                  
 33305 00004C26 28C0                    		sub	al,al ; 0
 33306 00004C28 50                      		push	ax		 ; mp_type - PRIMARY -  
 33307 00004C29 50                      		push	ax		 ; mp_bootable - not bootable - 
 33308 00004C2A 8A46FC                  		mov	al,[idc_temp]
 33309 00004C2D 50                      		push	ax		 ; mp_free_ptr 
 33310 00004C2E FF76FE                  		push	word [idc_input] ; mp_size
 33311 00004C31 E81209                  		call	make_partition
 33312                                  		;add	sp,8
 33313                                  
 33314                                  		;/* clear off the old prompt */
 33315                                  
 33316 00004C34 B84F00                  		mov	ax,79
 33317 00004C37 50                      		push	ax
 33318 00004C38 B81300                  		mov	ax,19
 33319 00004C3B 50                      		push	ax
 33320 00004C3C 29C0                    		sub	ax,ax
 33321 00004C3E 50                      		push	ax
 33322 00004C3F B80D00                  		mov	ax,13
 33323 00004C42 50                      		push	ax
 33324 00004C43 E850C8                  		call	clear_screen
 33325                                  		;add	sp,8
 33326                                  
 33327                                  		;/* Reissue the partition info */
 33328                                  		
 33329 00004C46 E824E2                  		call	table_display
 33330                                  
 33331                                  		;/* display the "okay, we did it" msg */
 33332                                  		
 33333 00004C49 803E[D5C3]01            		cmp	byte [number_of_drives],1
 33334 00004C4E 7507                    		jne	short idc_10
 33335                                  		
 33336                                  		;push	word [status_5_seg]
 33337 00004C50 1E                      		push	ds
 33338 00004C51 FF36[659E]              		push	word [status_5_off]
 33339 00004C55 EB17                    		jmp	short idc_11
 33340                                  idc_10:
 33341 00004C57 B84F00                  		mov	ax,79
 33342 00004C5A 50                      		push	ax
 33343 00004C5B B81700                  		mov	ax,23
 33344 00004C5E 50                      		push	ax
 33345 00004C5F 29C0                    		sub	ax,ax
 33346 00004C61 50                      		push	ax
 33347 00004C62 B81000                  		mov	ax,16
 33348 00004C65 50                      		push	ax
 33349 00004C66 E82DC8                  		call	clear_screen
 33350                                  		;add	sp,8
 33351                                  
 33352                                  		;push	word [status_12_seg]
 33353 00004C69 1E                      		push	ds
 33354 00004C6A FF36[719E]              		push	word [status_12_off]
 33355                                  idc_11:
 33356 00004C6E E8A9C9                  		call	display
 33357                                  		;pop	bx
 33358                                  		;pop	bx
 33359                                  
 33360 00004C71 E8F6E4                  		call	wait_for_ESC
 33361                                  
 33362 00004C74 C606[6AA0]01            		mov	byte [reboot_flag],1 ; TRUE
 33363 00004C79 EB0B                    		jmp	short idc_14
 33364                                  idc_12:
 33365                                  		; Display error if insufficient space for partition */
 33366                                  
 33367                                  		;push	word [error_10_seg]
 33368 00004C7B 1E                      		push	ds
 33369 00004C7C FF36[889E]              		push	word [error_10_off]
 33370                                  idc_13:
 33371 00004C80 E897C9                  		call	display
 33372                                  		;pop	bx
 33373                                  		;pop	bx
 33374                                  
 33375 00004C83 E8E4E4                  		call	wait_for_ESC
 33376                                  idc_14:
 33377                                  		;pop	si
 33378                                  
 33379 00004C86 89EC                    		mov	sp, bp
 33380 00004C88 5D                      		pop	bp
 33381 00004C89 C3                      		retn
 33382                                  
 33383                                  ;/***************************************************************************************************/
 33384                                  ;/*  Screen for EXT_CREATE_PARTITION                                                                */
 33385                                  ;/*                                                                                                 */
 33386                                  ;/*     |00000000001111111111222222222233333333334444444444555555555566666666667777777777|          */
 33387                                  ;/*     |01234567890123456789012345678901234567890123456789012345678901234567890123456789|          */
 33388                                  ;/*   --|--------------------------------------------------------------------------------|          */
 33389                                  ;/*   00|                                                                                |          */
 33390                                  ;/*   01|                                                                                |          */
 33391                                  ;/*   02|                                                                                |          */
 33392                                  ;/*   03|                                                                                |          */
 33393                                  ;/*   04|                           Create Extended DOS Partition                        |menu_17   */
 33394                                  ;/*   05|                                                                                |          */
 33395                                  ;/*   06|    Current fixed disk drive: #                                                 |menu_5 #  */
 33396                                  ;/*   07|                                                                                |          */
 33397                                  ;/*   08|    Partition Status   Type    Size in Mbytes   Percentage of Disk Used         |menu_14 # */
 33398                                  ;/*   09|     ##  #       #   #######       ####                   ###%                  |          */
 33399                                  ;/*   10|     ##  #       #   #######       ####                   ###%                  |          */
 33400                                  ;/*   11|     ##  #       #   #######       ####                   ###%                  |          */
 33401                                  ;/*   12|     ##  #       #   #######       ####                   ###%                  |          */
 33402                                  ;/*   13|                                                                                |          */
 33403                                  ;/*   14|    Total disk space is #### Mbytes (1 Mbyte = 1048576 bytes)                   |menu_15 # */
 33404                                  ;/*   15|    Maximum space available for partition is #### Mbytes (##%)                  |menu_16 # */
 33405                                  ;/*   16|                                                                                |          */
 33406                                  ;/*   17|                                                                                |          */
 33407                                  ;/*   18|    Enter partition size in Mbytes or percent of disk space (%) to              |menu_42 # */
 33408                                  ;/*   19|    create an Extended DOS Partition................................[####]      |          */
 33409                                  ;/*   20|                                                                                |          */
 33410                                  ;/*   21|                                                                                |          */
 33411                                  ;/*   22|                                                                                |          */
 33412                                  ;/*   23|                                                                                |          */
 33413                                  ;/*   24|    Press ESC to continue                                                       |menu_46   */
 33414                                  ;/*   ------------------------------------------------------------------------------------          */ 
 33415                                  ;/*                                                                                                 */
 33416                                  ;/***************************************************************************************************/
 33417                                  
 33418                                  ; c_menus.c (MSDOS 6.0)
 33419                                  ;/*  */
 33420                                  ;/******************* START OF SPECIFICATIONS *******************/
 33421                                  ;/*                                                             */
 33422                                  ;/* SUBROUTINE NAME: EXT_CREATE_PARTITION                       */
 33423                                  ;/*                                                             */
 33424                                  ;/* DESCRIPTIVE NAME: Create EXTENDED DOS partition             */
 33425                                  ;/*                                                             */
 33426                                  ;/* FUNCTION: Gets user specified size for EXTENDED partition   */
 33427                                  ;/*           (Maximum is largest contiguous freespace). The    */
 33428                                  ;/*           default is the largest available freespace.       */
 33429                                  ;/*           space. Partition is created to default size,      */
 33430                                  ;/*           unless user enters different size, but is not     */
 33431                                  ;/*           marked as active. User specified size must be     */
 33432                                  ;/*           smaller or equal to default size                  */
 33433                                  ;/*                                                             */
 33434                                  ;/* NOTES: Screen can be exited via the ESC command before      */
 33435                                  ;/*        partition is created and nothing will change         */
 33436                                  ;/*                                                             */
 33437                                  ;/*        The following screen is managed                      */
 33438                                  ;/*                                                             */
 33439                                  ;/*       |0000000000111111111122222222223333333333|            */
 33440                                  ;/*       |0123456789012345678901234567890123456789|            */
 33441                                  ;/*     --|----------------------------------------|            */
 33442                                  ;/*     00|                                        |            */
 33443                                  ;/*     01|                                        |            */
 33444                                  ;/*     02|                                        |            */
 33445                                  ;/*     03|                                        |            */
 33446                                  ;/*     04|Create EXTENDED DOS partition           |            */
 33447                                  ;/*     05|                                        |            */
 33448                                  ;/*     06|Current Fixed Disk Drive: #             |            */
 33449                                  ;/*     07|                                        |            */
 33450                                  ;/*     08|Partition Status   Type  Start  End Size|            */
 33451                                  ;/*     09|                                        |            */
 33452                                  ;/*     10|                                        |            */
 33453                                  ;/*     11|                                        |            */
 33454                                  ;/*     12|                                        |            */
 33455                                  ;/*     13|                                        |            */
 33456                                  ;/*     14|Total disk space is  #### cylinders.    |            */
 33457                                  ;/*     15|Maximum space available for partition   |            */
 33458                                  ;/*     16|is #### cylinders.                      |            */
 33459                                  ;/*     17|                                        |            */
 33460                                  ;/*     18|Enter partition size............: [####]|            */
 33461                                  ;/*     19|                                        |            */
 33462                                  ;/*     20|                                        |            */
 33463                                  ;/*     21|                                        |            */
 33464                                  ;/*     22|                                        |            */
 33465                                  ;/*     23|Press ESC to return to FDISK Options    |            */
 33466                                  ;/*     --------------------------------------------            */
 33467                                  ;/*                                                             */
 33468                                  ;/* ENTRY POINTS: EXTENDED_create_partition                     */
 33469                                  ;/*      LINKAGE: EXTENDED_create_partition();                  */
 33470                                  ;/*               NEAR CALL                                     */
 33471                                  ;/*                                                             */
 33472                                  ;/* INPUT: None                                                 */
 33473                                  ;/*                                                             */
 33474                                  ;/* EXIT-NORMAL: ERROR=FALSE                                    */
 33475                                  ;/*                                                             */
 33476                                  ;/* EXIT-ERROR: ERROR=TRUE                                      */
 33477                                  ;/*             GOTO internal_program_error if case statement   */
 33478                                  ;/*             failure when branching to requested function    */
 33479                                  ;/*                                                             */
 33480                                  ;/* EFFECTS: No data directly modified by this routine, but     */
 33481                                  ;/*          child routines will modify data.                   */
 33482                                  ;/*                                                             */
 33483                                  ;/* INTERNAL REFERENCES:                                        */
 33484                                  ;/*   ROUTINES:                                                 */
 33485                                  ;/*      clear_screen                                           */
 33486                                  ;/*      table_display                                          */
 33487                                  ;/*      get_num_input                                          */
 33488                                  ;/*      display                                                */
 33489                                  ;/*      find_partition_type                                    */
 33490                                  ;/*      wait_for_ESC                                           */
 33491                                  ;/*      make_partition                                         */
 33492                                  ;/*                                                             */
 33493                                  ;/* EXTERNAL REFERENCES:                                        */
 33494                                  ;/*   ROUTINES:                                                 */
 33495                                  ;/*                                                             */
 33496                                  ;/******************** END OF SPECIFICATIONS ********************/
 33497                                  
 33498                                  ;/*  */
 33499                                  ;void ext_create_partition()
 33500                                  ;
 33501                                  ;BEGIN
 33502                                  ;
 33503                                  ;    unsigned  input;
 33504                                  ;    unsigned  default_entry;
 33505                                  ;    char      temp;
 33506                                  ;
 33507                                  ;    input = u(NUL);                                                    /* AC000 */
 33508                                  ;    /* clear off screen */
 33509                                  ;    clear_screen(u(0),u(0),u(24),u(79));                               /* AC000 */
 33510                                  ;
 33511                                  ;    /* Put up heading */
 33512                                  ;    display(menu_17);
 33513                                  ;
 33514                                  ;    /* Setup and print current disk */
 33515                                  ;    insert[0] = cur_disk+1+'0';
 33516                                  ;    display(menu_5);
 33517                                  ;
 33518                                  ;    /* print ESC prompt */
 33519                                  ;    display(menu_11);
 33520                                  ;
 33521                                  ;    /* Display partition table-it will return if no partitions there */
 33522                                  ;        table_display();
 33523                                  ;
 33524                                  ;    /* Go see if primary already exists and ext doesn't */
 33525                                  ;    if ((cur_disk >= c(1)) || (find_partition_type(uc(DOS12))) || (find_partition_type(uc(DOS16))) ||
 33526                                  ;        (find_partition_type(uc(DOSNEW))))                                            /* AC000 */
 33527                                  ;        BEGIN
 33528                                  ;        if (!find_partition_type(uc(EXTENDED)))                         /* AC000 */
 33529                                  ;            /* We can go create one now */
 33530                                  ;            BEGIN
 33531                                  ;
 33532                                  ;            /* Get the free space */
 33533                                  ;            temp = find_part_free_space(c(EXTENDED));                   /* AC000 */
 33534                                  ;
 33535                                  ;            /* Is there any ?*/
 33536                                  ;            /* SR; 9/26/89; Instead of checking only the percentage which
 33537                                  ;               could be off because of rounding errors, we also check the
 33538                                  ;               mbytes available */
 33539                                  ;
 33540                                  ;            if (free_space[temp].space != u(0) &&                       /* AC000 */
 33541                                  ;                (free_space[temp].percent_unused != u(0) ||
 33542                                  ;                 free_space[temp].mbytes_unused != u(0)))
 33543                                  ;                BEGIN
 33544                                  ;
 33545                                  ;                /* Display disk space */
 33546                                  ;                sprintf(insert,"%4.0d",total_mbytes[cur_disk]);
 33547                                  ;                display(menu_15);
 33548                                  ;
 33549                                  ;                /* Setup and print max partition size */
 33550                                  ;
 33551                                  ;                sprintf(insert,"%4.0d%3.0d%%",
 33552                                  ;                        free_space[temp].mbytes_unused,
 33553                                  ;                        free_space[temp].percent_unused);
 33554                                  ;                display(menu_16);
 33555                                  ;
 33556                                  ;                /* Force repeats on the input until something valid (Non-Zero return) */
 33557                                  ;                /* Display MBytes unless MBytes == 0, then display percent */
 33558                                  ;                if (free_space[temp].mbytes_unused == u(0))             /* AN000 */
 33559                                  ;                    BEGIN                                               /* AN000 */
 33560                                  ;                    default_entry = (unsigned)free_space[temp].percent_unused; /* AC000 */
 33561                                  ;                    PercentFlag = (FLAG)TRUE;                           /* AN000 */
 33562                                  ;                    END                                                 /* AN000 */
 33563                                  ;                else                                                    /* AN000 */
 33564                                  ;                    BEGIN
 33565                                  ;                    default_entry = (unsigned)free_space[temp].mbytes_unused; /* AC000 */
 33566                                  ;                    PercentFlag = (FLAG)FALSE;                          /* AN000 */
 33567                                  ;                    END
 33568                                  ;
 33569                                  ;                valid_input = (FLAG)FALSE;                              /* AC000 */
 33570                                  ;
 33571                                  ;                while (!valid_input)
 33572                                  ;                    BEGIN
 33573                                  ;                    /* Display prompt */
 33574                                  ;                    if (!PercentFlag)                                   /* AN000 */
 33575                                  ;                        sprintf(insert,"%4.0d",default_entry);
 33576                                  ;                    else                                                /* AN000 */
 33577                                  ;                        sprintf(insert,"%3.0d%%",default_entry);        /* AN000 */
 33578                                  ;                    display(menu_42);                                   /* AC000 */
 33579                                  ;
 33580                                  ;                    input = get_large_num_input(default_entry,free_space[temp].mbytes_unused,free_space[temp].percent_unused,menu_42,u(0),error_13);   /*  AC000 */
 33581                                  ;
 33582                                  ;                    /* Update default in case of error, so it gets displayed and used */
 33583                                  ;                    /* if user presses CR only */
 33584                                  ;
 33585                                  ;                    default_entry = input;
 33586                                  ;                    clear_screen(u(19),u(0),u(23),u(79));                /* AC000 */
 33587                                  ;                    END
 33588                                  ;
 33589                                  ;                if (input != ((unsigned)(ESC_FLAG)))                          /* AC000 */
 33590                                  ;                    BEGIN
 33591                                  ;
 33592                                  ;                    /* Change input to cylinders */
 33593                                  ;                    if (PercentFlag)                                          /* AN000 */
 33594                                  ;                        BEGIN                                                 /* AN000 */
 33595                                  ;                        if (input == free_space[temp].percent_unused)
 33596                                  ;                            input = free_space[temp].space;                   /* AN000 */
 33597                                  ;                        else                                                  /* AN000 */
 33598                                  ;                            input = percent_to_cylinders(input,total_disk[cur_disk]);
 33599                                  ;                        END                                                   /* AN000 */
 33600                                  ;                    else                                                      /* AN000 */
 33601                                  ;                        BEGIN                                                 /* AN000 */
 33602                                  ;                        if (input == free_space[temp].mbytes_unused)
 33603                                  ;                            input = free_space[temp].space;                   /* AN000 */
 33604                                  ;                        else                                                  /* AN000 */
 33605                                  ;                            input = (unsigned)mbytes_to_cylinders(input,
 33606                                  ;                                                                  cur_disk);  /* AN004 */
 33607                                  ;                        END                                                   /* AN000 */
 33608                                  ;
 33609                                  ;
 33610                                  ;                    /* Initialize PecentFlag back to FALSE */
 33611                                  ;                    PercentFlag = (FLAG)FALSE;                                /* AN000 */
 33612                                  ;
 33613                                  ;                    /* SR; 9/26/89; Display error message if input value = 0 */
 33614                                  ;
 33615                                  ;                    if (input == 0)
 33616                                  ;                       {
 33617                                  ;                        display(error_28);
 33618                                  ;                        wait_for_ESC();
 33619                                  ;                       }
 33620                                  ;                    else
 33621                                  ;                       {
 33622                                  ;
 33623                                  ;                    	/* Go create the partition */
 33624                                  ;                    	make_partition(input,temp,uc(NUL),c(EXTENDED));     /* AC000 */
 33625                                  ;
 33626                                  ;                    	/* clear off the old prompt */
 33627                                  ;                    	clear_screen(u(13),u(0),u(19),u(79));               /* AC000 */
 33628                                  ;
 33629                                  ;                    	/* Display the updated partition information */
 33630                                  ;                    	table_display();
 33631                                  ;
 33632                                  ;                    	/* Tell user we created it */
 33633                                  ;                    	display(status_6);
 33634                                  ;                    	wait_for_ESC();
 33635                                  ;
 33636                                  ;                    	reboot_flag = (FLAG)TRUE;                           /* AC000 */
 33637                                  ;
 33638                                  ;                    	/* Go allow him to create disk volumes */
 33639                                  ;                    	volume_create();
 33640                                  ;                       }
 33641                                  ;                    END
 33642                                  ;                END
 33643                                  ;            else
 33644                                  ;                BEGIN
 33645                                  ;                /* No room */
 33646                                  ;                display(error_10);
 33647                                  ;                wait_for_ESC();
 33648                                  ;                END
 33649                                  ;            END
 33650                                  ;        else
 33651                                  ;            BEGIN
 33652                                  ;            /* Already have ext partition, tell user and bow out */
 33653                                  ;            display(error_9);
 33654                                  ;            wait_for_ESC();
 33655                                  ;            END
 33656                                  ;        END
 33657                                  ;    else
 33658                                  ;        BEGIN
 33659                                  ;        /* don't have a primary partition yet, can't create an ext */
 33660                                  ;        display(error_19);
 33661                                  ;        wait_for_ESC();
 33662                                  ;        END
 33663                                  ;
 33664                                  ;    return;
 33665                                  ;END
 33666                                  
 33667                                  ext_create_partition:
 33668                                  		; 25/01/2019
 33669                                  
 33670                                  	%define ecp_default_entry bp-6
 33671                                  	%define ecp_temp	  bp-4
 33672                                  	%define ecp_input	  bp-2
 33673                                  
 33674 00004C8A 55                      		push	bp
 33675 00004C8B 89E5                    		mov	bp,sp
 33676 00004C8D 83EC06                  		sub	sp,6
 33677                                  
 33678                                  		;push	si
 33679                                  		
 33680                                  		;/* clear off screen */
 33681                                  
 33682                                  		;mov	ax,79
 33683                                  		;push	ax
 33684                                  		;mov	ax,24
 33685                                  		;push	ax
 33686                                  		;sub	ax,ax
 33687                                  		;mov	[ecp_input],ax
 33688                                  		;push	ax
 33689                                  		;push	ax
 33690                                  		;call	clear_screen
 33691                                  		;add	sp,8
 33692                                  		
 33693 00004C90 E8CBC7                  		call	CLS
 33694                                  
 33695 00004C93 C746FE0000              		mov	word [ecp_input],0
 33696                                  
 33697                                  		;/* Put up heading */
 33698                                  
 33699                                  		;push	word [menu_17_segment]
 33700 00004C98 1E                      		push	ds
 33701 00004C99 FF36[0B9E]              		push	word [menu_17_offset]
 33702 00004C9D E87AC9                  		call	display
 33703                                  		;pop	bx
 33704                                  		;pop	bx
 33705                                  
 33706                                  		;/* Setup and print current disk */
 33707                                  
 33708 00004CA0 A0[D4CB]                		mov	al,[cur_disk]
 33709 00004CA3 0431                    		add	al,'1'
 33710 00004CA5 A2[E6CC]                		mov	[insert],al
 33711                                  
 33712                                  		;push	word [menu_5_segment]
 33713 00004CA8 1E                      		push	ds
 33714 00004CA9 FF36[EF9D]              		push	word [menu_5_offset]
 33715 00004CAD E86AC9                  		call	display
 33716                                  		;pop	bx
 33717                                  		;pop	bx
 33718                                  
 33719                                  		;/* print ESC prompt */
 33720                                  
 33721                                  		;push	word [menu_11_segment]
 33722 00004CB0 1E                      		push	ds
 33723 00004CB1 FF36[FB9D]              		push	word [menu_11_offset]
 33724 00004CB5 E862C9                  		call	display
 33725                                  		;pop	bx
 33726                                  		;pop	bx
 33727                                  
 33728                                  	;/* Display partition table-it will return if no partitions there */
 33729                                  
 33730 00004CB8 E8B2E1                  		call	table_display
 33731                                  
 33732                                  	;/* Go see if primary already exists and ext doesn't */
 33733                                  
 33734                                  ; *** ('create_partition', 'cp_6:') ***
 33735                                  ;
 33736                                  ;		cmp	bytew [cur_disk],1
 33737                                  ;		;jge	short ecp_1
 33738                                  ;		jnb	short ecp_1
 33739                                  ;
 33740                                  ;		mov	al,1 ; DOS12
 33741                                  ;		;push	ax
 33742                                  ;		call	find_partition_type
 33743                                  ;		;pop	bx
 33744                                  ;		;or	al,al
 33745                                  ;		;jnz	short ecp_1
 33746                                  ;		jnc	short ecp_1
 33747                                  ;		
 33748                                  ;		mov	al,4 ; DOS16
 33749                                  ;		;push	ax
 33750                                  ;		call	find_partition_type
 33751                                  ;		;pop	bx
 33752                                  ;		;or	al, al
 33753                                  ;		;jnz	short ecp_1
 33754                                  ;		jnc	short ecp_1
 33755                                  ;		
 33756                                  ;		mov	al,6  ; DOSNEW
 33757                                  ;		;push	ax
 33758                                  ;		call	find_partition_type
 33759                                  ;		;pop	bx
 33760                                  ;		;or	al,al
 33761                                  ;		;jnz	short ecp_1
 33762                                  ;		jnc	short ecp_1
 33763                                  ;
 33764                                  ;	;/* don't have a primary partition yet, can't create an ext */
 33765                                  ;
 33766                                  ;		jmp	ecp_19
 33767                                  
 33768                                  ecp_1:
 33769 00004CBB B005                    		mov	al,5 ; EXTENDED
 33770                                  		;push	ax
 33771 00004CBD E8FAD0                  		call	find_partition_type
 33772                                  		;pop	bx
 33773                                  		;or	al,al
 33774                                  		;jz	short ecp_2
 33775 00004CC0 7203                    		jc	short ecp_2
 33776 00004CC2 E97C01                  		jmp	ecp_18
 33777                                  
 33778                                  		;/* We can go create one now */
 33779                                  ecp_2:
 33780                                  		;/* Get the free space */
 33781                                  
 33782                                  		; temp = find_part_free_space(c(EXTENDED));    
 33783                                  
 33784 00004CC5 B005                    		mov	al,5
 33785                                  		;push	ax
 33786 00004CC7 E8CA03                  		call	find_part_free_space
 33787                                  		;pop	bx
 33788 00004CCA 8846FC                  		mov	[ecp_temp],al
 33789                                  
 33790                                  		;/* Is there any ?*/
 33791                                  	
 33792                                  	;Instead of checking only the percentage which
 33793                                  	;could be off because of rounding errors, we also check the
 33794                                  	;mbytes available */
 33795                                  
 33796                                  		;mov	cl,22
 33797                                  		;imul	cl
 33798 00004CCD B10A                    		mov	cl,10
 33799 00004CCF F6E1                    		mul	cl
 33800                                  		;mov	bx,ax
 33801 00004CD1 89C6                    		mov	si,ax ; /***/
 33802 00004CD3 31C0                    		xor	ax,ax ; 0
 33803                                  		;cmp	word [free_space.space+bx],0
 33804 00004CD5 3984[E2CB]              		cmp	[free_space.space+si],ax ; 0
 33805 00004CD9 7503                    		jne	short ecp_3
 33806 00004CDB E95C01                  		jmp	ecp_17
 33807                                  ecp_3:
 33808                                  		;cmp	word [free_space.percent_unused+bx],0
 33809 00004CDE 3984[EACB]              		cmp	[free_space.percent_unused+si],ax ; 0
 33810 00004CE2 7509                    		jne	short ecp_4
 33811                                  		;cmp	word [free_space.mbytes_unused+bx],0
 33812 00004CE4 3987[E8CB]              		cmp	[free_space.mbytes_unused+bx],ax ; 0
 33813 00004CE8 7503                    		jne	short ecp_4
 33814 00004CEA E94D01                  		jmp	ecp_17
 33815                                  ecp_4:
 33816                                  		;/* Display disk space */
 33817                                  		;sprintf(insert,"%4.0d",total_mbytes[cur_disk]);
 33818                                  		;display(menu_15);
 33819                                  
 33820                                  		;mov	al,[cur_disk]
 33821                                  		;cbw
 33822                                  		;mov	bx,ax
 33823 00004CED 8A1E[D4CB]              		mov	bl,[cur_disk]
 33824 00004CF1 30FF                    		xor	bh,bh
 33825                                  		;shl	bx,1
 33826 00004CF3 D0E3                    		shl	bl,1
 33827 00004CF5 FFB7[C8A0]              		push	word [total_mbytes+bx]
 33828 00004CF9 B8[846F]                		mov	ax,ecp_size_format ; "%4.1d"
 33829 00004CFC 50                      		push	ax
 33830 00004CFD B8[E6CC]                		mov	ax,insert
 33831 00004D00 50                      		push	ax
 33832 00004D01 E8B7D5                  		call	sprintf
 33833 00004D04 83C406                  		add	sp,6
 33834                                  
 33835                                  		;push	word [menu_15_segment]
 33836 00004D07 1E                      		push	ds
 33837 00004D08 FF36[059E]              		push	word [menu_15_offset]
 33838 00004D0C E80BC9                  		call	display
 33839                                  		;pop	bx
 33840                                  		;pop	bx
 33841                                  
 33842                                  		;/* Setup and print max partition size */
 33843                                  		;sprintf(insert,"%4.0d%3.0d%%",
 33844                                  		;	free_space[temp].mbytes_unused,
 33845                                  		;	free_space[temp].percent_unused);
 33846                                  		;display(menu_16);
 33847                                  
 33848                                  		;;mov	al,22
 33849                                  		;;imul	byte [ecp_temp]
 33850                                  		;mov	al,10
 33851                                  		;mul	byte [ecp_temp]
 33852                                  		;;mov	bx,ax
 33853                                  		;mov	si,ax ; /***/
 33854                                  		
 33855                                  		;push	word [free_space.percent_unused+bx]
 33856 00004D0F FFB4[EACB]              		push	word [free_space.percent_unused+si] ; /***/
 33857                                  		;push	word [free_space.mbytes_unused+bx]
 33858 00004D13 FFB4[E8CB]              		push	word [free_space.mbytes_unused+si] ; /***/
 33859 00004D17 B8[8A6F]                		mov	ax,ecp_mb_pcent_format ; "%4.1d%3.1d%%"
 33860 00004D1A 50                      		push	ax
 33861 00004D1B B8[E6CC]                		mov	ax,insert
 33862 00004D1E 50                      		push	ax
 33863                                  		;mov	si,bx
 33864 00004D1F E899D5                  		call	sprintf
 33865 00004D22 83C408                  		add	sp,8
 33866                                  
 33867                                  		;push	word [menu_16_segment]
 33868 00004D25 1E                      		push	ds
 33869 00004D26 FF36[079E]              		push	word [menu_16_offset]
 33870 00004D2A E8EDC8                  		call	display
 33871                                  		;pop	bx
 33872                                  		;pop	bx
 33873                                  
 33874                                  	;/* Force repeats on the input until something valid (Non-Zero return) */
 33875                                  	;/* Display MBytes unless MBytes == 0, then display percent */
 33876                                  
 33877 00004D2D 83BC[E8CB]00            		cmp	word [free_space.mbytes_unused+si],0
 33878 00004D32 750E                    		jne	short ecp_5
 33879 00004D34 8B84[EACB]              		mov	ax,[free_space.percent_unused+si]
 33880 00004D38 8946FA                  		mov	[ecp_default_entry],ax
 33881 00004D3B C606[D2C3]01            		mov	byte [PercentFlag],1  ; PercentFlag = (FLAG)TRUE;    
 33882 00004D40 EB0C                    		jmp	short ecp_6
 33883                                  ecp_5:
 33884                                  		;;mov	al,22
 33885                                  		;mov	al,10
 33886                                  		;;imul	byte [ecp_temp]
 33887                                  		;mul	byte [ecp_temp]
 33888                                  		;;mov	bx,ax
 33889                                  		;mov	si,ax ; /***/
 33890                                  		
 33891                                  		;mov	ax,[free_space.mbytes_unused+bx]
 33892 00004D42 8B84[E8CB]              		mov	ax,[free_space.mbytes_unused+si] ; /***/
 33893 00004D46 8946FA                  		mov	[ecp_default_entry],ax
 33894 00004D49 C606[D2C3]00            		mov	byte [PercentFlag],0  ; PercentFlag = (FLAG)FALSE;     
 33895                                  ecp_6:
 33896 00004D4E C606[DECB]00            		mov	byte [valid_input],0  ; valid_input = (FLAG)FALSE; 
 33897                                  ecp_7:
 33898 00004D53 FF76FA                  		push	word [ecp_default_entry] ; 25/01/2019
 33899                                  
 33900 00004D56 803E[D2C3]00            		cmp	byte [PercentFlag],0
 33901 00004D5B 7505                    		jne	short ecp_8
 33902                                  
 33903                                  		;/* Display prompt */
 33904                                  		;if (!PercentFlag)
 33905                                  		;   sprintf(insert,"%4.0d",default_entry);
 33906                                  		;else
 33907                                  		;   sprintf(insert,"%3.0d%%",default_entry);
 33908                                  		;display(menu_42);     
 33909                                  
 33910                                  		;push	word [ecp_default_entry]
 33911 00004D5D B8[846F]                		mov	ax,ecp_mb_format ; "%4.1d"
 33912 00004D60 EB03                    		jmp	short ecp_9
 33913                                  ecp_8:
 33914                                  		;push	word [ecp_default_entry]
 33915 00004D62 B8[976F]                		mov	ax,ecp_pcent_format ; "%3.1d%%"
 33916                                  ecp_9:
 33917 00004D65 50                      		push	ax
 33918 00004D66 B8[E6CC]                		mov	ax,insert
 33919 00004D69 50                      		push	ax
 33920 00004D6A E84ED5                  		call	sprintf
 33921 00004D6D 83C406                  		add	sp,6
 33922                                  
 33923                                  		;push	word [menu_42_segment]
 33924 00004D70 1E                      		push	ds
 33925 00004D71 FF36[0D9E]              		push	word [menu_42_offset]
 33926 00004D75 E8A2C8                  		call	display
 33927                                  		;pop	bx
 33928                                  		;pop	bx
 33929                                  
 33930                                  	;input = get_large_num_input(default_entry,free_space[temp].mbytes_unused,
 33931                                  	;		free_space[temp].percent_unused,menu_42,u(0),error_13);
 33932                                  
 33933                                  		;push	word [error_13_seg]
 33934 00004D78 1E                      		push	ds
 33935 00004D79 FF36[8C9E]              		push	word [error_13_off]
 33936 00004D7D 29C0                    		sub	ax,ax ; 0
 33937 00004D7F 50                      		push	ax
 33938                                  
 33939                                  		;push	word [menu_42_segment]
 33940 00004D80 1E                      		push	ds
 33941 00004D81 FF36[0D9E]              		push	word [menu_42_offset]
 33942                                  		
 33943                                  		;;mov	al,22
 33944                                  		;mov	al,10
 33945                                  		;;imul	byte [ecp_temp]
 33946                                  		;mul	byte [ecp_temp]
 33947                                  		;;mov	bx,ax
 33948                                  		;mov	si,ax ; /***/
 33949                                  
 33950                                  		;push	word [free_space.percent_unused+bx]
 33951                                  		;push	word [free_space.mbytes_unused+bx]
 33952 00004D85 FFB4[EACB]              		push	word [free_space.percent_unused+si] ; /***/
 33953 00004D89 FFB4[E8CB]              		push	word [free_space.mbytes_unused+si] ; /***/
 33954 00004D8D FF76FA                  		push	word [ecp_default_entry]
 33955 00004D90 E8E805                  		call	get_large_num_input
 33956                                  		;add	sp,16
 33957                                  
 33958 00004D93 8946FE                  		mov	[ecp_input],ax
 33959                                  
 33960                                  	;/* Update default in case of error, so it gets displayed and used */
 33961                                  	;/* if user presses CR only */
 33962                                  
 33963 00004D96 8946FA                  		mov	[ecp_default_entry],ax
 33964                                  
 33965 00004D99 B84F00                  		mov	ax,79
 33966 00004D9C 50                      		push	ax
 33967 00004D9D B81700                  		mov	ax,23
 33968 00004DA0 50                      		push	ax
 33969 00004DA1 29C0                    		sub	ax,ax
 33970 00004DA3 50                      		push	ax
 33971 00004DA4 B81300                  		mov	ax,19
 33972 00004DA7 50                      		push	ax
 33973 00004DA8 E8EBC6                  		call	clear_screen
 33974                                  		;add	sp,8
 33975                                  
 33976                                  		;while (!valid_input)
 33977                                  
 33978 00004DAB 803E[DECB]00            		cmp	byte [valid_input],0
 33979 00004DB0 74A1                    		je	short ecp_7
 33980                                  
 33981                                  		; if (input != ((unsigned)(ESC_FLAG)))  
 33982                                  
 33983 00004DB2 837EFEFE                		cmp	word [ecp_input],0FFFEh ; ESC_FLAG
 33984 00004DB6 7503                    		jne	short ecp_10
 33985 00004DB8 E99100                  		jmp	ecp_21
 33986                                  ecp_10:
 33987                                  		;/* Change input to cylinders */
 33988                                  
 33989                                  		;;mov	al,22
 33990                                  		;mov	al,10
 33991                                  		;;imul	byte [ecp_temp]
 33992                                  		;mul	byte [ecp_temp]
 33993                                  		;;mov	bx,ax
 33994                                  		;mov	si,ax ; /***/
 33995                                  
 33996                                  		; if (PercentFlag) 
 33997                                  
 33998 00004DBB 8B46FE                  		mov	ax,[ecp_input] ; **   
 33999                                  
 34000 00004DBE 803E[D2C3]00            		cmp	byte [PercentFlag],0
 34001 00004DC3 741D                    		je	short ecp_13  ; else
 34002                                  		
 34003                                  		;;mov	al,22
 34004                                  		;mov	al,10
 34005                                  		;;imul	byte [ecp_temp]
 34006                                  		;mul	byte [ecp_temp]
 34007                                  		;;mov	bx,ax
 34008                                  		;mov	si,ax ; /***/
 34009                                  
 34010                                  		; if (input == free_space[temp].percent_unused)
 34011                                  
 34012                                  		;mov	ax,[ecp_input] ; **
 34013                                  		;cmp	[free_space.percent_unused+bx],ax
 34014 00004DC5 3984[EACB]              		cmp	[free_space.percent_unused+si],ax ; /***/
 34015 00004DC9 7506                    		jne	short ecp_12  ; else
 34016                                  ecp_11:
 34017                                  		;input = free_space[temp].space;
 34018                                  		
 34019                                  		;mov	ax,[free_space.space+bx]
 34020 00004DCB 8B84[E2CB]              		mov	ax,[free_space.space+si] ; /***/
 34021 00004DCF EB1F                    		jmp	short ecp_15
 34022                                  ecp_12:	
 34023                                  	;input = percent_to_cylinders(input,total_disk[cur_disk]);
 34024                                  
 34025                                  		;mov	al,[cur_disk]
 34026                                  		;cbw
 34027                                  		;mov	bx,ax
 34028                                  		;shl	bx,1
 34029 00004DD1 8A1E[D4CB]              		mov	bl,[cur_disk]
 34030 00004DD5 28FF                    		sub	bh,bh
 34031 00004DD7 D0E3                    		shl	bl,1	
 34032                                  		;push	word [total_disk+bx]
 34033 00004DD9 8B8F[B8A0]              		mov	cx,[total_disk+bx]  ;total cylinders
 34034                                  		;;push	word [ecp_input]
 34035                                  		;mov	ax,[ecp_input]
 34036                                  			; cx = total cylinders (of the disk)
 34037                                  			; ax = percent in (word, <= 100)
 34038 00004DDD E83609                  		call	percent_to_cylinders
 34039 00004DE0 EB0E                    		jmp	short ecp_14
 34040                                  ecp_13:
 34041                                  		;;mov	al,22
 34042                                  		;mov	al,10
 34043                                  		;;imul	byte [ecp_temp]
 34044                                  		;mul	byte [ecp_temp]
 34045                                  		;;mov	bx,ax
 34046                                  		;mov	si,ax ; /***/
 34047                                  
 34048                                  		;if (input == free_space[temp].mbytes_unused)
 34049                                  		;   input = free_space[temp].space; 
 34050                                  
 34051                                  		;mov	ax,[ecp_input] ; **
 34052                                  		;cmp	[free_space.mbytes_unused+bx],ax
 34053 00004DE2 3984[E8CB]              		cmp	[free_space.mbytes_unused+si],ax ; /***/
 34054 00004DE6 74E3                    		je	short ecp_11
 34055                                  
 34056                                  		;else
 34057                                  
 34058                                  	; input = (unsigned)mbytes_to_cylinders(input,cur_disk); 
 34059                                  
 34060                                  		;mov	al,[cur_disk]
 34061                                  		;push	ax
 34062 00004DE8 FF36[D4CB]              		push	word [cur_disk] ; 25/01/2019
 34063                                  		;push	word [ecp_input]
 34064 00004DEC 50                      		push	ax ; **
 34065 00004DED E8CF08                  		call	mbytes_to_cylinders
 34066                                  ecp_14:
 34067                                  		;pop	bx
 34068                                  		;pop	bx
 34069                                  ecp_15:	
 34070                                  		;mov	[ecp_input],ax ; *
 34071                                  
 34072                                  		;/* Initialize PecentFlag back to FALSE */
 34073                                  
 34074 00004DF0 C606[D2C3]00            		mov	byte [PercentFlag],0 ; PercentFlag = (FLAG)FALSE;   
 34075                                  
 34076                                  		; Display error message if input value = 0 */
 34077                                  
 34078 00004DF5 09C0                    		or	ax,ax
 34079 00004DF7 7507                    		jnz	short ecp_16
 34080                                  
 34081                                  		;push	word [error_28_seg]
 34082 00004DF9 1E                      		push	ds
 34083 00004DFA FF36[A89E]              		push	word [error_28_off]
 34084 00004DFE EB46                    		jmp	short ecp_20
 34085                                  ecp_16:
 34086                                  		;/* Go create the partition */
 34087                                  
 34088 00004E00 89C1                    		mov	cx,ax ; *
 34089                                  
 34090 00004E02 B005                    		mov	al,5 ; EXTENDED
 34091 00004E04 50                      		push	ax		 ; mp_type (byte) - EXTENDED -
 34092 00004E05 28C0                    		sub	al,al ; 0
 34093 00004E07 50                      		push	ax		 ; mp_bootable (byte) - not bootable -
 34094 00004E08 8A46FC                  		mov	al,[ecp_temp]
 34095 00004E0B 50                      		push	ax		 ; mp_free_ptr (byte)
 34096                                  		;push	word [ecp_input] ; mp_size (word)
 34097 00004E0C 51                      		push	cx  ; *
 34098 00004E0D E83607                  		call	make_partition
 34099                                  		;add	sp,8
 34100                                  
 34101                                  		;* clear off the old prompt */
 34102                                  
 34103 00004E10 B84F00                  		mov	ax,79
 34104 00004E13 50                      		push	ax
 34105 00004E14 B81300                  		mov	ax,19
 34106 00004E17 50                      		push	ax
 34107 00004E18 29C0                    		sub	ax,ax
 34108 00004E1A 50                      		push	ax
 34109 00004E1B B80D00                  		mov	ax,13
 34110 00004E1E 50                      		push	ax
 34111 00004E1F E874C6                  		call	clear_screen
 34112                                  		;add	sp,8
 34113                                  
 34114                                  		;/* Display the updated partition information */
 34115                                  
 34116 00004E22 E848E0                  		call	table_display
 34117                                  
 34118                                  		;/* Tell user we created it */
 34119                                  
 34120                                  		;push	word [status_6_seg]
 34121 00004E25 1E                      		push	ds
 34122 00004E26 FF36[679E]              		push	word [status_6_off]
 34123 00004E2A E8EDC7                  		call	display
 34124                                  		;pop	bx
 34125                                  		;pop	bx
 34126                                  		
 34127 00004E2D E83AE3                  		call	wait_for_ESC
 34128                                  
 34129 00004E30 C606[6AA0]01            		mov	byte [reboot_flag],1  ;reboot_flag = (FLAG)TRUE; 
 34130                                  
 34131                                  		;/* Go allow him to create disk volumes */
 34132                                  
 34133 00004E35 E81800                  		call	volume_create
 34134 00004E38 EB12                    		jmp	short ecp_21
 34135                                  ecp_17:		
 34136                                  		;/* No room */
 34137                                  		
 34138                                  		;display(error_10);
 34139                                  
 34140                                  		;push	word [error_10_seg]
 34141 00004E3A 1E                      		push	ds
 34142 00004E3B FF36[889E]              		push	word [error_10_off]
 34143 00004E3F EB05                    		jmp	short ecp_20
 34144                                  ecp_18:
 34145                                  	;/* Already have ext partition, tell user and bow out */
 34146                                  		
 34147                                  		;display(error_9);
 34148                                  
 34149                                  		;push	word [error_9_seg]
 34150 00004E41 1E                      		push	ds
 34151 00004E42 FF36[869E]              		push	word [error_9_off]
 34152                                  ;		jmp	short ecp_20
 34153                                  ;ecp_19:
 34154                                  ;	;/* don't have a primary partition yet, can't create an ext */
 34155                                  ;
 34156                                  ;		;display(error_19);
 34157                                  ;
 34158                                  ;		;push	word [error_19_seg]
 34159                                  ;		push	ds
 34160                                  ;		push	word [error_19_off]
 34161                                  ecp_20:
 34162 00004E46 E8D1C7                  		call	display
 34163                                  		;pop	bx
 34164                                  		;pop	bx
 34165                                  
 34166 00004E49 E81EE3                  		call	wait_for_ESC  ; wait_for_ESC();
 34167                                  ecp_21:
 34168                                  		;pop	si
 34169                                  
 34170 00004E4C 89EC                    		mov	sp,bp
 34171 00004E4E 5D                      		pop	bp
 34172 00004E4F C3                      		retn
 34173                                  
 34174                                  ;/*  */
 34175                                  ;/******************* START OF SPECIFICATIONS *******************/
 34176                                  ;/*                                                             */
 34177                                  ;/* SUBROUTINE NAME: VOLUME_CREATE                              */
 34178                                  ;/*                                                             */
 34179                                  ;/* DESCRIPTIVE NAME: Create DOS disk volumes                   */
 34180                                  ;/*                                                             */
 34181                                  ;/* FUNCTION: Create the boot record/partition table structure  */
 34182                                  ;/*           needed to support the DOS disk volume arch in     */
 34183                                  ;/*           the EXTENDED partition. Volume is created to the  */
 34184                                  ;/*           the default size (largest contiguous freespace or */
 34185                                  ;/*           32mb, whichever smaller) or to the user specified */
 34186                                  ;/*           size (must be smaller or equal to default size).  */
 34187                                  ;/*           The volume boot record is created, and the appro- */
 34188                                  ;/*           priate pointers in other volume partition tables  */
 34189                                  ;/*           are generated.                                    */
 34190                                  ;/*                                                             */
 34191                                  ;/*                                                             */
 34192                                  ;/* NOTES: Screen can be exited via the ESC command before      */
 34193                                  ;/*        partition is created and nothing will change         */
 34194                                  ;/*                                                             */
 34195                                  ;/*        The following screen is managed                      */
 34196                                  ;/*                                                             */
 34197                                  ;/*       |0000000000111111111122222222223333333333|            */
 34198                                  ;/*       |0123456789012345678901234567890123456789|            */
 34199                                  ;/*     --|----------------------------------------|            */
 34200                                  ;/*     00|Create DOS Disk Volume                  |            */
 34201                                  ;/*     01|                                        |            */
 34202                                  ;/*     02|Vol Start End  Size                     |            */
 34203                                  ;/*     03| #  ####  #### ####                     |            */
 34204                                  ;/*     04|                                        |            */
 34205                                  ;/*     05|                                        |            */
 34206                                  ;/*     06|                                        |            */
 34207                                  ;/*     07|                                        |            */
 34208                                  ;/*     08|                                        |            */
 34209                                  ;/*     09|                                        |            */
 34210                                  ;/*     10|                                        |            */
 34211                                  ;/*     11|                                        |            */
 34212                                  ;/*     12|                                        |            */
 34213                                  ;/*     13|                                        |            */
 34214                                  ;/*     14|                                        |            */
 34215                                  ;/*     15|                                        |            */
 34216                                  ;/*     16|Total partition size is #### cylinders. |            */
 34217                                  ;/*     17|Maximum space available for disk        |            */
 34218                                  ;/*     18|volume is #### cylinders.               |            */
 34219                                  ;/*     19|                                        |            */
 34220                                  ;/*     20|Enter disk volume size..........: [####]|            */
 34221                                  ;/*     21|                                        |            */
 34222                                  ;/*     22|                                        |            */
 34223                                  ;/*     23|Press ESC to return to FDISK Options    |            */
 34224                                  ;/*     --------------------------------------------            */
 34225                                  ;/*                                                             */
 34226                                  ;/* ENTRY POINTS: Volume_Create                                 */
 34227                                  ;/*      LINKAGE: Volume_Create ()                              */
 34228                                  ;/*           NEAR CALL                                         */
 34229                                  ;/*                                                             */
 34230                                  ;/* INPUT: None                                                 */
 34231                                  ;/*                                                             */
 34232                                  ;/* EXIT-NORMAL: ERROR=FALSE                                    */
 34233                                  ;/*                                                             */
 34234                                  ;/* EXIT-ERROR: ERROR=TRUE                                      */
 34235                                  ;/*             GOTO internal_program_error if case statement   */
 34236                                  ;/*             failure when branching to requested function    */
 34237                                  ;/*                                                             */
 34238                                  ;/* EFFECTS: No data directly modified by this routine, but     */
 34239                                  ;/*          child routines will modify data.                   */
 34240                                  ;/*                                                             */
 34241                                  ;/* INTERNAL REFERENCES:                                        */
 34242                                  ;/*   ROUTINES:                                                 */
 34243                                  ;/*      clear_screen                                           */
 34244                                  ;/*      display                                                */
 34245                                  ;/*      volume_display                                         */
 34246                                  ;/*      get_num_input                                          */
 34247                                  ;/*      wait_for_ESC                                           */
 34248                                  ;/*      make_partition                                         */
 34249                                  ;/*                                                             */
 34250                                  ;/* EXTERNAL REFERENCES:                                        */
 34251                                  ;/*   ROUTINES:                                                 */
 34252                                  ;/*                                                             */
 34253                                  ;/******************** END OF SPECIFICATIONS ********************/
 34254                                  
 34255                                  ;/*  */
 34256                                  ;void volume_create()
 34257                                  ;
 34258                                  ;BEGIN
 34259                                  ;
 34260                                  ;    unsigned  input;
 34261                                  ;    unsigned  default_entry;
 34262                                  ;    char  drive_letter;
 34263                                  ;    char  location;
 34264                                  ;    char  ext_location;
 34265                                  ;    unsigned char  i;
 34266                                  ;    char  defined_drives;
 34267                                  ;    char  temp_cur_disk;
 34268                                  ;    unsigned ext_part_percent_unused;                           /* AN000 */
 34269                                  ;    unsigned ext_part_num;                                      /* AN000 */
 34270                                  ;
 34271                                  ;    input = u(NUL);                                             /* AC000 */
 34272                                  ;
 34273                                  ;    /* clear off screen */
 34274                                  ;    clear_screen(u(0),u(0),u(24),u(79));                        /* AC000 */
 34275                                  ;
 34276                                  ;    /* Display header */
 34277                                  ;    display (menu_18);
 34278                                  ;
 34279                                  ;    /* print ESC prompt */
 34280                                  ;    display(menu_11);
 34281                                  ;
 34282                                  ;    /* Display volume info */
 34283                                  ;    drive_letter = volume_display();
 34284                                  ;
 34285                                  ;    /* Loop until done */
 34286                                  ;    input = u(NUL);                                             /* AC000 */
 34287                                  ;    while (input != ((unsigned)(ESC_FLAG)))                     /* AC000 */
 34288                                  ;
 34289                                  ;        BEGIN
 34290                                  ;        /* See if we have hit the max number of drives */
 34291                                  ;        defined_drives = c(0);                                  /* AC000 */
 34292                                  ;        temp_cur_disk = cur_disk;
 34293                                  ;
 34294                                  ;        /* Search both drives for defined drives */
 34295                                  ;        for (i = uc(0); i < number_of_drives; i++)              /* AC000 */
 34296                                  ;
 34297                                  ;            BEGIN
 34298                                  ;            cur_disk = ((char)(i));
 34299                                  ;
 34300                                  ;            /* See if there is a primary drive letter */
 34301                                  ;            if ((find_partition_type(uc(DOS12))) || (find_partition_type(uc(DOS16))) || (find_partition_type(uc(DOSNEW)))) /*AC000*/
 34302                                  ;                defined_drives++;
 34303                                  ;
 34304                                  ;            /* See if extended partition on disk */
 34305                                  ;            if (find_partition_type(uc(EXTENDED)))              /* AC000 */
 34306                                  ;                BEGIN
 34307                                  ;                /* Get number of logical drives */
 34308                                  ;                defined_drives = defined_drives + get_num_logical_dos_drives();
 34309                                  ;                END
 34310                                  ;            END
 34311                                  ;        /* Restore cur_disk to original */
 34312                                  ;        cur_disk = temp_cur_disk;
 34313                                  ;
 34314                                  ;        /* See if 26 or less drives total */
 34315                                  ;        if ((defined_drives < c(24)) &&             /*C07*/
 34316                                  ;            (get_num_logical_dos_drives() < c(23))) /*C07*/
 34317                                  ;            BEGIN
 34318                                  ;            location = find_ext_free_space();
 34319                                  ;
 34320                                  ;            /* find the number of the extended partiton to figure out percent */
 34321                                  ;            ext_part_num = find_partition_location(uc(EXTENDED));       /* AN000 */
 34322                                  ;
 34323                                  ;            /* Set the percent used */
 34324                                  ;            ext_part_percent_unused =
 34325                                  ;                cylinders_to_percent(free_space[location].space,
 34326                                  ;                ((part_table[cur_disk][ext_part_num].end_cyl-part_table[cur_disk][ext_part_num].start_cyl)+1));
 34327                                  ;
 34328                                  ;            /* Is there any ?*/
 34329                                  ;
 34330                                  ;            /* SR; 9/26/89; Instead of checking only the percentage which
 34331                                  ;               could be off because of rounding errors, we also check the
 34332                                  ;               mbytes available */
 34333                                  ;
 34334                                  ;            if (free_space[location].space != u(0) &&
 34335                                  ;                (free_space[location].percent_unused != u(0) ||
 34336                                  ;                 free_space[location].mbytes_unused != u(0)))    /*C02*/
 34337                                  ;                BEGIN
 34338                                  ;
 34339                                  ;                /* Display disk space */
 34340                                  ;                sprintf(insert,"%4.0d",get_partition_size(uc(EXTENDED)) );
 34341                                  ;                display(menu_21);
 34342                                  ;
 34343                                  ;                /* Setup and print max partition size */
 34344                                  ;
 34345                                  ;                sprintf(insert,"%4.0d%3.0d%%",
 34346                                  ;                        free_space[location].mbytes_unused,
 34347                                  ;                        ext_part_percent_unused);
 34348                                  ;                display(menu_22);
 34349                                  ;
 34350                                  ;                /* Force repeats on the input until something valid (Non-Zero return) */
 34351                                  ;                /* If MBytes unused  is equel to zero, display percent unused */
 34352                                  ;                if (free_space[location].mbytes_unused == u(0))         /* AN000 */
 34353                                  ;                    BEGIN                                               /* AN000 */
 34354                                  ;                    default_entry = (unsigned)ext_part_percent_unused;     /* AN000 */
 34355                                  ;                    PercentFlag = (FLAG)TRUE;                           /* AN000 */
 34356                                  ;                    END                                                 /* AN000 */
 34357                                  ;                else                                                    /* AN000 */
 34358                                  ;                    BEGIN                                               /* AN000 */
 34359                                  ;                    default_entry = (unsigned)free_space[location].mbytes_unused;   /* AC000 */
 34360                                  ;                    PercentFlag = (FLAG)FALSE;                          /* AN000 */
 34361                                  ;                    END                                                 /* AN000 */
 34362                                  ;
 34363                                  ;                valid_input = (FLAG)FALSE;                              /* AC000 */
 34364                                  ;
 34365                                  ;                while (!valid_input)
 34366                                  ;                    BEGIN
 34367                                  ;                    /* Display prompt */
 34368                                  ;                    if (!PercentFlag)                                   /* AN000 */
 34369                                  ;                        sprintf(insert,"%4.0d",default_entry);
 34370                                  ;                    else                                                /* AN000 */
 34371                                  ;                        sprintf(insert,"%3.0d%%",default_entry);        /* AN000 */
 34372                                  ;
 34373                                  ;                    display(menu_40);
 34374                                  ;
 34375                                  ;                    input = get_large_num_input(default_entry,free_space[location].mbytes_unused,ext_part_percent_unused,menu_40,u(0),error_12); /* AC000*/
 34376                                  ;
 34377                                  ;                    /* Update default in case of error, so it gets displayed and used */
 34378                                  ;                    /* if user presses CR only */
 34379                                  ;
 34380                                  ;                    default_entry = input;
 34381                                  ;                    clear_screen(u(19),u(0),u(23),u(79));               /* AC000 */
 34382                                  ;                    END
 34383                                  ;
 34384                                  ;                if (input != ((unsigned)(ESC_FLAG)))                    /* AC000 */
 34385                                  ;                    BEGIN
 34386                                  ;
 34387                                  ;                    /* Change input to cylinders */
 34388                                  ;                    if (PercentFlag)                                          /* AN000 */
 34389                                  ;                        BEGIN                                                 /* AN000 */
 34390                                  ;                        if (input == ext_part_percent_unused)
 34391                                  ;                            input = free_space[location].space;               /* AN000 */
 34392                                  ;                        else                                                  /* AN000 */
 34393                                  ;                            input = percent_to_cylinders(input,((part_table[cur_disk][ext_part_num].end_cyl-part_table[cur_disk][ext_part_num].start_cyl)+1));
 34394                                  ;                        END                                                   /* AN000 */
 34395                                  ;                    else                                                      /* AN000 */
 34396                                  ;                        BEGIN                                                 /* AN000 */
 34397                                  ;                        if (input == free_space[location].mbytes_unused)
 34398                                  ;                            input = free_space[location].space;                   /* AN000 */
 34399                                  ;                        else                                                  /* AN000 */
 34400                                  ;                            input = (unsigned)mbytes_to_cylinders(input,
 34401                                  ;                                                                  cur_disk);  /* AN004 */
 34402                                  ;                        END                                                   /* AN000 */
 34403                                  ;
 34404                                  ;                    /* Initialize PecentFlag back to FALSE */
 34405                                  ;                    PercentFlag = (FLAG)FALSE;                                  /* AN000 */
 34406                                  ;
 34407                                  ;                    /* SR; 9/26/89; Display error message if input value = 0 */
 34408                                  ;
 34409                                  ;                    if (input == 0)
 34410                                  ;                       {
 34411                                  ;                        display(error_28);
 34412                                  ;                        wait_for_ESC();
 34413                                  ;                       }
 34414                                  ;                    else
 34415                                  ;                       {
 34416                                  ;                    	/* go create the entry and find out where it put it */
 34417                                  ;                    	ext_location = make_volume(input,location);
 34418                                  ;
 34419                                  ;                    	/* clear off the old prompt */
 34420                                  ;                    	clear_screen(u(15),u(0),u(19),u(79));               /* AC000 */
 34421                                  ;
 34422                                  ;                    	reboot_flag = (FLAG)TRUE;                           /* AC000 */
 34423                                  ;
 34424                                  ;                    	/* Display the updated partition information */
 34425                                  ;                    	drive_letter = volume_display();
 34426                                  ;
 34427                                  ;                    	/* Tell user we created it */
 34428                                  ;                    	display(status_7);
 34429                                  ;                       }
 34430                                  ;                    END
 34431                                  ;                END
 34432                                  ;            else
 34433                                  ;                BEGIN
 34434                                  ;                /* No space left or already max'd on the devices */
 34435                                  ;                /* Get rid of the size prompts */
 34436                                  ;                clear_screen(u(17),u(0),u(21),u(79));                   /* AC000 */
 34437                                  ;                display(error_20);
 34438                                  ;                volume_display();
 34439                                  ;                wait_for_ESC();                         /* KWC, 11-01-87 */
 34440                                  ;                input = u(ESC_FLAG);                    /* KWC, 11-01-87 */
 34441                                  ;                END
 34442                                  ;            END
 34443                                  ;        else
 34444                                  ;            BEGIN
 34445                                  ;            /* Reached the maximum */
 34446                                  ;            /* Get rid of the size prompts */
 34447                                  ;            clear_screen(u(17),u(0),u(21),u(79));                       /* AC000 */
 34448                                  ;            display(error_27);
 34449                                  ;            /* Force an exit with ESC */
 34450                                  ;            wait_for_ESC();                         /* KWC, 11-01-87 */
 34451                                  ;            input = u(ESC_FLAG);                    /* KWC, 11-01-87 */
 34452                                  ;            END
 34453                                  ;        END
 34454                                  ;    clear_screen(u(0),u(0),u(24),u(79));                               /* AC000 */
 34455                                  ;    return;
 34456                                  ;END
 34457                                  
 34458                                  volume_create:
 34459                                  		; 23/01/2019
 34460                                  
 34461                                  	%define vc_defined_drives	 bp-14 	;bp-16
 34462                                  	%define vc_ext_part_pcent_unused bp-12 	;bp-14
 34463                                  	%define vc_location		 bp-10	;bp-12
 34464                                  	%define vc_i		 	 bp-8	;bp-10
 34465                                  	%define vc_temp_cur_disk 	 bp-6	;bp-8
 34466                                  	%define vc_default_entry 	 bp-4	;bp-6
 34467                                  	;%define vc_ext_part_num  	 	;bp-4
 34468                                  	%define vc_input	 	 bp-2	;bp-2
 34469                                  
 34470 00004E50 55                      		push	bp
 34471 00004E51 89E5                    		mov	bp,sp
 34472 00004E53 83EC0E                  		sub	sp,14
 34473                                  
 34474                                  		;/* clear off screen */
 34475                                  
 34476                                  		;push	si
 34477                                  		
 34478                                  		;mov	ax,79
 34479                                  		;push	ax
 34480                                  		;mov	ax,24
 34481                                  		;push	ax
 34482                                  		;sub	ax,ax
 34483                                  		;push	ax
 34484                                  		;push	ax
 34485                                  		;call	clear_screen
 34486                                  		;add	sp,8
 34487                                  
 34488 00004E56 E805C6                  		call	CLS
 34489                                  
 34490                                  		;/* Display header */
 34491                                  
 34492                                  		;push	word [menu_18_segment]
 34493 00004E59 1E                      		push	ds
 34494 00004E5A FF36[119E]              		push	word [menu_18_offset]
 34495 00004E5E E8B9C7                  		call	display
 34496                                  		;pop	bx
 34497                                  		;pop	bx
 34498                                  
 34499                                  		;/* print ESC prompt */
 34500                                  		
 34501                                  		;push	word [menu_11_segment]
 34502 00004E61 1E                      		push	ds
 34503 00004E62 FF36[FB9D]              		push	word [menu_11_offset]
 34504 00004E66 E8B1C7                  		call	display
 34505                                  		;pop	bx
 34506                                  		;pop	bx
 34507                                  
 34508                                  		;/* Display volume info */
 34509                                  
 34510 00004E69 E86CE3                  		call	volume_display
 34511                                  
 34512                                  		;/* Loop until done */
 34513                                  
 34514 00004E6C C746FE0000              		mov	word [vc_input],0
 34515                                  vc_1:
 34516                                  		;/* See if we have hit the max number of drives */
 34517                                  
 34518 00004E71 C646F200                		mov	byte [vc_defined_drives],0
 34519 00004E75 A0[D4CB]                		mov	al,[cur_disk]
 34520 00004E78 8846FA                  		mov	[vc_temp_cur_disk],al
 34521 00004E7B C646F800                		mov	byte [vc_i],0
 34522 00004E7F EB2E                    		jmp	short vc_6
 34523                                  vc_2:
 34524 00004E81 8A46F8                  		mov	al,[vc_i]
 34525 00004E84 A2[D4CB]                		mov	[cur_disk],al
 34526                                  
 34527 00004E87 B001                    		mov	al,1 ; DOS12
 34528                                  		;push	ax
 34529 00004E89 E82ECF                  		call	find_partition_type
 34530                                  		;pop	bx
 34531                                  		;or	al,al
 34532                                  		;jnz	short vc_3
 34533 00004E8C 730E                    		jnc	short vc_3
 34534                                  
 34535 00004E8E B004                    		mov	al,4  ; DOS16
 34536                                  		;push	ax
 34537 00004E90 E827CF                  		call	find_partition_type
 34538                                  		;pop	bx
 34539                                  		;or	al,al
 34540                                  		;jnz	short vc_3
 34541 00004E93 7307                    		jnc	short vc_3
 34542                                  
 34543 00004E95 B006                    		mov	al,6 ; DOSNEW
 34544                                  		;push	ax
 34545 00004E97 E820CF                  		call	find_partition_type
 34546                                  		;pop	bx
 34547                                  		;or	al,al
 34548                                  		;jz	short vc_4
 34549 00004E9A 7203                    		jc	short vc_4
 34550                                  vc_3:
 34551 00004E9C FE46F2                  		inc	byte [vc_defined_drives]
 34552                                  vc_4:
 34553 00004E9F B005                    		mov	al,5 ; EXTENDED
 34554                                  		;push	ax
 34555 00004EA1 E816CF                  		call	find_partition_type
 34556                                  		;pop	bx
 34557                                  		;or	al,al
 34558                                  		;jz	short vc_5
 34559 00004EA4 7206                    		jc	short vc_5
 34560                                  
 34561 00004EA6 E865F9                  		call	get_num_logical_dos_drives
 34562 00004EA9 0046F2                  		add	[vc_defined_drives],al
 34563                                  vc_5:
 34564 00004EAC FE46F8                  		inc	byte [vc_i]
 34565                                  vc_6:
 34566                                  		;/* Search both drives for defined drives */
 34567                                  		;for (i = uc(0); i < number_of_drives; i++)  
 34568                                  
 34569 00004EAF A0[D5C3]                		mov	al,[number_of_drives]
 34570 00004EB2 3846F8                  		cmp	[vc_i],al
 34571 00004EB5 72CA                    		jb	short vc_2
 34572                                  
 34573                                  		;/* Restore cur_disk to original */
 34574 00004EB7 8A46FA                  		mov	al,[vc_temp_cur_disk]
 34575 00004EBA A2[D4CB]                		mov	[cur_disk],al
 34576                                  
 34577                                  		;/* See if 26 or less drives total */
 34578                                  
 34579 00004EBD 807EF218                		cmp	byte [vc_defined_drives],24
 34580                                  		;jge	short vc_7
 34581 00004EC1 7307                    		jnb	short vc_7
 34582                                  
 34583 00004EC3 E848F9                  		call	get_num_logical_dos_drives
 34584 00004EC6 3C17                    		cmp	al,23
 34585                                  		;jl	short vc_8
 34586 00004EC8 7203                    		jb	short vc_8
 34587                                  vc_7:
 34588 00004ECA E9A301                  		jmp	vc_24
 34589                                  vc_8:
 34590 00004ECD E87F08                  		call	find_ext_free_space
 34591 00004ED0 8846F6                  		mov	[vc_location],al
 34592                                  
 34593                                  	;/* find the number of the extended partiton to figure out percent */
 34594                                  	;ext_part_num = find_partition_location(uc(EXTENDED));
 34595                                  
 34596                                  		;mov	al,5
 34597                                  		;push	ax
 34598                                  		;call	find_partition_location
 34599                                  		;pop	bx
 34600                                  		;cbw
 34601                                  		;mov	[vc_ext_part_num],ax
 34602                                  		
 34603 00004ED3 B005                    		mov	al,5 ; EXTENDED
 34604 00004ED5 E8E2CE                  		call	find_partition_type
 34605                                  		;mov	[vc_ext_part_num],cl
 34606                                  
 34607                                  		;/* Set the percent used */
 34608                                  
 34609 00004ED8 A0[D4CB]                		mov	al,[cur_disk]
 34610                                  		;cbw
 34611                                  		;shl	ax,1
 34612                                  		;shl	ax,1
 34613                                  		;add	ax,[vc_ext_part_num]
 34614 00004EDB D0E0                    		shl	al,1
 34615 00004EDD D0E0                    		shl	al,1
 34616                                  		;add	al,[vc_ext_part_num]
 34617 00004EDF 00C8                    		add	al,cl
 34618                                  
 34619                                  		;mov	cx,46
 34620                                  		;mul	cx
 34621 00004EE1 B12E                    		mov	cl,46
 34622 00004EE3 F6E1                    		mul	cl
 34623 00004EE5 89C3                    		mov	bx,ax
 34624                                  
 34625                                  		;mov	ax,[part_table_end_cyl+bx]
 34626                                  		;sub	ax,[part_table_start_cyl+bx]
 34627                                  		;inc	ax
 34628                                  		;push	ax
 34629                                  
 34630 00004EE7 8B8F[1AC4]              		mov	cx,[part_table_end_cyl+bx]
 34631 00004EEB 2B8F[15C4]              		sub	cx,[part_table_start_cyl+bx]
 34632 00004EEF 41                      		inc	cx ; extended dos partition cylinders - divisor -
 34633                                  
 34634 00004EF0 89CF                    		mov	di,cx ; ***--
 34635                                  
 34636                                  		;mov	al,22
 34637 00004EF2 B00A                    		mov	al,10
 34638                                  		;imul	byte [vc_location]
 34639 00004EF4 F666F6                  		mul	byte [vc_location]
 34640                                  		;mov	bx,ax
 34641                                  		;push	word [free_space.space+bx]
 34642 00004EF7 89C6                    		mov	si,ax ; **--
 34643 00004EF9 8B9C[E2CB]              		mov	bx,[free_space.space+si]  ; volume cylinders - dividend -
 34644 00004EFD E8AFC6                  		call	cylinders_to_percent
 34645                                  		;pop	bx
 34646                                  		;pop	bx
 34647 00004F00 8946F4                  		mov	[vc_ext_part_pcent_unused],ax
 34648                                  
 34649                                  		;/* Is there any ?*/
 34650                                  
 34651                                  	;Instead of checking only the percentage which
 34652                                  	;could be off because of rounding errors, we also check the
 34653                                  	; mbytes available */
 34654                                  
 34655                                  	;if (free_space[location].space != u(0) &&
 34656                                  	;   (free_space[location].percent_unused != u(0) ||
 34657                                  	;    free_space[location].mbytes_unused != u(0)))
 34658                                  
 34659 00004F03 31C0                    		xor	ax,ax
 34660                                  		;cmp	word free_space.space+si],0
 34661 00004F05 3984[E2CB]              		cmp	[free_space.space+si],ax ; 0
 34662 00004F09 7503                    		jne	short vc_9
 34663 00004F0B E94301                  		jmp	vc_23
 34664                                  vc_9:
 34665                                  		;cmp	word [free_space.percent_unused+si],0
 34666 00004F0E 3984[EACB]              		cmp	[free_space.percent_unused+si],ax; 0
 34667 00004F12 7509                    		jne	short vc_10
 34668                                  		;cmp	word [free_space.mbytes_unused+si],0
 34669 00004F14 3984[E8CB]              		cmp	[free_space.mbytes_unused+si],ax ; 0
 34670 00004F18 7503                    		jne	short vc_10
 34671 00004F1A E93401                  		jmp	vc_23
 34672                                  vc_10:
 34673                                  		;/* Display disk space */
 34674                                  		;sprintf(insert,"%4.0d",get_partition_size(uc(EXTENDED)) );
 34675                                  		;display(menu_21);
 34676                                  
 34677                                  		;mov	al,5
 34678                                  		;push	ax
 34679 00004F1D B605                    		mov	dh,5
 34680 00004F1F E8FCE3                  		call	get_partition_size
 34681                                  		;pop	bx
 34682                                  
 34683                                  		; ax = extended dos partition size (in megabytes)
 34684                                  
 34685 00004F22 50                      		push	ax
 34686 00004F23 B8[846F]                		mov	ax,v_psize_format ; "%4.1d"
 34687 00004F26 50                      		push	ax
 34688 00004F27 B8[E6CC]                		mov	ax,insert
 34689 00004F2A 50                      		push	ax
 34690 00004F2B E88DD3                  		call	sprintf
 34691 00004F2E 83C406                  		add	sp,6
 34692                                  
 34693                                  		;push	word [menu_21_segment]
 34694 00004F31 1E                      		push	ds
 34695 00004F32 FF36[1B9E]              		push	word [menu_21_offset]
 34696 00004F36 E8E1C6                  		call	display
 34697                                  		;pop	bx
 34698                                  		;pop	bx
 34699                                  
 34700                                  	;/* Setup and print max partition size */
 34701                                  	;
 34702                                  	;	sprintf(insert,"%4.0d%3.0d%%",
 34703                                  	;	free_space[location].mbytes_unused,
 34704                                  	;	ext_part_percent_unused);
 34705                                  	;	display(menu_22);,
 34706                                  
 34707 00004F39 FF76F4                  		push	word [vc_ext_part_pcent_unused]
 34708                                  
 34709                                  		;;mov	al,22
 34710                                  		;mov	al,10
 34711                                  		;;imul	byte [vc_location]
 34712                                  		;mul	byte [vc_location]
 34713                                  		;mov	bx,ax
 34714                                  
 34715                                  		;push	word [free_space.mbytes_unused+bx]
 34716 00004F3C FFB4[E8CB]              		push	word [free_space.mbytes_unused+si] ; **--
 34717 00004F40 B8[8A6F]                		mov	ax,v_mb_percent_format ; "%4.1d%3.1d%%"
 34718 00004F43 50                      		push	ax
 34719 00004F44 B8[E6CC]                		mov	ax,insert
 34720 00004F47 50                      		push	ax
 34721                                  		;mov	si,bx ; **--
 34722 00004F48 E870D3                  		call	sprintf
 34723 00004F4B 83C408                  		add	sp,8
 34724                                  
 34725                                  		;push	word [menu_22_segment]
 34726 00004F4E 1E                      		push	ds
 34727 00004F4F FF36[1D9E]              		push	word [menu_22_offset]
 34728 00004F53 E8C4C6                  		call	display
 34729                                  		;pop	bx
 34730                                  		;pop	bx
 34731                                  
 34732                                  	;/* Force repeats on the input until something valid (Non-Zero return) */
 34733                                  	;/* If MBytes unused is equal to zero, display percent unused */
 34734                                  	;if (free_space[location].mbytes_unused == u(0))  
 34735                                  
 34736 00004F56 83BC[E8CB]00            		cmp	word [free_space.mbytes_unused+si],0 ;**--
 34737 00004F5B 750D                    		jne	short vc_11
 34738                                  
 34739                                  		;default_entry = (unsigned)ext_part_percent_unused;
 34740                                  
 34741 00004F5D 8B46F4                  		mov	ax,[vc_ext_part_pcent_unused]
 34742 00004F60 8946FC                  		mov	[vc_default_entry],ax
 34743 00004F63 C606[D2C3]01            		mov	byte [PercentFlag],1 ; PercentFlag = (FLAG)TRUE;
 34744 00004F68 EB0C                    		jmp	short vc_12
 34745                                  vc_11: 
 34746                                  	;default_entry = (unsigned)free_space[location].mbytes_unused;   
 34747                                  
 34748                                  		;;mov	al,22
 34749                                  		;mov	al,10
 34750                                  		;;imul	byte [vc_location]
 34751                                  		;mul	byte [vc_location]
 34752                                  		;mov	bx,ax
 34753                                  
 34754                                  		;mov	ax,[free_space.mbytes_unused+bx]
 34755 00004F6A 8B84[E8CB]              		mov	ax,[free_space.mbytes_unused+si] ; **--
 34756 00004F6E 8946FC                  		mov	[vc_default_entry],ax
 34757 00004F71 C606[D2C3]00            		mov	byte [PercentFlag],0 ; PercentFlag = (FLAG)FALSE;   
 34758                                  vc_12:	
 34759 00004F76 C606[DECB]00            		mov	byte [valid_input],0 ; valid_input = (FLAG)FALSE; 
 34760                                  vc_13:	
 34761                                  		;/* Display prompt */
 34762                                  
 34763                                  	;if (!PercentFlag)
 34764                                  	;    sprintf(insert,"%4.0d",default_entry);
 34765                                  	;else
 34766                                  	;    sprintf(insert,"%3.0d%%",default_entry);
 34767                                  
 34768 00004F7B FF76FC                  		push	word [vc_default_entry]
 34769                                  
 34770 00004F7E 803E[D2C3]00            		cmp	byte [PercentFlag],0
 34771 00004F83 7505                    		jne	short vc_14
 34772                                  
 34773                                  		;push	word [vc_default_entry]
 34774 00004F85 B8[846F]                		mov	ax,v_mbytes_format ; "%4.1d"
 34775 00004F88 EB03                    		jmp	short vc_15
 34776                                  vc_14:
 34777                                  		;push	word [vc_default_entry]
 34778 00004F8A B8[976F]                		mov	ax,v_percent_format ; "%3.1d%%"
 34779                                  vc_15:
 34780 00004F8D 50                      		push	ax
 34781 00004F8E B8[E6CC]                		mov	ax,insert
 34782 00004F91 50                      		push	ax
 34783 00004F92 E826D3                  		call	sprintf
 34784 00004F95 83C406                  		add	sp,6
 34785                                  
 34786                                  		;display(menu_40);
 34787                                  
 34788                                  		;push	word [menu_40_segment]
 34789 00004F98 1E                      		push	ds
 34790 00004F99 FF36[1F9E]              		push	word [menu_40_offset]
 34791 00004F9D E87AC6                  		call	display
 34792                                  		;pop	bx
 34793                                  		;pop	bx
 34794                                  
 34795                                  ;input = get_large_num_input(default_entry,free_space[location].mbytes_unused,ext_part_percent_unused,menu_40,u(0),error_12)
 34796                                  
 34797                                  		;push	word [error_12_seg]
 34798 00004FA0 1E                      		push	ds			; glni_err_msg_seg	
 34799 00004FA1 FF36[8A9E]              		push	word [error_12_off]	; glni_err_msg
 34800 00004FA5 29C0                    		sub	ax,ax
 34801 00004FA7 50                      		push	ax			; glni_prompt_loc
 34802                                  		;push	word [menu_40_segment]	
 34803 00004FA8 1E                      		push	ds			; glni_input_msg_seg
 34804 00004FA9 FF36[1F9E]              		push	word [menu_40_offset]	; glni_input_msg
 34805 00004FAD FF76F4                  		push	word [vc_ext_part_pcent_unused] ; glni_max_pc
 34806                                  
 34807                                  		;;mov	al,22
 34808                                  		;mov	al,10
 34809                                  		;;imul	byte [vc_location]
 34810                                  		;mul	byte [vc_location]
 34811                                  		;mov	bx,ax
 34812                                  
 34813                                  		;push	word [free_space.mbytes_unused+bx] ; glni_max_num
 34814 00004FB0 FFB4[E8CB]              		push	word [free_space.mbytes_unused+si] ; **--
 34815 00004FB4 FF76FC                  		push	word [vc_default_entry]	; glni_input_def
 34816 00004FB7 E8C103                  		call	get_large_num_input
 34817                                  		;add	sp,16
 34818 00004FBA 8946FE                  		mov	[vc_input],ax
 34819                                  
 34820                                  	;/* Update default in case of error, so it gets displayed and used */
 34821                                  	;/* if user presses CR only */
 34822                                  	;
 34823                                  	;	default_entry = input;
 34824                                  
 34825 00004FBD 8946FC                  		mov	[vc_default_entry],ax
 34826                                  
 34827 00004FC0 B84F00                  		mov	ax,79
 34828 00004FC3 50                      		push	ax
 34829 00004FC4 B81700                  		mov	ax,23
 34830 00004FC7 50                      		push	ax
 34831 00004FC8 29C0                    		sub	ax,ax
 34832 00004FCA 50                      		push	ax
 34833 00004FCB B81300                  		mov	ax,19
 34834 00004FCE 50                      		push	ax
 34835 00004FCF E8C4C4                  		call	clear_screen
 34836                                  		;add	sp,8
 34837                                  
 34838                                  		;while (!valid_input)
 34839                                  
 34840 00004FD2 803E[DECB]00            		cmp	byte [valid_input],0
 34841 00004FD7 74A2                    		je	short vc_13
 34842                                  
 34843                                  		;if (input != ((unsigned)(ESC_FLAG)))  
 34844                                  
 34845 00004FD9 837EFEFE                		cmp	word [vc_input],0FFFEh
 34846 00004FDD 7503                    		jne	short vc_16
 34847                                  		;jmp	vc_26
 34848 00004FDF E9AB00                  		jmp	vc_27
 34849                                  vc_16:
 34850                                  		; /* Change input to cylinders */
 34851                                  
 34852                                  		;;mov	al,22
 34853                                  		;mov	al,10
 34854                                  		;;imul	byte [vc_location]
 34855                                  		;mul	byte [vc_location]
 34856                                  		;mov	bx,ax
 34857                                  
 34858 00004FE2 8B46FE                  		mov	ax,[vc_input]
 34859                                  
 34860 00004FE5 803E[D2C3]00            		cmp	byte [PercentFlag],0
 34861 00004FEA 7417                    		je	short vc_19
 34862                                  
 34863                                  ;if (input == ext_part_percent_unused)
 34864                                  ;   input = free_space[location].space;
 34865                                  ;else
 34866                                  ;   input = percent_to_cylinders(input,((part_table[cur_disk][ext_part_num].end_cyl-
 34867                                  ;           part_table[cur_disk][ext_part_num].start_cyl)+1));
 34868                                  
 34869                                  		;mov	ax,[vc_input]
 34870                                  
 34871 00004FEC 3946F4                  		cmp	[vc_ext_part_pcent_unused],ax
 34872 00004FEF 7506                    		jne	short vc_18
 34873                                  
 34874                                  		;;mov	al,22
 34875                                  		;mov	al,10
 34876                                  		;;imul	byte [vc_location]
 34877                                  		;mul	byte [vc_location]
 34878                                  		;mov	bx,ax
 34879                                  vc_17:
 34880                                  		;mov	ax,[free_space.space+bx]
 34881 00004FF1 8B84[E2CB]              		mov	ax,[free_space.space+si]
 34882 00004FF5 EB1C                    		jmp	short vc_21
 34883                                  vc_18:
 34884                                  		;mov	al,[cur_disk]
 34885                                  		;;cbw
 34886                                  		;;shl	ax,1
 34887                                  		;;shl	ax,1
 34888                                  		;;add	ax,[vc_ext_part_num]
 34889                                  		;shl	al,1
 34890                                  		;shl	al,1
 34891                                  		;add	al,[vc_ext_part_num]
 34892                                  		;;mov	cx,46
 34893                                  		;;mul	cx
 34894                                  		;mov	cl,46
 34895                                  		;mul	cl
 34896                                  		;mov	bx,ax
 34897                                  
 34898                                  		;mov	ax,[part_table_end_cyl+bx]
 34899                                  		;sub	ax,[part_table_start_cyl+bx]
 34900                                  		;inc	ax
 34901                                  		;push	ax
 34902                                  
 34903                                  		;mov	cx,[part_table_end_cyl+bx]
 34904                                  		;sub	cx,[part_table_start_cyl+bx]
 34905                                  		;inc	cx ; available volume size in cylinders
 34906                                  
 34907 00004FF7 89F9                    		mov	cx,di ; ***--
 34908                                  		
 34909                                  		;push	word [vc_input]
 34910                                  		;mov	ax,[vc_input]  ; percentage input
 34911 00004FF9 E81A07                  		call	percent_to_cylinders  ; convert percent to cylinders
 34912                                  
 34913 00004FFC C606[D2C3]00            		mov	byte [PercentFlag],0
 34914                                  
 34915 00005001 EB10                    		jmp	short vc_20
 34916                                  vc_19:
 34917                                  		;;mov	al,22
 34918                                  		;mov	al,10
 34919                                  		;;imul	byte [vc_location]
 34920                                  		;mul	byte [vc_location]
 34921                                  		;mov	bx,ax
 34922                                  
 34923                                  	;if (input == free_space[location].mbytes_unused)
 34924                                  	;    input = free_space[location].space;
 34925                                  	;else
 34926                                  	;    input = (unsigned)mbytes_to_cylinders(input,cur_disk); 
 34927                                  
 34928                                  		;mov	ax,[vc_input]
 34929                                  
 34930                                  		;cmp	[free_space.mbytes_unused+bx],ax
 34931 00005003 3984[E8CB]              		cmp	[free_space.mbytes_unused+si],ax
 34932 00005007 74E8                    		je	short vc_17
 34933                                  
 34934                                  		;mov	al,[cur_disk]
 34935                                  		;push	ax		; mtc_which_disk
 34936 00005009 FF36[D4CB]              		push	word [cur_disk]
 34937 0000500D FF76FE                  		push	word [vc_input] ; mtc_mbytes_in
 34938 00005010 E8AC06                  		call	mbytes_to_cylinders
 34939                                  vc_20:
 34940                                  		;pop	bx
 34941                                  		;pop	bx
 34942                                  vc_21:
 34943                                  		;mov	[vc_input],ax
 34944                                  
 34945                                  		;/* Initialize PecentFlag back to FALSE */
 34946                                  		; PercentFlag = (FLAG)FALSE;   
 34947                                  
 34948                                  		;mov	byte [PercentFlag],0
 34949                                  
 34950                                  		;Display error message if input value = 0 */
 34951                                  
 34952 00005013 09C0                    		or	ax,ax ; cylinders
 34953 00005015 750E                    		jnz	short vc_22
 34954                                  
 34955                                  		;push	word [error_28_seg]
 34956 00005017 1E                      		push	ds
 34957 00005018 FF36[A89E]              		push	word [error_28_off]
 34958 0000501C E8FBC5                  		call	display
 34959                                  		;pop	bx
 34960                                  		;pop	bx
 34961                                  
 34962 0000501F E848E1                  		call	wait_for_ESC
 34963                                  		;jmp	vc_26
 34964 00005022 E94CFE                  		jmp	vc_1
 34965                                  vc_22:
 34966                                  		;/* go create the entry and find out where it put it */
 34967                                  		;ext_location = make_volume(input,location);
 34968                                  
 34969                                  		;mov	al,[vc_location]
 34970                                  		;push	ax
 34971 00005025 FF76F6                  		push	word [vc_location] ; mv_free_ptr
 34972                                  		;push	word [vc_input]
 34973                                  		;mov	ax,[vc_input]
 34974 00005028 50                      		push	ax ; volume size, mv_size
 34975 00005029 E88C09                  		call	make_volume
 34976                                  		;pop	bx
 34977                                  		;pop	bx
 34978                                  
 34979                                  		;/* clear off the old prompt */
 34980                                  		
 34981 0000502C B84F00                  		mov	ax,79
 34982 0000502F 50                      		push	ax
 34983 00005030 B81300                  		mov	ax,19
 34984 00005033 50                      		push	ax
 34985 00005034 29C0                    		sub	ax,ax
 34986 00005036 50                      		push	ax
 34987 00005037 B80F00                  		mov	ax,15
 34988 0000503A 50                      		push	ax
 34989 0000503B E858C4                  		call	clear_screen
 34990                                  		;add	sp,8
 34991                                  
 34992 0000503E C606[6AA0]01            		mov	byte [reboot_flag],1 ; reboot_flag = (FLAG)TRUE;  
 34993                                  
 34994                                  		;/* Display the updated partition information */ 
 34995                                     
 34996 00005043 E892E1                  		call	volume_display
 34997                                  
 34998                                  		;/* Tell user we created it */
 34999                                  
 35000                                  		;push	word [status_7_seg]
 35001 00005046 1E                      		push	ds
 35002 00005047 FF36[699E]              		push	word [status_7_off]
 35003 0000504B E8CCC5                  		call	display
 35004                                  		;pop	bx
 35005                                  		;pop	bx
 35006                                  		;jmp	short vc_26
 35007 0000504E E920FE                  		jmp	vc_1
 35008                                  vc_23:
 35009                                  		;/* No space left or already max'd on the devices */
 35010                                  		;/* Get rid of the size prompts */
 35011                                  		;clear_screen(u(17),u(0),u(21),u(79));
 35012                                  		;display(error_20);
 35013                                  		;volume_display();
 35014                                  		;wait_for_ESC();
 35015                                  		;input = u(ESC_FLAG);
 35016                                  
 35017 00005051 B84F00                  		mov	ax,79
 35018 00005054 50                      		push	ax
 35019 00005055 B81500                  		mov	ax,21
 35020 00005058 50                      		push	ax
 35021 00005059 29C0                    		sub	ax,ax
 35022 0000505B 50                      		push	ax
 35023 0000505C B81100                  		mov	ax,17
 35024 0000505F 50                      		push	ax
 35025 00005060 E833C4                  		call	clear_screen
 35026                                  		;add	sp,8
 35027                                  
 35028                                  		;push	word [error_20_seg]
 35029 00005063 1E                      		push	ds
 35030 00005064 FF36[989E]              		push	word [error_20_off]
 35031 00005068 E8AFC5                  		call	display
 35032                                  		;pop	bx
 35033                                  		;pop	bx
 35034 0000506B E86AE1                  		call	volume_display
 35035 0000506E EB1A                    		jmp	short vc_25
 35036                                  vc_24:	 
 35037                                  		;/* Reached the maximum */
 35038                                  		;/* Get rid of the size prompts */
 35039                                  		;clear_screen(u(17),u(0),u(21),u(79));
 35040                                  		;display(error_27);
 35041                                  
 35042 00005070 B84F00                  		mov	ax,79
 35043 00005073 50                      		push	ax
 35044 00005074 B81500                  		mov	ax,21
 35045 00005077 50                      		push	ax
 35046 00005078 29C0                    		sub	ax,ax
 35047 0000507A 50                      		push	ax
 35048 0000507B B81100                  		mov	ax,17
 35049 0000507E 50                      		push	ax
 35050 0000507F E814C4                  		call	clear_screen
 35051                                  		;add	sp,8
 35052                                  
 35053                                  		;push	word [error_27_seg]
 35054 00005082 1E                      		push	ds
 35055 00005083 FF36[A69E]              		push	word [error_27_off]
 35056 00005087 E890C5                  		call	display
 35057                                  		;pop	bx
 35058                                  		;pop	bx
 35059                                  vc_25:		
 35060                                  		;/* Force an exit with ESC */
 35061                                  
 35062 0000508A E8DDE0                  		call	wait_for_ESC ; wait_for_ESC();    
 35063                                  		;mov	word [vc_input],0FFFEh ; input = u(ESC_FLAG);  
 35064                                  ;		jmp	short vc_27
 35065                                  ;
 35066                                  ;		;while (input != ((unsigned)(ESC_FLAG)))
 35067                                  ;vc_26:
 35068                                  ;		cmp	word [vc_input],0FFFEh
 35069                                  ;		je	short vc_27
 35070                                  ;		jmp	vc_1
 35071                                  vc_27:
 35072                                  		;clear_screen(u(0),u(0),u(24),u(79));      
 35073                                  
 35074                                  		;mov	ax,79
 35075                                  		;push	ax
 35076                                  		;mov	ax,24
 35077                                  		;push	ax
 35078                                  		;sub	ax,ax
 35079                                  		;push	ax
 35080                                  		;push	ax
 35081                                  		;call	clear_screen
 35082                                  		;add	sp,8
 35083                                  		
 35084 0000508D E8CEC3                  		call	CLS
 35085                                  
 35086                                  		;pop	si
 35087                                  
 35088 00005090 89EC                    		mov	sp,bp
 35089 00005092 5D                      		pop	bp
 35090                                  
 35091                                  		;return;
 35092 00005093 C3                      		retn
 35093                                  
 35094                                  ; ----------------------------------------------------------------------------
 35095                                  ; space.c (FDISK, MSDOS 6.0, 1991)	
 35096                                  ; ----------------------------------------------------------------------------
 35097                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 14/01/2019)
 35098                                  
 35099                                  ;char find_part_free_space(type)
 35100                                  ;
 35101                                  ;char   type;
 35102                                  ;
 35103                                  ;BEGIN
 35104                                  ;
 35105                                  ;char        i;
 35106                                  ;char        partition_count;
 35107                                  ;char        last_found_partition;
 35108                                  ;unsigned    temp;
 35109                                  ;char        freespace_count;
 35110                                  ;char        any_partition;
 35111                                  ;unsigned    temp_size;
 35112                                  ;
 35113                                  ;        /* Sort the partition table */
 35114                                  ;        sort_part_table(c(4));                                          /* AC000 */
 35115                                  ;
 35116                                  ;        /* Intialize free space to zero */
 35117                                  ;        for (i = c(0); i < c(5); i++)                                   /* AC000 */
 35118                                  ;           BEGIN
 35119                                  ;            free_space[i].space = u(0);                                 /* AC000 */
 35120                                  ;            free_space[i].start = u(0);                                 /* AC000 */
 35121                                  ;            free_space[i].end = u(0);                                   /* AC000 */
 35122                                  ;            free_space[i].mbytes_unused = f(0);                         /* AC000 */  /* AN000 */
 35123                                  ;            free_space[i].percent_unused = u(0);                        /* AC000 */  /* AN000 */
 35124                                  ;           END
 35125                                  ;
 35126                                  ;        /* Find space between start of disk and first partition */
 35127                                  ;        partition_count = c(0);                                         /* AC000 */
 35128                                  ;
 35129                                  ;        any_partition = FALSE;
 35130                                  ;        for (i = c(0); i < c(4); i++)                                   /* AC000 */
 35131                                  ;           BEGIN
 35132                                  ;            if (part_table[cur_disk][sort[i]].sys_id != uc(0))          /* AC000 */
 35133                                  ;               BEGIN
 35134                                  ;                /* Found a partition, get the space */
 35135                                  ;
 35136                                  ;                free_space[0].start = u(0);                             /* AC000 */
 35137                                  ;
 35138                                  ;                /* This is a special case - the extended partition can not start */
 35139                                  ;                /* on cylinder 0 due too its archetecture. Protect against that here */
 35140                                  ;                if (type == c(EXTENDED))                                /* AC000 */
 35141                                  ;                   BEGIN
 35142                                  ;                    free_space[0].start = u(1);                         /* AC000 */
 35143                                  ;                  END
 35144                                  ;
 35145                                  ;                /* free space ends before start of next valid partition */
 35146                                  ;                if (part_table[cur_disk][sort[i]].start_cyl > u(0))     /* AC000 */
 35147                                  ;                   BEGIN
 35148                                  ;                    free_space[0].end = part_table[cur_disk][sort[i]].start_cyl-1;
 35149                                  ;                    free_space[0].space = part_table[cur_disk][sort[i]].start_cyl-free_space[0].start; /*C04*/
 35150                                  ;                   END
 35151                                  ;
 35152                                  ;                free_space[0].mbytes_unused =
 35153                                  ;                    cylinders_to_mbytes(free_space[0].space,cur_disk);  /* AN004 */
 35154                                  ;                free_space[0].percent_unused = (unsigned)cylinders_to_percent(free_space[0].space,total_disk[cur_disk]); /* AN000 */
 35155                                  ;
 35156                                  ;                partition_count = i;
 35157                                  ;                last_found_partition = sort[i];
 35158                                  ;                any_partition = TRUE;
 35159                                  ;                break;
 35160                                  ;               END
 35161                                  ;           END
 35162                                  ;        /* See if any partitions were there */
 35163                                  ;        if (any_partition)
 35164                                  ;           BEGIN
 35165                                  ;            /* Look for space between the rest of the partitions */
 35166                                  ;            freespace_count = c(1);                                     /* AC000 */
 35167                                  ;            for (i = partition_count+1; i < c(4); i++)                  /* AC000 */
 35168                                  ;               BEGIN
 35169                                  ;                if (part_table[cur_disk][sort[i]].sys_id != uc(0))      /* AC000 */
 35170                                  ;                   BEGIN
 35171                                  ;                    /* Check to see if more than one partition on a cylinder (i.e. XENIX bad block)  */
 35172                                  ;                    /* If so, leave the space at zero */
 35173                                  ;
 35174                                  ;                    if (part_table[cur_disk][sort[i]].start_cyl != part_table[cur_disk][last_found_partition].end_cyl)
 35175                                  ;                       BEGIN
 35176                                  ;                        /* No, things are normal */
 35177                                  ;                        /* Get space between the end of the last one and the start of the next one */
 35178                                  ;                        free_space[freespace_count].space = part_table[cur_disk][sort[i]].start_cyl
 35179                                  ;                           - (part_table[cur_disk][last_found_partition].end_cyl+1);
 35180                                  ;
 35181                                  ;                        temp_size = (part_table[cur_disk][sort[i]].start_cyl -
 35182                                  ;                             part_table[cur_disk][last_found_partition].end_cyl);
 35183                                  ;
 35184                                  ;                        if (temp_size != u(0) )                         /* AC000 */
 35185                                  ;                           BEGIN
 35186                                  ;                            free_space[freespace_count].space = temp_size - u(1);  /* AC000 */
 35187                                  ;                           END
 35188                                  ;                       END
 35189                                  ;
 35190                                  ;                    free_space[freespace_count].start = part_table[cur_disk][last_found_partition].end_cyl+1;
 35191                                  ;                    free_space[freespace_count].end = part_table[cur_disk][sort[i]].start_cyl -1;
 35192                                  ;                    free_space[freespace_count].mbytes_unused =
 35193                                  ;                         cylinders_to_mbytes(free_space[freespace_count].space,cur_disk); /* AN004 */
 35194                                  ;                    free_space[freespace_count].percent_unused = (unsigned)
 35195                                  ;                         cylinders_to_percent(free_space[freespace_count].space,total_disk[cur_disk]);  /* AN000 */
 35196                                  ;
 35197                                  ;                    /* update the last found partition */
 35198                                  ;                    last_found_partition = sort[i];
 35199                                  ;                    freespace_count++;
 35200                                  ;                   END
 35201                                  ;               END
 35202                                  ;            /* Find the space between the last partition and the end of the disk */
 35203                                  ;            /* SR; 10/10/89; Make sure that freespace cannot become negative */
 35204                                  ;
 35205                                  ;            if ( total_disk[cur_disk] >
 35206                                  ;                 part_table[cur_disk][last_found_partition].end_cyl )
 35207                                  ;               {
 35208                                  ;            	free_space[freespace_count].space = (total_disk[cur_disk]
 35209                                  ;                                     	-  part_table[cur_disk][last_found_partition].end_cyl)-1;
 35210                                  ;            	free_space[freespace_count].start = part_table[cur_disk][last_found_partition].end_cyl+1;
 35211                                  ;            	free_space[freespace_count].end = total_disk[cur_disk]-1;
 35212                                  ;            	free_space[freespace_count].mbytes_unused =
 35213                                  ;                 	cylinders_to_mbytes(free_space[freespace_count].space,cur_disk);    /* AN004 */
 35214                                  ;            	free_space[freespace_count].percent_unused =
 35215                                  ;                 	cylinders_to_percent(free_space[freespace_count].space,total_disk[cur_disk]); /* AN000 */
 35216                                  ;               }
 35217                                  ;            END
 35218                                  ;         else
 35219                                  ;           BEGIN
 35220                                  ;            /* No partitions found, show entire space as free */
 35221                                  ;            free_space[0].start = u(0);                                 /* AC000 */
 35222                                  ;
 35223                                  ;            /* This is a special case - the extended partition can not start */
 35224                                  ;            /* on cylinder 0 due too its architecture. Protect against that here */
 35225                                  ;            if (type == c(EXTENDED))                                    /* AC000 */
 35226                                  ;               BEGIN
 35227                                  ;                free_space[0].start = u(1);                             /* AC000 */
 35228                                  ;               END
 35229                                  ;            free_space[0].end = total_disk[cur_disk]-1;
 35230                                  ;            free_space[0].space = (free_space[0].end - free_space[0].start)+1;
 35231                                  ;            free_space[0].mbytes_unused =
 35232                                  ;                 cylinders_to_mbytes(free_space[0].space,cur_disk);    /* AN004 */
 35233                                  ;            free_space[0].percent_unused =
 35234                                  ;                 cylinders_to_percent(free_space[0].space,total_disk[cur_disk]); /* AN000 */
 35235                                  ;           END
 35236                                  ;
 35237                                  ;         /* Find largest free space, and verify the golden tracks while we are at it */
 35238                                  ;         do
 35239                                  ;            BEGIN
 35240                                  ;             temp = u(0);                                               /* AC000 */
 35241                                  ;
 35242                                  ;             /* Zip thru the table */
 35243                                  ;             for (i = c(0); i < c(5); i++)                              /* AC000 */
 35244                                  ;                BEGIN
 35245                                  ;                 /* Is this one bigger ? */
 35246                                  ;                 if (free_space[i].space > temp)
 35247                                  ;                    BEGIN
 35248                                  ;                     temp = free_space[i].space;
 35249                                  ;                     last_found_partition = i;
 35250                                  ;                    END
 35251                                  ;                END
 35252                                  ;
 35253                                  ;             /* If there is any free space, go verify it */
 35254                                  ;             temp = u(0);
 35255                                  ;             if (free_space[last_found_partition].space != u(0))        /* AC000 */
 35256                                  ;               BEGIN
 35257                                  ;                /* Go verify the tracks */
 35258                                  ;                temp = verify_tracks(last_found_partition,c(PRIMARY));  /* AC000 */
 35259                                  ;               END
 35260                                  ;             /* Move up to next golden track */
 35261                                  ;             free_space[last_found_partition].start = free_space[last_found_partition].start+temp;
 35262                                  ;             free_space[last_found_partition].space = free_space[last_found_partition].space-temp;
 35263                                  ;             free_space[last_found_partition].mbytes_unused =
 35264                                  ;                  cylinders_to_mbytes(free_space[last_found_partition].space,cur_disk);    /* AN004 */
 35265                                  ;             free_space[last_found_partition].percent_unused = (unsigned)
 35266                                  ;                  cylinders_to_percent(free_space[last_found_partition].space,total_disk[cur_disk]);                      /* AN000 */
 35267                                  ;             END
 35268                                  ;
 35269                                  ;            /* Repeat the loop if the start was moved due to bad tracks */
 35270                                  ;            /* Unless we're past the end of the free space */
 35271                                  ;            while ((temp != u(0)) && (free_space[last_found_partition].space != u(0)));    /* AC000 */
 35272                                  ;
 35273                                  ;        /* Don't create a partition larger than DOS can handle */                                       /*C05*/
 35274                                  ;        if((type == c(PRIMARY)) && (free_space[last_found_partition].mbytes_unused > u(MAX_PART_SIZE))) /*C05*/
 35275                                  ;          BEGIN                                                                                         /*C05*/
 35276                                  ;          free_space[last_found_partition].space =                                                      /*C05*/
 35277                                  ;           mbytes_to_cylinders(f(MAX_PART_SIZE),cur_disk) - 1;                                          /*C05*/
 35278                                  ;          free_space[last_found_partition].end =                                                        /*C05*/
 35279                                  ;           free_space[last_found_partition].start+free_space[last_found_partition].space-1;             /*C05*/
 35280                                  ;          free_space[last_found_partition].mbytes_unused =                                              /*C05*/
 35281                                  ;           cylinders_to_mbytes(free_space[last_found_partition].space,cur_disk);                        /*C05*/
 35282                                  ;          free_space[last_found_partition].percent_unused = (unsigned)                                  /*C05*/
 35283                                  ;           cylinders_to_percent(free_space[last_found_partition].space,total_disk[cur_disk]);           /*C05*/
 35284                                  ;          END                                                                                           /*C05*/
 35285                                  ;
 35286                                  ;        /* Return with the pointer to the largest free space */
 35287                                  ;        return(last_found_partition);
 35288                                  ;END
 35289                                  
 35290                                  find_part_free_space:
 35291                                  		; 17/01/2019
 35292                                  		; 14/01/2019
 35293                                  
 35294                                  	%define fpfs_type	bp-12 ; 25/01/2019
 35295                                  
 35296                                  	%define fpfs_i			bp-10	;bp-14
 35297                                  	%define last_found_partition	bp-8	;bp-12
 35298                                  	%define fpfs_temp		bp-6	;bp-10
 35299                                  	%define freespace_count		bp-4	;bp-8
 35300                                  	%define fpfs_partition_count	bp-2	;bp-6
 35301                                  	;%define fpfs_anypartition		;bp-4
 35302                                  
 35303                                  	;%define fpfs_type	bp+4
 35304                                  
 35305 00005094 55                      		push	bp
 35306 00005095 89E5                    		mov	bp,sp
 35307                                  		;;sub	sp,14
 35308                                  		;sub	sp,10  ; 20/01/2019
 35309 00005097 83EC0C                  		sub	sp,12  ; 25/01/2019
 35310                                  
 35311                                  		;push	di
 35312                                  		;push	si
 35313                                  
 35314                                    		;/* Sort the partition table */
 35315                                  
 35316                                  		;mov	al,4
 35317                                  		;push	ax
 35318 0000509A B104                    		mov	cl,4
 35319 0000509C E8FCD8                  		call	sort_part_table
 35320                                  		;pop	bx
 35321                                  
 35322                                  		;/* Initialize free space to zero */
 35323                                  
 35324                                  		;mov	byte [fpfs_i],0
 35325                                  fpfs_1:
 35326                                  		;mov	al,22
 35327                                  		;;imul	byte [fpfs_i]
 35328                                  		;mul	byte [fpfs_i]
 35329                                  		;mov	bx,ax
 35330                                  		;sub	ax,ax ; 0
 35331                                  		;mov	[free_space.space+bx],ax
 35332                                  		;mov	[free_space.start+bx],ax
 35333                                  		;mov	[free_space.end+bx],ax
 35334                                  		;mov	[free_space.mbytes_unused+bx],ax
 35335                                  		;mov	[free_space.percent_unused+bx],ax
 35336                                  		;inc	byte [fpfs_i]
 35337                                  		;cmp	byte [fpfs_i],5
 35338                                  		;jl	short fpfs_1
 35339                                  		
 35340                                  		;push	cs
 35341                                  		;pop	es
 35342 0000509F BF[E2CB]                		mov	di,fspc ; free_space.space
 35343 000050A2 B91900                  		mov	cx,5*5 ; (5*10/2) ; 17/01/2019
 35344 000050A5 31C0                    		xor	ax,ax ; 0
 35345 000050A7 F3AB                    		rep	stosw
 35346                                  
 35347                                  		;sub	al,al
 35348 000050A9 8846FE                  		mov	[fpfs_partition_count],al ; 0
 35349                                  		;mov	[fpfs_anypartition],al ; 0
 35350 000050AC 8846F6                  		mov	[fpfs_i],al ; 0
 35351 000050AF EB11                    		jmp	short fpfs_3
 35352                                  fpfs_2:	
 35353 000050B1 FE46F6                  		inc	byte [fpfs_i]
 35354                                  ;fpfs_3:
 35355 000050B4 807EF604                		cmp	byte [fpfs_i],4
 35356 000050B8 7203                    		jb	short fpfs_4
 35357                                  		;jmp	fpfs_7
 35358 000050BA E99E01                  		jmp	fpfs_16
 35359                                  fpfs_4:
 35360                                  	; /* Find space between start of disk and first partition */
 35361                                  
 35362                                  		; 17/01/2019
 35363                                  		;mov	al,[cur_disk]
 35364                                  		;;cbw
 35365                                  		;;shl	ax,1
 35366                                  		;;shl	ax,1
 35367                                  		;;mov	cx,ax
 35368                                  		;shl	al,1
 35369                                  		;shl	al,1
 35370                                  		;mov	cl,al
 35371                                  
 35372 000050BD 8A46F6                  		mov	al,[fpfs_i]
 35373                                  		;cbw
 35374 000050C0 30E4                    		xor	ah,ah
 35375                                  fpfs_3:
 35376                                  		; 17/01/2019
 35377 000050C2 8A0E[D4CB]              		mov	cl,[cur_disk]
 35378 000050C6 D0E1                    		shl	cl,1
 35379 000050C8 D0E1                    		shl	cl,1
 35380                                  
 35381 000050CA 89C3                    		mov	bx,ax
 35382                                  
 35383 000050CC 8A87[E2C3]              		mov	al,[sort+bx]
 35384                                  		;cbw
 35385                                  		;add	ax,cx
 35386 000050D0 00C8                    		add	al,cl
 35387                                  
 35388                                  		;mov	cx,46
 35389                                  		;imul	cx
 35390 000050D2 B12E                    		mov	cl,46
 35391 000050D4 F6E1                    		mul	cl
 35392 000050D6 89C3                    		mov	bx,ax
 35393                                  
 35394 000050D8 80BF[17C4]00            		cmp	byte [part_table_sys_id+bx],0
 35395 000050DD 74D2                    		je	short fpfs_2
 35396                                  
 35397 000050DF 31C0                    		xor	ax,ax
 35398                                  
 35399                                  		;free_space[0].start = u(0);  
 35400                                  
 35401                                  		;mov	word [free_space.start],0
 35402 000050E1 807EF405                		cmp	byte [fpfs_type],5  ; EXTENDED
 35403 000050E5 7502                    		jne	short fpfs_5
 35404                                  
 35405                                  	;/* This is a special case - the extended partition can not start */
 35406                                  	;/* on cylinder 0 due too its architecture. Protect against that here */
 35407                                  
 35408                                  		;free_space[0].start = u(1);  
 35409                                  
 35410                                  		;mov	word [free_space_start],1
 35411                                  
 35412 000050E7 FEC0                    		inc	al  ; ax = 1
 35413                                  fpfs_5:
 35414                                  		;/* Found a partition, get the space */	
 35415                                  
 35416 000050E9 A3[E4CB]                		mov	[free_space.start],ax ; 0 or 1
 35417                                  
 35418                                  		;mov	al,[cur_disk]
 35419                                  		;;cbw
 35420                                  		;;shl	ax,1
 35421                                  		;;shl	ax,1
 35422                                  		;;mov	cx,ax
 35423                                  		;mov	cl,al
 35424                                  		;mov	al,[fpfs_i]
 35425                                  		;;cbw
 35426                                  		;; ah = 0
 35427                                  		;mov	bx,ax
 35428                                  		;mov	al,[sort+bx]
 35429                                  		;;cbw
 35430                                  		;;add	ax,cx
 35431                                  		;add	al,cl
 35432                                  		;;mov	cx,46
 35433                                  		;;imul	cx
 35434                                  		;mov	cl,46
 35435                                  		;mul	cl	
 35436                                  		;mov	bx,ax
 35437                                  
 35438                                  		;/* free space ends before start of next valid partition */
 35439                                  		
 35440                                  		;cmp	word [part_table_start_cyl+bx],0
 35441                                  		;je	short fpfs_6
 35442                                  		;mov	ax,[part_table_start_cyl+bx]
 35443                                  		
 35444 000050EC 8B87[15C4]              		mov	ax,[part_table_start_cyl+bx]
 35445 000050F0 09C0                    		or	ax,ax
 35446 000050F2 740E                    		jz	short fpfs_6
 35447                                  
 35448                                  	;free_space[0].end = part_table[cur_disk][sort[i]].start_cyl-1;
 35449                                  	;free_space[0].space = part_table[cur_disk][sort[i]].start_cyl-free_space[0].start;
 35450                                  
 35451 000050F4 89C1                    		mov	cx,ax
 35452 000050F6 48                      		dec	ax 
 35453 000050F7 A3[E6CB]                		mov	[free_space.end],ax
 35454 000050FA 2B0E[E4CB]              		sub	cx,[free_space.start]
 35455 000050FE 890E[E2CB]              		mov	[free_space.space],cx
 35456                                  fpfs_6:	
 35457                                  	;free_space[0].mbytes_unused = cylinders_to_mbytes(free_space[0].space,cur_disk);
 35458                                  
 35459                                  		;mov	al,[cur_disk]
 35460                                  		;push	ax
 35461                                  		;push	word [free_space.space]
 35462                                  
 35463 00005102 8A1E[D4CB]              		mov	bl,[cur_disk]
 35464 00005106 30FF                    		xor	bh,bh
 35465                                  
 35466 00005108 A1[E2CB]                		mov	ax,[free_space.space]
 35467                                  
 35468 0000510B E84EC4                  		call	cylinders_to_mbytes
 35469                                  		;pop	bx
 35470                                  		;pop	bx
 35471                                  
 35472 0000510E A3[E8CB]                		mov	[free_space.mbytes_unused],ax
 35473                                  
 35474                                  ;free_space[0].percent_unused = cylinders_to_percent(free_space[0].space,total_disk[cur_disk]);
 35475                                  
 35476 00005111 A0[D4CB]                		mov	al,[cur_disk]
 35477 00005114 98                      		cbw
 35478 00005115 89C3                    		mov	bx,ax
 35479 00005117 D1E3                    		shl	bx,1
 35480                                  		;push	word [total_disk+bx]
 35481 00005119 8B8F[B8A0]              		mov	cx,[total_disk+bx]	; Total (disk) cylinders -divisor-
 35482                                  		;push	word [free_space.space]
 35483 0000511D 8B1E[E2CB]              		mov	bx,[free_space.space]	; Partition cylinders -dividend-
 35484                                  
 35485 00005121 E88BC4                  		call	cylinders_to_percent
 35486                                  		;pop	bx
 35487                                  		;pop	bx
 35488                                  
 35489 00005124 A3[EACB]                		mov	[free_space.percent_unused],ax
 35490                                  
 35491                                  		;partition_count = i;
 35492                                  		;last_found_partition = sort[i];
 35493                                  		;any_partition = TRUE;
 35494                                  
 35495 00005127 8A46F6                  		mov	al,[fpfs_i]
 35496 0000512A 8846FE                  		mov	[fpfs_partition_count],al
 35497 0000512D 98                      		cbw
 35498 0000512E 89C3                    		mov	bx,ax
 35499 00005130 8A87[E2C3]              		mov	al,[sort+bx]
 35500 00005134 8846F8                  		mov	[last_found_partition],al
 35501                                  		;mov	byte [fpfs_anypartition],1
 35502                                  ;fpfs_7:	
 35503                                  ;		;/* See if any partitions were there */
 35504                                  ;		cmp	byte [fpfs_anypartition],0
 35505                                  ;		jne	short fpfs_8
 35506                                  ;		jmp	fpfs_16
 35507                                  fpfs_8:	
 35508                                  		;/* Look for space between the rest of the partitions */
 35509                                  
 35510 00005137 C646FC01                		mov	byte [freespace_count],1
 35511 0000513B 8A46FE                  		mov	al,[fpfs_partition_count]
 35512 0000513E FEC0                    		inc	al
 35513 00005140 8846F6                  		mov	[fpfs_i],al
 35514 00005143 E9A000                  		jmp	fpfs_13
 35515                                  fpfs_9:
 35516                                  		;mov	al,[cur_disk]
 35517                                  		;cbw
 35518                                  		;shl	ax,1
 35519                                  		;shl	ax,1
 35520                                  		;mov	cx,ax
 35521 00005146 8A0E[D4CB]              		mov	cl,[cur_disk]
 35522 0000514A D0E1                    		shl	cl,1
 35523 0000514C D0E1                    		shl	cl,1   ; =**=
 35524 0000514E 8A46F6                  		mov	al,[fpfs_i]
 35525 00005151 98                      		cbw
 35526 00005152 89C3                    		mov	bx,ax
 35527 00005154 8A87[E2C3]              		mov	al,[sort+bx]
 35528                                  		;cbw
 35529                                  		;add	ax,cx
 35530 00005158 00C8                    		add	al,cl  ; =**=
 35531                                  		;mov	bx,46
 35532                                  		;imul	bx
 35533 0000515A B32E                    		mov	bl,46
 35534 0000515C F6E3                    		mul	bl
 35535 0000515E 89C6                    		mov	si,ax  ; ****
 35536                                  	
 35537                                  	;if (part_table[cur_disk][sort[i]].sys_id != uc(0))
 35538                                  
 35539 00005160 80BC[17C4]00            		cmp	byte [part_table_sys_id+si],0 ;****
 35540                                  		;jne	short fpfs_10
 35541                                  		;jmp	fpfs_12
 35542 00005165 747C                    		je	short fpfs_12 ; 17/01/2019
 35543                                  fpfs_10:
 35544                                  	;/* Check to see if more than one partition on a cylinder (i.e. XENIX bad block)  */
 35545                                  	;/* If so, leave the space at zero */
 35546                                  
 35547                                  ;if (part_table[cur_disk][sort[i]].start_cyl != part_table[cur_disk][last_found_partition].end_cyl)
 35548                                  
 35549 00005167 8A46F8                  		mov	al,[last_found_partition]
 35550                                  		;cbw
 35551                                  		;add	ax,cx
 35552 0000516A 00C8                    		add	al,cl ; =**=
 35553                                  		;imul	bx
 35554 0000516C F6E3                    		mul	bl
 35555 0000516E 89C3                    		mov	bx,ax
 35556                                  		;mov	ax,[part_table_end_cyl+bx]
 35557 00005170 8B97[1AC4]              		mov	dx,[part_table_end_cyl+bx] ;****	
 35558                                  		;cmp	[part_table_start_cyl+si],ax
 35559                                  		;je	short fpfs_11
 35560                                  
 35561 00005174 B00A                    		mov	al,10
 35562 00005176 F666FC                  		mul	byte [freespace_count]
 35563 00005179 89C7                    		mov	di,ax  ;***
 35564                                  
 35565 0000517B 3994[15C4]              		cmp	[part_table_start_cyl+si],dx  ;****
 35566 0000517F 740D                    		je	short fpfs_11
 35567                                  		
 35568                                  	;/* No, things are normal */
 35569                                  	;/* Get space between the end of the last one and the start of the next one */
 35570                                  
 35571                                  	; free_space[freespace_count].space = part_table[cur_disk][sort[i]].start_cyl
 35572                                  	;                           - (part_table[cur_disk][last_found_partition].end_cyl+1);
 35573                                  
 35574                                  		;sub	ax,[part_table_start_cyl+si]
 35575                                  		;neg	ax
 35576                                  		;dec	ax
 35577                                  		;mov	dx,ax
 35578                                  		
 35579                                  		;;mov	al,22
 35580                                  		;mov	al,10
 35581                                  		;;imul	byte [freespace_count]
 35582                                  		;mul	byte [freespace_count]
 35583                                  		;mov	bx,ax
 35584                                  
 35585                                  		;mov	[free_space.space+bx],dx  ; free_space[freespace_count].space
 35586                                  
 35587 00005181 89D0                    		mov	ax,dx  ; part_table[cur_disk][last_found_partition].end_cyl
 35588 00005183 2B84[15C4]              		sub	ax,[part_table_start_cyl+si] ; part_table[cur_disk][sort[i]].start_cyl
 35589 00005187 F7D8                    		neg	ax
 35590 00005189 48                      		dec	ax  ; - 1		
 35591                                  
 35592 0000518A 8985[E2CB]              		mov	[free_space.space+di],ax  ; free_space[freespace_count].space
 35593                                  fpfs_11:
 35594                                  	;free_space[freespace_count].start = part_table[cur_disk][last_found_partition].end_cyl+1;
 35595                                          ;free_space[freespace_count].end = part_table[cur_disk][sort[i]].start_cyl-1;
 35596                                          ;free_space[freespace_count].mbytes_unused =
 35597                                          ;	cylinders_to_mbytes(free_space[freespace_count].space,cur_disk);
 35598                                          ;free_space[freespace_count].percent_unused = (unsigned)
 35599                                          ;       cylinders_to_percent(free_space[freespace_count].space,total_disk[cur_disk]);
 35600                                  
 35601                                  		;mov	al,[cur_disk]
 35602                                  		;cbw
 35603                                  		;shl	ax,1
 35604                                  		;shl	ax,1
 35605                                  		;mov	cx,ax
 35606                                  		;mov	al,[last_found_partition]
 35607                                  		;cbw
 35608                                  		;add	ax,cx
 35609                                  		;mov	bx,46
 35610                                  		;imul	bx
 35611                                  		;mov	si,ax
 35612                                  		;mov	ax,[part_table_end_cyl+si]
 35613                                  		;inc	ax
 35614                                  		;mov	dx,ax
 35615                                  		
 35616 0000518E 42                      		inc	dx ;  part_table[cur_disk][last_found_partition].end_cyl+1
 35617                                  
 35618                                  		;mov	al,22
 35619                                  		;imul	byte [freespace_count]
 35620                                  		;mov	si,ax
 35621                                  		;mov	[free_space.start+si],dx
 35622                                  		
 35623 0000518F 8995[E4CB]              		mov	[free_space.start+di],dx ; ***
 35624                                  		
 35625 00005193 8A46F6                  		mov	al,[fpfs_i]
 35626 00005196 98                      		cbw
 35627                                  		;mov	di,ax
 35628                                  		;mov	al,[sort+di]
 35629 00005197 89C3                    		mov	bx,ax
 35630 00005199 8A87[E2C3]              		mov	al,[sort+bx]		
 35631                                  
 35632                                  		;cbw
 35633                                  		;add	ax,cx
 35634 0000519D 00C8                    		add	al,cl ; =**=
 35635                                  		
 35636                                  		;mov	cl,[cur_disk]
 35637                                  		;imul	bx
 35638                                  		;mov	bx,ax
 35639                                  
 35640                                  		; 17/01/2019
 35641 0000519F B12E                    		mov	cl,46
 35642 000051A1 F6E1                    		mul	cl
 35643 000051A3 89C6                    		mov	si,ax
 35644                                  		
 35645                                  		;mov	ax,[part_table_start_cyl+bx]
 35646 000051A5 8B84[15C4]              		mov	ax,[part_table_start_cyl+si] ;****
 35647 000051A9 48                      		dec	ax
 35648                                  		;mov	[free_space.end+si],ax
 35649 000051AA 8985[E6CB]              		mov	[free_space.end+di],ax ;***
 35650                                  
 35651                                  		;mov	al,[cur_disk]
 35652                                  		;push	ax
 35653                                  		;push	word [free_space.space+si]
 35654                                  		
 35655 000051AE 8A1E[D4CB]              		mov	bl,[cur_disk]
 35656                                  		; bh = 0
 35657 000051B2 8B85[E2CB]              		mov	ax,[free_space.space+di] ;***
 35658 000051B6 E8A3C3                  		call	cylinders_to_mbytes
 35659                                  		;pop	bx
 35660                                  		;pop	bx
 35661                                  		;mov	[free_space.mbytes_unused+si],ax
 35662                                  		
 35663 000051B9 8985[E8CB]              		mov	[free_space.mbytes_unused+di],ax ;***
 35664                                  
 35665 000051BD A0[D4CB]                		mov	al,[cur_disk]
 35666 000051C0 98                      		cbw
 35667 000051C1 89C3                    		mov	bx,ax
 35668 000051C3 D1E3                    		shl	bx,1
 35669                                  		;push	word [total_disk+bx]
 35670 000051C5 8B8F[B8A0]              		mov	cx,[total_disk+bx] ; -divisor-
 35671                                  		;push	word [free_space.space+si]
 35672 000051C9 8B9D[E2CB]              		mov	bx,[free_space.space+di] ;*** -dividend-
 35673 000051CD E8DFC3                  		call	cylinders_to_percent
 35674                                  		;pop	bx
 35675                                  		;pop	bx
 35676                                  
 35677                                  		;mov	[free_space.percent_unused+si],ax
 35678 000051D0 8985[EACB]              		mov	[free_space.percent_unused+di],ax ;***
 35679                                  
 35680                                  		; 17/01/2019
 35681                                  		;mov	al,[sort+di]
 35682                                  
 35683 000051D4 8A5EF6                  		mov	bl,[fpfs_i]
 35684 000051D7 30FF                    		xor	bh,bh
 35685 000051D9 8A87[E2C3]              		mov	al,[sort+bx]
 35686                                  		
 35687 000051DD 8846F8                  		mov	[last_found_partition],al
 35688                                  
 35689 000051E0 FE46FC                  		inc	byte [freespace_count]
 35690                                  fpfs_12:
 35691 000051E3 FE46F6                  		inc	byte [fpfs_i]
 35692                                  fpfs_13:
 35693                                  	;  for (i = partition_count+1; i < c(4); i++)
 35694                                  
 35695 000051E6 807EF604                		cmp	byte [fpfs_i],4
 35696 000051EA 7D03                    		jge	short fpfs_14
 35697 000051EC E957FF                  		jmp	fpfs_9
 35698                                  fpfs_14:
 35699                                  	;/* Find the space between the last partition and the end of the disk */
 35700                                  	;/* Make sure that freespace cannot become negative */
 35701                                  	;
 35702                                  	;  if ( total_disk[cur_disk] >
 35703                                  	;     part_table[cur_disk][last_found_partition].end_cyl )
 35704                                  
 35705 000051EF A0[D4CB]                		mov	al,[cur_disk]
 35706 000051F2 98                      		cbw
 35707                                  		;mov	bx,ax
 35708                                  		;mov	al,[last_found_partition]
 35709                                  		;cbw
 35710                                  		;mov	cx,bx
 35711                                  		;shl	bx,1
 35712                                  		;shl	bx,1
 35713                                  		;add	ax,bx
 35714 000051F3 D0E0                    		shl	al,1
 35715 000051F5 89C6                    		mov	si,ax
 35716 000051F7 D0E0                    		shl	al,1
 35717 000051F9 0246F8                  		add	al,[last_found_partition]
 35718                                  		;mov	bx,46
 35719                                  		;imul	bx
 35720                                  		;mov	bx,ax
 35721                                  		;mov	si,cx
 35722                                  		;shl	si,1
 35723 000051FC B12E                    		mov	cl,46
 35724 000051FE F6E1                    		mul	cl
 35725 00005200 89C3                    		mov	bx,ax
 35726 00005202 8B84[B8A0]              		mov	ax,[total_disk+si]
 35727 00005206 3987[1AC4]              		cmp	[part_table_end_cyl+bx],ax
 35728 0000520A 7203                    		jb	short fpfs_15
 35729 0000520C E98B00                  		jmp	fpfs_18
 35730                                  fpfs_15:
 35731                                  	;free_space[freespace_count].space = (total_disk[cur_disk]
 35732                                  	;      	-  part_table[cur_disk][last_found_partition].end_cyl)-1;
 35733                                  	;free_space[freespace_count].start = part_table[cur_disk][last_found_partition].end_cyl+1;
 35734                                  	;free_space[freespace_count].end = total_disk[cur_disk]-1;
 35735                                  	;free_space[freespace_count].mbytes_unused =
 35736                                  	;      	cylinders_to_mbytes(free_space[freespace_count].space,cur_disk);
 35737                                  	;free_space[freespace_count].percent_unused =
 35738                                  	;      	cylinders_to_percent(free_space[freespace_count].space,total_disk[cur_disk]);
 35739                                  
 35740 0000520F 89C1                    		mov	cx,ax
 35741 00005211 2B87[1AC4]              		sub	ax,[part_table_end_cyl+bx]
 35742 00005215 48                      		dec	ax
 35743 00005216 89C2                    		mov	dx,ax
 35744                                  		;mov	al,22
 35745 00005218 B00A                    		mov	al,10
 35746                                  		;imul	byte [freespace_count]
 35747 0000521A F666FC                  		mul	byte [freespace_count]
 35748 0000521D 89C6                    		mov	si,ax
 35749 0000521F 8994[E2CB]              		mov	[free_space.space+si],dx
 35750 00005223 8B87[1AC4]              		mov	ax,[part_table_end_cyl+bx]
 35751 00005227 40                      		inc	ax
 35752 00005228 8984[E4CB]              		mov	[free_space.start+si],ax
 35753 0000522C 49                      		dec	cx
 35754 0000522D 898C[E6CB]              		mov	[free_space.end+si],cx
 35755                                  		
 35756                                  		;mov	al,[cur_disk]
 35757                                  		;push	ax
 35758 00005231 8A1E[D4CB]              		mov	bl,[cur_disk]
 35759 00005235 30FF                    		xor	bh,bh
 35760                                  		;push	word [free_space.space+si]
 35761 00005237 8B84[E2CB]              		mov	ax,[free_space.space+si]
 35762 0000523B E81EC3                  		call	cylinders_to_mbytes
 35763                                  		;pop	bx
 35764                                  		;pop	bx
 35765 0000523E 8984[E8CB]              		mov	[free_space.mbytes_unused+si],ax
 35766 00005242 A0[D4CB]                		mov	al,[cur_disk]
 35767 00005245 98                      		cbw
 35768 00005246 89C3                    		mov	bx,ax
 35769 00005248 D1E3                    		shl	bx,1
 35770                                  		;push	word [total_disk+bx]
 35771 0000524A 8B8F[B8A0]              		mov	cx,[total_disk+bx]
 35772                                  		;push	word [free_space.space+si]
 35773 0000524E 8B9C[E2CB]              		mov	bx,[free_space.space+si]
 35774 00005252 E85AC3                  		call	cylinders_to_percent
 35775                                  		;pop	bx
 35776                                  		;pop	bx
 35777 00005255 8984[EACB]              		mov	[free_space.percent_unused+si],ax
 35778 00005259 EB3F                    		jmp	short fpfs_18
 35779                                  fpfs_16:
 35780                                  		;/* No partitions found, show entire space as free */
 35781                                  
 35782                                  		;free_space[0].start = u(0);
 35783                                  
 35784 0000525B 29C0                    		sub	ax,ax
 35785                                  		;mov	word [free_space.start],0
 35786                                  
 35787                                  	;/* This is a special case - the extended partition can not start */
 35788                                  	;/* on cylinder 0 due too its architecture. Protect against that here */
 35789                                  	;if (type == c(EXTENDED))
 35790                                  	;   BEGIN
 35791                                  	;      free_space[0].start = u(1);
 35792                                  	;   END
 35793 0000525D 807EF405                		cmp	byte [fpfs_type],5 ; EXTENDED
 35794 00005261 7502                    		jne	short fpfs_17
 35795                                  		
 35796                                  		;mov	word [free_space.start],1
 35797 00005263 FEC0                    		inc	al
 35798                                  fpfs_17:
 35799 00005265 A3[E4CB]                		mov	[free_space.start],ax ; 0 or 1
 35800                                  
 35801                                  	;free_space[0].end = total_disk[cur_disk]-1;
 35802                                  	;free_space[0].space = (free_space[0].end - free_space[0].start)+1;
 35803                                  	;free_space[0].mbytes_unused =
 35804                                  	;     cylinders_to_mbytes(free_space[0].space,cur_disk);
 35805                                  	;free_space[0].percent_unused =
 35806                                  	;     cylinders_to_percent(free_space[0].space,total_disk[cur_disk]);
 35807                                  
 35808 00005268 A0[D4CB]                		mov	al,[cur_disk]
 35809 0000526B 98                      		cbw
 35810                                  		;mov	bx,ax
 35811                                  		;shl	bx,1
 35812                                  		;mov	ax,[total_disk+bx]
 35813 0000526C D0E0                    		shl	al,1
 35814 0000526E 89C6                    		mov	si,ax
 35815 00005270 8B84[B8A0]              		mov	ax,[total_disk+si] 
 35816 00005274 48                      		dec	ax
 35817 00005275 A3[E6CB]                		mov	[free_space.end],ax
 35818 00005278 2B06[E4CB]              		sub	ax,[free_space.start]
 35819 0000527C 40                      		inc	ax
 35820 0000527D A3[E2CB]                		mov	[free_space.space],ax
 35821                                  		;mov	cl,[cur_disk]
 35822                                  		;push	cx
 35823                                  		;push	ax
 35824 00005280 30FF                    		xor	bh,bh
 35825 00005282 8A1E[D4CB]              		mov	bl,[cur_disk]
 35826 00005286 E8D3C2                  		call	cylinders_to_mbytes
 35827                                  		;pop	bx
 35828                                  		;pop	bx
 35829 00005289 A3[E8CB]                		mov	[free_space.mbytes_unused],ax
 35830                                  		;mov	al,[cur_disk]
 35831                                  		;cbw
 35832                                  		;mov	bx,ax
 35833                                  		;shl	bx,1
 35834                                  		;push	word [total_disk+bx]
 35835 0000528C 8B8C[B8A0]              		mov	cx,[total_disk+si] 
 35836                                  		;push	word [free_space.space]
 35837 00005290 8B1E[E2CB]              		mov	bx,[free_space.space]
 35838 00005294 E818C3                  		call	cylinders_to_percent
 35839                                  		;pop	bx
 35840                                  		;pop	bx
 35841 00005297 A3[EACB]                		mov	[free_space.percent_unused],ax
 35842                                  fpfs_18:
 35843                                  	;/* Find largest free space, and verify the golden tracks while we are at it */
 35844                                  	;         do
 35845                                  	;            BEGIN
 35846                                  	;             temp = u(0);
 35847                                  	;
 35848                                  	;             /* Zip thru the table */
 35849                                  	;             for (i = c(0); i < c(5); i++)
 35850                                  	;                BEGIN
 35851                                  	;                 /* Is this one bigger ? */
 35852                                  	;                 if (free_space[i].space > temp)
 35853                                  	;                    BEGIN
 35854                                  	;                     temp = free_space[i].space;
 35855                                  	;                     last_found_partition = i;
 35856                                  	;                    END
 35857                                  	;                END
 35858                                  
 35859 0000529A 29C0                    		sub	ax,ax
 35860 0000529C 8946FA                  		mov	[fpfs_temp],ax ; 0
 35861 0000529F 8846F6                  		mov	[fpfs_i],al ; 0
 35862                                  fpfs_19:
 35863                                  		;mov	al,22
 35864 000052A2 B00A                    		mov	al,10
 35865                                  		;imul	byte [fpfs_i]
 35866 000052A4 F666F6                  		mul	byte [fpfs_i]
 35867 000052A7 89C3                    		mov	bx,ax
 35868                                  		; 17/01/2019
 35869                                  		;mov	ax,[fpfs_temp]
 35870                                  		;cmp	[free_space.space+bx],ax
 35871                                  		;jbe	short fpfs_20
 35872 000052A9 8B87[E2CB]              		mov	ax,[free_space.space+bx] 
 35873 000052AD 3B46FA                  		cmp	ax,[fpfs_temp]
 35874 000052B0 7609                    		jbe	short fpfs_20
 35875                                  		;mov	ax,[free_space.space+bx]
 35876 000052B2 8946FA                  		mov	[fpfs_temp],ax
 35877 000052B5 8A46F6                  		mov	al,[fpfs_i]
 35878 000052B8 8846F8                  		mov	[last_found_partition],al
 35879                                  fpfs_20:
 35880 000052BB FE46F6                  		inc	byte [fpfs_i]
 35881                                  
 35882 000052BE 807EF605                		cmp	byte [fpfs_i],5
 35883 000052C2 72DE                    		jb	short fpfs_19
 35884                                  
 35885                                  		;/* If there is any free space, go verify it */
 35886                                  
 35887 000052C4 C746FA0000              		mov	word [fpfs_temp],0
 35888                                  
 35889                                  		;mov	al,22
 35890                                  		;imul	byte [last_found_partition]
 35891 000052C9 B00A                    		mov	al,10
 35892 000052CB F666F8                  		mul	byte [last_found_partition]
 35893 000052CE 89C3                    		mov	bx,ax
 35894                                  
 35895                                  	;if (free_space[last_found_partition].space != u(0))
 35896                                  	;   BEGIN
 35897                                  	;     /* Go verify the tracks */
 35898                                  	;    temp = verify_tracks(last_found_partition,c(PRIMARY));
 35899                                  	;  END
 35900 000052D0 83BF[E2CB]00            		cmp	word [free_space.space+bx],0
 35901 000052D5 740D                    		je	short fpfs_21
 35902                                  
 35903 000052D7 28C0                    		sub	al,al ; 0 ; type = PRIMARY
 35904 000052D9 50                      		push	ax
 35905 000052DA 8A46F8                  		mov	al,[last_found_partition] ; pointer
 35906 000052DD 50                      		push	ax
 35907 000052DE E8FD07                  		call	verify_tracks
 35908                                  		;pop	bx
 35909                                  		;pop	bx
 35910 000052E1 8946FA                  		mov	[fpfs_temp],ax	; offset from original cylinder number
 35911                                  fpfs_21:
 35912                                  
 35913                                  ; /* Move up to next golden track */
 35914                                  ;free_space[last_found_partition].start = free_space[last_found_partition].start+temp;
 35915                                  ;free_space[last_found_partition].space = free_space[last_found_partition].space-temp;
 35916                                  ;free_space[last_found_partition].mbytes_unused =
 35917                                  ;        cylinders_to_mbytes(free_space[last_found_partition].space,cur_disk);
 35918                                  ;free_space[last_found_partition].percent_unused = (unsigned)
 35919                                  ;        cylinders_to_percent(free_space[last_found_partition].space,total_disk[cur_disk]);
 35920                                  
 35921                                  		;mov	al,22
 35922 000052E4 B00A                    		mov	al,10
 35923                                  		;imul	byte [last_found_partition]
 35924 000052E6 F666F8                  		mul	byte [last_found_partition] 
 35925 000052E9 89C3                    		mov	bx,ax
 35926 000052EB 8B46FA                  		mov	ax,[fpfs_temp]
 35927 000052EE 0187[E4CB]              		add	[free_space.start+bx],ax
 35928                                  		;mov	cl,[cur_disk]
 35929                                  		;push	cx
 35930 000052F2 2987[E2CB]              		sub	[free_space.space+bx],ax
 35931                                  		;push	word [free_space.space+bx]
 35932 000052F6 8B87[E2CB]              		mov	ax,[free_space.space+bx]
 35933 000052FA 89DE                    		mov	si,bx ; *
 35934 000052FC 8A1E[D4CB]              		mov	bl,[cur_disk]
 35935                                  		; bh = 0
 35936 00005300 E859C2                  		call	cylinders_to_mbytes
 35937                                  		;pop	bx
 35938                                  		;pop	bx
 35939 00005303 8984[E8CB]              		mov	[free_space.mbytes_unused+si],ax ; *
 35940                                  		
 35941 00005307 A0[D4CB]                		mov	al,[cur_disk]
 35942 0000530A 98                      		cbw
 35943 0000530B 89C3                    		mov	bx,ax
 35944 0000530D D1E3                    		shl	bx,1
 35945                                  		;push	word [total_disk+bx]
 35946 0000530F 8B8F[B8A0]              		mov	cx,[total_disk+bx]
 35947                                  		;push	word [free_space.space+si]
 35948 00005313 8B9C[E2CB]              		mov	bx,[free_space.space+si] ; *
 35949 00005317 E895C2                  		call	cylinders_to_percent
 35950                                  		;pop	bx
 35951                                  		;pop	bx
 35952 0000531A 8984[EACB]              		mov	[free_space.percent_unused+si],ax ; *
 35953                                  
 35954                                  	;/* Repeat the loop if the start was moved due to bad tracks */
 35955                                  	;/* Unless we're past the end of the free space */
 35956                                  	; while ((temp != u(0)) && (free_space[last_found_partition].space != u(0))); 
 35957                                  
 35958 0000531E 29C0                    		sub	ax,ax ; 17/01/2019
 35959                                  
 35960                                  		;cmp	word [fpfs_temp],0
 35961 00005320 3946FA                  		cmp	[fpfs_temp],ax ; 0
 35962 00005323 7409                    		je	short fpfs_22
 35963                                  
 35964                                  		;;mov	al,22
 35965                                  		;mov	al,10
 35966                                  		;;imul	byte [last_found_partition]
 35967                                  		;mul	byte [last_found_partition]
 35968                                  		;mov	bx,ax
 35969                                  		;cmp	word [free_space.space+bx],0
 35970                                  		;je	short fpfs_22
 35971                                  		;jmp	fpfs_18
 35972                                  
 35973                                  		; 17/01/2019
 35974                                  		;cmp	word [free_space.space+si],0 ; *
 35975 00005325 3984[E2CB]              		cmp	[free_space.space+si],ax ; 0
 35976 00005329 7403                    		je	short short fpfs_22
 35977 0000532B E96CFF                  		jmp	fpfs_18
 35978                                  fpfs_22:
 35979                                  ;if((type == c(PRIMARY)) && (free_space[last_found_partition].mbytes_unused > u(MAX_PART_SIZE)))
 35980                                  
 35981                                  		;cmp	byte [fpfs_type],0 ; 0 for primary dos partition
 35982 0000532E 3846F4                  		cmp	[fpfs_type],al ; 0
 35983 00005331 7541                    		jne	short fpfs_23	   ; 5 for extended partition	
 35984                                  		
 35985                                  		; 17/01/2019
 35986                                  
 35987                                  		;;mov	al,22
 35988                                  		;mov	al,10
 35989                                  		;;imul	byte [last_found_partition]
 35990                                  		;mul	byte [last_found_partition]
 35991                                  		;mov	bx,ax
 35992                                  
 35993                                  	;/* Don't create a partition larger than DOS can handle */
 35994                                  
 35995                                  fefs_18: ; 20/01/2019
 35996                                  		;cmp	word [free_space.mbytes_unused+bx],2048 ; 2GB limit
 35997 00005333 81BC[E8CB]0008          		cmp	word [free_space.mbytes_unused+si],2048 ; 17/01/2019
 35998 00005339 7639                    		jbe	short fpfs_23
 35999                                  
 36000 0000533B A0[D4CB]                		mov	al,[cur_disk]
 36001                                  		;xor	ah,ah ; ah = 0
 36002                                  		;mov	di,ax ; *
 36003                                  
 36004 0000533E 50                      		push	ax ; * ; 19/01/2019
 36005                                  
 36006 0000533F 50                      		push	ax
 36007 00005340 B80008                  		mov	ax,2048
 36008 00005343 50                      		push	ax
 36009                                  		;mov	si,bx
 36010 00005344 E87803                  		call	mbytes_to_cylinders
 36011                                  		;pop	bx
 36012                                  		;pop	bx
 36013                                  
 36014 00005347 5F                      		pop	di ; * ; 20/01/2019
 36015                                  
 36016 00005348 48                      		dec	ax  ; max. available cylinders (for DOS partition)
 36017                                  
 36018 00005349 8984[E2CB]              		mov	[free_space.space+si],ax
 36019                                  		
 36020                                  		;mov	ax,[free_space.start+si]
 36021                                  		;add	ax,[free_space.space+si]
 36022                                  
 36023 0000534D 0384[E4CB]              		add	ax,[free_space.start+si]
 36024                                   
 36025 00005351 48                      		dec	ax
 36026 00005352 8984[E6CB]              		mov	[free_space.end+si],ax
 36027                                  
 36028                                  		;mov	al,[cur_disk]
 36029                                  		;push	ax
 36030                                  		;push	word [free_space.space+si]
 36031 00005356 8B84[E2CB]              		mov	ax,[free_space.space+si]
 36032 0000535A 89FB                    		mov	bx,di ; *
 36033 0000535C E8FDC1                  		call	cylinders_to_mbytes
 36034                                  		;pop	bx
 36035                                  		;pop	bx
 36036                                  
 36037 0000535F 8984[E8CB]              		mov	[free_space.mbytes_unused+si],ax
 36038                                  
 36039                                  		;mov	al,[cur_disk]
 36040                                  		;cbw
 36041                                  		;mov	bx,ax
 36042                                  		;mov	bx,di ; *
 36043                                  		;shl	bl,1
 36044                                  		;;push	word [total_disk+bx]
 36045                                  		;mov	cx,[total_disk+bx]
 36046 00005363 D1E7                    		shl	di,1 ; *
 36047 00005365 8B8D[B8A0]              		mov	cx,[total_disk+di] ; 20/01/2019 
 36048                                  		;push	word [free_space.space+si]
 36049 00005369 8B9C[E2CB]              		mov	bx,[free_space.space+si]
 36050 0000536D E83FC2                  		call	cylinders_to_percent
 36051                                  		;pop	bx
 36052                                  		;pop	bx
 36053 00005370 8984[EACB]              		mov	[free_space.percent_unused+si],ax
 36054                                  fpfs_23:
 36055                                  	; /* Return with the pointer to the largest free space */
 36056                                  
 36057 00005374 8A46F8                  		mov	al,[last_found_partition] ; mov al,[bp-8]
 36058                                  
 36059                                  		;pop	si
 36060                                  		;pop	di
 36061                                  
 36062 00005377 89EC                    		mov	sp,bp
 36063 00005379 5D                      		pop	bp
 36064 0000537A C3                      		retn
 36065                                  
 36066                                  ; ----------------------------------------------------------------------------
 36067                                  ; input.c (FDISK, MSDOS 6.0, 1991)	
 36068                                  ; ----------------------------------------------------------------------------
 36069                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 17/01/2019)
 36070                                  
 36071                                  ;XFLOAT get_large_num_input(input_default,max_num,max_percent,input_message,prompt_location,error_message)
 36072                                  ;
 36073                                  ;unsigned    input_default;                                          /* AC000 */
 36074                                  ;unsigned    max_num;
 36075                                  ;unsigned    max_percent;
 36076                                  ;char far   *input_message;
 36077                                  ;char far   *error_message;
 36078                                  ;unsigned   prompt_location;
 36079                                  ;
 36080                                  ;BEGIN
 36081                                  ;
 36082                                  ;    char           input;
 36083                                  ;    XFLOAT         large_input;                                     /* AC000 */
 36084                                  ;    char           default_used;
 36085                                  ;    FLAG           enter_flag;                                       /*C12*/
 36086                                  ;
 36087                                  ;    /* Assume bad input */
 36088                                  ;    valid_input = FALSE;
 36089                                  ;
 36090                                  ;    /* Assume no input, and use default */
 36091                                  ;    default_used = TRUE;
 36092                                  ;
 36093                                  ;    /* Assume ENTER key not pressed yet */                           /*C12*/
 36094                                  ;    enter_flag = FALSE;                                              /*C12*/
 36095                                  ;
 36096                                  ;    /* Initialize the input value */
 36097                                  ;    large_input = u(0);                                             /* AC000 */
 36098                                  ;
 36099                                  ;    /* Loop until we get good stuff */
 36100                                  ;    while (valid_input == FALSE)
 36101                                  ;
 36102                                  ;        BEGIN
 36103                                  ;        /* position the cursor */
 36104                                  ;        VIOSETCURPOS(input_row,input_col,u(0));                     /* AC000 */
 36105                                  ;
 36106                                  ;        /* Flush the keyboard buffer and get the next pressed key */
 36107                                  ;
 36108                                  ;        input = get_char_input();
 36109                                  ;
 36110                                  ;        /* Go handle different inputs */
 36111                                  ;        switch(input)
 36112                                  ;            BEGIN
 36113                                  ;            case ESC:
 36114                                  ;                valid_input = TRUE;
 36115                                  ;                large_input = ((unsigned)(ESC_FLAG));
 36116                                  ;                break;
 36117                                  ;
 36118                                  ;            case CR:
 36119                                  ;                BEGIN
 36120                                  ;                if (PercentFlag)
 36121                                  ;                    BEGIN
 36122                                  ;                    /* Set the input to the default if there is one there and nothing else entered */
 36123                                  ;                    if ((input_default != u(NUL)) && (default_used))  /* AC000 */
 36124                                  ;                        large_input = input_default;
 36125                                  ;                    /* See if input is less or equal to max_value */
 36126                                  ;                    if (large_input <= max_percent)
 36127                                  ;                        BEGIN
 36128                                  ;                        if (large_input != u(0))
 36129                                  ;                            valid_input = TRUE;
 36130                                  ;                        else
 36131                                  ;                            display(error_28);
 36132                                  ;                        END
 36133                                  ;                    else
 36134                                  ;                        display(error_message);
 36135                                  ;                    END
 36136                                  ;                else
 36137                                  ;                    BEGIN
 36138                                  ;                    /* Set the input to the default if there is one there and nothing else entered */
 36139                                  ;                    if ((input_default != u(NUL)) && (default_used))  /* AC000 */
 36140                                  ;                        large_input = input_default;
 36141                                  ;                    /* See if input is less or equal to max_value */
 36142                                  ;                    if (large_input <= max_num)
 36143                                  ;                        BEGIN
 36144                                  ;                        if (large_input != u(0))
 36145                                  ;                            valid_input = TRUE;
 36146                                  ;                        else
 36147                                  ;                            display(error_28);
 36148                                  ;                        END
 36149                                  ;                    else
 36150                                  ;                        display(error_message);
 36151                                  ;                    END
 36152                                  ;                enter_flag = TRUE;                                      /*C12*/
 36153                                  ;                break;
 36154                                  ;                END
 36155                                  ;
 36156                                  ;            case BACKSPACE:
 36157                                  ;                if (PercentFlag)
 36158                                  ;                    PercentFlag = (FLAG)FALSE;                      /* AN000 */
 36159                                  ;                else
 36160                                  ;                    large_input = large_input / 10;
 36161                                  ;
 36162                                  ;                /* Indicate that we are not using the default */
 36163                                  ;                default_used = FALSE;
 36164                                  ;                sprintf(&insert[prompt_location],"%4.0d",large_input);  /* AN000 */
 36165                                  ;                display(input_message);
 36166                                  ;                break;
 36167                                  ;
 36168                                  ;            case PERCENT:                                           /* AN000 */
 36169                                  ;
 36170                                  ;                if (PercentFlag == (FLAG)FALSE)
 36171                                  ;                    BEGIN                                           /* AN000 */
 36172                                  ;                    PercentFlag = (FLAG)TRUE;                       /* AN000 */
 36173                                  ;                    /* Round down if > 999.9 */
 36174                                  ;                    if (large_input > u(999))                       /* AN000 */
 36175                                  ;                        large_input = (large_input%1000);           /* AN000 */
 36176                                  ;                    sprintf(&insert[prompt_location],"%3.0d%%",large_input);  /* AN000 */
 36177                                  ;                    /* Indicate that we are not using the default */
 36178                                  ;                    default_used = FALSE;                           /* AN000 */
 36179                                  ;                    display(input_message);                         /* AN000 */
 36180                                  ;                    END                                             /* AN000 */
 36181                                  ;                else
 36182                                  ;                    display(error_33);                              /* AN000 */
 36183                                  ;
 36184                                  ;                break;                                              /* AN000 */
 36185                                  ;
 36186                                  ;            case '0':                                                   /*C12*/
 36187                                  ;            case '1':                                                   /*C12*/
 36188                                  ;            case '2':                                                   /*C12*/
 36189                                  ;            case '3':                                                   /*C12*/
 36190                                  ;            case '4':                                                   /*C12*/
 36191                                  ;            case '5':                                                   /*C12*/
 36192                                  ;            case '6':                                                   /*C12*/
 36193                                  ;            case '7':                                                   /*C12*/
 36194                                  ;            case '8':                                                   /*C12*/
 36195                                  ;            case '9':                                                   /*C12*/
 36196                                  ;                if (enter_flag == TRUE)                                 /*C12*/
 36197                                  ;                    BEGIN                                               /*C12*/
 36198                                  ;                    large_input = u(0);                                 /*C12*/
 36199                                  ;                    default_used = FALSE;                               /*C12*/
 36200                                  ;                    PercentFlag = FALSE;                                /*C12*/
 36201                                  ;                    enter_flag = FALSE;                                 /*C12*/
 36202                                  ;                    END                                                 /*C12*/
 36203                                  ;                if ((PercentFlag == FALSE) && (large_input < 1000))     /*C12*/
 36204                                  ;                    BEGIN                                               /*C12*/
 36205                                  ;                    /* Add this digit in */                             /*C12*/
 36206                                  ;                    large_input = (large_input * 10) +                  /*C12*/
 36207                                  ;                                  (XFLOAT)(input - '0');                /*C12*/
 36208                                  ;                                                                        /*C12*/
 36209                                  ;                    /* Put it in the message */                         /*C12*/
 36210                                  ;                    number_in_msg((XFLOAT)large_input,prompt_location); /*C12*/
 36211                                  ;                    display(input_message);                             /*C12*/
 36212                                  ;                                                                        /*C12*/
 36213                                  ;                    /* Indicate that we are not using the default */    /*C12*/
 36214                                  ;                    default_used = FALSE;                               /*C12*/
 36215                                  ;                    PercentFlag = (FLAG)FALSE;                          /*C12*/
 36216                                  ;                    END                                                 /*C12*/
 36217                                  ;                else                                                    /*C12*/
 36218                                  ;                    display(error_33);                                  /*C12*/
 36219                                  ;                break;                                                  /*C12*/
 36220                                  ;                                                                        /*C12*/
 36221                                  ;            default:                                                    /*C12*/
 36222                                  ;                if ((PercentFlag == FALSE) && (large_input < 1000))     /*C12*/
 36223                                  ;                    BEGIN                                               /*C12*/
 36224                                  ;                    /* Setup error message */                           /*C12*/
 36225                                  ;                    insert[0] = c('0');                                 /*C12*/
 36226                                  ;                    insert[1] = c('-');                                 /*C12*/
 36227                                  ;                    insert[2] = c('9');                                 /*C12*/
 36228                                  ;                    display(error_31);                                  /*C12*/
 36229                                  ;                    END                                                 /*C12*/
 36230                                  ;                else                                                    /*C12*/
 36231                                  ;                    display(error_33);                                  /*C12*/
 36232                                  ;            END
 36233                                  ;        END
 36234                                  ;
 36235                                  ;    return(large_input);
 36236                                  ;END
 36237                                  
 36238                                  get_large_num_input:
 36239                                  		; 17/01/2019
 36240                                  
 36241                                  	%define large_input	   bp-8
 36242                                  	%define glni_enter_flag	   bp-6
 36243                                  	%define glni_def_used	   bp-4
 36244                                  	%define glni_input	   bp-2
 36245                                  	%define glni_input_def	   bp+4
 36246                                  	%define glni_max_num	   bp+6
 36247                                  	%define glni_max_pc	   bp+8
 36248                                  	%define glni_input_msg	   bp+10
 36249                                  	%define glni_input_msg_seg bp+12
 36250                                  	%define glni_prompt_loc	   bp+14
 36251                                  	%define glni_err_msg	   bp+16
 36252                                  	%define glni_err_msg_seg   bp+18
 36253                                  
 36254 0000537B 55                      		push	bp
 36255 0000537C 89E5                    		mov	bp,sp
 36256 0000537E 83EC08                  		sub	sp,8
 36257                                  		
 36258                                  		;/* Assume no input, and use default */
 36259 00005381 C646FC01                		mov	byte [glni_def_used],1 ; default_used = TRUE;
 36260                                  
 36261 00005385 28C0                    		sub	al,al ; 0
 36262                                  
 36263                                  		;/* Assume bad input */
 36264 00005387 A2[DECB]                		mov	[valid_input],al ; valid_input = FALSE;
 36265                                  
 36266                                  		;/* Assume ENTER key not pressed yet */  
 36267 0000538A 8846FA                  		mov	[glni_enter_flag],al  ; enter_flag = FALSE;   
 36268                                  
 36269                                  		;/* Initialize the input value */
 36270 0000538D C746F80000              		mov	word [large_input],0 ; large_input = u(0);      
 36271 00005392 E99E01                  		jmp	glni_29
 36272                                  glni_1:
 36273                                  		;/* Loop until we get good stuff */
 36274                                  		;while (valid_input == FALSE)
 36275                                  
 36276                                  		;/* position the cursor */
 36277                                  		
 36278                                  		;push	word [input_row]
 36279                                  		;push	word [input_col]
 36280                                  		;sub	ax,ax
 36281                                  		;push	ax
 36282 00005395 8A36[3EA1]              		mov	dh,[input_row]
 36283 00005399 8A16[9CA0]              		mov	dl,[input_col]
 36284 0000539D E876D8                  		call	VIOSETCURPOS
 36285                                  
 36286                                  	;/* Flush the keyboard buffer and get the next pressed key */
 36287                                  
 36288 000053A0 E866D8                  		call	get_char_input  ; input = get_char_input();
 36289 000053A3 8846FE                  		mov	[glni_input],al
 36290                                  
 36291                                  	; /* Go handle different inputs */
 36292                                  		 ; switch(input)
 36293                                  switch_input12:
 36294                                  		;cbw
 36295                                  		;sub	ax,8
 36296 000053A6 2C08                    		sub	al,8  ; 08h (8)  - BACKSPACE key
 36297 000053A8 7503                    		jnz	short glni_3
 36298 000053AA E9B400                  		jmp	case_gln_backspace
 36299                                  glni_3:
 36300                                  		;sub	ax,5  ; 0Dh (13) - ENTER/CR key
 36301 000053AD 2C05                    		sub	al,5
 36302 000053AF 744B                    		jz	short case_gln_CR
 36303                                  		;sub	ax,14 ; 1Bh (27) - ESC key
 36304 000053B1 2C0E                    		sub	al,14
 36305 000053B3 743A                    		jz	short case_gln_ESC
 36306                                  		;sub	ax,10 ; 25h (37) - '%' character/key
 36307 000053B5 2C0A                    		sub	al,10
 36308 000053B7 7503                    		jnz	short glni_4
 36309 000053B9 E9DA00                  		jmp	case_gln_percent
 36310                                  glni_4:
 36311                                  		;sub	ax,11 ; 30h (48) - '0' character/key
 36312 000053BC 2C0B                    		sub	al,11 
 36313 000053BE 7207                    		jb	short case_gln_default
 36314                                  		;sub	ax,9  ; 39h (57) - '9' character/key
 36315 000053C0 2C09                    		sub	al,9
 36316 000053C2 7703                    		ja	short case_gln_default
 36317 000053C4 E91201                  		jmp	case_gln_dec_digits ; one of decimal digits
 36318                                  case_gln_default:
 36319                                  		; default:
 36320                                  	;if ((PercentFlag == FALSE) && (large_input < 1000))  
 36321 000053C7 803E[D2C3]00                		cmp	byte [PercentFlag],0
 36322 000053CC 7507                    		jne	short glni_6
 36323 000053CE 817EF8E803              		cmp	word [large_input], 1000
 36324 000053D3 7203                    		jb	short glni_7
 36325                                  glni_6:
 36326 000053D5 E95301                  		jmp	glni_27  ; else 
 36327                                  				 ;       display(error_33); 
 36328                                  glni_7:
 36329                                  		;/* Setup error message */
 36330                                  		;insert[0] = c('0');
 36331                                       		;insert[1] = c('-');
 36332                                                  ;insert[2] = c('9');       
 36333                                  		;display(error_31);   
 36334 000053D8 C606[E6CC]30            		mov	byte [insert],'0'
 36335 000053DD C606[E7CC]2D            		mov	byte [insert+1],'-'
 36336 000053E2 C606[E8CC]39            		mov	byte [insert+2],'9'
 36337                                  		;push	word [error_31_seg]
 36338 000053E7 1E                      		push	ds
 36339 000053E8 FF36[AE9E]              		push	word [error_31_off]
 36340 000053EC E94101                  		jmp	glni_28
 36341                                  case_gln_ESC:
 36342                                  		;case ESC:
 36343 000053EF C606[DECB]01            		mov	byte [valid_input],1  ; valid_input = TRUE;
 36344                                  		;large_input = ((unsigned)(ESC_FLAG));
 36345 000053F4 C746F8FEFF              		mov	word [large_input],0FFFEh
 36346 000053F9 E93701                  		jmp	glni_29  ; break;
 36347                                  case_gln_CR:
 36348 000053FC 803E[D2C3]00            		cmp	byte [PercentFlag],0  ; if (PercentFlag)
 36349 00005401 7437                    		je	short glni_15
 36350                                  	;/* Set the input to the default if there is one there and nothing else entered */
 36351                                  	;if ((input_default != u(NUL)) && (default_used)) 
 36352 00005403 837E0400                		cmp	word [glni_input_def],0
 36353 00005407 740C                    		je	short glini_10
 36354 00005409 807EFC00                		cmp	byte [glni_def_used],0
 36355 0000540D 7406                    		je	short glini_10
 36356 0000540F 8B4604                  		mov	ax,[glni_input_def]
 36357 00005412 8946F8                  		mov	[large_input],ax  ; large_input = input_default;
 36358                                  glini_10:
 36359                                  		;if (large_input <= max_percent)
 36360 00005415 8B4608                  		mov	ax,[glni_max_pc]
 36361 00005418 3946F8                  		cmp	[large_input],ax
 36362 0000541B 770D                    		ja	short glni_12 ; display(error_message);
 36363                                  		;if (large_input != u(0))
 36364 0000541D 837EF800                		cmp	word [large_input],0
 36365 00005421 7437                    		je	short glni_17  ; display(error_28);
 36366                                  glni_11:
 36367 00005423 C606[DECB]01            		mov	byte [valid_input],1  ; valid_input = TRUE;
 36368 00005428 EB09                    		jmp	short glni_14
 36369                                  glni_12:
 36370                                  		;display(error_message);
 36371 0000542A FF7612                  		push	word [glni_err_msg_seg]
 36372 0000542D FF7610                  		push	word [glni_err_msg]
 36373                                  glni_13:
 36374 00005430 E8E7C1                  		call	display
 36375                                  		;pop	bx
 36376                                  		;pop	bx
 36377                                  glni_14:
 36378 00005433 C646FA01                		mov	byte [glni_enter_flag],1  ; enter_flag = TRUE;
 36379 00005437 E9F900                  		jmp	glni_29  ; break;
 36380                                  glni_15:
 36381                                  		; else
 36382                                   	;/* Set the input to the default if there is one there and nothing else entered */
 36383                                  	;if ((input_default != u(NUL)) && (default_used))
 36384 0000543A 837E0400                		cmp	word [glni_input_def],0
 36385 0000543E 740C                    		je	short glni_16
 36386 00005440 807EFC00                		cmp	byte [glni_def_used],0
 36387 00005444 7406                    		je	short glni_16
 36388 00005446 8B4604                  		mov	ax,[glni_input_def]
 36389 00005449 8946F8                  		mov	[large_input],ax ;  large_input = input_default;
 36390                                  glni_16:
 36391                                  		;/* See if input is less or equal to max_value */
 36392                                  		;if (large_input <= max_num)
 36393 0000544C 8B4606                  		mov	ax,[glni_max_num]
 36394 0000544F 3946F8                  		cmp	[large_input],ax
 36395 00005452 77D6                    		ja	short glni_12
 36396                                  		;if (large_input != u(0))
 36397 00005454 837EF800                		cmp	word [large_input],0
 36398 00005458 75C9                    		jne	short glni_11
 36399                                  glni_17:
 36400                                  		;display(error_28);
 36401                                  		;push	word [error_28_seg]
 36402 0000545A 1E                      		push	ds
 36403 0000545B FF36[A89E]              		push	word [error_28_off]
 36404 0000545F EBCF                    		jmp	short glni_13
 36405                                  case_gln_backspace:
 36406                                  		;case BACKSPACE:
 36407 00005461 803E[D2C3]00            		cmp	byte [PercentFlag],0
 36408 00005466 7407                    		je	short glni_19
 36409 00005468 C606[D2C3]00            		mov	byte [PercentFlag],0  ; PercentFlag = (FLAG)FALSE;   
 36410 0000546D EB0D                    		jmp	short glni_20
 36411                                  glni_19:
 36412                                  		;large_input = large_input / 10;
 36413 0000546F B90A00                  		mov	cx,10
 36414 00005472 8B46F8                  		mov	ax,[large_input]
 36415 00005475 29D2                    		sub	dx,dx
 36416 00005477 F7F1                    		div	cx
 36417 00005479 8946F8                  		mov	[large_input],ax
 36418                                  glni_20:
 36419                                  		;/* Indicate that we are not using the default */
 36420 0000547C C646FC00                		mov	byte [glni_def_used],0 ; default_used = FALSE;
 36421                                  
 36422                                  	;sprintf(&insert[prompt_location],"%4.1d",large_input);
 36423                                  
 36424 00005480 FF76F8                  		push	word [large_input]
 36425 00005483 B8[846F]                		mov	ax,glni_num_format ; "%4.1d"
 36426 00005486 50                      		push	ax
 36427 00005487 8B460E                  		mov	ax,[glni_prompt_loc]
 36428 0000548A 05[E6CC]                		add	ax,insert
 36429 0000548D 50                      		push	ax
 36430 0000548E E82ACE                  		call	sprintf
 36431 00005491 83C406                  		add	sp,6
 36432 00005494 EB3B                    		jmp	short glni_24
 36433                                  case_gln_percent:
 36434                                  		;case PERCENT:    
 36435 00005496 803E[D2C3]00            		cmp	byte [PercentFlag],0
 36436 0000549B 7403                    		je	short glni_22
 36437 0000549D E98B00                  		jmp	glni_27
 36438                                  glni_22:
 36439 000054A0 C606[D2C3]01            		mov	byte [PercentFlag],1  ; PercentFlag = (FLAG)TRUE;   
 36440                                  		;/* Round down if > 999.9 */
 36441 000054A5 817EF8E703              		cmp	word [large_input],999
 36442 000054AA 760D                    		jbe	short glni_23
 36443 000054AC B9E803                  		mov	cx,1000
 36444 000054AF 8B46F8                  		mov	ax,[large_input]
 36445 000054B2 29D2                    		sub	dx,dx
 36446 000054B4 F7F1                    		div	cx
 36447 000054B6 8956F8                  		mov	[large_input],dx
 36448                                  glni_23:
 36449 000054B9 FF76F8                  		push	word [large_input]
 36450 000054BC B8[976F]                		mov	ax,percent_format ; "%3.1d%%"
 36451 000054BF 50                      		push	ax
 36452 000054C0 8B460E                  		mov	ax,[glni_prompt_loc]
 36453 000054C3 05[E6CC]                		add	ax,insert
 36454 000054C6 50                      		push	ax
 36455 000054C7 E8F1CD                  		call	sprintf
 36456 000054CA 83C406                  		add	sp,6
 36457                                  		;/* Indicate that we are not using the default */
 36458 000054CD C646FC00                		mov	byte [glni_def_used],0 ; default_used = FALSE;
 36459                                  glni_24:
 36460                                  		; display(input_message);
 36461 000054D1 FF760C                  		push	word [glni_input_msg_seg]
 36462 000054D4 FF760A                  		push	word [glni_input_msg]
 36463 000054D7 EB57                    		jmp	short glni_28
 36464                                  case_gln_dec_digits:
 36465                                  		;case '0': 
 36466                                  		;...
 36467                                              	;case '9':  
 36468                                  		;if (enter_flag == TRUE) 
 36469 000054D9 807EFA01                		cmp	byte [glni_enter_flag],1
 36470 000054DD 7510                    		jne	short glni_26
 36471 000054DF 29C0                    		sub	ax,ax
 36472                                  		;mov	word [large_input],0  ; large_input = u(0);
 36473 000054E1 8946F8                  		mov	[large_input],ax ; 0
 36474                                  		;sub	al,al
 36475 000054E4 8846FC                  		mov	[glni_def_used],al ; default_used = FALSE; 
 36476 000054E7 A2[D2C3]                		mov	[PercentFlag],al ; PercentFlag = FALSE
 36477 000054EA 8846FA                  		mov	[glni_enter_flag],al ; enter_flag = FALSE; 
 36478 000054ED EB0E                    		jmp	short glni_31  ; 17/01/2019
 36479                                  glni_26:
 36480                                  		;if ((PercentFlag == FALSE) && (large_input < 1000))  
 36481 000054EF 803E[D2C3]00            		cmp	byte [PercentFlag],0
 36482 000054F4 7535                    		jne	short glni_27
 36483 000054F6 817EF8E803              		cmp	word [large_input],1000
 36484 000054FB 732E                    		jnb	short glni_27
 36485                                  glni_31:
 36486                                  		;/* Add this digit in */ 
 36487                                  		
 36488                                  	;large_input = (large_input * 10) + (XFLOAT)(input - '0');  
 36489                                  
 36490                                  	; /* Put it in the message */
 36491                                          ;    number_in_msg((XFLOAT)large_input,prompt_location)
 36492                                  
 36493 000054FD FF760E                  		push	word [glni_prompt_loc] ; numinmsg_start, start address 
 36494 00005500 8A46FE                  		mov	al,[glni_input]
 36495 00005503 98                      		cbw
 36496 00005504 89C1                    		mov	cx,ax
 36497 00005506 B80A00                  		mov	ax,10
 36498 00005509 F766F8                  		mul	word [large_input]
 36499 0000550C 01C8                    		add	ax,cx
 36500 0000550E 83E830                  		sub	ax,'0'
 36501 00005511 8946F8                  		mov	[large_input],ax
 36502 00005514 50                      		push	ax	; numinmsg_num, number
 36503 00005515 E8D9DA                  		call	number_in_msg
 36504                                  		;pop	bx
 36505                                  		;pop	bx
 36506                                  		
 36507                                  		;display(input_message);  
 36508 00005518 FF760C                  		push	word [glni_input_msg_seg]
 36509 0000551B FF760A                  		push	word [glni_input_msg]
 36510 0000551E E8F9C0                  		call	display
 36511                                  		;pop	bx
 36512                                  		;pop	bx
 36513                                  		
 36514                                  		;/* Indicate that we are not using the default */
 36515 00005521 28C0                    		sub	al,al ; 0
 36516 00005523 8846FC                  		mov	[glni_def_used],al  ; default_used = FALSE; 
 36517 00005526 A2[D2C3]                		mov	[PercentFlag],al ; PercentFlag = (FLAG)FALSE;   
 36518 00005529 EB08                    		jmp	short glni_29
 36519                                  glni_27:
 36520                                  		;display(error_33); 
 36521                                  		;push	word [error_33_seg]
 36522 0000552B 1E                      		push	ds
 36523 0000552C FF36[B29E]              		push	word [error_33_off]
 36524                                  glni_28:
 36525 00005530 E8E7C0                  		call	display
 36526                                  		;pop	bx
 36527                                  		;pop	bx
 36528                                  glni_29:
 36529                                  		;/* Loop until we get good stuff */
 36530                                      		;while (valid_input == FALSE)
 36531 00005533 803E[DECB]00            		cmp	byte [valid_input],0
 36532 00005538 7503                    		jne	short glni_30
 36533 0000553A E958FE                  		jmp	glni_1
 36534                                  glni_30:
 36535                                  		;return(large_input);
 36536 0000553D 8B46F8                  		mov	ax,[large_input]
 36537                                  		
 36538 00005540 89EC                    		mov	sp,bp
 36539 00005542 5D                      		pop	bp
 36540                                  		;retn
 36541 00005543 C21000                  		retn	16
 36542                                  
 36543                                  ; ----------------------------------------------------------------------------
 36544                                  ; makepart.c (FDISK, MSDOS 6.0, 1991)	
 36545                                  ; ----------------------------------------------------------------------------
 36546                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 19/01/2019)
 36547                                  
 36548                                  ;void make_partition(size,free_pointer,bootable,type)
 36549                                  ;
 36550                                  ;unsigned        size;
 36551                                  ;char            free_pointer;
 36552                                  ;unsigned char   bootable;
 36553                                  ;char            type;
 36554                                  ;
 36555                                  ;BEGIN
 36556                                  ;
 36557                                  ;    char table_pointer;
 36558                                  ;    unsigned i;
 36559                                  ;    unsigned char   temp;
 36560                                  ;    unsigned long   total_sectors;
 36561                                  ;
 36562                                  ;    /* Find a free spot to put it in */
 36563                                  ;    table_pointer = find_free_partition();
 36564                                  ;
 36565                                  ;    if (table_pointer != ((char)(NOT_FOUND)))
 36566                                  ;        BEGIN
 36567                                  ;        /* found a free partition, now lets go fill it up */
 36568                                  ;
 36569                                  ;        /* Do we need to make it active? */
 36570                                  ;        if (bootable == ((unsigned char)(ACTIVE)))
 36571                                  ;            BEGIN
 36572                                  ;
 36573                                  ;            /* Go clear out a previously active one */
 36574                                  ;            for (i=u(0); i <u(4); i++) 			/* AC000 */
 36575                                  ;                BEGIN
 36576                                  ;                if (part_table[cur_disk][i].boot_ind == uc(0x80))	/* AC000 */
 36577                                  ;                    BEGIN
 36578                                  ;                    part_table[cur_disk][i].changed = TRUE;
 36579                                  ;                    part_table[cur_disk][i].boot_ind = uc(0);	/* AC000 */
 36580                                  ;                    END
 36581                                  ;                END
 36582                                  ;
 36583                                  ;                /* Now mark the new one active */
 36584                                  ;                part_table[cur_disk][table_pointer].boot_ind = uc(0x80); /* AC000 */
 36585                                  ;            END
 36586                                  ;        else
 36587                                  ;            BEGIN
 36588                                  ;            /* Mark it as not active, leaving the others alone */
 36589                                  ;            part_table[cur_disk][table_pointer].boot_ind = uc(0);	/* AC000 */
 36590                                  ;            END
 36591                                  ;
 36592                                  ;            /* Go get the start cylinder */
 36593                                  ;            part_table[cur_disk][table_pointer].start_cyl = free_space[free_pointer].start;
 36594                                  ;
 36595                                  ;            /* Setup end cylinder */
 36596                                  ;            part_table[cur_disk][table_pointer].end_cyl = part_table[cur_disk][table_pointer].start_cyl + size - 1;
 36597                                  ;
 36598                                  ;            /* Start sector is always 1 */
 36599                                  ;            part_table[cur_disk][table_pointer].start_sector = uc(1);	/* AC000 */
 36600                                  ;
 36601                                  ;            /* End sector is always the last sector */
 36602                                  ;            part_table[cur_disk][table_pointer].end_sector = max_sector[cur_disk];
 36603                                  ;
 36604                                  ;            /* End head is always the last head */
 36605                                  ;            part_table[cur_disk][table_pointer].end_head = uc(max_head[cur_disk] -1); /* AC004 */
 36606                                  ;
 36607                                  ;            /* Start head is always 0 unless this is track 0 - then it is 1 */
 36608                                  ;            temp = uc(0);						/* AC000 */
 36609                                  ;            if (part_table[cur_disk][table_pointer].start_cyl == u(0))	/* AC000 */
 36610                                  ;                BEGIN
 36611                                  ;                temp = uc(1);						/* AC000 */
 36612                                  ;                END
 36613                                  ;            part_table[cur_disk][table_pointer].start_head = temp;
 36614                                  ;
 36615                                  ;            /* Figure out the total number of sectors */
 36616                                  ;            /* Total sectors in partition =                    */
 36617                                  ;            /* [(end_cyl - start_cyl)*(max_sector)*(max_head)] */
 36618                                  ;            /* - [start_head * max_sector]                     */
 36619                                  ;            /* Note: This is assuming a track or cylinder aligned partition */
 36620                                  ;
 36621                                  ;            /* First - get the total size in Cylinders assuming head 0 start*/
 36622                                  ;            total_sectors = ((unsigned long)(part_table[cur_disk][table_pointer].end_cyl -
 36623                                  ;                             part_table[cur_disk][table_pointer].start_cyl+1));
 36624                                  ;
 36625                                  ;            /* Now multiply it by the number of sectors and heads per track */
 36626                                  ;            total_sectors = total_sectors * max_sector[cur_disk] * max_head[cur_disk];
 36627                                  ;
 36628                                  ;            /* This will give us the total of sectors if it is cyl aligned */
 36629                                  ;            /* Now, if it isn't aligned on head 0, we need to subtract off */
 36630                                  ;            /* the skipped tracks in the first cylinder  */
 36631                                  ;
 36632                                  ;            /* Because the head is zero based, we can get the total number of */
 36633                                  ;            /* skipped sectors by multipling the head number by sectors per track */
 36634                                  ;            total_sectors = total_sectors - ((unsigned long)part_table[cur_disk][table_pointer].start_head) *
 36635                                  ;                             max_sector[cur_disk];
 36636                                  ;            part_table[cur_disk][table_pointer].num_sec = total_sectors;
 36637                                  ;
 36638                                  ;            /* Get the relative sector */
 36639                                  ;            /* Figure out the total number of sectors	*/
 36640                                  ;            /* Total sectors before partition =  	*/
 36641                                  ;            /* (start_cyl)*(max_sector)*(max_head)]	*/
 36642                                  ;            /* + [start_head * max_sector]		*/
 36643                                  ;            /* Note: This is assuming a track or cylinder aligned partition */
 36644                                  ;
 36645                                  ;            /* Start cyl will work because it is zero based */
 36646                                  ;            total_sectors = ((unsigned long)part_table[cur_disk][table_pointer].start_cyl);
 36647                                  ;
 36648                                  ;            /* Get sectors up to head 0 of the partition */
 36649                                  ;            total_sectors = total_sectors * max_sector[cur_disk] * max_head[cur_disk];
 36650                                  ;
 36651                                  ;            /* Because the head is zero based, we can get the total number of */
 36652                                  ;            /* skipped sectors by multipling the head number by sectors per track */
 36653                                  ;            total_sectors = total_sectors + ((unsigned long)part_table[cur_disk][table_pointer].start_head) *
 36654                                  ;                              max_sector[cur_disk];
 36655                                  ;            /* Save it! */
 36656                                  ;            part_table[cur_disk][table_pointer].rel_sec = total_sectors;
 36657                                  ;
 36658                                  ;            /* Setup the system id byte */
 36659                                  ;            if (type == ((char)(EXTENDED)))
 36660                                  ;                BEGIN
 36661                                  ;                temp = uc(EXTENDED);					/* AC000 */
 36662                                  ;                END
 36663                                  ;            else
 36664                                  ;                BEGIN
 36665                                  ;                if (type == ((char)(PRIMARY)))
 36666                                  ;                    BEGIN
 36667                                  ;                    /* Always set to 06h - let format worry about setting to correct value */
 36668                                  ;                    /* SR; 9/30/89; We fix up the size ourselves here. The
 36669                                  ;                       calculation is simple. If total_sectors > 65536 then
 36670                                  ;                       type = 06 else if total_sectors > 32680 then type = 04
 36671                                  ;                       else type = 01 */
 36672                                  ;
 36673                                  ;                    /* SR; 9/30/89; Calculate total_sectors from start
 36674                                  ;                       including the hidden sectors */
 36675                                  ;
 36676                                  ;                    total_sectors += part_table[cur_disk][table_pointer].num_sec;
 36677                                  ;
 36678                                  ;                    if ( (total_sectors >> 16) > 0 )
 36679                                  ;                        temp = uc(DOSNEW); /* Partition extends beyond the 32M boundary */
 36680                                  ;                    else if (part_table[cur_disk][table_pointer].num_sec > ul( FAT16_SIZE ))
 36681                                  ;                        temp = uc(DOS16);
 36682                                  ;                    else
 36683                                  ;                        temp = uc(DOS12);				/* AC000 */
 36684                                  ;                    END
 36685                                  ;                else
 36686                                  ;                    BEGIN
 36687                                  ;                    internal_program_error();
 36688                                  ;                    END
 36689                                  ;                END
 36690                                  ;
 36691                                  ;            /* We got the sys id, now put it in */
 36692                                  ;            part_table[cur_disk][table_pointer].sys_id = temp;
 36693                                  ;
 36694                                  ;            /* Set the changed flag */
 36695                                  ;            part_table[cur_disk][table_pointer].changed = TRUE;
 36696                                  ;
 36697                                  ;            /* Set the mbytes used */
 36698                                  ;            part_table[cur_disk][table_pointer].mbytes_used =
 36699                                  ;                cylinders_to_mbytes(size,cur_disk);			- /* AN004 */
 36700                                  ;
 36701                                  ;            /* Set the percent used */
 36702                                  ;            part_table[cur_disk][table_pointer].percent_used =
 36703                                  ;                cylinders_to_percent(((part_table[cur_disk][table_pointer].end_cyl-part_table[cur_disk][table_pointer].start_cyl)+1),
 36704                                  ;                total_disk[cur_disk]);                                  /* AN000 */
 36705                                  ;
 36706                                  ;            /* set the system to unknown and volume label to blanks */  /*C21*/
 36707                                  ;            strcpy(part_table[cur_disk][table_pointer].system,NOFORMAT); /*C21*/
 36708                                  ;            strcpy(part_table[cur_disk][table_pointer].vol_label,NOVOLUME); /*C21*/
 36709                                  ;        END
 36710                                  ;    else
 36711                                  ;        BEGIN
 36712                                  ;        /* This should not have happened */
 36713                                  ;        internal_program_error();
 36714                                  ;        return;
 36715                                  ;        END
 36716                                  ;
 36717                                  ;    return;
 36718                                  ;END
 36719                                  
 36720                                  make_partition:
 36721                                  		; 19/01/2019
 36722                                  
 36723                                  	;%define mp_temp4_lw	    bp-26
 36724                                  	;%define mp_temp4_hw	    bp-24
 36725                                  	;%define mp_temp3_lw	    bp-22
 36726                                  	;%define mp_temp3_hw	    bp-20
 36727                                  	;%define mp_temp2_lw	    bp-18
 36728                                  	;%define mp_temp2_hw	    bp-16
 36729                                  	;%define mp_temp1_lw	    bp-14
 36730                                  	;%define mp_temp1_hw	    bp-12
 36731                                  	
 36732                                  	%define mp_i		    bp-10
 36733                                  	%define mp_table_ptr	    bp-8
 36734                                  	%define mp_temp		    bp-6
 36735                                  	%define mp_total_sectors_lw bp-4
 36736                                  	%define mp_total_sectors_hw bp-2
 36737                                  
 36738                                  	%define mp_size		    bp+4
 36739                                  	%define mp_free_ptr	    bp+6
 36740                                  	%define mp_bootable	    bp+8
 36741                                  	%define mp_type		    bp+10
 36742                                  
 36743 00005546 55                      		push	bp
 36744 00005547 89E5                    		mov	bp,sp
 36745                                  		;sub	sp,26
 36746 00005549 83EC0A                  		sub	sp,10 ; 19/01/2019
 36747                                  		
 36748                                  		;push	di
 36749                                  		;push	si
 36750                                  
 36751                                  		;/* Find a free spot to put it in */
 36752 0000554C E8D501                  		call	find_free_partition
 36753 0000554F 8846F8                  		mov	[mp_table_ptr],al
 36754                                  		;if (table_pointer != ((char)(NOT_FOUND)))
 36755 00005552 FEC0                    		inc	al
 36756 00005554 7503                    		jnz	short mp_1 
 36757 00005556 E96101                  		jmp	mp_13
 36758                                  mp_1:
 36759                                  		;/* found a free partition, now lets go fill it up */
 36760                                  
 36761 00005559 B92E00                  		mov	cx,46 ; *- ; 19/01/2019
 36762                                  
 36763                                  		;/* Do we need to make it active? */
 36764 0000555C 807E0880                		cmp	byte [mp_bootable],80h
 36765 00005560 752E                    		jne	short mp_4
 36766                                  		
 36767                                  		;/* Go clear out a previously active one */
 36768 00005562 C646F600                		mov	byte [mp_i],0
 36769                                  mp_2:
 36770 00005566 A0[D4CB]                		mov	al,[cur_disk]
 36771                                  		;cbw
 36772                                  		;shl	ax,1
 36773                                  		;shl	ax,1
 36774                                  		;add	ax,[mp_i]
 36775 00005569 D0E0                    		shl	al,1
 36776 0000556B D0E0                    		shl	al,1
 36777 0000556D 0246F6                  		add	al,[mp_i]
 36778                                  		
 36779                                  		;mov	cx,46
 36780                                  		;mul	cx
 36781                                  		;mov	cl,46
 36782 00005570 F6E1                    		mul	cl
 36783 00005572 89C3                    		mov	bx,ax
 36784                                  
 36785 00005574 80BF[12C4]80            		cmp	byte [part_table_boot_ind+bx],80h
 36786 00005579 750A                    		jne	short mp_3
 36787                                  		;part_table[cur_disk][i].changed = TRUE;
 36788 0000557B C687[25C4]01            		mov	byte [part_table_changed+bx],1
 36789 00005580 C687[12C4]00            		mov	byte [part_table_boot_ind+bx],0
 36790                                  mp_3:
 36791 00005585 FE46F6                  		inc	byte [mp_i]
 36792 00005588 807EF604                		cmp	byte [mp_i],4
 36793 0000558C 72D8                    		jb	short mp_2
 36794                                  
 36795                                  		;/* Now mark the new one active */
 36796                                  		;part_table[cur_disk][table_pointer].boot_ind = uc(0x80);
 36797                                  
 36798                                  		;mov	al,[cur_disk]
 36799                                  		;;cbw
 36800                                  		;;shl	ax, 1
 36801                                  		;;shl	ax, 1
 36802                                  		;;mov	cx, ax
 36803                                  		;;mov	al,[mp_table_ptr]
 36804                                  		;;cbw
 36805                                  		;;add	ax,cx
 36806                                  		;shl	al,1
 36807                                  		;shl	al,1
 36808                                  		;add	al,[mp_table_ptr]
 36809                                  		;;mov	cx,46
 36810                                  		;;imul	cx
 36811                                  		;;mov	cl,46
 36812                                  		;mul	cl
 36813                                  		;mov	bx,ax
 36814                                  		;mov	[part_table_boot_ind+bx],80h
 36815                                  		;jmp	short mp_5,
 36816                                  
 36817 0000558E B580                    		mov	ch,80h ; *- ; 19/01/2019
 36818                                  mp_4:
 36819                                  		;/* Mark it as not active, leaving the others alone */
 36820 00005590 A0[D4CB]                		mov	al,[cur_disk]
 36821                                  		;cbw
 36822                                  		;shl	ax,1
 36823                                  		;shl	ax,1
 36824                                  		;mov	cx,ax
 36825                                  		;mov	al,[mp_table_ptr]
 36826                                  		;cbw
 36827                                  		;add	ax,cx
 36828                                  		;mov	cx,46
 36829                                  		;imul	cx
 36830                                  
 36831 00005593 D0E0                    		shl	al,1
 36832 00005595 D0E0                    		shl	al,1
 36833 00005597 0246F8                  		add	al,[mp_table_ptr]
 36834                                  		;mov	cl,46
 36835 0000559A F6E1                    		mul	cl
 36836 0000559C 89C3                    		mov	bx,ax
 36837                                  
 36838                                  		;mov	byte [part_table_boot_ind+bx],0
 36839 0000559E 88AF[12C4]              		mov	[part_table_boot_ind+bx],ch ; *- ; 19/01/2019
 36840                                  mp_5:
 36841                                  		;/* Go get the start cylinder */
 36842 000055A2 B016                    		mov	al,22
 36843                                  		;imul	byte [mp_free_ptr]
 36844 000055A4 F66606                  		mul	byte [mp_free_ptr]
 36845 000055A7 89C3                    		mov	bx,ax
 36846                                  		;mov	ax,[free_space.start+bx]
 36847                                  		;mov	cx,ax
 36848 000055A9 8B8F[E4CB]              		mov	cx,[free_space.start+bx]
 36849 000055AD A0[D4CB]                		mov	al,[cur_disk]
 36850                                  		;cbw
 36851                                  		;ah = 0
 36852                                  		;mov	dx,ax ; *-**
 36853 000055B0 89C6                    		mov	si,ax ; **-	
 36854                                  		;shl	ax,1
 36855                                  		;shl	ax,1
 36856 000055B2 D0E0                    		shl	al,1
 36857 000055B4 D0E0                    		shl	al,1
 36858                                  		;mov	bx,ax
 36859                                  		;mov	al,[mp_table_ptr]
 36860                                  		;cbw
 36861                                  		;add	ax,bx
 36862 000055B6 0246F8                  		add	al,[mp_table_ptr]
 36863                                  		;mov	bx,46
 36864 000055B9 B32E                    		mov	bl,46
 36865                                  		;mov	si,dx ; *-**
 36866                                  		;imul	bx
 36867 000055BB F6E3                    		mul	bl
 36868 000055BD 89C3                    		mov	bx,ax
 36869 000055BF 898F[15C4]              		mov	[part_table_start_cyl+bx],cx
 36870                                  		;/* Setup end cylinder */
 36871                                  		;part_table[cur_disk][table_pointer].end_cyl =
 36872 000055C3 034E04                  		add	cx,[mp_size]
 36873 000055C6 49                      		dec	cx  ; part_table[cur_disk][table_pointer].start_cyl + size - 1
 36874 000055C7 898F[1AC4]              		mov	[part_table_end_cyl+bx],cx
 36875                                  		;/* Start sector is always 1 */
 36876 000055CB C687[14C4]01            		mov	byte [part_table_start_sector+bx],1
 36877                                  		;/* End sector is always the last sector */
 36878 000055D0 8A84[A0A0]              		mov	al,[max_sector+si] ; **-
 36879 000055D4 8887[19C4]              		mov	[part_table_end_sector+bx],al
 36880                                  		;/* End head is always the last head */
 36881 000055D8 D1E6                    		shl	si,1  ;**-
 36882 000055DA 8A84[A8A0]              		mov	al,[max_head+si] ; **-
 36883 000055DE FEC8                    		dec	al
 36884 000055E0 8887[18C4]              		mov	[part_table_end_head+bx],al
 36885                                  		;/* Start head is always 0 unless this is track 0 - then it is 1 */
 36886                                  		;mov	byte [mp_temp],0 ; temp = uc(0);         
 36887 000055E4 29D2                    		sub	dx,dx ; 0
 36888                                  		;cmp	word [part_table_start_cyl+bx],0
 36889 000055E6 3997[15C4]              		cmp	[part_table_start_cyl+bx],dx ; 0
 36890 000055EA 7502                    		jne	short mp_6
 36891                                  		;mov	byte [mp_temp],1 ; temp = uc(1);     
 36892 000055EC FEC2                    		inc	dl  ; dl = 1 = [mp_temp]
 36893                                  mp_6:
 36894                                  		;mov	al,[cur_disk]
 36895                                  		;cbw
 36896                                  		;mov	cx,ax
 36897                                  		;shl	ax,1
 36898                                  		;shl	ax,1
 36899                                  		;mov	dx,ax
 36900                                  		;mov	al,[mp_table_ptr]
 36901                                  		;cbw
 36902                                  		;add	ax,dx
 36903                                  		;mov	bx,46
 36904                                  		;imul	bx
 36905                                  		;mov	bx,ax
 36906                                  		;mov	al,[mp_temp]
 36907                                  
 36908                                  		; part_table[cur_disk][table_pointer].start_head = temp;
 36909                                  		;mov	[part_table_start_head+bx],al ; 0 or 1
 36910 000055EE 8897[13C4]              		mov	[part_table_start_head+bx],dl ; 0 or 1
 36911                                  
 36912                                  		;/* Figure out the total number of sectors */
 36913                                              	;/* Total sectors in partition =                    */
 36914                                              	;/* [(end_cyl - start_cyl)*(max_sector)*(max_head)] */
 36915                                              	;/* - [start_head * max_sector]                     */
 36916                                              	;/* Note: This is assuming a track or cylinder aligned partition */
 36917                                  
 36918                                  		; dl = 0 or 1
 36919                                  		; dh = 0
 36920                                  
 36921 000055F2 28E4                    		sub	ah,ah ; 0
 36922                                  
 36923                                  		; AX = start head (0 or 1)
 36924                                  
 36925                                  		;sub	dx,dx ; 0
 36926                                  
 36927                                  		;push	dx	; multiplier_hw = 0
 36928                                  		;push	ax	; multiplier_lw  (0 or 1)
 36929                                  		;;mov	si,cx
 36930                                  		;shr	si,1 ; **-
 36931                                  		;mov	al,[max_sector+si] ; **-
 36932                                  		;push	dx	; multiplicand_hw
 36933                                  		;push	ax	; multiplicand_lw
 36934                                  		;mov	di,ax
 36935                                  		;mov	[mp_temp1_lw],di ; max_sector lw
 36936                                  		;mov	[mp_temp1_hw],dx ; max_sector hw
 36937                                  		;mov	di,bx
 36938                                  		;call	mul32
 36939                                  		;	; dx:ax = [start_head * max_sector] 
 36940                                  
 36941                                  		; **** modification by Erdogan Tan
 36942                                  
 36943 000055F4 D1EE                    		shr	si,1
 36944 000055F6 8A84[A0A0]              		mov	al,[max_sector+si]
 36945                                  
 36946 000055FA 08D2                    		or	dl,dl ; dh = 0 , dl = start head (0 or 1)
 36947 000055FC 7402                    		jz	short mp_15
 36948                                  
 36949 000055FE 88C2                    		mov	dl,al	
 36950                                  mp_15:
 36951 00005600 8956FA                  		mov	[mp_temp],dx ; **** ; 19/01/2019
 36952                                  	
 36953                                  		; ****
 36954                                  
 36955                                  		;push	word [mp_temp1_hw] ; multiplier_hw
 36956                                  		;push	word [mp_temp1_lw] ; multiplier_lw
 36957                                  		
 36958 00005603 D1E6                    		shl	si,1
 36959 00005605 8B8C[A8A0]              		mov	cx,[max_head+si]
 36960                                  		;sub	bx,bx
 36961                                  		;push	bx  ; multiplicand_hw	
 36962                                  		;push	cx  ; multiplicand_lw
 36963                                  			; dx:ax = [start_head * max_sector] 	
 36964                                  		;mov	si,ax
 36965                                  		;mov	[mp_temp2_lw],si
 36966                                  		;mov	[mp_temp2_hw],dx
 36967                                  		;call	mul32
 36968                                  		;	; dx:ax = (max_sector)*(max_head)
 36969                                  
 36970                                  		; **** modification by Erdogan Tan ; 19/01/2019
 36971                                  
 36972                                  		; ax = max_sector (ah = 0)
 36973                                  		; cx = max_head   
 36974                                  
 36975 00005609 F7E1                    		mul	cx
 36976                                  			; dx:ax = (max_sector)*(max_head)
 36977                                  		; ****
 36978                                  
 36979 0000560B 52                      		push	dx  ; multiplier_hw
 36980 0000560C 50                      		push	ax  ; multiplier_lw	
 36981                                  
 36982                                  	;/* First - get the total size in Cylinders assuming head 0 start*/
 36983                                  	;total_sectors = ((unsigned long)(part_table[cur_disk][table_pointer].end_cyl -
 36984                                          ;                    part_table[cur_disk][table_pointer].start_cyl+1));
 36985                                  
 36986                                  		;mov	cx,[part_table_end_cyl+di]
 36987 0000560D 8B8F[1AC4]              		mov	cx,[part_table_end_cyl+bx] ; ****
 36988                                  		;sub	cx,[part_table_start_cyl+di]
 36989 00005611 2B8F[15C4]              		sub	cx,[part_table_start_cyl+bx] ; ****
 36990 00005615 41                      		inc	cx
 36991                                  			; cx = (end_cyl - start_cyl) + 1
 36992                                  
 36993                                  	;/* Now multiply it by the number of sectors and heads per track */
 36994                                  	;total_sectors = total_sectors * max_sector[cur_disk] * max_head[cur_disk];
 36995                                  
 36996                                  		;sub	bx,bx ; 0
 36997                                  		;push	bx 	; multiplicand_hw = 0	
 36998                                  		;push	cx	; multiplicand_lw
 36999                                  		;	; dx:ax = (max_sector)*(max_head)
 37000                                  		;	; (dx = 0)
 37001                                  		;mov	si,ax
 37002                                  		;mov	[mp_temp3_lw],si
 37003                                  		;mov	[mp_temp3_hw],dx
 37004                                  		;call	mul32
 37005                                  		;	; dx:ax = ((end_cyl - start_cyl) + 1) * (max_sector)*(max_head)
 37006                                  		;	; dx:ax = cylinders * (sectors per track * heads)
 37007                                  		;	; dx:ax = (cylinders*heads) * sectors per track
 37008                                  
 37009                                  		
 37010                                  		; **** modification by Erdogan Tan ; 19/01/2019
 37011                                  
 37012                                  		; ax = (max_sector)*(max_head) ; <= 16065 (max_head <= 255, max_sector <= 63)
 37013                                  		; dx = 0
 37014                                  		; cx = (end_cyl - start_cyl) + 1 = cylinders 
 37015                                  
 37016 00005616 89C7                    		mov	di,ax ; ***** (max_sector)*(max_head) 
 37017                                  
 37018 00005618 F7E1                    		mul	cx
 37019                                  			; dx:ax = (cylinders*heads) * sectors per track
 37020                                  
 37021                                  		; ****
 37022                                  
 37023                                  	;/* This will give us the total of sectors if it is cyl aligned */
 37024                                  	;/* Now, if it isn't aligned on head 0, we need to subtract off */
 37025                                  	;/* the skipped tracks in the first cylinder  */
 37026                                  
 37027                                  	;/* Because the head is zero based, we can get the total number of */
 37028                                  	;/* skipped sectors by multipling the head number by sectors per track */
 37029                                  	;total_sectors = 
 37030                                  	;	total_sectors - ((unsigned long)part_table[cur_disk][table_pointer].start_head) *
 37031                                  	;                       max_sector[cur_disk];
 37032                                  
 37033                                  		;sub	ax,[mp_temp2_lw] ; total_sectors = 
 37034                                  		;sbb	dx,[mp_temp2_hw] ; 	total_sectors - [start_head * max_sector] 
 37035                                  
 37036                                  		; **** modification by Erdogan Tan ; 19/01/2019
 37037                                  
 37038 0000561A 8B4EFA                  		mov	cx,[mp_temp] ; **** ; [start_head * max_sector] = 0 or max_sector
 37039 0000561D E305                    		jcxz	mp_16
 37040                                  
 37041 0000561F 29C8                    		sub	ax,cx ; cx = max_sector
 37042 00005621 83DA00                  		sbb	dx,0
 37043                                  	
 37044                                  		; ****
 37045                                  mp_16:		
 37046                                  	;part_table[cur_disk][table_pointer].num_sec = total_sectors;	
 37047                                  
 37048                                  		;mov	[part_table_num_sec_lw+di],ax
 37049                                  		;mov	[part_table_num_sec_hw+di],dx
 37050                                  
 37051 00005624 8987[20C4]              		mov	[part_table_num_sec_lw+bx],ax ; ****
 37052 00005628 8997[22C4]              		mov	[part_table_num_sec_hw+bx],dx ; ****
 37053                                  
 37054                                  		;/* Get the relative sector */
 37055                                              	;/* Figure out the total number of sectors */
 37056                                              	;/* Total sectors before partition =       */
 37057                                  		;/* (start_cyl)*(max_sector)*(max_head)    */
 37058                                  		;/* + [start_head * max_sector]            */
 37059                                  		;/* Note: This is assuming a track or cylinder aligned partition */
 37060                                  
 37061                                  		;push	word [mp_temp1_hw]
 37062                                  		;push	word [mp_temp1_lw]
 37063                                  		;mov	al,[part_table_start_head+di]
 37064                                  		;sub	ah,ah
 37065                                  		;sub	dx,dx
 37066                                  		;push	dx
 37067                                  		;push	ax
 37068                                  		;call	mul32
 37069                                  		;	 ; dx:ax = [start_head * max_sector]  
 37070                                  
 37071                                  	;/* Start cyl will work because it is zero based */
 37072                                  	;total_sectors = ((unsigned long)part_table[cur_disk][table_pointer].start_cyl);
 37073                                  
 37074                                  	;/* Get sectors up to head 0 of the partition */
 37075                                          ;total_sectors = total_sectors * max_sector[cur_disk] * max_head[cur_disk];
 37076                                  
 37077                                  		;mov	cx,[part_table_start_cyl+di]
 37078                                  		;sub	bx,bx
 37079                                  		;push	bx
 37080                                  		;push	cx
 37081                                  		;push	word [mp_temp3_hw] ; (max_sector)*(max_head)
 37082                                  		;push	word [mp_temp3_lw]
 37083                                  		;mov	si, ax
 37084                                  		;mov	[mp_temp4_lw],si ; [start_head * max_sector]
 37085                                  		;mov	[mp_temp4_hw],dx
 37086                                  		;call	mul32
 37087                                  		;add	ax,[mp_temp4_lw] 
 37088                                  		;adc	dx,[mp_temp4_hw]
 37089                                  			
 37090                                  		; **** modification by Erdogan Tan ; 19/01/2019
 37091                                  
 37092                                  		; cx = (start_head * max_sector) = max_sector or cx = 0
 37093                                  		; di = (max_sector * max_head) 
 37094                                  
 37095 0000562C 8B87[15C4]              		mov	ax,[part_table_start_cyl+bx]
 37096 00005630 F7E7                    		mul	di ; *****
 37097                                  			; dx:ax = part_table[cur_disk][table_pointer].start_cyl *
 37098                                  			;	  max_sector[cur_disk] * max_head[cur_disk]
 37099                                  
 37100 00005632 01C8                    		add	ax,cx
 37101 00005634 83D200                  		adc	dx,0
 37102                                  			; dx:ax =  Total sectors before partition = 
 37103                                  			;	   (start_cyl)*(max_sector * max_head)
 37104                                  			;	   + (start_head * max_sector)
 37105                                  
 37106                                  		; ****		  
 37107                                  
 37108                                  	;/* Because the head is zero based, we can get the total number of */
 37109                                  	;/* skipped sectors by multipling the head number by sectors per track */
 37110                                  	;total_sectors = 
 37111                                  	;	total_sectors + ((unsigned long)part_table[cur_disk][table_pointer].start_head) *
 37112                                  	;		max_sector[cur_disk];
 37113                                  
 37114 00005637 8946FC                  		mov	[mp_total_sectors_lw],ax  ; -**-
 37115 0000563A 8956FE                  		mov	[mp_total_sectors_hw],dx  ; -**-	
 37116                                  
 37117                                  		;* Save it! */
 37118                                  		;part_table[cur_disk][table_pointer].rel_sec = total_sectors;
 37119                                  
 37120                                  		;mov	[part_table_rel_sec_lw+di],ax
 37121                                  		;mov	[part_table_rel_sec_hw+di],dx
 37122                                  
 37123 0000563D 8987[1CC4]              		mov	[part_table_rel_sec_lw+bx],ax
 37124 00005641 8997[1EC4]              		mov	[part_table_rel_sec_hw+bx],dx
 37125                                  
 37126                                  		;/* Setup the system id byte */
 37127                                  
 37128 00005645 807E0A05                		cmp	byte [mp_type],5 ; EXTENDED
 37129 00005649 7504                    		jne	short mp_7
 37130                                  		;mov	byte [mp_temp],5
 37131 0000564B B005                    		mov	al,5 ; EXTENDED
 37132 0000564D EB1C                    		jmp	short mp_12
 37133                                  mp_7:
 37134                                  		;NOTE: If [mp_type] <> 5, it is 0 (there is not another possibility)
 37135                                  		
 37136                                  		;cmp	byte [mp_type],0 ; PRIMARY
 37137                                  		;jne	short mp_11  ; not possible !
 37138                                  		
 37139                                  		;mov	al,[cur_disk]
 37140                                  		;;cbw
 37141                                  		;;shl	ax,1
 37142                                  		;;shl	ax,1
 37143                                  		;;mov	cx,ax
 37144                                  		;;mov	al,[mp_table_ptr]
 37145                                  		;;cbw
 37146                                  		;;add	ax,cx
 37147                                  		;shl	al,1
 37148                                  		;shl	al,1
 37149                                  		;add	al,[mp_table_ptr]
 37150                                  		;;mov	cx,46
 37151                                  		;;imul	cx
 37152                                  		;mov	cl,46
 37153                                  		;mul	cl
 37154                                  		;mov	bx,ax
 37155                                  
 37156                                  	;/* Always set to 06h - let format worry about setting to correct value */
 37157                                          ;/* SR; 9/30/89; We fix up the size ourselves here. The
 37158                                          ;	calculation is simple. If total_sectors > 65536 then
 37159                                          ;	type = 06 else if total_sectors > 32680 then type = 04
 37160                                          ;       else type = 01 */
 37161                                  
 37162                                          ;/* SR; 9/30/89; Calculate total_sectors from start
 37163                                          ; including the hidden sectors */
 37164                                  
 37165                                  	; total_sectors += part_table[cur_disk][table_pointer].num_sec;
 37166                                  
 37167                                  		;mov	ax,[part_table_num_sec_lw+bx]
 37168                                  		;mov	dx,[part_table_num_sec_hw+bx]
 37169                                  		;add	[mp_total_sectors_lw],ax
 37170                                  		;adc	[mp_total_sectors_hw],dx
 37171                                  
 37172                                  		; ax = [mp_total_sectors_lw] ; -**-
 37173                                  		; dx = [mp_total_sectors_hw] ; -**-
 37174                                  
 37175 0000564F 0387[20C4]              		add	ax,[part_table_num_sec_lw+bx]  ; -**-
 37176 00005653 1397[22C4]              		adc	dx,[part_table_num_sec_hw+bx]  ; -**-	
 37177                                  		
 37178                                  	; if ( (total_sectors >> 16) > 0 )
 37179 00005657 7404                    		jz	short mp_8 ; [mp_total_sectors_hw] = 0
 37180                                  	; temp = uc(DOSNEW); /* Partition extends beyond the 32M boundary */
 37181                                  		;mov	byte [mp_temp],6
 37182 00005659 B006                    		mov	al,6 ; DOSNEW
 37183 0000565B EB0E                    		jmp	short mp_12
 37184                                  ;mp_8:
 37185                                  		;mov	al,[cur_disk]
 37186                                  		;cbw
 37187                                  		;shl	ax,1
 37188                                  		;shl	ax,1
 37189                                  		;mov	cx,ax
 37190                                  		;mov	al,[mp_table_ptr]
 37191                                  		;cbw
 37192                                  		;add	ax,cx
 37193                                  		;mov	cx,46
 37194                                  		;imul	cx
 37195                                  		;mov	bx,ax
 37196                                  		
 37197                                  		;cmp	word [part_table_num_sec_hw+bx],0
 37198                                  		;jne	short mp_9
 37199                                  mp_8:
 37200                                  	;if (part_table[cur_disk][table_pointer].num_sec > ul( FAT16_SIZE ))
 37201                                  
 37202 0000565D 81BF[20C4]A87F          		cmp	word [part_table_num_sec_lw+bx],32680 ; FAT16_SIZE = 32680
 37203 00005663 7604                    		jbe	short mp_10 ;  if sectors <= 32680, it must be a FAT12 file system 
 37204                                  mp_9:
 37205                                  		;mov	byte [mp_temp],4 ; temp = uc(DOS16);
 37206 00005665 B004                    		mov	al,4
 37207 00005667 EB02                    		jmp	short mp_12
 37208                                  ;mp_11:
 37209                                  ;		call	internal_program_error
 37210                                  ;		jmp	short mp_12
 37211                                  mp_10:
 37212                                  		;mov	byte [mp_temp],1 ; temp = uc(DOS12); 
 37213 00005669 B001                    		mov	al,1
 37214                                  ;;		jmp	short mp_12
 37215                                  ;;mp_11:
 37216                                  ;;		call	internal_program_error
 37217                                  mp_12:
 37218                                  		;mov	al,[mp_table_ptr]
 37219                                  		;cbw
 37220                                  		;mov	cx,ax
 37221                                  		;mov	al,[cur_disk]
 37222                                  		;cbw
 37223                                  		;shl	ax,1
 37224                                  		;shl	ax,1
 37225                                  		;add	ax,cx
 37226                                  		;mov	bx,46
 37227                                  		;imul	bx
 37228                                  		;mov	si,ax
 37229                                  
 37230                                  		; /* We got the sys id, now put it in */
 37231                                              	;part_table[cur_disk][table_pointer].sys_id = temp;
 37232                                  
 37233                                  		;mov	al,[mp_temp]
 37234                                  
 37235                                  		;mov	[part_table_sys_id+si],al
 37236                                  		;mov	byte [part_table_changed+si],1
 37237 0000566B 8887[17C4]              		mov	[part_table_sys_id+bx],al ; al = [mp_temp]
 37238                                  
 37239                                  		;/* Set the changed flag */
 37240                                              	;part_table[cur_disk][table_pointer].changed = TRUE;
 37241                                  
 37242 0000566F C687[25C4]01            		mov	byte [part_table_changed+bx],1
 37243                                  		
 37244 00005674 89DE                    		mov	si,bx ; *
 37245                                  
 37246                                  		;mov	al,[cur_disk]
 37247                                  		;push	ax
 37248 00005676 8A1E[D4CB]              		mov	bl,[cur_disk]
 37249 0000567A 30FF                    		xor	bh,bh
 37250 0000567C 89DF                    		mov	di,bx ; **
 37251                                  
 37252                                  		;/* Set the mbytes used */
 37253                                  
 37254                                  		;push	word [mp_size]
 37255 0000567E 8B4604                  		mov	ax,[mp_size]
 37256                                  		;mov	di,cx
 37257 00005681 E8D8BE                  		call	cylinders_to_mbytes
 37258                                  		;pop	bx
 37259                                  		;pop	bx
 37260 00005684 8984[26C4]              		mov	[part_table_mbytes_used+si],ax  ; *
 37261                                  		
 37262                                  		;mov	al,[cur_disk]
 37263                                  		;cbw
 37264                                  		;mov	bx,ax
 37265                                  		;;shl	bx,1
 37266                                  		;shl	bl,1
 37267                                  		;push	word [total_disk+bx]
 37268                                  		
 37269                                  		;;shl	ax,1
 37270                                  		;;shl	ax,1
 37271                                  		;shl	al,1
 37272                                  		;shl	al,1
 37273                                  		;;add	ax,di
 37274                                  		;add	al,[mp_table_ptr]
 37275                                  		;;mov	cx,46
 37276                                  		;;imul	cx
 37277                                  		;mov	cl,46
 37278                                  		;mul	cl
 37279                                  		;mov	bx,ax
 37280                                  		
 37281                                  		;mov	ax,[part_table_end_cyl+bx]
 37282                                  		;sub	ax,[part_table_start_cyl+bx]
 37283                                  		;inc	ax
 37284                                  		;push	ax
 37285                                  
 37286                                  		;mov	si,bx
 37287                                  
 37288                                  		;/* Set the percent used */
 37289                                  
 37290 00005688 D1E7                    		shl	di,1 ; **
 37291 0000568A 8B8D[B8A0]              		mov	cx,[total_disk+di] ; **
 37292                                  			; cx = total cylinders (of the disk)
 37293 0000568E 8B9C[1AC4]              		mov	bx,[part_table_end_cyl+si]
 37294 00005692 2B9C[15C4]              		sub	bx,[part_table_start_cyl+si]		
 37295 00005696 43                      		inc	bx
 37296                                  			; bx = number of cylinders (of the partition)
 37297 00005697 E815BF                  		call	cylinders_to_percent
 37298                                  		;pop	bx
 37299                                  		;pop	bx
 37300 0000569A 8984[28C4]              		mov	[part_table_percent_used+si],ax ; percent (<=100)
 37301                                  
 37302                                  	;/* set the system to unknown and volume label to blanks */
 37303                                          ;strcpy(part_table[cur_disk][table_pointer].system,NOFORMAT)
 37304                                          ;strcpy(part_table[cur_disk][table_pointer].vol_label,NOVOLUME)
 37305                                  
 37306                                  		;mov	ax,NO_FORMAT ; "UNKNOWN	"
 37307                                  		;push	ax
 37308 0000569E A0[D4CB]                		mov	al,[cur_disk]
 37309                                  		;cbw
 37310                                  		;shl	ax,1
 37311                                  		;shl	ax,1
 37312                                  		;add	ax,di
 37313                                  		;mov	cx,46
 37314                                  		;imul	cx
 37315                                  		;add	ax,part_table_system
 37316                                  		;push	ax
 37317                                  		;call	strcpy
 37318                                  		;pop	bx
 37319                                  		;pop	bx
 37320                                  
 37321 000056A1 89F3                    		mov	bx,si
 37322 000056A3 BE[4570]                		mov	si,NO_FORMAT
 37323 000056A6 89DF                    		mov	di,bx
 37324 000056A8 81C7[36C4]              		add	di,part_table_system
 37325 000056AC E874C6                  		call	strcpy
 37326                                  		
 37327                                  
 37328                                  		;mov	ax,NO_VOLUME
 37329                                  		;push	ax
 37330                                  		;mov	al,[cur_disk]
 37331                                  		;cbw
 37332                                  		;shl	ax,1
 37333                                  		;shl	ax,1
 37334                                  		;add	ax,di
 37335                                  		;mov	cx,46
 37336                                  		;imul	cx
 37337                                  		;add	ax,part_table_vol_label
 37338                                  		;push	ax
 37339                                  		;call	strcpy
 37340                                  		;pop	bx
 37341                                  		;pop	bx
 37342                                  
 37343                                  		;mov	si,NO_VOLUME ; [NO_VOLUME] = 0
 37344                                  		;mov	di,bx
 37345                                  		;add	di,part_table_vol_label
 37346                                  		;call	strcpy
 37347 000056AF C687[2AC4]00            		mov	byte [part_table_vol_label+bx],0 ; NOVOLUME
 37348                                  
 37349                                  		;jmp	short mp_14
 37350                                  ;mp_13:
 37351                                  ;		call	internal_program_error
 37352                                  mp_14:
 37353                                  		;pop	si
 37354                                  		;pop	di
 37355                                  
 37356 000056B4 89EC                    		mov	sp,bp
 37357 000056B6 5D                      		pop	bp
 37358                                  		;retn
 37359 000056B7 C20800                  		retn	8
 37360                                  mp_13:
 37361 000056BA E854DC                  		call	internal_program_error
 37362 000056BD EBF5                    		jmp	short mp_14
 37363                                  
 37364                                  ; ----------------------------------------------------------------------------
 37365                                  ; convert.c (FDISK, MSDOS 6.0, 1991)	
 37366                                  ; ----------------------------------------------------------------------------
 37367                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 19/01/2019)
 37368                                  
 37369                                  ;/***************************************************************************/
 37370                                  ;/*Routine name:  MBYTES_TO_CYLINDERS                                       */
 37371                                  ;/***************************************************************************/
 37372                                  ;/*                                                                         */
 37373                                  ;/*Description:   This routine will take input of MBtes and                 */
 37374                                  ;/*               convert it to cylinders rounding up to the next largest   */
 37375                                  ;/*               cylinder boundry.  Rounding up is done to make sure the   */
 37376                                  ;/*               requester is getting at least what he asked for to the    */
 37377                                  ;/*               next cylinder boundry.                                    */
 37378                                  ;/*                                                                         */
 37379                                  ;/*Called Procedures:    none                                               */
 37380                                  ;/*                                                                         */
 37381                                  ;/*                                                                         */
 37382                                  ;/*Change History: Created	5/30/87	DRM                                 */
 37383                                  ;/*                                                                         */
 37384                                  ;/*Input: Input                                                             */
 37385                                  ;/*                                                                         */
 37386                                  ;/*Output: Cylinders_out                                                    */
 37387                                  ;/*                                                                         */
 37388                                  ;/***************************************************************************/
 37389                                  
 37390                                  ;unsigned mbytes_to_cylinders(mbytes_in,which_disk)
 37391                                  ;
 37392                                  ;XFLOAT	mbytes_in;
 37393                                  ;char	which_disk;
 37394                                  ;
 37395                                  ;BEGIN
 37396                                  ;
 37397                                  ;unsigned	cylinders_out;
 37398                                  ;unsigned long	cylinders_out1;
 37399                                  ;unsigned long	number_of_sectors;
 37400                                  ;unsigned long	number_of_tracks;
 37401                                  ;unsigned long	divide_by;
 37402                                  ;
 37403                                  ;      /* If trying to create a 3.30 compatible 32 MB partition */
 37404                                  ;      /* Set the 32mb limit - round down                       */
 37405                                  ;      if (mbytes_in == (XFLOAT)32)
 37406                                  ;          BEGIN
 37407                                  ;          cylinders_out1 = ul(DOS_MAX);
 37408                                  ;          divide_by = ul((max_head[which_disk]) * ul(max_sector[which_disk]));
 37409                                  ;          cylinders_out = u(cylinders_out1 / divide_by);
 37410                                  ;          END
 37411                                  ;      else
 37412                                  ;          BEGIN
 37413                                  ;	   /* SR; 9/26/89; Long calculation incorrect */
 37414                                  ;	   number_of_sectors = ((ul(mbytes_in) * ul(ONE_MEG))/BYTES_PER_SECTOR);
 37415                                  ;
 37416                                  ;          /* SR; 9/26/89; Incorrect cast to int. Actually this modulo is */
 37417                                  ;          /* always 0 because ONE_MEG mod BYTES_PER_SECTOR = 0 */
 37418                                  ;	   if (((mbytes_in * ONE_MEG) % BYTES_PER_SECTOR) != (int)0)
 37419                                  ;	       number_of_sectors++;
 37420                                  ;	       number_of_tracks = ul((number_of_sectors / max_sector[which_disk]));
 37421                                  ;
 37422                                  ;          /* SR; 9/26/89; Changed int cast to unsigned */
 37423                                  ;	   if (((unsigned)number_of_sectors % max_sector[which_disk]) != 0)
 37424                                  ;	       number_of_tracks++;
 37425                                  ;	       cylinders_out = u((number_of_tracks / max_head[which_disk]));
 37426                                  ;
 37427                                  ;	   /* SR; 9/26/89; Changed int cast to unsigned */
 37428                                  ;	   if (((unsigned)number_of_tracks % max_head[which_disk]) != 0)
 37429                                  ;	       cylinders_out++;
 37430                                  ;          END
 37431                                  ;
 37432                                  ;      return(cylinders_out);
 37433                                  ;END
 37434                                  
 37435                                  mbytes_to_cylinders:
 37436                                  		; 19/01/2019
 37437                                  
 37438                                  	;%define mtc_num_sectors_lw bp-18
 37439                                  	;%define mtc_num_sectors_hw bp-16
 37440                                  	;%define mtc_cylinders_out  bp-6
 37441                                  	;%define mtc_num_tracks_lw  bp-4
 37442                                  	;%define mtc_num_tracks_hw  bp-2
 37443                                  	
 37444                                  	%define mtc_mbytes_in	bp+4
 37445                                  	%define mtc_which_disk	bp+6
 37446                                  
 37447 000056BF 55                      		push	bp
 37448 000056C0 89E5                    		mov	bp,sp
 37449                                  
 37450                                  		;sub	sp,18
 37451                                  		
 37452                                  		;push	di
 37453                                  		;push	si
 37454                                  
 37455                                  	;/* If trying to create a 3.30 compatible 32 MB partition */
 37456                                  	;/* Set the 32mb limit - round down  
 37457                                  		
 37458 000056C2 8A4606                  		mov	al,[mtc_which_disk]
 37459 000056C5 98                      		cbw	; ah = 0
 37460 000056C6 89C3                    		mov	bx,ax
 37461 000056C8 8A87[A0A0]              		mov	al,[max_sector+bx]
 37462 000056CC 89C6                    		mov	si,ax ; *+* ; 19/01/2019
 37463 000056CE D0E3                    		shl	bl,1
 37464 000056D0 8BBF[A8A0]              		mov	di,[max_head+bx] ; *++* ; 19/01/2019
 37465                                  
 37466 000056D4 8B4604                  		mov	ax,[mtc_mbytes_in] ; 19/01/2019
 37467                                  
 37468                                  		;cmp	word [mtc_mbytes_in],32
 37469 000056D7 83F820                  		cmp	ax,32
 37470 000056DA 750C                    		jne	short mbtocyl_1
 37471                                  
 37472                                  		;mov	al,[mtc_which_disk]
 37473                                  		;cbw
 37474                                  		;mov	bx,ax
 37475                                  		;mov	al,[max_sector+bx]
 37476                                  		;;sub	ah,ah
 37477                                  		;mov	si,ax ; *+* ; 19/01/2019
 37478                                  		
 37479                                  		;;shl	bx,1
 37480                                  		;shl	bl,1
 37481                                  		;mul	word [max_head+bx]
 37482                                  
 37483 000056DC F7E7                    		mul	di ; *++* ; 19/01/2019
 37484                                  
 37485                                  		;push	dx  ; divisor hw = 0
 37486                                  		;push	ax  ; divisor lw <= 16065 (255*63)
 37487 000056DE 89C1                    		mov	cx,ax ; 19/01/2019
 37488 000056E0 B8FFFF                  		mov	ax,0FFFFh ; 65535 sectors
 37489                                  		;sub	dx,dx ; dx = 0
 37490                                  		;push	dx ; dividend hw
 37491                                  		;push	ax ; dividend lw
 37492                                  			; dx:ax = dividend (32 bit)
 37493                                  			; cx = divisor (16 bit)
 37494 000056E3 E826BF                  		call	div32
 37495                                  			; dx:ax = quotient
 37496                                  			; bx = remainder
 37497 000056E6 EB28                    		jmp	short mbtocyl_4
 37498                                  mbtocyl_1:
 37499                                  	;number_of_sectors = ((ul(mbytes_in) * ul(ONE_MEG))/BYTES_PER_SECTOR);
 37500 000056E8 B104                    		mov	cl,4
 37501                                  		;mov	ax,[mtc_mbytes_in]
 37502 000056EA 29D2                    		sub	dx,dx
 37503                                  		;mov	bx,ax
 37504                                  		;mov	si,dx
 37505 000056EC D3E0                    		shl	ax,cl ; 16
 37506 000056EE 89C2                    		mov	dx,ax ; 16*65536
 37507 000056F0 29C0                    		sub	ax,ax
 37508 000056F2 B109                    		mov	cl,9  ; bytes / 512
 37509                                  		;mov	di,bx
 37510 000056F4 E80CBF                  		call	shr32
 37511                                  			; dx:ax = sectors
 37512                                  		;mov	[mtc_num_sectors_lw],ax
 37513                                  		;mov	[mtc_num_sectors_hw],dx
 37514                                  		
 37515                                  	;Actually this modulo is always 0 because ONE_MEG mod BYTES_PER_SECTOR = 0
 37516                                  	
 37517                                  	;if (((mbytes_in * ONE_MEG) % BYTES_PER_SECTOR) != (int)0)
 37518                                  	;       number_of_sectors++;
 37519                                  
 37520                                  		;mov	cx,512
 37521                                  		;sub	bx,bx
 37522                                  		;push	bx
 37523                                  		;push	cx
 37524                                  		;mov	cl,4
 37525                                  		;shl	di,cl
 37526                                  		;sub	cx,cx
 37527                                  		;push	di
 37528                                  		;push	cx
 37529                                  		;call	_mod32
 37530                                  		;or	dx,ax
 37531                                  		;jz	short mbtocyl_2  ; always 0
 37532                                  		
 37533                                  		;mov	ax,[bp+mtc_num_sectors_lw]
 37534                                  		;mov	dx,[bp+mtc_num_sectors_hw]
 37535                                  		;add	ax,1
 37536                                  		;adc	dx,si
 37537                                  		;mov	[mtc_num_sectors_lw],ax
 37538                                  		;mov	[mtc_num_sectors_hw],dx
 37539                                  mbtocyl_2:
 37540                                  	;number_of_tracks = ul((number_of_sectors / max_sector[which_disk]));	
 37541                                  
 37542                                  		;mov	al,[mtc_which_disk]
 37543                                  		;cbw
 37544                                  		;mov	bx,ax
 37545                                  		;mov	al,[max_sector+bx]
 37546                                  		;sub	ah,ah
 37547                                  
 37548                                  		;mov	cx,ax
 37549 000056F7 89F1                    		mov	cx,si ; *+* ; 19/01/2019
 37550                                  			; cl = [max_sector+bx]
 37551                                  			; ch = 0
 37552                                  		;sub	dx,dx
 37553                                  		;push	dx ; divisor hw = 0
 37554                                  		;push	ax ; divisor lw = sectors per track
 37555                                  		;push	word [mtc_num_sectors_hw] ; dividend hw
 37556                                  		;push	word [mtc_num_sectors_lw] ; dividend lw
 37557                                  		;mov	si,cx
 37558                                  		;call	div32
 37559                                  		
 37560                                  		;mov	dx,[mtc_num_sectors_hw]
 37561                                  		;mov	ax,[mtc_num_sectors_lw]	
 37562                                  
 37563                                  			; dx:ax = number of sectors (dividend)
 37564                                  			; cx = sectors per track (divisor)
 37565 000056F9 E810BF                  		call	div32
 37566                                  			; dx:ax = quotient, number of tracks (cylinders*heads)
 37567                                  			; bx = remainder, sectors (less than spt)
 37568                                  
 37569                                  		;mov	[mtc_num_tracks_lw],ax
 37570                                  		;mov	[mtc_num_tracks_hw],dx
 37571                                  		
 37572                                  	;if (((unsigned)number_of_sectors % max_sector[which_disk]) != 0)
 37573                                  	;      number_of_tracks++;
 37574                                  
 37575                                  		;mov	ax,[mtc_num_sectors_lw]
 37576                                  		;sub	dx,dx
 37577                                  		;div	si
 37578                                  		;or	dx,dx
 37579                                  		;jz	short mbtocyl_3
 37580                                  		
 37581                                  		;mov	ax,[mtc_num_tracks_lw]
 37582                                  		;mov	dx,[mtc_num_tracks_hw]
 37583                                  		;add	ax,1
 37584                                  		;adc	dx,0
 37585                                  		;mov	[mtc_num_tracks_lw],ax
 37586                                  		;mov	[mtc_num_tracks_hw],dx
 37587                                  
 37588 000056FC 09DB                    		or	bx,bx
 37589 000056FE 7406                    		jz	short  mbtocyl_3
 37590                                  
 37591                                  		; round up
 37592 00005700 83C001                  		add	ax,1 ; number_of_tracks++;
 37593 00005703 83D200                  		adc	dx,0
 37594                                  mbtocyl_3:
 37595                                  		;mov	[mtc_num_tracks_lw],ax
 37596                                  		;mov	[mtc_num_tracks_hw],dx
 37597                                  
 37598                                  	;cylinders_out = u((number_of_tracks / max_head[which_disk]));
 37599                                  
 37600                                  		;mov	al,[mtc_which_disk]
 37601                                  		;cbw
 37602                                  		;mov	bx,ax
 37603                                  		;shl	bx,1
 37604                                  		;mov	ax,[max_head+bx]
 37605                                  
 37606                                  		;mov	cx,ax
 37607 00005706 89F9                    		mov	cx,di ; *++* ; 19/01/2019
 37608                                  			; cx = [max_head+bx]
 37609                                  		;sub	dx,dx
 37610                                  		;push	dx
 37611                                  		;push	ax
 37612                                  		;push	word [mtc_num_tracks_hw]
 37613                                  		;push	word [mtc_num_tracks_lw]
 37614                                  		;mov	si,ax
 37615                                  		;call	div32
 37616                                  
 37617                                  		;mov	ax,[mtc_num_tracks_lw]
 37618                                  		;mov	dx,[[mtc_num_tracks_hw]
 37619                                  			; dx:ax = number of tracks (dividend)	
 37620                                  			; cx = heads (divisor)
 37621 00005708 E801BF                  		call	div32
 37622                                  			 ; dx:ax = quotient, cylinders  ; dx = 0
 37623                                  			 ; bx = remainder, head 	
 37624                                  
 37625                                  		;mov	[mtc_cylinders_out],ax
 37626                                  
 37627                                  	;if (((unsigned)number_of_tracks % max_head[which_disk]) != 0)
 37628                                  	;      cylinders_out++;
 37629                                  
 37630                                  		;mov	ax,[mtc_num_tracks_lw]
 37631                                  		;sub	dx,dx
 37632                                  		;div	si
 37633                                  		;or	dx,dx
 37634                                  		;jz	short mbtocyl_5
 37635                                  
 37636 0000570B 21DB                    		and	bx,bx
 37637 0000570D 7501                    		jnz	short mbtocyl_5
 37638                                  		
 37639                                  		;mov	ax,[mtc_cylinders_out]
 37640 0000570F 40                      		inc	ax  ; round up ; cylinders_out++
 37641                                  mbtocyl_4:
 37642                                  		;mov	[mtc_cylinders_out],ax
 37643                                  mbtocyl_5:
 37644                                  		;mov	ax,[mtc_cylinders_out]
 37645                                  
 37646                                  		; ax = cylinders
 37647                                  		
 37648                                  		;pop	si
 37649                                  		;pop	di
 37650                                  		
 37651 00005710 89EC                    		mov	sp,bp
 37652 00005712 5D                      		pop	bp
 37653                                  		;retn
 37654                                  
 37655 00005713 C20400                  		retn	4
 37656                                  
 37657                                  ;/***************************************************************************/
 37658                                  ;/*Routine name:  PERCENT_TO_CYLINDERS                                      */
 37659                                  ;/***************************************************************************/
 37660                                  ;/*                                                                         */
 37661                                  ;/*Description:   This routine will take input of percentage and            */
 37662                                  ;/*               convert it to cylinders rounding up to the next largest   */
 37663                                  ;/*               cylinder boundry.  Rounding up is done to make sure the   */
 37664                                  ;/*               requester is getting at least what he asked for to the    */
 37665                                  ;/*               next cylinder boundry.                                    */
 37666                                  ;/*                                                                         */
 37667                                  ;/*Called Procedures:    none                                               */
 37668                                  ;/*                                                                         */
 37669                                  ;/*                                                                         */
 37670                                  ;/*Change History: Created	5/30/87	DRM				    */
 37671                                  ;/*                                                                         */
 37672                                  ;/*Input: Input                                                             */
 37673                                  ;/*                                                                         */
 37674                                  ;/*Output: Cylinders_out                                                    */
 37675                                  ;/*                                                                         */
 37676                                  ;/***************************************************************************/
 37677                                  
 37678                                  ;XFLOAT percent_to_cylinders(percent_in,total_cylinders)
 37679                                  ;
 37680                                  ;unsigned percent_in;
 37681                                  ;unsigned total_cylinders;
 37682                                  ;
 37683                                  ;BEGIN
 37684                                  ;	XFLOAT	cylinders_out;
 37685                                  ;        cylinders_out = (unsigned)((ul(percent_in) * ul(total_cylinders)) / 100);
 37686                                  ;		 /* SR; 9/26/89; Typecast to long needed */
 37687                                  ;	if (((ul(percent_in) * ul(total_cylinders)) % 100) != u(0))
 37688                                  ;	   cylinders_out++;
 37689                                  ;	return(cylinders_out);
 37690                                  ;END
 37691                                  
 37692                                  percent_to_cylinders:
 37693                                  		; 19/01/2019
 37694                                  
 37695                                  	;%define ptc_cylinders_out   bp-2
 37696                                  	;%define ptc_percent_in	     bp+4
 37697                                  	;%define ptc_total_cylinders bp+6
 37698                                  
 37699                                  		; INPUT:
 37700                                  		;	CX = total cylinders (of the disk)
 37701                                  		;	AX = percent in (word, <= 100)
 37702                                  		; OUTPUT:
 37703                                  		;	AX = cylinders (of the partition)
 37704                                  		;
 37705                                   		; (modified registers: bx,cx,dx)
 37706                                  
 37707                                  		;push	bp
 37708                                  		;mov	bp,sp
 37709                                  		;sub	sp,2
 37710                                  		
 37711                                  		;push	di
 37712                                  		;push	si
 37713                                  		
 37714                                  		;;mov	ax,100
 37715                                  		;;cwd
 37716                                  		;;push	dx  ; divisor hw
 37717                                  		;;push	ax  ; divisor lw
 37718                                  		;;mov	ax,[ptc_total_cylinders]
 37719                                  		;;mul	word [ptc_percent_in]
 37720                                  		;;push	dx  ; dividend hw
 37721                                  		;;push	ax  ; dividend lw
 37722                                  		;;mov	si,ax
 37723                                  		;;mov	di,dx
 37724                                  		;;call	div32
 37725                                  
 37726                                  	;cylinders_out = (unsigned)((ul(percent_in) * ul(total_cylinders)) / 100);
 37727                                  
 37728                                  		;mov	ax,[ptc_total_cylinders]
 37729                                  		;mul	word [ptc_percent_in]
 37730                                  
 37731 00005716 F7E1                    		mul	cx ; total cylinders * percent in
 37732                                  
 37733                                  			; dx:ax = (100*cylinders/totalcylinders) * total cylinders 
 37734                                  
 37735 00005718 B96400                  		mov	cx,100
 37736                                  					
 37737                                  			; dx:ax = Dividend
 37738                                  			; cx = divisor (16 bit)
 37739                                  
 37740 0000571B E8EEBE                  		call	div32 ; ((100*cylinders/totalcylinders) * total cylinders) / 100 
 37741                                  			
 37742                                  			; DX:AX = Quotient 
 37743                                  			; BX = Remainder
 37744                                  
 37745                                  		;mov	[ptc_cylinders_out],ax  ; dx = 0
 37746                                  
 37747                                  		;mov	cx,100
 37748                                  		;sub	dx,dx
 37749                                  		;push	dx
 37750                                  		;push	cx
 37751                                  		;push	di
 37752                                  		;push	si
 37753                                  		;call	mod32
 37754                                  
 37755                                  		;or	dx,ax
 37756                                  		;jz	short pctocyl_1
 37757                                  
 37758                                  	;if (((ul(percent_in) * ul(total_cylinders)) % 100) != u(0))
 37759                                  	;   cylinders_out++;
 37760                                  
 37761 0000571E 09DB                    		or	bx,bx
 37762 00005720 7401                    		jz	short pctocyl_1 ; remainder = 0
 37763                                  
 37764                                  		;mov	ax,[ptc_cylinders_out]
 37765 00005722 40                      		inc	ax  ; round up
 37766                                  		;mov	[ptc_cylinders_out],ax
 37767                                  pctocyl_1:
 37768                                  		;mov	ax,[ptc_cylinders_out]
 37769                                  		
 37770                                  		;pop	si
 37771                                  		;pop	di
 37772                                  		
 37773                                  		;mov	sp,bp
 37774                                  		;pop	bp
 37775                                  
 37776 00005723 C3                      		retn
 37777                                  
 37778                                  ; ----------------------------------------------------------------------------
 37779                                  ; partinfo.c (FDISK, MSDOS 6.0, 1991)	
 37780                                  ; ----------------------------------------------------------------------------
 37781                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 19/01/2019)
 37782                                  
 37783                                  ;char find_free_partition()
 37784                                  ;
 37785                                  ;BEGIN
 37786                                  ; char  i;
 37787                                  ;
 37788                                  ;    /* Look at all four partition entries for empty partition */
 37789                                  ;    for (i = c(0); i < c(4);i++)                             /* AC000 */
 37790                                  ;       BEGIN
 37791                                  ;
 37792                                  ;       /* if we find an empty one, return which one */
 37793                                  ;        if (part_table[cur_disk][i].num_sec == ul(0))        /* AC000 */
 37794                                  ;           BEGIN
 37795                                  ;            return(i);
 37796                                  ;            break;
 37797                                  ;           END
 37798                                  ;       END
 37799                                  ;    /* Did not find one, return NOT_FOUND */
 37800                                  ;    return(c(NOT_FOUND));                                    /* AC000 */
 37801                                  ;END
 37802                                  
 37803                                  find_free_partition:
 37804                                  		; 19/01/2019
 37805                                  
 37806                                  	%define	ffp_i	bp-2
 37807                                  
 37808                                  		;push	bp
 37809                                  		;mov	bp,sp
 37810                                  		;sub	sp,2
 37811                                  
 37812                                  	;/* Look at all four partition entries for empty partition */
 37813                                  	
 37814                                  		; for (i = c(0); i < c(4);i++)	
 37815                                  	
 37816                                  		;mov	byte [ffp_i],0
 37817 00005724 31C9                    		xor	cx,cx ; 0
 37818 00005726 EB07                    		jmp	short ffp_2
 37819                                  ffp_1:
 37820                                  		;inc	byte [ffp_i]
 37821 00005728 FEC1                    		inc	cl
 37822                                  ;ffp_2:
 37823                                  		;cmp	byte [ffp_i],4
 37824                                  		;jge	short ffp_3
 37825 0000572A 80F904                  		cmp	cl,4
 37826 0000572D 731D                    		jnb	short ffp_3
 37827                                  ffp_2:		
 37828                                  		;/* if we find an empty one, return which one */
 37829                                  		
 37830                                  		;mov	al,[cur_disk]
 37831                                  		;cbw
 37832                                  		;shl	ax,1
 37833                                  		;shl	ax,1
 37834                                  		;mov	cx,ax
 37835                                  		
 37836 0000572F 8A1E[D4CB]              		mov	bl,[cur_disk]
 37837 00005733 D0E3                    		shl	bl,1
 37838 00005735 D0E3                    		shl	bl,1		
 37839                                  
 37840                                  		;mov	al,[ffp_i]
 37841                                  		;cbw
 37842                                  		;add	ax,cx
 37843                                  
 37844 00005737 00CB                    		add	bl,cl ; cl = [ffp_i]
 37845                                  		
 37846                                  		;mov	cx,46
 37847                                  		;imul	cx
 37848 00005739 B02E                    		mov	al,46
 37849 0000573B F6E3                    		mul	bl		
 37850                                  
 37851 0000573D 89C3                    		mov	bx,ax
 37852                                  
 37853                                  		;if (part_table[cur_disk][i].num_sec == ul(0)) 
 37854                                  
 37855 0000573F 8B87[22C4]              		mov	ax,[part_table_num_sec_hw+bx]
 37856 00005743 0B87[20C4]              		or	ax,[part_table_num_sec_lw+bx]
 37857 00005747 75DF                    		jnz	short ffp_1
 37858                                  
 37859                                  		;mov	al,[ffp_i]
 37860 00005749 88C8                    		mov	al,cl  ; return(i);
 37861                                  		;jmp	short ffp_4
 37862 0000574B C3                      		retn
 37863                                  ffp_3:
 37864                                  		;/* Did not find one, return NOT_FOUND */
 37865                                  
 37866 0000574C B0FF                    		mov	al,0FFh ; -1 ; return(c(NOT_FOUND)); 
 37867                                  ffp_4:
 37868                                  		;mov	sp,bp
 37869                                  		;pop	bp
 37870 0000574E C3                      		retn
 37871                                  
 37872                                  ; ----------------------------------------------------------------------------
 37873                                  ; space.c (FDISK, MSDOS 6.0, 1991)	
 37874                                  ; ----------------------------------------------------------------------------
 37875                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 20/01/2019)
 37876                                  
 37877                                  ;char find_ext_free_space()
 37878                                  ;
 37879                                  ;BEGIN
 37880                                  ;
 37881                                  ;char   i;
 37882                                  ;char   partition_count;
 37883                                  ;char   last_found_partition;
 37884                                  ;unsigned    temp;
 37885                                  ;char   freespace_count;
 37886                                  ;char   any_partition;
 37887                                  ;char   ext_location;
 37888                                  ;
 37889                                  ;        /* Sort the partition table */
 37890                                  ;        sort_ext_table(c(23));                                          /* AC000 */
 37891                                  ;
 37892                                  ;        /* Initialize free space to zero */
 37893                                  ;        for (i = c(0); i < c(24); i++)                                  /* AC000 */
 37894                                  ;           BEGIN
 37895                                  ;            free_space[i].space = u(0);                                 /* AC000 */
 37896                                  ;            free_space[i].start = u(0);
 37897                                  ;            free_space[i].end = u(0);                                   /* AC000 */
 37898                                  ;            free_space[i].mbytes_unused = f(0);                         /* AN000 */
 37899                                  ;            free_space[i].percent_unused = u(0);                        /* AN000 */
 37900                                  ;           END
 37901                                  ;
 37902                                  ;        /* Find space between start of Extended partition and first volume */
 37903                                  ;        ext_location = find_partition_location(uc(EXTENDED));           /* AC000 */
 37904                                  ;
 37905                                  ;        partition_count = c(0);                                         /* AC000 */
 37906                                  ;
 37907                                  ;        any_partition = FALSE;
 37908                                  ;        for (i = c(0); i < c(23); i++)                                  /* AC000 */
 37909                                  ;           BEGIN
 37910                                  ;            if (ext_table[cur_disk][sort[i]].sys_id != uc(0))           /* AC000 */
 37911                                  ;               BEGIN
 37912                                  ;                /* Found a partition, get the space */
 37913                                  ;                free_space[0].space = ext_table[cur_disk][sort[i]].start_cyl - part_table[cur_disk][ext_location].start_cyl;
 37914                                  ;                free_space[0].start = part_table[cur_disk][ext_location].start_cyl;
 37915                                  ;                free_space[0].end = ext_table[cur_disk][sort[i]].start_cyl-1;
 37916                                  ;                free_space[0].mbytes_unused =
 37917                                  ;                     cylinders_to_mbytes(free_space[0].space,cur_disk); /* AN004 */
 37918                                  ;                free_space[0].percent_unused = (unsigned)cylinders_to_percent(free_space[0].space,total_disk[cur_disk]); /* AN000 */
 37919                                  ;
 37920                                  ;                partition_count = i;
 37921                                  ;                last_found_partition = sort[i];
 37922                                  ;                any_partition = TRUE;
 37923                                  ;                break;
 37924                                  ;               END
 37925                                  ;           END
 37926                                  ;        /* See if any partitions were there */
 37927                                  ;        if (any_partition)
 37928                                  ;           BEGIN
 37929                                  ;            /* Look for space between the rest of the partitions */
 37930                                  ;            freespace_count = c(1);                                     /* AC000 */
 37931                                  ;            for (i = partition_count+1; i < c(23); i++)                 /* AC000 */
 37932                                  ;               BEGIN
 37933                                  ;                if (ext_table[cur_disk][sort[i]].sys_id != uc(0))       /* AC000 */
 37934                                  ;                   BEGIN
 37935                                  ;
 37936                                  ;                    /* Get space between the end of the last one and the start of the next one */
 37937                                  ;                    temp = ext_table[cur_disk][sort[i]].start_cyl - (ext_table[cur_disk][last_found_partition].end_cyl+1);
 37938                                  ;                    free_space[freespace_count].space = temp;
 37939                                  ;                    free_space[freespace_count].start = ext_table[cur_disk][last_found_partition].end_cyl+1;
 37940                                  ;                    free_space[freespace_count].end = ext_table[cur_disk][sort[i]].start_cyl -1;
 37941                                  ;                    free_space[freespace_count].mbytes_unused =
 37942                                  ;                         cylinders_to_mbytes(free_space[freespace_count].space,cur_disk);   /* AN004 */
 37943                                  ;                    free_space[freespace_count].percent_unused = (unsigned)
 37944                                  ;                         cylinders_to_percent(free_space[freespace_count].space,total_disk[cur_disk]); /* AN000 */
 37945                                  ;
 37946                                  ;                    /* update the last found partition */
 37947                                  ;                    last_found_partition = sort[i];
 37948                                  ;                    freespace_count++;
 37949                                  ;                   END
 37950                                  ;               END
 37951                                  ;            /* Find the space between the last partition and the end of the extended partition */
 37952                                  ;            temp = part_table[cur_disk][ext_location].end_cyl -  ext_table[cur_disk][last_found_partition].end_cyl;
 37953                                  ;            free_space[freespace_count].space = temp;
 37954                                  ;            free_space[freespace_count].start = ext_table[cur_disk][last_found_partition].end_cyl+1;
 37955                                  ;            free_space[freespace_count].end = part_table[cur_disk][ext_location].end_cyl;
 37956                                  ;            free_space[freespace_count].mbytes_unused =
 37957                                  ;                 cylinders_to_mbytes(free_space[freespace_count].space,cur_disk);    /* AN004 */
 37958                                  ;            free_space[freespace_count].percent_unused = (unsigned)
 37959                                  ;                 cylinders_to_percent(free_space[freespace_count].space,total_disk[cur_disk]);  /* AN000 */
 37960                                  ;           END
 37961                                  ;        else
 37962                                  ;           BEGIN
 37963                                  ;            /* No partitions found, show entire space as free */
 37964                                  ;            free_space[0].space = (part_table[cur_disk][ext_location].end_cyl - part_table[cur_disk][ext_location].start_cyl) + 1;
 37965                                  ;            free_space[0].start = part_table[cur_disk][ext_location].start_cyl;
 37966                                  ;            free_space[0].end = part_table[cur_disk][ext_location].end_cyl;
 37967                                  ;            free_space[0].mbytes_unused =
 37968                                  ;                 cylinders_to_mbytes(free_space[0].space,cur_disk);  /* AN004 */
 37969                                  ;            free_space[0].percent_unused = (unsigned)cylinders_to_percent(free_space[0].space,total_disk[cur_disk]); /* AN000 */
 37970                                  ;           END
 37971                                  ;
 37972                                  ;         /* Find largest free space */
 37973                                  ;         temp = u(0);                                                   /* AC000 */
 37974                                  ;
 37975                                  ;         /* Find largest free space, and verify the golden tracks while we are at it */
 37976                                  ;         do
 37977                                  ;            BEGIN
 37978                                  ;             temp = u(0);                                               /* AC000 */
 37979                                  ;
 37980                                  ;             /* Zip thru the table */
 37981                                  ;             for (i = c(0); i < c(24); i++)                             /* AC000 */
 37982                                  ;                BEGIN
 37983                                  ;                 /* Is this one bigger ? */
 37984                                  ;                 if (free_space[i].space > temp)
 37985                                  ;                    BEGIN
 37986                                  ;                     temp = free_space[i].space;
 37987                                  ;                     last_found_partition = i;
 37988                                  ;                    END
 37989                                  ;                END
 37990                                  ;             /* If there is any free space, go verify it */
 37991                                  ;             temp = u(0);
 37992                                  ;             if (free_space[last_found_partition].space != u(0))       /* AC000 */
 37993                                  ;                BEGIN
 37994                                  ;
 37995                                  ;                 /* Go verify the tracks */
 37996                                  ;                 temp = verify_tracks(last_found_partition,c(EXTENDED)); /* AC000 */
 37997                                  ;                END
 37998                                  ;             /* Move up to next golden track */
 37999                                  ;             free_space[last_found_partition].start = free_space[last_found_partition].start+temp;
 38000                                  ;             free_space[last_found_partition].space = free_space[last_found_partition].space-temp;
 38001                                  ;             free_space[last_found_partition].mbytes_unused =
 38002                                  ;                  cylinders_to_mbytes(free_space[last_found_partition].space,cur_disk);    /* AN004 */
 38003                                  ;             free_space[last_found_partition].percent_unused =
 38004                                  ;                  cylinders_to_percent(free_space[last_found_partition].space,total_disk[cur_disk]); /* AN000 */
 38005                                  ;             END
 38006                                  ;             /* Repeat the loop if the start was moved due to bad tracks */
 38007                                  ;            /* Unless we're past the end of the free space */
 38008                                  ;            while ((temp !=u(0)) && (free_space[last_found_partition].space!= u(0)));  /* AC000 */
 38009                                  ;
 38010                                  ;        /* Don't create a partition larger than DOS can handle */                              /*C05*/
 38011                                  ;        if(free_space[last_found_partition].mbytes_unused > u(MAX_PART_SIZE))                  /*C05*/
 38012                                  ;          BEGIN                                                                                /*C05*/
 38013                                  ;          free_space[last_found_partition].space =                                             /*C05*/
 38014                                  ;           mbytes_to_cylinders(f(MAX_PART_SIZE),cur_disk) - 1;                                 /*C05*/
 38015                                  ;          free_space[last_found_partition].end =                                               /*C05*/
 38016                                  ;           free_space[last_found_partition].start+free_space[last_found_partition].space-1;    /*C05*/
 38017                                  ;          free_space[last_found_partition].mbytes_unused =                                     /*C05*/
 38018                                  ;           cylinders_to_mbytes(free_space[last_found_partition].space,cur_disk);               /*C05*/
 38019                                  ;          free_space[last_found_partition].percent_unused = (unsigned)                         /*C05*/
 38020                                  ;           cylinders_to_percent(free_space[last_found_partition].space,total_disk[cur_disk]);  /*C05*/
 38021                                  ;          END                                                                                  /*C05*/
 38022                                  ;
 38023                                  ;        /* Return with the pointer to the largest free space */
 38024                                  ;        return(last_found_partition);
 38025                                  ;END
 38026                                  
 38027                                  find_ext_free_space:
 38028                                  		; 21/01/2019
 38029                                  		; 20/01/2019
 38030                                  
 38031                                  	%define fefs_i		     	bp-12	;bp-14
 38032                                  	%define fefs_ext_location    	bp-10	;bp-12
 38033                                  	%define fefs_last_found_part 	bp-8	;bp-10
 38034                                  	%define fefs_temp	     	bp-6	;bp-8
 38035                                  	%define fefs_freespace_count 	bp-4	;bp-6
 38036                                  	%define fefs_partition_count 	bp-2	;bp-4
 38037                                  	%define fefs_any_partition   		;bp-2
 38038                                  
 38039 0000574F 55                      		push	bp
 38040 00005750 89E5                    		mov	bp,sp
 38041                                  		;sub	sp,14
 38042 00005752 83EC0C                  		sub	sp,12
 38043                                  
 38044                                  		;push	di
 38045                                  		;push	si
 38046                                  
 38047                                  		;/* Sort the partition table */
 38048                                  
 38049                                  		;mov	al,23
 38050                                  		;push	ax
 38051 00005755 B117                    		mov	cl,23
 38052 00005757 E8ABD2                  		call	sort_ext_table
 38053                                  		;pop	bx
 38054                                  
 38055                                  		;/* Initialize free space to zero */
 38056                                  
 38057 0000575A 31C0                    		xor	ax,ax ; 21/01/2019
 38058                                  
 38059                                  		;mov	word [fefs_i],0
 38060 0000575C 8946F4                  		mov	[fefs_i],ax ; 0
 38061                                  fefs_1:
 38062                                  		;;mov	al,22
 38063                                  		;mov	al,10
 38064                                  		;;imul	byte [fefs_i]
 38065                                  		;mul	byte [fefs_i]
 38066                                  		;mov	bx,ax
 38067                                  		;sub	ax,ax
 38068                                  		;mov	[free_space.space+bx],ax
 38069                                  		;mov	[free_space.start+bx],ax
 38070                                  		;mov	[free_space.end+bx],ax
 38071                                  		;mov	[free_space.mbytes_unused+bx],ax
 38072                                  		;mov	[free_space.percent_unused+bx],ax
 38073                                  		;inc	byte [fefs_i]
 38074                                  		;cmp	byte [fefs_i],24
 38075                                  		;jl	short fefs_1
 38076                                  
 38077                                  		;push	cs
 38078                                  		;pop	es
 38079 0000575F BF[E2CB]                		mov	di,fspc ; free_space.space
 38080 00005762 B97800                  		mov	cx,24*5 ; (24*10/2) ; 20/01/2019
 38081                                  		;xor	ax,ax ; 0
 38082 00005765 F3AB                    		rep	stosw
 38083                                  
 38084                                  	;/* Find space between start of Extended partition and first volume */
 38085                                  
 38086                                  		;mov	al,5
 38087                                  		;push	ax
 38088                                  		;call	find_partition_location
 38089                                  		;pop	bx
 38090                                  
 38091                                  		;mov	[fefs_ext_location],al
 38092                                  		
 38093                                  		; 20/01/2019
 38094                                  		; get partition entry number of extended dos partion
 38095                                   		; 	(on current disk/drive)
 38096 00005767 B005                    		mov	al,5  ; EXTENDED partition ID
 38097 00005769 E84EC6                  		call	find_partition_type
 38098                                  		; CL = partition number (index), 0 to 3 or 4 (not found)
 38099                                  
 38100 0000576C 884EF6                  		mov	[fefs_ext_location],cl
 38101                                  
 38102 0000576F 28C0                    		sub	al,al ; 0
 38103 00005771 8846FE                  		mov	[fefs_partition_count],al ; 0
 38104                                  		;mov	[fefs_any_partition],al ; 0
 38105                                  		;mov	[fefs_i],al ; 0
 38106                                  		;jmp	short fefs_3
 38107 00005774 EB0C                    		jmp	short fefs_4
 38108                                  fefs_2:
 38109 00005776 FE46F4                  		inc	byte [fefs_i]
 38110                                  fefs_3:
 38111 00005779 807EF417                		cmp	byte [fefs_i],23
 38112 0000577D 7203                    		jb	short fefs_4
 38113                                  		;jmp	fefs_5
 38114                                  		;jnb	short fefs_5  ; [fefs_any_partition] = 0
 38115 0000577F E96001                  		jmp	fefs_11 ; [fefs_any_partition] = 0
 38116                                  fefs_4:
 38117 00005782 A0[D4CB]                		mov	al,[cur_disk]
 38118                                  		;cbw
 38119 00005785 B91800                  		mov	cx,24
 38120                                  		;mov	bx,ax
 38121 00005788 88C3                    		mov	bl,al
 38122                                  		;imul	cx
 38123 0000578A F6E1                    		mul	cl
 38124                                  		;mov	cx,ax ; ah = 0
 38125                                  		;mov	al,[fefs_i]
 38126                                  		;cbw
 38127                                  		;mov	si,ax
 38128 0000578C 8B76F4                  		mov	si,[fefs_i] ; =**=
 38129                                  		;mov	al,[sort+si]
 38130 0000578F 8A8C[E2C3]              		mov	cl,[sort+si]
 38131                                  		;cbw
 38132                                  		;add	ax,cx
 38133 00005793 00C8                    		add	al,cl
 38134                                  		;mov	cx,46
 38135                                  		;imul	cx
 38136 00005795 B12E                    		mov	cl,46
 38137 00005797 F6E1                    		mul	cl
 38138 00005799 89C7                    		mov	di,ax
 38139                                  	
 38140 0000579B 80BD[4FA1]00            		cmp	byte [ext_table_sys_id+di],0
 38141 000057A0 74D4                    		je	short fefs_2
 38142                                  
 38143                                  		;shl	bx,1
 38144                                  		;shl	bx,1
 38145 000057A2 D0E3                    		shl	bl,1
 38146 000057A4 D0E3                    		shl	bl,1
 38147 000057A6 8A46F6                  		mov	al,[fefs_ext_location]
 38148                                  		;cbw
 38149                                  		;add	ax,bx
 38150 000057A9 00D8                    		add	al,bl
 38151                                  		;imul	cx
 38152 000057AB F6E1                    		mul	cl
 38153 000057AD 89C3                    		mov	bx,ax
 38154                                  		;mov	ax,[part_table_start_cyl+bx]
 38155                                  		;mov	[free_space.start],ax
 38156 000057AF 8B97[15C4]              		mov	dx,[part_table_start_cyl+bx]
 38157 000057B3 8916[E4CB]              		mov	[free_space.start],dx
 38158 000057B7 8B8D[4DA1]              		mov	cx,[ext_table_start_cyl+di]
 38159                                  		;mov	dx,cx
 38160 000057BB 89C8                    		mov	ax,cx
 38161 000057BD 49                      		dec	cx
 38162 000057BE 890E[E6CB]              		mov	[free_space.end],cx
 38163                                  		;mov	cl,[cur_disk]
 38164                                  		;push	cx
 38165 000057C2 8A1E[D4CB]              		mov	bl,[cur_disk]	      ; BX = Drive number	
 38166 000057C6 30FF                    		xor	bh,bh
 38167 000057C8 53                      		push	bx ; *
 38168                                  		;sub	dx,ax
 38169 000057C9 29D0                    		sub	ax,dx
 38170                                  		;mov	[free_space.space],dx
 38171 000057CB A3[E2CB]                		mov	[free_space.space],ax ; AX = CYLINDERS
 38172                                  		;push	dx
 38173                                  			; BX = drive number (0 to 7)
 38174                                  			; AX = cylinders
 38175 000057CE E88BBD                  		call	cylinders_to_mbytes
 38176                                  		;pop	bx
 38177                                  		;pop	bx
 38178 000057D1 A3[E8CB]                		mov	[free_space.mbytes_unused],ax
 38179                                  
 38180                                  		;mov	al,[cur_disk]
 38181                                  		;cbw
 38182                                  		;mov	bx,ax
 38183 000057D4 5B                      		pop	bx ; *
 38184                                  		;shl	bx,1
 38185 000057D5 D0E3                    		shl	bl,1
 38186                                  		;push	word [total_disk+bx]
 38187 000057D7 8B8F[B8A0]              		mov	cx,[total_disk+bx]  ; total (disk) cylinders -divisor-
 38188                                  		;push	word [free_space.space]
 38189 000057DB 8B1E[E2CB]              		mov	bx,[free_space.space] ; num of cylinders (of partition) -dividend-
 38190 000057DF E8CDBD                  		call	cylinders_to_percent
 38191                                  		;pop	bx
 38192                                  		;pop	bx
 38193 000057E2 A3[EACB]                		mov	[free_space.percent_unused],ax
 38194 000057E5 8A46F4                  		mov	al,[fefs_i]
 38195 000057E8 8846FE                  		mov	[fefs_partition_count],al
 38196 000057EB 8A84[E2C3]              		mov	al,[sort+si] ; =**=
 38197 000057EF 8846F8                  		mov	[fefs_last_found_part],al
 38198                                  		;mov	[fefs_any_partition],1
 38199                                  
 38200                                  		;/* See if any partitions were there */
 38201                                  ;fefs_5:
 38202                                  ;		cmp	byte [fefs_any_partition],0
 38203                                  ;		jne	short fefs_6
 38204                                  ;		jmp	fefs_11
 38205                                  fefs_6:
 38206                                  		;/* Look for space between the rest of the partitions */
 38207                                  
 38208 000057F2 C646FC01                		mov	byte [fefs_freespace_count],1
 38209                                  		;mov	al,[fefs_partition_count]
 38210                                  		;inc	al
 38211                                  		;mov	[fefs_i],al
 38212                                  		;jmp	fefs_9
 38213                                  		; 21/01/2019
 38214 000057F6 EB77                    		jmp	short fefs_8 ; inc byte [fefs_i]
 38215                                  fefs_7:
 38216 000057F8 B018                    		mov	al,24
 38217                                  		;imul	byte [cur_disk]
 38218 000057FA F626[D4CB]              		mul	byte [cur_disk]
 38219                                  		;mov	cx,ax ; ah = 0
 38220 000057FE 88C3                    		mov	bl,al ; ==*
 38221                                  		;mov	al,[fefs_i]
 38222                                  		;cbw
 38223                                  		;;mov	bx,ax
 38224 00005800 8B76F4                  		mov	si,[fefs_i]  ; *==*
 38225                                  		;mov	al,[sort+bx]
 38226                                  		;cbw
 38227                                  		;add	ax,cx
 38228 00005803 8A8C[E2C3]              		mov	cl,[sort+si] ; *==*
 38229 00005807 00C8                    		add	al,cl	
 38230                                  	
 38231                                  		;mov	si,46
 38232                                  		;imul	si
 38233 00005809 B12E                    		mov	cl,46
 38234 0000580B F6E1                    		mul	cl
 38235                                  
 38236 0000580D 89C7                    		mov	di,ax
 38237                                  		
 38238 0000580F 80BD[4FA1]00            		cmp	byte [ext_table_sys_id+di],0
 38239 00005814 7459                    		je	short fefs_8
 38240                                  
 38241                                  	;/* Get space between the end of the last one and the start of the next one */
 38242                                  
 38243 00005816 8A46F8                  		mov	al,[fefs_last_found_part]
 38244                                  		;cbw
 38245                                  		;add	ax,cx
 38246 00005819 00D8                    		add	al,bl ; ==*
 38247                                  		;imul	si
 38248 0000581B F6E1                    		mul	cl ; * 46
 38249                                  		;mov	si,ax
 38250 0000581D 89C3                    		mov	bx,ax ; ++=
 38251                                  
 38252                                  		; 21/01/2019
 38253                                  		;mov	ax,[ext_table_start_cyl+di]
 38254                                  		;mov	cx,ax
 38255 0000581F 8B95[4DA1]              		mov	dx,[ext_table_start_cyl+di]
 38256 00005823 89D1                    		mov	cx,dx
 38257                                  		;;sub	ax,[ext_table_end_cyl+si]
 38258                                  		;sub	ax,[ext_table_end_cyl+bx] ; ++=
 38259                                  		;dec	ax
 38260                                  		;mov	[fefs_temp],ax
 38261                                  		;mov	dx,ax
 38262 00005825 2B97[52A1]              		sub	dx,[ext_table_end_cyl+bx] ; ++=
 38263 00005829 4A                      		dec	dx
 38264                                  		;mov	[fefs_temp],dx
 38265                                  
 38266                                  		;mov	al,22
 38267 0000582A B00A                    		mov	al,10
 38268                                  		;imul	byte [fefs_freespace_count]
 38269 0000582C F666FC                  		mul	byte [fefs_freespace_count]
 38270 0000582F 89C7                    		mov	di,ax
 38271 00005831 8995[E2CB]              		mov	[free_space.space+di],dx
 38272                                  		;mov	ax,[ext_table_end_cyl+si]
 38273 00005835 8B87[52A1]              		mov	ax,[ext_table_end_cyl+bx] ; ++=
 38274 00005839 40                      		inc	ax
 38275 0000583A 8985[E4CB]              		mov	[free_space.start+di],ax
 38276 0000583E 49                      		dec	cx
 38277 0000583F 898D[E6CB]              		mov	[free_space.end+di],cx
 38278                                  
 38279                                  		;mov	al,[cur_disk]
 38280                                  		;push	ax
 38281                                  		;push	word [free_space.space+di]
 38282                                  		;mov	si,bx
 38283                                  		
 38284 00005843 28FF                    		sub	bh,bh
 38285 00005845 8A1E[D4CB]              		mov	bl,[cur_disk]
 38286 00005849 53                      		push	bx ; *!*
 38287                                  
 38288                                  		;mov	ax,[free_space.space+di]
 38289 0000584A 89D0                    		mov	ax,dx 
 38290                                  			; bx = drive number (0 to 7)
 38291                                  			; ax = cylinders
 38292 0000584C E80DBD                  		call	cylinders_to_mbytes
 38293                                  		;pop	bx
 38294                                  		;pop	bx
 38295                                  
 38296 0000584F 8985[E8CB]              		mov	[free_space.mbytes_unused+di],ax
 38297                                  
 38298                                  		;mov	al,[cur_disk]
 38299                                  		;cbw
 38300                                  		;mov	bx,ax
 38301                                  		
 38302 00005853 5B                      		pop	bx ;*!*
 38303                                  
 38304                                  		;shl	bx,1
 38305 00005854 D0E3                    		shl	bl,1
 38306                                  		;push	word [total_disk+bx]
 38307 00005856 8B8F[B8A0]              		mov	cx,[total_disk+bx]
 38308                                  		;push	word [free_space.space+di]
 38309 0000585A 8B9D[E2CB]              		mov	bx,[free_space.space+di] 
 38310                                  			; cx = total (disk) cylinders -divisor-
 38311                                  			; bx = num of cylinders (of partition) -dividend-
 38312 0000585E E84EBD                  		call	cylinders_to_percent
 38313                                  		;pop	bx
 38314                                  		;pop	bx
 38315                                  
 38316 00005861 8985[EACB]              		mov	[free_space.percent_unused+di],ax
 38317                                  
 38318                                  		;/* update the last found partition */
 38319                                  
 38320 00005865 8A84[E2C3]              		mov	al,[sort+si] ; *==*
 38321 00005869 8846F8                  		mov	[fefs_last_found_part],al
 38322 0000586C FE46FC                  		inc	byte [fefs_freespace_count]
 38323                                  fefs_8:
 38324                                  
 38325 0000586F FE46F4                  		inc	byte [fefs_i]
 38326                                  fefs_9:
 38327 00005872 807EF417                		cmp	byte [fefs_i],23
 38328                                  		;jge	short fefs_10
 38329 00005876 7303                    		jnb	short fefs_10
 38330 00005878 E97DFF                  		jmp	fefs_7
 38331                                  fefs_10:
 38332                                  	;/* Find the space between the last partition and the end of the extended partition */
 38333                                  
 38334                                  		;mov	al,[fefs_last_found_part]
 38335 0000587B 8A56F8                  		mov	dl,[fefs_last_found_part] ; -*-
 38336                                  		;cbw
 38337                                  		;mov	cx,24
 38338 0000587E B118                    		mov	cl,24
 38339                                  		;mov	dx,ax
 38340 00005880 A0[D4CB]                		mov	al,[cur_disk] ; *-*-
 38341                                  		;cbw
 38342                                  		;mov	bx,dx
 38343                                  		;mov	si,ax
 38344 00005883 88C3                    		mov	bl,al ; *-*-
 38345                                  		;imul	cx
 38346 00005885 F6E1                    		mul	cl
 38347                                  		;add	ax,bx ; ah = 0
 38348 00005887 00D0                    		add	al,dl ; -*-
 38349                                  		;mov	cx,46
 38350                                  		;imul	cx
 38351 00005889 B12E                    		mov	cl,46
 38352 0000588B F6E1                    		mul	cl
 38353                                  		;mov	bx,ax
 38354 0000588D 89C6                    		mov	si,ax ; -**-
 38355 0000588F 8A46F6                  		mov	al,[fefs_ext_location]
 38356                                  		;cbw
 38357                                  		;shl	si,1
 38358                                  		;shl	si,1
 38359 00005892 D0E3                    		shl	bl,1 ; *-*-
 38360 00005894 D0E3                    		shl	bl,1
 38361                                  		;add	ax,si
 38362 00005896 00D8                    		add	al,bl ; *-*-
 38363                                  		;imul	cx
 38364 00005898 F6E1                    		mul	cl
 38365                                  		;mov	si,ax
 38366 0000589A 89C3                    		mov	bx,ax ; -***-
 38367                                  		;mov	ax,[part_table_end_cyl+si]
 38368 0000589C 8B8F[1AC4]              		mov	cx,[part_table_end_cyl+bx] ; -***-
 38369                                  		;mov	cx,ax
 38370 000058A0 89CA                    		mov	dx,cx ; ++
 38371                                  		;sub	ax,[ext_table_end_cyl+bx]
 38372 000058A2 2B8C[52A1]              		sub	cx,[ext_table_end_cyl+si] ; -**-
 38373                                  		;;mov	[fefs_temp],ax
 38374                                  		;mov	[fefs_temp],cx ; *+
 38375                                  		;mov	dx,ax
 38376                                  		;mov	al,22
 38377 000058A6 B00A                    		mov	al,10
 38378                                  		;imul	byte [fefs_freespace_count]
 38379 000058A8 F666FC                  		mul	byte [fefs_freespace_count]
 38380                                  		;mov	si,ax
 38381 000058AB 89C7                    		mov	di,ax ; -****-
 38382                                  		;mov	[free_space.space+si],dx
 38383 000058AD 898D[E2CB]              		mov	[free_space.space+di],cx ; -****- ; *+
 38384                                  
 38385                                  		;mov	ax,[ext_table_end_cyl+bx]
 38386 000058B1 8B84[52A1]              		mov	ax,[ext_table_end_cyl+si] ; -**-
 38387 000058B5 40                      		inc	ax
 38388                                  		;mov	[free_space.start+si],ax
 38389 000058B6 8985[E4CB]              		mov	[free_space.start+di],ax ; -****-
 38390                                  		;mov	[free_space.end+si],cx
 38391 000058BA 8995[E6CB]              		mov	[free_space.end+di],dx ; -****- ; ++
 38392                                  		
 38393                                  		;mov	al,[cur_disk]
 38394                                  		;push	ax
 38395 000058BE 28FF                    		sub	bh,bh
 38396 000058C0 8A1E[D4CB]              		mov	bl,[cur_disk]
 38397 000058C4 53                      		push	bx ; +**
 38398                                  		;push	word [free_space.space+si]
 38399                                  		;mov	ax,[free_space.space+di] ; *+
 38400 000058C5 89C8                    		mov	ax,cx ; *+ ; 21/01/2019
 38401                                  			; bx = drive number (0 to 7)
 38402                                  			; ax = cylinders	
 38403 000058C7 E892BC                  		call	cylinders_to_mbytes
 38404                                  		;pop	bx
 38405                                  		;pop	bx
 38406                                  		;mov	[free_space.mbytes_unused+si],ax
 38407 000058CA 8985[E8CB]              		mov	[free_space.mbytes_unused+di],ax
 38408                                  
 38409                                  		;mov	al,[cur_disk]
 38410                                  		;cbw
 38411                                  		;mov	bx,ax
 38412                                  		
 38413 000058CE 5B                      		pop	bx ; +**
 38414                                  
 38415                                  		;shl	bx,1
 38416 000058CF D0E3                    		shl	bl,1	
 38417                                  		
 38418                                  		;push	word [total_disk+bx]
 38419 000058D1 8B8F[B8A0]              		mov	cx,[total_disk+bx]
 38420                                  		;push	word [free_space.space+si]
 38421 000058D5 8B9D[E2CB]              		mov	bx,[free_space.space+di] 
 38422                                  			; cx = total (disk) cylinders -divisor-
 38423                                  			; bx = num of cylinders (of partition) -dividend-
 38424 000058D9 E8D3BC                  		call	cylinders_to_percent
 38425                                  		;pop	bx
 38426                                  		;pop	bx
 38427                                  		;mov	[free_space.percent_unused+si],ax
 38428 000058DC 8985[EACB]              		mov	[free_space.percent_unused+di],ax
 38429 000058E0 EB42                    		jmp	short fefs_12
 38430                                  fefs_11:
 38431                                  	;/* No partitions found, show entire space as free */
 38432                                  
 38433 000058E2 A0[D4CB]                		mov	al,[cur_disk]
 38434 000058E5 98                      		cbw
 38435                                  
 38436 000058E6 50                      		push	ax ; **
 38437                                  
 38438                                  		;shl	ax,1
 38439                                  		;shl	ax,1
 38440 000058E7 D0E0                    		shl	al,1
 38441 000058E9 D0E0                    		shl	al,1
 38442                                  		;mov	cx,ax
 38443                                  		;mov	al,[fefs_ext_location]
 38444                                  		;cbw
 38445                                  		;add	ax,cx
 38446 000058EB 0246F6                  		add	al,[fefs_ext_location]
 38447                                  		;mov	cx,46
 38448                                  		;imul	cx
 38449 000058EE B12E                    		mov	cl,46
 38450 000058F0 F6E1                    		mul	cl
 38451 000058F2 89C3                    		mov	bx,ax
 38452                                  		; 21/01/2019
 38453 000058F4 8B87[1AC4]              		mov	ax,[part_table_end_cyl+bx]
 38454                                  		;mov	cx,ax
 38455 000058F8 A3[E6CB]                		mov	[free_space.end],ax
 38456 000058FB 2B87[15C4]              		sub	ax,[part_table_start_cyl+bx]
 38457 000058FF 40                      		inc	ax
 38458 00005900 A3[E2CB]                		mov	[free_space.space],ax
 38459 00005903 8B97[15C4]              		mov	dx,[part_table_start_cyl+bx]
 38460 00005907 8916[E4CB]              		mov	[free_space.start],dx
 38461                                  		;mov	[free_space.end],cx
 38462                                  		;mov	cl,[cur_disk]
 38463                                  		;push	cx
 38464                                  		;push	ax
 38465 0000590B 5B                      		pop	bx ; **
 38466 0000590C 89DE                    		mov	si,bx ; **
 38467                                  			; bx = drive number (0 to 7)
 38468                                  			; ax = cylinders
 38469 0000590E E84BBC                  		call	cylinders_to_mbytes
 38470                                  		;pop	bx
 38471                                  		;pop	bx
 38472 00005911 A3[E8CB]                		mov	[free_space.mbytes_unused],ax
 38473                                  		
 38474                                  		;mov	al,[cur_disk]
 38475                                  		;cbw
 38476                                  		;mov	bx,ax
 38477                                  		;shl	bx,1
 38478 00005914 D1E6                    		shl	si,1 ; **
 38479                                  		;push	word [total_disk+bx]
 38480 00005916 8B8C[B8A0]              		mov	cx,[total_disk+si]
 38481                                  		;push	word [free_space.space]
 38482 0000591A 8B1E[E2CB]              		mov	bx,[free_space.space] 	
 38483                                  			; cx = total (disk) cylinders -divisor-
 38484                                  			; bx = num of cylinders (of partition) -dividend-
 38485 0000591E E88EBC                  		call	cylinders_to_percent
 38486                                  		;pop	bx
 38487                                  		;pop	bx
 38488 00005921 A3[EACB]                		mov	[free_space.percent_unused],ax
 38489                                  fefs_12:
 38490                                  		;mov	word [fefs_temp],0
 38491                                  fefs_13:
 38492                                  	;/* Find largest free space, and verify the golden tracks while we are at it */
 38493                                  
 38494 00005924 C746FA0000              		mov	word [fefs_temp],0
 38495                                  
 38496                                  		; /* Zip thru the table */
 38497                                  
 38498 00005929 C646F400                		mov	byte [fefs_i],0
 38499                                  fefs_14:
 38500                                  		;mov	al,22
 38501 0000592D B00A                    		mov	al,10
 38502                                  		;imul	byte [fefs_i]
 38503 0000592F F666F4                  		mul	byte [fefs_i]
 38504 00005932 89C3                    		mov	bx,ax
 38505                                  		;mov	ax,[fefs_temp]
 38506 00005934 8B87[E2CB]              		mov	ax,[free_space.space+bx]
 38507                                  		;cmp	[free_space.space+bx],ax
 38508 00005938 3B46FA                  		cmp	ax,[fefs_temp]
 38509 0000593B 7609                    		jbe	short fefs_15
 38510                                  		;mov	ax,[free_space.space+bx]
 38511 0000593D 8946FA                  		mov	[fefs_temp],ax
 38512 00005940 8A46F4                  		mov	al,[fefs_i]
 38513 00005943 8846F8                  		mov	[fefs_last_found_part],al
 38514                                  fefs_15:
 38515 00005946 FE46F4                  		inc	byte [fefs_i]
 38516 00005949 807EF418                		cmp	byte [fefs_i],24
 38517 0000594D 72DE                    		jb	short fefs_14
 38518                                  
 38519                                  		;/* If there is any free space, go verify it */
 38520                                  
 38521 0000594F C746FA0000              		mov	word [fefs_temp],0
 38522                                  
 38523                                  		;mov	al,22
 38524 00005954 B00A                    		mov	al,10
 38525                                  		;imul	byte [fefs_last_found_part]
 38526 00005956 F666F8                  		mul	byte [fefs_last_found_part]
 38527 00005959 89C3                    		mov	bx,ax
 38528                                  
 38529 0000595B 83BF[E2CB]00            		cmp	word [free_space.space+bx],0
 38530 00005960 740D                    		je	short fefs_16
 38531                                  
 38532                                  		;/* Go verify the tracks */
 38533                                  
 38534 00005962 B005                    		mov	al,5 ; EXTENDED  ; type
 38535 00005964 50                      		push	ax
 38536 00005965 8A46F8                  		mov	al,[fefs_last_found_part] ; pointer
 38537 00005968 50                      		push	ax
 38538 00005969 E87201                  		call	verify_tracks
 38539                                  		;pop	bx
 38540                                  		;pop	bx
 38541 0000596C 8946FA                  		mov	[fefs_temp],ax
 38542                                  fefs_16:
 38543                                  		;/* Move up to next golden track */
 38544                                  
 38545                                  		;mov	al,22
 38546 0000596F B00A                    		mov	al,10
 38547                                  		;imul	byte [fefs_last_found_part]
 38548 00005971 F666F8                  		mul	byte [fefs_last_found_part]
 38549                                  		;mov	bx,ax
 38550 00005974 89C6                    		mov	si,ax
 38551 00005976 8B46FA                  		mov	ax,[fefs_temp]
 38552                                  		;add	[free_space.start+bx],ax
 38553 00005979 0184[E4CB]              		add	[free_space.start+si],ax
 38554                                  
 38555                                  		;mov	cl,[cur_disk]
 38556                                  		;push	cx
 38557                                  		;sub	[free_space.space+bx],ax
 38558                                  		;push	word [free_space.space+bx]
 38559                                  		;mov	si,bx
 38560 0000597D 30FF                    		xor	bh,bh
 38561 0000597F 8A1E[D4CB]              		mov	bl,[cur_disk]
 38562 00005983 53                      		push	bx ; --*
 38563 00005984 2984[E2CB]              		sub	[free_space.space+si],ax
 38564 00005988 8B84[E2CB]              		mov	ax,[free_space.space+si]
 38565                                  			; bx = drive number (0 to 7)
 38566                                  			; ax = cylinders
 38567 0000598C E8CDBB                  		call	cylinders_to_mbytes
 38568                                  		;pop	bx
 38569                                  		;pop	bx
 38570 0000598F 8984[E8CB]              		mov	[free_space.mbytes_unused+si],ax
 38571                                  
 38572                                  		;mov	al,[cur_disk]
 38573                                  		;cbw
 38574                                  		;mov	bx,ax
 38575 00005993 5B                      		pop	bx; --*
 38576                                  		;shl	bx,1
 38577 00005994 D0E3                    		shl	bl,1
 38578                                  		;push	word [total_disk+bx]
 38579 00005996 8B8F[B8A0]              		mov	cx,[total_disk+bx]
 38580                                  		;push	word [free_space.space+si]
 38581 0000599A 8B9C[E2CB]              		mov	bx,[free_space.space+si]
 38582                                  			; cx = total (disk) cylinders -divisor-
 38583                                  			; bx = num of cylinders (of partition) -dividend-
 38584 0000599E E80EBC                  		call	cylinders_to_percent
 38585                                  		;pop	bx
 38586                                  		;pop	bx
 38587 000059A1 8984[EACB]              		mov	[free_space.percent_unused+si],ax
 38588                                  
 38589                                  	;/* Repeat the loop if the start was moved due to bad tracks */
 38590                                          ;/* Unless we're past the end of the free space */
 38591                                  
 38592 000059A5 31C0                    		xor	ax,ax ; 20/01/2019
 38593                                  
 38594                                  		;cmp	word [fefs_temp],0
 38595 000059A7 3946FA                  		cmp	[fefs_temp],ax ; 0
 38596 000059AA 7409                    		je	short fefs_17
 38597                                  
 38598                                  		;;mov	al,22
 38599                                  		;mov	al,10
 38600                                  		;;imul	byte [fefs_last_found_part]
 38601                                  		;mul	byte [fefs_last_found_part]
 38602                                  		;mov	bx,ax
 38603                                  		;;cmp	word [free_space.space+bx],0
 38604                                  		;cmp	word [free_space.space+si],0
 38605 000059AC 3984[E2CB]              		cmp	[free_space.space+si],ax ; 0
 38606 000059B0 7403                    		je	short fefs_17
 38607 000059B2 E96FFF                  		jmp	fefs_13
 38608                                  fefs_17:
 38609                                  	;/* Don't create a partition larger than DOS can handle */ 
 38610                                  
 38611 000059B5 E97BF9                  		jmp	fefs_18  ; 20/01/2019
 38612                                  
 38613                                  ;		;;mov	al,22
 38614                                  ;		;mov	al,10
 38615                                  ;		;;imul	byte [fefs_last_found_part]
 38616                                  ;		;mul	byte [fefs_last_found_part]
 38617                                  ;		;mov	bx,ax
 38618                                  ;
 38619                                  ;		;cmp	[free_space.mbytes_unused+bx],2048
 38620                                  ;		cmp	[free_space.mbytes_unused+si],2048  ; 2 GB limit
 38621                                  ;		jbe	short fefs_18
 38622                                  ;
 38623                                  ;		mov	al,[cur_disk]
 38624                                  ;		; ah = 0
 38625                                  ;
 38626                                  ;		push	ax ; *
 38627                                  ;		
 38628                                  ;		push	ax
 38629                                  ;		mov	ax,2048
 38630                                  ;		push	ax
 38631                                  ;		mov	si,bx
 38632                                  ;		call	mbytes_to_cylinders
 38633                                  ;		;pop	bx
 38634                                  ;		;pop	bx
 38635                                  ;
 38636                                  ;		pop	di ; *
 38637                                  ;
 38638                                  ;		dec	ax
 38639                                  ;
 38640                                  ;		mov	[free_space.space+si],ax
 38641                                  ;
 38642                                  ;		;mov	ax,[free_space.start+si]
 38643                                  ;		;add	ax,[free_space.space+si]
 38644                                  ;
 38645                                  ;		add	ax,[free_space.start+si]
 38646                                  ;
 38647                                  ;		dec	ax
 38648                                  ;		mov	[free_space.end+si],ax
 38649                                  ;
 38650                                  ;		;mov	al,[cur_disk]
 38651                                  ;		;push	ax
 38652                                  ;		;push	word [free_space.space+si]
 38653                                  ;		mov	ax,[free_space.space+si]
 38654                                  ;		mov	bx,di ; *
 38655                                  ;		call	cylinders_to_mbytes
 38656                                  ;		;pop	bx
 38657                                  ;		;pop	bx
 38658                                  ;
 38659                                  ;		mov	[free_space.mbytes_unused+si],ax
 38660                                  ;
 38661                                  ;		;mov	al,[cur_disk]
 38662                                  ;		;cbw
 38663                                  ;		;mov	bx,ax
 38664                                  ;		;shl	bx,1
 38665                                  ;		;push	word [total_disk+bx]
 38666                                  ;		shl	di,1 ; *
 38667                                  ;		mov	cx,[total_disk+di]
 38668                                  ;		;push	word [free_space.space+si]
 38669                                  ;		mov	bx,[free_space.space+si]
 38670                                  ;		call	cylinders_to_percent
 38671                                  ;		;pop	bx
 38672                                  ;		;pop	bx
 38673                                  ;		mov	[free_space.percent_unused+si],ax
 38674                                  ;fefs_18:
 38675                                  ;		mov	al,[fefs_last_found_part] ; mov al,[bp-8]
 38676                                  ;
 38677                                  ;		;pop	si
 38678                                  ;		;pop	di
 38679                                  ;
 38680                                  ;		mov	sp,bp
 38681                                  ;		pop	bp
 38682                                  ;		retn
 38683                                  
 38684                                  ; ----------------------------------------------------------------------------
 38685                                  ; makepart.c (FDISK, MSDOS 6.0, 1991)	
 38686                                  ; ----------------------------------------------------------------------------
 38687                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 21/01/2019)
 38688                                  
 38689                                  ;char make_volume(size,free_pointer)
 38690                                  ;
 38691                                  ;unsigned    size;
 38692                                  ;char   free_pointer;
 38693                                  ;
 38694                                  ;BEGIN
 38695                                  ;
 38696                                  ;    char table_pointer;
 38697                                  ;    unsigned ext_part_num;                                        /* AN000 */
 38698                                  ;    unsigned char   temp;
 38699                                  ;    unsigned long   total_sectors;
 38700                                  ;
 38701                                  ;    /* Find a free spot to put it in */
 38702                                  ;    table_pointer = find_free_ext();
 38703                                  ;
 38704                                  ;    if (table_pointer != ((char)(NOT_FOUND)))
 38705                                  ;       BEGIN
 38706                                  ;        /* found a free partition, now lets go fill it up */
 38707                                  ;
 38708                                  ;        /* This can never be marked active */
 38709                                  ;        ext_table[cur_disk][table_pointer].boot_ind = uc(0);     /* AC000 */
 38710                                  ;
 38711                                  ;        /* Go get the start cylinder */
 38712                                  ;        ext_table[cur_disk][table_pointer].start_cyl = free_space[free_pointer].start;
 38713                                  ;
 38714                                  ;        /* Setup end cylinder */
 38715                                  ;        ext_table[cur_disk][table_pointer].end_cyl = ext_table[cur_disk][table_pointer].start_cyl + size - 1;
 38716                                  ;
 38717                                  ;        /* Start sector is always 1 */
 38718                                  ;        ext_table[cur_disk][table_pointer].start_sector = uc(1);  /* AC000 */
 38719                                  ;
 38720                                  ;        /* End sector is always the last sector */
 38721                                  ;        ext_table[cur_disk][table_pointer].end_sector = max_sector[cur_disk];
 38722                                  ;
 38723                                  ;        /* End head is always the last head */
 38724                                  ;        ext_table[cur_disk][table_pointer].end_head = uc(max_head[cur_disk]-1);  /* AC004 */
 38725                                  ;
 38726                                  ;        /* Start head is always 1 - NOTE: This is a shortcut for PC-DOS */
 38727                                  ;        /* If this is being modified for IFS drivers this may not be the */
 38728                                  ;        /* the case - use caution */
 38729                                  ;        ext_table[cur_disk][table_pointer].start_head = uc(1);   /* AC000 */
 38730                                  ;
 38731                                  ;        /* Figure out the total number of sectors */
 38732                                  ;        /* Total sectors in partition =                    */
 38733                                  ;        /* [(end_cyl - start_cyl)*(max_sector)*(max_head)] */
 38734                                  ;        /* - [start_head * max_sector]                     */
 38735                                  ;        /* Note: This is assuming a track or cylinder aligned partition */
 38736                                  ;
 38737                                  ;        /* First - get the total size in Cylinders assuming head 0 start*/
 38738                                  ;        total_sectors = ((unsigned long)(ext_table[cur_disk][table_pointer].end_cyl -
 38739                                  ;          ext_table[cur_disk][table_pointer].start_cyl+1));
 38740                                  ;
 38741                                  ;        /* Now multiply it by the number of sectors and heads per track */
 38742                                  ;        total_sectors = total_sectors * max_sector[cur_disk] * max_head[cur_disk];
 38743                                  ;
 38744                                  ;        /* This will give us the total of sectors if it is cyl aligned */
 38745                                  ;        /* Now, if it isn't aligned on head 0, we need to subtract off */
 38746                                  ;        /* the skipped tracks in the first cylinder  */
 38747                                  ;
 38748                                  ;        /* Because the head is zero based, we can get the total number of */
 38749                                  ;        /* skipped sectors by multipling the head number by sectors per track */
 38750                                  ;        total_sectors = total_sectors - ((unsigned long)(ext_table[cur_disk][table_pointer].start_head *
 38751                                  ;                           max_sector[cur_disk]));
 38752                                  ;
 38753                                  ;        ext_table[cur_disk][table_pointer].num_sec = total_sectors;
 38754                                  ;
 38755                                  ;        /* Get the relative sector */
 38756                                  ;        /* Figure out the total number of sectors */
 38757                                  ;        /* Total sectors before partition = max_sector     */
 38758                                  ;        /* NOTE: Again, this is a PC-DOS 3.30 shortcut - by definition */
 38759                                  ;        /* a logical drive always starts on head 1, so there is always */
 38760                                  ;        /* one tracks worth of sectors before it. Hence, max_sector */
 38761                                  ;
 38762                                  ;        /* Save it! */
 38763                                  ;        ext_table[cur_disk][table_pointer].rel_sec = ((unsigned long)(max_sector[cur_disk]));
 38764                                  ;
 38765                                  ;        /* Setup the system id byte */
 38766                                  ;        /* Set to 06h - format will fix later on */
 38767                                  ;        /* EGH; 7/03/90; We fix up the size ourselves here. The
 38768                                  ;           calculation is simple. If total_sectors > 65536 then
 38769                                  ;           type = 06 else if total_sectors > 32680 then type = 04
 38770                                  ;           else type = 01 */
 38771                                  ;
 38772                                  ;        if (ext_table[cur_disk][table_pointer].num_sec > ul(65536))     /*C23*/
 38773                                  ;            temp = uc(DOSNEW);                                         /* AC000 */                                    /*  AN000  */
 38774                                  ;        else if (ext_table[cur_disk][table_pointer].num_sec > ul(FAT16_SIZE)) /*C23*/
 38775                                  ;            temp = uc(DOS16);                                           /*C23*/
 38776                                  ;        else                                                            /*C23*/
 38777                                  ;            temp = uc(DOS12);                                           /*C23*/
 38778                                  ;
 38779                                  ;        /* We got the sys id, now put it in */
 38780                                  ;        ext_table[cur_disk][table_pointer].sys_id = temp;
 38781                                  ;
 38782                                  ;        /* Set the changed flag */
 38783                                  ;        ext_table[cur_disk][table_pointer].changed = TRUE;
 38784                                  ;
 38785                                  ;        /* Set the mbytes used */
 38786                                  ;        ext_table[cur_disk][table_pointer].mbytes_used =
 38787                                  ;            cylinders_to_mbytes(size,cur_disk);                   /* AN004 */
 38788                                  ;
 38789                                  ;        /* find the number of the extended partition to figure out percent */
 38790                                  ;        ext_part_num = find_partition_location(uc(EXTENDED));              /* AN000 */
 38791                                  ;
 38792                                  ;        /* Set the percent used */
 38793                                  ;        ext_table[cur_disk][table_pointer].percent_used =
 38794                                  ;            cylinders_to_percent(((ext_table[cur_disk][table_pointer].end_cyl-ext_table[cur_disk][table_pointer].start_cyl)+1),
 38795                                  ;            ((part_table[cur_disk][ext_part_num].end_cyl-part_table[cur_disk][ext_part_num].start_cyl)+1)); /* AN000 */
 38796                                  ;
 38797                                  ;        /* set the system to unknown and volume label to blanks */
 38798                                  ;        strcpy(ext_table[cur_disk][table_pointer].system,NOFORMAT);     /* AN000 */
 38799                                  ;        strcpy(ext_table[cur_disk][table_pointer].vol_label,NOVOLUME);  /* AN000 */
 38800                                  ;
 38801                                  ;       END
 38802                                  ;    else
 38803                                  ;
 38804                                  ;       BEGIN
 38805                                  ;        /* This should not have happened */
 38806                                  ;        internal_program_error();
 38807                                  ;       END
 38808                                  ;
 38809                                  ;    return(table_pointer);
 38810                                  ;END
 38811                                  
 38812                                  make_volume:
 38813                                  		; 21/01/2019
 38814                                  
 38815                                  	;%define mv_total_secs_lw 	;bp-10	;bp-14
 38816                                  	;%define mv_total_secs_hw 	;bp-8	;bp-12
 38817                                  	%define mv_table_ptr	bp-2 	;bp-6	;bp-10
 38818                                  	;%define mv_ext_part_num 	;bp-4	;bp-8
 38819                                  	;%define mv_temp	 	;bp-2	;bp-6
 38820                                  
 38821                                  	%define mv_size		bp+4
 38822                                  	%define mv_free_ptr	bp+6
 38823                                  
 38824 000059B8 55                      		push	bp
 38825 000059B9 89E5                    		mov	bp,sp
 38826                                  
 38827                                  		;;;sub	sp,14
 38828                                  		;;sub	sp,10
 38829                                  		;sub	sp,2
 38830                                  
 38831                                  		;xor	ax,ax
 38832 000059BB 50                      		push	ax ; sub sp,2
 38833                                  
 38834                                  		;push	di
 38835                                  		;push	si
 38836                                  
 38837                                  		;/* Find a free spot to put it in */
 38838                                  		
 38839 000059BC E8F900                  		call	find_free_ext
 38840 000059BF 8846FE                  		mov	[mv_table_ptr],al
 38841 000059C2 FEC0                    		inc	al
 38842 000059C4 7503                    		jnz	short mv_1
 38843 000059C6 E9E700                  		jmp	mv_8
 38844                                  mv_1:
 38845                                  	;/* found a free partition, now lets go fill it up */
 38846                                  
 38847 000059C9 A0[D4CB]                		mov	al,[cur_disk]
 38848 000059CC 98                      		cbw
 38849                                  		;mov	cx,24
 38850 000059CD B118                    		mov	cl,24
 38851 000059CF 89C3                    		mov	bx,ax  ; *****
 38852                                  		;imul	cx
 38853 000059D1 F6E1                    		mul	cl
 38854                                  		;mov	cx,ax
 38855                                  
 38856                                  		;mov	al,[mv_table_ptr]
 38857                                  		;cbw
 38858                                  		;add	ax,cx
 38859                                  
 38860                                  		; ah = 0
 38861 000059D3 0246FE                  		add	al,[mv_table_ptr]
 38862                                  		
 38863                                  		;mov	cx,46
 38864                                  		;imul	cx
 38865 000059D6 B12E                    		mov	cl,46
 38866 000059D8 F6E1                    		mul	cl
 38867                                  
 38868 000059DA 89C6                    		mov	si,ax ; *-+*
 38869                                  
 38870                                  		;/* This can never be marked active */
 38871 000059DC C684[4AA1]00            		mov	byte [ext_table_boot_ind+si],0
 38872                                  
 38873                                  		;/* Go get the start cylinder */
 38874                                  
 38875                                  		;mov	al,22
 38876 000059E1 B00A                    		mov	al,10
 38877                                  		;imul	byte [mv_free_ptr]
 38878 000059E3 F66606                  		mul	byte [mv_free_ptr]
 38879 000059E6 89C7                    		mov	di,ax
 38880                                  
 38881 000059E8 8B85[E4CB]              		mov	ax,[free_space.start+di]
 38882 000059EC 8984[4DA1]              		mov	[ext_table_start_cyl+si],ax
 38883                                  
 38884                                  		;/* Setup end cylinder */
 38885                                  
 38886 000059F0 034604                  		add	ax,[mv_size]
 38887 000059F3 48                      		dec	ax
 38888 000059F4 8984[52A1]              		mov	[ext_table_end_cyl+si],ax
 38889                                  
 38890                                  		;/* Start sector is always 1 */
 38891                                  
 38892 000059F8 C684[4CA1]01            		mov	byte [ext_table_start_sector+si],1
 38893                                  
 38894                                  		;/* End sector is always the last sector */
 38895                                  
 38896 000059FD 8A87[A0A0]              		mov	al,[max_sector+bx]
 38897                                  		
 38898 00005A01 28E4                    		sub	ah,ah
 38899 00005A03 89C7                    		mov	di,ax ; -**- ; [start_head * max_sector]  
 38900                                  
 38901 00005A05 8884[51A1]              		mov	[ext_table_end_sector+si],al
 38902                                  		
 38903                                  		;/* End head is always the last head */
 38904                                  
 38905 00005A09 D1E3                    		shl	bx,1  ; *****
 38906 00005A0B 8A8F[A8A0]              		mov	cl,[max_head+bx] ; num of (disk) heads
 38907 00005A0F 88CC                    		mov	ah,cl ; 21/01/2019
 38908 00005A11 FEC9                    		dec	cl
 38909 00005A13 888C[50A1]              		mov	[ext_table_end_head+si],cl
 38910                                  
 38911                                  	;/* Start head is always 1 - NOTE: This is a shortcut for PC-DOS */
 38912                                  	;/* If this is being modified for IFS drivers this may not be the */
 38913                                  	;/* the case - use caution */
 38914                                  
 38915 00005A17 C684[4BA1]01            		mov	byte [ext_table_start_head+si],1 ; start_head = 1
 38916                                  
 38917                                  	;/* Figure out the total number of sectors */
 38918                                  	;/* Total sectors in partition =                    */
 38919                                  	;/* [(end_cyl - start_cyl)*(max_sector)*(max_head)] */
 38920                                  	;/* - [start_head * max_sector]                     */
 38921                                  	;/* Note: This is assuming a track or cylinder aligned partition */
 38922                                  	;
 38923                                  	;/* First - get the total size in Cylinders assuming head 0 start*/
 38924                                  	;total_sectors = ((unsigned long)(ext_table[cur_disk][table_pointer].end_cyl -
 38925                                  	;          ext_table[cur_disk][table_pointer].start_cyl+1));
 38926                                  		
 38927                                  		;sub	ah,ah
 38928                                  		;mov	cx,ax
 38929                                  		;sub	dx,dx
 38930                                  		;push	dx
 38931                                  		;push	ax
 38932                                  		;mov	di,cx
 38933                                  		;mov	ax,[ext_table_end_cyl+si]
 38934                                  		;sub	ax,[ext_table_start_cyl+si]
 38935                                  		;inc	ax
 38936                                  		;mov	[mv_total_secs_lw],di
 38937                                  		;mov	[mv_total_secs_hw],dx
 38938                                  
 38939                                  	;/* Now multiply it by the number of sectors and heads per track */
 38940                                  	;total_sectors = total_sectors * max_sector[cur_disk] * max_head[cur_disk];
 38941                                  	;
 38942                                  	;/* This will give us the total of sectors if it is cyl aligned */
 38943                                  
 38944                                  
 38945                                  		;mul	word [max_head+bx]
 38946                                  		;push	dx
 38947                                  		;push	ax
 38948                                  		;call	mul32
 38949                                  
 38950                                  		; al = max_sector (sectors per track) <= 63
 38951                                  		; ah = max_head (heads) - 2 to 255
 38952                                  
 38953 00005A1C F6E4                    		mul	ah
 38954                                  			 ; ax <= 16065
 38955                                  
 38956 00005A1E 8B8C[52A1]              		mov	cx,[ext_table_end_cyl+si]
 38957 00005A22 2B8C[4DA1]              		sub	cx,[ext_table_start_cyl+si]
 38958 00005A26 41                      		inc	cx
 38959                                   
 38960 00005A27 F7E1                    		mul	cx
 38961                                  			 ; dx:ax = cylinders*heads*spt 
 38962                                  
 38963                                  	;/* Now, if it isn't aligned on head 0, we need to subtract off */
 38964                                  	;/* the skipped tracks in the first cylinder */
 38965                                  
 38966                                  	;/* Because the head is zero based, we can get the total number of */
 38967                                  	;/* skipped sectors by multipling the head number by sectors per track */
 38968                                  	;total_sectors = total_sectors - ((unsigned long)(ext_table[cur_disk][table_pointer].start_head *
 38969                                  	;                max_sector[cur_disk]));
 38970                                  
 38971 00005A29 31C9                    		xor	cx,cx
 38972                                  
 38973 00005A2B 29F8                    		sub	ax,di  ; -**-  ; - [start_head * max_sector]  
 38974                                  		;sbb	dx,0
 38975 00005A2D 19CA                    		sbb	dx,cx
 38976                                  
 38977                                  		;mov	cx,ax
 38978                                  		;mov	ax,di
 38979                                  		;mov	bx,dx
 38980                                  		;cwd
 38981                                  		;sub	cx,ax
 38982                                  		;sbb	bx,dx
 38983                                  		;mov	ax,cx
 38984                                  		;mov	dx,bx
 38985                                  		
 38986 00005A2F 8984[58A1]              		mov	[ext_table_num_sec_lw+si],ax
 38987 00005A33 8994[5AA1]              		mov	[ext_table_num_sec_hw+si],dx
 38988                                  
 38989                                  	;/* Get the relative sector */
 38990                                  	;/* Figure out the total number of sectors */
 38991                                  	;/* Total sectors before partition = max_sector */
 38992                                  	;/* NOTE: Again, this is a PC-DOS 3.30 shortcut - by definition */
 38993                                  	;/* a logical drive always starts on head 1, so there is always */
 38994                                  	;/* one tracks worth of sectors before it. Hence, max_sector */
 38995                                  		
 38996                                  		;mov	ax,[mv_total_secs_lw]
 38997                                  		;mov	dx,[mv_total_secs_hw]
 38998                                  		;mov	[ext_table_rel_sec_lw+si],ax
 38999                                  		;mov	[ext_table_rel_sec_hw+si],dx
 39000                                  
 39001                                  		;/* Save it! */
 39002                                  
 39003 00005A37 89BC[54A1]              		mov	[ext_table_rel_sec_lw+si],di ; -**- ; max_sector
 39004                                  		;mov	word [ext_table_rel_sec_hw+si],0
 39005 00005A3B 898C[56A1]              		mov	[ext_table_rel_sec_hw+si],cx ; 0
 39006                                  
 39007                                  mkvol_chk_fat16_limit:
 39008                                  		;/* Setup the system id byte */
 39009                                  		;/* Set to 06h - format will fix later on */
 39010                                  		;/* EGH; 7/03/90; We fix up the size ourselves here.
 39011                                  		; The calculation is simple. If total_sectors > 65536 then
 39012                                  		; type = 06 else if total_sectors > 32680 then type = 04
 39013                                  		; else type = 01 */
 39014                                  
 39015                                  		;cmp	word [ext_table_num_sec_hw+si],1
 39016 00005A3F 83FA01                  		cmp	dx,1
 39017                                  		;jb	short mkvol_chk_fat12_limit
 39018 00005A42 720A                    		jb	short mv_10
 39019 00005A44 7704                    		ja	short mkvol_fat16big
 39020                                  		;cmp	word [ext_table_num_sec_lw+si],0
 39021                                  		;je	short mkvol_chk_fat12_limit
 39022                                  		
 39023 00005A46 21C0                    		and	ax,ax
 39024                                  		;jz	short mkvol_chk_fat12_limit
 39025 00005A48 7409                    	 	jz	short mkvol_fat16 ; partition size: 65536 sectors
 39026                                  mkvol_fat16big:
 39027                                  		;mov	byte [mv_temp],6  ; DOSNEW
 39028 00005A4A B006                    		mov	al,6
 39029 00005A4C EB0B                    		jmp	short mv_7
 39030                                  mkvol_chk_fat12_limit:
 39031                                  		;mov	al,[mv_table_ptr]
 39032                                  		;cbw
 39033                                  		;mov	cx,ax
 39034                                  		;mov	al,24
 39035                                  		;;imul	byte [cur_disk]
 39036                                  		;mul	byte [cur_disk]
 39037                                  		;add	ax,cx
 39038                                  		;mov	cx,46
 39039                                  		;imul	cx
 39040                                  		;mov	bx,ax
 39041                                  
 39042                                  		;;cmp	word [ext_table_num_sec_hw+bx],0
 39043                                  		;cmp	word [ext_table_num_sec_hw+si],0
 39044                                  		;jne	short mkvol_fat16
 39045                                  
 39046                                  		;and	dx,dx
 39047                                  		;jnz	short mkvol_fat16
 39048                                  mv_10:
 39049                                  		;;cmp	word [ext_table_num_sec_lw+bx],32680 ; FAT12 upper limit
 39050                                  		;cmp	word [ext_table_num_sec_lw+si],32680
 39051                                  		;jbe	short mkvol_fat12
 39052 00005A4E 3DA87F                  		cmp	ax,32680
 39053 00005A51 7604                    		jbe	short mkvol_fat12
 39054                                  mkvol_fat16:
 39055                                  		;mov	byte [mv_temp],4 ; DOS16
 39056 00005A53 B004                    		mov	al,4
 39057 00005A55 EB02                    		jmp	short mv_7
 39058                                  mkvol_fat12:
 39059                                  		;mov	byte [mv_temp],1 ; DOS12
 39060 00005A57 B001                    		mov	al,1
 39061                                  mv_7:
 39062                                  		;mov	al,[mv_table_ptr]
 39063                                  		;cbw
 39064                                  		;mov	cx,ax
 39065                                  		;mov	al,24
 39066                                  		;;imul	byte [cur_disk]
 39067                                  		;mul	byte [cur_disk]
 39068                                  		;add	ax,cx
 39069                                  		;;mov	bx,46
 39070                                  		;mov	bl,46
 39071                                  		;;imul	bx
 39072                                  		;mul	bl
 39073                                  		;mov	si,ax
 39074                                  
 39075                                  		;/* We got the sys id, now put it in */
 39076                                  
 39077                                  		;mov	al,[mv_temp]
 39078 00005A59 8884[4FA1]              		mov	[ext_table_sys_id+si],al
 39079                                  
 39080                                  		;/* Set the changed flag */
 39081                                  
 39082 00005A5D C684[5DA1]01            		mov	byte [ext_table_changed+si],1
 39083                                  
 39084                                  		;/* Set the mbytes used */
 39085                                  
 39086                                  		;mov	al,[cur_disk]
 39087                                  		;push	ax
 39088                                  		; bh = 0
 39089                                  		;mov	bl,[cur_disk]
 39090                                  		;;xor	bh,bh
 39091                                  
 39092 00005A62 D0EB                    		shr	bl,1 ; ***** 
 39093                                  			; bl = [cur_disk]
 39094                                  			; bh = 0 
 39095                                  
 39096                                  		;push	word [mv_size]
 39097                                  		;mov	di,cx
 39098 00005A64 8B4604                  		mov	ax,[mv_size]
 39099 00005A67 E8F2BA                  		call	cylinders_to_mbytes
 39100                                  		;pop	bx
 39101                                  		;pop	bx
 39102 00005A6A 8984[5EA1]              		mov	[ext_table_mbytes_used+si],ax
 39103                                  
 39104                                  	;/* find the number of the extended partition to figure out percent */
 39105                                  
 39106                                  		;mov	al,5 ; EXTENDED
 39107                                  		;push	ax
 39108                                  		;call	find_partition_location
 39109                                  		;pop	bx
 39110                                  		;cbw
 39111                                  		;mov	[mv_ext_part_num],ax
 39112                                  
 39113                                  		; get partition entry number of extended dos partion
 39114                                   		; 	(on current disk/drive)
 39115 00005A6E B005                    		mov	al,5  ; EXTENDED partition ID
 39116 00005A70 E847C3                  		call	find_partition_type
 39117                                  		; cl = partition number (index), 0 to 3 or 4 (not found)
 39118                                  
 39119                                  		;mov	[mv_ext_part_num],cl ; ***
 39120                                  
 39121                                  		;/* Set the percent used */
 39122                                  
 39123 00005A73 A0[D4CB]                		mov	al,[cur_disk]
 39124                                  		;cbw
 39125                                  		;mov	cx,ax
 39126                                  		
 39127                                  		;shl	ax,1
 39128                                  		;shl	ax,1
 39129 00005A76 D0E0                    		shl	al,1
 39130 00005A78 D0E0                    		shl	al,1		
 39131                                  
 39132                                  		;add	ax,[mv_ext_part_num]
 39133 00005A7A 00C8                    		add	al,cl ; ***		
 39134                                  
 39135                                  		;mov	bx,46
 39136                                  		;mul	bx
 39137 00005A7C B12E                    		mov	cl,46
 39138 00005A7E F6E1                    		mul	cl
 39139 00005A80 89C3                    		mov	bx,ax
 39140                                  
 39141                                  		;mov	ax,[part_table_end_cyl+bx]
 39142                                  		;sub	ax,[part_table_start_cyl+bx]
 39143                                  		;inc	ax
 39144                                  		;push	ax
 39145                                  
 39146 00005A82 8B8F[1AC4]              		mov	cx,[part_table_end_cyl+bx]
 39147 00005A86 2B8F[15C4]              		sub	cx,[part_table_start_cyl+bx]
 39148 00005A8A 41                      		inc	cx  ; extended dos partition cylinders
 39149                                  
 39150                                  		;;mov	bx,24
 39151                                  		;mov	al,24
 39152                                  		;;mov	ax,cx
 39153                                  		;;imul	bx
 39154                                  		;mul	byte [cur_disk]
 39155                                  		;;add	ax,di
 39156                                  		;add	al,[mv_table_ptr]
 39157                                  		;;mov	cx,46
 39158                                  		;;imul	cx
 39159                                  		;mov	cl,46
 39160                                  		;mul	cl
 39161                                  		;mov	si,ax
 39162                                  
 39163                                  		;mov	ax,[ext_table_end_cyl+si]
 39164                                  		;sub	ax,[ext_table_start_cyl+si]
 39165                                  		;inc	ax
 39166                                  		;push	ax
 39167                                  
 39168 00005A8B 8B9C[52A1]              		mov	bx,[ext_table_end_cyl+si]
 39169 00005A8F 2B9C[4DA1]              		sub	bx,[ext_table_start_cyl+si]
 39170 00005A93 43                      		inc	bx  ; dos volume cylinders
 39171 00005A94 E818BB                  		call	cylinders_to_percent
 39172                                  		;pop	bx
 39173                                  		;pop	bx
 39174 00005A97 8984[60A1]              		mov	[ext_table_percent_used+si],ax
 39175                                  
 39176                                  	;/* set the system to unknown and volume label to blanks */
 39177                                  		
 39178                                  		;mov	ax,_NOFORMAT ; "UNKNOWN	"
 39179                                  		;push	ax
 39180                                  		
 39181                                  		;mov	al,24
 39182                                  		;;imul	byte [cur_disk]
 39183                                  		;mul	byte [cur_disk]
 39184                                  		;add	ax,di
 39185                                  		;;mov	cx,46
 39186                                  		;mov	cl,46
 39187                                  		;;imul	cx
 39188                                  		;mul	cl
 39189                                  
 39190                                  		;add	ax,ext_table_system
 39191                                  		;push	ax
 39192                                  		
 39193 00005A9B 89F3                    		mov	bx,si ; *
 39194                                  
 39195 00005A9D BE[4570]                		mov	si,NO_FORMAT ; 'UNKNOWN ' ; source 
 39196 00005AA0 89DF                    		mov	di,bx ; *
 39197 00005AA2 81C7[6EA1]              		add	di,ext_table_system ; destination 
 39198                                  
 39199 00005AA6 E87AC2                  		call	strcpy
 39200                                  		;pop	bx
 39201                                  		;pop	bx
 39202                                  
 39203                                  		;mov	ax,NOVOLUME
 39204                                  		;push	ax
 39205                                  
 39206                                  		;mov	al,24
 39207                                  		;;imul	byte [cur_disk]
 39208                                  		;mul	byte [cur_disk]
 39209                                  		;add	ax,di
 39210                                  		;mov	cx,46
 39211                                  		;imul	cx
 39212                                  
 39213                                  		;add	ax,ext_table_vol_label
 39214                                  		;push	ax
 39215                                  		;call	strcpy
 39216                                  		;pop	bx
 39217                                  		;pop	bx
 39218                                  		
 39219                                  		;mov	di,bx ; *
 39220                                  		;mov	byte [di+ext_table_vol_label],0 ; NOVOLUME
 39221 00005AA9 C687[62A1]00            		mov	byte [bx+ext_table_vol_label],0
 39222                                  
 39223 00005AAE EB03                    		jmp	short mv_9
 39224                                  mv_8:
 39225                                  		;/* This should not have happened */
 39226 00005AB0 E85ED8                  		call	internal_program_error
 39227                                  mv_9:
 39228                                  		;mov	al,[mv_table_ptr]
 39229                                  		
 39230                                  		;pop	si
 39231                                  		;pop	di
 39232                                  			   ; sp = bp-2	
 39233 00005AB3 58                      		pop	ax ; mov al,[mv_table_ptr] ; mov al,[bp-2]
 39234                                  			   ; mov sp,bp	
 39235                                  		
 39236                                  		;mov	sp,bp
 39237 00005AB4 5D                      		pop	bp
 39238                                  		;retn
 39239 00005AB5 C20400                  		retn	4
 39240                                  
 39241                                  ; ----------------------------------------------------------------------------
 39242                                  ; partinfo.c (FDISK, MSDOS 6.0, 1991)	
 39243                                  ; ----------------------------------------------------------------------------
 39244                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 21/01/2019)
 39245                                  
 39246                                  ;char find_free_ext()
 39247                                  ;
 39248                                  ;BEGIN
 39249                                  ;
 39250                                  ; char   i;
 39251                                  ;
 39252                                  ;    /* Look at all 23 extended entries for empty partition */
 39253                                  ;    for (i = c(0); i < c(23);i++) 				/* AC000 */
 39254                                  ;       BEGIN
 39255                                  ;        /* if we find an empty one, return which one */
 39256                                  ;        if (ext_table[cur_disk][i].sys_id == uc(0))		/* AC000 */
 39257                                  ;           BEGIN
 39258                                  ;            return(i);
 39259                                  ;            break;
 39260                                  ;           END
 39261                                  ;       END
 39262                                  ;    return(c(NOT_FOUND));					/* AC000 */
 39263                                  ;END
 39264                                  
 39265                                  find_free_ext:
 39266                                  		; 21/01/2019
 39267                                  
 39268                                  	;%define ffe_i bp-2
 39269                                  
 39270                                  		;push	bp
 39271                                  		;mov	bp,sp
 39272                                  		;sub	sp,2
 39273                                  
 39274                                  		;mov	byte [ffe_i],0
 39275                                  		;xor	cx,cx
 39276 00005AB8 30C9                    		xor	cl,cl
 39277 00005ABA EB07                    		jmp	short ffe_2
 39278                                  ffe_1:
 39279                                  		;inc	byte [ffe_i]
 39280 00005ABC FEC1                    		inc	cl
 39281                                  ;ffe_2:
 39282                                  		;cmp	byte [ffe_i],23
 39283                                  		;jge	short ffe_3
 39284 00005ABE 80F917                  		cmp	cl,23
 39285 00005AC1 7318                    		jnb	short ffe_3
 39286                                  ffe_2:
 39287                                  		;mov	al,[ffe_i]
 39288                                  		;cbw
 39289                                  		;mov	cx,ax
 39290 00005AC3 B018                    		mov	al,24
 39291                                  		;imul	byte [cur_disk]
 39292 00005AC5 F626[D4CB]              		mul	byte [cur_disk]
 39293                                  		;add	ax,cx
 39294 00005AC9 00C8                    		add	al,cl
 39295                                  		;mov	cx,46
 39296                                  		;imul	cx
 39297 00005ACB B32E                    		mov	bl,46
 39298 00005ACD F6E3                    		mul	bl
 39299 00005ACF 89C3                    		mov	bx,ax
 39300 00005AD1 80BF[4FA1]00            		cmp	byte [ext_table_sys_id+bx],0
 39301 00005AD6 75E4                    		jne	short ffe_1
 39302                                  		;mov	al,[ffe_i]
 39303 00005AD8 88C8                    		mov	al,cl
 39304                                  		;jmp	short ffe_4
 39305 00005ADA C3                      		retn
 39306                                  ffe_3:
 39307 00005ADB B0FF                    		mov	al,0FFh	; NOT_FOUND
 39308                                  ffe_4:
 39309                                  		;mov	sp,bp
 39310                                  		;pop	bp
 39311                                  		
 39312 00005ADD C3                      		retn
 39313                                  
 39314                                  ; ----------------------------------------------------------------------------
 39315                                  ; int13.c (FDISK, MSDOS 6.0, 1991)	
 39316                                  ; ----------------------------------------------------------------------------
 39317                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 26/01/2019)
 39318                                  
 39319                                  ; 28/01/2019
 39320                                  
 39321                                  ;/*  */
 39322                                  ;unsigned verify_tracks(pointer,type)
 39323                                  ;
 39324                                  ;char pointer;
 39325                                  ;char type;
 39326                                  ;
 39327                                  ;BEGIN
 39328                                  ;  unsigned	i;
 39329                                  ;
 39330                                  ;  /* SR; 9/29/89; Temp store */
 39331                                  ;  unsigned	j;
 39332                                  ;  unsigned	sectors_per_fat;
 39333                                  ;  unsigned	cur_cyl;
 39334                                  ;  unsigned	verify_cyl;
 39335                                  ;  unsigned	num_tracks;
 39336                                  ;  unsigned	retry_flg;
 39337                                  ;  unsigned	long   total_sectors;
 39338                                  ;  char	golden_tracks;
 39339                                  ;  char	retry;
 39340                                  ;  unsigned char cur_head;					     /* AC004 */
 39341                                  ;
 39342                                  ;  char far *buffer_pointer = boot_record;
 39343                                  ;
 39344                                  ;  for (i=u(0); i< u(BYTES_PER_SECTOR);i++)                        /* AC000 */
 39345                                  ;     BEGIN
 39346                                  ;      /* Put something other then 0's so that unformatted FAT looks full */
 39347                                  ;
 39348                                  ;      boot_record[i] = uc(0xF6);                                /* AC000 */
 39349                                  ;     END
 39350                                  ;
 39351                                  ;  /* Get the start cylinder for the sweep */
 39352                                  ;  cur_cyl = free_space[pointer].start;
 39353                                  ;
 39354                                  ;  /* Also keep track of what it is */
 39355                                  ;  verify_cyl = cur_cyl;
 39356                                  ;
 39357                                  ;  /* Initialize the start head -assume 0*/
 39358                                  ;  cur_head = uc(0);                                             /* AC004 */
 39359                                  ;
 39360                                  ;  /* SR; 9/29/89; cur_head should be 1 for extended partitions too */
 39361                                  ;  if (((type == c(PRIMARY)) && (cur_cyl == u(0))) || type == c(EXTENDED))  /* AC000 */
 39362                                  ;    BEGIN
 39363                                  ;
 39364                                  ;     /* It's head 1 - NOTE: This is convience for PC-DOS because it is */
 39365                                  ;     /* always this way - This may have to be beefed up for IFS  */
 39366                                  ;     cur_head = uc(1);                                          /* AC004 */
 39367                                  ;    END
 39368                                  ;
 39369                                  ;  /* Now go figure out the number of golden sectors needed. Use the */
 39370                                  ;  /* allocation equation in the fixed disk section of DOS Tech Ref. */
 39371                                  ;  /*                                                                */
 39372                                  ;  /*  TS = Free cyl's * sector/track * track/cyl                    */
 39373                                  ;  /*  RS = 1                                                        */
 39374                                  ;  /*  D  = 512                                                      */
 39375                                  ;  /*  BPD = 32                                                      */
 39376                                  ;  /*  BPS = BYTES_PER_SECTOR                                        */
 39377                                  ;  /*  CF = 2                                                        */
 39378                                  ;  /*  SPF = Solve                                                   */
 39379                                  ;  /*  SPC = 4 or 8                                                  */
 39380                                  ;  /*  BPC = 1.5 or 2                                                */
 39381                                  ;  /*                                                                */
 39382                                  ;  /*  Golden Sectors = RS + 2(SPF) + BPD(D)  + (DOSFILES)           */
 39383                                  ;  /*                                 ------   if bootable           */
 39384                                  ;  /*                                  BPS                           */
 39385                                  ;
 39386                                  ;  total_sectors = ((unsigned long)free_space[pointer].space) * max_head[cur_disk] * max_sector[cur_disk];
 39387                                  ;
 39388                                  ;  /* Chop off one track if it starts on head 1 */
 39389                                  ;  if (cur_head == uc(1))                                          /* AC004 */
 39390                                  ;     BEGIN
 39391                                  ;      total_sectors = total_sectors - max_sector[cur_disk];
 39392                                  ;     END
 39393                                  ;
 39394                                  ;  /* See if 12 or 16 bit fat */
 39395                                  ;  if (total_sectors > (unsigned long)FAT16_SIZE)
 39396                                  ;     BEGIN
 39397                                  ;      /* SR; 9/30/89; We have to round up the sectors_per_fat.
 39398                                  ;         Calculate the denominator first */
 39399                                  ;
 39400                                  ;      j = 2 + (BYTES_PER_SECTOR * 2);
 39401                                  ;      /* 16 bit */
 39402                                  ;      /* SR; 9/30/89; To round up add j-1 and divide by j */
 39403                                  ;      sectors_per_fat = u(((total_sectors - 33) + j - 1) / j);      /*C00*/
 39404                                  ;     END
 39405                                  ;  else
 39406                                  ;     BEGIN
 39407                                  ;      /* SR; 9/30/89; We have to round up the sectors_per_fat.
 39408                                  ;      Calculate the denominator first. We have to round up the
 39409                                  ;      denominator too. The multiplying factor 16 = SPC * 2 */
 39410                                  ;
 39411                                  ;      j = 2 + (( BYTES_PER_SECTOR * 16 ) + 2 ) / 3;
 39412                                  ;      /* 12 bit */
 39413                                  ;      sectors_per_fat = u(((total_sectors - 33) + j - 1) / j);      /*C00*/
 39414                                  ;     END
 39415                                  ;
 39416                                  ;  /* Round up one just to handle any rounding errors */
 39417                                  ;  /* SR; 9/30/89; We have taken care of the rounding */
 39418                                  ;  /***SR; 9/30/89; sectors_per_fat++;   ***/
 39419                                  ;
 39420                                  ;  /* Now see how many tracks */
 39421                                  ;  num_tracks = (sectors_per_fat*2) + 33;
 39422                                  ;
 39423                                  ;  /* If primary and drive 0, add in enough for system files */
 39424                                  ;  if ((type == c(PRIMARY)) && (cur_disk == c(0)))                 /* AC000 */
 39425                                  ;     BEGIN
 39426                                  ;      num_tracks = num_tracks + SYSTEM_FILE_SECTORS;
 39427                                  ;     END
 39428                                  ;
 39429                                  ;   /* Handle upward rounding */         /* The problem with the IBM code is */
 39430                                  ;   if (num_tracks%max_sector[cur_disk] != u(0)) /* that if num_tracks is < max_sector[cur_disk] */
 39431                                  ;       BEGIN                           /* the num_tracks becomes 0 due to the integer  */
 39432                                  ;       num_tracks = num_tracks + max_sector[cur_disk]; /* division and num_tracks will not be inc'd .  */
 39433                                  ;       END                             /* This section of code overcomes that. */
 39434                                  ;
 39435                                  ;   /* Now convert to tracks */
 39436                                  ;   num_tracks = num_tracks/max_sector[cur_disk];
 39437                                  ;
 39438                                  ;   /* SR; 9/30/89; The number of tracks above does not take into
 39439                                  ;      account the wasted track 0 which contains the partition info.
 39440                                  ;      If cur_head = 0, then the above calculation would cause the
 39441                                  ;      last track in the partition to be not verified */
 39442                                  ;
 39443                                  ;   if ( cur_head == 0 )
 39444                                  ;           num_tracks++;
 39445                                  ;
 39446                                  ;   golden_tracks = FALSE;
 39447                                  ;
 39448                                  ;   while (!golden_tracks)
 39449                                  ;       {                               /* this allows resetting the starting cyl of the golden tracks */
 39450                                  ;       for (i = u(0);i < num_tracks; i++)
 39451                                  ;           {               /* this for loop is to write the number of golden tracks  AC000 */
 39452                                  ;           retry = c(0);                         /* AC000 */
 39453                                  ;           do
 39454                                  ;               {                                       /* this do loop is for retries */
 39455                                  ;               retry++;
 39456                                  ;               regs.h.ah = uc(VERIFY_DISK);          /* BC001 */ /* Specify the operation */
 39457                                  ;               regs.h.al = (unsigned char)max_sector[cur_disk]; /* Specify number of sectors */
 39458                                  ;               regs.h.cl = 1;  /* Specify the start sectors */
 39459                                  ;				 /* AC000 BC001 Scramble CX so that sectors and cyl's are in INT 13 format*/
 39460                                  ;               if (cur_cyl > u(255))                                 /* AC000 */
 39461                                  ;                   regs.h.cl = regs.h.cl | ((unsigned char)((cur_cyl/256) << 6));
 39462                                  ;               regs.h.ch = ((unsigned char)cur_cyl) & 0xFF;
 39463                                  ;               regs.h.dl = ((unsigned char)cur_disk) + 0x80; /* Specify the disk */
 39464                                  ;               regs.h.dh = cur_head;                       /* Specify the head */ /* AC004 */
 39465                                  ;               int86((int)DISK, &regs, &regs);   /* BC001 */ /* verify the track */
 39466                                  ;                   retry_flg = regs.x.cflag & 1; /* BN001 */
 39467                                  ;               }
 39468                                  ;           while ((retry_flg) && (retry != c(3))); /* BN001 */ /* retry loop */
 39469                                  ;
 39470                                  ;           /************************************************************/
 39471                                  ;           /* Check to see if cylinder was verified w/o errors.        */
 39472                                  ;           /************************************************************/
 39473                                  ;
 39474                                  ;           if (!retry_flg)
 39475                                  ;               {                                               /* BN001 */
 39476                                  ;           /*********************************************************/
 39477                                  ;           /* Cylinder verified correctly. So write boot sector     */
 39478                                  ;           /* and bump cylinder count, then go verify that cylinder.*/
 39479                                  ;           /* Do not pass the end of the partition free space.      */
 39480                                  ;           /*********************************************************/
 39481                                  ;               retry = 0;
 39482                                  ;               do
 39483                                  ;                   {
 39484                                  ;                   retry++;
 39485                                  ;                   regs.h.ah = uc(WRITE_DISK);          /* BN001 */ /* Specify the operation */
 39486                                  ;                   regs.h.al = 1;                       /* BN001 */ /* Write one sector only */
 39487                                  ;                   regs.h.cl = 1;                       /* BN001 */ /* Specify the start sectors */ /* AC000 BC001 Need to scramble CX for INT 13 format */
 39488                                  ;                   if (cur_cyl > u(255))                  /* BN001 */
 39489                                  ;                   regs.h.cl = regs.h.cl | ((unsigned char)((cur_cyl/256) << 6)); /* BN001 */
 39490                                  ;                   regs.h.ch = ((unsigned char)cur_cyl) & 0xFF;  /* BN001 */
 39491                                  ;                   regs.h.dl = ((unsigned char)cur_disk) + 0x80; /* BN001 */ /* Specify the disk */
 39492                                  ;                   regs.h.dh = cur_head;                       /* BN001 */ /* Specify the head */   /* AC004 */
 39493                                  ;                   regs.x.bx = FP_OFF(buffer_pointer);         /* BN001 */ /* Point at the place to write */
 39494                                  ;                   segregs.es = FP_SEG(buffer_pointer);        /* BN001 */
 39495                                  ;                   DiskIo(&regs,&regs,&segregs);               /* BN001 */ /* write the track */
 39496                                  ;                   retry_flg = regs.x.cflag & 1;               /* BN001 */
 39497                                  ;                   }
 39498                                  ;               while ((retry_flg) && (retry != c(3)));         /* BN001 */ /* retry loop */
 39499                                  ;               }
 39500                                  ;
 39501                                  ;           /* See if we had a good read */
 39502                                  ;           if (!retry_flg)                        /* AC000 */
 39503                                  ;               BEGIN
 39504                                  ;               golden_tracks = TRUE;
 39505                                  ;               /* Get the next head */
 39506                                  ;               cur_head++;
 39507                                  ;
 39508                                  ;               /* SR; 9/29/89; Head no. is pre-incremented and cannot
 39509                                  ;                  subtract 1 from max_head[cur_disk] */
 39510                                  ;               if (cur_head == (uc(max_head[cur_disk] )))       /* AC004 */
 39511                                  ;                   BEGIN
 39512                                  ;                   /* Up to the next cylinder */
 39513                                  ;                   cur_head = uc(0);                          /* AC004 */
 39514                                  ;                   cur_cyl++;
 39515                                  ;
 39516                                  ;                   /* Check to see if we've reached the end of the free_space*/
 39517                                  ;                   if (cur_cyl > free_space[pointer].end)
 39518                                  ;                       BEGIN
 39519                                  ;                       /* It is, so return with the cyl offset equal to the freespace */
 39520                                  ;                       return(free_space[pointer].space);
 39521                                  ;                       END
 39522                                  ;                   END
 39523                                  ;               END
 39524                                  ;           else
 39525                                  ;               BEGIN
 39526                                  ;               /* Get out of the for loop, with a false flag */
 39527                                  ;               golden_tracks = FALSE;
 39528                                  ;
 39529                                  ;               /* Bump up to the next cylinder boundary */
 39530                                  ;               cur_cyl++;
 39531                                  ;
 39532                                  ;               /* SR; 9/29/89; To get out of the loop we have to
 39533                                  ;                  check if there have been enough golden tracks or
 39534                                  ;                  not. The setting of the flag as above will not
 39535                                  ;                  get us out of the loop. We return with the cyl
 39536                                  ;                  offset equal to the freespace to indicate that
 39537                                  ;                  this freespace cannot be used */
 39538                                  ;
 39539                                  ;               if ( cur_cyl > free_space[pointer].end )
 39540                                  ;                   return( free_space[pointer].space );
 39541                                  ;
 39542                                  ;               cur_head = uc(0);                             /* AC004 */
 39543                                  ;
 39544                                  ;               /* Save the new verify start point */
 39545                                  ;               verify_cyl = cur_cyl;
 39546                                  ;
 39547                                  ;               break;
 39548                                  ;               END
 39549                                  ;           END  /* for num_tracks */
 39550                                  ;       } /*while !golden_tracks */
 39551                                  ;
 39552                                  ;  /* All done, return the offset from original cyl to the new one */
 39553                                  ;  return(verify_cyl - free_space[pointer].start);
 39554                                  ;END
 39555                                  
 39556                                  verify_tracks:
 39557                                  		; 26/01/2019
 39558                                  
 39559                                  	%define verify_cyl 	bp-14	;bp-22	;bp-26
 39560                                  	%define	cur_head   	bp-12	;bp-20	;bp-24
 39561                                  	;%define buffer_pointer_off 	;bp-18	;bp-20
 39562                                  	;%define buffer_pointer_seg 	;bp-16	;bp-18
 39563                                  	%define vt_i		bp-10	;bp-14	;bp-16
 39564                                  	%define num_tracks	bp-8	;bp-12	;bp-14
 39565                                  	;%define vt_total_secs_lw 	;bp-10	;bp-12
 39566                                  	;%define vt_total_secs_hw 	;bp-8	;bp-10
 39567                                  	%define vt_retry	bp-6		;bp-8
 39568                                  	%define cur_cyl		bp-4
 39569                                  	%define golden_tracks	bp-2
 39570                                  
 39571                                  	%define vt_pointer	bp+4
 39572                                  	%define vt_type		bp+6
 39573                                  
 39574 00005ADE 55                      		push	bp
 39575 00005ADF 89E5                    		mov	bp,sp
 39576                                  		;;sub	sp,28
 39577                                  		;sub	sp,22
 39578 00005AE1 83EC0E                  		sub	sp,14
 39579                                  
 39580                                  		;push	di
 39581                                  		;push	si
 39582                                  
 39583                                  		;char far *buffer_pointer = boot_record;
 39584                                  		
 39585                                  		;mov	word [buffer_pointer_off],boot_record
 39586                                  		;mov	[buffer_pointer_seg],ds
 39587                                  
 39588                                  		;for (i=u(0); i< u(BYTES_PER_SECTOR);i++)    
 39589                                  
 39590                                  		;mov	word [vt_i],0
 39591                                  
 39592                                  	;/* Put something other then 0's so that unformatted FAT looks full */
 39593                                  vt_01:
 39594                                  		;mov	bx,[vt_i]
 39595                                  		;mov	byte [boot_record+bx],0F6h  ; boot_record[i] = uc(0xF6);  
 39596                                  		;inc	word [vt_i]
 39597                                  		;cmp	[vt_i],512
 39598                                  		;jb	short vt_01
 39599                                  
 39600                                  		;push	cs
 39601                                  		;pop	es
 39602                                  
 39603 00005AE4 B90001                  		mov	cx,256
 39604 00005AE7 BF[D2C9]                		mov	di,boot_record
 39605 00005AEA B8F6F6                  		mov	ax,0F6F6h
 39606 00005AED F3AB                    		rep	stosw
 39607                                  		
 39608                                  		;mov	al,22
 39609 00005AEF B00A                    		mov	al,10
 39610                                  		;imul	byte [vt_pointer]
 39611 00005AF1 F66604                  		mul	byte [vt_pointer]
 39612                                  		;mov	bx,ax
 39613 00005AF4 89C6                    		mov	si,ax ; ***
 39614                                  
 39615                                  		;/* Get the start cylinder for the sweep */
 39616                                  		;cur_cyl = free_space[pointer].start;
 39617                                  		;
 39618                                  		;/* Also keep track of what it is */
 39619                                  		;verify_cyl = cur_cyl;
 39620                                  
 39621                                  		;mov	ax,[free_space.start+bx]
 39622 00005AF6 8B84[E4CB]              		mov	ax,[free_space.start+si] ; ***
 39623 00005AFA 8946FC                  		mov	[cur_cyl],ax
 39624 00005AFD 8946F2                  		mov	[verify_cyl],ax
 39625                                  
 39626                                  		;/* Initialize the start head - assume 0*/
 39627                                  
 39628 00005B00 C646F400                		mov	byte [cur_head],0
 39629                                  
 39630                                  		;cur_head should be 1 for extended partitions too */
 39631                                  	;  if (((type == c(PRIMARY)) && (cur_cyl == u(0))) || type == c(EXTENDED))
 39632                                  	
 39633 00005B04 807E0600                		cmp	byte [vt_type],0 ; PRIMARY
 39634 00005B08 7504                    		jne	short vt_02
 39635 00005B0A 09C0                    		or	ax,ax
 39636 00005B0C 7406                    		jz	short vt_03
 39637                                  vt_02:
 39638 00005B0E 807E0605                		cmp	byte [vt_type],5 ; EXTENDED
 39639 00005B12 7503                    		jne	short vt_04
 39640                                  vt_03:
 39641                                  	;/* It's head 1 - NOTE: This is convience for PC-DOS because it is */
 39642                                  	;/* always this way - This may have to be beefed up for IFS */
 39643                                  
 39644                                  		;mov	byte [cur_head],1
 39645 00005B14 FE46F4                  		inc	byte [cur_head] ; [cur_head] = 1
 39646                                  
 39647                                  ;  /* Now go figure out the number of golden sectors needed. Use the */
 39648                                  ;  /* allocation equation in the fixed disk section of DOS Tech Ref. */
 39649                                  ;  /*                                                                */
 39650                                  ;  /*  TS = Free cyl's * sector/track * track/cyl                    */
 39651                                  ;  /*  RS = 1                                                        */
 39652                                  ;  /*  D  = 512                                                      */
 39653                                  ;  /*  BPD = 32                                                      */
 39654                                  ;  /*  BPS = BYTES_PER_SECTOR                                        */
 39655                                  ;  /*  CF = 2                                                        */
 39656                                  ;  /*  SPF = Solve                                                   */
 39657                                  ;  /*  SPC = 4 or 8                                                  */
 39658                                  ;  /*  BPC = 1.5 or 2                                                */
 39659                                  ;  /*                                                                */
 39660                                  ;  /*  Golden Sectors = RS + 2(SPF) + BPD(D)  + (DOSFILES)           */
 39661                                  ;  /*                                 ------   if bootable           */
 39662                                  ;  /*                                  BPS                           */
 39663                                  
 39664                                  vt_04:
 39665                                  
 39666                                  ;total_sectors = ((unsigned long)free_space[pointer].space) * max_head[cur_disk] 
 39667                                  ;		* max_sector[cur_disk];
 39668                                  
 39669                                  		;mov	al,[cur_disk]
 39670                                  		;cbw
 39671                                  		;mov	bx,ax
 39672                                  		;mov	al,[max_sector+bx]
 39673                                  		;sub	ah,ah
 39674                                  		;sub	dx,dx
 39675                                  		;push	dx
 39676                                  		;push	ax
 39677                                  		;mov	cx,ax
 39678                                  
 39679 00005B17 A0[D4CB]                		mov	al,[cur_disk]
 39680 00005B1A 98                      		cbw
 39681 00005B1B 89C3                    		mov	bx,ax
 39682 00005B1D 8A87[A0A0]              		mov	al,[max_sector+bx] ; <= 63
 39683 00005B21 89C1                    		mov	cx,ax
 39684                                  
 39685                                  		;;mov	al,22
 39686                                  		;mov	al,10
 39687                                  		;;imul	byte [vt_pointer]
 39688                                  		;mul	byte [vt_pointer]
 39689                                  		;mov	si,ax ; ***
 39690                                  
 39691                                  		;shl	bx,1
 39692 00005B23 D0E3                    		shl	bl,1
 39693 00005B25 8B87[A8A0]              		mov	ax,[max_head+bx] ; <= 255
 39694                                  		;mov	bx,dx
 39695                                  		
 39696                                  		;mul	word [free_space.space+si]
 39697                                  		;push	dx
 39698                                  		;push	ax
 39699                                  		;mov	si,cx
 39700                                  		;mov	di,bx
 39701                                  		;call	mul32
 39702                                  
 39703 00005B29 F7E1                    		mul	cx ; [max_sector] 
 39704                                  			;ax = [max_sector] * [max_head] <= 16065
 39705                                  			;dx = 0
 39706                                  
 39707 00005B2B F7A4[E2CB]              		mul	word [free_space.space+si]
 39708                                  
 39709                                  		;mov	[vt_total_secs_lw],ax
 39710                                  		;mov	[vt_total_secs_hw],dx
 39711                                  
 39712                                  		;/* Chop off one track if it starts on head 1 */
 39713                                  
 39714                                  	;if (cur_head == uc(1))
 39715                                  	;  BEGIN
 39716                                  	;    total_sectors = total_sectors - max_sector[cur_disk];
 39717                                  	;  END
 39718 00005B2F 807EF401                		cmp	byte [cur_head],1
 39719 00005B33 7506                    		jne	short vt_05
 39720                                  
 39721                                  		;sub	ax,si
 39722                                  		;sbb	dx,di
 39723                                  
 39724 00005B35 31FF                    		xor	di,di ; 0
 39725                                  
 39726 00005B37 29C8                    		sub	ax,cx	; cx = max_sector[cur_disk]
 39727                                  		;sbb	dx,0
 39728 00005B39 19FA                    		sbb	dx,di ; sbb dx,0
 39729                                  
 39730                                  		;;mov	[vt_total_secs_lw],ax
 39731                                  		;;mov	[vt_total_secs_hw],dx
 39732                                  vt_05:
 39733                                  		;mov	[vt_total_secs_lw],ax
 39734                                  		;mov	[vt_total_secs_hw],dx
 39735                                  
 39736                                  		;cmp	dx,di
 39737                                  		;jne	short vt_06
 39738                                  
 39739                                  		;/* See if 12 or 16 bit fat */
 39740                                  		; if (total_sectors > (unsigned long)FAT16_SIZE)
 39741                                  
 39742 00005B3B 21D2                    		and	dx,dx
 39743 00005B3D 7505                    		jnz	short vt_06
 39744                                  
 39745 00005B3F 3DA87F                  		cmp	ax,32680  ; FAT16_SIZE (FAT 12 size limit)
 39746 00005B42 760A                    		jbe	short vt_07 ; FAT 12
 39747                                  vt_06:
 39748                                  		;/* We have to round up the sectors_per_fat.
 39749                                  		;   Calculate the denominator first */
 39750                                  
 39751                                  		;j = 2 + (BYTES_PER_SECTOR * 2);
 39752                                  
 39753                                  		;mov	ax,1026 ; j
 39754                                  		;cwd
 39755                                  
 39756 00005B44 B90204                  		mov	cx,1026 ; j  ; divisor
 39757                                  
 39758                                  		;/* 16 bit */
 39759                                  		;To round up add j-1 and divide by j */
 39760                                  		;sectors_per_fat = u(((total_sectors - 33) + j - 1) / j); 
 39761                                  
 39762                                  		;push	dx
 39763                                  		;push	ax
 39764                                  		;mov	ax,[vt_total_secs_lw]
 39765                                  		;mov	dx,[vt_total_secs_hw]
 39766                                  
 39767 00005B47 05E003                  		add	ax,992 ; 1026-33-1
 39768                                  		;adc	dx,0
 39769 00005B4A 11FA                    		adc	dx,di ; adc dx,0
 39770 00005B4C EB06                    		jmp	short vt_08
 39771                                  vt_07:
 39772                                  		;We have to round up the sectors_per_fat.
 39773                                  		;Calculate the denominator first. We have to round up the
 39774                                  		;denominator too. The multiplying factor 16 = SPC * 2 */
 39775                                  
 39776                                  		;j = 2 + (( BYTES_PER_SECTOR * 16 ) + 2 ) / 3;
 39777                                  		
 39778                                  		;mov	ax,2733	; j (= 2731+2)
 39779                                  		;cwd
 39780                                  
 39781 00005B4E B9AD0A                  		mov	cx,2733	; j
 39782                                  
 39783                                  		;/* 12 bit */
 39784                                  		;sectors_per_fat = u(((total_sectors - 33) + j - 1) / j);
 39785                                  
 39786                                  		;push	dx
 39787                                  		;push	ax
 39788                                  		;mov	ax,[vt_total_secs_lw]
 39789                                  		;mov	dx,[vt_total_secs_hw]
 39790                                  		
 39791 00005B51 058B0A                  		add	ax,2699 ; 2733-33-1  
 39792                                  			 ;ax <= 32680+2699
 39793                                  			 ;dx = 0
 39794                                  ;vt_08:
 39795                                  		;adc	dx,di
 39796                                  vt_08:
 39797                                  		;push	dx
 39798                                  		;push	ax
 39799                                  			; dx:ax = dividend (32 bit)
 39800                                  			; cx = divisor (16 bit)
 39801                                  
 39802 00005B54 E8B5BA                  		call	div32
 39803                                  			; ax = sectors per fat
 39804                                  
 39805                                  		;/* Round up one just to handle any rounding errors */
 39806                                  		;/* We have taken care of the rounding */
 39807                                  
 39808                                  		;/* Now see how many tracks */
 39809                                  		;num_tracks = (sectors_per_fat*2) + 33;
 39810                                  
 39811 00005B57 D1E0                    		shl	ax,1
 39812 00005B59 83C021                  		add	ax,33
 39813 00005B5C 8946F8                  		mov	[num_tracks],ax
 39814                                  
 39815                                  	;/* If primary and drive 0, add in enough for system files */
 39816                                  
 39817                                  		;if ((type == c(PRIMARY)) && (cur_disk == c(0)))
 39818                                  		;   BEGIN
 39819                                  		;     num_tracks = num_tracks + SYSTEM_FILE_SECTORS;
 39820                                  		;   END
 39821                                  
 39822 00005B5F 807E0600                		cmp	byte [vt_type],0 ; PRIMARY
 39823 00005B63 750D                    		jne	short vt_09
 39824 00005B65 803E[D4CB]00            		cmp	byte [cur_disk],0
 39825 00005B6A 7506                    		jne	short vt_09
 39826 00005B6C 05FA00                  		add	ax,250 ; SYSTEM_FILE_SECTORS
 39827 00005B6F 8946F8                  		mov	[num_tracks],ax
 39828                                  vt_09:
 39829                                  		;/* Handle upward rounding */         
 39830                                  	
 39831                                  		;/* The problem with the IBM code is */
 39832                                  		;/* that if num_tracks is < max_sector[cur_disk] */
 39833                                  		;/* the num_tracks becomes 0 due to the integer */
 39834                                  		;/* division and num_tracks will not be inc'd. */
 39835                                  		;/* This section of code overcomes that. */
 39836                                  
 39837                                  		;if (num_tracks%max_sector[cur_disk] != u(0)) 
 39838                                  		;   BEGIN                          
 39839                                  		;     num_tracks = num_tracks + max_sector[cur_disk];
 39840                                  		;   END
 39841                                  
 39842                                  		;mov	al,[cur_disk]
 39843                                  		;cbw
 39844                                  		;mov	bx,ax
 39845 00005B72 8A1E[D4CB]              		mov	bl,[cur_disk]
 39846 00005B76 28FF                    		sub	bh,bh		
 39847 00005B78 8A8F[A0A0]              		mov	cl,[max_sector+bx]
 39848 00005B7C 28ED                    		sub	ch,ch ; 0
 39849 00005B7E 8B46F8                  		mov	ax,[num_tracks]
 39850 00005B81 29D2                    		sub	dx,dx ; 0
 39851 00005B83 F7F1                    		div	cx
 39852 00005B85 09D2                    		or	dx,dx
 39853 00005B87 7405                    		jz	short vt_10
 39854 00005B89 014EF8                  		add	[num_tracks],cx
 39855                                  
 39856 00005B8C 31D2                    		xor	dx,dx ; **
 39857                                  vt_10:
 39858                                  		;/* Now convert to tracks */
 39859                                  		;   num_tracks = num_tracks/max_sector[cur_disk];
 39860                                  
 39861                                  		;mov	al,[cur_disk]
 39862                                  		;cbw
 39863                                  		;mov	bx,ax
 39864                                  		;mov	cl,[max_sector+bx]
 39865                                  		;sub	ch,ch
 39866                                  		;mov	ax,[num_tracks]
 39867                                  		;sub	dx,dx ; **
 39868                                  
 39869 00005B8E 8B46F8                  		mov	ax,[num_tracks]
 39870                                  
 39871 00005B91 F7F1                    		div	cx
 39872 00005B93 8946F8                  		mov	[num_tracks],ax
 39873                                  
 39874                                  	;/* The number of tracks above does not take into
 39875                                  	;account the wasted track 0 which contains the partition info.
 39876                                  	;If cur_head = 0, then the above calculation would cause the
 39877                                  	;last track in the partition to be not verified */
 39878                                  
 39879                                  		;   if ( cur_head == 0 )
 39880                                  		;           num_tracks++;
 39881                                  
 39882 00005B96 386EF4                  		cmp	[cur_head],ch ; 0
 39883 00005B99 7503                    		jne	short vt_11
 39884 00005B9B FF46F8                  		inc	word [num_tracks]
 39885                                  vt_11:
 39886 00005B9E C646FE00                		mov	byte [golden_tracks],0 ; golden_tracks = FALSE;
 39887                                  vt_12:
 39888                                  	;/* this allows resetting the starting cyl of the golden tracks */	
 39889                                  
 39890                                  		;for (i = u(0);i < num_tracks; i++)
 39891                                  
 39892 00005BA2 C746F60000              		mov	word [vt_i],0
 39893 00005BA7 EB03                    		jmp	short vt_14
 39894                                  vt_13:
 39895 00005BA9 FF46F6                  		inc	word [vt_i]
 39896                                  vt_14:
 39897                                  	;/* this for loop is to write the number of golden tracks */
 39898                                  
 39899 00005BAC 8B46F6                  		mov	ax,[vt_i]
 39900 00005BAF 3946F8                  		cmp	[num_tracks],ax
 39901 00005BB2 7703                    		ja	short vt_15
 39902                                  
 39903 00005BB4 E9B600                  		jmp	vt_25
 39904                                  vt_15:
 39905                                  	;/* this for loop is to write the number of golden tracks */		
 39906                                  
 39907 00005BB7 C646FA00                		mov	byte [vt_retry],0
 39908                                  vt_16:
 39909                                  		; /* this do loop is for retries */
 39910                                  
 39911 00005BBB FE46FA                  		inc	byte [vt_retry]
 39912                                  
 39913                                  		;mov	byte [regs_x_ax+1],4 ; verify
 39914                                  		;mov	al,[cur_disk]
 39915                                  		;cbw
 39916                                  		;mov	bx,ax
 39917                                  		;mov	al,[max_sector+bx]
 39918                                  		;mov	[regs_x_ax],al
 39919                                  		;mov	byte [regs_x_cx],1
 39920                                  
 39921 00005BBE B101                    		mov	cl,1 	  ; /* Specify the start sectors */
 39922                                  
 39923                                  		;cmp	word [cur_cyl],255
 39924                                  		;jbe	short vt_17
 39925                                  
 39926 00005BC0 8B56FC                  		mov	dx,[cur_cyl]
 39927 00005BC3 81FAFF00                		cmp	dx,255
 39928 00005BC7 7605                    		jbe	short vt_17
 39929                                  
 39930                                  		;mov	ax,[cur_cyl]
 39931                                  		;shr	ax,1
 39932                                  		;shr	ax,1
 39933                                  		;and	al,0C1h
 39934                                  		;or	al,1
 39935                                  		;mov	byte [regs_x_cx],al
 39936                                  
 39937 00005BC9 C0E606                  		shl	dh,6
 39938 00005BCC 08F1                    		or	cl,dh  ; high two bits of cylinder in bits 7-6
 39939                                  vt_17:
 39940                                  		;mov	al,[cur_cyl]
 39941                                  		;mov	[regs_x_cx+1],al
 39942                                  		;mov	al,[cur_disk]
 39943                                  		;add	al,80h
 39944                                  		;mov	[regs_x_dx],al
 39945                                  		;mov	al,[cur_head]
 39946                                  		;mov	[regs_x_dx+1],al
 39947                                  		;mov	ax,regs_x_ax
 39948                                  		;push	ax
 39949                                  		;push	ax
 39950                                  		;mov	ax,13h
 39951                                  		;push	ax
 39952                                  		;call	int86
 39953                                  		;add	sp,6
 39954                                  
 39955 00005BCE 88D5                    		mov	ch,dl  ; byte [cur_cyl], low 8 bits of cylinder
 39956 00005BD0 8A76F4                  		mov	dh,[cur_head] ; /* Specify the head */
 39957 00005BD3 8A16[D4CB]              		mov	dl,[cur_disk] 
 39958 00005BD7 88D3                    		mov	bl,dl
 39959 00005BD9 80C280                  		add	dl,80h 	      ; /* Specify the disk */	
 39960                                   
 39961                                  		;regs.h.al = (unsigned char)max_sector[cur_disk];
 39962                                  
 39963                                  		;mov	bl,[cur_disk]
 39964 00005BDC 28FF                    		sub	bh,bh
 39965 00005BDE 8A87[A0A0]              		mov	al,[max_sector+bx]  ; /* Specify number of sectors */
 39966                                  
 39967                                  		; regs.h.ah = uc(VERIFY_DISK);
 39968 00005BE2 B404                    		mov	ah,04h  ; verify disk sectors
 39969 00005BE4 CD13                    		int	13h
 39970                                  
 39971                                  		; retry_flg = regs.x.cflag & 1;
 39972                                  
 39973                                  		;mov	al,[regs_x_cflag]
 39974                                  		;and	ax,1
 39975                                  		;jz	short vt_18
 39976                                  
 39977 00005BE6 7308                    		jnc	short vt_18
 39978                                  
 39979                                  		;while ((retry_flg) && (retry != c(3))); /* retry loop */
 39980                                  
 39981 00005BE8 807EFA03                		cmp	byte [vt_retry],3
 39982                                  		;jnz	short vt_16
 39983 00005BEC 72CD                    		jb	short vt_16
 39984                                  
 39985 00005BEE EB66                    		jmp	short vt_24
 39986                                  ;vt_18:
 39987                                  	;/************************************************************/
 39988                                  	;/* Check to see if cylinder was verified w/o errors.        */
 39989                                  	;/************************************************************/
 39990                                  	
 39991                                  	;if (!retry_flg)
 39992                                  	;   {                 
 39993                                  		;or	ax,ax
 39994                                  		;jnz	short vt_21
 39995                                  vt_18:
 39996                                  	;/*********************************************************/
 39997                                  	;/* Cylinder verified correctly. So write boot sector     */
 39998                                  	;/* and bump cylinder count, then go verify that cylinder.*/
 39999                                  	;/* Do not pass the end of the partition free space.      */
 40000                                  	;/*********************************************************/
 40001                                  
 40002 00005BF0 C646FA00                		mov	byte [vt_retry],0
 40003                                  	;do
 40004                                  	;	{
 40005                                  vt_19:
 40006 00005BF4 FE46FA                  		inc	byte [vt_retry]
 40007                                  
 40008                                  		;mov	byte ptr [regs_x_ax+1],3  ; WRITE_DISK
 40009                                  		;mov	al,1	; /* Write one sector only */
 40010                                  		;mov	[regs_x_ax],al
 40011                                  		;mov	[regs_x_cx],al ; /* Specify the start sectors */
 40012                                  
 40013                                  		;if (cur_cyl > u(255)) 
 40014                                  
 40015 00005BF7 B101                    		mov	cl,1 	  ; start sector	
 40016                                  
 40017                                  		;cmp	word [cur_cyl],255
 40018                                  		;jbe	short vt_20
 40019                                  
 40020 00005BF9 8B56FC                  		mov	dx,[cur_cyl]
 40021 00005BFC 81FAFF00                		cmp	dx,255
 40022 00005C00 7605                    		jbe	short vt_20
 40023                                  
 40024                                  		;regs.h.cl = regs.h.cl | ((unsigned char)((cur_cyl/256) << 6));
 40025                                  
 40026                                  		;mov	ax,[cur_cyl]
 40027                                  		;shr	ax,1
 40028                                  		;shr	ax,1
 40029                                  		;and	al,0C1h
 40030                                  		;or	al,1
 40031                                  		;mov	[regs_x_cx],al
 40032                                  
 40033 00005C02 C0E606                  		shl	dh,6
 40034 00005C05 08F1                    		or	cl,dh  ; high two bits of cylinder in bits 7-6
 40035                                  vt_20:
 40036                                  		;mov	al,[cur_cyl]
 40037                                  		;mov	[regs_x_cx+1],al
 40038                                  		;mov	al,[cur_disk]
 40039                                  		;add	al,80h
 40040                                  		;mov	[regs_x_dx],al	 ; /* Specify the disk */
 40041                                  		;mov	al,[cur_head]
 40042                                  		;mov	[regs_x_dx+1],al ; /* Specify the head */ 
 40043                                  		;mov	ax,[buffer_pointer_off]
 40044                                  		;mov	[regs_x_bx],ax
 40045                                  		;mov	ax,[buffer_pointer_seg]
 40046                                  		;mov	[segregs_es],ax
 40047                                  		;mov	ax,segregs_es
 40048                                  		;push	ax
 40049                                  		;mov	ax,regs_x_ax
 40050                                  		;push	ax
 40051                                  		;push	ax
 40052                                  		;call	DiskIo
 40053                                  		;add	sp,6
 40054                                  
 40055 00005C07 88D5                    		mov	ch,dl  ; byte [cur_cyl], low 8 bits of cylinder
 40056 00005C09 8A76F4                  		mov	dh,[cur_head]
 40057 00005C0C 8A16[D4CB]              		mov	dl,[cur_disk]
 40058 00005C10 80C280                  		add	dl,80h 
 40059                                  		;push	cs
 40060                                  		;pop	es
 40061 00005C13 BB[D2C9]                		mov	bx,boot_record
 40062 00005C16 B80103                  		mov	ax,0301h  ; write disk sectors 
 40063                                  				  ; (al = sector count = 1)
 40064 00005C19 CD13                    		int	13h
 40065                                  
 40066                                  		;/* See if we had a good read */
 40067                                  
 40068                                  		;retry_flg = regs.x.cflag & 1;  
 40069                                  
 40070                                  		;mov	al,[regs_x_cflag]
 40071                                  		;and	ax,1
 40072                                  		;jz	short vt_21
 40073                                  
 40074 00005C1B 7308                    		jnc	short vt_21
 40075                                  
 40076                                  		;while ((retry_flg) && (retry != c(3)));  
 40077                                  		
 40078 00005C1D 807EFA03                		cmp	byte [vt_retry],3
 40079 00005C21 72D1                    		jb	short vt_19
 40080                                  
 40081 00005C23 EB31                    		jmp	short vt_24
 40082                                  ;vt_21:
 40083                                  		;or	ax,ax
 40084                                  		;jnz	short vt_24
 40085                                  vt_21:
 40086                                  		; if (!retry_flg)
 40087                                  
 40088 00005C25 C646FE01                		mov	byte [golden_tracks],1  ; golden_tracks = TRUE;
 40089                                  		
 40090                                  		;mov	al,[cur_disk] 
 40091                                  		;cbw
 40092                                  		;mov	bx,ax
 40093                                  		;shl	bx,1
 40094 00005C29 28FF                    		sub	bh,bh
 40095 00005C2B 8A1E[D4CB]              		mov	bl,[cur_disk]
 40096 00005C2F D0E3                    		shl	bl,1
 40097                                  		
 40098                                  		;/* Get the next head */
 40099 00005C31 FE46F4                  		inc	byte [cur_head]  ; cur_head++;
 40100 00005C34 8A46F4                  		mov	al,[cur_head]
 40101                                  
 40102                                  		;/* Head no. is pre-incremented and cannot
 40103                                  		;   subtract 1 from max_head[cur_disk] */
 40104                                  
 40105                                  		;if (cur_head == (uc(max_head[cur_disk] )))
 40106                                  		;   BEGIN
 40107                                  		; /* Up to the next cylinder */
 40108                                  		;      cur_head = uc(0);
 40109                                  		;      cur_cyl++;
 40110                                  
 40111 00005C37 3887[A8A0]              		cmp	[max_head+bx],al
 40112 00005C3B 7510                    		jne	short vt_22
 40113 00005C3D C646F400                		mov	byte [cur_head],0
 40114                                  		
 40115                                  		;;mov	al,22
 40116                                  		;mov	al,10
 40117                                  		;;imul	byte [vt_pointer]
 40118                                  		;mul	byte [vt_pointer]
 40119                                  		;mov	bx,ax
 40120 00005C41 FF46FC                  		inc	word [cur_cyl]
 40121                                  
 40122                                  	;/* Check to see if we've reached the end of the free_space*/
 40123                                  
 40124                                  		;if (cur_cyl > free_space[pointer].end)
 40125                                  		;   BEGIN
 40126                                  	; /* It is, so return with the cyl offset equal to the freespace */
 40127                                  		;    return(free_space[pointer].space);
 40128                                  		;   END
 40129                                  
 40130 00005C44 8B46FC                  		mov	ax,[cur_cyl]
 40131                                  		;cmp	[free_space.end+bx],ax
 40132 00005C47 3984[E6CB]              		cmp	[free_space.end+si],ax ; ***
 40133 00005C4B 7203                    		jb	short vt_23
 40134                                  vt_22:
 40135 00005C4D E959FF                  		jmp	vt_13
 40136                                  vt_23:
 40137                                  		; return( free_space[pointer].space );
 40138                                  		;mov	ax,[free_space.space+bx]
 40139 00005C50 8B84[E2CB]              		mov	ax,[free_space.space+si] ; ***
 40140 00005C54 EB27                    		jmp	short vt_27
 40141                                  	; else	
 40142                                  vt_24:
 40143                                  	;/* Get out of the for loop, with a false flag */
 40144                                  	
 40145                                  		;golden_tracks = FALSE;
 40146 00005C56 C646FE00                		mov	byte [golden_tracks],0
 40147                                  		
 40148                                  		;;mov	al,22
 40149                                  		;mov	al,10
 40150                                  		;;imul	byte [vt_pointer]
 40151                                  		;mul	byte [vt_pointer]
 40152                                  		;mov	bx,ax
 40153                                  
 40154                                  		;/* Bump up to the next cylinder boundary */
 40155                                  		
 40156                                  		;cur_cyl++;
 40157                                  		
 40158 00005C5A FF46FC                  		inc	word [cur_cyl]
 40159                                  
 40160                                  		;/* To get out of the loop we have to check if 
 40161                                  		;there have been enough golden tracks or not.
 40162                                  		;The setting of the flag as above will not get us 
 40163                                  		;out of the loop. We return with the cyl offset 
 40164                                  		;equal to the freespace to indicate that
 40165                                  		;this freespace cannot be used */
 40166                                  
 40167 00005C5D 8B46FC                  		mov	ax,[cur_cyl]
 40168                                  
 40169                                  		;if ( cur_cyl > free_space[pointer].end )
 40170                                  		;     return( free_space[pointer].space );
 40171                                  
 40172                                  		;cmp	[free_space.end+bx],ax
 40173 00005C60 3984[E6CB]              		cmp	[free_space.end+si],ax ; ***
 40174 00005C64 72EA                    		jb	short vt_23
 40175                                  
 40176 00005C66 C646F400                		mov	byte [cur_head],0  ; cur_head = uc(0);   
 40177                                  
 40178                                  		;/* Save the new verify start point */
 40179                                  
 40180 00005C6A 8946F2                  		mov	[verify_cyl],ax
 40181                                  vt_25:
 40182                                  		;while (!golden_tracks)
 40183                                  	
 40184 00005C6D 807EFE00                		cmp	byte [golden_tracks],0
 40185 00005C71 7503                    		jne	short vt_26
 40186                                  
 40187                                  	;/* this allows resetting the starting cyl of the golden tracks */
 40188                                  
 40189 00005C73 E92CFF                  		jmp	vt_12  ; /*while !golden_tracks */
 40190                                  vt_26:
 40191                                  	;/* All done, return the offset from original cyl to the new one */
 40192                                  	
 40193                                  		; return(verify_cyl - free_space[pointer].start);
 40194                                  
 40195                                  		;;mov	al,22
 40196                                  		;mov	al,10
 40197                                  		;;imul	byte [vt_pointer]
 40198                                  		;mul	byte [vt_pointer]
 40199                                  		;mov	bx,ax
 40200 00005C76 8B46F2                  		mov	ax,[verify_cyl]
 40201                                  		;sub	ax,[free_space.start+bx]
 40202 00005C79 2B84[E4CB]              		sub	ax,[free_space.start+si] ; ***
 40203                                  vt_27:
 40204                                  		;pop	si
 40205                                  		;pop	di
 40206                                  		
 40207 00005C7D 89EC                    		mov	sp,bp
 40208 00005C7F 5D                      		pop	bp
 40209                                  		;retn
 40210 00005C80 C20400                  		retn	4
 40211                                  
 40212                                  ;=============================================================================
 40213                                  ;        	TEMPORARY
 40214                                  ;=============================================================================
 40215                                  ; 10/11/2018
 40216                                  
 40217                                  ;print_parse_error_msg:
 40218                                  ;		;and	al,al
 40219                                  ;		;jnz	short ppe
 40220                                  ;		;retn
 40221                                  ;;ppe:
 40222                                  ;		push	ax
 40223                                  ;		mov	si,beep_next_line
 40224                                  ;		call	print_msg
 40225                                  ;		pop	bx
 40226                                  ;		dec	bx
 40227                                  ;		shl	bx,1
 40228                                  ;		add	bx,parse_error_tbl
 40229                                  ;
 40230                                  ;		mov	si,[bx]
 40231                                  ;		call	print_msg
 40232                                  ;		mov	si,next_line
 40233                                  ;		jmp	print_msg
 40234                                  ;
 40235                                  ;parse_error_tbl:
 40236                                  ;		;dw	_No_Error
 40237                                  ;		dw	_Too_Many	; 1
 40238                                  ;		dw	_Op_Missing	; 2
 40239                                  ;		dw	_Not_In_Sw	; 3
 40240                                  ;		dw	_Not_In_Key	; 4
 40241                                  ;		dw	_unused_err_no	;(5)
 40242                                  ;		dw	_Out_Of_Range	; 6
 40243                                  ;		dw	_Not_In_Val	; 7
 40244                                  ;		dw	_Not_In_Str	; 8
 40245                                  ;		dw	_Syntax		; 9
 40246                                  ;		; TEMPORARY!
 40247                                  ;		dw	_Invalid
 40248                                  
 40249                                  print_msg:
 40250 00005C83 B40E                    		mov	ah,0Eh
 40251 00005C85 BB0700                  		mov	bx,07h
 40252                                  pmsg_1:
 40253 00005C88 AC                      		lodsb
 40254 00005C89 20C0                    		and	al,al
 40255 00005C8B 7404                    		jz	short pmsg_2
 40256 00005C8D CD10                    		int	10h
 40257 00005C8F EBF7                    		jmp	short pmsg_1
 40258                                  pmsg_2:
 40259 00005C91 C3                      		retn	
 40260                                  
 40261                                  beep_next_line:
 40262 00005C92 07                      		db	07h
 40263                                  next_line:
 40264 00005C93 0D0A00                  		db	0Dh,0Ah,0
 40265                                  
 40266                                  ;		; Note: Same error message order in COMMAND.COM 6.22 (*)
 40267                                  ;		;	offset 0A41h - INT 2Fh MULTDOS,MSG_RETRIEVAL ; 11/11/2018
 40268                                  ;_Too_Many:	;db	'Too many operands!',0
 40269                                  ;		db	'Too many parameters!',0 ; (*)
 40270                                  ;_Op_Missing:	;db	'Required operand missing!',0
 40271                                  ;		db	'Required parameter missing!',0 ; (*)
 40272                                  ;_Not_In_Sw:	;db	'Not in switch list provided!',0
 40273                                  ;		db	'Invalid switch!',0 ; (*)		
 40274                                  ;_Not_In_Key:	;db	'Not in keyword list provided!',0
 40275                                  ;		db	'Invalid keyword!',0 ; (*)
 40276                                  ;_unused_err_no: db	' ',0 ; (*)
 40277                                  ;_Out_Of_Range:	;db	'Out of range specified!',0
 40278                                  ;		;db	'Out of range!',0
 40279                                  ;		db	'Parameter value not in allowed range!',0 ; (*)	
 40280                                  ;_Not_In_Val:	;db	'Not in value list provided!',0
 40281                                  ;		;db	'Invalid size!',0
 40282                                  ;		db	'Parameter value not allowed!',0 ; (*)	
 40283                                  ;_Not_In_Str:	;db	'Not in string list provided!',0
 40284                                  ;		;db	'Invalid string!',0
 40285                                  ;		db	'Parameter value not allowed',0 ; (*)
 40286                                  ;_Syntax:	;db	'Syntax error!',0
 40287                                  ;		db	'Parameter format not correct!',0 ; (*)
 40288                                  ;_Invalid:	db	'Invalid command parameter(s)!',0 ; TEMPORARY!
 40289                                  
 40290                                  incorrect_dos_version:
 40291 00005C96 0D0A                    		db	0Dh,0Ah
 40292 00005C98 496E636F7272656374-     		db	'Incorrect DOS version!'
 40293 00005CA1 20444F532076657273-
 40294 00005CAA 696F6E21           
 40295 00005CAE 0D0A00                  		db	0Dh,0Ah,0
 40296                                  
 40297                                  ; ----------------------------------------------------------------------------
 40298                                  
 40299                                  ; TEMPORARY SUBROUTINES - 10/11/2018 
 40300                                  
 40301                                  fdisk_program_msg:
 40302 00005CB1 0D0A                    		db	0Dh,0Ah
 40303 00005CB3 464449534B20757469-     		db	'FDISK utility (v2) by Erdogan Tan - 2019'
 40304 00005CBC 6C6974792028763229-
 40305 00005CC5 206279204572646F67-
 40306 00005CCE 616E2054616E202D20-
 40307 00005CD7 32303139           
 40308 00005CDB 0D0A00                  		db	0Dh,0Ah,0
 40309                                  
 40310                                  print_fdisk_program_msg:
 40311 00005CDE BE[B15C]                		mov	si,fdisk_program_msg
 40312 00005CE1 EBA0                    		jmp	print_msg
 40313                                  
 40314                                  ;=============================================================================
 40315                                  ;        	initialized data
 40316                                  ;=============================================================================
 40317                                  
 40318                                  ; 13/11/2018
 40319                                  
 40320 00005CE3 90                      align 2
 40321                                  
 40322 00005CE4 00000000                $M_EXT_ERR_ADDRS: dd 0	
 40323 00005CE8 00000000                $M_EXT_FILE:	dd 0
 40324 00005CEC 00000000                $M_EXT_COMMAND:	dd 0
 40325 00005CF0 FFFFFFFF                $M_EXT_TERM:	dd 0FFFFFFFFh
 40326 00005CF4 00000000                $M_PARSE_COMMAND: dd 0
 40327 00005CF8 00000000                $M_PARSE_ADDRS:	dd 0
 40328 00005CFC FFFFFFFF                $M_PARSE_TERM:	dd 0FFFFFFFFh
 40329 00005D00 00000000                $M_CRIT_ADDRS:	dd 0
 40330 00005D04 00000000                $M_CRIT_COMMAND: dd 0
 40331 00005D08 FFFFFFFF                $M_CRIT_TERM:	dd 0FFFFFFFFh
 40332 00005D0C FFFFFFFF                $M_DISK_PROC_ADDR: dd 0FFFFFFFFh
 40333 00005D10 00000000                $M_CLASS_A_ADDRS: dd 0
 40334 00005D14 00000000                $M_CLASS_B_ADDRS: dd 0
 40335 00005D18 FFFFFFFF                $M_CLS_TERM:	dd 0FFFFFFFFh
 40336 00005D1C 00000000                $M_DBCS_VEC:	dd 0
 40337 00005D20 0000                    $M_HANDLE:	dw 0
 40338 00005D22 00                      $M_SIZE:	db 0
 40339 00005D23 0D0A                    $M_CRLF:	dw 0A0Dh
 40340 00005D25 00                      $M_CLASS:	db 0
 40341 00005D26 0000                    $M_RETURN_ADDR:	dw 0
 40342 00005D28 0000                    $M_MSG_NUM:	dw 0
 40343 00005D2A 0A00                    $M_DIVISOR:	dw 10
 40344 00005D2C 24242424242424          $M_TEMP_BUF:	db '$$$$$$$'
 40345 00005D33 24<rept>                $M_THOU_SEPARA:	times 57 db '$' ; db 39h dup('$')
 40346 00005D6C 24                      $M_BUF_TERM:	db '$'
 40347                                  
 40348                                  		;db 0
 40349 00005D6D 90                      align 2
 40350                                  
 40351                                  ;	; MSDOS 6.0 (1991) FDISK.SKL file (content):
 40352                                  ;	
 40353                                  ;	:util FDISK                ;utility name
 40354                                  ;	:class A                   ;system messages
 40355                                  ;	;
 40356                                  ;	:use 1 COMMON1             ;"Incorrect DOS version"
 40357                                  ;	:use 2 COMMON2             ;"Insufficient Memory"
 40358                                  ;	:use 3 COMMON3             ;"Internal error loading messages"
 40359                                  ;	:use 8 EXTEND87            ;"Invalid parameter"
 40360                                  ;	:def 9  "Y",0              ;"Y"
 40361                                  ;	:def 10 "N",0              ;"N"
 40362                                  ;
 40363                                  ;	;    Options help messages (all class A) 300-399 RESERVED
 40364                                  ;	:def 300 FDISK /?
 40365                                  ;	:def 301 FDISK /?
 40366                                  ;
 40367                                  ;	;
 40368                                  ;	:class B
 40369                                  ;	:def 4 "Cannot FDISK with network loaded",CR,LF
 40370                                  ;	:def 5 "No fixed disks present",CR,LF
 40371                                  ;	:def 6 "Error reading fixed disk",CR,LF
 40372                                  ;	:def 7 "Error writing fixed disk",CR,LF
 40373                                  ;	:def 11 "The Master boot code has NOT been updated.",CR,LF 
 40374                                  
 40375                                  	; PC-DOS 7.0 FDISK.COM (unpacked & disassembled Offset: DGROUP:2262h)
 40376                                  
 40377                                  CLASS_A_msg_tbl:
 40378 00005D6E FF                      		db 0FFh	; Class identifer : UTILITY_MSG_CLASS
 40379 00005D6F 0700                    		dw 7	; COMMAND.COM version check : 7.0 (PC-DOS 7.0)
 40380 00005D71 09                      		db 9	; Total number of messages in class
 40381 00005D72 0100                    		dw 1	; Message number: 1
 40382 00005D74 2400                    		dw 24h	; Message offset from previous word. / Addr: 2266h+24h
 40383 00005D76 0200                    		dw 2	; Message number: 2
 40384 00005D78 3800                    		dw 38h	; Message offset from previous word. / Addr: 226Ah+38h
 40385 00005D7A 0300                    		dw 3	; $M_NUM
 40386 00005D7C 4B00                    		dw 4Bh	; $M_TXT_PTR
 40387 00005D7E 0800                    		dw 8
 40388 00005D80 6400                    		dw 64h
 40389 00005D82 0900                    		dw 9	; Message number: 9
 40390 00005D84 7400                    		dw 74h
 40391 00005D86 0A00                    		dw 10
 40392 00005D88 7300                    		dw 73h
 40393 00005D8A 2C01                    		dw 300	; Message number: 300
 40394 00005D8C 7200                    		dw 72h	; Message offset from previous word. / Addr: 227Eh+72h
 40395 00005D8E 2D01                    		dw 301
 40396 00005D90 9E00                    		dw 9Eh
 40397 00005D92 2E01                    		dw 302
 40398 00005D94 AE00                    		dw 0AEh
 40399 00005D96 17496E636F72726563-     		db 17h,'Incorrect DOS version',0Dh,0Ah
 40400 00005D9F 7420444F5320766572-
 40401 00005DA8 73696F6E0D0A       
 40402 00005DAE 16253120616C726561-     		db 16h,'%1 already installed',0Dh,0Ah
 40403 00005DB7 647920696E7374616C-
 40404 00005DC0 6C65640D0A         
 40405 00005DC5 1C2531206279746573-     		db 1Ch,'%1 bytes available on disk',0Dh,0Ah
 40406 00005DCE 20617661696C61626C-
 40407 00005DD7 65206F6E206469736B-
 40408 00005DE0 0D0A               
 40409 00005DE2 13496E76616C696420-     		db 13h,'Invalid parameter',0Dh,0Ah
 40410 00005DEB 706172616D65746572-
 40411 00005DF4 0D0A               
 40412 00005DF6 02                      		db 2
 40413 00005DF7 5900                    _yes:		db 'Y',0
 40414 00005DF9 02                      		db 2
 40415 00005DFA 4E00                    _no:		db 'N',0
 40416 00005DFC 2F                      options_msg:	db 2Fh
 40417 00005DFD 436F6E666967757265-     		db 'Configures a hard disk for use with PC DOS.',0Dh,0Ah
 40418 00005E06 732061206861726420-
 40419 00005E0F 6469736B20666F7220-
 40420 00005E18 757365207769746820-
 40421 00005E21 504320444F532E0D0A 
 40422 00005E2A 0D0A                    		db 0Dh,0Ah
 40423 00005E2C 13                      _fdisk_st_row:	db 13h
 40424 00005E2D 464449534B205B2F53-     		db 'FDISK [/STATUS]'
 40425 00005E36 54415455535D       
 40426 00005E3C 0D0A                    		db 0Dh,0Ah
 40427 00005E3E 0D0A                    		db 0Dh,	0Ah
 40428 00005E40 3D                      stats_desc_row:	db 3Dh
 40429 00005E41 202020202F53544154-     		db '    /STATUS     Displays the status of the fixed disk drive',0Dh,0Ah
 40430 00005E4A 555320202020204469-
 40431 00005E53 73706C617973207468-
 40432 00005E5C 652073746174757320-
 40433 00005E65 6F6620746865206669-
 40434 00005E6E 786564206469736B20-
 40435 00005E77 64726976650D0A     
 40436                                  
 40437                                  		;db 0
 40438                                  align 2
 40439                                  
 40440                                  	; PC-DOS 7.0 FDISK.COM (unpacked & disassembled Offset: DGROUP:237Dh)
 40441                                  
 40442                                  CLASS_B_msg_tbl:
 40443 00005E7E FF                      		db 0FFh	; Class identifer : UTILITY_MSG_CLASS
 40444 00005E7F 0700                    		dw 7	; COMMAND.COM version check : 7.0 (PC-DOS 7.0)
 40445 00005E81 05                      		db 5	; Total number of messages in class
 40446 00005E82 0400                    		dw 4	; $M_NUM
 40447 00005E84 1400                    		dw 14h	; $M_TXT_PTR
 40448 00005E86 0500                    		dw 5	; Message number: 5
 40449 00005E88 3300                    		dw 33h	; Message offset from previous word. / Addr: 2285h+33h
 40450 00005E8A 0600                    		dw 6
 40451 00005E8C 4800                    		dw 48h
 40452 00005E8E 0700                    		dw 7
 40453 00005E90 5F00                    		dw 5Fh
 40454 00005E92 0B00                    		dw 11	; Message number: 11
 40455 00005E94 7600                    		dw 76h	; Message offset from previous word. / Addr: 2291h+76h
 40456 00005E96 22                      		db 22h
 40457 00005E97 43616E6E6F74204644-     		db 'Cannot FDISK with network loaded',0Dh,0Ah
 40458 00005EA0 49534B207769746820-
 40459 00005EA9 6E6574776F726B206C-
 40460 00005EB2 6F616465640D0A     
 40461 00005EB9 18                      		db 18h
 40462 00005EBA 4E6F20666978656420-     		db 'No fixed disks present',0Dh,0Ah
 40463 00005EC3 6469736B7320707265-
 40464 00005ECC 73656E740D0A       
 40465 00005ED2 1A                      		db 1Ah
 40466 00005ED3 4572726F7220726561-     		db 'Error reading fixed disk',0Dh,0Ah
 40467 00005EDC 64696E672066697865-
 40468 00005EE5 64206469736B0D0A   
 40469 00005EED 1A                      		db 1Ah
 40470 00005EEE 4572726F7220777269-     		db 'Error writing fixed disk',0Dh,0Ah
 40471 00005EF7 74696E672066697865-
 40472 00005F00 64206469736B0D0A   
 40473 00005F08 2C                      		db 2Ch
 40474 00005F09 546865206D61737465-     		db 'The master boot code has NOT been updated.',0Dh,0Ah
 40475 00005F12 7220626F6F7420636F-
 40476 00005F1B 646520686173204E4F-
 40477 00005F24 54206265656E207570-
 40478 00005F2D 64617465642E0D0A   
 40479                                  
 40480                                  		;db 0
 40481 00005F35 90                      align 2
 40482                                  
 40483                                  CLASS_1_msg_tbl:
 40484 00005F36 01                      		db 1	; Class identifier : EXT_ERR_CLASS
 40485 00005F37 0700                    		dw 7	; COMMAND.COM version check : 7.0 (PC-DOS 7.0)
 40486 00005F39 01                      		db 1	; Total number of messages in class
 40487 00005F3A FFFF                    		dw 0FFFFh ; $M_NUM = -1
 40488 00005F3C 0400                    		dw 4	; $M_TXT_PTR
 40489 00005F3E 11                      _EXT_ERR_CLASS:	db 17	; Msg length
 40490 00005F3F 457874656E64656420-     		db 'Extended Error %1'
 40491 00005F48 4572726F72202531   
 40492                                  
 40493                                  		;db 0
 40494                                  
 40495                                  CLASS_2_msg_tbl:
 40496 00005F50 02                      		db 2	; Class identifier : PARSE_ERR_CLASS
 40497 00005F51 0700                    		dw 7	; COMMAND.COM version check : 7.0 (PC-DOS 7.0)
 40498 00005F53 01                      		db 1	; Total number of messages in class
 40499 00005F54 FFFF                    		dw 0FFFFh ; $M_NUM = -1
 40500 00005F56 0400                    		dw 4	; $M_TXT_PTR
 40501 00005F58 0E                      _PARSE_ERR_CLASSS: db 14 ; Msg length
 40502 00005F59 506172736520457272-     		db 'Parse Error %1'
 40503 00005F62 6F72202531         
 40504                                  
 40505                                  		;db 0
 40506                                  
 40507                                  ; 24/11/2018
 40508                                  extFAT16:
 40509 00005F67 464154313620202000      FAT16:		db 'FAT16   ',0
 40510                                  extFAT12:
 40511 00005F70 464154313220202000      FAT12:		db 'FAT12   ',0
 40512                                  extNOVOLUME:
 40513 00005F79 00                      NOVOLUME:	db 0
 40514                                  extUNKNOWN:
 40515 00005F7A 554E4B4E4F574E2000      UNKNOWN:	db 'UNKNOWN ',0
 40516                                  
 40517                                  ; 26/11/2018
 40518                                  ;extFAT16:	db 'FAT16   ',0 
 40519                                  ;extFAT12:	db 'FAT12   ',0
 40520                                  ;extNOVOLUME:	db 0
 40521                                  ;extUNKNOWN:	db 'UNKNOWN ',0
 40522                                  
 40523 00005F83 90                      align 2
 40524                                  
 40525                                  master_boot_record:
 40526 00005F84 FA33C08ED0BC007C8B-     	db 0FAh, 33h, 0C0h, 8Eh, 0D0h, 0BCh, 00h, 7Ch, 8Bh, 0F4h, 50h, 07h, 50h, 1Fh, 0FBh, 0FCh
 40527 00005F8D F45007501FFBFC     
 40528 00005F94 BF0006B90001F2A5EA-     	db 0BFh, 00h, 06h, 0B9h, 00h, 01h, 0F2h, 0A5h, 0EAh, 1Dh, 06h, 00h, 00h, 0BEh, 0BEh, 07h
 40529 00005F9D 1D060000BEBE07     
 40530 00005FA4 B304803C80740E803C-     	db 0B3h, 04h, 80h, 3Ch,	80h, 74h, 0Eh, 80h, 3Ch, 00h, 75h, 1Ch,	83h, 0C6h, 10h,	0FEh
 40531 00005FAD 00751C83C610FE     
 40532 00005FB4 CB75EFCD188B148B4C-     	db 0CBh, 75h, 0EFh, 0CDh, 18h, 8Bh, 14h, 8Bh, 4Ch, 02h,	8Bh, 0EEh, 83h,	0C6h, 10h, 0FEh
 40533 00005FBD 028BEE83C610FE     
 40534 00005FC4 CB741A803C0074F4BE-     	db 0CBh, 74h, 1Ah, 80h,	3Ch, 00h, 74h, 0F4h, 0BEh, 8Bh,	06h, 0ACh, 3Ch,	00h, 74h, 0Bh
 40535 00005FCD 8B06AC3C00740B     
 40536 00005FD4 56BB0700B40ECD105E-     	db 56h,	0BBh, 07h, 00h,	0B4h, 0Eh, 0CDh, 10h, 5Eh, 0EBh, 0F0h, 0EBh, 0FEh, 0BFh, 05h, 00h
 40537 00005FDD EBF0EBFEBF0500     
 40538 00005FE4 BB007CB8010257CD13-     	db 0BBh, 00h, 7Ch, 0B8h, 01h, 02h, 57h,	0CDh, 13h, 5Fh,	73h, 0Ch, 33h, 0C0h, 0CDh, 13h
 40539 00005FED 5F730C33C0CD13     
 40540 00005FF4 4F75EDBEA306EBD3BE-     	db 4Fh,	75h, 0EDh, 0BEh, 0A3h, 06h, 0EBh, 0D3h,	0BEh, 0C2h, 06h, 0BFh, 0FEh, 7Dh, 81h, 3Dh
 40541 00005FFD C206BFFE7D813D     
 40542 00006004 55AA75C78BF5EA007C-     	db 55h,	0AAh, 75h, 0C7h, 8Bh, 0F5h, 0EAh, 00h, 7Ch, 00h, 00h, 49h, 6Eh,	76h, 61h, 6Ch
 40543 0000600D 0000496E76616C     
 40544 00006014 696420706172746974-     	db 69h,	64h, 20h, 70h, 61h, 72h, 74h, 69h, 74h,	69h, 6Fh, 6Eh, 20h, 74h, 61h, 62h
 40545 0000601D 696F6E20746162     
 40546 00006024 6C65004572726F7220-     	db 6Ch,	65h, 00h, 45h, 72h, 72h, 6Fh, 72h, 20h,	6Ch, 6Fh, 61h, 64h, 69h, 6Eh, 67h
 40547 0000602D 6C6F6164696E67     
 40548 00006034 206F7065726174696E-     	db 20h,	6Fh, 70h, 65h, 72h, 61h, 74h, 69h, 6Eh,	67h, 20h, 73h, 79h, 73h, 74h, 65h
 40549 0000603D 67207379737465     
 40550 00006044 6D004D697373696E67-     	db 6Dh,	00h, 4Dh, 69h, 73h, 73h, 69h, 6Eh, 67h,	20h, 6Fh, 70h, 65h, 72h, 61h, 74h
 40551 0000604D 206F7065726174     
 40552 00006054 696E67207379737465-     	db 69h,	6Eh, 67h, 20h, 73h, 79h, 73h, 74h, 65h,	6Dh, 00h, 00h, 00h, 00h, 00h, 00h
 40553 0000605D 6D000000000000     
 40554 00006064 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40555 0000606D 00000000000000     
 40556 00006074 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40557 0000607D 00000000000000     
 40558 00006084 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40559 0000608D 00000000000000     
 40560 00006094 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40561 0000609D 00000000000000     
 40562 000060A4 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40563 000060AD 00000000000000     
 40564 000060B4 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40565 000060BD 00000000000000     
 40566 000060C4 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40567 000060CD 00000000000000     
 40568 000060D4 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40569 000060DD 00000000000000     
 40570 000060E4 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40571 000060ED 00000000000000     
 40572 000060F4 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40573 000060FD 00000000000000     
 40574 00006104 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40575 0000610D 00000000000000     
 40576 00006114 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40577 0000611D 00000000000000     
 40578 00006124 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40579 0000612D 00000000000000     
 40580 00006134 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40581 0000613D 00000000000000     
 40582 00006144 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40583 0000614D 00000000000000     
 40584 00006154 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40585 0000615D 00000000000000     
 40586 00006164 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40587 0000616D 00000000000000     
 40588 00006174 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 55h, 0AAh
 40589 0000617D 000000000055AA     
 40590                                  mbr_hd1:
 40591 00006184 FA33C08ED0BC007C8B-     	db 0FAh, 33h, 0C0h, 8Eh, 0D0h, 0BCh, 00h, 7Ch, 8Bh, 0F4h, 50h, 07h, 50h, 1Fh, 0FBh, 0FCh
 40592 0000618D F45007501FFBFC     
 40593 00006194 BF0006B90001F2A5EA-     	db 0BFh, 00h, 06h, 0B9h, 00h, 01h, 0F2h, 0A5h, 0EAh, 1Dh, 06h, 00h, 00h, 0BEh, 0BEh, 07h
 40594 0000619D 1D060000BEBE07     
 40595 000061A4 B304803C80740E803C-     	db 0B3h, 04h, 80h, 3Ch,	80h, 74h, 0Eh, 80h, 3Ch, 00h, 75h, 1Ch,	83h, 0C6h, 10h,	0FEh
 40596 000061AD 00751C83C610FE     
 40597 000061B4 CB75EFCD188B148B4C-     	db 0CBh, 75h, 0EFh, 0CDh, 18h, 8Bh, 14h, 8Bh, 4Ch, 02h,	8Bh, 0EEh, 83h,	0C6h, 10h, 0FEh
 40598 000061BD 028BEE83C610FE     
 40599 000061C4 CB741A803C0074F4BE-     	db 0CBh, 74h, 1Ah, 80h,	3Ch, 00h, 74h, 0F4h, 0BEh, 8Bh,	06h, 0ACh, 3Ch,	00h, 74h, 0Bh
 40600 000061CD 8B06AC3C00740B     
 40601 000061D4 56BB0700B40ECD105E-     	db 56h,	0BBh, 07h, 00h,	0B4h, 0Eh, 0CDh, 10h, 5Eh, 0EBh, 0F0h, 0EBh, 0FEh, 0BFh, 05h, 00h
 40602 000061DD EBF0EBFEBF0500     
 40603 000061E4 BB007CB8010257CD13-     	db 0BBh, 00h, 7Ch, 0B8h, 01h, 02h, 57h,	0CDh, 13h, 5Fh,	73h, 0Ch, 33h, 0C0h, 0CDh, 13h
 40604 000061ED 5F730C33C0CD13     
 40605 000061F4 4F75EDBEA306EBD3BE-     	db 4Fh,	75h, 0EDh, 0BEh, 0A3h, 06h, 0EBh, 0D3h,	0BEh, 0C2h, 06h, 0BFh, 0FEh, 7Dh, 81h, 3Dh
 40606 000061FD C206BFFE7D813D     
 40607 00006204 55AA75C78BF5EA007C-     	db 55h,	0AAh, 75h, 0C7h, 8Bh, 0F5h, 0EAh, 00h, 7Ch, 00h, 00h, 49h, 6Eh,	76h, 61h, 6Ch
 40608 0000620D 0000496E76616C     
 40609 00006214 696420706172746974-     	db 69h,	64h, 20h, 70h, 61h, 72h, 74h, 69h, 74h,	69h, 6Fh, 6Eh, 20h, 74h, 61h, 62h
 40610 0000621D 696F6E20746162     
 40611 00006224 6C65004572726F7220-     	db 6Ch,	65h, 00h, 45h, 72h, 72h, 6Fh, 72h, 20h,	6Ch, 6Fh, 61h, 64h, 69h, 6Eh, 67h
 40612 0000622D 6C6F6164696E67     
 40613 00006234 206F7065726174696E-     	db 20h,	6Fh, 70h, 65h, 72h, 61h, 74h, 69h, 6Eh,	67h, 20h, 73h, 79h, 73h, 74h, 65h
 40614 0000623D 67207379737465     
 40615 00006244 6D004D697373696E67-     	db 6Dh,	00h, 4Dh, 69h, 73h, 73h, 69h, 6Eh, 67h,	20h, 6Fh, 70h, 65h, 72h, 61h, 74h
 40616 0000624D 206F7065726174     
 40617 00006254 696E67207379737465-     	db 69h,	6Eh, 67h, 20h, 73h, 79h, 73h, 74h, 65h,	6Dh, 00h, 00h, 00h, 00h, 00h, 00h
 40618 0000625D 6D000000000000     
 40619 00006264 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40620 0000626D 00000000000000     
 40621 00006274 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40622 0000627D 00000000000000     
 40623 00006284 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40624 0000628D 00000000000000     
 40625 00006294 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40626 0000629D 00000000000000     
 40627 000062A4 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40628 000062AD 00000000000000     
 40629 000062B4 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40630 000062BD 00000000000000     
 40631 000062C4 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40632 000062CD 00000000000000     
 40633 000062D4 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40634 000062DD 00000000000000     
 40635 000062E4 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40636 000062ED 00000000000000     
 40637 000062F4 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40638 000062FD 00000000000000     
 40639 00006304 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40640 0000630D 00000000000000     
 40641 00006314 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40642 0000631D 00000000000000     
 40643 00006324 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40644 0000632D 00000000000000     
 40645 00006334 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40646 0000633D 00000000000000     
 40647 00006344 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40648 0000634D 00000000000000     
 40649 00006354 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40650 0000635D 00000000000000     
 40651 00006364 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40652 0000636D 00000000000000     
 40653 00006374 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 55h, 0AAh
 40654 0000637D 000000000055AA     
 40655                                  mbr_hd2:
 40656 00006384 FA33C08ED0BC007C8B-     	db 0FAh, 33h, 0C0h, 8Eh, 0D0h, 0BCh, 00h, 7Ch, 8Bh, 0F4h, 50h, 07h, 50h, 1Fh, 0FBh, 0FCh
 40657 0000638D F45007501FFBFC     
 40658 00006394 BF0006B90001F2A5EA-     	db 0BFh, 00h, 06h, 0B9h, 00h, 01h, 0F2h, 0A5h, 0EAh, 1Dh, 06h, 00h, 00h, 0BEh, 0BEh, 07h
 40659 0000639D 1D060000BEBE07     
 40660 000063A4 B304803C80740E803C-     	db 0B3h, 04h, 80h, 3Ch,	80h, 74h, 0Eh, 80h, 3Ch, 00h, 75h, 1Ch,	83h, 0C6h, 10h,	0FEh
 40661 000063AD 00751C83C610FE     
 40662 000063B4 CB75EFCD188B148B4C-     	db 0CBh, 75h, 0EFh, 0CDh, 18h, 8Bh, 14h, 8Bh, 4Ch, 02h,	8Bh, 0EEh, 83h,	0C6h, 10h, 0FEh
 40663 000063BD 028BEE83C610FE     
 40664 000063C4 CB741A803C0074F4BE-     	db 0CBh, 74h, 1Ah, 80h,	3Ch, 00h, 74h, 0F4h, 0BEh, 8Bh,	06h, 0ACh, 3Ch,	00h, 74h, 0Bh
 40665 000063CD 8B06AC3C00740B     
 40666 000063D4 56BB0700B40ECD105E-     	db 56h,	0BBh, 07h, 00h,	0B4h, 0Eh, 0CDh, 10h, 5Eh, 0EBh, 0F0h, 0EBh, 0FEh, 0BFh, 05h, 00h
 40667 000063DD EBF0EBFEBF0500     
 40668 000063E4 BB007CB8010257CD13-     	db 0BBh, 00h, 7Ch, 0B8h, 01h, 02h, 57h,	0CDh, 13h, 5Fh,	73h, 0Ch, 33h, 0C0h, 0CDh, 13h
 40669 000063ED 5F730C33C0CD13     
 40670 000063F4 4F75EDBEA306EBD3BE-     	db 4Fh,	75h, 0EDh, 0BEh, 0A3h, 06h, 0EBh, 0D3h,	0BEh, 0C2h, 06h, 0BFh, 0FEh, 7Dh, 81h, 3Dh
 40671 000063FD C206BFFE7D813D     
 40672 00006404 55AA75C78BF5EA007C-     	db 55h,	0AAh, 75h, 0C7h, 8Bh, 0F5h, 0EAh, 00h, 7Ch, 00h, 00h, 49h, 6Eh,	76h, 61h, 6Ch
 40673 0000640D 0000496E76616C     
 40674 00006414 696420706172746974-     	db 69h,	64h, 20h, 70h, 61h, 72h, 74h, 69h, 74h,	69h, 6Fh, 6Eh, 20h, 74h, 61h, 62h
 40675 0000641D 696F6E20746162     
 40676 00006424 6C65004572726F7220-     	db 6Ch,	65h, 00h, 45h, 72h, 72h, 6Fh, 72h, 20h,	6Ch, 6Fh, 61h, 64h, 69h, 6Eh, 67h
 40677 0000642D 6C6F6164696E67     
 40678 00006434 206F7065726174696E-     	db 20h,	6Fh, 70h, 65h, 72h, 61h, 74h, 69h, 6Eh,	67h, 20h, 73h, 79h, 73h, 74h, 65h
 40679 0000643D 67207379737465     
 40680 00006444 6D004D697373696E67-     	db 6Dh,	00h, 4Dh, 69h, 73h, 73h, 69h, 6Eh, 67h,	20h, 6Fh, 70h, 65h, 72h, 61h, 74h
 40681 0000644D 206F7065726174     
 40682 00006454 696E67207379737465-     	db 69h,	6Eh, 67h, 20h, 73h, 79h, 73h, 74h, 65h,	6Dh, 00h, 00h, 00h, 00h, 00h, 00h
 40683 0000645D 6D000000000000     
 40684 00006464 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40685 0000646D 00000000000000     
 40686 00006474 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40687 0000647D 00000000000000     
 40688 00006484 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40689 0000648D 00000000000000     
 40690 00006494 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40691 0000649D 00000000000000     
 40692 000064A4 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40693 000064AD 00000000000000     
 40694 000064B4 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40695 000064BD 00000000000000     
 40696 000064C4 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40697 000064CD 00000000000000     
 40698 000064D4 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40699 000064DD 00000000000000     
 40700 000064E4 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40701 000064ED 00000000000000     
 40702 000064F4 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40703 000064FD 00000000000000     
 40704 00006504 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40705 0000650D 00000000000000     
 40706 00006514 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40707 0000651D 00000000000000     
 40708 00006524 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40709 0000652D 00000000000000     
 40710 00006534 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40711 0000653D 00000000000000     
 40712 00006544 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40713 0000654D 00000000000000     
 40714 00006554 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40715 0000655D 00000000000000     
 40716 00006564 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40717 0000656D 00000000000000     
 40718 00006574 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 55h, 0AAh
 40719 0000657D 000000000055AA     
 40720                                  mbr_hd3:
 40721 00006584 FA33C08ED0BC007C8B-     	db 0FAh, 33h, 0C0h, 8Eh, 0D0h, 0BCh, 00h, 7Ch, 8Bh, 0F4h, 50h, 07h, 50h, 1Fh, 0FBh, 0FCh
 40722 0000658D F45007501FFBFC     
 40723 00006594 BF0006B90001F2A5EA-     	db 0BFh, 00h, 06h, 0B9h, 00h, 01h, 0F2h, 0A5h, 0EAh, 1Dh, 06h, 00h, 00h, 0BEh, 0BEh, 07h
 40724 0000659D 1D060000BEBE07     
 40725 000065A4 B304803C80740E803C-     	db 0B3h, 04h, 80h, 3Ch,	80h, 74h, 0Eh, 80h, 3Ch, 00h, 75h, 1Ch,	83h, 0C6h, 10h,	0FEh
 40726 000065AD 00751C83C610FE     
 40727 000065B4 CB75EFCD188B148B4C-     	db 0CBh, 75h, 0EFh, 0CDh, 18h, 8Bh, 14h, 8Bh, 4Ch, 02h,	8Bh, 0EEh, 83h,	0C6h, 10h, 0FEh
 40728 000065BD 028BEE83C610FE     
 40729 000065C4 CB741A803C0074F4BE-     	db 0CBh, 74h, 1Ah, 80h,	3Ch, 00h, 74h, 0F4h, 0BEh, 8Bh,	06h, 0ACh, 3Ch,	00h, 74h, 0Bh
 40730 000065CD 8B06AC3C00740B     
 40731 000065D4 56BB0700B40ECD105E-     	db 56h,	0BBh, 07h, 00h,	0B4h, 0Eh, 0CDh, 10h, 5Eh, 0EBh, 0F0h, 0EBh, 0FEh, 0BFh, 05h, 00h
 40732 000065DD EBF0EBFEBF0500     
 40733 000065E4 BB007CB8010257CD13-     	db 0BBh, 00h, 7Ch, 0B8h, 01h, 02h, 57h,	0CDh, 13h, 5Fh,	73h, 0Ch, 33h, 0C0h, 0CDh, 13h
 40734 000065ED 5F730C33C0CD13     
 40735 000065F4 4F75EDBEA306EBD3BE-     	db 4Fh,	75h, 0EDh, 0BEh, 0A3h, 06h, 0EBh, 0D3h,	0BEh, 0C2h, 06h, 0BFh, 0FEh, 7Dh, 81h, 3Dh
 40736 000065FD C206BFFE7D813D     
 40737 00006604 55AA75C78BF5EA007C-     	db 55h,	0AAh, 75h, 0C7h, 8Bh, 0F5h, 0EAh, 00h, 7Ch, 00h, 00h, 49h, 6Eh,	76h, 61h, 6Ch
 40738 0000660D 0000496E76616C     
 40739 00006614 696420706172746974-     	db 69h,	64h, 20h, 70h, 61h, 72h, 74h, 69h, 74h,	69h, 6Fh, 6Eh, 20h, 74h, 61h, 62h
 40740 0000661D 696F6E20746162     
 40741 00006624 6C65004572726F7220-     	db 6Ch,	65h, 00h, 45h, 72h, 72h, 6Fh, 72h, 20h,	6Ch, 6Fh, 61h, 64h, 69h, 6Eh, 67h
 40742 0000662D 6C6F6164696E67     
 40743 00006634 206F7065726174696E-     	db 20h,	6Fh, 70h, 65h, 72h, 61h, 74h, 69h, 6Eh,	67h, 20h, 73h, 79h, 73h, 74h, 65h
 40744 0000663D 67207379737465     
 40745 00006644 6D004D697373696E67-     	db 6Dh,	00h, 4Dh, 69h, 73h, 73h, 69h, 6Eh, 67h,	20h, 6Fh, 70h, 65h, 72h, 61h, 74h
 40746 0000664D 206F7065726174     
 40747 00006654 696E67207379737465-     	db 69h,	6Eh, 67h, 20h, 73h, 79h, 73h, 74h, 65h,	6Dh, 00h, 00h, 00h, 00h, 00h, 00h
 40748 0000665D 6D000000000000     
 40749 00006664 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40750 0000666D 00000000000000     
 40751 00006674 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40752 0000667D 00000000000000     
 40753 00006684 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40754 0000668D 00000000000000     
 40755 00006694 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40756 0000669D 00000000000000     
 40757 000066A4 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40758 000066AD 00000000000000     
 40759 000066B4 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40760 000066BD 00000000000000     
 40761 000066C4 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40762 000066CD 00000000000000     
 40763 000066D4 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40764 000066DD 00000000000000     
 40765 000066E4 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40766 000066ED 00000000000000     
 40767 000066F4 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40768 000066FD 00000000000000     
 40769 00006704 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40770 0000670D 00000000000000     
 40771 00006714 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40772 0000671D 00000000000000     
 40773 00006724 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40774 0000672D 00000000000000     
 40775 00006734 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40776 0000673D 00000000000000     
 40777 00006744 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40778 0000674D 00000000000000     
 40779 00006754 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40780 0000675D 00000000000000     
 40781 00006764 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40782 0000676D 00000000000000     
 40783 00006774 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 55h, 0AAh
 40784 0000677D 000000000055AA     
 40785                                  mbr_5:
 40786 00006784 FA33C08ED0BC007C8B-     	db 0FAh, 33h, 0C0h, 8Eh, 0D0h, 0BCh, 00h, 7Ch, 8Bh, 0F4h, 50h, 07h, 50h, 1Fh, 0FBh, 0FCh
 40787 0000678D F45007501FFBFC     
 40788 00006794 BF0006B90001F2A5EA-     	db 0BFh, 00h, 06h, 0B9h, 00h, 01h, 0F2h, 0A5h, 0EAh, 1Dh, 06h, 00h, 00h, 0BEh, 0BEh, 07h
 40789 0000679D 1D060000BEBE07     
 40790 000067A4 B304803C80740E803C-     	db 0B3h, 04h, 80h, 3Ch,	80h, 74h, 0Eh, 80h, 3Ch, 00h, 75h, 1Ch,	83h, 0C6h, 10h,	0FEh
 40791 000067AD 00751C83C610FE     
 40792 000067B4 CB75EFCD188B148B4C-     	db 0CBh, 75h, 0EFh, 0CDh, 18h, 8Bh, 14h, 8Bh, 4Ch, 02h,	8Bh, 0EEh, 83h,	0C6h, 10h, 0FEh
 40793 000067BD 028BEE83C610FE     
 40794 000067C4 CB741A803C0074F4BE-     	db 0CBh, 74h, 1Ah, 80h,	3Ch, 00h, 74h, 0F4h, 0BEh, 8Bh,	06h, 0ACh, 3Ch,	00h, 74h, 0Bh
 40795 000067CD 8B06AC3C00740B     
 40796 000067D4 56BB0700B40ECD105E-     	db 56h,	0BBh, 07h, 00h,	0B4h, 0Eh, 0CDh, 10h, 5Eh, 0EBh, 0F0h, 0EBh, 0FEh, 0BFh, 05h, 00h
 40797 000067DD EBF0EBFEBF0500     
 40798 000067E4 BB007CB8010257CD13-     	db 0BBh, 00h, 7Ch, 0B8h, 01h, 02h, 57h,	0CDh, 13h, 5Fh,	73h, 0Ch, 33h, 0C0h, 0CDh, 13h
 40799 000067ED 5F730C33C0CD13     
 40800 000067F4 4F75EDBEA306EBD3BE-     	db 4Fh,	75h, 0EDh, 0BEh, 0A3h, 06h, 0EBh, 0D3h,	0BEh, 0C2h, 06h, 0BFh, 0FEh, 7Dh, 81h, 3Dh
 40801 000067FD C206BFFE7D813D     
 40802 00006804 55AA75C78BF5EA007C-     	db 55h,	0AAh, 75h, 0C7h, 8Bh, 0F5h, 0EAh, 00h, 7Ch, 00h, 00h, 49h, 6Eh,	76h, 61h, 6Ch
 40803 0000680D 0000496E76616C     
 40804 00006814 696420706172746974-     	db 69h,	64h, 20h, 70h, 61h, 72h, 74h, 69h, 74h,	69h, 6Fh, 6Eh, 20h, 74h, 61h, 62h
 40805 0000681D 696F6E20746162     
 40806 00006824 6C65004572726F7220-     	db 6Ch,	65h, 00h, 45h, 72h, 72h, 6Fh, 72h, 20h,	6Ch, 6Fh, 61h, 64h, 69h, 6Eh, 67h
 40807 0000682D 6C6F6164696E67     
 40808 00006834 206F7065726174696E-     	db 20h,	6Fh, 70h, 65h, 72h, 61h, 74h, 69h, 6Eh,	67h, 20h, 73h, 79h, 73h, 74h, 65h
 40809 0000683D 67207379737465     
 40810 00006844 6D004D697373696E67-     	db 6Dh,	00h, 4Dh, 69h, 73h, 73h, 69h, 6Eh, 67h,	20h, 6Fh, 70h, 65h, 72h, 61h, 74h
 40811 0000684D 206F7065726174     
 40812 00006854 696E67207379737465-     	db 69h,	6Eh, 67h, 20h, 73h, 79h, 73h, 74h, 65h,	6Dh, 00h, 00h, 00h, 00h, 00h, 00h
 40813 0000685D 6D000000000000     
 40814 00006864 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40815 0000686D 00000000000000     
 40816 00006874 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40817 0000687D 00000000000000     
 40818 00006884 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40819 0000688D 00000000000000     
 40820 00006894 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40821 0000689D 00000000000000     
 40822 000068A4 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40823 000068AD 00000000000000     
 40824 000068B4 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40825 000068BD 00000000000000     
 40826 000068C4 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40827 000068CD 00000000000000     
 40828 000068D4 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40829 000068DD 00000000000000     
 40830 000068E4 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40831 000068ED 00000000000000     
 40832 000068F4 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40833 000068FD 00000000000000     
 40834 00006904 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40835 0000690D 00000000000000     
 40836 00006914 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40837 0000691D 00000000000000     
 40838 00006924 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40839 0000692D 00000000000000     
 40840 00006934 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40841 0000693D 00000000000000     
 40842 00006944 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40843 0000694D 00000000000000     
 40844 00006954 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40845 0000695D 00000000000000     
 40846 00006964 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40847 0000696D 00000000000000     
 40848 00006974 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 55h, 0AAh
 40849 0000697D 000000000055AA     
 40850                                  mbr_6:
 40851 00006984 FA33C08ED0BC007C8B-     	db 0FAh, 33h, 0C0h, 8Eh, 0D0h, 0BCh, 00h, 7Ch, 8Bh, 0F4h, 50h, 07h, 50h, 1Fh, 0FBh, 0FCh
 40852 0000698D F45007501FFBFC     
 40853 00006994 BF0006B90001F2A5EA-     	db 0BFh, 00h, 06h, 0B9h, 00h, 01h, 0F2h, 0A5h, 0EAh, 1Dh, 06h, 00h, 00h, 0BEh, 0BEh, 07h
 40854 0000699D 1D060000BEBE07     
 40855 000069A4 B304803C80740E803C-     	db 0B3h, 04h, 80h, 3Ch,	80h, 74h, 0Eh, 80h, 3Ch, 00h, 75h, 1Ch,	83h, 0C6h, 10h,	0FEh
 40856 000069AD 00751C83C610FE     
 40857 000069B4 CB75EFCD188B148B4C-     	db 0CBh, 75h, 0EFh, 0CDh, 18h, 8Bh, 14h, 8Bh, 4Ch, 02h,	8Bh, 0EEh, 83h,	0C6h, 10h, 0FEh
 40858 000069BD 028BEE83C610FE     
 40859 000069C4 CB741A803C0074F4BE-     	db 0CBh, 74h, 1Ah, 80h,	3Ch, 00h, 74h, 0F4h, 0BEh, 8Bh,	06h, 0ACh, 3Ch,	00h, 74h, 0Bh
 40860 000069CD 8B06AC3C00740B     
 40861 000069D4 56BB0700B40ECD105E-     	db 56h,	0BBh, 07h, 00h,	0B4h, 0Eh, 0CDh, 10h, 5Eh, 0EBh, 0F0h, 0EBh, 0FEh, 0BFh, 05h, 00h
 40862 000069DD EBF0EBFEBF0500     
 40863 000069E4 BB007CB8010257CD13-     	db 0BBh, 00h, 7Ch, 0B8h, 01h, 02h, 57h,	0CDh, 13h, 5Fh,	73h, 0Ch, 33h, 0C0h, 0CDh, 13h
 40864 000069ED 5F730C33C0CD13     
 40865 000069F4 4F75EDBEA306EBD3BE-     	db 4Fh,	75h, 0EDh, 0BEh, 0A3h, 06h, 0EBh, 0D3h,	0BEh, 0C2h, 06h, 0BFh, 0FEh, 7Dh, 81h, 3Dh
 40866 000069FD C206BFFE7D813D     
 40867 00006A04 55AA75C78BF5EA007C-     	db 55h,	0AAh, 75h, 0C7h, 8Bh, 0F5h, 0EAh, 00h, 7Ch, 00h, 00h, 49h, 6Eh,	76h, 61h, 6Ch
 40868 00006A0D 0000496E76616C     
 40869 00006A14 696420706172746974-     	db 69h,	64h, 20h, 70h, 61h, 72h, 74h, 69h, 74h,	69h, 6Fh, 6Eh, 20h, 74h, 61h, 62h
 40870 00006A1D 696F6E20746162     
 40871 00006A24 6C65004572726F7220-     	db 6Ch,	65h, 00h, 45h, 72h, 72h, 6Fh, 72h, 20h,	6Ch, 6Fh, 61h, 64h, 69h, 6Eh, 67h
 40872 00006A2D 6C6F6164696E67     
 40873 00006A34 206F7065726174696E-     	db 20h,	6Fh, 70h, 65h, 72h, 61h, 74h, 69h, 6Eh,	67h, 20h, 73h, 79h, 73h, 74h, 65h
 40874 00006A3D 67207379737465     
 40875 00006A44 6D004D697373696E67-     	db 6Dh,	00h, 4Dh, 69h, 73h, 73h, 69h, 6Eh, 67h,	20h, 6Fh, 70h, 65h, 72h, 61h, 74h
 40876 00006A4D 206F7065726174     
 40877 00006A54 696E67207379737465-     	db 69h,	6Eh, 67h, 20h, 73h, 79h, 73h, 74h, 65h,	6Dh, 00h, 00h, 00h, 00h, 00h, 00h
 40878 00006A5D 6D000000000000     
 40879 00006A64 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40880 00006A6D 00000000000000     
 40881 00006A74 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40882 00006A7D 00000000000000     
 40883 00006A84 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40884 00006A8D 00000000000000     
 40885 00006A94 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40886 00006A9D 00000000000000     
 40887 00006AA4 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40888 00006AAD 00000000000000     
 40889 00006AB4 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40890 00006ABD 00000000000000     
 40891 00006AC4 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40892 00006ACD 00000000000000     
 40893 00006AD4 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40894 00006ADD 00000000000000     
 40895 00006AE4 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40896 00006AED 00000000000000     
 40897 00006AF4 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40898 00006AFD 00000000000000     
 40899 00006B04 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40900 00006B0D 00000000000000     
 40901 00006B14 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40902 00006B1D 00000000000000     
 40903 00006B24 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40904 00006B2D 00000000000000     
 40905 00006B34 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40906 00006B3D 00000000000000     
 40907 00006B44 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40908 00006B4D 00000000000000     
 40909 00006B54 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40910 00006B5D 00000000000000     
 40911 00006B64 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40912 00006B6D 00000000000000     
 40913 00006B74 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 55h, 0AAh
 40914 00006B7D 000000000055AA     
 40915                                  mbr_7:
 40916 00006B84 FA33C08ED0BC007C8B-     	db 0FAh, 33h, 0C0h, 8Eh, 0D0h, 0BCh, 00h, 7Ch, 8Bh, 0F4h, 50h, 07h, 50h, 1Fh, 0FBh, 0FCh
 40917 00006B8D F45007501FFBFC     
 40918 00006B94 BF0006B90001F2A5EA-     	db 0BFh, 00h, 06h, 0B9h, 00h, 01h, 0F2h, 0A5h, 0EAh, 1Dh, 06h, 00h, 00h, 0BEh, 0BEh, 07h
 40919 00006B9D 1D060000BEBE07     
 40920 00006BA4 B304803C80740E803C-     	db 0B3h, 04h, 80h, 3Ch,	80h, 74h, 0Eh, 80h, 3Ch, 00h, 75h, 1Ch,	83h, 0C6h, 10h,	0FEh
 40921 00006BAD 00751C83C610FE     
 40922 00006BB4 CB75EFCD188B148B4C-     	db 0CBh, 75h, 0EFh, 0CDh, 18h, 8Bh, 14h, 8Bh, 4Ch, 02h,	8Bh, 0EEh, 83h,	0C6h, 10h, 0FEh
 40923 00006BBD 028BEE83C610FE     
 40924 00006BC4 CB741A803C0074F4BE-     	db 0CBh, 74h, 1Ah, 80h,	3Ch, 00h, 74h, 0F4h, 0BEh, 8Bh,	06h, 0ACh, 3Ch,	00h, 74h, 0Bh
 40925 00006BCD 8B06AC3C00740B     
 40926 00006BD4 56BB0700B40ECD105E-     	db 56h,	0BBh, 07h, 00h,	0B4h, 0Eh, 0CDh, 10h, 5Eh, 0EBh, 0F0h, 0EBh, 0FEh, 0BFh, 05h, 00h
 40927 00006BDD EBF0EBFEBF0500     
 40928 00006BE4 BB007CB8010257CD13-     	db 0BBh, 00h, 7Ch, 0B8h, 01h, 02h, 57h,	0CDh, 13h, 5Fh,	73h, 0Ch, 33h, 0C0h, 0CDh, 13h
 40929 00006BED 5F730C33C0CD13     
 40930 00006BF4 4F75EDBEA306EBD3BE-     	db 4Fh,	75h, 0EDh, 0BEh, 0A3h, 06h, 0EBh, 0D3h,	0BEh, 0C2h, 06h, 0BFh, 0FEh, 7Dh, 81h, 3Dh
 40931 00006BFD C206BFFE7D813D     
 40932 00006C04 55AA75C78BF5EA007C-     	db 55h,	0AAh, 75h, 0C7h, 8Bh, 0F5h, 0EAh, 00h, 7Ch, 00h, 00h, 49h, 6Eh,	76h, 61h, 6Ch
 40933 00006C0D 0000496E76616C     
 40934 00006C14 696420706172746974-     	db 69h,	64h, 20h, 70h, 61h, 72h, 74h, 69h, 74h,	69h, 6Fh, 6Eh, 20h, 74h, 61h, 62h
 40935 00006C1D 696F6E20746162     
 40936 00006C24 6C65004572726F7220-     	db 6Ch,	65h, 00h, 45h, 72h, 72h, 6Fh, 72h, 20h,	6Ch, 6Fh, 61h, 64h, 69h, 6Eh, 67h
 40937 00006C2D 6C6F6164696E67     
 40938 00006C34 206F7065726174696E-     	db 20h,	6Fh, 70h, 65h, 72h, 61h, 74h, 69h, 6Eh,	67h, 20h, 73h, 79h, 73h, 74h, 65h
 40939 00006C3D 67207379737465     
 40940 00006C44 6D004D697373696E67-     	db 6Dh,	00h, 4Dh, 69h, 73h, 73h, 69h, 6Eh, 67h,	20h, 6Fh, 70h, 65h, 72h, 61h, 74h
 40941 00006C4D 206F7065726174     
 40942 00006C54 696E67207379737465-     	db 69h,	6Eh, 67h, 20h, 73h, 79h, 73h, 74h, 65h,	6Dh, 00h, 00h, 00h, 00h, 00h, 00h
 40943 00006C5D 6D000000000000     
 40944 00006C64 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40945 00006C6D 00000000000000     
 40946 00006C74 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40947 00006C7D 00000000000000     
 40948 00006C84 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40949 00006C8D 00000000000000     
 40950 00006C94 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40951 00006C9D 00000000000000     
 40952 00006CA4 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40953 00006CAD 00000000000000     
 40954 00006CB4 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40955 00006CBD 00000000000000     
 40956 00006CC4 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40957 00006CCD 00000000000000     
 40958 00006CD4 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40959 00006CDD 00000000000000     
 40960 00006CE4 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40961 00006CED 00000000000000     
 40962 00006CF4 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40963 00006CFD 00000000000000     
 40964 00006D04 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40965 00006D0D 00000000000000     
 40966 00006D14 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40967 00006D1D 00000000000000     
 40968 00006D24 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40969 00006D2D 00000000000000     
 40970 00006D34 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40971 00006D3D 00000000000000     
 40972 00006D44 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40973 00006D4D 00000000000000     
 40974 00006D54 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40975 00006D5D 00000000000000     
 40976 00006D64 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40977 00006D6D 00000000000000     
 40978 00006D74 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 55h, 0AAh
 40979 00006D7D 000000000055AA     
 40980                                  
 40981                                  mbr_8:
 40982 00006D84 FA33C08ED0BC007C8B-     	db 0FAh, 33h, 0C0h, 8Eh, 0D0h, 0BCh, 00h, 7Ch, 8Bh, 0F4h, 50h, 07h, 50h, 1Fh, 0FBh, 0FCh
 40983 00006D8D F45007501FFBFC     
 40984 00006D94 BF0006B90001F2A5EA-     	db 0BFh, 00h, 06h, 0B9h, 00h, 01h, 0F2h, 0A5h, 0EAh, 1Dh, 06h, 00h, 00h, 0BEh, 0BEh, 07h
 40985 00006D9D 1D060000BEBE07     
 40986 00006DA4 B304803C80740E803C-     	db 0B3h, 04h, 80h, 3Ch,	80h, 74h, 0Eh, 80h, 3Ch, 00h, 75h, 1Ch,	83h, 0C6h, 10h,	0FEh
 40987 00006DAD 00751C83C610FE     
 40988 00006DB4 CB75EFCD188B148B4C-     	db 0CBh, 75h, 0EFh, 0CDh, 18h, 8Bh, 14h, 8Bh, 4Ch, 02h,	8Bh, 0EEh, 83h,	0C6h, 10h, 0FEh
 40989 00006DBD 028BEE83C610FE     
 40990 00006DC4 CB741A803C0074F4BE-     	db 0CBh, 74h, 1Ah, 80h,	3Ch, 00h, 74h, 0F4h, 0BEh, 8Bh,	06h, 0ACh, 3Ch,	00h, 74h, 0Bh
 40991 00006DCD 8B06AC3C00740B     
 40992 00006DD4 56BB0700B40ECD105E-     	db 56h,	0BBh, 07h, 00h,	0B4h, 0Eh, 0CDh, 10h, 5Eh, 0EBh, 0F0h, 0EBh, 0FEh, 0BFh, 05h, 00h
 40993 00006DDD EBF0EBFEBF0500     
 40994 00006DE4 BB007CB8010257CD13-     	db 0BBh, 00h, 7Ch, 0B8h, 01h, 02h, 57h,	0CDh, 13h, 5Fh,	73h, 0Ch, 33h, 0C0h, 0CDh, 13h
 40995 00006DED 5F730C33C0CD13     
 40996 00006DF4 4F75EDBEA306EBD3BE-     	db 4Fh,	75h, 0EDh, 0BEh, 0A3h, 06h, 0EBh, 0D3h,	0BEh, 0C2h, 06h, 0BFh, 0FEh, 7Dh, 81h, 3Dh
 40997 00006DFD C206BFFE7D813D     
 40998 00006E04 55AA75C78BF5EA007C-     	db 55h,	0AAh, 75h, 0C7h, 8Bh, 0F5h, 0EAh, 00h, 7Ch, 00h, 00h, 49h, 6Eh,	76h, 61h, 6Ch
 40999 00006E0D 0000496E76616C     
 41000 00006E14 696420706172746974-     	db 69h,	64h, 20h, 70h, 61h, 72h, 74h, 69h, 74h,	69h, 6Fh, 6Eh, 20h, 74h, 61h, 62h
 41001 00006E1D 696F6E20746162     
 41002 00006E24 6C65004572726F7220-     	db 6Ch,	65h, 00h, 45h, 72h, 72h, 6Fh, 72h, 20h,	6Ch, 6Fh, 61h, 64h, 69h, 6Eh, 67h
 41003 00006E2D 6C6F6164696E67     
 41004 00006E34 206F7065726174696E-     	db 20h,	6Fh, 70h, 65h, 72h, 61h, 74h, 69h, 6Eh,	67h, 20h, 73h, 79h, 73h, 74h, 65h
 41005 00006E3D 67207379737465     
 41006 00006E44 6D004D697373696E67-     	db 6Dh,	00h, 4Dh, 69h, 73h, 73h, 69h, 6Eh, 67h,	20h, 6Fh, 70h, 65h, 72h, 61h, 74h
 41007 00006E4D 206F7065726174     
 41008 00006E54 696E67207379737465-     	db 69h,	6Eh, 67h, 20h, 73h, 79h, 73h, 74h, 65h,	6Dh, 00h, 00h, 00h, 00h, 00h, 00h
 41009 00006E5D 6D000000000000     
 41010 00006E64 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 41011 00006E6D 00000000000000     
 41012 00006E74 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 41013 00006E7D 00000000000000     
 41014 00006E84 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 41015 00006E8D 00000000000000     
 41016 00006E94 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 41017 00006E9D 00000000000000     
 41018 00006EA4 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 41019 00006EAD 00000000000000     
 41020 00006EB4 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 41021 00006EBD 00000000000000     
 41022 00006EC4 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 41023 00006ECD 00000000000000     
 41024 00006ED4 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 41025 00006EDD 00000000000000     
 41026 00006EE4 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 41027 00006EED 00000000000000     
 41028 00006EF4 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 41029 00006EFD 00000000000000     
 41030 00006F04 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 41031 00006F0D 00000000000000     
 41032 00006F14 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 41033 00006F1D 00000000000000     
 41034 00006F24 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 41035 00006F2D 00000000000000     
 41036 00006F34 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 41037 00006F3D 00000000000000     
 41038 00006F44 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 41039 00006F4D 00000000000000     
 41040 00006F54 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 41041 00006F5D 00000000000000     
 41042 00006F64 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 41043 00006F6D 00000000000000     
 41044 00006F74 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 55h, 0AAh
 41045 00006F7D 000000000055AA     
 41046                                  
 41047                                  numinmsg_format:
 41048                                  		;db '%4.1d',0
 41049                                  glni_num_format:      ; 17/01/2019		
 41050                                  idc_tot_mb_format:
 41051                                  idc_def_entry_format: ; 14/01/2019
 41052                                  ld_p_size_format:
 41053                                  nd_p_size_format:
 41054                                  disk_size_format:
 41055                                  v_psize_format:	; 23/01/2019
 41056                                  v_mbytes_format:
 41057                                  ecp_size_format: ; 25/01/2019
 41058                                  ecp_mb_format:
 41059 00006F84 25342E316400            p_size_format:	db '%4.1d',0
 41060                                  v_mb_percent_format: ; 23/01/2019
 41061                                  ecp_mb_pcent_format: ; 25/01/2019
 41062                                  idc_mb_pcent_format:
 41063 00006F8A 25342E316425332E31-     		db '%4.1d%3.1d%%',0
 41064 00006F93 64252500           
 41065                                  v_percent_format:
 41066                                  ecp_pcent_format:
 41067 00006F97 25332E3164252500        percent_format:	db '%3.1d%%',0
 41068                                  ;v_percent_format:db '%3.1d%%',0
 41069 00006F9F 2E222F5C5B5D3A7C3C-     invstrchars:	db '."/\[]:|<>+=;,',0
 41070 00006FA8 3E2B3D3B2C00       
 41071 00006FAE 00                      		db 0
 41072 00006FAF 202000                  twospace:	db '  ',0
 41073 00006FB2 2563256300              twochars:	db '%c%c',0
 41074                                  ptbl_row_format:
 41075 00006FB7 252D322E3273256325-     		db '%-2.2s%c%c%-7.7s%-11.11s%4.1d%-8.8s%3.1d%%',0
 41076 00006FC0 63252D372E3773252D-
 41077 00006FC9 31312E31317325342E-
 41078 00006FD2 3164252D382E387325-
 41079 00006FDB 332E3164252500     
 41080                                  align 2
 41081 00006FE2 25632563252D31312E-     eptbl_row_format:  db '%c%c%-11.11s%4.1d%-8.8s%3.1d%%',0
 41082 00006FEB 31317325342E316425-
 41083 00006FF4 2D382E387325332E31-
 41084 00006FFD 64252500           
 41085 00007001 25312E306425632563-     cd_pt_row_format:  db '%1.0d%c%c%4.1d%4.1d%3.1d%%',0
 41086 0000700A 25342E316425342E31-
 41087 00007013 6425332E3164252500 
 41088 0000701C 25632563256325342E-     drv_mb_row_format: db '%c%c%c%4.1d%8c',0
 41089 00007025 316425386300       
 41090 0000702B 25632563256325342E-     cdrv_mb_format:	   db '%c%c%c%4.1d%8c',0
 41091 00007034 316425386300       
 41092 0000703A 25312E306425312E30-     cdrive_format:	   db '%1.0d%1.0d',0
 41093 00007043 6400               
 41094                                  
 41095 00007045 554E4B4E4F574E2000      NO_FORMAT:	db 'UNKNOWN ',0
 41096 0000704E 00                      NO_VOLUME:	db 0
 41097 0000704F 554E4B4E4F574E2000      _NOFORMAT:	db 'UNKNOWN ',0
 41098 00007058 00                      _NOVOLUME:	db 0
 41099 00007059 2F50524900              PRI:		db '/PRI',0
 41100 0000705E 2F45585400              EXT:		db '/EXT',0
 41101 00007063 2F4C4F4700              LOG:		db '/LOG',0
 41102 00007068 2F5100                  QUIET:		db '/Q',0
 41103 0000706B 2F53544154555300        STATUS:		db '/STATUS',0
 41104 00007073 2F3F00                  OPTIONS:	db '/?',0
 41105 00007076 2F4D425200              MBR:		db '/MBR',0
 41106 0000707B 3A5C3F3F3F3F3F3F3F-     FILE_NAME:	db ':\????????.???',0
 41107 00007084 3F2E3F3F3F00       
 41108                                  
 41109                                  align 2
 41110                                  
 41111 0000708A [E6CC]                  pinsert:	dw insert
 41112 0000708C 00000000                NOVAL:		dd 0
 41113                                  
 41114 00007090 0000                    _$P_ordinal:	dw 0
 41115 00007092 0000                    _$P_RC:		dw 0
 41116 00007094 0000                    _$P_SI_Save:	dw 0
 41117 00007096 0000                    _$P_DX:		dw 0
 41118 00007098 00                      _$P_Terminator:	db 0
 41119 00007099 0000                    _$P_DBCSEV_OFF:	dw 0
 41120 0000709B 0000                    _$P_DBCSEV_SEG:	dw 0
 41121                                  _$P_Flags:
 41122 0000709D 00                      _$P_Flags1:	db 0
 41123 0000709E 00                      _$P_Flags2:	db 0
 41124 0000709F 0000                    _$P_SaveSI_Cmpx: dw 0
 41125 000070A1 0000                    _$P_KEYorSW_Ptr: dw 0
 41126 000070A3 0000                    _$P_Save_EOB:	dw 0
 41127 000070A5 0000                    _$P_Found_SYNONYM: dw 0
 41128 000070A7 00<rept>                _$P_STRING_BUF:	times 128 db 0		; Pick a operand from command line
 41129 00007127 00                      _$P_Got_Time:	db 0
 41130 00007128 FFFF                    _$P_Country_Info: dw _$P_NeedToBeRead ; 0FFFFh
 41131                                  		;times 32 db 0
 41132 0000712A 00<rept>                		times _$P_CDI.size - 2 db 0
 41133 00007145 0000                    _$P_1st_Val:	dw 0
 41134 00007147 0000                    _$P_2nd_Val:	dw 0
 41135 00007149 0000                    _$P_3rd_Val:	dw 0
 41136 0000714B 0000                    _$P_4th_Val:	dw 0
 41137 0000714D FF                      _$P_Char_CAP_Ptr: db 0FFh
 41138 0000714E 0000                    		dw 0
 41139 00007150 0000                    		dw 0
 41140 00007152 00                      _$P_err_flag:	db 0
 41141                                  
 41142                                  ; 15/12/2018
 41143                                  
 41144                                  ;/************************************************************************/
 41145                                  ;/*  FDISK MESSAGES                                                      */
 41146                                  ;/*                                                                      */
 41147                                  ;/* Portions of the screen that are handled in the msg are indicated on  */
 41148                                  ;/* the listing of the screen with the message name given. If the text   */
 41149                                  ;/* message is defined in another screen, then the name is followed by   */
 41150                                  ;/* a "#" character                                                      */
 41151                                  ;/*                                                                      */
 41152                                  ;/* NOTE TO TRANSLATORS                                                  */
 41153                                  ;/* The characters inside the <> and the  are control characters and   */
 41154                                  ;/* should not be translated. The Control characters are defined as      */
 41155                                  ;/* follows:                                                             */
 41156                                  ;/*                                                                      */
 41157                                  ;/* <H> - Highlight the following text                                   */
 41158                                  ;/* <R> - Regular text                                                   */
 41159                                  ;/* <U> - Underline the following text                                   */
 41160                                  ;/* <B> - Blink the following text                                       */
 41161                                  ;/* <O> - Turn off Blink                                                 */
 41162                                  ;/* <Y> - Print YES character, as set by define                          */
 41163                                  ;/* <N> - Print NO character, as set by define                           */
 41164                                  ;/* <W> - Sound the beep                                                 */
 41165                                  ;/* <S> - Save cursor position for later use                             */
 41166                                  ;/* <G> - Cursor position left justified and regular proceed to right    */
 41167                                  ;/* <C> - Clear the screen out from control char to end of line          */
 41168                                  ;/* <I> - Insert character from Insert[] string. This string must be set */
 41169                                  ;/*       up prior to displaying the message. The first <I> will insert  */
 41170                                  ;/*       Insert[0], the second Insert[1], etc....This will move the     */
 41171                                  ;/*       cursor one postition. The Insert%% string will be initialized  */
 41172                                  ;/*                                                                      */
 41173                                  ;/*  Multiple control characters can be between the <>.                  */
 41174                                  ;/*                                                                      */
 41175                                  ;/*  The  indicates Row and column for the text and has the format of  */
 41176                                  ;/*  rrcc where the numbers are decimal and zero based .first row/col  */
 41177                                  ;/*  is 00. The numbers are in decimal, and must be 2 characters, which  */
 41178                                  ;/*  means rows/cols 0-9 should be listed as 00-09. For example, the 5th */
 41179                                  ;/*  row, 3rd column on the screen would be listed as 0402.            */
 41180                                  ;/*                                                                      */
 41181                                  ;/*  The column number is always the column desired. The row number is   */
 41182                                  ;/*  an offset from the previous row. For example, if the text just      */
 41183                                  ;/*  printed is on row 6, and the next text should be printed 2 rows     */
 41184                                  ;/*  down in column 0, then the control strin would be 0201. The first */
 41185                                  ;/*  row specified in the message is assumed to be based off of row 0,   */
 41186                                  ;/*  it would actually specify the actual row for the start of the msg   */
 41187                                  ;/*  to be printed.                                                      */
 41188                                  ;/*                                                                      */
 41189                                  ;/************************************************************************/
 41190                                  
 41191                                  ; 01/12/2018
 41192                                  ; FORMATTED MENU TEXT
 41193                                  
 41194 00007153 063030303406            menu_1:		db 6,'0004',6
 41195 00007159 3C523E202020202020-     		db '<R>                           PC DOS Version 7.0 '
 41196 00007162 202020202020202020-
 41197 0000716B 202020202020202020-
 41198 00007174 202020504320444F53-
 41199 0000717D 2056657273696F6E20-
 41200 00007186 372E3020           
 41201 0000718A 063031303406            		db 6,'0104',6
 41202 00007190 3C523E202020202020-     		db '<R>                         Fixed Disk Setup Program '
 41203 00007199 202020202020202020-
 41204 000071A2 202020202020202020-
 41205 000071AB 204669786564204469-
 41206 000071B4 736B20536574757020-
 41207 000071BD 50726F6772616D20   
 41208 000071C5 063031303406            		db 6,'0104',6
 41209 000071CB 3C523E202020202020-     		db '<R>                Copyright (c) IBM Corporation 1983 - 1994',0
 41210 000071D4 202020202020202020-
 41211 000071DD 20436F707972696768-
 41212 000071E6 74202863292049424D-
 41213 000071EF 20436F72706F726174-
 41214 000071F8 696F6E203139383320-
 41215 00007201 2D203139393400     
 41216 00007208 063034303406            menu_2:		db 6,'0404',6
 41217 0000720E 3C483E202020202020-     		db '<H>                             FDISK Options '
 41218 00007217 202020202020202020-
 41219 00007220 202020202020202020-
 41220 00007229 202020202046444953-
 41221 00007232 4B204F7074696F6E73-
 41222 0000723B 20                 
 41223 0000723C 063036303406            		db 6,'0604',6
 41224 00007242 3C483E312E203C523E-     		db '<H>1. <R>Create DOS partition or Logical DOS Drive '
 41225 0000724B 43726561746520444F-
 41226 00007254 532070617274697469-
 41227 0000725D 6F6E206F72204C6F67-
 41228 00007266 6963616C20444F5320-
 41229 0000726F 447269766520       
 41230 00007275 063031303406            		db 6,'0104',6
 41231 0000727B 3C483E322E203C523E-     		db '<H>2. <R>Set active partition '
 41232 00007284 536574206163746976-
 41233 0000728D 652070617274697469-
 41234 00007296 6F6E20             
 41235 00007299 063031303406            		db 6,'0104',6
 41236 0000729F 3C483E332E203C523E-     		db '<H>3. <R>Delete partition or Logical DOS Drive '
 41237 000072A8 44656C657465207061-
 41238 000072B1 72746974696F6E206F-
 41239 000072BA 72204C6F676963616C-
 41240 000072C3 20444F532044726976-
 41241 000072CC 6520               
 41242 000072CE 063031303406            		db 6,'0104',6
 41243 000072D4 3C483E342E203C523E-     		db '<H>4. <R>Display partition information '
 41244 000072DD 446973706C61792070-
 41245 000072E6 6172746974696F6E20-
 41246 000072EF 696E666F726D617469-
 41247 000072F8 6F6E20             
 41248 000072FB 063131303406            		db 6,'1104',6
 41249 00007301 3C523E507265737320-     		db '<R>Press <H>Esc<R> to exit FDISK',0
 41250 0000730A 3C483E4573633C523E-
 41251 00007313 20746F206578697420-
 41252 0000731C 464449534B00       
 41253 00007322 063038303406            menu_3:		db 6,'0804',6
 41254 00007328 3C523E43686F6F7365-     		db '<R>Choose one of the following:',0
 41255 00007331 206F6E65206F662074-
 41256 0000733A 686520666F6C6C6F77-
 41257 00007343 696E673A00         
 41258 00007348 063134303406            menu_4:		db 6,'1404',6
 41259 0000734E 3C483E352E203C523E-     		db '<H>5. <R>Change current fixed disk drive',0
 41260 00007357 4368616E6765206375-
 41261 00007360 7272656E7420666978-
 41262 00007369 6564206469736B2064-
 41263 00007372 7269766500         
 41264 00007377 063036303406            menu_5:		db 6,'0604',6
 41265 0000737D 3C523E43757272656E-     		db '<R>Current fixed disk drive: <H><I>',0
 41266 00007386 742066697865642064-
 41267 0000738F 69736B206472697665-
 41268 00007398 3A203C483E3C493E00 
 41269 000073A1 063230303406            menu_6:		db 6,'2004',6
 41270 000073A7 3C483E5741524E494E-     		db '<H>WARNING! <R>No partitions are set active - disk 1 is not startable unless '
 41271 000073B0 4721203C523E4E6F20-
 41272 000073B9 706172746974696F6E-
 41273 000073C2 732061726520736574-
 41274 000073CB 20616374697665202D-
 41275 000073D4 206469736B20312069-
 41276 000073DD 73206E6F7420737461-
 41277 000073E6 727461626C6520756E-
 41278 000073EF 6C65737320         
 41279 000073F4 063031303406            		db 6,'0104',6
 41280 000073FA 3C523E612070617274-     		db '<R>a partition is set active',0
 41281 00007403 6974696F6E20697320-
 41282 0000740C 736574206163746976-
 41283 00007415 6500               
 41284 00007417 063137303406            menu_7:		db 6,'1704',6
 41285 0000741D 3C523E456E74657220-     		db '<R>Enter choice: <H>[<S> ]',0
 41286 00007426 63686F6963653A203C-
 41287 0000742F 483E5B3C533E205D00 
 41288 00007438 063034303406            menu_8:		db 6,'0404',6
 41289 0000743E 3C483E202020202020-     		db '<H>                Create DOS Partition or Logical DOS Drive',0
 41290 00007447 202020202020202020-
 41291 00007450 204372656174652044-
 41292 00007459 4F5320506172746974-
 41293 00007462 696F6E206F72204C6F-
 41294 0000746B 676963616C20444F53-
 41295 00007474 20447269766500     
 41296 0000747B 063130303406            menu_9:		db 6,'1004',6
 41297 00007481 3C483E312E203C523E-     		db '<H>1. <R>Create Primary DOS Partition '
 41298 0000748A 437265617465205072-
 41299 00007493 696D61727920444F53-
 41300 0000749C 20506172746974696F-
 41301 000074A5 6E20               
 41302 000074A7 063031303406            		db 6,'0104',6
 41303 000074AD 3C483E322E203C523E-     		db '<H>2. <R>Create Extended DOS Partition',0
 41304 000074B6 437265617465204578-
 41305 000074BF 74656E64656420444F-
 41306 000074C8 532050617274697469-
 41307 000074D1 6F6E00             
 41308 000074D4 063132303406            menu_10:	db 6,'1204',6
 41309 000074DA 3C483E332E203C523E-     		db '<H>3. <R>Create Logical DOS Drive(s) in the Extended DOS Partition',0
 41310 000074E3 437265617465204C6F-
 41311 000074EC 676963616C20444F53-
 41312 000074F5 204472697665287329-
 41313 000074FE 20696E207468652045-
 41314 00007507 7874656E6465642044-
 41315 00007510 4F5320506172746974-
 41316 00007519 696F6E00           
 41317 0000751D 063234303406            menu_11:	db 6,'2404',6
 41318 00007523 3C523E507265737320-     		db '<R>Press <H>Esc<R> to return to FDISK Options',0
 41319 0000752C 3C483E4573633C523E-
 41320 00007535 20746F207265747572-
 41321 0000753E 6E20746F2046444953-
 41322 00007547 4B204F7074696F6E73-
 41323 00007550 00                 
 41324 00007551 063034303406            menu_12:	db 6,'0404',6
 41325 00007557 3C483E202020202020-     		db '<H>                      Create Primary DOS Partition',0
 41326 00007560 202020202020202020-
 41327 00007569 202020202020204372-
 41328 00007572 65617465205072696D-
 41329 0000757B 61727920444F532050-
 41330 00007584 6172746974696F6E00 
 41331 0000758D 063038303406            menu_13:	db 6,'0804',6
 41332 00007593 3C523E446F20796F75-     		db '<R>Do you wish to use the maximum available size for a Primary DOS Partition '
 41333 0000759C 207769736820746F20-
 41334 000075A5 75736520746865206D-
 41335 000075AE 6178696D756D206176-
 41336 000075B7 61696C61626C652073-
 41337 000075C0 697A6520666F722061-
 41338 000075C9 205072696D61727920-
 41339 000075D2 444F53205061727469-
 41340 000075DB 74696F6E20         
 41341 000075E0 063031303406            		db 6,'0104',6
 41342 000075E6 3C523E616E64206D61-     		db '<R>and make the partition active (<Y>/<N>).....................? <H>[<S> ]',0
 41343 000075EF 6B6520746865207061-
 41344 000075F8 72746974696F6E2061-
 41345 00007601 637469766520283C59-
 41346 0000760A 3E2F3C4E3E292E2E2E-
 41347 00007613 2E2E2E2E2E2E2E2E2E-
 41348 0000761C 2E2E2E2E2E2E2E2E2E-
 41349 00007625 3F203C483E5B3C533E-
 41350 0000762E 205D00             
 41351 00007631 063038303406            menu_45:	db 6,'0804',6
 41352 00007637 3C523E446F20796F75-     		db '<R>Do you wish to use the maximum available size for a Primary DOS Partition '
 41353 00007640 207769736820746F20-
 41354 00007649 75736520746865206D-
 41355 00007652 6178696D756D206176-
 41356 0000765B 61696C61626C652073-
 41357 00007664 697A6520666F722061-
 41358 0000766D 205072696D61727920-
 41359 00007676 444F53205061727469-
 41360 0000767F 74696F6E20         
 41361 00007684 063031303406            		db 6,'0104',6
 41362 0000768A 3C523E283C593E2F3C-     		db '<R>(<Y>/<N>)...................................................? '
 41363 00007693 4E3E292E2E2E2E2E2E-
 41364 0000769C 2E2E2E2E2E2E2E2E2E-
 41365 000076A5 2E2E2E2E2E2E2E2E2E-
 41366 000076AE 2E2E2E2E2E2E2E2E2E-
 41367 000076B7 2E2E2E2E2E2E2E2E2E-
 41368 000076C0 2E2E2E2E2E2E2E2E2E-
 41369 000076C9 3F20               
 41370 000076CB 3C483E5B3C533E205D-     		db '<H>[<S> ]',0
 41371 000076D4 00                 
 41372 000076D5 063038303406            menu_14:	db 6,'0804',6
 41373 000076DB 3C523E506172746974-     		db '<R>Partition  Status   Type    Volume Label  Mbytes   System   Usage '
 41374 000076E4 696F6E202053746174-
 41375 000076ED 757320202054797065-
 41376 000076F6 20202020566F6C756D-
 41377 000076FF 65204C6162656C2020-
 41378 00007708 4D6279746573202020-
 41379 00007711 53797374656D202020-
 41380 0000771A 557361676520       
 41381 00007720 063031303406            		db 6,'0104',6
 41382 00007726 3C523E203C49493E20-     		db '<R> <II> <HI>         <RI>    <IIIIIII>   <IIIIIIIIIII>   <IIII> '
 41383 0000772F 3C48493E2020202020-
 41384 00007738 202020203C52493E20-
 41385 00007741 2020203C4949494949-
 41386 0000774A 49493E2020203C4949-
 41387 00007753 494949494949494949-
 41388 0000775C 3E2020203C49494949-
 41389 00007765 3E20               
 41390 00007767 20203C494949494949-     		db '  <IIIIIIII>   <IIII> '
 41391 00007770 49493E2020203C4949-
 41392 00007779 49493E20           
 41393 0000777D 063031303406            		db 6,'0104',6
 41394 00007783 3C523E203C49493E20-     		db '<R> <II> <HI>         <RI>    <IIIIIII>   <IIIIIIIIIII>   <IIII> '
 41395 0000778C 3C48493E2020202020-
 41396 00007795 202020203C52493E20-
 41397 0000779E 2020203C4949494949-
 41398 000077A7 49493E2020203C4949-
 41399 000077B0 494949494949494949-
 41400 000077B9 3E2020203C49494949-
 41401 000077C2 3E20               
 41402 000077C4 20203C494949494949-     		db '  <IIIIIIII>   <IIII> '
 41403 000077CD 49493E2020203C4949-
 41404 000077D6 49493E20           
 41405 000077DA 063031303406            		db 6,'0104',6
 41406 000077E0 3C523E203C49493E20-     		db '<R> <II> <HI>         <RI>    <IIIIIII>   <IIIIIIIIIII>   <IIII> '
 41407 000077E9 3C48493E2020202020-
 41408 000077F2 202020203C52493E20-
 41409 000077FB 2020203C4949494949-
 41410 00007804 49493E2020203C4949-
 41411 0000780D 494949494949494949-
 41412 00007816 3E2020203C49494949-
 41413 0000781F 3E20               
 41414 00007821 20203C494949494949-     		db '  <IIIIIIII>   <IIII> '
 41415 0000782A 49493E2020203C4949-
 41416 00007833 49493E20           
 41417 00007837 063031303406            		db 6,'0104',6
 41418 0000783D 3C523E203C49493E20-     		db '<R> <II> <HI>         <RI>    <IIIIIII>   <IIIIIIIIIII>   <IIII> '
 41419 00007846 3C48493E2020202020-
 41420 0000784F 202020203C52493E20-
 41421 00007858 2020203C4949494949-
 41422 00007861 49493E2020203C4949-
 41423 0000786A 494949494949494949-
 41424 00007873 3E2020203C49494949-
 41425 0000787C 3E20               
 41426 0000787E 20203C494949494949-     		db '  <IIIIIIII>   <IIII>'
 41427 00007887 49493E2020203C4949-
 41428 00007890 49493E             
 41429 00007893 00                      		db 0
 41430 00007894 063134303406            menu_15:	db 6,'1404',6
 41431 0000789A 3C523E546F74616C20-     		db '<R>Total disk space is <HIIIIR> Mbytes (1 Mbyte = 1048576 bytes)',0
 41432 000078A3 6469736B2073706163-
 41433 000078AC 65206973203C484949-
 41434 000078B5 4949523E204D627974-
 41435 000078BE 6573202831204D6279-
 41436 000078C7 7465203D2031303438-
 41437 000078D0 353736206279746573-
 41438 000078D9 2900               
 41439 000078DB 063135303406            menu_16:	db 6,'1504',6
 41440 000078E1 3C52433E4D6178696D-     		db '<RC>Maximum space available for partition is <HIIIIR> Mbytes (<HIIIIR>)',0
 41441 000078EA 756D20737061636520-
 41442 000078F3 617661696C61626C65-
 41443 000078FC 20666F722070617274-
 41444 00007905 6974696F6E20697320-
 41445 0000790E 3C4849494949523E20-
 41446 00007917 4D627974657320283C-
 41447 00007920 4849494949523E2900 
 41448 00007929 063138303406            menu_39:	db 6,'1804',6
 41449 0000792F 3C52433E456E746572-     		db '<RC>Enter partition size in Mbytes or percent of disk space (%) to '
 41450 00007938 20706172746974696F-
 41451 00007941 6E2073697A6520696E-
 41452 0000794A 204D6279746573206F-
 41453 00007953 722070657263656E74-
 41454 0000795C 206F66206469736B20-
 41455 00007965 737061636520282529-
 41456 0000796E 20746F20           
 41457 00007972 063031303406            		db 6,'0104',6
 41458 00007978 3C52433E6372656174-     		db '<RC>create a Primary DOS Partition...............................'
 41459 00007981 652061205072696D61-
 41460 0000798A 727920444F53205061-
 41461 00007993 72746974696F6E2E2E-
 41462 0000799C 2E2E2E2E2E2E2E2E2E-
 41463 000079A5 2E2E2E2E2E2E2E2E2E-
 41464 000079AE 2E2E2E2E2E2E2E2E2E-
 41465 000079B7 2E2E               
 41466 000079B9 2E2E3A203C483E5B3C-     		db '..: <H>[<IIISI>]',0
 41467 000079C2 49494953493E5D00   
 41468 000079CA 063034303406            menu_17:	db 6,'0404',6
 41469 000079D0 3C483E202020202020-     		db '<H>                      Create Extended DOS Partition',0
 41470 000079D9 202020202020202020-
 41471 000079E2 202020202020204372-
 41472 000079EB 656174652045787465-
 41473 000079F4 6E64656420444F5320-
 41474 000079FD 506172746974696F6E-
 41475 00007A06 00                 
 41476 00007A07 063138303406            menu_42:	db 6,'1804',6
 41477 00007A0D 3C52433E456E746572-     		db '<RC>Enter partition size in Mbytes or percent of disk space (%) to '
 41478 00007A16 20706172746974696F-
 41479 00007A1F 6E2073697A6520696E-
 41480 00007A28 204D6279746573206F-
 41481 00007A31 722070657263656E74-
 41482 00007A3A 206F66206469736B20-
 41483 00007A43 737061636520282529-
 41484 00007A4C 20746F20           
 41485 00007A50 063031303406            		db 6,'0104',6
 41486 00007A56 3C52433E6372656174-     		db '<RC>create an Extended DOS Partition..............................: <H>[<IIISI>]',0
 41487 00007A5F 6520616E2045787465-
 41488 00007A68 6E64656420444F5320-
 41489 00007A71 506172746974696F6E-
 41490 00007A7A 2E2E2E2E2E2E2E2E2E-
 41491 00007A83 2E2E2E2E2E2E2E2E2E-
 41492 00007A8C 2E2E2E2E2E2E2E2E2E-
 41493 00007A95 2E2E2E3A203C483E5B-
 41494 00007A9E 3C49494953493E5D00 
 41495 00007AA7 063234303406            menu_46:	db 6,'2404',6
 41496 00007AAD 3C523E507265737320-     		db '<R>Press <H>Esc<R> to continue<S>',0
 41497 00007AB6 3C483E4573633C523E-
 41498 00007ABF 20746F20636F6E7469-
 41499 00007AC8 6E75653C533E00     
 41500 00007ACF 063031303406            menu_18:	db 6,'0104',6
 41501 00007AD5 3C48433E2020202020-     		db '<HC>       Create Logical DOS Drive(s) in the Extended DOS Partition',0
 41502 00007ADE 202043726561746520-
 41503 00007AE7 4C6F676963616C2044-
 41504 00007AF0 4F5320447269766528-
 41505 00007AF9 732920696E20746865-
 41506 00007B02 20457874656E646564-
 41507 00007B0B 20444F532050617274-
 41508 00007B14 6974696F6E00       
 41509 00007B1A 063033303006            menu_19:	db 6,'0300',6
 41510 00007B20 3C523E44727620566F-     		db '<R>Drv Volume Label  Mbytes  System  Usage'
 41511 00007B29 6C756D65204C616265-
 41512 00007B32 6C20204D6279746573-
 41513 00007B3B 202053797374656D20-
 41514 00007B44 205573616765       
 41515 00007B4A 063031303006            		db 6,'0100',6
 41516 00007B50 3C483E3C49493E2020-     		db '<H><II>  <RIIIIIIIIIII>    <IIII>  <IIIIIIII>  <IIII>'
 41517 00007B59 3C5249494949494949-
 41518 00007B62 494949493E20202020-
 41519 00007B6B 3C494949493E20203C-
 41520 00007B74 49494949494949493E-
 41521 00007B7D 20203C494949493E   
 41522 00007B85 063031303006            		db 6,'0100',6
 41523 00007B8B 3C483E3C49493E2020-     		db '<H><II>  <RIIIIIIIIIII>    <IIII>  <IIIIIIII>  <IIII>'
 41524 00007B94 3C5249494949494949-
 41525 00007B9D 494949493E20202020-
 41526 00007BA6 3C494949493E20203C-
 41527 00007BAF 49494949494949493E-
 41528 00007BB8 20203C494949493E   
 41529 00007BC0 063031303006            		db 6,'0100',6
 41530 00007BC6 3C483E3C49493E2020-     		db '<H><II>  <RIIIIIIIIIII>    <IIII>  <IIIIIIII>  <IIII>'
 41531 00007BCF 3C5249494949494949-
 41532 00007BD8 494949493E20202020-
 41533 00007BE1 3C494949493E20203C-
 41534 00007BEA 49494949494949493E-
 41535 00007BF3 20203C494949493E   
 41536 00007BFB 063031303006            		db 6,'0100',6
 41537 00007C01 3C483E3C49493E2020-     		db '<H><II>  <RIIIIIIIIIII>    <IIII>  <IIIIIIII>  <IIII>'
 41538 00007C0A 3C5249494949494949-
 41539 00007C13 494949493E20202020-
 41540 00007C1C 3C494949493E20203C-
 41541 00007C25 49494949494949493E-
 41542 00007C2E 20203C494949493E   
 41543 00007C36 063031303006            		db 6,'0100',6
 41544 00007C3C 3C483E3C49493E2020-     		db '<H><II>  <RIIIIIIIIIII>    <IIII>  <IIIIIIII>  <IIII>'
 41545 00007C45 3C5249494949494949-
 41546 00007C4E 494949493E20202020-
 41547 00007C57 3C494949493E20203C-
 41548 00007C60 49494949494949493E-
 41549 00007C69 20203C494949493E   
 41550 00007C71 063031303006            		db 6,'0100',6
 41551 00007C77 3C483E3C49493E2020-     		db '<H><II>  <RIIIIIIIIIII>    <IIII>  <IIIIIIII>  <IIII>',0
 41552 00007C80 3C5249494949494949-
 41553 00007C89 494949493E20202020-
 41554 00007C92 3C494949493E20203C-
 41555 00007C9B 49494949494949493E-
 41556 00007CA4 20203C494949493E00 
 41557 00007CAD 063130303006            menu_43:	db 6,'1000',6
 41558 00007CB3 3C483E3C49493E2020-     		db '<H><II>  <RIIIIIIIIIII>    <IIII>  <IIIIIIII>  <IIII>'
 41559 00007CBC 3C5249494949494949-
 41560 00007CC5 494949493E20202020-
 41561 00007CCE 3C494949493E20203C-
 41562 00007CD7 49494949494949493E-
 41563 00007CE0 20203C494949493E   
 41564 00007CE8 063031303006            		db 6,'0100',6
 41565 00007CEE 3C483E3C49493E2020-     		db '<H><II>  <RIIIIIIIIIII>    <IIII>  <IIIIIIII>  <IIII>'
 41566 00007CF7 3C5249494949494949-
 41567 00007D00 494949493E20202020-
 41568 00007D09 3C494949493E20203C-
 41569 00007D12 49494949494949493E-
 41570 00007D1B 20203C494949493E   
 41571 00007D23 063031303006            		db 6,'0100',6
 41572 00007D29 3C483E3C49493E2020-     		db '<H><II>  <RIIIIIIIIIII>    <IIII>  <IIIIIIII>  <IIII>'
 41573 00007D32 3C5249494949494949-
 41574 00007D3B 494949493E20202020-
 41575 00007D44 3C494949493E20203C-
 41576 00007D4D 49494949494949493E-
 41577 00007D56 20203C494949493E   
 41578 00007D5E 063031303006            		db 6,'0100',6
 41579 00007D64 3C483E3C49493E2020-     		db '<H><II>  <RIIIIIIIIIII>    <IIII>  <IIIIIIII>  <IIII>'
 41580 00007D6D 3C5249494949494949-
 41581 00007D76 494949493E20202020-
 41582 00007D7F 3C494949493E20203C-
 41583 00007D88 49494949494949493E-
 41584 00007D91 20203C494949493E   
 41585 00007D99 063031303006            		db 6,'0100',6
 41586 00007D9F 3C483E3C49493E2020-     		db '<H><II>  <RIIIIIIIIIII>    <IIII>  <IIIIIIII>  <IIII>'
 41587 00007DA8 3C5249494949494949-
 41588 00007DB1 494949493E20202020-
 41589 00007DBA 3C494949493E20203C-
 41590 00007DC3 49494949494949493E-
 41591 00007DCC 20203C494949493E   
 41592 00007DD4 063031303006            		db 6,'0100',6
 41593 00007DDA 3C483E3C49493E2020-     		db '<H><II>  <RIIIIIIIIIII>    <IIII>  <IIIIIIII>  <IIII>',0
 41594 00007DE3 3C5249494949494949-
 41595 00007DEC 494949493E20202020-
 41596 00007DF5 3C494949493E20203C-
 41597 00007DFE 49494949494949493E-
 41598 00007E07 20203C494949493E00 
 41599 00007E10 063033343106            menu_20:	db 6,'0341',6
 41600 00007E16 3C523E44727620566F-     		db '<R>Drv Volume Label  Mbytes  System  Usage'
 41601 00007E1F 6C756D65204C616265-
 41602 00007E28 6C20204D6279746573-
 41603 00007E31 202053797374656D20-
 41604 00007E3A 205573616765       
 41605 00007E40 063031343106            		db 6,'0141',6
 41606 00007E46 3C483E3C49493E2020-     		db '<H><II>  <RIIIIIIIIIII>    <IIII>  <IIIIIIII>  <IIII>'
 41607 00007E4F 3C5249494949494949-
 41608 00007E58 494949493E20202020-
 41609 00007E61 3C494949493E20203C-
 41610 00007E6A 49494949494949493E-
 41611 00007E73 20203C494949493E   
 41612 00007E7B 063031343106            		db 6,'0141',6
 41613 00007E81 3C483E3C49493E2020-     		db '<H><II>  <RIIIIIIIIIII>    <IIII>  <IIIIIIII>  <IIII>'
 41614 00007E8A 3C5249494949494949-
 41615 00007E93 494949493E20202020-
 41616 00007E9C 3C494949493E20203C-
 41617 00007EA5 49494949494949493E-
 41618 00007EAE 20203C494949493E   
 41619 00007EB6 063031343106            		db 6,'0141',6
 41620 00007EBC 3C483E3C49493E2020-     		db '<H><II>  <RIIIIIIIIIII>    <IIII>  <IIIIIIII>  <IIII>'
 41621 00007EC5 3C5249494949494949-
 41622 00007ECE 494949493E20202020-
 41623 00007ED7 3C494949493E20203C-
 41624 00007EE0 49494949494949493E-
 41625 00007EE9 20203C494949493E   
 41626 00007EF1 063031343106            		db 6,'0141',6
 41627 00007EF7 3C483E3C49493E2020-     		db '<H><II>  <RIIIIIIIIIII>    <IIII>  <IIIIIIII>  <IIII>'
 41628 00007F00 3C5249494949494949-
 41629 00007F09 494949493E20202020-
 41630 00007F12 3C494949493E20203C-
 41631 00007F1B 49494949494949493E-
 41632 00007F24 20203C494949493E   
 41633 00007F2C 063031343106            		db 6,'0141',6
 41634 00007F32 3C483E3C49493E2020-     		db '<H><II>  <RIIIIIIIIIII>    <IIII>  <IIIIIIII>  <IIII>'
 41635 00007F3B 3C5249494949494949-
 41636 00007F44 494949493E20202020-
 41637 00007F4D 3C494949493E20203C-
 41638 00007F56 49494949494949493E-
 41639 00007F5F 20203C494949493E   
 41640 00007F67 063031343106            		db 6,'0141',6
 41641 00007F6D 3C483E3C49493E2020-     		db '<H><II>  <RIIIIIIIIIII>    <IIII>  <IIIIIIII>  <IIII>',0
 41642 00007F76 3C5249494949494949-
 41643 00007F7F 494949493E20202020-
 41644 00007F88 3C494949493E20203C-
 41645 00007F91 49494949494949493E-
 41646 00007F9A 20203C494949493E00 
 41647 00007FA3 063130343106            menu_44:	db 6,'1041',6
 41648 00007FA9 3C483E3C49493E2020-     		db '<H><II>  <RIIIIIIIIIII>    <IIII>  <IIIIIIII>  <IIII>'
 41649 00007FB2 3C5249494949494949-
 41650 00007FBB 494949493E20202020-
 41651 00007FC4 3C494949493E20203C-
 41652 00007FCD 49494949494949493E-
 41653 00007FD6 20203C494949493E   
 41654 00007FDE 063031343106            		db 6,'0141',6
 41655 00007FE4 3C483E3C49493E2020-     		db '<H><II>  <RIIIIIIIIIII>    <IIII>  <IIIIIIII>  <IIII>'
 41656 00007FED 3C5249494949494949-
 41657 00007FF6 494949493E20202020-
 41658 00007FFF 3C494949493E20203C-
 41659 00008008 49494949494949493E-
 41660 00008011 20203C494949493E   
 41661 00008019 063031343106            		db 6,'0141',6
 41662 0000801F 3C483E3C49493E2020-     		db '<H><II>  <RIIIIIIIIIII>    <IIII>  <IIIIIIII>  <IIII>'
 41663 00008028 3C5249494949494949-
 41664 00008031 494949493E20202020-
 41665 0000803A 3C494949493E20203C-
 41666 00008043 49494949494949493E-
 41667 0000804C 20203C494949493E   
 41668 00008054 063031343106            		db 6,'0141',6
 41669 0000805A 3C483E3C49493E2020-     		db '<H><II>  <RIIIIIIIIIII>    <IIII>  <IIIIIIII>  <IIII>'
 41670 00008063 3C5249494949494949-
 41671 0000806C 494949493E20202020-
 41672 00008075 3C494949493E20203C-
 41673 0000807E 49494949494949493E-
 41674 00008087 20203C494949493E   
 41675 0000808F 063031343106            		db 6,'0141',6
 41676 00008095 3C483E3C49493E2020-     		db '<H><II>  <RIIIIIIIIIII>    <IIII>  <IIIIIIII>  <IIII>',0
 41677 0000809E 3C5249494949494949-
 41678 000080A7 494949493E20202020-
 41679 000080B0 3C494949493E20203C-
 41680 000080B9 49494949494949493E-
 41681 000080C2 20203C494949493E00 
 41682 000080CB 063137303406            menu_21:	db 6,'1704',6
 41683 000080D1 3C52433E546F74616C-     		db '<RC>Total Extended DOS Partition size is <HIIIIR> Mbytes (1 MByte'
 41684 000080DA 20457874656E646564-
 41685 000080E3 20444F532050617274-
 41686 000080EC 6974696F6E2073697A-
 41687 000080F5 65206973203C484949-
 41688 000080FE 4949523E204D627974-
 41689 00008107 6573202831204D4279-
 41690 00008110 7465               
 41691 00008112 203D20313034383537-     		db ' = 1048576 bytes)',0
 41692 0000811B 362062797465732900 
 41693 00008124 063138303406            menu_22:	db 6,'1804',6
 41694 0000812A 3C52433E4D6178696D-     		db '<RC>Maximum space available for logical drive is <HIIIIR> Mbytes '
 41695 00008133 756D20737061636520-
 41696 0000813C 617661696C61626C65-
 41697 00008145 20666F72206C6F6769-
 41698 0000814E 63616C206472697665-
 41699 00008157 206973203C48494949-
 41700 00008160 49523E204D62797465-
 41701 00008169 7320               
 41702 0000816B 3C483E283C49494949-     		db '<H>(<IIII>)',0
 41703 00008174 3E2900             
 41704 00008177 063230303406            menu_40:	db 6,'2004',6
 41705 0000817D 3C52433E456E746572-     		db '<RC>Enter logical drive size in Mbytes or percent of disk space (%)'
 41706 00008186 206C6F676963616C20-
 41707 0000818F 64726976652073697A-
 41708 00008198 6520696E204D627974-
 41709 000081A1 6573206F7220706572-
 41710 000081AA 63656E74206F662064-
 41711 000081B3 69736B207370616365-
 41712 000081BC 20282529           
 41713 000081C0 2E2E2E3C483E5B3C49-     		db '...<H>[<IIISI>]',0
 41714 000081C9 494953493E5D00     
 41715 000081D0 063034303406            menu_23:	db 6,'0404',6
 41716 000081D6 3C483E202020202020-     		db '<H>                          Set Active Partition',0
 41717 000081DF 202020202020202020-
 41718 000081E8 202020202020202020-
 41719 000081F1 202053657420416374-
 41720 000081FA 697665205061727469-
 41721 00008203 74696F6E00         
 41722 00008208 063136303406            menu_24:	db 6,'1604',6
 41723 0000820E 3C523E456E74657220-     		db '<R>Enter the number of the partition you want to make active.....'
 41724 00008217 746865206E756D6265-
 41725 00008220 72206F662074686520-
 41726 00008229 706172746974696F6E-
 41727 00008232 20796F752077616E74-
 41728 0000823B 20746F206D616B6520-
 41729 00008244 6163746976652E2E2E-
 41730 0000824D 2E2E               
 41731 0000824F 2E2E2E2E2E2E3A203C-     		db '......: <H>[<S> ]',0
 41732 00008258 483E5B3C533E205D00 
 41733 00008261 063034303406            menu_25:	db 6,'0404',6
 41734 00008267 3C483E202020202020-     		db '<H>                Delete DOS Partition or Logical DOS Drive',0
 41735 00008270 202020202020202020-
 41736 00008279 2044656C6574652044-
 41737 00008282 4F5320506172746974-
 41738 0000828B 696F6E206F72204C6F-
 41739 00008294 676963616C20444F53-
 41740 0000829D 20447269766500     
 41741 000082A4 063130303406            menu_26:	db 6,'1004',6
 41742 000082AA 3C48433E312E20203C-     		db '<HC>1.  <R>Delete Primary DOS Partition '
 41743 000082B3 523E44656C65746520-
 41744 000082BC 5072696D6172792044-
 41745 000082C5 4F5320506172746974-
 41746 000082CE 696F6E20           
 41747 000082D2 063031303406            		db 6,'0104',6
 41748 000082D8 3C48433E322E20203C-     		db '<HC>2.  <R>Delete Extended DOS Partition',0
 41749 000082E1 523E44656C65746520-
 41750 000082EA 457874656E64656420-
 41751 000082F3 444F53205061727469-
 41752 000082FC 74696F6E00         
 41753 00008301 063132303406            menu_27:	db 6,'1204',6
 41754 00008307 3C48433E332E20203C-     		db '<HC>3.  <R>Delete Logical DOS Drive(s) in the Extended DOS Partition',0
 41755 00008310 523E44656C65746520-
 41756 00008319 4C6F676963616C2044-
 41757 00008322 4F5320447269766528-
 41758 0000832B 732920696E20746865-
 41759 00008334 20457874656E646564-
 41760 0000833D 20444F532050617274-
 41761 00008346 6974696F6E00       
 41762 0000834C 063133303406            menu_57:	db 6,'1304',6
 41763 00008352 3C48433E342E20203C-     		db '<HC>4.  <R>Delete Non-DOS Partition',0
 41764 0000835B 523E44656C65746520-
 41765 00008364 4E6F6E2D444F532050-
 41766 0000836D 6172746974696F6E00 
 41767 00008376 063034303406            menu_28:	db 6,'0404',6
 41768 0000837C 3C483E202020202020-     		db '<H>                      Delete Primary DOS Partition',0
 41769 00008385 202020202020202020-
 41770 0000838E 202020202020204465-
 41771 00008397 6C657465205072696D-
 41772 000083A0 61727920444F532050-
 41773 000083A9 6172746974696F6E00 
 41774 000083B2 063139303406            menu_55:	db 6,'1904',6
 41775 000083B8 3C4842433E5741524E-     		db '<HBC>WARNING! <OR>Data in the deleted Primary DOS Partition will be lost. '
 41776 000083C1 494E4721203C4F523E-
 41777 000083CA 4461746120696E2074-
 41778 000083D3 68652064656C657465-
 41779 000083DC 64205072696D617279-
 41780 000083E5 20444F532050617274-
 41781 000083EE 6974696F6E2077696C-
 41782 000083F7 6C206265206C6F7374-
 41783 00008400 2E20               
 41784 00008402 063031303406            		db 6,'0104',6
 41785 00008408 3C523E576861742070-     		db '<R>What primary partition do you want to delete..? <H>[<S> ]<R>',0
 41786 00008411 72696D617279207061-
 41787 0000841A 72746974696F6E2064-
 41788 00008423 6F20796F752077616E-
 41789 0000842C 7420746F2064656C65-
 41790 00008435 74652E2E3F203C483E-
 41791 0000843E 5B3C533E205D3C523E-
 41792 00008447 00                 
 41793 00008448 063232303406            menu_56:	db 6,'2204',6
 41794 0000844E 3C52433E446F20796F-     		db '<RC>Do you wish to continue (<Y>/<N>).................? <H>[<S> ]',0
 41795 00008457 75207769736820746F-
 41796 00008460 20636F6E74696E7565-
 41797 00008469 20283C593E2F3C4E3E-
 41798 00008472 292E2E2E2E2E2E2E2E-
 41799 0000847B 2E2E2E2E2E2E2E2E2E-
 41800 00008484 3F203C483E5B3C533E-
 41801 0000848D 205D00             
 41802 00008490 063034303406            menu_30:	db 6,'0404',6
 41803 00008496 3C483E202020202020-     		db '<H>                      Delete Extended DOS Partition',0
 41804 0000849F 202020202020202020-
 41805 000084A8 202020202020204465-
 41806 000084B1 6C6574652045787465-
 41807 000084BA 6E64656420444F5320-
 41808 000084C3 506172746974696F6E-
 41809 000084CC 00                 
 41810 000084CD 063136303406            menu_31:	db 6,'1604',6
 41811 000084D3 3C4842433E5741524E-     		db '<HBC>WARNING! <OR>Data in the deleted Extended DOS Partition will be lost. '
 41812 000084DC 494E4721203C4F523E-
 41813 000084E5 4461746120696E2074-
 41814 000084EE 68652064656C657465-
 41815 000084F7 6420457874656E6465-
 41816 00008500 6420444F5320506172-
 41817 00008509 746974696F6E207769-
 41818 00008512 6C6C206265206C6F73-
 41819 0000851B 742E20             
 41820 0000851E 063031303406            		db 6,'0104',6
 41821 00008524 3C52433E446F20796F-     		db '<RC>Do you wish to continue (<Y>/<N>).................? <H>[<S> ]',0
 41822 0000852D 75207769736820746F-
 41823 00008536 20636F6E74696E7565-
 41824 0000853F 20283C593E2F3C4E3E-
 41825 00008548 292E2E2E2E2E2E2E2E-
 41826 00008551 2E2E2E2E2E2E2E2E2E-
 41827 0000855A 3F203C483E5B3C533E-
 41828 00008563 205D00             
 41829 00008566 063031303406            menu_32:	db 6,'0104',6
 41830 0000856C 3C483E202020202020-     		db '<H>        Delete Logical DOS Drive(s) in the Extended DOS Partition',0
 41831 00008575 202044656C65746520-
 41832 0000857E 4C6F676963616C2044-
 41833 00008587 4F5320447269766528-
 41834 00008590 732920696E20746865-
 41835 00008599 20457874656E646564-
 41836 000085A2 20444F532050617274-
 41837 000085AB 6974696F6E00       
 41838 000085B1 063139303406            menu_33:	db 6,'1904',6
 41839 000085B7 3C4842433E5741524E-     		db '<HBC>WARNING! <OR>Data in a deleted Logical DOS Drive will be lost. '
 41840 000085C0 494E4721203C4F523E-
 41841 000085C9 4461746120696E2061-
 41842 000085D2 2064656C6574656420-
 41843 000085DB 4C6F676963616C2044-
 41844 000085E4 4F5320447269766520-
 41845 000085ED 77696C6C206265206C-
 41846 000085F6 6F73742E20         
 41847 000085FB 063031303406            		db 6,'0104',6
 41848 00008601 3C52433E5768617420-     		db '<RC>What drive do you want to delete...............................? <H>[<S> ]',0
 41849 0000860A 647269766520646F20-
 41850 00008613 796F752077616E7420-
 41851 0000861C 746F2064656C657465-
 41852 00008625 2E2E2E2E2E2E2E2E2E-
 41853 0000862E 2E2E2E2E2E2E2E2E2E-
 41854 00008637 2E2E2E2E2E2E2E2E2E-
 41855 00008640 2E2E2E2E3F203C483E-
 41856 00008649 5B3C533E205D00     
 41857 00008650 063232303406            menu_34:	db 6,'2204',6
 41858 00008656 3C523E41726520796F-     		db '<R>Are you sure (<Y>/<N>)..............................? <H>[<S> ]',0
 41859 0000865F 75207375726520283C-
 41860 00008668 593E2F3C4E3E292E2E-
 41861 00008671 2E2E2E2E2E2E2E2E2E-
 41862 0000867A 2E2E2E2E2E2E2E2E2E-
 41863 00008683 2E2E2E2E2E2E2E2E2E-
 41864 0000868C 2E3F203C483E5B3C53-
 41865 00008695 3E205D00           
 41866 00008699 063231303406            menu_41:	db 6,'2104',6
 41867 0000869F 3C523E456E74657220-     		db '<R>Enter Volume Label..............................? <H>[<S>           ]',0
 41868 000086A8 566F6C756D65204C61-
 41869 000086B1 62656C2E2E2E2E2E2E-
 41870 000086BA 2E2E2E2E2E2E2E2E2E-
 41871 000086C3 2E2E2E2E2E2E2E2E2E-
 41872 000086CC 2E2E2E2E2E2E3F203C-
 41873 000086D5 483E5B3C533E202020-
 41874 000086DE 20202020202020205D-
 41875 000086E7 00                 
 41876 000086E8 063034303406            menu_58:	db 6,'0404',6
 41877 000086EE 3C483E202020202020-     		db '<H>                        Delete Non-DOS Partition',0
 41878 000086F7 202020202020202020-
 41879 00008700 202020202020202020-
 41880 00008709 44656C657465204E6F-
 41881 00008712 6E2D444F5320506172-
 41882 0000871B 746974696F6E00     
 41883 00008722 063136303406            menu_59:	db 6,'1604',6
 41884 00008728 3C4842433E5741524E-     		db '<HBC>WARNING! <OR>Data in the deleted Non-DOS Partition will be lost. '
 41885 00008731 494E4721203C4F523E-
 41886 0000873A 4461746120696E2074-
 41887 00008743 68652064656C657465-
 41888 0000874C 64204E6F6E2D444F53-
 41889 00008755 20506172746974696F-
 41890 0000875E 6E2077696C6C206265-
 41891 00008767 206C6F73742E20     
 41892 0000876E 063031303406            		db 6,'0104',6
 41893 00008774 3C52433E5768617420-     		db '<RC>What Non-DOS partition do you want to delete..? <H>[<S> ]<R>',0
 41894 0000877D 4E6F6E2D444F532070-
 41895 00008786 6172746974696F6E20-
 41896 0000878F 646F20796F75207761-
 41897 00008798 6E7420746F2064656C-
 41898 000087A1 6574652E2E3F203C48-
 41899 000087AA 3E5B3C533E205D3C52-
 41900 000087B3 3E00               
 41901 000087B5 063034303406            menu_35:	db 6,'0404',6
 41902 000087BB 3C483E202020202020-     		db '<H>                      Display Partition Information',0
 41903 000087C4 202020202020202020-
 41904 000087CD 202020202020204469-
 41905 000087D6 73706C617920506172-
 41906 000087DF 746974696F6E20496E-
 41907 000087E8 666F726D6174696F6E-
 41908 000087F1 00                 
 41909 000087F2 063137303406            menu_36:	db 6,'1704',6
 41910 000087F8 3C52433E5468652045-     		db '<RC>The Extended DOS Partition contains Logical DOS Drives. '
 41911 00008801 7874656E6465642044-
 41912 0000880A 4F5320506172746974-
 41913 00008813 696F6E20636F6E7461-
 41914 0000881C 696E73204C6F676963-
 41915 00008825 616C20444F53204472-
 41916 0000882E 697665732E20       
 41917 00008834 063031303406            		db 6,'0104',6
 41918 0000883A 3C52433E446F20796F-     		db '<RC>Do you want to display the logical drive information (<Y>/<N>)'
 41919 00008843 752077616E7420746F-
 41920 0000884C 20646973706C617920-
 41921 00008855 746865206C6F676963-
 41922 0000885E 616C20647269766520-
 41923 00008867 696E666F726D617469-
 41924 00008870 6F6E20283C593E2F3C-
 41925 00008879 4E3E29             
 41926 0000887C 2E2E2E2E2E2E3F3C48-     		db '......?<H>[<S> ]',0
 41927 00008885 3E5B3C533E205D00   
 41928 0000888D 063031303406            menu_37:	db 6,'0104',6
 41929 00008893 3C483E202020202020-     		db '<H>                  Display Logical DOS Drive Information',0
 41930 0000889C 202020202020202020-
 41931 000088A5 202020446973706C61-
 41932 000088AE 79204C6F676963616C-
 41933 000088B7 20444F532044726976-
 41934 000088C0 6520496E666F726D61-
 41935 000088C9 74696F6E00         
 41936 000088CE 063030303406            menu_47:	db 6,'0004',6
 41937 000088D4 3C483E202020202020-     		db '<H>                     Change Current Fixed Disk Drive',0
 41938 000088DD 202020202020202020-
 41939 000088E6 202020202020436861-
 41940 000088EF 6E6765204375727265-
 41941 000088F8 6E7420466978656420-
 41942 00008901 4469736B2044726976-
 41943 0000890A 6500               
 41944 0000890C 063032303006            menu_48:	db 6,'0200',6
 41945 00008912 3C523E20204469736B-     		db '<R>  Disk   Drv   Mbytes   Free   Usage'
 41946 0000891B 202020447276202020-
 41947 00008924 4D6279746573202020-
 41948 0000892D 467265652020205573-
 41949 00008936 616765             
 41950 00008939 063031303406            		db 6,'0104',6
 41951 0000893F 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 41952 00008948 3C5249493E20202020-
 41953 00008951 3C494949493E202020-
 41954 0000895A 203C494949493E2020-
 41955 00008963 20203C494949493E   
 41956 0000896B 063031303406            		db 6,'0104',6
 41957 00008971 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 41958 0000897A 3C5249493E20202020-
 41959 00008983 3C494949493E202020-
 41960 0000898C 203C494949493E2020-
 41961 00008995 20203C494949493E   
 41962 0000899D 063031303406            		db 6,'0104',6
 41963 000089A3 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 41964 000089AC 3C5249493E20202020-
 41965 000089B5 3C494949493E202020-
 41966 000089BE 203C494949493E2020-
 41967 000089C7 20203C494949493E   
 41968 000089CF 063031303406            		db 6,'0104',6
 41969 000089D5 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 41970 000089DE 3C5249493E20202020-
 41971 000089E7 3C494949493E202020-
 41972 000089F0 203C494949493E2020-
 41973 000089F9 20203C494949493E   
 41974 00008A01 063031303406            		db 6,'0104',6
 41975 00008A07 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 41976 00008A10 3C5249493E20202020-
 41977 00008A19 3C494949493E202020-
 41978 00008A22 203C494949493E2020-
 41979 00008A2B 20203C494949493E   
 41980 00008A33 063031303406            		db 6,'0104',6
 41981 00008A39 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 41982 00008A42 3C5249493E20202020-
 41983 00008A4B 3C494949493E202020-
 41984 00008A54 203C494949493E2020-
 41985 00008A5D 20203C494949493E   
 41986 00008A65 063031303406            		db 6,'0104',6
 41987 00008A6B 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 41988 00008A74 3C5249493E20202020-
 41989 00008A7D 3C494949493E202020-
 41990 00008A86 203C494949493E2020-
 41991 00008A8F 20203C494949493E   
 41992 00008A97 063031303406            		db 6,'0104',6
 41993 00008A9D 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>',0
 41994 00008AA6 3C5249493E20202020-
 41995 00008AAF 3C494949493E202020-
 41996 00008AB8 203C494949493E2020-
 41997 00008AC1 20203C494949493E00 
 41998 00008ACA 063131303406            menu_49:	db 6,'1104',6
 41999 00008AD0 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 42000 00008AD9 3C5249493E20202020-
 42001 00008AE2 3C494949493E202020-
 42002 00008AEB 203C494949493E2020-
 42003 00008AF4 20203C494949493E   
 42004 00008AFC 063031303406            		db 6,'0104',6
 42005 00008B02 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 42006 00008B0B 3C5249493E20202020-
 42007 00008B14 3C494949493E202020-
 42008 00008B1D 203C494949493E2020-
 42009 00008B26 20203C494949493E   
 42010 00008B2E 063031303406            		db 6,'0104',6
 42011 00008B34 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 42012 00008B3D 3C5249493E20202020-
 42013 00008B46 3C494949493E202020-
 42014 00008B4F 203C494949493E2020-
 42015 00008B58 20203C494949493E   
 42016 00008B60 063031303406            		db 6,'0104',6
 42017 00008B66 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 42018 00008B6F 3C5249493E20202020-
 42019 00008B78 3C494949493E202020-
 42020 00008B81 203C494949493E2020-
 42021 00008B8A 20203C494949493E   
 42022 00008B92 063031303406            		db 6,'0104',6
 42023 00008B98 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 42024 00008BA1 3C5249493E20202020-
 42025 00008BAA 3C494949493E202020-
 42026 00008BB3 203C494949493E2020-
 42027 00008BBC 20203C494949493E   
 42028 00008BC4 063031303406            		db 6,'0104',6
 42029 00008BCA 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 42030 00008BD3 3C5249493E20202020-
 42031 00008BDC 3C494949493E202020-
 42032 00008BE5 203C494949493E2020-
 42033 00008BEE 20203C494949493E   
 42034 00008BF6 063031303406            		db 6,'0104',6
 42035 00008BFC 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 42036 00008C05 3C5249493E20202020-
 42037 00008C0E 3C494949493E202020-
 42038 00008C17 203C494949493E2020-
 42039 00008C20 20203C494949493E   
 42040 00008C28 063031303406            		db 6,'0104',6
 42041 00008C2E 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>',0
 42042 00008C37 3C5249493E20202020-
 42043 00008C40 3C494949493E202020-
 42044 00008C49 203C494949493E2020-
 42045 00008C52 20203C494949493E00 
 42046 00008C5B 063032343106            menu_50:	db 6,'0241',6
 42047 00008C61 3C523E20204469736B-     		db '<R>  Disk   Drv   Mbytes   Free   Usage'
 42048 00008C6A 202020447276202020-
 42049 00008C73 4D6279746573202020-
 42050 00008C7C 467265652020205573-
 42051 00008C85 616765             
 42052 00008C88 063031343506            		db 6,'0145',6
 42053 00008C8E 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 42054 00008C97 3C5249493E20202020-
 42055 00008CA0 3C494949493E202020-
 42056 00008CA9 203C494949493E2020-
 42057 00008CB2 20203C494949493E   
 42058 00008CBA 063031343506            		db 6,'0145',6
 42059 00008CC0 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 42060 00008CC9 3C5249493E20202020-
 42061 00008CD2 3C494949493E202020-
 42062 00008CDB 203C494949493E2020-
 42063 00008CE4 20203C494949493E   
 42064 00008CEC 063031343506            		db 6,'0145',6
 42065 00008CF2 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 42066 00008CFB 3C5249493E20202020-
 42067 00008D04 3C494949493E202020-
 42068 00008D0D 203C494949493E2020-
 42069 00008D16 20203C494949493E   
 42070 00008D1E 063031343506            		db 6,'0145',6
 42071 00008D24 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 42072 00008D2D 3C5249493E20202020-
 42073 00008D36 3C494949493E202020-
 42074 00008D3F 203C494949493E2020-
 42075 00008D48 20203C494949493E   
 42076 00008D50 063031343506            		db 6,'0145',6
 42077 00008D56 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 42078 00008D5F 3C5249493E20202020-
 42079 00008D68 3C494949493E202020-
 42080 00008D71 203C494949493E2020-
 42081 00008D7A 20203C494949493E   
 42082 00008D82 063031343506            		db 6,'0145',6
 42083 00008D88 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 42084 00008D91 3C5249493E20202020-
 42085 00008D9A 3C494949493E202020-
 42086 00008DA3 203C494949493E2020-
 42087 00008DAC 20203C494949493E   
 42088 00008DB4 063031343506            		db 6,'0145',6
 42089 00008DBA 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 42090 00008DC3 3C5249493E20202020-
 42091 00008DCC 3C494949493E202020-
 42092 00008DD5 203C494949493E2020-
 42093 00008DDE 20203C494949493E   
 42094 00008DE6 063031343506            		db 6,'0145',6
 42095 00008DEC 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>',0
 42096 00008DF5 3C5249493E20202020-
 42097 00008DFE 3C494949493E202020-
 42098 00008E07 203C494949493E2020-
 42099 00008E10 20203C494949493E00 
 42100 00008E19 063131343506            menu_51:	db 6,'1145',6
 42101 00008E1F 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 42102 00008E28 3C5249493E20202020-
 42103 00008E31 3C494949493E202020-
 42104 00008E3A 203C494949493E2020-
 42105 00008E43 20203C494949493E   
 42106 00008E4B 063031343506            		db 6,'0145',6
 42107 00008E51 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 42108 00008E5A 3C5249493E20202020-
 42109 00008E63 3C494949493E202020-
 42110 00008E6C 203C494949493E2020-
 42111 00008E75 20203C494949493E   
 42112 00008E7D 063031343506            		db 6,'0145',6
 42113 00008E83 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 42114 00008E8C 3C5249493E20202020-
 42115 00008E95 3C494949493E202020-
 42116 00008E9E 203C494949493E2020-
 42117 00008EA7 20203C494949493E   
 42118 00008EAF 063031343506            		db 6,'0145',6
 42119 00008EB5 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 42120 00008EBE 3C5249493E20202020-
 42121 00008EC7 3C494949493E202020-
 42122 00008ED0 203C494949493E2020-
 42123 00008ED9 20203C494949493E   
 42124 00008EE1 063031343506            		db 6,'0145',6
 42125 00008EE7 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 42126 00008EF0 3C5249493E20202020-
 42127 00008EF9 3C494949493E202020-
 42128 00008F02 203C494949493E2020-
 42129 00008F0B 20203C494949493E   
 42130 00008F13 063031343506            		db 6,'0145',6
 42131 00008F19 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 42132 00008F22 3C5249493E20202020-
 42133 00008F2B 3C494949493E202020-
 42134 00008F34 203C494949493E2020-
 42135 00008F3D 20203C494949493E   
 42136 00008F45 063031343506            		db 6,'0145',6
 42137 00008F4B 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 42138 00008F54 3C5249493E20202020-
 42139 00008F5D 3C494949493E202020-
 42140 00008F66 203C494949493E2020-
 42141 00008F6F 20203C494949493E   
 42142 00008F77 063031343506            		db 6,'0145',6
 42143 00008F7D 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>',0
 42144 00008F86 3C5249493E20202020-
 42145 00008F8F 3C494949493E202020-
 42146 00008F98 203C494949493E2020-
 42147 00008FA1 20203C494949493E00 
 42148 00008FAA 063230303406            menu_52:	db 6,'2004',6
 42149 00008FB0 3C523E2831204D4279-     		db '<R>(1 MByte = 1048576 bytes)',0
 42150 00008FB9 7465203D2031303438-
 42151 00008FC2 353736206279746573-
 42152 00008FCB 2900               
 42153 00008FCD 063231303406            menu_53:	db 6,'2104',6
 42154 00008FD3 3C523E456E74657220-     		db '<R>Enter Fixed Disk Drive Number (1-<I>).......................<H>[<SI>]',0
 42155 00008FDC 466978656420446973-
 42156 00008FE5 6B204472697665204E-
 42157 00008FEE 756D6265722028312D-
 42158 00008FF7 3C493E292E2E2E2E2E-
 42159 00009000 2E2E2E2E2E2E2E2E2E-
 42160 00009009 2E2E2E2E2E2E2E2E2E-
 42161 00009012 3C483E5B3C53493E5D-
 42162 0000901B 00                 
 42163 0000901C 063031303406            menu_54:	db 6,'0104',6
 42164 00009022 3C483E202020202020-     		db '<H>                         Fixed Disk Drive Status',0
 42165 0000902B 202020202020202020-
 42166 00009034 202020202020202020-
 42167 0000903D 204669786564204469-
 42168 00009046 736B20447269766520-
 42169 0000904F 53746174757300     
 42170 00009056 063133303406            menu_38:	db 6,'1304',6
 42171 0000905C 3C483E53797374656D-     		db '<H>System will now restart '
 42172 00009065 2077696C6C206E6F77-
 42173 0000906E 207265737461727420 
 42174 00009077 063032303406            		db 6,'0204',6
 42175 0000907D 3C523E496E73657274-     		db '<R>Insert DOS system diskette in drive A: '
 42176 00009086 20444F532073797374-
 42177 0000908F 656D206469736B6574-
 42178 00009098 746520696E20647269-
 42179 000090A1 766520413A20       
 42180 000090A7 063031303406            		db 6,'0104',6
 42181 000090AD 3C523E507265737320-     		db '<R>Press any key when ready . . .<S>',0
 42182 000090B6 616E79206B65792077-
 42183 000090BF 68656E207265616479-
 42184 000090C8 202E202E202E3C533E-
 42185 000090D1 00                 
 42186 000090D2 06                      menu_60:	db 6
 42187 000090D3 31333034                		db '1304'
 42188 000090D7 06                      		db 6
 42189 000090D8 3C483E53797374656D-     		db '<H>System will now restart '
 42190 000090E1 2077696C6C206E6F77-
 42191 000090EA 207265737461727420 
 42192 000090F3 06                      		db 6
 42193 000090F4 30333034                		db '0304'
 42194 000090F8 06                      		db 6
 42195 000090F9 3C523E507265737320-     		db '<R>Press any key when ready . . .<S>',0
 42196 00009102 616E79206B65792077-
 42197 0000910B 68656E207265616479-
 42198 00009114 202E202E202E3C533E-
 42199 0000911D 00                 
 42200                                  
 42201                                  ; STATUS MESSAGES
 42202                                  ; 01/12/2018
 42203 0000911E 063231303406            status_1:	db 6,'2104',6
 42204 00009124 3C43483E5072696D61-     		db '<CH>Primary DOS Partition deleted '
 42205 0000912D 727920444F53205061-
 42206 00009136 72746974696F6E2064-
 42207 0000913F 656C6574656420     
 42208 00009146 063031303006            		db 6,'0100',6
 42209 0000914C 3C43573E00              		db '<CW>',0
 42210 00009151 063231303406            status_2:	db 6,'2104',6
 42211 00009157 3C43483E457874656E-     		db '<CH>Extended DOS Partition deleted '
 42212 00009160 64656420444F532050-
 42213 00009169 6172746974696F6E20-
 42214 00009172 64656C6574656420   
 42215 0000917A 063031303006            		db 6,'0100',6
 42216 00009180 3C43573E00              		db '<CW>',0
 42217 00009185 063030303406            status_3:	db 6,'0004',6
 42218 0000918B 3C483E447269766520-     		db '<H>Drive deleted',0
 42219 00009194 64656C6574656400   
 42220 0000919C 063231303406            status_4:	db 6,'2104',6
 42221 000091A2 3C43483E5061727469-     		db '<CH>Partition <I> made active '
 42222 000091AB 74696F6E203C493E20-
 42223 000091B4 6D6164652061637469-
 42224 000091BD 766520             
 42225 000091C0 063031303006            		db 6,'0100',6
 42226 000091C6 3C43573E00              		db '<CW>',0
 42227 000091CB 063231303406            status_5:	db 6,'2104',6
 42228 000091D1 3C43483E5072696D61-     		db '<CH>Primary DOS Partition created '
 42229 000091DA 727920444F53205061-
 42230 000091E3 72746974696F6E2063-
 42231 000091EC 72656174656420     
 42232 000091F3 063031303006            		db 6,'0100',6
 42233 000091F9 3C43573E00              		db '<CW>',0
 42234 000091FE 063231303406            status_6:	db 6,'2104',6
 42235 00009204 3C43483E457874656E-     		db '<CH>Extended DOS Partition created '
 42236 0000920D 64656420444F532050-
 42237 00009216 6172746974696F6E20-
 42238 0000921F 6372656174656420   
 42239 00009227 063031303006            		db 6,'0100',6
 42240 0000922D 3C43573E00              		db '<CW>',0
 42241 00009232 063232303406            status_7:	db 6,'2204',6
 42242 00009238 3C43483E4C6F676963-     		db '<CH>Logical DOS Drive created, drive letters changed or added<W>',0
 42243 00009241 616C20444F53204472-
 42244 0000924A 697665206372656174-
 42245 00009253 65642C206472697665-
 42246 0000925C 206C65747465727320-
 42247 00009265 6368616E676564206F-
 42248 0000926E 722061646465643C57-
 42249 00009277 3E00               
 42250 00009279 063231303406            status_8:	db 6,'2104',6
 42251 0000927F 3C43483E4E6F207061-     		db '<CH>No partitions defined '
 42252 00009288 72746974696F6E7320-
 42253 00009291 646566696E656420   
 42254 00009299 063031303006            		db 6,'0100',6
 42255 0000929F 3C433E00                		db '<C>',0
 42256 000092A3 063130303406            status_9:	db 6,'1004',6
 42257 000092A9 3C43483E4E6F206C6F-     		db '<CH>No logical drives defined '
 42258 000092B2 676963616C20647269-
 42259 000092BB 76657320646566696E-
 42260 000092C4 656420             
 42261 000092C7 063031303006            		db 6,'0100',6
 42262 000092CD 3C433E00                		db '<C>',0
 42263 000092D1 063138303406            status_10:	db 6,'1804',6
 42264 000092D7 3C43483E4472697665-     		db '<CH>Drive letters have been changed or deleted<W>',0
 42265 000092E0 206C65747465727320-
 42266 000092E9 68617665206265656E-
 42267 000092F2 206368616E67656420-
 42268 000092FB 6F722064656C657465-
 42269 00009304 643C573E00         
 42270 00009309 063030303406            status_11:	db 6,'0004',6
 42271 0000930F 3C483E447269766520-     		db '<H>Drive redirected',0
 42272 00009318 726564697265637465-
 42273 00009321 6400               
 42274 00009323 063231303406            status_12:	db 6,'2104',6
 42275 00009329 3C43483E5072696D61-     		db '<CH>Primary DOS Partition created, drive letters changed or added '
 42276 00009332 727920444F53205061-
 42277 0000933B 72746974696F6E2063-
 42278 00009344 7265617465642C2064-
 42279 0000934D 72697665206C657474-
 42280 00009356 657273206368616E67-
 42281 0000935F 6564206F7220616464-
 42282 00009368 656420             
 42283 0000936B 063031303006            		db 6,'0100',6
 42284 00009371 3C43573E00              		db '<CW>',0
 42285 00009376 063231303406            status_13:	db 6,'2104',6
 42286 0000937C 3C43483E4E6F6E2D44-     		db '<CH>Non-DOS Partition deleted '
 42287 00009385 4F5320506172746974-
 42288 0000938E 696F6E2064656C6574-
 42289 00009397 656420             
 42290 0000939A 063031303006            		db 6,'0100',6
 42291 000093A0 3C43573E00              		db '<CW>',0
 42292                                  
 42293                                  ; ERROR MESSAGES
 42294                                  ; 17/11/2018
 42295                                  
 42296                                  ;-- FDISK.MSG (MSDOS 6.0, FDISK) --
 42297                                  ;/*                                                                      */
 42298                                  ;/* The following character strings are required to display the          */
 42299                                  ;/* error messages. These have form: error_xx                            */
 42300                                  ;/*                                                                      */
 42301                                  ;/* Note: In order to overlay any previous message on the screen, these  */
 42302                                  ;/*       messages are all 2 lines long. The second line may only be     */
 42303                                  ;/*       a blank line. If 2 lines are needed for translation, use the   */
 42304                                  ;/*       second line for text.  Exceptions are those msgs on line 0.    */
 42305                                  ;/*       and those messages that start on line 23                       */
 42306                                  ;/*                                                                      */
 42307                                  
 42308                                  error_1:	
 42309 000093A5 063030303406            		db 6,'0004',6
 42310 000093AB 3C43483E4E6F206669-     		db '<CH>No fixed disks present. '
 42311 000093B4 786564206469736B73-
 42312 000093BD 2070726573656E742E-
 42313 000093C6 20                 
 42314 000093C7 063031303006            		db 6,'0100',6
 42315 000093CD 3C43573E00              		db '<CW>',0
 42316                                  error_2:	
 42317 000093D2 063232303406            		db 6,'2204',6
 42318 000093D8 3C43483E4572726F72-     		db '<CH>Error reading fixed disk. '
 42319 000093E1 2072656164696E6720-
 42320 000093EA 666978656420646973-
 42321 000093F3 6B2E20             
 42322 000093F6 063031303006            		db 6,'0100',6
 42323 000093FC 3C43573E00              		db '<CW>',0
 42324                                  error_3:		
 42325 00009401 063232303406            		db 6,'2204',6
 42326 00009407 3C43483E4572726F72-     		db '<CH>Error writing fixed disk. '
 42327 00009410 2077726974696E6720-
 42328 00009419 666978656420646973-
 42329 00009422 6B2E20             
 42330 00009425 063031303006            		db 6,'0100',6
 42331 0000942B 3C43573E00              		db '<CW>',0
 42332                                  error_4:
 42333 00009430 063030303406            		db 6,'0004',6
 42334 00009436 3C4348573E496E636F-     		db '<CHW>Incorrect DOS version.',0
 42335 0000943F 727265637420444F53-
 42336 00009448 2076657273696F6E2E-
 42337 00009451 00                 
 42338                                  error_5:
 42339 00009452 063030303406            		db 6,'0004',6
 42340 00009458 3C4348573E43616E6E-     		db '<CHW>Cannot FDISK with network loaded.',0
 42341 00009461 6F7420464449534B20-
 42342 0000946A 77697468206E657477-
 42343 00009473 6F726B206C6F616465-
 42344 0000947C 642E00             
 42345                                  error_6:
 42346 0000947F 063232303406            		db 6,'2204',6
 42347 00009485 3C43483E4E6F205072-     		db '<CH>No Primary DOS Partition to delete. '
 42348 0000948E 696D61727920444F53-
 42349 00009497 20506172746974696F-
 42350 000094A0 6E20746F2064656C65-
 42351 000094A9 74652E20           
 42352 000094AD 063031303006            		db 6,'0100',6
 42353 000094B3 3C43573E00              		db '<CW>',0
 42354                                  error_7:
 42355 000094B8 063232303406            		db 6,'2204',6
 42356 000094BE 3C43483E4E6F204578-     		db '<CH>No Extended DOS Partition to delete. '
 42357 000094C7 74656E64656420444F-
 42358 000094D0 532050617274697469-
 42359 000094D9 6F6E20746F2064656C-
 42360 000094E2 6574652E20         
 42361 000094E7 063031303006            		db 6,'0100',6
 42362 000094ED 3C43573E00              		db '<CW>',0
 42363                                  error_8:
 42364 000094F2 063232303406            		db 6,'2204',6
 42365 000094F8 3C43483E5072696D61-     		db '<CH>Primary DOS Partition already exists. '
 42366 00009501 727920444F53205061-
 42367 0000950A 72746974696F6E2061-
 42368 00009513 6C7265616479206578-
 42369 0000951C 697374732E20       
 42370 00009522 063031303006            		db 6,'0100',6
 42371 00009528 3C43573E00              		db '<CW>',0
 42372                                  error_9:
 42373 0000952D 063232303406            		db 6,'2204',6
 42374 00009533 3C43483E457874656E-     		db '<CH>Extended DOS Partition already exists. '
 42375 0000953C 64656420444F532050-
 42376 00009545 6172746974696F6E20-
 42377 0000954E 616C72656164792065-
 42378 00009557 78697374732E20     
 42379 0000955E 063031303006            		db 6,'0100',6
 42380 00009564 3C43573E00              		db '<CW>',0
 42381                                  error_10:
 42382 00009569 063232303406            		db 6,'2204',6
 42383 0000956F 3C43483E4E6F207370-     		db '<CH>No space to create a DOS partition. '
 42384 00009578 61636520746F206372-
 42385 00009581 65617465206120444F-
 42386 0000958A 532070617274697469-
 42387 00009593 6F6E2E20           
 42388 00009597 063031303006            		db 6,'0100',6
 42389 0000959D 3C43573E00              		db '<CW>',0
 42390                                  
 42391 000095A2 063232303406            error_12:	db 6,'2204',6
 42392 000095A8 3C43483E5265717565-     		db '<CH>Requested logical drive size exceeds the maximum available sp'
 42393 000095B1 73746564206C6F6769-
 42394 000095BA 63616C206472697665-
 42395 000095C3 2073697A6520657863-
 42396 000095CC 656564732074686520-
 42397 000095D5 6D6178696D756D2061-
 42398 000095DE 7661696C61626C6520-
 42399 000095E7 7370               
 42400 000095E9 6163652E3C573E20        		db 'ace.<W> '
 42401 000095F1 063031303006            		db 6,'0100',6
 42402 000095F7 3C43573E00              		db '<CW>',0
 42403 000095FC 063232303406            error_13:	db 6,'2204',6
 42404 00009602 3C43483E5265717565-     		db '<CH>Requested partition size exceeds the maximum available space.'
 42405 0000960B 737465642070617274-
 42406 00009614 6974696F6E2073697A-
 42407 0000961D 652065786365656473-
 42408 00009626 20746865206D617869-
 42409 0000962F 6D756D20617661696C-
 42410 00009638 61626C652073706163-
 42411 00009641 652E               
 42412 00009643 3C573E20                		db '<W> '
 42413 00009647 063031303006            		db 6,'0100',6
 42414 0000964D 3C43573E00              		db '<CW>',0
 42415 00009652 063232303406            error_14:	db 6,'2204',6
 42416 00009658 3C43483E4E6F207061-     		db '<CH>No partitions to delete. '
 42417 00009661 72746974696F6E7320-
 42418 0000966A 746F2064656C657465-
 42419 00009673 2E20               
 42420 00009675 063031303006            		db 6,'0100',6
 42421 0000967B 3C43573E00              		db '<CW>',0
 42422 00009680 063232303406            error_15:	db 6,'2204',6
 42423 00009686 3C43483E546865206F-     		db '<CH>The only startable partition on Drive 1 is already set active'
 42424 0000968F 6E6C79207374617274-
 42425 00009698 61626C652070617274-
 42426 000096A1 6974696F6E206F6E20-
 42427 000096AA 447269766520312069-
 42428 000096B3 7320616C7265616479-
 42429 000096BC 207365742061637469-
 42430 000096C5 7665               
 42431 000096C7 2E3C573E20              		db '.<W> '
 42432 000096CC 063031303006            		db 6,'0100',6
 42433 000096D2 3C43573E00              		db '<CW>',0
 42434 000096D7 063232303406            error_16:	db 6,'2204',6
 42435 000096DD 3C43483E4E6F207061-     		db '<CH>No partitions to make active. '
 42436 000096E6 72746974696F6E7320-
 42437 000096EF 746F206D616B652061-
 42438 000096F8 63746976652E20     
 42439 000096FF 063031303006            		db 6,'0100',6
 42440 00009705 3C43573E00              		db '<CW>',0
 42441 0000970A 063232303406            error_17:	db 6,'2204',6
 42442 00009710 3C43483E5061727469-     		db '<CH>Partition selected (<I>) is not startable, active partition not '
 42443 00009719 74696F6E2073656C65-
 42444 00009722 6374656420283C493E-
 42445 0000972B 29206973206E6F7420-
 42446 00009734 737461727461626C65-
 42447 0000973D 2C2061637469766520-
 42448 00009746 706172746974696F6E-
 42449 0000974F 206E6F7420         
 42450 00009754 6368616E6765642E3C-     		db 'changed.<W>',0
 42451 0000975D 573E00             
 42452 00009760 063232303406            error_19:	db 6,'2204',6
 42453 00009766 3C43483E43616E6E6F-     		db '<CH>Cannot create Extended DOS Partition without '
 42454 0000976F 742063726561746520-
 42455 00009778 457874656E64656420-
 42456 00009781 444F53205061727469-
 42457 0000978A 74696F6E2077697468-
 42458 00009793 6F757420           
 42459 00009797 063031303406            		db 6,'0104',6
 42460 0000979D 3C43483E5072696D61-     		db '<CH>Primary DOS Partition on disk 1.<W>',0
 42461 000097A6 727920444F53205061-
 42462 000097AF 72746974696F6E206F-
 42463 000097B8 6E206469736B20312E-
 42464 000097C1 3C573E00           
 42465 000097C5 063232303406            error_20:	db 6,'2204',6
 42466 000097CB 3C43483E416C6C2061-     		db '<CH>All available space in the Extended DOS Partition '
 42467 000097D4 7661696C61626C6520-
 42468 000097DD 737061636520696E20-
 42469 000097E6 74686520457874656E-
 42470 000097EF 64656420444F532050-
 42471 000097F8 6172746974696F6E20 
 42472 00009801 063031303406            		db 6,'0104',6
 42473 00009807 3C43483E6973206173-     		db '<CH>is assigned to logical drives.<W>',0
 42474 00009810 7369676E656420746F-
 42475 00009819 206C6F676963616C20-
 42476 00009822 6472697665732E3C57-
 42477 0000982B 3E00               
 42478 0000982D 063232303406            error_21:	db 6,'2204',6
 42479 00009833 3C43483E43616E6E6F-     		db '<CH>Cannot delete Extended DOS Partition while logical drives exist.<W>',0
 42480 0000983C 742064656C65746520-
 42481 00009845 457874656E64656420-
 42482 0000984E 444F53205061727469-
 42483 00009857 74696F6E207768696C-
 42484 00009860 65206C6F676963616C-
 42485 00009869 206472697665732065-
 42486 00009872 786973742E3C573E00 
 42487 0000987B 063232303406            error_22:	db 6,'2204',6
 42488 00009881 3C43483E416C6C206C-     		db '<CH>All logical drives deleted in the Extended DOS Partition.<W>',0
 42489 0000988A 6F676963616C206472-
 42490 00009893 697665732064656C65-
 42491 0000989C 74656420696E207468-
 42492 000098A5 6520457874656E6465-
 42493 000098AE 6420444F5320506172-
 42494 000098B7 746974696F6E2E3C57-
 42495 000098C0 3E00               
 42496 000098C2 063232303406            error_23:	db 6,'2204',6
 42497 000098C8 3C433E20                		db '<C> '
 42498 000098CC 063031303406            		db 6,'0104',6
 42499 000098D2 3C4348493E20697320-     		db '<CHI> is not a choice. Please enter <III>.<W>',0
 42500 000098DB 6E6F7420612063686F-
 42501 000098E4 6963652E20506C6561-
 42502 000098ED 736520656E74657220-
 42503 000098F6 3C4949493E2E3C573E-
 42504 000098FF 00                 
 42505 00009900 063232303406            error_24:	db 6,'2204',6
 42506 00009906 3C43483E5741524E49-     		db '<CH>WARNING! The partition set active is not startable.<W>',0
 42507 0000990F 4E4721205468652070-
 42508 00009918 6172746974696F6E20-
 42509 00009921 736574206163746976-
 42510 0000992A 65206973206E6F7420-
 42511 00009933 737461727461626C65-
 42512 0000993C 2E3C573E00         
 42513 00009941 063232303406            error_25:	db 6,'2204',6
 42514 00009947 3C43483E204F6E6C79-     		db '<CH> Only non-startable partitions exist. '
 42515 00009950 206E6F6E2D73746172-
 42516 00009959 7461626C6520706172-
 42517 00009962 746974696F6E732065-
 42518 0000996B 786973742E20       
 42519 00009971 063031303006            		db 6,'0100',6
 42520 00009977 3C43573E00              		db '<CW>',0
 42521 0000997C 063232303406            error_26:	db 6,'2204',6
 42522 00009982 3C43483E4F6E6C7920-     		db '<CH>Only partitions on Drive 1 can be made active.<W>',0
 42523 0000998B 706172746974696F6E-
 42524 00009994 73206F6E2044726976-
 42525 0000999D 6520312063616E2062-
 42526 000099A6 65206D616465206163-
 42527 000099AF 746976652E3C573E00 
 42528 000099B8 063232303406            error_27:	db 6,'2204',6
 42529 000099BE 3C43483E4D6178696D-     		db '<CH>Maximum number of Logical DOS Drives installed.<W>',0
 42530 000099C7 756D206E756D626572-
 42531 000099D0 206F66204C6F676963-
 42532 000099D9 616C20444F53204472-
 42533 000099E2 6976657320696E7374-
 42534 000099EB 616C6C65642E3C573E-
 42535 000099F4 00                 
 42536 000099F5 063232303406            error_28:	db 6,'2204',6
 42537 000099FB 3C43483E43616E6E6F-     		db '<CH>Cannot create a zero size partition. '
 42538 00009A04 742063726561746520-
 42539 00009A0D 61207A65726F207369-
 42540 00009A16 7A6520706172746974-
 42541 00009A1F 696F6E2E20         
 42542 00009A24 063031303006            		db 6,'0100',6
 42543 00009A2A 3C43573E00              		db '<CW>',0
 42544 00009A2F 063232303406            error_29:	db 6,'2204',6
 42545 00009A35 3C43483E4472697665-     		db '<CH>Drive <II> already deleted. '
 42546 00009A3E 203C49493E20616C72-
 42547 00009A47 656164792064656C65-
 42548 00009A50 7465642E20         
 42549 00009A55 063031303006            		db 6,'0100',6
 42550 00009A5B 3C43573E00              		db '<CW>',0
 42551 00009A60 063232303406            error_30:	db 6,'2204',6
 42552 00009A66 3C4348423E556E6162-     		db '<CHB>Unable to access Drive <I>.<OW>',0
 42553 00009A6F 6C6520746F20616363-
 42554 00009A78 657373204472697665-
 42555 00009A81 203C493E2E3C4F573E-
 42556 00009A8A 00                 
 42557 00009A8B 063233303406            error_31:	db 6,'2304',6
 42558 00009A91 3C43483E496E76616C-     		db '<CH>Invalid entry, please enter <III>.<W>',0
 42559 00009A9A 696420656E7472792C-
 42560 00009AA3 20706C656173652065-
 42561 00009AAC 6E746572203C494949-
 42562 00009AB5 3E2E3C573E00       
 42563 00009ABB 063232303406            error_32:	db 6,'2204',6
 42564 00009AC1 3C43483E43616E6E6F-     		db '<CH>Cannot delete Primary DOS Partition on drive 1  '
 42565 00009ACA 742064656C65746520-
 42566 00009AD3 5072696D6172792044-
 42567 00009ADC 4F5320506172746974-
 42568 00009AE5 696F6E206F6E206472-
 42569 00009AEE 69766520312020     
 42570 00009AF5 063031303406            		db 6,'0104',6
 42571 00009AFB 3C43483E7768656E20-     		db '<CH>when an Extended DOS Partition exists.<W>',0
 42572 00009B04 616E20457874656E64-
 42573 00009B0D 656420444F53205061-
 42574 00009B16 72746974696F6E2065-
 42575 00009B1F 78697374732E3C573E-
 42576 00009B28 00                 
 42577 00009B29 063232303006            error_33:	db 6,'2200',6
 42578 00009B2F 3C433E20                		db '<C> '
 42579 00009B33 063031303406            		db 6,'0104',6
 42580 00009B39 3C43483E496E76616C-     		db '<CH>Invalid entry.<W>',0
 42581 00009B42 696420656E7472792E-
 42582 00009B4B 3C573E00           
 42583 00009B4F 063232303406            error_34:	db 6,'2204',6
 42584 00009B55 3C43483E566F6C756D-     		db '<CH>Volume label does not match.<W>',0
 42585 00009B5E 65206C6162656C2064-
 42586 00009B67 6F6573206E6F74206D-
 42587 00009B70 617463682E3C573E00 
 42588 00009B79 063232303406            error_35:	db 6,'2204',6
 42589 00009B7F 3C43483E43616E6E6F-     		db '<CH>Cannot create Logical DOS Drive without '
 42590 00009B88 742063726561746520-
 42591 00009B91 4C6F676963616C2044-
 42592 00009B9A 4F5320447269766520-
 42593 00009BA3 776974686F757420   
 42594 00009BAB 063031303406            		db 6,'0104',6
 42595 00009BB1 3C43483E616E204578-     		db '<CH>an Extended DOS Partition on the current drive.<W>',0
 42596 00009BBA 74656E64656420444F-
 42597 00009BC3 532050617274697469-
 42598 00009BCC 6F6E206F6E20746865-
 42599 00009BD5 2063757272656E7420-
 42600 00009BDE 64726976652E3C573E-
 42601 00009BE7 00                 
 42602 00009BE8 063232303406            error_36:	db 6,'2204',6
 42603 00009BEE 3C43483E4E6F204C6F-     		db '<CH>No Logical DOS Drive(s) to delete. '
 42604 00009BF7 676963616C20444F53-
 42605 00009C00 204472697665287329-
 42606 00009C09 20746F2064656C6574-
 42607 00009C12 652E20             
 42608 00009C15 063031303006            		db 6,'0100',6
 42609 00009C1B 3C43573E00              		db '<CW>',0
 42610 00009C20 063232303406            error_37:	db 6,'2204',6
 42611 00009C26 3C43483E5061727469-     		db '<CH>Partition selected is not a Primary DOS Partition '
 42612 00009C2F 74696F6E2073656C65-
 42613 00009C38 63746564206973206E-
 42614 00009C41 6F742061205072696D-
 42615 00009C4A 61727920444F532050-
 42616 00009C53 6172746974696F6E20 
 42617 00009C5C 063031303006            		db 6,'0100',6
 42618 00009C62 3C43573E00              		db '<CW>',0
 42619 00009C67 063232303406            error_38:	db 6,'2204',6
 42620 00009C6D 3C43483E4E6F204E6F-     		db '<CH>No Non-DOS Partition to delete. '
 42621 00009C76 6E2D444F5320506172-
 42622 00009C7F 746974696F6E20746F-
 42623 00009C88 2064656C6574652E20 
 42624 00009C91 063031303006            		db 6,'0100',6
 42625 00009C97 3C43573E00              		db '<CW>',0
 42626 00009C9C 063232303406            error_39:	db 6,'2204',6
 42627 00009CA2 3C43483E5061727469-     		db '<CH>Partition selected is not a Non-DOS Partition '
 42628 00009CAB 74696F6E2073656C65-
 42629 00009CB4 63746564206973206E-
 42630 00009CBD 6F742061204E6F6E2D-
 42631 00009CC6 444F53205061727469-
 42632 00009CCF 74696F6E20         
 42633 00009CD4 063031303006            		db 6,'0100',6
 42634 00009CDA 3C43573E00              		db '<CW>',0
 42635                                  
 42636                                  ;-- FDISK.MSG (MSDOS 6.0, FDISK) --
 42637                                  ;/*                                                                      */
 42638                                  ;/* The following message is only included as an aide to debug message   */
 42639                                  ;/* strings during translations. The FDISK message formatter will attempt*/
 42640                                  ;/* to the best of its ability to catch invalid message strings and      */
 42641                                  ;/* print the error. This message should NEVER appear for a user, so it  */
 42642                                  ;/* is not neccessary to translate this message                          */
 42643                                  ;/*                                                                      */
 42644                                  
 42645                                  debug_msg:
 42646 00009CDF 063232303006            		db 6,'2200',6
 42647 00009CE5 3C4857423E4D657373-     		db '<HWB>Message string error <I>. See header of FDISKC.MSG for error'
 42648 00009CEE 61676520737472696E-
 42649 00009CF7 67206572726F72203C-
 42650 00009D00 493E2E205365652068-
 42651 00009D09 6561646572206F6620-
 42652 00009D12 464449534B432E4D53-
 42653 00009D1B 4720666F7220657272-
 42654 00009D24 6F72               
 42655 00009D26 20646566696E697469-     		db ' definition',0
 42656 00009D2F 6F6E00             
 42657                                  
 42658                                  internal_error:
 42659 00009D32 063232303406            		db 6,'2204',6
 42660 00009D38 3C4842573E496E7465-     		db '<HBW>Internal error',0
 42661 00009D41 726E616C206572726F-
 42662 00009D4A 7200               
 42663                                  ; 14/12/2018
 42664                                  stack_error:
 42665 00009D4C 063232303406            		db 6,'2204',6
 42666 00009D52 3C4842573E53746163-     		db '<HBW>Stack overflow',0
 42667 00009D5B 6B206F766572666C6F-
 42668 00009D64 7700               
 42669                                  fp_error:
 42670 00009D66 063232303406            		db 6,'2204',6
 42671 00009D6C 3C4842573E466C6F61-     		db '<HBW>Floating-point support not loaded',0
 42672 00009D75 74696E672D706F696E-
 42673 00009D7E 7420737570706F7274-
 42674 00009D87 206E6F74206C6F6164-
 42675 00009D90 656400             
 42676                                  
 42677                                  ;-- FDISK.MSG (MSDOS 6.0, FDISK) --
 42678                                  ;/*                                                                      */
 42679                                  ;/* The following are not translatable. They are the partition names     */
 42680                                  ;/*                                                                      */
 42681                                  
 42682 00009D93 2A2052656D6F746520-     txtRemote:	db '* Remote * ',0
 42683 00009D9C 2A2000             
 42684 00009D9F 50524920444F5300        txtPriDos:	db 'PRI DOS',0
 42685 00009DA7 2058454E49582000        txtXenix:	db ' XENIX ',0
 42686 00009DAF 45585420444F5300        txtExtDos:	db 'EXT DOS',0
 42687 00009DB7 205461626C652000        txtTable:	db ' Table ',0
 42688 00009DBF 2050432F49582000        txtPcIx:	db ' PC/IX ',0
 42689                                  ;txtHpFs	db ' HPFS  ',0
 42690 00009DC7 204E544653202000        txtNTFS:	db ' NTFS  ',0 ; 17/11/2018	
 42691 00009DCF 4E4F56454C4C2000        txtNovell:	db 'NOVELL ',0
 42692 00009DD7 2043502F4D202000        txtCpM:		db ' CP/M  ',0
 42693 00009DDF 4E6F6E2D444F5300        txtNonDos:	db 'Non-DOS',0
 42694                                  
 42695                                  ; MENU (FORMATTED) TEXT ADDRESS POINTERS
 42696                                  ; 01/12/2018
 42697                                  
 42698 00009DE7 [5371]                  menu_1_offset:	dw menu_1
 42699                                  ;menu_1_segment: dw DGROUP
 42700 00009DE9 [0872]                  menu_2_offset: dw menu_2
 42701                                  ;menu_2_segment: dw DGROUP
 42702 00009DEB [2273]                  menu_3_offset: dw menu_3
 42703                                  ;menu_3_segment: dw DGROUP
 42704 00009DED [4873]                  menu_4_offset: dw menu_4
 42705                                  ;menu_4_segment: dw DGROUP
 42706 00009DEF [7773]                  menu_5_offset: dw menu_5
 42707                                  ;menu_5_segment: dw DGROUP
 42708 00009DF1 [A173]                  menu_6_offset: dw menu_6
 42709                                  ;menu_6_segment: dw DGROUP
 42710 00009DF3 [1774]                  menu_7_offset: dw menu_7
 42711                                  ;menu_7_segment: dw DGROUP
 42712 00009DF5 [3874]                  menu_8_offset: dw menu_8
 42713                                  ;menu_8_segment: dw DGROUP
 42714 00009DF7 [7B74]                  menu_9_offset: dw menu_9
 42715                                  ;menu_9_segment: dw DGROUP
 42716 00009DF9 [D474]                  menu_10_offset: dw menu_10
 42717                                  ;menu_10_segment: dw DGROUP
 42718 00009DFB [1D75]                  menu_11_offset: dw menu_11
 42719                                  ;menu_11_segment: dw DGROUP
 42720 00009DFD [5175]                  menu_12_offset: dw menu_12
 42721                                  ;menu_12_segment: dw DGROUP
 42722 00009DFF [8D75]                  menu_13_offset: dw menu_13
 42723                                  ;menu_13_segment: dw DGROUP
 42724 00009E01 [3176]                  menu_45_offset: dw menu_45
 42725                                  ;menu_45_segment: dw DGROUP
 42726 00009E03 [D576]                  menu_14_offset: dw menu_14
 42727                                  ;menu_14_segment: dw DGROUP
 42728 00009E05 [9478]                  menu_15_offset: dw menu_15
 42729                                  ;menu_15_segment: dw DGROUP
 42730 00009E07 [DB78]                  menu_16_offset: dw menu_16
 42731                                  ;menu_16_segment: dw DGROUP
 42732 00009E09 [2979]                  menu_39_offset: dw menu_39
 42733                                  ;menu_39_segment: dw DGROUP
 42734 00009E0B [CA79]                  menu_17_offset: dw menu_17
 42735                                  ;menu_17_segment: dw DGROUP
 42736 00009E0D [077A]                  menu_42_offset: dw menu_42
 42737                                  ;menu_42_segment: dw DGROUP
 42738 00009E0F [A77A]                  menu_46_offset: dw menu_46
 42739                                  ;menu_46_segment: dw DGROUP
 42740 00009E11 [CF7A]                  menu_18_offset: dw menu_18
 42741                                  ;menu_18_segment: dw DGROUP
 42742 00009E13 [1A7B]                  menu_19_offset: dw menu_19
 42743                                  ;menu_19_segment: dw DGROUP
 42744 00009E15 [AD7C]                  menu_43_offset: dw menu_43
 42745                                  ;menu_43_segment: dw DGROUP
 42746 00009E17 [107E]                  menu_20_offset: dw menu_20
 42747                                  ;menu_20_segment: dw DGROUP
 42748 00009E19 [A37F]                  menu_44_offset: dw menu_44
 42749                                  ;menu_44_segment: dw DGROUP
 42750 00009E1B [CB80]                  menu_21_offset: dw menu_21
 42751                                  ;menu_21_segment: dw DGROUP
 42752 00009E1D [2481]                  menu_22_offset: dw menu_22
 42753                                  ;menu_22_segment: dw DGROUP
 42754 00009E1F [7781]                  menu_40_offset: dw menu_40
 42755                                  ;menu_40_segment: dw DGROUP
 42756 00009E21 [D081]                  menu_23_offset: dw menu_23
 42757                                  ;menu_23_segment: dw DGROUP
 42758 00009E23 [0882]                  menu_24_offset: dw menu_24
 42759                                  ;menu_24_segment: dw DGROUP
 42760 00009E25 [6182]                  menu_25_offset: dw menu_25
 42761                                  ;menu_25_segment: dw DGROUP
 42762 00009E27 [A482]                  menu_26_offset: dw menu_26
 42763                                  ;menu_26_segment: dw DGROUP
 42764 00009E29 [0183]                  menu_27_offset: dw menu_27
 42765                                  ;menu_27_segment: dw DGROUP
 42766 00009E2B [4C83]                  menu_57_offset: dw menu_57
 42767                                  ;menu_57_segment: dw DGROUP
 42768 00009E2D [7683]                  menu_28_offset: dw menu_28
 42769                                  ;menu_28_segment: dw DGROUP
 42770 00009E2F [B283]                  menu_55_offset: dw menu_55
 42771                                  ;menu_55_segment: dw DGROUP
 42772 00009E31 [4884]                  menu_56_offset: dw menu_56
 42773                                  ;menu_56_segment: dw DGROUP
 42774 00009E33 [9084]                  menu_30_offset: dw menu_30
 42775                                  ;menu_30_segment: dw DGROUP
 42776 00009E35 [CD84]                  menu_31_offset: dw menu_31
 42777                                  ;menu_31_segment: dw DGROUP
 42778 00009E37 [6685]                  menu_32_offset: dw menu_32
 42779                                  ;menu_32_segment: dw DGROUP
 42780 00009E39 [B185]                  menu_33_offset: dw menu_33
 42781                                  ;menu_33_segment: dw DGROUP
 42782 00009E3B [5086]                  menu_34_offset: dw menu_34
 42783                                  ;menu_34_segment: dw DGROUP
 42784 00009E3D [9986]                  menu_41_offset: dw menu_41
 42785                                  ;menu_41_segment: dw DGROUP
 42786 00009E3F [E886]                  menu_58_offset: dw menu_58
 42787                                  ;menu_58_segment: dw DGROUP
 42788 00009E41 [2287]                  menu_59_offset: dw menu_59
 42789                                  ;menu_59_segment: dw DGROUP
 42790 00009E43 [B587]                  menu_35_offset: dw menu_35
 42791                                  ;menu_35_segment: dw DGROUP
 42792 00009E45 [F287]                  menu_36_offset: dw menu_36
 42793                                  ;menu_36_segment: dw DGROUP
 42794 00009E47 [8D88]                  menu_37_offset: dw menu_37
 42795                                  ;menu_37_segment: dw DGROUP
 42796 00009E49 [CE88]                  menu_47_offset: dw menu_47
 42797                                  ;menu_47_segment: dw DGROUP
 42798 00009E4B [0C89]                  menu_48_offset: dw menu_48
 42799                                  ;menu_48_segment: dw DGROUP
 42800 00009E4D [CA8A]                  menu_49_offset: dw menu_49
 42801                                  ;menu_49_segment: dw DGROUP
 42802 00009E4F [5B8C]                  menu_50_offset: dw menu_50
 42803                                  ;menu_50_segment: dw DGROUP
 42804 00009E51 [198E]                  menu_51_offset: dw menu_51
 42805                                  ;menu_51_segment: dw DGROUP
 42806 00009E53 [AA8F]                  menu_52_offset: dw menu_52
 42807                                  ;menu_52_segment: dw DGROUP
 42808 00009E55 [CD8F]                  menu_53_offset: dw menu_53
 42809                                  ;menu_53_segment: dw DGROUP
 42810 00009E57 [1C90]                  menu_54_offset: dw menu_54
 42811                                  ;menu_54_segment: dw DGROUP
 42812 00009E59 [5690]                  menu_38_offset: dw menu_38
 42813                                  ;menu_38_segment: dw DGROUP
 42814 00009E5B [D290]                  menu_60_offset: dw menu_60
 42815                                  ;menu_60_segment: dw DGROUP
 42816                                  
 42817                                  ; STATUS MESSAGE ADDRESS POINTERS
 42818                                  ; 01/12/2018
 42819                                  
 42820 00009E5D [1E91]                  status_1_off:	dw status_1
 42821                                  ;status_1_seg:	dw DGROUP
 42822 00009E5F [5191]                  status_2_off:	dw status_2
 42823                                  ;status_2_seg:	dw DGROUP
 42824 00009E61 [8591]                  status_3_off:	dw status_3
 42825                                  ;status_3_seg:	dw DGROUP
 42826 00009E63 [9C91]                  status_4_off:	dw status_4
 42827                                  ;status_4_seg:	dw DGROUP
 42828 00009E65 [CB91]                  status_5_off:	dw status_5
 42829                                  ;status_5_seg:	dw DGROUP
 42830 00009E67 [FE91]                  status_6_off:	dw status_6
 42831                                  ;status_6_seg:	dw DGROUP
 42832 00009E69 [3292]                  status_7_off:	dw status_7
 42833                                  ;status_7_seg:	dw DGROUP
 42834 00009E6B [7992]                  status_8_off:	dw status_8
 42835                                  ;status_8_seg:	dw DGROUP
 42836 00009E6D [A392]                  status_9_off:	dw status_9
 42837                                  ;status_9_seg:	dw DGROUP
 42838 00009E6F [D192]                  status_10_off:	dw status_10
 42839                                  ;status_10_seg:	dw DGROUP
 42840                                  ;status_11_off:	dw status_11
 42841                                  ;status_11_seg:	dw DGROUP
 42842 00009E71 [2393]                  status_12_off:	dw status_12
 42843                                  ;status_12_seg:	dw DGROUP
 42844 00009E73 [7693]                  status_13_off:	dw status_13
 42845                                  ;status_13_seg:	dw DGROUP
 42846                                  
 42847                                  ; ERROR MESSAGE ADDRESS POINTERS
 42848                                  ; 17/11/2018
 42849                                  
 42850 00009E75 90                      align 2
 42851                                  
 42852 00009E76 [A593]                  error_1_off:	dw error_1
 42853                                  ;error_1_seg:	dw DGROUP
 42854 00009E78 [D293]                  error_2_off:	dw error_2
 42855                                  ;error_2_seg:	dw DGROUP
 42856 00009E7A [0194]                  error_3_off:	dw error_3
 42857                                  ;error_3_seg:	dw DGROUP
 42858 00009E7C [3094]                  error_4_off:	dw error_4
 42859                                  ;error_4_seg:	dw DGROUP
 42860 00009E7E [5294]                  error_5_off:	dw error_5
 42861                                  ;error_5_seg:	dw DGROUP
 42862 00009E80 [7F94]                  error_6_off:	dw error_6
 42863                                  ;error_6_seg:	dw DGROUP
 42864 00009E82 [B894]                  error_7_off:	dw error_7
 42865                                  ;error_7_seg:	dw DGROUP
 42866 00009E84 [F294]                  error_8_off:	dw error_8
 42867                                  ;error_8_seg:	dw DGROUP
 42868 00009E86 [2D95]                  error_9_off:	dw error_9
 42869                                  ;error_9_seg:	dw DGROUP
 42870 00009E88 [6995]                  error_10_off:	dw error_10
 42871                                  ;error_10_seg:	dw DGROUP
 42872 00009E8A [A295]                  error_12_off:	dw error_12
 42873                                  ;error_12_seg:	dw DGROUP
 42874 00009E8C [FC95]                  error_13_off:	dw error_13
 42875                                  ;error_13_seg:	dw DGROUP
 42876 00009E8E [5296]                  error_14_off:	dw error_14
 42877                                  ;error_14_seg:	dw DGROUP
 42878 00009E90 [8096]                  error_15_off:	dw error_15
 42879                                  ;error_15_seg:	dw DGROUP
 42880 00009E92 [D796]                  error_16_off:	dw error_16
 42881                                  ;error_16_seg:	dw DGROUP
 42882 00009E94 [0A97]                  error_17_off:	dw error_17
 42883                                  ;error_17_seg:	dw DGROUP
 42884 00009E96 [6097]                  error_19_off:	dw error_19
 42885                                  ;error_19_seg:	dw DGROUP
 42886 00009E98 [C597]                  error_20_off:	dw error_20
 42887                                  ;error_20_seg:	dw DGROUP
 42888 00009E9A [2D98]                  error_21_off:	dw error_21
 42889                                  ;error_21_seg:	dw DGROUP
 42890 00009E9C [7B98]                  error_22_off:	dw error_22
 42891                                  ;error_22_seg:	dw DGROUP
 42892 00009E9E [C298]                  error_23_off:	dw error_23
 42893                                  ;error_23_seg:	dw DGROUP
 42894 00009EA0 [0099]                  error_24_off:	dw error_24
 42895                                  ;error_24_seg:	dw DGROUP
 42896 00009EA2 [4199]                  error_25_off:	dw error_25
 42897                                  ;error_25_seg:	dw DGROUP
 42898 00009EA4 [7C99]                  error_26_off:	dw error_26
 42899                                  ;error_26_seg:	dw DGROUP
 42900 00009EA6 [B899]                  error_27_off:	dw error_27
 42901                                  ;error_27_seg:	dw DGROUP
 42902 00009EA8 [F599]                  error_28_off:	dw error_28
 42903                                  ;error_28_seg:	dw DGROUP
 42904 00009EAA [2F9A]                  error_29_off:	dw error_29
 42905                                  ;error_29_seg:	dw DGROUP
 42906 00009EAC [609A]                  error_30_off:	dw error_30
 42907                                  ;error_30_seg:	dw DGROUP
 42908 00009EAE [8B9A]                  error_31_off:	dw error_31
 42909                                  ;error_31_seg:	dw DGROUP
 42910 00009EB0 [BB9A]                  error_32_off:	dw error_32
 42911                                  ;error_32_seg:	dw DGROUP
 42912 00009EB2 [299B]                  error_33_off:	dw error_33
 42913                                  ;error_33_seg:	dw DGROUP
 42914 00009EB4 [4F9B]                  error_34_off:	dw error_34
 42915                                  ;error_34_seg:	dw DGROUP
 42916 00009EB6 [799B]                  error_35_off:	dw error_35
 42917                                  ;error_35_seg:	dw DGROUP
 42918 00009EB8 [E89B]                  error_36_off:	dw error_36
 42919                                  ;error_36_seg:	dw DGROUP
 42920 00009EBA [209C]                  error_37_off:	dw error_37
 42921                                  ;error_37_seg:	dw DGROUP
 42922 00009EBC [679C]                  error_38_off:	dw error_38
 42923                                  ;error_38_seg:	dw DGROUP
 42924 00009EBE [9C9C]                  error_39_off:	dw error_39
 42925                                  ;error_39_seg:	dw DGROUP
 42926                                  
 42927 00009EC0 [DF9C]                  debug_msg_off:	dw debug_msg
 42928                                  ;debug_msg_seg:	dw DGROUP
 42929                                  
 42930                                  ; 18/12/2018
 42931 00009EC2 [329D]                  inter_err_off:	dw internal_error
 42932                                  ;inter_err_seg:	dw DGROUP
 42933                                  
 42934                                  ; 14/12/2018
 42935                                  stackerror_msg_off:
 42936 00009EC4 [4C9D]                  		dw stack_error
 42937                                  ;stackerror_msg_seg:
 42938                                  ;		dw DGROUP		 
 42939                                  
 42940                                  fperror_msg_off:
 42941 00009EC6 [669D]                  		dw fp_error
 42942                                  ;fperror_msg_seg:
 42943                                  ;		de DGROUP
 42944                                  
 42945                                  ; 26/11/2018
 42946 00009EC8 [939D]                  REMOTE:		dw txtRemote
 42947 00009ECA [9F9D]                  PRIDOS:		dw txtPriDos
 42948 00009ECC [A79D]                  XENIX:		dw txtXenix
 42949 00009ECE [AF9D]                  EXTDOS:		dw txtExtDos
 42950 00009ED0 [B79D]                  TABLE:		dw txtTable
 42951 00009ED2 [BF9D]                  PCIX:		dw txtPcIx
 42952                                  ;HPFS:		dw txtHpFs
 42953 00009ED4 [C79D]                  NTFS:		dw txtNTFS
 42954 00009ED6 [CF9D]                  NOVELL:		dw txtNovell
 42955 00009ED8 [D79D]                  CPM:		dw txtCpM
 42956 00009EDA [DF9D]                  NONDOS:		dw txtNonDos
 42957                                  
 42958                                  ; 07/12/2018
 42959                                  ;_atopsp:	dw 0
 42960                                  ;_aexit_rtn:	dw _exit_
 42961                                  ;_asizds:	dw 0
 42962                                  
 42963                                  ; 14/12/2018 (no need to  _nheap_desc)
 42964                                  ; 09/12/2018
 42965 00009EDC 0000050000000000        _nheap_desc:	db 0, 0, 5, 0, 0, 0, 0,	0
 42966 00009EE4 0000000000000000        		db 0, 0, 0, 0, 0, 0, 0,	0
 42967 00009EEC 0000000000000000        		db 0, 0, 0, 0, 0, 0, 0,	0
 42968                                  
 42969 00009EF4 0000                    errno:		dw 0
 42970                                  
 42971                                  ;umaskval:	dw 0
 42972                                  ;_pspadr:	dw 0
 42973 00009EF6 0000                    _psp:		dw 0
 42974                                  
 42975 00009EF8 00                      _dosvermajor:	db 0
 42976 00009EF9 00                      _dosverminor:	db 0
 42977                                  
 42978                                  ; 14/12/2018 (cleaning)
 42979                                  
 42980                                  ;;_osmode	db 0
 42981                                  
 42982                                  ;_doserrno:	dw 0
 42983                                  ;_nfile		dw 20
 42984                                  ;
 42985                                  ;_osfile:	db 81h,81h,81h
 42986                                  ;		db 01h,01h
 42987                                  ;		times 15 db 0	
 42988                                  
 42989                                  ; 17/11/2018
 42990                                  
 42991                                  ; ctype.h (MSDOS 6.0)
 42992                                  
 42993                                  ;/* set bit masks for the possible character types */
 42994                                  
 42995                                  ;#define _UPPER        0x1       /* upper case letter */
 42996                                  ;#define _LOWER        0x2       /* lower case letter */
 42997                                  ;#define _DIGIT        0x4       /* digit[0-9] */
 42998                                  ;#define _SPACE        0x8       /* tab, carriage return, newline, */
 42999                                  ;                                /* vertical tab or form feed */
 43000                                  ;#define _PUNCT       0x10       /* punctuation character */
 43001                                  ;#define _CONTROL     0x20       /* control character */
 43002                                  ;#define _BLANK       0x40       /* space char */
 43003                                  ;#define _HEX         0x80       /* hexadecimal digit */
 43004                                  
 43005                                  ;/* the character classification macro definitions */
 43006                                  
 43007                                  ;#define isalpha(c)      ( (_ctype+1)[c] & (_UPPER|_LOWER) )
 43008                                  ;#define isupper(c)      ( (_ctype+1)[c] & _UPPER )
 43009                                  ;#define islower(c)      ( (_ctype+1)[c] & _LOWER )
 43010                                  ;#define isdigit(c)      ( (_ctype+1)[c] & _DIGIT )
 43011                                  ;#define isxdigit(c)     ( (_ctype+1)[c] & _HEX )
 43012                                  ;#define isspace(c)      ( (_ctype+1)[c] & _SPACE )
 43013                                  ;#define ispunct(c)      ( (_ctype+1)[c] & _PUNCT )
 43014                                  ;#define isalnum(c)      ( (_ctype+1)[c] & (_UPPER|_LOWER|_DIGIT) )
 43015                                  ;#define isprint(c)      ( (_ctype+1)[c] & (_BLANK|_PUNCT|_UPPER|_LOWER|_DIGIT) )
 43016                                  ;#define isgraph(c)      ( (_ctype+1)[c] & (_PUNCT|_UPPER|_LOWER|_DIGIT) )
 43017                                  ;#define iscntrl(c)      ( (_ctype+1)[c] & _CONTROL )
 43018                                  ;
 43019                                  ;#define toupper(c)      ( (islower(c)) ? _toupper(c) : (c) )
 43020                                  ;#define tolower(c)      ( (isupper(c)) ? _tolower(c) : (c) )
 43021                                  ;
 43022                                  ;#define _tolower(c)     ( (c)-'A'+'a' )
 43023                                  ;#define _toupper(c)     ( (c)-'a'+'A' )
 43024                                  ;
 43025                                  ;#define isascii(c)      ( (unsigned)(c) < 0x80 )
 43026                                  ;#define toascii(c)      ( (c) & 0x7f )
 43027                                  
 43028                                  align 2
 43029 00009EFA 00                      	db 0
 43030                                  
 43031                                  ;isdigit(*s) -c-
 43032                                  ;[isdigit+bx] -asm-
 43033                                  
 43034                                  _ctype:		; (PC-DOS 7.0 FDISK.COM - segment 4, offset 543Eh)
 43035 00009EFB 00                      	db 0
 43036                                  isdigit: ; Table for numeric character check	; _ctype+1
 43037 00009EFC 202020202020202020-     	db 20h,	20h, 20h, 20h, 20h, 20h, 20h, 20h, 20h, 28h, 28h, 28h, 28h, 28h, 20h, 20h
 43038 00009F05 28282828282020     
 43039 00009F0C 202020202020202020-     	db 20h,	20h, 20h, 20h, 20h, 20h, 20h, 20h, 20h,	20h, 20h, 20h, 20h, 20h, 20h, 20h
 43040 00009F15 20202020202020     
 43041 00009F1C 481010101010101010-     	db 48h,	10h, 10h, 10h, 10h, 10h, 10h, 10h, 10h,	10h, 10h, 10h, 10h, 10h, 10h, 10h
 43042 00009F25 10101010101010     
 43043 00009F2C 848484848484848484-     	db 84h,	84h, 84h, 84h, 84h, 84h, 84h, 84h, 84h,	84h, 10h, 10h, 10h, 10h, 10h, 10h
 43044 00009F35 84101010101010     
 43045 00009F3C 108181818181810101-     	db 10h,	81h, 81h, 81h, 81h, 81h, 81h, 01h, 01h,	01h, 01h, 01h, 01h, 01h, 01h, 01h
 43046 00009F45 01010101010101     
 43047 00009F4C 010101010101010101-     	db 01h,	01h, 01h, 01h, 01h, 01h, 01h, 01h, 01h,	01h, 01h, 10h, 10h, 10h, 10h, 10h
 43048 00009F55 01011010101010     
 43049 00009F5C 108282828282820202-     	db 10h,	82h, 82h, 82h, 82h, 82h, 82h, 02h, 02h,	02h, 02h, 02h, 02h, 02h, 02h, 02h
 43050 00009F65 02020202020202     
 43051 00009F6C 020202020202020202-     	db 02h,	02h, 02h, 02h, 02h, 02h, 02h, 02h, 02h,	02h, 02h, 10h, 10h, 10h, 10h, 20h
 43052 00009F75 02021010101020     
 43053 00009F7C 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 43054 00009F85 00000000000000     
 43055 00009F8C 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 43056 00009F95 00000000000000     
 43057 00009F9C 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 43058 00009FA5 00000000000000     
 43059 00009FAC 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 43060 00009FB5 00000000000000     
 43061 00009FBC 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 43062 00009FC5 00000000000000     
 43063 00009FCC 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 43064 00009FD5 00000000000000     
 43065 00009FDC 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 43066 00009FE5 00000000000000     
 43067 00009FEC 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 43068 00009FF5 00000000000000     
 43069                                  
 43070                                  ; 26/11/2018
 43071                                  
 43072                                  ;align 2
 43073                                  ;_cpush:	dw 0FFFFh
 43074                                  ;retadr:	dw 0
 43075                                  
 43076                                  ; 14/12/2018 (no need to err_conv_tbl)
 43077                                  ;err_conv_tbl:
 43078                                  ;		db 00h,	16h, 02h, 02h, 18h, 0Dh, 09h, 0Ch, 0Ch,	0Ch
 43079                                  ;		db 07h,	08h, 16h, 16h, 0FFh, 02h, 0Dh, 12h, 02h, 0FFh
 43080                                  
 43081                                  ; 06/12/2018
 43082                                  	; The following defines the lookup table for changing states
 43083                                  	; This is actually two table combined into one.
 43084                                  	; The lower nybble of each byte gives the character
 43085                                  	; class of any character -- i.e.
 43086                                  	;   charclass = lookuptable[char-' '] & 0xF;
 43087                                  	; The upper nybble of each byte gives the next state to enter -- i.e.
 43088                                  	;   newstate = looptable[charclass][oldstate] >> 4;
 43089                                  
 43090                                  	; The table below is generated by maketab.c -- use this program
 43091                                  	; to make changes.
 43092                                  
 43093 00009FFC 0600000600010000        lookuptable:	db 06h, 00h, 00h, 06h, 00h, 01h, 00h, 00h
 43094 0000A004 1000030600060210        		db 10h, 00h, 03h, 06h, 00h, 06h, 02h, 10h
 43095 0000A00C 0445454505050505        		db 04h, 45h, 45h, 45h, 05h, 05h, 05h, 05h
 43096 0000A014 0535300050000000        		db 05h, 35h, 30h, 00h, 50h, 00h, 00h, 00h
 43097 0000A01C 0020203050580708        		db 00h, 20h, 20h, 30h, 50h, 58h, 07h, 08h
 43098 0000A024 0030303057500700        		db 00h, 30h, 30h, 30h, 57h, 50h, 07h, 00h
 43099 0000A02C 0020200000000000        		db 00h, 20h, 20h, 00h, 00h, 00h, 00h, 00h
 43100 0000A034 0860606060606000        		db 08h, 60h, 60h, 60h, 60h, 60h, 60h, 00h
 43101 0000A03C 0070707878787808        		db 00h, 70h, 70h, 78h, 78h, 78h, 78h, 08h
 43102 0000A044 0708000007000808        		db 07h, 08h, 00h, 00h, 07h, 00h, 08h, 08h
 43103 0000A04C 0800000800080000        		db 08h, 00h, 00h, 08h, 00h, 08h, 00h, 00h
 43104 0000A054 08                      		db 08h
 43105                                  
 43106 0000A055 286E756C6C29            nullstring:	db '(null)'
 43107 0000A05B 0600                    nullstrlen:	dw 6	; string to print when null string passed
 43108                                  
 43109 0000A05D 90                      		align 2
 43110 0000A05E FFFF                    		dw 0FFFFh
 43111                                  end_of_bss:	
 43112                                  		;dw 8B10h   ; File Size + BSS
 43113 0000A060 [16D0]                  		dw end_of_file ; 10/12/2018
 43114                                  
 43115                                  ; 14/12/2018 (cleaning)
 43116                                  
 43117                                  ; 07/12/2018
 43118                                  ;_iob:
 43119                                  ;STDIN:		dw _bufin
 43120                                  ;STDIN_cnt:	dw 0
 43121                                  ;STDIN_base:	dw _bufin
 43122                                  ;STDIN_flag:	db 1
 43123                                  ;STDIN_file:	db 0
 43124                                  ;
 43125                                  ;STDOUT:	dw 0
 43126                                  ;STDOUT_cnt:	dw 0
 43127                                  ;STDOUT_base:	dw 0
 43128                                  ;STDOUT_flag:	db 2
 43129                                  ;STDOUT_file:	db 1
 43130                                  ;
 43131                                  ;STDERR:	dw 0
 43132                                  ;STDERR_cnt:	dw 0
 43133                                  ;STDERR_base:	dw 0
 43134                                  ;STDERR_flag:	db 2
 43135                                  ;STDERR_file:	db 2
 43136                                  ;
 43137                                  ;STDAUX:	dw 0
 43138                                  ;STDAUX_cnt:	dw 0
 43139                                  ;STDAUX_base:	dw 0
 43140                                  ;STDAUX_flag:	db 84h
 43141                                  ;STDAUX_file:	db 3
 43142                                  ;
 43143                                  ;STDPRN:	dw 0
 43144                                  ;STDPRN_cnt:	dw 0
 43145                                  ;STDPRN_base:	dw 0
 43146                                  ;STDPRN_flag:	db 2
 43147                                  ;STDPRN_file:	db 4
 43148                                  ;
 43149                                  ;	times 120 db 0
 43150                                  ;
 43151                                  ;_iob2:
 43152                                  ;_iob2_flag2:	db 1
 43153                                  ;_iob2_charbuf:	db 0
 43154                                  ;_iob2_bufsiz:	dw 512
 43155                                  ;_iob2_tmpnum:	dw 0
 43156                                  ;_iob2_padding:	dw 0
 43157                                  ;		
 43158                                  ;	times 152 db 0
 43159                                  
 43160                                  ; CMISTDAT.ASM ; miscellaneous C run-time data
 43161                                  ; MSDOS Visual C++ 1.0
 43162                                  
 43163                                  ;_cfltcvt_tab:
 43164 0000A062 [5C2A]                  _cfltcvt:	dw _fptrap
 43165 0000A064 [5C2A]                  _cropzeros	dw _fptrap
 43166                                  ;		dw _fptrap
 43167 0000A066 [5C2A]                  _forcdecpt	dw _fptrap
 43168                                  ;		dw _fptrap
 43169 0000A068 [5C2A]                  _cldcvt:	dw _fptrap
 43170                                  ;	
 43171                                  ;	times 8 db 0
 43172                                  ;_amblksiz:	dw 2000h ; 09/12/2018
 43173                                  ;_aDBswpflg:	dw 0
 43174                                  ;_aDBswpchk:	dw _aDBretaddr
 43175                                  ;_aDBrterr:	dw _aDBretaddr
 43176                                  ;_aDBexit:	dw _aDBretaddr
 43177                                  ;	
 43178                                  ;	times 4 db 0
 43179                                  ; 
 43180                                  ; 13/12/2018
 43181                                  ;strbuf:	; Stream Buffer (for sprintf)
 43182                                  ;_strbuf_ptr:	dw 7E7Eh
 43183                                  ;_strbuf_cnt:	dw 7E7Eh
 43184                                  ;_strbuf_base:	dw 7E7Eh
 43185                                  ;_strbuf_flag:	db 7Eh
 43186                                  ;_strbuf_file:	db 7Eh
 43187                                  ;
 43188                                  ;xontab:	db 7Eh
 43189                                  ;		db 7Eh
 43190                                  
 43191                                  ;=============================================================================
 43192                                  ;        	uninitialized data
 43193                                  ;=============================================================================
 43194                                  
 43195                                  bss_start:
 43196                                  
 43197                                  ABSOLUTE bss_start
 43198                                  
 43199                                  alignb 2
 43200                                  
 43201                                  ; SEGMENT 4 - DGROUP ---------------------------------------------------------
 43202                                  
 43203 0000A06A <res 00000001>          reboot_flag:	resb 1
 43204 0000A06B <res 00000011>          dx_buff:	resb 17
 43205 0000A07C <res 00000008>          dx_buff_file_system: resb 8
 43206 0000A084 <res 00000001>          video_mode:	resb 1
 43207 0000A085 <res 00000001>          		resb 1
 43208                                  p_px:					; PARMSX block structure
 43209 0000A086 <res 00000001>          p_px_p_minp:	 resb 1			; Minimum positional number
 43210 0000A087 <res 00000001>          p_px_p_maxp:	 resb 1			; Maximum positional number
 43211 0000A088 <res 00000002>          p_px_p_con1_ptr: resw 1			; Address of the 1st CONTROL block
 43212 0000A08A <res 00000001>          p_px_p_maxs:	 resb 1			; # OF SWITCHES
 43213 0000A08B <res 00000002>          p_px_p_swi1_ptr: resw 1			; DESCRIPTION OF SWITCH 1
 43214 0000A08D <res 00000002>          p_px_p_swi2_ptr: resw 1			; REPEATS maxs-1 TIMES
 43215 0000A08F <res 00000002>          p_px_p_swi3_ptr: resw 1
 43216 0000A091 <res 00000002>          p_px_p_swi4_ptr: resw 1
 43217 0000A093 <res 00000002>          p_px_p_swi5_ptr: resw 1
 43218 0000A095 <res 00000001>          p_px_p_maxk:	 resb 1			; # OF KEYWORDS
 43219                                  
 43220 0000A096 <res 00000001>          disk_flag:	 resb 1
 43221                                  p_p:					; PARMS block structure
 43222 0000A097 <res 00000002>          p_p_p_parmxs_ptr:      resw 1		; Address of PARMSX		
 43223 0000A099 <res 00000001>          p_p_p_num_extra:       resb 1		; Number of extra stuff
 43224 0000A09A <res 00000001>          p_p_p_len_extra_delim: resb 1		; Length of extra delimiter
 43225 0000A09B <res 00000001>          p_p_p_extra_delim:     resb 1		; Extra delimiter
 43226                                  
 43227 0000A09C <res 00000002>          input_col:	resw 1
 43228 0000A09E <res 00000001>          No:		resb 1
 43229 0000A09F <res 00000001>          		resb 1
 43230                                  
 43231 0000A0A0 <res 00000008>          max_sector:	resb 8
 43232 0000A0A8 <res 00000010>          max_head:	resw 8
 43233 0000A0B8 <res 00000010>          total_disk:	resw 8
 43234 0000A0C8 <res 00000010>          total_mbytes:	resw 8
 43235                                  
 43236 0000A0D8 <res 00000004>          		resw 2
 43237                                  ;regs:
 43238                                  ;regs_x_ax:	resw 1
 43239                                  ;regs_x_bx:	resw 1
 43240                                  ;regs_x_cx:	resw 1
 43241                                  ;regs_x_dx:	resw 1
 43242                                  ;regs_x_si:	resw 1
 43243                                  ;regs_x_di:	resw 1
 43244                                  ;regs_x_cflag:	resb 1
 43245                                  ;		resb 1
 43246                                  
 43247 0000A0DC <res 00000001>          sublistp_size:	    resb 1
 43248 0000A0DD <res 00000001>          sublistp_res:	    resb 1
 43249 0000A0DE <res 00000002>          sublistp_value:	    resw 1
 43250 0000A0E0 <res 00000002>          sublistp_value_seg: resw 1
 43251 0000A0E2 <res 00000001>          sublistp_id:	    resb 1
 43252 0000A0E3 <res 00000001>          sublistp_flags:	    resb 1
 43253 0000A0E4 <res 00000001>          sublistp_max_width: resb 1
 43254 0000A0E5 <res 00000001>          sublistp_min_width: resb 1
 43255 0000A0E6 <res 00000001>          sublistp_pad_char:  resb 1
 43256 0000A0E7 <res 00000001>          		resb 1
 43257                                  p_swi1:
 43258 0000A0E8 <res 00000002>          p_swi1_sp_match_flag:	 resw 1
 43259 0000A0EA <res 00000002>          p_swi1_sp_function_flag: resw 1
 43260 0000A0EC <res 00000002>          p_swi1_sp_buff1_ptr:	 resw 1
 43261 0000A0EE <res 00000002>          p_swi1_sp_val1_ptr:	 resw 1
 43262 0000A0F0 <res 00000001>          p_swi1_sp_nid:		 resb 1
 43263 0000A0F1 <res 00000005>          p_swi1_sp_switch1:	 resb 5
 43264 0000A0F6 <res 00000005>          p_swi1_sp_switch2:	 resb 5
 43265 0000A0FB <res 00000005>          p_swi1_sp_switch3:	 resb 5
 43266 0000A100 <res 00000001>          primary_flag:	resb 1
 43267 0000A101 <res 00000001>          		resb 1
 43268                                  
 43269                                  p_swi2:
 43270 0000A102 <res 00000002>          p_swi2_sp_match_flag:	 resw 1
 43271 0000A104 <res 00000002>          p_swi2_sp_function_flag: resw 1
 43272 0000A106 <res 00000002>          p_swi2_sp_buff1_ptr:	 resw 1
 43273 0000A108 <res 00000002>          p_swi2_sp_val1_ptr:	 resw 1
 43274 0000A10A <res 00000001>          p_swi2_sp_nid:		 resb 1
 43275 0000A10B <res 00000003>          p_swi2_sp_switch4:	 resb 3
 43276                                  
 43277                                  p_swi3:
 43278 0000A10E <res 00000002>          p_swi3_sp_match_flag:	 resw 1
 43279 0000A110 <res 00000002>          p_swi3_sp_function_flag: resw 1
 43280 0000A112 <res 00000002>          p_swi3_sp_buff1_ptr:	 resw 1
 43281 0000A114 <res 00000002>          p_swi3_sp_val1_ptr:	 resw 1
 43282 0000A116 <res 00000001>          p_swi3_sp_nid:		 resb 1
 43283 0000A117 <res 00000008>          p_swi3_sp_switch5:	 resb 8
 43284                                  
 43285 0000A11F <res 00000001>          next_letter:	resb 1
 43286 0000A120 <res 00000001>          display_page:	resb 1
 43287 0000A121 <res 00000001>          		resb 1
 43288                                  p_swi4:
 43289 0000A122 <res 00000002>          p_swi4_sp_match_flag:	 resw 1
 43290 0000A124 <res 00000002>          p_swi4_sp_function_flag: resw 1
 43291 0000A126 <res 00000002>          p_swi4_sp_buff1_ptr:	 resw 1
 43292 0000A128 <res 00000002>          p_swi4_sp_val1_ptr:	 resw 1
 43293 0000A12A <res 00000001>          p_swi4_sp_nid:		 resb 1
 43294 0000A12B <res 00000003>          p_swi4_sp_switch6:	 resb 3
 43295                                  
 43296 0000A12E <res 00000001>          mbr_flag:	resb 1
 43297 0000A12F <res 00000001>          		resb 1
 43298                                  
 43299                                  ; 14/12/2018 (no need to _bufin for FDISK2.COM) 
 43300                                  
 43301                                  ;_bufin:	resb 512
 43302                                  
 43303                                  p_swi5:
 43304 0000A130 <res 00000002>          p_swi5_sp_match_flag:	 resw 1
 43305 0000A132 <res 00000002>          p_swi5_sp_function_flag: resw 1
 43306 0000A134 <res 00000002>          p_swi5_sp_buff1_ptr:	 resw 1
 43307 0000A136 <res 00000002>          p_swi5_sp_val1_ptr:	 resw 1
 43308 0000A138 <res 00000001>          p_swi5_sp_nid:	 	 resb 1
 43309 0000A139 <res 00000005>          p_swi5_sp_switch7:	 resb 5
 43310                                  
 43311 0000A13E <res 00000002>          input_row:	resw 1
 43312 0000A140 <res 00000001>          quiet_flag:	resb 1
 43313 0000A141 <res 00000001>          		resb 1
 43314                                  
 43315 0000A142 <res 00000008>          good_disk:	resb 8
 43316                                  
 43317                                  ; LOGICAL PARTITION DATA STRUCTURE
 43318                                  ; (for logical paritions in extended paritions)
 43319                                  ; 23/11/2018
 43320                                  ; 8 extended partitions (on 8 hard disks -8 physical drives-)
 43321                                  ; 24 logical drives (46 bytes) per extended partition
 43322                                  ; 8832 bytes (8*24*46)
 43323                                  
 43324 0000A14A <res 00000001>          ext_table_boot_ind:	resb 1
 43325 0000A14B <res 00000001>          ext_table_start_head:	resb 1
 43326 0000A14C <res 00000001>          ext_table_start_sector: resb 1
 43327 0000A14D <res 00000002>          ext_table_start_cyl:	resw 1
 43328 0000A14F <res 00000001>          ext_table_sys_id:	resb 1
 43329 0000A150 <res 00000001>          ext_table_end_head:	resb 1
 43330 0000A151 <res 00000001>          ext_table_end_sector:	resb 1
 43331 0000A152 <res 00000002>          ext_table_end_cyl:	resw 1
 43332 0000A154 <res 00000002>          ext_table_rel_sec_lw:	resw 1
 43333 0000A156 <res 00000002>          ext_table_rel_sec_hw:	resw 1
 43334 0000A158 <res 00000002>          ext_table_num_sec_lw:	resw 1
 43335 0000A15A <res 00000002>          ext_table_num_sec_hw:	resw 1
 43336 0000A15C <res 00000001>          			resb 1
 43337 0000A15D <res 00000001>          ext_table_changed:	resb 1
 43338 0000A15E <res 00000002>          ext_table_mbytes_used:	resw 1
 43339 0000A160 <res 00000002>          ext_table_percent_used:	resw 1
 43340 0000A162 <res 0000000C>          ext_table_vol_label:	resb 12
 43341 0000A16E <res 00000009>          ext_table_system:	resb 9
 43342 0000A177 <res 00000001>          ext_table_drive_letter:	resb 1
 43343 0000A178 <res 000003F4>          		resb 1012 ; 46*22
 43344 0000A56C <res 00000001>          ep0_lp23_boot_ind:	resb 1
 43345 0000A56D <res 00000001>          ep0_lp23_start_head:	resb 1
 43346 0000A56E <res 00000001>          ep0_lp23_start_sector:	resb 1
 43347 0000A56F <res 00000002>          ep0_lp23_start_cyl:	resw 1 ; 06/01/2019
 43348 0000A571 <res 00000001>          ep0_lp23_sys_id:	resb 1
 43349 0000A572 <res 00000001>          ep0_lp23_end_head:	resb 1
 43350 0000A573 <res 00000001>          ep0_lp23_end_sector:	resb 1
 43351 0000A574 <res 00000002>          ep0_lp23_end_cyl:	resw 1 ; 06/01/2019
 43352 0000A576 <res 00000002>          ep0_lp23_rel_sec_lw:	resw 1
 43353 0000A578 <res 00000002>          ep0_lp23_rel_sec_hw:	resw 1
 43354 0000A57A <res 00000002>          ep0_lp23_num_sec_lw:	resw 1
 43355 0000A57C <res 00000002>          ep0_lp23_num_sec_hw:	resw 1
 43356 0000A57E <res 00000001>          			resb 1 ; 06/01/2019
 43357 0000A57F <res 00000001>          ep0_lp23_changed: 	resb 1
 43358 0000A580 <res 00000002>          ep0_lp23_mbytes_used:	resw 1
 43359 0000A582 <res 00000002>          ep0_lp23_percent_used:	resw 1
 43360 0000A584 <res 0000000C>          ep0_lp23_vol_label:	resb 12
 43361 0000A590 <res 00000009>          ep0_lp23_system:	resb 9
 43362 0000A599 <res 00000001>          ep0_lp23_drive_letter:	resb 1
 43363 0000A59A <res 00001E30>          		resb 7728 ; 7*46*24
 43364                                  
 43365 0000C3CA <res 00000001>          mono_flag:	resb 1
 43366 0000C3CB <res 00000001>          Yes:		resb 1
 43367                                  ;segregs:
 43368                                  ;segregs_es:	resw 1
 43369                                  ;segregs_cs:	resw 1
 43370                                  ;segregs_ss:	resw 1
 43371                                  ;segregs_ds:	resw 1
 43372 0000C3CC <res 00000002>          extended_buff:	resw 1
 43373                                  
 43374                                  ;total_disk:	resw 8
 43375                                  
 43376 0000C3CE <res 00000001>          primary_partition_count: resb 1
 43377 0000C3CF <res 00000001>          		resb 1
 43378 0000C3D0 <res 00000002>          primary_buff:	resw 1
 43379 0000C3D2 <res 00000001>          PercentFlag:	resb 1
 43380 0000C3D3 <res 00000001>          logical_flag:	resb 1
 43381 0000C3D4 <res 00000001>          status_flag:	resb 1
 43382 0000C3D5 <res 00000001>          number_of_drives: resb 1
 43383 0000C3D6 <res 00000001>          extended_flag:	resb 1
 43384                                  
 43385                                  sp_val:
 43386 0000C3D7 <res 00000001>          sp_val_p_values:	resb 1
 43387 0000C3D8 <res 00000001>          sp_val_p_range:		resb 1
 43388 0000C3D9 <res 00000001>          sp_val_p_range_one: 	resb 1
 43389 0000C3DA <res 00000004>          sp_val_p_low_range: 	resd 1
 43390 0000C3DE <res 00000002>          sp_val_p_high_range:   	resw 1
 43391 0000C3E0 <res 00000001>          sp_val_p_high_range_2: 	resb 1
 43392                                  
 43393 0000C3E1 <res 00000001>          sort_1:			resb 1
 43394 0000C3E2 <res 00000018>          sort:			resb 24
 43395                                  
 43396                                  p_val:
 43397 0000C3FA <res 00000001>          p_val_p_values		resb 1
 43398 0000C3FB <res 00000001>          p_val_p_range:		resb 1
 43399 0000C3FC <res 00000001>          p_val_p_range_one:	resb 1
 43400 0000C3FD <res 00000004>          p_val_p_low_range:	resd 1
 43401 0000C401 <res 00000004>          p_val_p_high_range:	resd 1
 43402 0000C405 <res 00000001>          no_fatal_error:	resb 1
 43403                                  p_con:
 43404 0000C406 <res 00000002>          p_con_p_match_flag:	resw 1
 43405 0000C408 <res 00000002>          p_con_p_function_flag:	resw 1
 43406 0000C40A <res 00000002>          p_con_p_buff1_ptr:	resw 1
 43407 0000C40C <res 00000002>          p_con_p_val1_ptr:	resw 1
 43408 0000C40E <res 00000001>          p_con_nid:		resb 1
 43409 0000C40F <res 00000001>          cur_disk_buff:		resb 1
 43410                                  
 43411                                  ; 13/12/2018
 43412 0000C410 <res 00000001>          video_attribute: resb 1
 43413 0000C411 <res 00000001>          		 resb 1
 43414                                  
 43415                                  ; PARTITION DATA STRUCTURE
 43416                                  ; 32 (4*8) partitions (on 8 hard disks -8 physical drives-)
 43417                                  ; 46 byte partition data structure per partition
 43418                                  ; (4*46 bytes per disk)
 43419                                  
 43420 0000C412 <res 00000001>          part_table_boot_ind:	 resb 1
 43421 0000C413 <res 00000001>          part_table_start_head:	 resb 1
 43422 0000C414 <res 00000001>          part_table_start_sector: resb 1
 43423 0000C415 <res 00000002>          part_table_start_cyl:	 resw 1
 43424 0000C417 <res 00000001>          part_table_sys_id:	 resb 1
 43425 0000C418 <res 00000001>          part_table_end_head:	 resb 1
 43426 0000C419 <res 00000001>          part_table_end_sector:	 resb 1
 43427 0000C41A <res 00000002>          part_table_end_cyl:	 resw 1
 43428 0000C41C <res 00000002>          part_table_rel_sec_lw:	 resw 1
 43429 0000C41E <res 00000002>          part_table_rel_sec_hw:	 resw 1
 43430 0000C420 <res 00000002>          part_table_num_sec_lw:	 resw 1
 43431 0000C422 <res 00000002>          part_table_num_sec_hw:	 resw 1
 43432 0000C424 <res 00000001>          			 resb 1
 43433 0000C425 <res 00000001>          part_table_changed:	 resb 1
 43434 0000C426 <res 00000002>          part_table_mbytes_used:  resw 1
 43435 0000C428 <res 00000002>          part_table_percent_used: resw 1
 43436 0000C42A <res 0000000C>          part_table_vol_label:	 resb 12
 43437 0000C436 <res 00000009>          part_table_system:	 resb 9
 43438 0000C43F <res 00000001>          part_table_drive_letter: resb 1
 43439 0000C440 <res 00000014>          		       resb 20
 43440 0000C454 <res 00000002>          pt_part2_mbytes_used:  resw 1
 43441 0000C456 <res 00000002>          pt_part2_percent_used: resw 1
 43442 0000C458 <res 00000016>          		       resb 22
 43443 0000C46E <res 00000014>          		       resb 20
 43444 0000C482 <res 00000002>          pt_part3_mbytes_used:  resw 1
 43445 0000C484 <res 00000002>          pt_part3_percent_used: resw 1
 43446 0000C486 <res 00000016>          		       resb 22
 43447 0000C49C <res 00000014>          		       resb 20
 43448 0000C4B0 <res 00000002>          pt_part4_mbytes_used:  resw 1
 43449 0000C4B2 <res 00000002>          pt_part4_percent_used: resw 1
 43450 0000C4B4 <res 00000016>          		       resb 22
 43451 0000C4CA <res 00000508>          		resb 1288 ; 22/11/2018 (4*46*7 = 1288)
 43452                                  
 43453                                  ;max_sector:	resb 8
 43454 0000C9D2 <res 00000200>          boot_record:	resb 512
 43455 0000CBD2 <res 00000002>          logical_buff:	resw 1
 43456 0000CBD4 <res 00000001>          cur_disk:	resb 1
 43457 0000CBD5 <res 00000001>          		resb 1
 43458 0000CBD6 <res 00000001>          p_buff:		   resb 1
 43459 0000CBD7 <res 00000001>          p_buff_p_item_tag: resb 1
 43460 0000CBD8 <res 00000002>          p_buff_p_synonym:  resw 1
 43461 0000CBDA <res 00000004>          p_buff_p_value:	   resd 1
 43462 0000CBDE <res 00000001>          valid_input:	resb 1
 43463 0000CBDF <res 00000001>          		resb 1
 43464 0000CBE0 <res 00000002>          Parse_Ptr:	resw 1
 43465                                  
 43466                                  ; 14/11/2019
 43467                                  fspc:		; 5*10 words (for free space calculations)
 43468                                  
 43469                                  ; Space 1 - unused cylinders before partition 0
 43470                                  ; Space 2 - unused cylinders between partition 0 & 1 
 43471                                  ; Space 3 - unused cylinders between partition 1 & 2 
 43472                                  ; Space 5 - unused cylinders between partition 2 & 3 
 43473                                  ; Space 5 - unused cylinders after partition 3
 43474                                  
 43475                                  ; 13/01/2019
 43476 0000CBE2 <res 00000002>          free_space.space:   	   resw 1
 43477 0000CBE4 <res 00000002>          free_space.start:   	   resw 1
 43478 0000CBE6 <res 00000002>          free_space.end:	   	   resw 1
 43479 0000CBE8 <res 00000002>          free_space.mbytes_unused:  resw 1
 43480 0000CBEA <res 00000002>          free_space.percent_unused: resw 1
 43481                                  		;resb 520
 43482                                  		;resw 4*5  ; 17/01/2019
 43483 0000CBEC <res 000000E6>          		resw  23*5 ; 20/01/2019		 	
 43484                                  
 43485 0000CCD2 <res 00000001>          disk_access:	 resb 1
 43486 0000CCD3 <res 00000001>          dac_access_flag: resb 1
 43487 0000CCD4 <res 00000001>          sp_buff:	    resb 1
 43488 0000CCD5 <res 00000001>          sp_buff_p_item_tag: resb 1
 43489 0000CCD6 <res 00000002>          sp_buff_p_synonym:  resw 1
 43490 0000CCD8 <res 0000000A>          sp_buff_p_value:    resb 10
 43491                                  
 43492                                  ; 13/12/2018
 43493 0000CCE2 <res 00000002>          outbuf_ptr:	resw 1 ; offset insert (insert+)
 43494 0000CCE4 <res 00000002>          outbuf_cnt:	resw 1 ; 800
 43495                                  
 43496 0000CCE6 <res 00000320>          insert:		resb 800
 43497                                  
 43498 0000D006 <res 00000002>          dataoffset_end_2: resw 1
 43499                                  
 43500                                  ; 10/11/2018
 43501 0000D008 <res 00000002>          _argc:  resw 1
 43502 0000D00A <res 00000002>          _argv:	resw 1
 43503 0000D00C <res 00000002>          retadr:	resw 1
 43504 0000D00E <res 00000002>          _temp:	resw 1
 43505 0000D010 <res 00000002>          _input: resw 1
 43506 0000D012 <res 00000004>          _pgmptr: resd 1
 43507                                  		
 43508                                  ; SEGMENT 5 - Uninitialized --------------------------------------------------
 43509                                  
 43510                                  ;resb 2048
 43511                                  
 43512                                  alignb 2
 43513                                  
 43514                                  end_of_file: 
