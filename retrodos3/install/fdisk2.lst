     1                                  ; ****************************************************************************
     2                                  ; FDISK2.ASM (FDISK2.COM) //// MSDOS 5.0-6.22 Hard Disk Partitioning Utility
     3                                  ; 	     by Erdogan Tan				  (for MSDOS/WINDOWS)
     4                                  ; ****************************************************************************
     5                                  ; Last Update: 22/12/2022 (Previous: 28/01/2019)
     6                                  ; ----------------------------------------------------------------------------
     7                                  ; Beginning: 06/11/2018
     8                                  ; ----------------------------------------------------------------------------
     9                                  ; Assembler: NASM version 2.11
    10                                  ; ----------------------------------------------------------------------------
    11                                  ; Source Code Reference: MSDOS 6.0 FDISK.EXE source code (in C language).
    12                                  ; ----------------------------------------------------------------------------
    13                                  ; This FDISK (Version 2) source code has been written by using disassembled
    14                                  ;      FDISK.COM source code of IBM PC-DOS 7.0 (1996).
    15                                  ; ****************************************************************************
    16                                  ; nasm fdisk2.s -l fdisk2.txt -o FDISK2.COM
    17                                  ; ============================================================================
    18                                  ;
    19                                  ; ... Retro DOS v3.0 (and Retro DOS v4.0) FDISK utility ... by Erdogan Tan ...
    20                                  
    21                                  ; ---------------------------------------------------------------------------
    22                                  ; -	This file is generated by The Interactive Disassembler (IDA)	    -
    23                                  ; -	Copyright (c) 2010 by Hex-Rays SA, <support@hex-rays.com>	    -
    24                                  ; -			 Licensed to: Freeware version			    -
    25                                  ; ---------------------------------------------------------------------------
    26                                  ;
    27                                  ; Input	MD5   :	60ADAF7E26AAC0C3FD48E6F4E2774E73
    28                                  
    29                                  ; File Name   :	D:\Documents and Settings\Erdoðan Tan\Desktop\FDISK70.COM
    30                                  ; Format      :	MS-DOS executable (EXE)
    31                                  ; Base Address:	0h Range: 0h-11CE0h Loaded length: E210h
    32                                  ; Entry	Point :	0:6CAA
    33                                  
    34                                  ; Input	MD5   :	B4080FCD526BEB3060C00FCC3FF4E9CC
    35                                  
    36                                  ; File Name   :	D:\Documents and Settings\Erdoðan Tan\Desktop\FDISK.COM
    37                                  ; Format      :	MS-DOS COM-file
    38                                  ; Base Address:	0h Range: 100h-1702h Loaded length: 1602h
    39                                  
    40                                  ; ============================================================================
    41                                  
    42                                  ; (IBM PC-DOS) FDISK.COM (1996) has been unpacked by using UNP.EXE (1997)
    43                                  ; (unpacking program); then, FDISK70.COM (EXE file) has been disassembled
    44                                  ; by using IDA Pro Free (2010) program.
    45                                  
    46                                  ; ============================================================================
    47                                  
    48                                  	[BITS 16]
    49                                  	[ORG 100h]
    50                                  
    51                                  start:
    52 00000000 EB2D                    	jmp	short _astart
    53                                  
    54 00000002 E207                    	dw	2018
    55 00000004 A101                    	dw	01A1h
    56                                  
    57 00000006 00                      	db	0
    58                                  ; ----------------------------------------------------------------------------
    59                                  
    60                                  ;db '<R>                           PC DOS Version 7.0 '
    61                                  ;db 6,'0104',6
    62                                  ;db '<R>                         Fixed Disk Setup Program '
    63                                  ;db 6,'0104',6
    64                                  ;db '<R>                Copyright (c) IBM Corporation 1983 - 1994',0
    65                                  
    66                                  ; ----------------------------------------------------------------------------
    67                                  
    68                                  ;MBR_ADDR:	dw	MBR
    69 00000007 [26D0]                  buffer:		dw	end_of_file+2
    70                                  
    71                                  current_partition:
    72 00000009 00                      p_status:	db	0
    73 0000000A 00                      start_head:	db	0
    74 0000000B 0000                    start_cyl_sec:	dw	0
    75 0000000D 00                      partition_type:	db	0
    76 0000000E 00                      end_head:	db	0
    77 0000000F 0000                    end_cyl_sec:	dw	0
    78 00000011 0000                    start_lba_lw:	dw	0
    79 00000013 0000                    start_lba_hw:	dw	0
    80 00000015 0000                    sectors_lba_lw:	dw	0
    81 00000017 0000                    sectors_lba_hw:	dw	0
    82                                  
    83 00000019 0000                    pt_start_cyl:	dw	0
    84 0000001B 0000                    pt_end_cyl:	dw	0
    85 0000001D 0000                    pt_cylinders:	dw	0
    86 0000001F 01                      file_system:	db	1
    87                                  cpartition_number:
    88 00000020 00                      		db	0
    89 00000021 00                      partition:	db	0
    90 00000022 80                      drive:		db	80h ; 0
    91 00000023 31                      disk_number:	db	'1' ; 0
    92 00000024 00                      wait_for_input:	db	0
    93                                  max_avl_cylinders: 
    94 00000025 0000                    		dw	0
    95                                  next_start_cylinder: 
    96 00000027 0000                    		dw	0
    97 00000029 0000                    cylinders:	dw	0
    98 0000002B 0000                    start_cyl:	dw	0
    99                                  active_part_input:
   100 0000002D 00                      		db	0
   101                                  active_partition:
   102 0000002E 00                      		db	0
   103                                  
   104                                  ; ----------------------------------------------------------------------------
   105                                  ; CRT0 - Modified and simplified for Assembly language
   106                                  ; ----------------------------------------------------------------------------
   107                                  ; 						  (by Erdogan Tan, 06/11/2018)
   108                                  
   109                                  _astart:
   110 0000002F B430                    		mov	ah,30h
   111 00000031 CD21                    		int	21h   ; DOS - GET DOS VERSION
   112                                  			      ; Return: AL = major ver. num. (00h for DOS 1.x)
   113                                  
   114                                  		;mov	word [_dosvermajor],ax	
   115                                  
   116                                  		;cmp	al,5	; MSDOS 5.0 or next versions are needed
   117                                  				; for (correct) running this program. 
   118                                  		;jnb	short setup
   119                                  
   120                                  		; 14/11/2018
   121 00000033 3C03                    		cmp	al,3	; MSDOS 3.3 check
   122 00000035 7714                    		ja	short setup_2
   123 00000037 740B                    		je	short setup_1
   124                                  
   125                                  _wrong_version:
   126                                  		; 'Incorrect dos version!' msg writing code may be put here.
   127 00000039 BE[A05C]                		mov	si,incorrect_dos_version ; ('Incorrect DOS version!')
   128 0000003C E84E5C                  		call	print_msg 
   129                                  
   130 0000003F 31C0                    		xor	ax,ax
   131 00000041 06                      		push	es
   132 00000042 50                      		push	ax
   133 00000043 CB                      		retf		; DOS 1.0 exit program (int 20h at psp:0)	
   134                                  setup_1:
   135                                  		; 14/11/2018
   136 00000044 80FC1E                  		cmp	ah,30	; MSDOS 3.30 (3.3) ? (at least) 
   137 00000047 72F0                       		jb	short _wrong_version
   138 00000049 740B                    		je	short _correct_version ; Proper version for now...
   139                                  					 ; .. but, 'Incorrect DOS version' msg
   140                                  					 ; is waiting at next stage!
   141                                  					 ; (in 'preload_messages' procedure)
   142                                  ;setup:
   143                                  setup_2:
   144 0000004B 3C07                    		cmp	al,7	; MS-DOS/PC-DOS version 5.0 to 7.1 is proper
   145 0000004D 7207                    		jb	short _correct_version
   146 0000004F 77E8                    		ja	short _wrong_version
   147 00000051 80FC0A                  		cmp	ah,10
   148 00000054 77E3                    		ja	short _wrong_version  
   149                                  
   150                                  _correct_version:
   151                                  
   152                                  		; 14/12/2018
   153                                  		; (clear bss)	
   154 00000056 B9[14D0]                		mov	cx,dataoffset_end_2
   155 00000059 BF[78A0]                		mov	di,bss_start
   156 0000005C 29F9                    		sub	cx,di
   157 0000005E 41                      		inc	cx
   158 0000005F D1E9                    		shr	cx,1
   159 00000061 31C0                    		xor	ax, ax		
   160 00000063 F3AB                    		rep	stosw
   161                                  		
   162                                  		;call	clear_screen
   163                                  
   164                                  		; process command line (and environment)
   165                                  		;call	_setenvp
   166                                  		;call	_setargv ; crack command line
   167                                  
   168                                  		;;push	word [environ]				
   169                                  		;push	word [_argv]
   170                                  		;push	word [_argc]
   171                                  
   172 00000065 E80500                  		call	_main
   173                                  		;push	ax
   174                                  		;call	_exit
   175                                  
   176                                  		;int	20h
   177                                  _exit:
   178                                  _exit_:		; 10/12/2018
   179                                  DOSEXIT:	; 19/11/2018	
   180                                  		;pop	ax
   181 00000068 B44C                    		mov	ah,4Ch
   182 0000006A CD21                    		int	21h	; DOS -	2+ - QUIT WITH EXIT CODE (EXIT)
   183                                  				; AL = exit code
   184                                  
   185                                  ; ----------------------------------------------------------------------------
   186                                  
   187                                  int23h:		; 14/11/2018
   188                                  
   189 0000006C CF                      		iret
   190                                  
   191                                  ; ----------------------------------------------------------------------------
   192                                  
   193                                  ; ----------------------------------------------------------------------------
   194                                  ; main.c (FDISK, MSDOS 6.0, 1991)	
   195                                  ; ----------------------------------------------------------------------------
   196                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 06/11/2018)
   197                                  
   198                                  ;/******************* START OF SPECIFICATIONS *******************/
   199                                  ;/*                                                             */
   200                                  ;/* SOURCE FILE NAME: FDISK                                     */
   201                                  ;/*                                                             */
   202                                  ;/* DESCRIPTIVE NAME: FIXED DISK PARTITIONING UTILITY           */
   203                                  ;/*                                                             */
   204                                  ;/* FUNCTION:                                                   */
   205                                  ;/*     Allows creation and deletion of DOS related partitions  */
   206                                  ;/*     on fixed disk devices 80-86h (int 13h BIOS defined,     */
   207                                  ;/*     DOS). Also allows display of all partitions, and will   */
   208                                  ;/*     allow a partition to be marked active (bootable). The   */
   209                                  ;/*     user will be prompted for action thru a full screen     */
   210                                  ;/*     interface. The user can also create, delete and display */
   211                                  ;/*     logical DOS drives within a EXTENDED DOS Partition. If a*/
   212                                  ;/*     regular DOS partition is created, the beginning of the  */
   213                                  ;/*     partition will be scanned to insure a contiguous area of*/
   214                                  ;/*     good sectors on the disk large enough to satisfy the    */
   215                                  ;/*     DOS system requirements. If a bad spot is found, the    */
   216                                  ;/*     start of the partition will be moved out until a good   */
   217                                  ;/*     area is located                                         */
   218                                  ;/*                                                             */
   219                                  ;/* NOTES: The program will work by setting up a logical image  */
   220                                  ;/*        of all relevant disk information at initilization    */
   221                                  ;/*        time. All operations will be performed on this       */
   222                                  ;/*        logical image, thus reducing disk accesses to only   */
   223                                  ;/*        those required to initially set up the logical image,*/
   224                                  ;/*        and to write the changed information at the end. The */
   225                                  ;/*        user will be informed if there is a problem writing  */
   226                                  ;/*        the logical image back to the disk.                  */
   227                                  ;/*                                                             */
   228                                  ;/*        FDISK will interface with the partition table in the */
   229                                  ;/*        master boot record as defined in the PC-DOS technical*/
   230                                  ;/*        reference manual. It will also create and manage the */
   231                                  ;/*        EXTENDED DOS partition architecture as defined in the*/
   232                                  ;/*        PC-DOS 3.30 functional spec (CP/DOS spec dcr pending)*/
   233                                  ;/*                                                             */
   234                                  ;/* ENTRY POINTS: MAIN                                          */
   235                                  ;/*    LINKAGE: [d:] [path] FDISK                               */
   236                                  ;/*                                                             */
   237                                  ;/* EXTERNAL REFERENCES:                                        */
   238                                  ;/*              Fixed Disk Master Boot Record                  */
   239                                  ;/*              EXTENDED Partition Volume Boot Records         */
   240                                  ;/*   Note: Both of the above are physical data structures on   */
   241                                  ;/*         the surface of the disk                             */
   242                                  ;/*                                                             */
   243                                  ;/* P.S. - To whoever winds up maintaining this, I will         */
   244                                  ;/*        apoligize in advance. I had just learned 'C' when    */
   245                                  ;/*        writing this, so out of ignorance of the finer points*/
   246                                  ;/*        of the langauge I did a lot of things by brute force.*/
   247                                  ;/*        Hope this doesn't mess you up too much - MT 5/20/86  */
   248                                  ;/******************** END OF SPECIFICATIONS ********************/
   249                                  
   250                                  ;/*  */
   251                                  ;/******************* START OF SPECIFICATIONS *******************/
   252                                  ;/*                                                             */
   253                                  ;/* SUBROUTINE NAME: MAIN                                       */
   254                                  ;/*                                                             */
   255                                  ;/* DESCRIPTIVE NAME: Main control routine                      */
   256                                  ;/*                                                             */
   257                                  ;/* FUNCTION: Main will handle call routines to handle the      */
   258                                  ;/*           setup of the video for the full screen interface, */
   259                                  ;/*           get physical data on the drive characteristics,   */
   260                                  ;/*           initilize all data fields with the current status */
   261                                  ;/*           of the disk partitioning information. Before the  */
   262                                  ;/*           program is terminated, the video is reset to the  */
   263                                  ;/*           mode it was in previous to the routine entry. It  */
   264                                  ;/*           will also handle the case of an improper setup    */
   265                                  ;/*                                                             */
   266                                  ;/* NOTES: FDISK requires at least 1 hardfile to operate        */
   267                                  ;/*                                                             */
   268                                  ;/* ENTRY POINTS: main();                                       */
   269                                  ;/*      LINKAGE:                                               */
   270                                  ;/*                                                             */
   271                                  ;/* INPUT: None                                                 */
   272                                  ;/*                                                             */
   273                                  ;/* EXIT-NORMAL: Return Code = 0                                */
   274                                  ;/*                                                             */
   275                                  ;/* EXIT-ERROR: Return Code =  1                                */
   276                                  ;/*                                                             */
   277                                  ;/* EFFECTS: Sets up status variables, sets up video for full   */
   278                                  ;/*          screen interface, and then restores the video mode */
   279                                  ;/*          before exiting program                             */
   280                                  ;/*                                                             */
   281                                  ;/* INTERNAL REFERENCES:                                        */
   282                                  ;/*   ROUTINES:                                                 */
   283                                  ;/*      init_video_information                                 */
   284                                  ;/*      get_disk_information                                   */
   285                                  ;/*      check_valid_environment                                */
   286                                  ;/*      do_main_menu                                           */
   287                                  ;/*      init_partition_tables                                  */
   288                                  ;/*      reset_video_information                                */
   289                                  ;/*                                                             */
   290                                  ;/* EXTERNAL REFERENCES:                                        */
   291                                  ;/*   ROUTINES:                                                 */
   292                                  ;/*       DosExit                                               */
   293                                  ;/*                                                             */
   294                                  ;/******************** END OF SPECIFICATIONS ********************/
   295                                  
   296                                  
   297                                  ;/*  */
   298                                  ;/**************************************************************************/
   299                                  ;/*                                                                        */
   300                                  ;/*   UTILITY NAME:         FDISK.com                                      */
   301                                  ;/*   SOURCE FILE NAME:     FDISK.c                                        */
   302                                  ;/*   STATUS:               FDISK utility, DOS 3.3			   */
   303                                  ;/*   CHANGE HISTORY:       UPDATED        5-29-87     DOS4.0       DRM    */
   304                                  ;/*   SYNTAX (Command line)                                                */
   305                                  ;/*                                                                        */
   306                                  ;/*     [d:][path]FDISK                                                    */
   307                                  ;/*                                                                        */
   308                                  ;/*     or                                                                 */
   309                                  ;/*                                                                        */
   310                                  ;/*     [d:][path]FDISK d [/PRI:m | /EXT:n | /LOG:o | /Q | /STATUS | /MBR] */
   311                                  ;/*                                                                        */
   312                                  ;/*         d:      Drive to load FDISK utility from                       */
   313                                  ;/*                                                                        */
   314                                  ;/*         path    path to the directory on specified drive to            */
   315                                  ;/*                 load FDISK from                                        */
   316                                  ;/*                                                                        */
   317                                  ;/*         d       Drive (1 or 2) that FDISK should operate on            */
   318                                  ;/*                                                                        */
   319                                  ;/*         /PRI:m  Size of Primary DOS partition to create in K           */
   320                                  ;/*                                                                        */
   321                                  ;/*         /EXT:n  Size of Extended DOS partition to create in K          */
   322                                  ;/*                                                                        */
   323                                  ;/*         /LOG:o  Size of Logical drive to create in K in the            */
   324                                  ;/*                 extended partition                                     */
   325                                  ;/*                                                                        */
   326                                  ;/*         /Q      This suppresses the reboot screen and returns          */
   327                                  ;/*                 FDISK to DOS even if partitions have changed.          */
   328                                  ;/*                                                                        */
   329                                  ;/*         /STATUS This gives a display of the data portion of the        */
   330                                  ;/*                 Change Current Fixed Disk Drive menu.                  */
   331                                  ;/*                                                                        */
   332                                  ;/*   UTILITY FUNCTION:                                                    */
   333                                  ;/*     Allows you to create, set up, display, afnd delete the             */
   334                                  ;/*     DOS partitions on a fixed disk.                                    */
   335                                  ;/*                                                                        */
   336                                  ;/* PSEUDOCODE:                                                            */
   337                                  ;/*                                                                        */
   338                                  ;/*      Disable CTRL-break                                                */
   339                                  ;/*      IF Preload_messages and get_yes_no_values                         */
   340                                  ;/*          IF Parse Command Line                                         */
   341                                  ;/*              IF no switches set                                        */
   342                                  ;/*                  IF Valid Environment                                  */
   343                                  ;/*                      Change video information                          */
   344                                  ;/*                      IF Get disk information                           */
   345                                  ;/*                          Initialize tables                             */
   346                                  ;/*                          IF status_flag == TRUE                        */
   347                                  ;/*                              display current drive information         */
   348                                  ;/*                          else                                          */
   349                                  ;/*                              display main menu                         */
   350                                  ;/*                              write information to disk                 */
   351                                  ;/*                              IF reboot_flag == TRUE                    */
   352                                  ;/*                                  reboot                                */
   353                                  ;/*                              else                                      */
   354                                  ;/*                                  reset video mode                      */
   355                                  ;/*                              ENDIF  reboot flag                        */
   356                                  ;/*                          ENDIF  status flag                            */
   357                                  ;/*                      ENDIF  get disk info                              */
   358                                  ;/*                  ENDIF  valid environment                              */
   359                                  ;/*              else                                                      */
   360                                  ;/*                  IF all flags == FALSE                                 */
   361                                  ;/*                      display error message                             */
   362                                  ;/*                  else                                                  */
   363                                  ;/*                      IF get_disk_info                                  */
   364                                  ;/*                          IF drive number not valid                     */
   365                                  ;/*                              display error message                     */
   366                                  ;/*                          else                                          */
   367                                  ;/*                              init_partition_tables                     */
   368                                  ;/*                              IF PRIMARY flag == true                   */
   369                                  ;/*                                  find available free space             */
   370                                  ;/*                                  IF asking for too much                */
   371                                  ;/*                                      reset ask to available space      */
   372                                  ;/*                                  else                                  */
   373                                  ;/*                                      change request to cylinders       */
   374                                  ;/*                                  ENDIF                                 */
   375                                  ;/*                                  make the partition                    */
   376                                  ;/*                              ENDIF                                     */
   377                                  ;/*                              IF EXTENDED flag == true                  */
   378                                  ;/*                                  find available free space             */
   379                                  ;/*                                  IF asking for too much                */
   380                                  ;/*                                      reset ask to available space      */
   381                                  ;/*                                  else                                  */
   382                                  ;/*                                      change request to cylinders       */
   383                                  ;/*                                  ENDIF                                 */
   384                                  ;/*                                  make the partition                    */
   385                                  ;/*                              ENDIF                                     */
   386                                  ;/*                              IF LOGICAL flag == true                   */
   387                                  ;/*                                  find available free space in extended */
   388                                  ;/*                                  IF asking for too much                */
   389                                  ;/*                                      reset ask to available space      */
   390                                  ;/*                                  else                                  */
   391                                  ;/*                                      change request to cylinders       */
   392                                  ;/*                                  ENDIF                                 */
   393                                  ;/*                                  make the partition                    */
   394                                  ;/*                              ENDIF                                     */
   395                                  ;/*                              Write information to disk                 */
   396                                  ;/*                          ENDIF                                         */
   397                                  ;/*                      ENDIF                                             */
   398                                  ;/*                  ENDIF                                                 */
   399                                  ;/*              ENDIF                                                     */
   400                                  ;/*          ENDIF                                                         */
   401                                  ;/*      ENDIF                                                             */
   402                                  ;/*      IF no PRIMARY on disk 1 and /Q switch                             */
   403                                  ;/*          exit errorlevel 1                                             */
   404                                  ;/*      else                                                              */
   405                                  ;/*          IF no switches set and /Q option                              */
   406                                  ;/*              exit errorlevel 2                                         */
   407                                  ;/*          else                                                          */
   408                                  ;/*              exit errorlevel 0                                         */
   409                                  ;/*          ENDIF                                                         */
   410                                  ;/*      ENDIF                                                             */
   411                                  ;/*                                                                        */
   412                                  ;/**************************************************************************/
   413                                  ;/*  */
   414                                  
   415                                  ; 24/11/2018
   416                                  
   417                                  ; void main(argc,argv)
   418                                  
   419                                  	; int	argc;
   420                                  	; char	*argv[];  
   421                                  
   422                                  _main:
   423                                  		;push	bp
   424                                  		;mov	bp,sp
   425                                  
   426                                  		;argv	equ 6 		; [bp+6]
   427                                  		;argc	equ 4		; [bp+4]
   428                                  
   429                                  		       ; Return Address = [bp+2]
   430                                  
   431                                  	      ;	unsigned   i;  		; [bp-6] 
   432                                  	      ;	char       temp; 	; [bp-4]
   433                                  	      ;	unsigned   input;	; [bp-2]
   434                                  
   435                                  ;	;/* DISABLE CNTL-BREAK HERE */
   436                                  ;	;/* Gets defines from signal.h */
   437                                  ;
   438                                  ;		signal( (int) SIGINT, SIG_IGN ); /* AN000 */
   439                                  
   440 0000006D BA[6C00]                		mov	dx,int23h
   441 00000070 B82325                  		mov	ax,2523h
   442                                  				; DOS -	SET INTERRUPT VECTOR
   443 00000073 CD21                    		int	21h	; AL = interrupt number
   444                                  			; DS:DX	= new vector to	be used	for specified interrupt
   445                                  
   446                                  ;	no_fatal_error = TRUE;
   447                                  
   448 00000075 C606[13C4]01            		mov	byte [no_fatal_error],1
   449                                  
   450                                  		; 13/11/2018
   451 0000007A E8A70B                  		call	preload_messages
   452                                  
   453                                  		;or	al,al
   454                                  		;jz	_main_33
   455                                  
   456 0000007D 0F824602                		jc	_main_33
   457                                  
   458 00000081 E8B60C                  		call	get_yes_no_values
   459                                  
   460                                  		;or	al,al
   461                                  		;jnz	_main_01
   462                                  
   463                                  		; 14/11/2018
   464                                  		;;jnc	_main_01
   465                                  		;;jmp	short _main_33
   466                                  		;jmp	short _main_01
   467                                  
   468                                  ; ----------------------------------------------------------------------------
   469                                  
   470                                  ;int23h:
   471                                  ;		iret
   472                                  
   473                                  ; ----------------------------------------------------------------------------
   474                                  
   475                                  _main_01:
   476                                  ;	;/* Parse the command line for syntax and switches */
   477                                  
   478                                  	; if(parse_command_line(argc,argv))     
   479                                  
   480                                  		;push	word [bp+argv]
   481                                  		;push	word [bp+argc]
   482                                  
   483 00000084 E88302                  		call 	parse_command_line
   484                                  
   485                                  		;pop	bx
   486                                  		;pop	bx
   487                                  
   488                                  		;or	al,al
   489                                  		;jz	_main_33	; [parse_good] = 0
   490                                  
   491 00000087 0F823C02                		jc	_main_33
   492                                  
   493                                  ;	;/* check to see if switches were set */
   494                                  
   495                                  ;	if ((primary_flag == FALSE) && (extended_flag == FALSE) &&
   496                                  ;           (logical_flag == FALSE) && (disk_flag == FALSE) && (mbr_flag == FALSE))
   497                                  
   498 0000008B 803E[0EA1]00            		cmp	byte [primary_flag],0
   499 00000090 7557                    		jne	short _main_04 ; _main_11
   500 00000092 803E[E4C3]00            		cmp	byte [extended_flag],0
   501 00000097 7550                    		jne	short _main_04 ; _main_11
   502 00000099 803E[E1C3]00            		cmp	byte [logical_flag],0
   503 0000009E 7549                    		jne	short _main_04 ; _main_11
   504 000000A0 803E[A4A0]00            		cmp	byte [disk_flag],0
   505 000000A5 7544                    		jne	short _main_05 ; _main_14
   506 000000A7 803E[3CA1]00            		cmp	byte [mbr_flag],0
   507 000000AC 753D                    		jne	short _main_05 ; _main_14
   508                                  
   509 000000AE C606[78A0]00            		mov	byte [reboot_flag],0
   510                                  
   511                                  ;	;/* See if running evironment is ok (Got hardfile, no network)
   512                                  
   513 000000B3 E82713                  		call	check_valid_environment
   514                                  
   515                                  		;or	al,al
   516                                  		;jnz	short _main_02
   517                                  		;jmp	_main_33
   518                                  
   519 000000B6 7303                    		jnc	short _main_02
   520 000000B8 E90C02                  		jmp	_main_33
   521                                  _main_02:
   522                                  ;	;/* Get and save screen mode information */
   523                                  
   524 000000BB E84713                  		call	init_video_information
   525                                  
   526                                  		;mov	ax,79
   527                                  		;push	ax	 ; Bottom Rigth Column (79)  
   528                                  		;mov	ax,24
   529                                  		;push	ax	 ; Bottom Row (24)
   530                                  		;sub	ax,ax ; 0
   531                                  		;push	ax	 ; Top Left Column (0)	
   532                                  		;push	ax	 ; Top Row (0)
   533                                  		;
   534                                  		;call	clear_screen
   535                                  		;
   536                                  		;add	sp,8	; 15/11/2018
   537                                  
   538                                  		; Clear screen (clear whole video page)
   539 000000BE E89D13                  		call	CLS	; 16/11/2018
   540                                  
   541                                  ;	;/* Get disk size information */
   542                                  
   543                                  		; for (i=0; i < u(MAX_HDISK); i++)
   544                                                  ;     good_disk[i] = TRUE;
   545                                  
   546                                  		;mov	word [_i],0
   547 000000C1 31DB                    		xor	bx,bx
   548                                  _main_03:
   549                                  		;mov	bx,[_i]
   550 000000C3 C687[50A1]01            		mov	byte [good_disk+bx],1 ; TRUE
   551                                  		;inc	word [_i]
   552                                  		;inc	bx
   553 000000C8 FEC3                    		inc	bl
   554                                  		;cmp	word [_i],8
   555 000000CA 80FB08                  		cmp	bl,8
   556 000000CD 72F4                    		jb	short _main_03
   557                                  
   558                                  		; if (get_disk_info())
   559                                  
   560 000000CF E8E813                  		call	get_disk_info
   561                                  
   562                                  		;or	al,al
   563                                  		;jz	short _main_07
   564                                  
   565 000000D2 721F                    		jc	short _main_07
   566                                  
   567                                  ;	;/* build memory model of partitions */
   568                                  
   569 000000D4 E8A518                  		call	init_partition_tables
   570 000000D7 C606[E2CB]00            		mov	byte [cur_disk],0
   571                                  
   572                                  		;if (status_flag == TRUE)
   573 000000DC 803E[E2C3]01            		cmp	byte [status_flag],1 ; TRUE
   574 000000E1 750A                    		jne	short _main_06  ; else
   575                                  
   576 000000E3 E8581F                  		call	change_current_drive
   577                                  		;jmp	short _main_07
   578                                  		; 19/11/2018
   579 000000E6 E9DE01                  		jmp	_main_33
   580                                  _main_04:
   581 000000E9 EB31                    		jmp	_main_11
   582                                  _main_05:
   583 000000EB EB58                    		jmp	_main_14	
   584                                  _main_06:
   585                                  
   586                                  ;	;/* Go do main screen */
   587 000000ED E8962B                  		call	do_main_menu
   588 000000F0 E8D835                  		call	write_info_to_disk
   589                                  _main_07:
   590                                  		; if (!status_flag)
   591 000000F3 803E[E2C3]00            		cmp	byte [status_flag],0 ; FALSE
   592 000000F8 7403                    		je	short _main_08
   593 000000FA E9CA01                  		jmp	_main_33
   594                                  _main_08:
   595 000000FD 803E[78A0]00            		cmp	byte [reboot_flag],0
   596 00000102 7408                    		je	short _main_09
   597 00000104 E8DE34                  		call	reboot_system
   598                                  
   599                                  		; DOSEXIT((unsigned) 0,(unsigned) 0); 
   600 00000107 29C0                    		sub	ax,ax
   601                                  		;push	ax
   602                                  		;push	ax
   603 00000109 E85CFF                  		call	DOSEXIT
   604                                  _main_09:
   605 0000010C 803E[13C4]00            		cmp	byte [no_fatal_error],0
   606 00000111 7503                    		jne	short _main_10
   607 00000113 E9B101                  		jmp	_main_33
   608                                  _main_10:
   609                                  ;	 ;/* Nearly done, go reset screen mode */
   610                                  
   611 00000116 E82813                  		call	reset_video_information
   612 00000119 E9AB01                  		jmp	_main_33
   613                                  ; else
   614                                  
   615                                  ; if ((((primary_flag == FALSE) && (extended_flag == FALSE) &&
   616                                  ;        (logical_flag == FALSE)) || (disk_flag == FALSE)) && (mbr_flag == FALSE))
   617                                  ; display_msg((int)8,(int)DosStdEr,(int)nosubcnt,(int)nosubptr,c(noinput),c(Utility_Msg_Class))	
   618                                  
   619                                  _main_11:
   620 0000011C 803E[A4A0]00            		cmp	byte [disk_flag],0
   621 00000121 7522                    		jne	short _main_14
   622                                  
   623 00000123 803E[3CA1]00            		cmp	byte [mbr_flag],0
   624 00000128 751B                    		jne	short _main_14
   625                                  
   626                                  _main_12:	; 14/11/2018
   627                                  		;jmp	short_main_37		
   628                                  
   629 0000012A B0FF                    		mov	al,-1
   630 0000012C 50                      		push	ax
   631 0000012D 28C0                    		sub	al,al
   632 0000012F 50                      		push	ax
   633 00000130 29C0                    		sub	ax,ax
   634 00000132 50                      		push	ax
   635 00000133 50                      		push	ax
   636 00000134 B80200                  		mov	ax,2
   637 00000137 50                      		push	ax
   638 00000138 B80800                  		mov	ax,8
   639                                  _main_13:
   640 0000013B 50                      		push	ax
   641 0000013C E8DB0B                  		call	display_msg
   642 0000013F 83C40C                  		add	sp,12
   643 00000142 E98201                  		jmp	_main_33
   644                                  
   645                                  ;_main_37:
   646                                  		; Temporary - 10/11/2018
   647                                  		;mov	ax,10
   648                                  		;call	print_parse_error_msg
   649                                  		;jmp	_main_33
   650                                  
   651                                  ; ----------------------------------------------------------------------------
   652                                  
   653                                  _main_14:
   654 00000145 C606[78A0]00            		mov	byte [reboot_flag],0  ; FALSE
   655                                  
   656                                  ;	;/* Get disk size information */
   657                                  
   658                                  		; for (i=0; i < u(MAX_HDISK); i++)
   659                                                  ;     good_disk[i] = TRUE;
   660                                  
   661                                  		;mov	word [_i],0
   662 0000014A 31DB                    		xor	bx,bx
   663                                  _main_15:
   664                                  		;mov	bx,[_i]
   665 0000014C C687[50A1]01            		mov	byte [good_disk+bx],1 ; TRUE
   666                                  		;inc	word [_i]
   667                                  		;inc	bx
   668 00000151 FEC3                    		inc	bl
   669                                  		;cmp	word [_i],8
   670 00000153 80FB08                  		cmp	bl,8
   671 00000156 72F4                    		jb	short _main_15
   672                                  
   673                                  		; if (get_disk_info())
   674                                  
   675 00000158 E85F13                  		call	get_disk_info
   676                                  
   677                                  		;or	al,al
   678                                  		;jz	short _main_33
   679                                  
   680                                  		;jc	short _main_33
   681 0000015B 0F826801                		jc	_main_33
   682                                  
   683                                  _main_16:
   684 0000015F A0[1DC4]                		mov	al,[cur_disk_buff]
   685 00000162 98                      		cbw	; ah = 0
   686 00000163 40                      		inc	ax
   687 00000164 8A0E[E3C3]              		mov	cl,[number_of_drives]
   688 00000168 28ED                    		sub	ch,ch
   689                                  
   690                                  ; if (number_of_drives < (cur_disk_buff+1))
   691                                  ; display_msg((int)8,(int)DosStdEr,(int)nosubcnt,(int)nosubptr,c(noinput),c(Utility_Msg_Class));
   692                                  
   693 0000016A 39C8                    		cmp	ax,cx
   694 0000016C 7FBC                    		jg	short _main_12
   695                                  
   696                                  ; else
   697                                  ;	if(mbr_flag == TRUE)  
   698                                  
   699 0000016E 803E[3CA1]01            		cmp	byte [mbr_flag],1
   700 00000173 754B                    		jne	short _main_22
   701                                  
   702                                  ; if(!read_boot_record(0,0,0,1))
   703                                  ; display_msg((int)11,(int)DosStdEr,(int)nosubcnt,(int)nosubptr,c(noinput),c(Utility_Msg_Class));
   704                                  
   705 00000175 B001                    		mov	al,1
   706                                  		; ah = 0
   707 00000177 50                      		push	ax
   708 00000178 28C0                    		sub	al,al ; al = 0
   709 0000017A 50                      		push	ax
   710 0000017B 50                      		push	ax
   711                                  		;sub	ax,ax ; ah = 0
   712 0000017C 50                      		push	ax
   713 0000017D E87C1E                  		call	read_boot_record
   714                                  		;add	sp,8  ; 22/12/2018
   715                                  		
   716                                  		;or	al,al
   717                                  		;jnz	short _main_18
   718                                  		
   719 00000180 7311                    		jnc	short _main_18
   720                                  ; else  
   721                                  _main_17:
   722                                  		; 19/11/2018
   723                                  		;mov	al,-1
   724                                  		; 11/12/2018
   725 00000182 31C0                    		xor	ax,ax ; 0
   726 00000184 FEC8                    		dec	al ; -1
   727 00000186 50                      		push	ax
   728                                  		;sub	al,al
   729 00000187 FEC0                    		inc	al ; 0
   730 00000189 50                      		push	ax
   731                                  		;sub	ax,ax
   732 0000018A 50                      		push	ax
   733 0000018B 50                      		push	ax
   734                                  		;mov	ax,2
   735 0000018C B002                    		mov	al,2 ; 11/12/2018
   736 0000018E 50                      		push	ax
   737                                  		;mov	ax,11
   738 0000018F B00B                    		mov	al,11
   739 00000191 EBA8                    		jmp	short _main_13
   740                                  
   741                                  _main_18:
   742                                  ;	if((boot_record[0x1FE]==0x55) && (boot_record[0x1FF]==0xAA)) 
   743                                  
   744                                  		;cmp	byte [boot_record+1FEh],55h
   745                                  		;jne	short _main_19
   746                                  		;cmp	[boot_record+1FFh],0AAh
   747                                  		;jne	short _main_19
   748                                  
   749                                  		;mov	cx,1FFh ; 10/11/2018
   750 00000193 B9BD01                  		mov	cx,1BDh
   751                                   
   752 00000196 813E[DECB]55AA          		cmp	word [boot_record+1FEh],0AA55h
   753                                  		;jne	short _main_19
   754 0000019C 7402                    		je	short _main_19 ; 10/11/2018
   755                                  
   756                                  		; for(i=0; i<=0x1BD; i++)
   757                                                  ;    boot_record[i] = master_boot_record[0][i]; 
   758                                  
   759                                  		;;mov	cx,1BDh
   760                                  		;mov	cl,0BDh ; 10/11/2018
   761 0000019E B1FF                    		mov	cl,0FFh
   762                                  _main_19:
   763                                  		;mov	word [_i],0
   764 000001A0 31DB                    		xor	bx,bx
   765                                  _main_20:
   766                                  		;mov	bx,[_i]
   767 000001A2 8A87[925F]              		mov     al,[master_boot_record+bx]
   768 000001A6 8887[E0C9]              		mov	[boot_record+bx],al
   769                                  		;inc	word [_i]
   770 000001AA 43                      		inc	bx
   771                                  		;cmp	word [_i],cx
   772 000001AB 39CB                    		cmp	bx,cx
   773 000001AD 76F3                    		jbe	short _main_20
   774                                  
   775                                  		; 15/12/2018
   776                                  		;sub	al,al ; disk 0
   777 000001AF 29C0                    		sub	ax,ax
   778 000001B1 50                      		push	ax 
   779                                  		;sub	ax,ax ; cylinder 0
   780 000001B2 50                      		push	ax
   781 000001B3 E88C2A                  		call	write_boot_record
   782                                  		;pop	bx
   783                                  		;pop	bx ; 22/12/2018
   784                                  		
   785                                  		;or	al,al
   786                                  		;jz	short _main_17
   787                                  		
   788 000001B6 72CA                    		jc	short _main_17
   789                                  
   790 000001B8 E90C01                  		jmp	_main_33
   791                                  _main_21:
   792                                  ;	else
   793                                          	; for(i=0; i<=0x1FF; i++)
   794                                                  ;    boot_record[i] = master_boot_record[0][i];        
   795                                  
   796 000001BB B9FF01                  		mov	cx,1FFh
   797 000001BE EBE0                    		jmp	short _main_19
   798                                  
   799                                  _main_22:
   800                                  ;	;/* build memory model of partitions */
   801                                  
   802 000001C0 E8B917                  		call	init_partition_tables
   803                                  
   804                                  ;	;/* set cur_disk to current disk */
   805                                  
   806 000001C3 A0[1DC4]                		mov	al,[cur_disk_buff]
   807 000001C6 A2[E2CB]                		mov	[cur_disk],al
   808                                  
   809                                  		DOS12	equ  1	; FAT12 PARTITION ID
   810                                  		DOS16	equ  4	; FAT16 PARTITION (<=32MB) ID
   811                                  		DOSNEW	equ  6	; FAT16 BIG PARTITION (<32MB) ID
   812                                  	
   813                                  		;DOS16BIG equ 6	; FAT16 BIG PARTITION (>32MB) ID
   814                                  
   815                                  		EXTENDED equ 5	; EXTENDED DOS PARTITION ID
   816                                  
   817                                  ;	;/* If /PRI: was specified, create primary partition */
   818                                  ;	;/* check to see if a primary partition already exists */
   819                                  
   820 000001C9 803E[0EA1]01            		cmp	byte [primary_flag],1
   821 000001CE 7551                    		jne	short _main_25
   822                                  
   823                                  ;	if ( (primary_flag == TRUE)  && 
   824                                  ;          ( (!find_partition_type(uc(DOS12))) &&
   825                                  ;            (!find_partition_type(uc(DOS16))) &&
   826                                  ;            (!find_partition_type(uc(DOSNEW))) ) )
   827                                  
   828 000001D0 B001                    		mov	al,DOS12 ; 1
   829                                  		;push	ax
   830 000001D2 E8EF1B                  		call	find_partition_type
   831                                  		;pop	bx
   832                                  		;or	al,al
   833                                  		;jnz	short _main_25
   834 000001D5 734A                    		jnc	short _main_25
   835                                  
   836 000001D7 B004                    		mov	al,DOS16 ; 4
   837                                  		;push	ax
   838 000001D9 E8E81B                  		call	find_partition_type
   839                                  		;pop	bx
   840                                  		;or	al,al
   841                                  		;jnz	short _main_25
   842 000001DC 7343                    		jnc	short _main_25
   843                                  
   844 000001DE B006                    		mov	al,DOSNEW ; 6
   845                                  		;push	ax
   846 000001E0 E8E11B                  		call	find_partition_type
   847                                  		;pop	bx
   848                                  		;or	al,al
   849                                  		;jnz	short _main_25
   850 000001E3 733C                    		jnc	short _main_25
   851                                  
   852 000001E5 30C0                    		xor	al,al ; 14/01/2019
   853                                  		;push	ax
   854                                  		; AL = 0
   855 000001E7 E8B44E                  		call	find_part_free_space
   856                                  		;pop	bx
   857                                  
   858                                  ;	temp = find_part_free_space((char) PRIMARY);
   859                                  ;	if (primary_buff >= free_space[temp].mbytes_unused)
   860                                  
   861 000001EA A2[1CD0]                		mov	[_temp],al
   862                                  		;mov	al,22
   863                                  		;imul	byte [_temp]
   864 000001ED B316                    		mov	bl,22
   865 000001EF F6E3                    		mul	bl
   866 000001F1 89C3                    		mov	bx,ax
   867 000001F3 A1[DEC3]                		mov	ax,[primary_buff]
   868                                  		; 13/01/2019
   869 000001F6 3987[F6CB]              		cmp	[free_space.mbytes_unused+bx],ax
   870 000001FA 7706                    		ja	short _main_23
   871 000001FC 8B87[F0CB]              		mov	ax,[free_space.space+bx]
   872 00000200 EB0B                    		jmp	short _main_24
   873                                  _main_23:
   874                                  ;else
   875                                  ;	input = (unsigned)mbytes_to_cylinders(primary_buff,cur_disk_buff);
   876                                  
   877 00000202 A0[1DC4]                		mov	al,[cur_disk_buff]
   878 00000205 50                      		push	ax
   879 00000206 FF36[DEC3]              		push	word [primary_buff]
   880 0000020A E8BC54                  		call	mbytes_to_cylinders
   881                                  		;pop	bx
   882                                  		;pop	bx
   883                                  _main_24:
   884                                  ;	make_partition(input,temp,uc(ACTIVE),(char)PRIMARY);
   885                                  
   886 0000020D A3[1ED0]                		mov	[_input],ax
   887 00000210 28C0                    		sub	al,al ; 0 	
   888 00000212 50                      		push	ax	      ; mp_type - PRIMARY -			
   889 00000213 B080                    		mov	al,80h
   890 00000215 50                      		push	ax	      ; mp_bootable - bootable, active -  	
   891 00000216 A0[1CD0]                		mov	al,[_temp]	
   892 00000219 50                      		push	ax	      ;	mp_free_ptr (byte)
   893 0000021A FF36[1ED0]              		push	word [_input] ; mp_size (word)
   894 0000021E E82F53                  		call	make_partition
   895                                  		;add	sp,8
   896                                  _main_25:
   897                                  
   898                                  ; /* If /EXT: was specified, create extended partition */
   899                                  ; /* Check and see if there is a primary partition before you create an extended */
   900                                  
   901 00000221 803E[E4C3]01            		cmp	byte [extended_flag],1
   902 00000226 755F                    		jne	short _main_29
   903                                  
   904                                  ;	if ( (extended_flag == TRUE) && 
   905                                  ;	   ( (cur_disk >= c(1)) ||
   906                                  ;	     (find_partition_type(uc(DOS12))) ||
   907                                  ;	     (find_partition_type(uc(DOS16))) ||
   908                                  ;	     (find_partition_type(uc(DOSNEW))) ) ) 
   909                                  
   910 00000228 803E[E2CB]01            		cmp	byte [cur_disk],1
   911 0000022D 7D15                    		jge	short _main_26
   912                                  
   913 0000022F B001                    		mov	al,DOS12 ; 1
   914                                  		;push	ax
   915 00000231 E8901B                  		call	find_partition_type
   916                                  		;pop	bx
   917                                  		;or	al,al
   918                                  		;jnz	short _main_26
   919 00000234 730E                    		jnc	short _main_26
   920                                  
   921 00000236 B004                    		mov	al,DOS16 ; 4
   922                                  		;push	ax
   923 00000238 E8891B                  		call	find_partition_type
   924                                  		;pop	bx
   925                                  		;or	al,al
   926                                  		;jnz	short _main_26
   927 0000023B 7307                    		jnc	short _main_26
   928                                  
   929 0000023D B006                    		mov	al,DOSNEW ; 6
   930                                  		;push	ax
   931 0000023F E8821B                  		call	find_partition_type
   932                                  		;pop	bx
   933                                  		;or	al,al
   934                                  		;jz	short _main_29
   935 00000242 7243                    		jc	short _main_29
   936                                  
   937                                  _main_26:
   938                                  ;	;/* Make sure there isn't an extended already there */
   939                                  ;	if (!find_partition_type(uc(EXTENDED))) 
   940                                    
   941 00000244 B005                    		mov	al,EXTENDED ; 5
   942                                  		;push	ax
   943 00000246 E87B1B                  		call	find_partition_type
   944                                  		;pop	bx
   945                                  		;or	al,al
   946                                  		;jnz	short _main_29
   947 00000249 733C                    		jnc	short _main_29
   948                                  
   949                                  	; temp = find_part_free_space((char) EXTENDED);
   950                                  	
   951 0000024B B005                    		mov	al,EXTENDED ; 5
   952                                  		;push	ax
   953 0000024D E84E4E                  		call	find_part_free_space
   954                                  		;pop	bx
   955                                  		
   956 00000250 A2[1CD0]                		mov	[_temp],al
   957                                  		;mov	al,22
   958                                  		;imul	byte [_temp]
   959 00000253 B316                    		mov	bl,22
   960 00000255 F6E3                    		mul	bl
   961 00000257 89C3                    		mov	bx,ax
   962                                  ;
   963                                  ; if (extended_buff >= free_space[temp].mbytes_unused)
   964                                  ;	input = free_space[temp].space;
   965                                  ; else
   966                                  ; 	input = (unsigned)mbytes_to_cylinders(extended_buff,cur_disk_buff);
   967                                  ; 
   968 00000259 A1[DAC3]                		mov	ax,[extended_buff]
   969                                  		; 13/01/2019
   970 0000025C 3987[F6CB]              		cmp	[free_space.mbytes_unused+bx],ax
   971 00000260 7706                    		ja	short _main_27
   972 00000262 8B87[F0CB]              		mov	ax,[free_space.space+bx]
   973 00000266 EB0B                    		jmp	short _main_28
   974                                  _main_27:
   975 00000268 A0[1DC4]                		mov	al,[cur_disk_buff]
   976 0000026B 50                      		push	ax
   977 0000026C FF36[DAC3]              		push	word [extended_buff]
   978 00000270 E85654                  		call	mbytes_to_cylinders
   979                                  		;pop	bx
   980                                  		;pop	bx
   981                                  _main_28:
   982                                  ;	make_partition(input,temp,(unsigned char) NUL,(char) EXTENDED)
   983                                  
   984 00000273 A3[1ED0]                		mov	[_input],ax
   985 00000276 B005                    		mov	al,EXTENDED ; 5
   986 00000278 50                      		push	ax		; mp_type (byte) - EXTENDED -
   987 00000279 28C0                    		sub	al,al ; 0
   988 0000027B 50                      		push	ax		; mp_bootable (byte) - not bootable -
   989 0000027C A0[1CD0]                		mov	al,[_temp]
   990 0000027F 50                      		push	ax		; mp_free_ptr (byte)
   991 00000280 FF36[1ED0]              		push	word [_input]	; mp_size (word)
   992 00000284 E8C952                  		call	make_partition
   993                                  		;add	sp,8
   994                                  
   995                                  _main_29:
   996                                  ;	;/* If /LOG: was specified, create logical partition */
   997                                  ;
   998                                  ;	   if ( (logical_flag == TRUE) &&
   999                                  ;	        (find_partition_type(uc(EXTENDED))) )
  1000                                  
  1001 00000287 803E[E1C3]01            		cmp	byte [logical_flag],1 ; TRUE
  1002 0000028C 7536                    		jne	short _main_32
  1003 0000028E B005                    		mov	al,EXTENDED ; 5
  1004                                  		;push	ax
  1005 00000290 E8311B                  		call	find_partition_type
  1006                                  		;pop	bx
  1007                                  		;or	al, al
  1008                                  		;jz	short _main_32
  1009 00000293 722F                    		jc	short _main_32
  1010                                  
  1011                                  		; temp = find_ext_free_space();
  1012                                      		
  1013 00000295 E8C154                  		call	find_ext_free_space
  1014 00000298 A2[1CD0]                		mov	[_temp],al
  1015                                  		;mov	al,22
  1016                                  		;imul	byte [_temp]
  1017 0000029B B316                    		mov	bl,22
  1018 0000029D F6E3                    		mul	bl
  1019 0000029F 89C3                    		mov	bx,ax
  1020                                  ;
  1021                                  ; if (logical_buff >= free_space[temp].mbytes_unused)
  1022                                  ;	input = free_space[temp].space;
  1023                                  ; else
  1024                                  ;	input = (unsigned)mbytes_to_cylinders(logical_buff,cur_disk_buff);
  1025                                  ;
  1026 000002A1 A1[E0CB]                		mov	ax,[logical_buff]
  1027                                  		; 13/01/2019
  1028 000002A4 3987[F6CB]              		cmp	[free_space.mbytes_unused+bx],ax
  1029 000002A8 7706                    		ja	short _main_30
  1030 000002AA 8B87[F0CB]              		mov	ax,[free_space.space+bx]
  1031 000002AE EB0B                    		jmp	short _main_31
  1032                                  _main_30:
  1033 000002B0 A0[1DC4]                		mov	al,[cur_disk_buff]
  1034 000002B3 50                      		push	ax
  1035 000002B4 FF36[E0CB]              		push	word [logical_buff]
  1036 000002B8 E80E54                  		call	mbytes_to_cylinders
  1037                                  		;pop	bx
  1038                                  		;pop	bx
  1039                                  _main_31:
  1040                                  		;mov	[_input],ax
  1041                                  
  1042                                  		; make_volume(input,temp);  
  1043                                  
  1044                                  		;mov	al,[_temp]
  1045                                  		;push	ax
  1046 000002BB 8A1E[1CD0]              		mov	bl,[_temp]
  1047 000002BF 53                      		push	bx
  1048                                  		;push	word [_input]
  1049 000002C0 50                      		push	ax
  1050 000002C1 E8FE56                  		call	make_volume
  1051                                  		;pop	bx
  1052                                  		;pop	bx
  1053                                  _main_32:
  1054 000002C4 E80434                  		call	write_info_to_disk
  1055                                  _main_33:
  1056 000002C7 C606[E2CB]00            		mov	byte [cur_disk],0
  1057                                  
  1058                                  ;  if ( (quiet_flag == TRUE) &&
  1059                                  ;	(!find_partition_type(uc(DOS12))) &&
  1060                                  ;	(!find_partition_type(uc(DOS16))) &&
  1061                                  ;	(!find_partition_type(uc(DOSNEW))) )  
  1062                                  
  1063 000002CC 803E[4EA1]01            		cmp	byte [quiet_flag],1
  1064                                  		;jne	short _main_34
  1065 000002D1 7534                    		jne	short _main_35
  1066                                  
  1067 000002D3 B001                    		mov	al,DOS12 ; 1
  1068                                  		;push	ax
  1069 000002D5 E8EC1A                  		call	find_partition_type
  1070                                  		;pop	bx
  1071                                  		;or	al,al
  1072                                  		;jnz	short _main_34
  1073 000002D8 7313                    		jnc	short _main_34
  1074                                  		
  1075 000002DA B004                    		mov	al,DOS16 ; 4
  1076                                  		;push	ax
  1077 000002DC E8E51A                  		call	find_partition_type
  1078                                  		;pop	bx
  1079                                  		;or	al,al
  1080                                  		;jnz	short _main_34
  1081 000002DF 730C                    		jnc	short _main_34
  1082                                  		
  1083 000002E1 B006                    		mov	al,DOSNEW ; 6
  1084                                  		;push	ax
  1085 000002E3 E8DE1A                  		call	find_partition_type
  1086                                  		;pop	bx
  1087                                  		;or	al,al
  1088                                  		;jnz	short _main_34
  1089 000002E6 7305                    		jnc	short _main_34
  1090                                  
  1091                                  		; exit(ERR_LEVEL_1);
  1092 000002E8 B80100                  		mov	ax,1
  1093 000002EB EB1C                    		jmp	short _main_36
  1094                                  _main_34:
  1095                                  ;  else
  1096                                  	; if ((quiet_flag == TRUE) && 
  1097                                  	;     (primary_flag == FALSE) && 
  1098                                  	;     (extended_flag == FALSE) && 
  1099                                  	;     (logical_flag == FALSE))   
  1100                                  
  1101                                  		;cmp	byte [quiet_flag],1
  1102                                  		;jne	short _main_35
  1103                                  
  1104 000002ED 803E[0EA1]00            		cmp	byte [primary_flag],0
  1105 000002F2 7513                    		jne	short _main_35
  1106 000002F4 803E[E4C3]00            		cmp	byte [extended_flag],0
  1107 000002F9 750C                    		jne	short _main_35
  1108 000002FB 803E[E1C3]00            		cmp	byte [logical_flag],0
  1109 00000300 7505                    		jne	short _main_35
  1110                                  
  1111                                  		; exit(ERR_LEVEL_2);
  1112 00000302 B80200                  		mov	ax,2
  1113 00000305 EB02                    		jmp	short _main_36
  1114                                  _main_35:
  1115                                  	; else	
  1116                                  		; exit(ERR_LEVEL_0);
  1117 00000307 29C0                    		sub	ax,ax
  1118                                  _main_36:
  1119                                  		;push	ax
  1120                                  		;call	_exit
  1121                                  		;pop	bx
  1122                                  		
  1123                                  		;mov	sp,bp
  1124                                  		;pop	bp
  1125                                  
  1126 00000309 C3                      		retn	; Return to '_astart:', '_exit:' address.
  1127                                  
  1128                                  ; ----------------------------------------------------------------------------
  1129                                  ; Microsoft (Optimizing) C 6.0 - STDARGV.ASM
  1130                                  ; ----------------------------------------------------------------------------
  1131                                  ; Modified for NASM syntax & single C/D/S segment (by Erdogan Tan, 07/11/2018)
  1132                                  
  1133                                  ;*****************************************************************************
  1134                                  ;stdargv.asm - standard & wildcard _setargv routine
  1135                                  ;
  1136                                  ;	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
  1137                                  ;
  1138                                  ;Purpose:
  1139                                  ;	processes program command line, with or without wildcard expansion
  1140                                  ;
  1141                                  ;*****************************************************************************
  1142                                  
  1143                                  ;_setargv, __setargv - set up "argc" and "argv" for C programs
  1144                                  ;
  1145                                  ;Purpose:
  1146                                  ;	Gets the command line from the PSP and moves the information
  1147                                  ;	to its place on the stack.
  1148                                  ;
  1149                                  ;	SIDE EFFECTS:
  1150                                  ;		Allocates space on the stack for the argument strings
  1151                                  ;		and a list of pointers to them.
  1152                                  ;	ASSUMPTIONS:
  1153                                  ;		Under DOS 2, there is no argv[0] string, so we store a null
  1154                                  ;		char ('\0').
  1155                                  ;
  1156                                  ;		Under DOS 3 and later, the argv[0] string is found in the
  1157                                  ;		environment segment, after the double null that terminates
  1158                                  ;		that segment and after a word of value 1.  The rest of the
  1159                                  ;		command line is found in the Program Segment Prefix at
  1160                                  ;		offset 81H, and is terminated by a 0DH.  This command "tail"
  1161                                  ;		cannot be greater than 126 bytes in length.
  1162                                  ;
  1163                                  ;		Quote marks and backslashes are treated specially.  A quoted
  1164                                  ;		string is passed as a single argument, not including the
  1165                                  ;		opening and closing quote characters.  A quote may be imbedded
  1166                                  ;		in a string by placing an odd number of backslashes (`\')
  1167                                  ;		before it.  Each pair of backslashes which precedes a quote
  1168                                  ;		results in a single backslash in the resultant string.
  1169                                  ;		An even number of backslashes followed by a quote results in
  1170                                  ;		half that many backslashes, and the quote begins or ends the
  1171                                  ;		quoted part of the string as is appropriate.  Backslashes not
  1172                                  ;		followed by a quote are treated normally.
  1173                                  ;
  1174                                  ;		[""] ==> []
  1175                                  ;		[\"] ==> ["]
  1176                                  ;		[" \" "] == [ " ]
  1177                                  ;		[" \\"] == [ \]
  1178                                  ;		[" \\ "] == [ \\ ]
  1179                                  ;		[" \\\" "] == [ \" ]
  1180                                  ;		etc.
  1181                                  ;		["one two three"] ==> [one two three]
  1182                                  ;		[one" two "three] ==> [one two three]
  1183                                  ;		[o"ne two t"hree] ==> [one two three]
  1184                                  ;		["one \"two\" three"] ==> [one "two" three]
  1185                                  ;		["x\\\"x"] ==> [x\"x]
  1186                                  ;
  1187                                  ;Entry:
  1188                                  ;
  1189                                  ;Exit:
  1190                                  ;	"argv" points to a null-terminated list of pointers to ASCIZ
  1191                                  ;	strings, each of which is an argument from the command line.
  1192                                  ;	"argc" is the number of arguments.  The strings are copied from
  1193                                  ;	the Program Segment Prefix into space allocated on the stack.
  1194                                  ;	The list of pointers is also located on the stack.
  1195                                  ;
  1196                                  ;Uses:
  1197                                  ;	All registers except DS, SS, and BP are modified
  1198                                  ;	Note especially that SI and DI are NOT preserved!
  1199                                  ;
  1200                                  ;Exceptions:
  1201                                  ;
  1202                                  ;*****************************************************************************
  1203                                  
  1204                                  ;_setargv:
  1205                                  ;		DOS_envp equ 2Ch	
  1206                                  ;
  1207                                  ;		pop	word [retadr]	; get return address (offset)
  1208                                  ;
  1209                                  ;; Check and store DOS version. This is done here because it cannot be done
  1210                                  ;; in CRT0.ASM (Windows replaces CRT0.ASM with their own code) and _setargv()
  1211                                  ;; is the only other place in the startup code where the DOS version number
  1212                                  ;; needed.
  1213                                  ;
  1214                                  ;		;mov	ah,30h
  1215                                  ;		;int	21h ; DOS - GET DOS VERSION
  1216                                  ;			 ; Return: AL = major version number (00h for DOS 1.x)
  1217                                  ;		;mov	word [_dosvermajor],ax	
  1218                                  ;		;mov	dx,1	 ; dx = number of bytes in argv[0] if DOS 2.x
  1219                                  ;		;cmp	al,2
  1220                                  ;		;jz	short dos_two
  1221                                  ;
  1222                                  ;		;mov	es,[_psp]
  1223                                  ;	
  1224                                  ;		; get environment segment
  1225                                  ;		;mov	es,[es:DOS_envp] ; [es:2Ch]
  1226                                  ;		;mov	[_pgmptr+2],es	; set global variable "_pgmptr"
  1227                                  ;
  1228                                  ;		mov	ax,[DOS_envp]	; [2Ch] 
  1229                                  ;		mov	[_pgmptr+2],ax
  1230                                  ;
  1231                                  ;		; Erdogan Tan - 07/11/2018
  1232                                  ;		mov	bx,ds ; *
  1233                                  ;		mov	es,ax
  1234                                  ;
  1235                                  ;		xor	ax,ax
  1236                                  ;		cwd
  1237                                  ;		mov	cx,8000h
  1238                                  ;		xor	di,di;		; scan from beginning of environment
  1239                                  ;find_env_end:
  1240                                  ;		repne scasb
  1241                                  ;		scasb
  1242                                  ;		jnz	short find_env_end
  1243                                  ;		inc	di;		; skip count word (always 0x0001)
  1244                                  ;		inc	di
  1245                                  ;		mov	[_pgmptr], di	; set global variable "_pgmptr"
  1246                                  ;		mov	cx,0FFFFh
  1247                                  ;		repne scasb
  1248                                  ;		not	cx
  1249                                  ;		mov	dx,cx;		; DX=number of bytes in argv[0]
  1250                                  ;dos_two:
  1251                                  ;		mov	di,1;		; always start with one argument
  1252                                  ;		mov	si,81h
  1253                                  ;
  1254                                  ;		;mov	ds,[_psp]
  1255                                  ;arg100:
  1256                                  ;
  1257                                  ;;*	Count the command tail arguments
  1258                                  ;;*
  1259                                  ;;
  1260                                  ;;	DI will count the number of arguments
  1261                                  ;;	DX will count the number of bytes needed for the arguments
  1262                                  ;;		(not including the null terminators)
  1263                                  ;
  1264                                  ;arg110:
  1265                                  ;		lodsb
  1266                                  ;		cmp	al,' '	; 20h	; C_BLANK  ; space chr
  1267                                  ;		jz	short arg110
  1268                                  ;		cmp	al,9	; TAB	; C_TAB
  1269                                  ;		jz	short arg110	
  1270                                  ;
  1271                                  ;		;DELIM	arg400;		
  1272                                  ;
  1273                                  ;		cmp	al,0Dh	;  CR	; ENTER
  1274                                  ;		jz	short arg400
  1275                                  ;		or	al,al	; 0 = ASCIIZ string terminator (ZERO chr)
  1276                                  ;		jz	short arg400
  1277                                  ;
  1278                                  ; ----------------------------------------------------------------------------
  1279                                  ; psdata.inc (FDISK, MSDOS 6.0, 1991)	
  1280                                  ; ----------------------------------------------------------------------------
  1281                                  ; 10/11/2018
  1282                                  
  1283                                  ;*******************************************************************
  1284                                  ; Parser include file
  1285                                  ;*******************************************************************
  1286                                  
  1287                                  ;**** Equation field
  1288                                  ;-------- Character code definition
  1289                                  
  1290                                  ; version.inc (	ifndef DBCS)
  1291                                  DB_SPACE EQU 2020h
  1292                                  DB_SP_HI EQU 20h
  1293                                  DB_SP_LO EQU 20h
  1294                                  
  1295                                  _$P_DBSP1	   equ	DB_SP_HI	; 1st byte of DBCS blank
  1296                                  _$P_DBSP2	   equ	DB_SP_LO	; 2nd byte of DBCS blank
  1297                                  _$P_Period	   equ	"."             ;
  1298                                  _$P_Slash	   equ	"/"             ;
  1299                                  _$P_Space	   equ	" "             ; SBCS blank
  1300                                  _$P_Comma	   equ	","             ;
  1301                                  _$P_Switch	   equ	"/"             ;
  1302                                  _$P_Keyword	   equ	"="             ;
  1303                                  _$P_Colon	   equ	":"             ;
  1304                                  _$P_Plus 	   equ	"+"             ;
  1305                                  _$P_Minus	   equ	"-"             ;
  1306                                  _$P_Rparen	   equ	")"             ;
  1307                                  _$P_Lparen	   equ	"("             ;
  1308                                  ;_$P_SQuote	   equ  "'"		; Deleted
  1309                                  _$P_DQuote	   equ	'"'             ;
  1310                                  _$P_NULL 	   equ	0		;
  1311                                  _$P_TAB		   equ	9		;
  1312                                  _$P_CR		   equ	0Dh		;
  1313                                  _$P_LF		   equ	0Ah		;
  1314                                  _$P_ASCII80	   equ	80h		; ASCII 80h character code
  1315                                  
  1316                                  ;-------- Masks
  1317                                  _$P_Make_Lower	   equ	20h		; make lower case character
  1318                                  _$P_Make_Upper	   equ	0FFh-_$P_Make_Lower ; make upper case character
  1319                                  
  1320                                  ;-------- DOS function call related equs
  1321                                  
  1322                                  _$P_DOS_Get_CDI	   equ	3800h		; get country dependent information
  1323                                  					; by this call, following information
  1324                                  struc _$P_CDI	; _$P_CDI		; is returned.
  1325 00000000 ????                    .DateF:	   resw 1			;
  1326 00000002 ??????????              .Money:	   resb	5			;
  1327 00000007 ????                    .1000:	   resb	2			;
  1328 00000009 ????                    .Dec:	   resb 2			;
  1329 0000000B ????                    .DateS:	   resb 2			;
  1330 0000000D ????                    .TimeS:	   resb	2			;
  1331 0000000F ??                      	   resb 1			;
  1332 00000010 ??                      	   resb 1			;
  1333 00000011 ??                      .TimeF:	   resb 1			;
  1334 00000012 ????????                	   resw	2			;
  1335 00000016 ????                    	   resb 2			;
  1336 00000018 ??????????              	   resb	5			;
  1337                                  .size:
  1338                                  endstruc
  1339                                  
  1340                                  _$P_Date_MDY	   equ	0		;
  1341                                  _$P_Date_DMY	   equ	1		;
  1342                                  _$P_Date_YMD	   equ	2		;
  1343                                  ;-------------
  1344                                  _$P_DOS_GetEV	   equ	6300h		; get DBCS EV call
  1345                                  					; DS:SI will points to DBCS EV
  1346                                  ;-------------
  1347                                  _$P_DOS_Get_TBL	   equ	65h		; get uppercase table call
  1348                                  					; following parameters are set
  1349                                  					; to get casemap table.
  1350                                  _$P_DOSTBL_Def	   equ	-1		; get default
  1351                                  _$P_DOSTBL_BL	   equ	5		; buffer length for Tbl pointer
  1352                                  _$P_DOSTBL_File	   equ	4		; get file uppercase table
  1353                                  _$P_DOSTBL_Char	   equ	2		; get character uppercase table
  1354                                  					; By this call following information
  1355                                  					; is returned.
  1356                                  struc _$P_DOS_TBL
  1357 00000000 ??                      .InfoID:   resb 1			; information id for the table
  1358 00000001 ????                    .Off:	   resw 1			; offset address of the table
  1359 00000003 ????                    .Seg:	   resw 1			; segment address of the table
  1360                                  .size:
  1361                                  endstruc
  1362                                  
  1363                                  ; ----------------------------------------------------------------------------------
  1364                                  ; PARMS 	LABEL	BYTE
  1365                                  ;		DW	PARMSX
  1366                                  ;		DB	2		; NUMBER OF STRINGS (0, 1, 2)
  1367                                  ;		DB	length		; LENGTH OF THE NEXT LIST, 0 IF NONE
  1368                                  ;		DB	" .. "		; EXTRA DELIMITER LIST,
  1369                                  ;					; TYPICAL ARE ";", "="
  1370                                  ;					; "," & WHITESPACE ALWAYS
  1371                                  ;		DB	length		; LENGTH OF THE NEXT LIST, 0 IF NONE
  1372                                  ;		DB	" .. "		; EXTRA END OF LINE LIST, CR, LF OR 0 ALWAYS
  1373                                  ; ----------------------------------------------------------------------------------
  1374                                  
  1375                                  ;-------------------------------- PARMS block structure
  1376                                  struc _$P_PARMS	; _$P_PARMS_Blk
  1377 00000000 ????                    .PARMSX_Address:  resw 1		; Address of PARMSX
  1378 00000002 ??                      .Num_Extra:	  resb 1		; Number of extra stuff
  1379 00000003 ??                      .Len_Extra_Delim: resb 1		; Length of extra delimiter
  1380                                  .size:
  1381                                  endstruc
  1382                                  
  1383                                  _$P_Len_PARMS	   equ	4		;
  1384                                  _$P_I_Use_Default   equ	0		; no extra stuff specified
  1385                                  _$P_I_Have_Delim    equ	1		; extra delimiter specified
  1386                                  _$P_I_Have_EOL	   equ	2		; extra EOL specified
  1387                                  
  1388                                  ; ----------------------------------------------------------------------------------
  1389                                  ; PARMSX	LABEL	BYTE
  1390                                  ;		DB	minp,maxp	; MIN, MAX POSITIONAL OPERANDS ALLOWED
  1391                                  ;		DW	CONTROL 	; DESCRIPTION OF POSITIONAL 1
  1392                                  ;		:			; REPEATS maxp-1 TIMES
  1393                                  ;		DB	maxs		; # OF SWITCHES
  1394                                  ;		DW	CONTROL 	; DESCRIPTION OF SWITCH 1
  1395                                  ;		:			; REPEATS maxs-1 TIMES
  1396                                  ;		DB	maxk		; # OF KEYWORD
  1397                                  ;		DW	CONTROL 	; DESCRIPTION OF KEYWORD 1
  1398                                  ;		:			; REPEATS maxk-1 TIMES
  1399                                  ; ----------------------------------------------------------------------------------
  1400                                  
  1401                                  ;-------------------------------- PARMSX block structure
  1402                                  struc _$P_PARMSX ; _$P_PARMSX_Blk		;
  1403 00000000 ??                      .MinP:	      resb 1			; Minimum positional number
  1404 00000001 ??                      .Maxp:	      resb 1			; Maximum positional number
  1405 00000002 ????                    .1st_Control: resw 1			; Address of the 1st CONTROL block
  1406                                  .size:
  1407                                  endstruc
  1408                                  
  1409                                  ;--------------------------------------------------------------------------------------------
  1410                                  ; << Control field definition  >>
  1411                                  ;
  1412                                  ;CONTROL   LABEL   BYTE
  1413                                  ;	   DW	   MATCH_FLAGS	   ; CONTROLS TYPE MATCHED
  1414                                  ;				   ; 8000H=NUMERIC VALUE, (VALUE LIST WILL BE CHECKED)
  1415                                  ;				   ; 4000H=SIGNED NUMERIC VALUE (VALUE LIST WILL BE CHECKED)
  1416                                  ;				   ; 2000H=SIMPLE STRING(VALUE LIST WILL BE CHECKED)
  1417                                  ;				   ; 1000H=DATE STRING (VALUE LIST WON'T BE CHECKED)
  1418                                  ;				   ; 0800H=TIME STRING (VALUE LIST WON'T BE CHECKED)
  1419                                  ;				   ; 0400H=COMPLEX LIST (VALUE LIST WON'T BE CHECKED)
  1420                                  ;				   ; 0200H=FILE SPEC (VALUE LIST WON'T BE CHECKED)
  1421                                  ;				   ; 0100H=DRIVE ONLY (VALUE LIST WON'T BE CHECKED)
  1422                                  ;				   ; 0080H=QUOTED STRING (VALUE LIST WON'T BE CHECKED)
  1423                                  ;				   ; 0010H=IGNORE ":" AT END IN MATCH
  1424                                  ;				   ; 0002H=REPEATS ALLOWED
  1425                                  ;				   ; 0001H=OPTIONAL
  1426                                  ;	   DW	   FUNCTION_FLAGS
  1427                                  ;				   ; 0001H=CAP RESULT BY FILE TABLE
  1428                                  ;				   ; 0002H=CAP RESULT BY CHAR TABLE
  1429                                  ;				   ; 0010H=REMOVE ":" AT END
  1430                                  ;				   ; 0020H=colon is not necessary for switch
  1431                                  ;	   DW	   RESULT	   ; RESULT BUFFER
  1432                                  ;	   DW	   VALUES	   ; VALUE LISTS
  1433                                  ;	   DB	   nid		   ; NUMBER OF KEYWORD/SWITCH SYNONYMS IN FOLLOWING LIST
  1434                                  ;	   DB	   "...",0         ; IF n >0, KEYWORD 1
  1435                                  ;	   :
  1436                                  ;
  1437                                  ;Note:
  1438                                  ;    - The MATCH_FLAG is bit significant. You can set, for example, TIME bit and
  1439                                  ;      DATE bit simalteniously.
  1440                                  ;
  1441                                  ;      The parser examins each bit along with the following priority.
  1442                                  ;
  1443                                  ;      COMPLEX -> DATE -> TIME -> NUMERIC VAL -> SIGNED NUMERIC VAL -> DRIVE ->
  1444                                  ;      FILE SPEC -> SIMPLE STRING.
  1445                                  ;
  1446                                  ;
  1447                                  ;    - When the FUNCTION_FLAG is 0001 or 0002, the STRING pointed to by a pointer
  1448                                  ;      in the result buffer is capitalized.
  1449                                  ;
  1450                                  ;    - Match_Flags 0001H and 0002H have meaning only for the positional.
  1451                                  ;
  1452                                  ;
  1453                                  ;    - The "...",0 (bottom most line) does require '=' or '/'. When you need a
  1454                                  ;      switch, for example, '/A', then STRING points to;
  1455                                  ;
  1456                                  ;			DB    1 	; number of following synonyms
  1457                                  ;			DB   '/A',0
  1458                                  ;
  1459                                  ;      When you need a keyword, for example, 'CODEPAGE=', then "...",0 will be;
  1460                                  ;
  1461                                  ;			DB    1 	; number of following synonyms
  1462                                  ;			DB   'CODEPAGE=',0
  1463                                  ;
  1464                                  ;
  1465                                  ;    - "..." must consist of upper case characters only because the parser
  1466                                  ;      performs pattern matching after converting input to upper case (by
  1467                                  ;      using the current country upper case table)
  1468                                  ;
  1469                                  ;
  1470                                  ;    - One "..." can contain only one switch or keyword. If you need, for
  1471                                  ;      example /A and /B, the format will be;
  1472                                  ;
  1473                                  ;			DB    2 	; number of following synonyms
  1474                                  ;			DB    '/A',0
  1475                                  ;			DB    '/B',0
  1476                                  ;--------------------------------------------------------------------------------------------
  1477                                  
  1478                                  ;**** Match_Flags
  1479                                  
  1480                                  _$P_Num_Val	   equ	8000h		; Numeric Value
  1481                                  _$P_SNum_Val	   equ	4000h		; Signed numeric value
  1482                                  _$P_Simple_S	   equ	2000h		; Simple string
  1483                                  _$P_Date_S	   equ	1000h		; Date string
  1484                                  _$P_Time_S	   equ	0800h		; Time string
  1485                                  _$P_Cmpx_S	   equ	0400h		; Complex string
  1486                                  _$P_File_Spc	   equ	0200h		; File Spec
  1487                                  _$P_Drv_Only	   equ	0100h		; Drive Only
  1488                                  _$P_Qu_String	   equ	0080h		; Quoted string
  1489                                  _$P_Ig_Colon	   equ	0010h		; Ignore colon at end in match
  1490                                  _$P_Repeat	   equ	0002h		; Repeat allowed
  1491                                  _$P_Optional	   equ	0001h		; Optional
  1492                                  
  1493                                  ;**** Function flags
  1494                                  
  1495                                  _$P_CAP_File	   equ	0001h		; CAP result by file table
  1496                                  _$P_CAP_Char	   equ	0002h		; CAP result by character table
  1497                                  _$P_Rm_Colon	   equ	0010h		; Remove ":" at the end
  1498                                  _$P_colon_is_not_necessary equ 0020h	; /+10 and /+:10
  1499                                  
  1500                                  ;-------------------------------- Control block structure
  1501                                  struc _$P_Control_Blk ; _$P_Control_Blk
  1502 00000000 ????                    .Match_Flag:	resw 1		; Controls type matched
  1503 00000002 ????                    .Function_Flag: resw 1		; Function should be taken
  1504 00000004 ????                    .Result_Buf:	resw 1		; Result buffer address
  1505 00000006 ????                    .Value_List:	resw 1		; Value list address
  1506 00000008 ??                      .nid:		resb 1		; # of keyword/SW synonyms
  1507 00000009 ??                      .KeyorSW:	resb 1		; keyword or sw
  1508                                  .size:
  1509                                  endstruc
  1510                                  
  1511                                  ; -------------------------------------------------------------------------------
  1512                                  ; << Value List Definition >>
  1513                                  ;
  1514                                  ;VALUES 	LABEL	BYTE
  1515                                  ;		DB	nval		; NUMBER OF VALUE DEFINITIONS (0 - 3)
  1516                                  ;	     +-
  1517                                  ;	     |	DB	nrng		; NUMBER OF RANGES
  1518                                  ;	     | +DB	ITEM_TAG	; RETURN VALUE IF RANGE MATCHED
  1519                                  ;	     | +DD	X,Y		; RANGE OF VALUES
  1520                                  ;	     |	:
  1521                                  ;	     |	DB	nnval		; NUMBER OF CHOICES
  1522                                  ;	     | +DB	ITEM_TAG	; RETURN VALUE IF NUMBER CHOICE MATCHED
  1523                                  ;	     | +DD	VALUE		; SPECIFIC CHOICE IF NUMBER
  1524                                  ;	     |	:
  1525                                  ;	     |	DB	nstrval 	; NUMBER OF CHOICES
  1526                                  ;	     | +DB	ITEM_TAG	; RETURN VALUE IF STRING CHOICE MATCHED
  1527                                  ;	     | +DW	STRING		; SPECIFIC CHOICE IF STING
  1528                                  ;	     +-	:
  1529                                  ;
  1530                                  ;STRING 	DB	"...",0		; ASCIIZ STRING IMAGE
  1531                                  ;
  1532                                  ;Note:
  1533                                  ;    - ITEM_TAG must not be 0FFH, which will be used in the result buffer
  1534                                  ;      when no choice lists are provided.
  1535                                  ;
  1536                                  ;    - STRING must consist of upper case characters only because the parser
  1537                                  ;      performs pattern matching after converting input to upper case (by
  1538                                  ;      using the current country upper case table)
  1539                                  ; -------------------------------------------------------------------------------
  1540                                  
  1541                                  _$P_nval_None	   equ	0		; no value list ID
  1542                                  _$P_nval_Range	   equ	1		; range list ID
  1543                                  _$P_nval_Value	   equ	2		; value list ID
  1544                                  _$P_nval_String	   equ	3		; string list ID
  1545                                  _$P_Len_Range	   equ	9		; Length of a range choice(two DD plus one DB)
  1546                                  _$P_Len_Value	   equ	5		; Length of a value choice(one DD plus one DB)
  1547                                  _$P_Len_String	   equ	3		; Length of a string choice(one DW plus one DB)
  1548                                  _$P_No_nrng	   equ	0		; (tm07) no nrng. nnval must not be 0.
  1549                                  
  1550                                  struc _$P_Val_List ; _$P_Val_List
  1551 00000000 ??                      .NumofList: resb 1		; number of following choice
  1552 00000001 ????                    .Val_XL:    resw 1		; lower word of value
  1553 00000003 ????                    .Val_XH:    resw 1		; higher word of value
  1554 00000005 ????                    .Val_YL:    resw 1		; lower word of another value
  1555 00000007 ????                    .Val_YH:    resw 1		; higher word of another value
  1556                                  .size:
  1557                                  endstruc
  1558                                  
  1559                                  ;----------------------------------------------------------------------------------------------------------------
  1560                                  ; << Result Buffer Definition  >>
  1561                                  ;
  1562                                  ;RESULT 	LABEL	BYTE			; BELOW FILLED IN FOR DEFAULTS
  1563                                  ;		DB	type			; TYPE RETURNED: 0=RESERVED,
  1564                                  ;						;	1=NUMBER, 2=LIST INDEX,
  1565                                  ;						;	3=STRING, 4=COMPLEX,
  1566                                  ;						;	5=FILESPEC, 6=DRIVE
  1567                                  ;						;	7=DATE, 8=TIME
  1568                                  ;						;	9=QUOTED STRING
  1569                                  ;		DB	ITEM_TAG		; MATCHED ITEM TAG
  1570                                  ;
  1571                                  ;		dw	synonym@		; es:@ points to found SYNONYM if provided.
  1572                                  ;
  1573                                  ;            +-
  1574                                  ;	    | DD	n			; VALUE IF NUMBER
  1575                                  ;	    | or
  1576                                  ;	    |	DW	i			; INDEX (OFFSET) INTO VALUE LIST
  1577                                  ;	    |					; (ES presents Segment address)
  1578                                  ;	    | or
  1579                                  ;	    |	DD	STRING			; OFFSET OF STRING VALUE
  1580                                  ;	    | or
  1581                                  ;	    |	DB	drv			; DRIVE NUMBER (1-A, 2-B,..., 26-Z)
  1582                                  ;	    | or
  1583                                  ;	    |	DW	YEAR	   ;(1980-2099)	IN CASE OF DATE
  1584                                  ;	    |	DB	MONTH	   ;(1-12)	Note: Range check is not performed.
  1585                                  ;	    |	DB	DATE	   ;(1-31)	      0 is filled when the corresponding field was not specified.
  1586                                  ;	    | or
  1587                                  ;	    |	DB	HOUR	   ;(0-23)	IN CASE OF TIME
  1588                                  ;	    |	DB	MINUTES    ;(0-59)	Note: Range check is not performed .
  1589                                  ;	    |	DB	SECONDS    ;(0-59)	      0 is filled when the corresponding field was not specified.
  1590                                  ;	    |	DB	HUNDREDTHS ;(0-99)
  1591                                  ;	    +-
  1592                                  ;
  1593                                  ;Note: ITEM_TAG is 0FFH when the caller does not specify the choice list.
  1594                                  ;
  1595                                  ;      YEAR: If the input value for the year is less than 100, parser
  1596                                  ;	     adds 1900 to it. For example, when 87 is input to parser for
  1597                                  ;	     the year value, he returns 1987.
  1598                                  ;----------------------------------------------------------------------------------------------------------------
  1599                                  
  1600                                  ;-------------------------------- Result block structure
  1601                                  struc _$P_Result ; _$P_Result_Blk
  1602 00000000 ??                      .Type:	      resb 1		; Type returned
  1603 00000001 ??                      .Item_Tag:    resb 1		; Matched item tag
  1604 00000002 ????                    .SYNONYM_Ptr: resw 1		; pointer to Synonym list returned
  1605 00000004 ????????                .Picked_Val:  resb 4		; value
  1606                                  .size:
  1607                                  endstruc
  1608                                  
  1609                                  ;--------------------------------
  1610                                  ;**** values for the type field in the result block
  1611                                  
  1612                                  _$P_EOL		   equ	0		; End of line
  1613                                  _$P_Number	   equ	1		; Number
  1614                                  _$P_List_Idx	   equ	2		; List Index
  1615                                  _$P_String	   equ	3		; String
  1616                                  _$P_Complex	   equ	4		; Complex
  1617                                  _$P_File_Spec	   equ	5		; File Spec
  1618                                  _$P_Drive	   equ	6		; Drive
  1619                                  _$P_Date_F	   equ	7		; Date
  1620                                  _$P_Time_F	   equ	8		; Time
  1621                                  _$P_Quoted_String   equ	9		; Quoted String
  1622                                  
  1623                                  _$P_No_Tag	   equ	0FFH		; No ITEM_TAG found
  1624                                  
  1625                                  ;**** Return code
  1626                                  ;
  1627                                  ; following return code will be returned in the AX register.
  1628                                  
  1629                                  _$P_No_Error	   equ	0		; No error
  1630                                  _$P_Too_Many	   equ	1		; Too many operands
  1631                                  _$P_Op_Missing	   equ	2		; Required operand missing
  1632                                  _$P_Not_In_SW	   equ	3		; Not in switch list provided
  1633                                  _$P_Not_In_Key	   equ	4		; Not in keyword list provided
  1634                                  _$P_Out_Of_Range   equ	6		; Out of range specified
  1635                                  _$P_Not_In_Val	   equ	7		; Not in value list provided
  1636                                  _$P_Not_In_Str	   equ	8		; Not in string list provided
  1637                                  _$P_Syntax	   equ	9		; Syntax error
  1638                                  _$P_RC_EOL	   equ	-1		; End of command line
  1639                                  
  1640                                  _$P_equ		   equ	01h		; "=" packed in string buffet
  1641                                  _$P_Neg		   equ	02h		; Negative value
  1642                                  _$P_Time12	   equ	04h		; set when PM is specified
  1643                                  _$P_Key_Cmp	   equ	08h		; set when keyword compare
  1644                                  _$P_SW_Cmp	   equ	10h		; set when switch compare
  1645                                  _$P_Extra	   equ	20h		; set when extra delimiter found
  1646                                  _$P_SW		   equ	40h		; set when switch found (tm08)
  1647                                  _$P_Signed	   equ	80h		; signed numeric specified
  1648                                  
  1649                                  _$P_NeedToBeRead    equ	0FFFFh		;
  1650                                  
  1651                                  ; delimiter parsing
  1652                                  _$P_colon_period    equ	01		; check for colon & period
  1653                                  _$P_period_only	   equ	02		; check only for period
  1654                                  
  1655                                  _$P_error_filespec  equ	01		; mask to set flag
  1656                                  
  1657                                  ;***********************************************************************
  1658                                  
  1659                                  ; ----------------------------------------------------------------------------
  1660                                  ; fdparse.c (FDISK, MSDOS 6.0, 1991)	
  1661                                  ; ----------------------------------------------------------------------------
  1662                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 07/11/2018)
  1663                                  
  1664                                  ;/*  */
  1665                                  ;/******************************************************************************/
  1666                                  ;/*Routine name:  PARSE_COMMAND_LINE                                           */
  1667                                  ;/******************************************************************************/
  1668                                  ;/*                                                                            */
  1669                                  ;/*Description:   Sets up flags, preloads messages, and parses the command     */
  1670                                  ;/*               line for switchs.                                            */
  1671                                  ;/*                                                                            */
  1672                                  ;/*Called Procedures:                                                          */
  1673                                  ;/*                                                                            */
  1674                                  ;/*Change History: Created        5/30/87         DRM                          */
  1675                                  ;/*                                                                            */
  1676                                  ;/*Input: None                                                                 */
  1677                                  ;/*                                                                            */
  1678                                  ;/*Output: None                                                                */
  1679                                  ;/*                                                                            */
  1680                                  ;/******************************************************************************/
  1681                                  
  1682                                  ;char parse_command_line(argc,argv)
  1683                                  
  1684                                  ;char *argv[];  ; [bp+6]                 ;/* array of pointer arguments */
  1685                                  ;int  argc;	; [bp+4]
  1686                                  
  1687                                  parse_command_line:
  1688                                  	
  1689                                  	;char	cmd_line[128];  ; [bp-86h]
  1690                                          ;char	finished;	; [bp-6]
  1691                                          ;int	i;		; [bp-4]
  1692                                          ;char	parse_good;	; [bp-2]
  1693                                          ;char	far *cmdline;	; [bp-8Ah]
  1694                                  
  1695                                  		;%define cmd_line   bp-134
  1696                                  		;%define finished   bp-6
  1697                                  		;%define i	    bp-4
  1698                                  		;%define parse_good bp-2
  1699                                  		;%define cmdlineptr bp-138
  1700                                  
  1701                                  		; 11/11/2018
  1702                                  		%define cmd_line   bp-128
  1703                                  
  1704                                  		;push	bp
  1705 0000030A 89E5                    		mov	bp,sp
  1706                                  		
  1707                                  		;sub	sp,138 ; 11/11/2018
  1708                                  
  1709 0000030C 81EC8000                		sub	sp,128 ; 11/11/2018		
  1710                                  		
  1711                                  		;push	si
  1712                                  
  1713 00000310 E85300                  		call	parse_init
  1714                                  		;mov	byte [parse_good],1 ; TRUE ; 11/11/2018
  1715                                  
  1716                                  		; Get PSP address
  1717                                  		;mov	ah,62h
  1718                                  		;int	21h
  1719                                  			; Return:
  1720                                  			; BX = segment address of current process
  1721                                  		;mov	word [cmdlineptr],81h
  1722                                  		;;mov	[cmdlineptr+2],bx
  1723                                  		;mov	[cmdlineptr+2],ds
  1724 00000313 BE8100                  		mov	si,81h	; command tail offset
  1725                                  
  1726                                  		;mov	word [i],0
  1727 00000316 8D7E80                  		lea	di,[cmd_line]
  1728 00000319 EB01                    		jmp	short pcmdl_2	
  1729                                  pcmdl_1:
  1730                                  		;mov	al,[es:bx]
  1731                                  		;mov	si,[i]
  1732                                  		;mov	byte [si+cmd_line],al
  1733                                  		;inc	word [cmdlineptr]
  1734                                  		;inc	byte [i]		
  1735 0000031B AA                      		stosb
  1736                                  pcmdl_2:
  1737                                  		;les	bx,[cmdlineptr]
  1738 0000031C AC                      		lodsb
  1739                                  		;cmp	byte [es:bx],0Dh
  1740 0000031D 3C0D                    		cmp	al,0Dh
  1741 0000031F 75FA                    		jne	short pcmdl_1
  1742                                  		;mov	si,[i]
  1743                                  		;mov	byte [si+cmd_line],0Dh
  1744 00000321 30E4                    		xor	ah,ah	
  1745                                  		;;inc	word [i]
  1746                                  		;inc	byte [i]
  1747                                  		;mov	si,[i]
  1748                                  		;mov	byte [si+cmd_line],0
  1749 00000323 AB                      		stosw
  1750                                  		
  1751                                  		;lea	ax,[si+1] ; ?
  1752                                  		;mov	[i],ax
  1753                                  
  1754                                  		;sub	di,cmd_line+1
  1755                                  
  1756 00000324 8D7680                  		lea	si,[cmd_line]
  1757 00000327 29C9                    		sub	cx,cx
  1758                                  		;sub	dx,dx
  1759 00000329 BF[A5A0]                		mov	di,p_p
  1760                                  		;mov	[Parse_Ptr],si
  1761                                  		;mov	word [finished],0
  1762                                  		;mov	[finished],cx ; 0 ; 11/11/2018
  1763                                  pcmdl_3:
  1764 0000032C 8936[EECB]              		mov	[Parse_Ptr],si
  1765 00000330 E89E01                  		call	parse
  1766                                  			; AX = Error Code (0 = No error) ; 14/11/2018
  1767                                  		;and	ax,ax
  1768                                  		;jnz	short pcmdl_5
  1769 00000333 7216                    		jc	short pcmdl_5
  1770                                  
  1771 00000335 81FA[E4CB]              		cmp	dx,p_buff
  1772 00000339 7505                    		jne	short pcmdl_4
  1773 0000033B E8320A                  		call	check_disk_validity
  1774                                  		;jmp	short pcmdl_7
  1775 0000033E EBEC                    		jmp	short pcmdl_3 ; 11/11/2018
  1776                                  pcmdl_4:
  1777 00000340 81FA[E2CC]              		cmp	dx,sp_buff
  1778                                  		;jne	short pcmdl_7
  1779 00000344 75E6                    		jne	short pcmdl_3 ; 11/11/2018
  1780 00000346 E8350A                  		call	process_switch
  1781                                  		;jmp	short pcmdl_7
  1782 00000349 EBE1                    		jmp	short pcmdl_3 ; 11/11/2018
  1783                                  pcmdl_5:
  1784 0000034B 83F8FF                  		cmp	ax,0FFFFh ; -1
  1785                                  		;je	short pcmdl_6	; Empty command tail (CR after file name). 
  1786 0000034E 740F                    		je	short pcmdl_8 ; 11/11/2018		
  1787                                  
  1788                                  		; 14/11/2018
  1789                                  		;jmp	short _pcmdl_10
  1790                                  
  1791                                  		;mov	al,2
  1792                                  		;push	ax
  1793                                  		;mov	ax,2
  1794                                  		;push	ax
  1795                                  		;push	word [regs_x_ax]  ; push word [_$P_RC]
  1796                                  
  1797                                  		;Parse_msg(regs.x.ax,STDERR,Parse_err_class); 
  1798 00000350 BA0200                  		mov	dx,2
  1799 00000353 52                      		push	dx	 ;Message_Type	; PARSE_ERR_CLASS = 2
  1800 00000354 52                      		push	dx	 ;Handle	; STDERR = 2
  1801 00000355 50                      		push	ax 	 ;Msg_Num       ; Error Number = [_$P_RC]
  1802 00000356 E83710                  		call	Parse_msg
  1803 00000359 83C406                  		add	sp,6
  1804                                  
  1805                                  ;_pcmdl_10:
  1806                                  		; TEMPORARY
  1807                                  		; Erdogan Tan - 10/11/2018
  1808                                  		;call	print_parse_error_msg ; (*)
  1809                                  
  1810                                  		;mov	byte [parse_good],0 ; FALSE ; 11/11/2018
  1811                                  
  1812                                  		;sub	al,al
  1813                                  		; AL = 0 (*)
  1814                                  		;jmp	short pcmdl_9 ; 11/11/2018
  1815                                  
  1816                                  		;sub	ah,ah
  1817 0000035C F9                      		stc
  1818 0000035D EB04                    		jmp	short pcmdl_9 ; 11/11/2018
  1819                                  		
  1820                                  pcmdl_6:
  1821                                  		;;mov	byte [finished],1
  1822                                  		;jmp	short pcmdl_8
  1823                                  pcmdl_7:
  1824                                  		;cmp	byte [finished],0
  1825                                  		;je	short pcmdl_3
  1826                                  pcmdl_8:
  1827                                  		;mov	al,[parse_good] ; 11/11/2018
  1828                                  
  1829                                  		;xor	ax,ax
  1830 0000035F 30C0                    		xor	al,al ; clc
  1831 00000361 FEC0                    		inc	al ; 1	; 11/11/2018
  1832                                  pcmdl_9:
  1833                                  		;cmp	al,1	; 11/11/2018
  1834                                  
  1835                                  		;pop	si
  1836                                  		
  1837 00000363 89EC                    		mov	sp,bp
  1838                                  		;pop	bp
  1839                                  		
  1840 00000365 C3                      		retn
  1841                                  
  1842                                  ;/*  */
  1843                                  ;/******************************************************************************/
  1844                                  ;/*Routine name:  INIT_PARSE                                                   */
  1845                                  ;/******************************************************************************/
  1846                                  ;/*                                                                            */
  1847                                  ;/*Description:   Sets up ALL VALUES AND STRUCTS FOR PARSER.                   */
  1848                                  ;/*                                                                            */
  1849                                  ;/*Called Procedures:                                                          */
  1850                                  ;/*                                                                            */
  1851                                  ;/*Change History: Created        6/15/87         DRM                          */
  1852                                  ;/*                                                                            */
  1853                                  ;/*Input: None                                                                 */
  1854                                  ;/*                                                                            */
  1855                                  ;/*Output: None                                                                */
  1856                                  ;/*                                                                            */
  1857                                  ;/******************************************************************************/
  1858                                  
  1859                                  ;void parse_init()
  1860                                  
  1861                                  parse_init:	; 10/11/2018
  1862                                  		;sub	al,al
  1863 00000366 29C0                    		sub	ax,ax
  1864 00000368 A2[0EA1]                		mov	[primary_flag],al
  1865 0000036B A2[E4C3]                		mov	[extended_flag],al
  1866 0000036E A2[E1C3]                		mov	[logical_flag],al
  1867 00000371 A2[A4A0]                		mov	[disk_flag],al
  1868 00000374 A2[4EA1]                		mov	[quiet_flag],al
  1869 00000377 A2[E2C3]                		mov	[status_flag],al
  1870 0000037A A2[3CA1]                		mov	[mbr_flag],al
  1871 0000037D C706[A5A0][94A0]        		mov	word [p_p_p_parmxs_ptr],p_px ; /* Address of extended parm list */
  1872 00000383 C606[A9A0]3B            		mov	byte [p_p_p_extra_delim],';'
  1873                                  		;mov	al,1
  1874 00000388 FEC0                    		inc	al
  1875 0000038A A2[A7A0]                		mov	[p_p_p_num_extra],al
  1876 0000038D A2[A8A0]                		mov	[p_p_p_len_extra_delim],al
  1877 00000390 A2[95A0]                		mov	[p_px_p_maxp],al ; /* 1 maximum positionals */	
  1878 00000393 C706[96A0][14C4]        		mov	word [p_px_p_con1_ptr],p_con ; /* pointer to next control blk */
  1879 00000399 C606[98A0]05            		mov	byte [p_px_p_maxs],5	; /* number of switches */
  1880 0000039E C706[99A0][F6A0]        		mov	word [p_px_p_swi1_ptr],p_swi1 ; /* pointer to next control blk */
  1881 000003A4 C706[9BA0][10A1]        		mov	word [p_px_p_swi2_ptr],p_swi2 ; /* pointer to next control blk */
  1882 000003AA C706[9DA0][1CA1]        		mov	word [p_px_p_swi3_ptr],p_swi3
  1883 000003B0 C706[9FA0][30A1]        		mov	word [p_px_p_swi4_ptr],p_swi4
  1884 000003B6 C706[A1A0][3EA1]        		mov	word [p_px_p_swi5_ptr],p_swi5
  1885                                  		;mov	al,[NOVAL]	 ; /* no keywords */
  1886                                  		;sub	al,al ; 0
  1887 000003BC FEC8                    		dec	al
  1888 000003BE A2[A3A0]                		mov	[p_px_p_maxk],al
  1889                                  		;mov	word [p_con],8001h	; /* DRIVE NUMBER 1 OR 2 optional */
  1890 000003C1 C706[14C4]0180          		mov	word [p_con_p_match_flag],8001h
  1891 000003C7 C706[18C4][E4CB]        		mov	word [p_con_p_buff1_ptr],p_buff
  1892 000003CD C706[1AC4][08C4]        		mov	word [p_con_p_val1_ptr],p_val
  1893 000003D3 28C0                    		sub	al,al ; 0
  1894 000003D5 A2[94A0]                		mov	[p_px_p_minp],al	; /* 1 required positional */
  1895 000003D8 A2[1CC4]                		mov	[p_con_nid],al
  1896                                  		;mov	word [p_swi1],8000h	; /* Optional (switch) */
  1897 000003DB C706[F6A0]0080          		mov	word [p_swi1_sp_match_flag],8000h
  1898                                  		;sub	ax,ax
  1899 000003E1 A3[16C4]                		mov	[p_con_p_function_flag],ax ; /* DO NOTHING FOR FUNCTION FLAG */
  1900 000003E4 A3[F8A0]                		mov	[p_swi1_sp_function_flag],ax ; /* DO NOTHING FOR FUNCTION FLAG */
  1901 000003E7 C706[FAA0][E2CC]        		mov	word [p_swi1_sp_buff1_ptr],sp_buff
  1902 000003ED C706[FCA0][E5C3]        		mov	word [p_swi1_sp_val1_ptr],sp_val
  1903 000003F3 C606[FEA0]03            		mov	byte [p_swi1_sp_nid],3	; /* 3 switches allowed */
  1904                                  
  1905                                  		;mov	ax,PRI	; "/PRI"	; /* /a switch */
  1906                                  		;push	ax
  1907                                  		;mov	ax,p_swi1_sp_switch1
  1908                                  		;push	ax
  1909                                  		;call	strcpy
  1910                                  		;pop	bx
  1911                                  		;pop	bx
  1912 000003F8 BE[6770]                		mov	si,PRI
  1913 000003FB BF[FFA0]                		mov	di,p_swi1_sp_switch1
  1914                                  		;mov	cx,5  ; db '/PRI',0
  1915                                  		;rep	movsb		
  1916 000003FE A5                      		movsw
  1917 000003FF A5                      		movsw
  1918 00000400 A4                      		movsb
  1919                                  
  1920                                  		;mov	ax,EXT	; "/EXT"	; /* /a switch */
  1921                                  		;push	ax
  1922                                  		;mov	ax,p_swi1_sp_switch2
  1923                                  		;push	ax
  1924                                  		;call	strcpy
  1925                                  		;pop	bx
  1926                                  		;pop	bx
  1927 00000401 BE[6C70]                		mov	si,EXT
  1928 00000404 BF[04A1]                		mov	di,p_swi1_sp_switch2
  1929                                  		;mov	cx,5  ; db '/EXT',0
  1930                                  		;mov	cl,5
  1931                                  		;rep	movsb	
  1932 00000407 A5                      		movsw
  1933 00000408 A5                      		movsw	
  1934 00000409 A4                      		movsb
  1935                                  
  1936                                  		;mov	ax,LOG	; "/LOG"	; /* /a switch */
  1937                                  		;push	ax
  1938                                  		;mov	ax,p_swi1_sp_switch3
  1939                                  		;push	ax
  1940                                  		;call	strcpy
  1941                                  		;pop	bx
  1942                                  		;pop	bx
  1943 0000040A BE[7170]                		mov	si,LOG
  1944 0000040D BF[09A1]                		mov	di,p_swi1_sp_switch3
  1945                                  		;mov	cx,5  ; db '/LOG',0
  1946                                  		;mov	cl,5
  1947                                  		;rep	movsb	
  1948 00000410 A5                      		movsw
  1949 00000411 A5                      		movsw
  1950 00000412 A4                      		movsb
  1951                                  
  1952                                  		;mov	[p_swi2],1		; /* Optional (switch) */
  1953 00000413 C706[10A1]0100          		mov	word [p_swi2_sp_match_flag],1
  1954 00000419 C706[12A1]0000          		mov	word [p_swi2_sp_function_flag],0
  1955 0000041F C706[14A1][E2CC]        		mov	word [p_swi2_sp_buff1_ptr],sp_buff
  1956                                  		;mov	ax,[NOVAL]
  1957 00000425 31C0                    		xor	ax,ax ; 0
  1958 00000427 A3[16A1]                		mov	[p_swi2_sp_val1_ptr],ax
  1959 0000042A C606[18A1]01            		mov	byte [p_swi2_sp_nid],1	; /* 1 switch allowed */
  1960                                  
  1961                                  		;mov	ax,QUIET ; "/Q"		; /* /a switch */
  1962                                  		;push	ax
  1963                                  		;mov	ax,p_swi2_sp_switch4
  1964                                  		;push	ax
  1965                                  		;call	strcpy
  1966                                  		;pop	bx
  1967                                  		;pop	bx
  1968 0000042F BE[7670]                		mov	si,QUIET
  1969 00000432 BF[19A1]                		mov	di,p_swi2_sp_switch4
  1970                                  		;mov	cx,3  ; db '/Q',0
  1971                                  		;mov	cl,3
  1972                                  		;rep	movsb
  1973 00000435 A5                      		movsw
  1974 00000436 A4                      		movsb
  1975                                  
  1976 00000437 29C0                    		sub	ax,ax ; 0
  1977                                  		;mov	word [p_swi3],1
  1978 00000439 A3[1CA1]                		mov	[p_swi3_sp_match_flag],ax
  1979 0000043C A3[1EA1]                		mov	[p_swi3_sp_function_flag],ax ; 0
  1980 0000043F C706[20A1][E2CC]        		mov	word [p_swi3_sp_buff1_ptr],sp_buff
  1981                                  		;mov	ax,[NOVAL]
  1982 00000445 A3[22A1]                		mov	[p_swi3_sp_val1_ptr],ax ; 0
  1983 00000448 C606[24A1]01            		mov	byte [p_swi3_sp_nid],1
  1984                                  
  1985                                  		;mov	ax,STATUS ; "/STATUS"
  1986                                  		;push	ax
  1987                                  		;mov	ax,p_swi3_sp_switch5
  1988                                  		;push	ax
  1989                                  		;call	strcpy
  1990                                  		;pop	bx
  1991                                  		;pop	bx
  1992 0000044D BE[7970]                		mov	si,STATUS
  1993 00000450 BF[25A1]                		mov	di,p_swi3_sp_switch5
  1994                                  		;mov	cx,8  ; db '/STATUS',0
  1995                                  		;mov	cl,8
  1996                                  		;rep	movsb
  1997 00000453 B90400                  		mov	cx,4
  1998 00000456 F3A5                    		rep	movsw
  1999                                  
  2000 00000458 29C0                    		sub	ax,ax
  2001                                  		;mov	[p_swi4],ax
  2002 0000045A A3[30A1]                		mov	[p_swi4_sp_match_flag],ax
  2003 0000045D A3[32A1]                		mov	[p_swi4_sp_function_flag],ax
  2004 00000460 C706[34A1][E2CC]        		mov	word [p_swi4_sp_buff1_ptr],sp_buff
  2005                                  		;mov	ax,[NOVAL]
  2006 00000466 A3[36A1]                		mov	[p_swi4_sp_val1_ptr],ax
  2007 00000469 C606[38A1]01            		mov	byte [p_swi4_sp_nid],1
  2008                                  		
  2009                                  		;mov	ax,OPTIONS ; "/?"
  2010                                  		;push	ax
  2011                                  		;mov	ax,p_swi4_sp_switch6
  2012                                  		;push	ax
  2013                                  		;call	strcpy
  2014                                  		;pop	bx
  2015                                  		;pop	bx
  2016 0000046E BE[8170]                		mov	si,OPTIONS
  2017 00000471 BF[39A1]                		mov	di,p_swi4_sp_switch6
  2018                                  		;mov	cx,3  ; db '/?',0
  2019                                  		;mov	cl,3
  2020                                  		;rep	movsb
  2021 00000474 A5                      		movsw	
  2022 00000475 A4                      		movsb	
  2023                                  
  2024 00000476 B80100                  		mov	ax,1
  2025                                  		;mov	word [p_swi5],1
  2026                                  		;mov	[p_swi5],ax
  2027 00000479 A3[3EA1]                		mov	[p_swi5_sp_match_flag],ax
  2028 0000047C FEC8                    		dec	al ; dec ax ; 0
  2029 0000047E A3[40A1]                		mov	[p_swi5_sp_function_flag],ax ; 0
  2030 00000481 C706[42A1][E2CC]        		mov	word [p_swi5_sp_buff1_ptr],sp_buff
  2031                                  		;mov	ax,[NOVAL]
  2032 00000487 A3[44A1]                		mov	[p_swi5_sp_val1_ptr],ax
  2033 0000048A C606[46A1]01            		mov	byte [p_swi5_sp_nid],1
  2034                                  
  2035                                  		;mov	ax,MBR	; "/MBR"
  2036                                  		;push	ax
  2037                                  		;mov	ax,p_swi5_sp_switch7
  2038                                  		;push	ax
  2039                                  		;call	strcpy
  2040                                  		;pop	bx
  2041                                  		;pop	bx
  2042 0000048F BE[8470]                		mov	si,MBR
  2043 00000492 BF[47A1]                		mov	di,p_swi5_sp_switch7
  2044                                  		;mov	cx,5  ; db '/MBR',0
  2045                                  		;mov	cl,5
  2046                                  		;rep	movsb	
  2047 00000495 A5                      		movsw
  2048 00000496 A5                      		movsw
  2049 00000497 A4                      		movsb
  2050                                  		
  2051 00000498 31C0                    		xor	ax,ax
  2052 0000049A C706[0FC4]0800          		mov	word [p_val_p_high_range],8
  2053 000004A0 A3[11C4]                		mov	word [p_val_p_high_range+2],ax ; 0
  2054                                  		;mov	al,1
  2055 000004A3 FEC0                    		inc	al
  2056                                  		;mov	[p_val],al		; /* Number of values items returned */
  2057 000004A5 A2[08C4]                		mov	[p_val_p_values],al
  2058 000004A8 A2[09C4]                		mov	[p_val_p_range],al	; /* Number of ranges */
  2059 000004AB A2[0AC4]                		mov	[p_val_p_range_one],al	; /* range number one */
  2060                                  		;mov	[sp_val],al		
  2061 000004AE A2[E5C3]                		mov	[sp_val_p_values],al
  2062 000004B1 A2[E6C3]                		mov	[sp_val_p_range],al
  2063 000004B4 A2[E7C3]                		mov	[sp_val_p_range_one],al
  2064                                  		;mov	ax,1
  2065 000004B7 99                      		cwd
  2066 000004B8 A3[0BC4]                		mov	[p_val_p_low_range],ax	; /* low value for range */
  2067 000004BB 8916[0DC4]              		mov	[p_val_p_low_range+2],dx ; /* high value for range */
  2068 000004BF A3[E8C3]                		mov	[sp_val_p_low_range],ax	; /* low value for range */
  2069 000004C2 8916[EAC3]              		mov	[sp_val_p_low_range+2],dx ; /* high value for range */
  2070 000004C6 C706[ECC3]801F          		mov	word [sp_val_p_high_range],8064  ; /* max disk size=7.875GB=8064MB */
  2071 000004CC 8916[EEC3]              		mov	word [sp_val_p_high_range+2],dx ; 0
  2072 000004D0 C3                      		retn
  2073                                  
  2074                                  ; ----------------------------------------------------------------------------
  2075                                  ; strcpy - (c library function) Modified by Erdogan Tan for Assembly language
  2076                                  ; ----------------------------------------------------------------------------
  2077                                  ; 10/11/2018
  2078                                  
  2079                                  ;strcpy:
  2080                                  		;%define source	     bp+6  ; word	
  2081                                  		;%define destination bp+4  ; word
  2082                                  		;
  2083                                  		;push	bp
  2084                                  		;mov	bp,sp
  2085                                  		;mov	dx,di
  2086                                  		;mov	bx,si
  2087                                  		;mov	si,[source] ; [bp+6]
  2088                                  		;mov	di,si
  2089                                  		;mov	ax,ds
  2090                                  		;mov	es,ax
  2091                                  		;xor	ax,ax
  2092                                  		;mov	cx,0FFFFh ; 65535
  2093                                  		;repne scasb
  2094                                  		;not	cx
  2095                                  		;mov	di,[destination] ; [bp+4]
  2096                                  		;mov	ax,di
  2097                                  		;test	al,1
  2098                                  		;jz	short strcpy_0
  2099                                  		;movsb
  2100                                  		;dec	cx
  2101                                  ;strcpy_0:
  2102                                  		;shr	cx,1
  2103                                  		;rep movsw
  2104                                  		;adc	cx,cx
  2105                                  		;rep movsb
  2106                                  		;mov	si,bx
  2107                                  		;mov	di,dx
  2108                                  		;pop	bp
  2109                                  		;retn
  2110                                  
  2111                                  ; ----------------------------------------------------------------------------
  2112                                  ; PARSE - Modified by Erdogan Tan for Assembly language - 07/11/2018	
  2113                                  ; ----------------------------------------------------------------------------
  2114                                  
  2115                                  ; _parse.asm (MSDOS 6.0, 1991)
  2116                                  ;-------------------------------------------------------------------
  2117                                  ;
  2118                                  ;       MODULE:         _parse
  2119                                  ;
  2120                                  ;       PURPOSE:        Supplies an interface between C programs and
  2121                                  ;                       the DOS 3.30 parser
  2122                                  ;
  2123                                  ;       CALLING FORMAT:
  2124                                  ;                       parse(&inregs,&outregs);
  2125                                  ;
  2126                                  ;       DATE:           5-21-87
  2127                                  ;
  2128                                  ;-------------------------------------------------------------------
  2129                                  
  2130                                  parse:
  2131 000004D1 E80500                  		call	SysParse
  2132                                  	
  2133 000004D4 83F801                  		cmp	ax,1 ; Error Code (If > 0)
  2134 000004D7 F5                      		cmc	; cf = 1 if AX > 0
  2135 000004D8 C3                      		retn
  2136                                  
  2137                                  ; ----------------------------------------------------------------------------
  2138                                  ; parse.asm (MSDOS 6.0, 1991)	
  2139                                  ; ----------------------------------------------------------------------------
  2140                                  ; Modified for NASM and COM file (by Erdogan Tan, 08/11/2018)
  2141                                  
  2142                                  ;*****************************************************************************
  2143                                  ; SysParse;
  2144                                  ;
  2145                                  ;  Function : Parser Entry
  2146                                  ;
  2147                                  ;  Input: DS:SI -> command line
  2148                                  ;	  ES:DI -> parameter block
  2149                                  ;	  psdata_seg -> psdata.inc
  2150                                  ;	  CX = operand ordinal
  2151                                  ;
  2152                                  ;	  Note:  ES is the segment containing all the control blocks defined
  2153                                  ;		 by the caller, except for the DOS COMMAND line parms, which
  2154                                  ;		 is in DS.
  2155                                  ;
  2156                                  ;  Output: CY = 1   error of caller, means invalid parameter block or
  2157                                  ;		    invalid value list. But this parser does NOT implement
  2158                                  ;		    this feature. Therefore CY always zero.
  2159                                  ;
  2160                                  ;	   CY = 0   AX = return code
  2161                                  ;		    BL = terminated delimiter code
  2162                                  ;		    CX = new operand ordinal
  2163                                  ;		    SI = set past scaned operand
  2164                                  ;		    DX = selected result buffer
  2165                                  ;
  2166                                  ; Use:	_$P_Skip_Delim, _$P_Chk_EOL, _$P_Chk_Delim, _$P_Chk_DBCS
  2167                                  ;	_$P_Chk_Swtch, _$P_Chk_Pos_Control, _$P_Chk_Key_Control
  2168                                  ;	_$P_Chk_Sw_Control, _$P_Fill_Result
  2169                                  ;
  2170                                  ; Vars: _$P_Ordinal(RW), _$P_RC(RW), _$P_SI_Save(RW), _$P_DX(R), _$P_Terminator(R)
  2171                                  ;	_$P_SaveSI_Cmpx(W), _$P_Flags(RW), _$P_Found_SYNONYM(R), _$P_Save_EOB(W)
  2172                                  ;
  2173                                  ;*****************************************************************************
  2174                                  
  2175                                  SysParse:
  2176 000004D9 31D2                    		xor	dx,dx ; 09/11/2018
  2177                                  
  2178                                  		;mov	word [_$P_Flags],0	; Clear all internal flags
  2179 000004DB 8916[AB70]              		mov	[_$P_Flags],dx		
  2180                                  
  2181 000004DF FC                      		cld
  2182 000004E0 890E[9E70]              		mov	[_$P_ordinal],cx	; save operand ordinal
  2183                                  		;mov	word [_$P_RC],0	;_$P_No_Error
  2184                                  		;mov	byte [_$P_RC],0		; Assume no error
  2185 000004E4 8916[A070]              		mov	[_$P_RC],dx	
  2186                                  		;mov	word [_$P_Found_SYNONYM],0 ; initalize synonym pointer
  2187 000004E8 8916[B370]              		mov	[_$P_Found_SYNONYM],dx
  2188                                  		;mov	word [_$P_DX],0
  2189 000004EC 8916[A470]              		mov	[_$P_DX],dx
  2190                                  
  2191 000004F0 E80B01                  		call	_$P_Skip_Delim		; Move si to 1st non white space
  2192 000004F3 7311                    		jnc	short _$P_Start		; If EOL is not encountered, do parse
  2193                                  
  2194 000004F5 B8FFFF                  		mov	ax,0FFFFh ; _$P_RC_EOL	; set exit code to -1
  2195 000004F8 53                      		push	bx
  2196                                  						; Get the PARMSX address to
  2197                                  		;mov	bx,[es:di] ; [es:di+_$P_PARMSX_Address]
  2198 000004F9 8B1D                    		mov	bx,[di]
  2199                                  						; check ORDINAL to see if the minimum
  2200                                  		;cmp	cl,[es:bx] ; [es:bx+_$P_MinP]
  2201 000004FB 3A0F                    		cmp	cl,[bx]
  2202 000004FD 7303                    		jnb	short _$P_Fin		; positional found.
  2203 000004FF B80200                  		mov	ax,2 ; _$P_Op_Missing ; If no, set exit code to missing operand
  2204                                  _$P_Fin:
  2205 00000502 5B                      		pop	bx
  2206 00000503 E9F600                  		jmp	_$P_Single_Exit		; return to the caller
  2207                                  
  2208                                  _$P_Start:			;  save ptr to command line for later use by complex,
  2209 00000506 8936[AD70]              		mov	[_$P_SaveSI_Cmpx],si 	; quoted string or file spec.
  2210 0000050A 53                      		push	bx
  2211 0000050B 57                      		push	di
  2212 0000050C 55                      		push	bp
  2213                                  		;lea	bx,[_$P_STRING_BUF]  ; set buffer to copy from command string
  2214 0000050D BB[B570]                		mov	bx,_$P_STRING_BUF
  2215                                  						; extra delimiter encountered ?
  2216 00000510 F606[AC70]20            		test	byte [_$P_Flags2],20h ;_$P_Extra
  2217 00000515 753E                    		jnz	short _$P_Pack_End	; if yes, no need to copy
  2218                                  _$P_Pack_Loop:
  2219 00000517 AC                      		lodsb				; Pick a operand from buffer
  2220 00000518 E88F01                  		call	_$P_Chk_Switch		; Check switch character
  2221 0000051B 7237                    		jc	short _$P_Pack_End_BY_EOL 
  2222                                  					    ; if carry set found delimiter type slash,
  2223                                  					    ; need backup si, else continue
  2224 0000051D E80201                  		call	_$P_Chk_EOL		; Check EOL character
  2225 00000520 7432                    		jz	short _$P_Pack_End_BY_EOL ; need backup si
  2226                                  
  2227 00000522 E82E01                  		call	_$P_Chk_Delim		; Check delimiter
  2228 00000525 7516                    		jnz	short _$P_PL01		; If no, process next byte
  2229                                  
  2230 00000527 F606[AC70]20            		test	byte [_$P_Flags2],20h ;_$P_Extra ; If yes and white spec,
  2231 0000052C 7505                    		jnz	short _$P_Pack_End_backup_si ; then
  2232                                  
  2233 0000052E E8CD00                  		call	_$P_Skip_Delim		; skip subsequent white space,too
  2234 00000531 EB22                    		jmp	short _$P_Pack_End	; finish copy by placing NUL at end
  2235                                  
  2236                                  _$P_Pack_End_backup_si:
  2237 00000533 F606[AC70]41            		test	byte [_$P_Flags2],41h ;_$P_SW+_$P_equ
  2238 00000538 741B                    		jz	short _$P_Pack_End
  2239 0000053A 4E                      		dec	si
  2240 0000053B EB18                    		jmp	short _$P_Pack_End
  2241                                  
  2242                                  _$P_PL01:
  2243 0000053D 8807                    		mov	[bx],al			; move byte to STRING_BUF
  2244 0000053F 3C3D                    		cmp	al,'='			; if it is equal character,
  2245 00000541 7505                    		jne	short _$P_PL00		; then
  2246 00000543 800E[AC70]01            		or	byte [_$P_Flags2],1 ;_$P_equ ; remember it in flag
  2247                                  _$P_PL00:
  2248 00000548 43                      		inc	bx			; ready to see next byte
  2249 00000549 E88701                  		call	_$P_Chk_DBCS		; was it 1st byte of DBCS ?
  2250 0000054C 73C9                    		jnc	short _$P_Pack_Loop	; if no, process to next byte
  2251 0000054E AC                      		lodsb				; if yes, store
  2252 0000054F 8807                    		mov	[bx],al			;    2nd byte of DBCS
  2253 00000551 43                      		inc	bx			; update pointer
  2254 00000552 EBC3                    		jmp	short _$P_Pack_Loop	; process to next byte
  2255                                  
  2256                                  _$P_Pack_End_BY_EOL:
  2257 00000554 4E                      		dec	si			; backup si pointer
  2258                                  _$P_Pack_End:
  2259 00000555 8936[A270]              		mov	[_$P_SI_Save],si	; save next pointer, SI	
  2260 00000559 C60700                  		mov	byte [bx],0 ; _$P_NULL	; put NULL at the end
  2261 0000055C 891E[B170]              		mov	[_$P_Save_EOB],bx ; keep the address for later use of complex	
  2262                                  		;mov	bx,[es:di] ; [es:di+_$P_PARMSX_Address] ; get PARMSX address
  2263 00000560 8B1D                    		mov	bx,[di]
  2264                                  		;lea	si,[_$P_STRING_BUF]
  2265 00000562 BE[B570]                		mov	si,_$P_STRING_BUF
  2266 00000565 803C2F                  		cmp	byte [si],'/' ;_$P_Switch ; the operand begins w/ switch char?
  2267 00000568 7439                    		je	short _$P_SW_Manager	; if yes, process as switch
  2268                                  
  2269 0000056A 803C22                  		cmp	byte [si],'"' ;_$P_DQuote ; is it a string?
  2270 0000056D 7407                    		je	short _$P_Positional_Manager ; if so, process as one!
  2271                                  						; the operand includes equal char?
  2272 0000056F F606[AC70]01            		test	byte [_$P_Flags2],1 ;_$P_equ 
  2273 00000574 754B                    		jnz	short _$P_Key_manager	; if yes, process as keyword	
  2274                                  
  2275                                  _$P_Positional_Manager:				; else process as positional
  2276                                  		;mov	al,[es:bx+1] ; es:[bx]._$P_MaxP ; get maxp
  2277 00000576 8A4701                  		mov	al,[bx+1]
  2278 00000579 30E4                    		xor	ah,ah			; ax = maxp
  2279 0000057B 3906[9E70]              		cmp	[_$P_ordinal],ax	; too many positional?	
  2280 0000057F 7310                    		jnb	short _$P_Too_Many_Error ; if yes, set exit code to too many
  2281 00000581 A1[9E70]                		mov	ax,[_$P_ordinal]	; see what the current ordinal
  2282 00000584 D1E0                    		shl	ax,1			; ax = ax*2
  2283 00000586 43                      		inc	bx			; add '2' to
  2284 00000587 43                      		inc	bx			;  BX reg
  2285                                  					; now bx points to 1st CONTROL
  2286 00000588 01C3                    		add	bx,ax		; now bx points to specified CONTROL address
  2287                                  		;mov	bx,[es:bx]	; now bx points to specified CONTROL itself
  2288 0000058A 8B1F                    		mov	bx,[bx]
  2289 0000058C E89101                  		call	_$P_Chk_Pos_Control	; Do process for positional
  2290 0000058F EB55                    		jmp	short _$P_Return_to_Caller ; and return to the caller
  2291                                  
  2292                                  _$P_Too_Many_Error:
  2293                                  		;mov	word [_$P_RC],1 ;_$P_Too_Many ; set exit code
  2294 00000591 C606[A070]01            		mov	byte [_$P_RC],1
  2295 00000596 EB4E                    		jmp	short _$P_Return_to_Caller ; and return to the caller
  2296                                  	
  2297                                  ; ----------------------------------------------------------------------------
  2298                                  
  2299                                  _$P_SW_Key_Mgr_sub:
  2300                                  		;mov	al,[es:bx+1] ; [es:bx+_$P_MaxP] ; get maxp
  2301 00000598 8A4701                  		mov	al,[bx+1]
  2302 0000059B 30E4                    		xor	ah,ah			; ax = maxp
  2303 0000059D 40                      		inc	ax
  2304 0000059E D1E0                    		shl	ax,1			; ax = (ax+1)*2
  2305 000005A0 01C3                    		add	bx,ax			; now bx points to maxs
  2306 000005A2 C3                      		retn
  2307                                  
  2308                                  ; ----------------------------------------------------------------------------
  2309                                  
  2310                                  _$P_SW_Manager:
  2311 000005A3 E8F2FF                  		call	_$P_SW_Key_Mgr_sub  ; repetitive portion as subroutine
  2312                                  		;mov	cl,[es:bx]
  2313 000005A6 8A0F                    		mov	cl,[bx]
  2314 000005A8 30ED                    		xor	ch,ch			; cx = maxs
  2315                                  		;or	cx,cx
  2316                                  		;jz	short _$P_SW_Not_Found 
  2317 000005AA E30E                    		jcxz	_$P_SW_Not_Found	; at least one switch?
  2318 000005AC 43                      		inc	bx		; now bx points to 1st CONTROL address
  2319                                  
  2320                                  _$P_SW_Mgr_Loop:
  2321 000005AD 53                      		push	bx
  2322                                  		;mov	bx,[es:bx]	   ; bx points to Switch CONTROL itself
  2323 000005AE 8B1F                    		mov	bx,[bx]
  2324 000005B0 E8C701                  		call	_$P_Chk_SW_Control	; do process for switch
  2325 000005B3 5B                      		pop	bx		; if the CONTROL is for the switch, exit
  2326 000005B4 7330                    		jnc	short _$P_Return_to_Caller
  2327 000005B6 43                      		inc	bx			;  add 2 to BX reg
  2328 000005B7 43                      		inc	bx		   ; else bx points to the next CONTROL
  2329 000005B8 E2F3                    		loop	_$P_SW_Mgr_Loop		; and loop
  2330                                  
  2331                                  _$P_SW_Not_Found:
  2332                                  		;mov	word [_$P_RC],3 ;_$P_Not_In_SW
  2333 000005BA C606[A070]03            		mov	byte [_$P_RC],3	    ; here no CONTROL for the switch has
  2334 000005BF EB25                    		jmp	short _$P_Return_to_Caller ; not been found, means error.
  2335                                  
  2336                                  _$P_Key_manager:
  2337 000005C1 E8D4FF                  		call	_$P_SW_Key_Mgr_sub  ; repetitive portion as subroutine	
  2338                                  		;mov	al,[es:bx]
  2339 000005C4 8A07                    		mov	al,[bx]
  2340 000005C6 30E4                    		xor	ah,ah			; ax = maxs
  2341 000005C8 D1E0                    		shl	ax,1
  2342 000005CA 40                      		inc	ax			; ax = ax*2+1
  2343 000005CB 01C3                    		add	bx,ax			; now bx points to maxk
  2344                                  		;mov	cl,[es:bx]
  2345 000005CD 8A0F                    		mov	cl,[bx]
  2346 000005CF 30ED                    		xor	ch,ch			; cx = maxk
  2347 000005D1 E30E                    		jcxz	_$P_Key_Not_Found	; at least one keyword?
  2348 000005D3 43                      		inc	bx			; now bx points to 1st CONTROL
  2349                                  
  2350                                  _$P_Key_Mgr_Loop:
  2351 000005D4 53                      		push	bx
  2352                                  		;mov	bx,[es:bx]	   ; bx points to keyword CONTROL itself
  2353 000005D5 8B1F                    		mov	bx,[bx]
  2354 000005D7 E87201                  		call	_$P_Chk_Key_Control	; do process for keyword
  2355 000005DA 5B                      		pop	bx		; if the CONTROL is for the keyword, exit
  2356 000005DB 7309                    		jnc	short _$P_Return_to_Caller
  2357 000005DD 43                      		inc	bx			; add '2' to BX reg
  2358 000005DE 43                      		inc	bx		; else bx points to the next CONTROL
  2359 000005DF E2F3                    		loop	_$P_Key_Mgr_Loop	; and loop
  2360                                  
  2361                                  _$P_Key_Not_Found:
  2362                                  		;mov	word [_$P_RC],4 ;_$P_Not_In_Key
  2363                                  					   ; here no CONTROL for the keyword has
  2364 000005E1 C606[A070]04            		mov	byte [_$P_RC],4	 	; not been found, means error.
  2365                                  
  2366                                  _$P_Return_to_Caller:
  2367 000005E6 5D                      		pop	bp
  2368 000005E7 5F                      		pop	di
  2369 000005E8 5B                      		pop	bx
  2370 000005E9 8B0E[9E70]              		mov	cx,[_$P_ordinal]	; return next ordinal
  2371 000005ED A1[A070]                		mov	ax,[_$P_RC]		; return exit code
  2372 000005F0 8B36[A270]              		mov	si,[_$P_SI_Save]	; return next operand pointer	
  2373 000005F4 8B16[A470]              		mov	dx,[_$P_DX]		; return result buffer address
  2374 000005F8 8A1E[A670]              		mov	bl,[_$P_Terminator]	; return delimiter code found
  2375                                  
  2376                                  _$P_Single_Exit:
  2377 000005FC F8                      		clc
  2378 000005FD C3                      		retn
  2379                                  
  2380                                  ;***********************************************************************
  2381                                  ;
  2382                                  ; _$P_Skip_Delim;
  2383                                  ;
  2384                                  ; Function: Skip delimiters specified in the PARMS list, white space
  2385                                  ;	    and comma.
  2386                                  ;
  2387                                  ; Input:    DS:SI -> Command String
  2388                                  ;	    ES:DI -> Parameter List
  2389                                  ;
  2390                                  ; Output:   CY = 1 if the end of line encounterd
  2391                                  ;	    CY = 0 then SI move to 1st non-delimiter character
  2392                                  ;	    AL = Last examineed character
  2393                                  ;
  2394                                  ; Use:	    _$P_Chk_EOL, _$P_Chk_Delim,
  2395                                  ;
  2396                                  ; Vars:     _$P_Flags(R)
  2397                                  ;
  2398                                  ;***********************************************************************
  2399                                  
  2400                                  _$P_Skip_Delim:
  2401                                  _$P_Skip_Delim_Loop:
  2402 000005FE AC                      		lodsb
  2403 000005FF E82000                  		call	_$P_Chk_EOL	; is it EOL character?
  2404 00000602 7416                    		jz	short _$P_Skip_Delim_CY ; if yes, exit w/ CY on
  2405                                  
  2406 00000604 E84C00                  		call	_$P_Chk_Delim	; is it one of delimiters?
  2407 00000607 7514                    		jnz	short _$P_Skip_Delim_NCY ; if no, exit w/ CY off
  2408                                  					; extra delim or comma found? 
  2409 00000609 F606[AC70]20            		test	byte [_$P_Flags2],20h ;_$P_Extra
  2410 0000060E 74EE                    		jz	short _$P_Skip_Delim_Loop ; if no, loop
  2411                                  					
  2412 00000610 F606[AC70]41            		test	byte [_$P_Flags2],41h ;_$P_SW+_$P_equ ; /x or xxx=zzz
  2413 00000615 7409                    		jz	short _$P_Exit_At_Extra ; no switch, no keyword
  2414                                  
  2415 00000617 4E                      		dec	si		; backup si for next call
  2416 00000618 EB06                    		jmp	short _$P_Exit_At_Extra ; else exit w/ CY off
  2417                                  
  2418                                  _$P_Skip_Delim_CY:
  2419 0000061A F9                      		stc			; indicate EOL
  2420 0000061B EB01                    		jmp	short _$P_Skip_Delim_Exit
  2421                                  
  2422                                  _$P_Skip_Delim_NCY:
  2423 0000061D F8                      		clc			; indicate non delim
  2424                                  
  2425                                  _$P_Skip_Delim_Exit:			; in this case, need
  2426 0000061E 4E                      		dec	si		; backup index pointer
  2427 0000061F C3                      		retn
  2428                                  
  2429                                  _$P_Exit_At_Extra:
  2430 00000620 F8                      		clc			; indicate extra delim
  2431 00000621 C3                      		retn
  2432                                  
  2433                                  ;***********************************************************************
  2434                                  ;
  2435                                  ; _$P_Chk_EOL;
  2436                                  ;
  2437                                  ; Function: Check if AL is one of End of Line characters.
  2438                                  ;
  2439                                  ; Input:    AL = character code
  2440                                  ;	    ES:DI -> Parameter List
  2441                                  ;
  2442                                  ; Output:   ZF = 1 if one of End of Line characters
  2443                                  ;
  2444                                  ;***********************************************************************
  2445                                  
  2446                                  _$P_Chk_EOL:
  2447 00000622 53                      		push	bx
  2448 00000623 51                      		push	cx
  2449                                  
  2450 00000624 3C0D                    		cmp	al,0Dh ;_$P_CR	; Carriage return?
  2451 00000626 7428                    		je	short _$P_Chk_EOL_Exit
  2452                                  		
  2453 00000628 3C00                    		cmp	al,0 ;_$P_NULL	; zero?
  2454 0000062A 7424                    		je	short _$P_Chk_EOL_Exit
  2455                                  		
  2456 0000062C 3C0A                    		cmp	al,0Ah ;_$P_LF	; Line feed?
  2457 0000062E 7420                    		je	short _$P_Chk_EOL_Exit
  2458                                  		
  2459                                  		;cmp	byte [es:di+_$Pp_num_extra],_$P_I_Have_EOL
  2460                                  		;cmp	byte [es:di+2],2 ; EOL character specified?
  2461 00000630 807D0202                		cmp	byte [di+2],2 ; 09/11/2018
  2462 00000634 721A                    		jb	short _$P_Chk_EOL_Exit
  2463                                  		
  2464 00000636 31DB                    		xor	bx,bx
  2465                                  		;mov	bl,[es:di+_$P_p_len_extra_delim]
  2466                                  		;mov	bl,[es:di+3]	; get length of delimiter list
  2467 00000638 8A5D03                  		mov	bl,[di+3]
  2468 0000063B 83C304                  		add	bx,4 ;_$P_Len_PARMS ; skip it
  2469                                  					  ; No extra EOL character?
  2470                                  		;cmp	byte [es:bx+di],0 ;_$P_I_Use_Default
  2471 0000063E 803900                  		cmp	byte [bx+di],0
  2472 00000641 740B                    		je	short _$P_Chk_EOL_NZ
  2473 00000643 31C9                    		xor	cx,cx
  2474                                  		;mov	cl,[es:bx+di]	; Get number of extra character
  2475 00000645 8A09                    		mov	cl,[bx+di]
  2476                                  _$P_Chk_EOL_Loop:
  2477 00000647 43                      		inc	bx
  2478                                  		;cmp	al,[es:bx+di]	; Check extra EOL character
  2479 00000648 3A01                    		cmp	al,[bx+di]
  2480 0000064A 7404                    		je	short _$P_Chk_EOL_Exit
  2481 0000064C E2F9                    		loop	_$P_Chk_EOL_Loop
  2482                                  _$P_Chk_EOL_NZ:
  2483 0000064E 3C0D                    		cmp	al,0Dh ; _$P_CR	; reset ZF
  2484                                  _$P_Chk_EOL_Exit:
  2485 00000650 59                      		pop	cx
  2486 00000651 5B                      		pop	bx
  2487 00000652 C3                      		retn
  2488                                  
  2489                                  ;***********************************************************************
  2490                                  ;
  2491                                  ; _$P_Chk_Delim;
  2492                                  ;
  2493                                  ; Function: Check if AL is one of delimiter characters.
  2494                                  ;	    if AL+[si] is DBCS blank, it is replaced with two SBCS
  2495                                  ;	    blanks.
  2496                                  ;
  2497                                  ; Input:    AL = character code
  2498                                  ;	    DS:SI -> Next Character
  2499                                  ;	    ES:DI -> Parameter List
  2500                                  ;
  2501                                  ; Output:   ZF = 1 if one of delimiter characters
  2502                                  ;	    SI points to the next character
  2503                                  ; Vars:  _$P_Terminator(W), _$P_Flags(W)
  2504                                  ;
  2505                                  ;***********************************************************************
  2506                                  
  2507                                  _$P_Chk_Delim:
  2508 00000653 53                      		push	bx
  2509 00000654 51                      		push	cx
  2510                                  					; Assume terminated by space
  2511 00000655 C606[A670]20            		mov	byte [_$P_Terminator],' ' ;_$P_Space  
  2512 0000065A 8026[AC70]DF            		and	byte [_$P_Flags2],~20h ; not 20h ; 0FFh-_$P_Extra 
  2513 0000065F 3C20                    		cmp	al,' '	;_$P_Space	; Space?
  2514 00000661 7431                    		je	short _$P_Chk_Delim_Exit
  2515 00000663 3C09                    		cmp	al,9	;_$P_TAB		; TAB?
  2516 00000665 742D                    		je	short _$P_Chk_Delim_Exit
  2517 00000667 3C2C                    		cmp	al,','	;_$P_Comma	; Comma?
  2518 00000669 742C                    		je	short _$P_Chk_Delim_Exit0
  2519                                  _$P_Chk_Delim00:
  2520 0000066B 3C20                    		cmp	al,' '	;_$P_DBSP1	; 1st byte of DBCS Space?
  2521 0000066D 750C                    		jne	short _$P_Chk_Delim01
  2522 0000066F 803C20                  		cmp	byte [si],' ' ;_$P_DBSP2	; 2nd byte of DBCS Space?
  2523 00000672 7507                    		jne	short _$P_Chk_Delim01
  2524 00000674 B020                    		mov	al,' '
  2525 00000676 46                      		inc	si			; make si point to next character
  2526 00000677 38C0                    		cmp	al,al			; Set ZF
  2527 00000679 EB19                    		jmp	short _$P_Chk_Delim_Exit
  2528                                  
  2529                                  _$P_Chk_Delim01:
  2530                                  		;cmp	byte [es:di+_$Pp_num_extra],_$P_I_Have_Delim
  2531                                  		;cmp	byte [es:di+2],1	;delimiter character specified?
  2532 0000067B 807D0201                		cmp	byte [di+2],1 ; 09/11/2018
  2533 0000067F 7213                    		jb	short _$P_Chk_Delim_Exit
  2534 00000681 31C9                    		xor	cx,cx
  2535                                  		;mov	cl,[es:di+_$P_p_len_extra_delim]
  2536                                  		;mov	cl,[es:di+3]		; get length of delimiter list
  2537 00000683 8A4D03                  		mov	cl,[di+3]
  2538 00000686 E30A                    		jcxz	_$P_Chk_Delim_NZ
  2539 00000688 BB0300                  		mov	bx,3 ;_$P_Len_PARMS-1	; set bx to 1st extra delimiter
  2540                                  
  2541                                  _$P_Chk_Delim_Loop:
  2542 0000068B 43                      		inc	bx
  2543                                  		;cmp	al,[es:bx+di]		; Check extra Delim character
  2544 0000068C 3A01                    		cmp	al,[bx+di]
  2545 0000068E 7407                    		je	short _$P_Chk_Delim_Exit0
  2546 00000690 E2F9                    		loop	_$P_Chk_Delim_Loop	; examine all extra delimiter
  2547                                  
  2548                                  _$P_Chk_Delim_NZ:
  2549 00000692 3C20                    		cmp	al,' '	;_$P_Space	; reset ZF
  2550                                  
  2551                                  _$P_Chk_Delim_Exit:
  2552 00000694 59                      		pop	cx
  2553 00000695 5B                      		pop	bx
  2554 00000696 C3                      		retn
  2555                                  
  2556                                  _$P_Chk_Delim_Exit0:
  2557 00000697 A2[A670]                		mov	[_$P_Terminator],al	; keep terminated delimiter
  2558 0000069A F606[AC70]01            		test	byte [_$P_Flags2],1 ;_$P_Equ ; if terminating a key=
  2559 0000069F 7505                    		jnz	short _$P_No_Set_Extra	; then do not set the EXTRA bit
  2560                                  					; flag terminated extra delimiter or comma
  2561 000006A1 800E[AC70]20            		or	byte [_$P_Flags2],20h ;_$P_Extra
  2562                                  _$P_No_Set_Extra:
  2563 000006A6 38C0                    		cmp	al,al			; set ZF
  2564 000006A8 EBEA                    		jmp	short _$P_Chk_Delim_Exit
  2565                                  
  2566                                  ;***********************************************************************
  2567                                  ;
  2568                                  ; _$P_Chk_Switch;
  2569                                  ;
  2570                                  ; Function: Check if AL is the switch character not in first position of
  2571                                  ;	    _$P_STRING_BUF
  2572                                  ;
  2573                                  ; Input:    AL = character code
  2574                                  ;	    BX = current pointer within _$P_String_Buf
  2575                                  ;	    SI = next char on command line (following the one in AL)
  2576                                  ;
  2577                                  ; Output:   CF = 1 (set) if AL is switch character, and not in first
  2578                                  ;		 position, and has no chance of being part of a date string,
  2579                                  ;		 i.e. should be treated as a delimiter.
  2580                                  
  2581                                  ;	    CF = 0 (reset, cleared) if AL is not a switch char, is in the first
  2582                                  ;		 position, or is a slash but may be part of a date string, i.e.
  2583                                  ;		 should not be treated as a delimiter.
  2584                                  ;
  2585                                  ; Vars:  _$P_Terminator(W)
  2586                                  ;
  2587                                  ; Use:	 _$P_0099
  2588                                  ;
  2589                                  ;***********************************************************************
  2590                                  
  2591                                  _$P_Chk_Switch:
  2592                                  		;lea	bp,[_$P_STRING_BUF]
  2593                                  			; BP = OFFSET of _$P_String_Buf even in group addressing
  2594 000006AA BD[B570]                		mov	bp,_$P_STRING_BUF
  2595 000006AD 39EB                    		cmp	bx,bp			; if not first char
  2596 000006AF 7417                    		je	short _$P_STRUC_L2	; then
  2597 000006B1 3C2F                    		cmp	al,'/'	;_$P_Switch	; otherwise see if a slash
  2598 000006B3 7511                    		jne	short _$P_STRUC_L5	; not a switch char
  2599                                  						; not in first position and is slash, 
  2600 000006B5 F9                      		stc				; now see if might be in date string
  2601 000006B6 50                      		push	ax			; save input char
  2602 000006B7 8A47FF                  		mov	al,[bx-1]		; AL = char before the current char
  2603 000006BA E8A103                  		call	_$P_0099		; return carry set if not numeric
  2604 000006BD 7205                    		jc	short _$P_STRUC_L7
  2605 000006BF 8A04                    		mov	al,[si]			; AL = char after the current char
  2606 000006C1 E89A03                  		call	_$P_0099		; return carry set if not numeric
  2607                                  _$P_STRUC_L7:
  2608 000006C4 58                      		pop	ax			; restore AL to input char
  2609 000006C5 C3                      		retn				; DateSw
  2610                                  _$P_STRUC_L5:
  2611 000006C6 F8                      		clc				; not a slash
  2612 000006C7 C3                      		retn
  2613                                  _$P_STRUC_L2:
  2614 000006C8 3C2F                    		cmp	al,'/' ;_$P_Switch
  2615 000006CA 7505                    		jne	short _$P_STRUC_L12
  2616                                  					; could be valid switch, first char and is slash	
  2617 000006CC 800E[AC70]40            		or	byte [_$P_Flags2],40h ;_$P_Flags2,_$P_SW
  2618                                  _$P_STRUC_L12:
  2619 000006D1 F8                      		clc				; CF=0 indicating first char
  2620                                  _$P_STRUC_L1:					;is first char in the buffer, ZF=0
  2621 000006D2 C3                      		retn
  2622                                  
  2623                                  ;**************************************************************************
  2624                                  ;
  2625                                  ; _$P_Chk_DBCS:
  2626                                  ;
  2627                                  ;  Function: Check if a specified byte is in ranges of the DBCS lead bytes
  2628                                  ;
  2629                                  ;  Input:
  2630                                  ;	  AL	= Code to be examineed
  2631                                  ;
  2632                                  ;  Output:
  2633                                  ;	  If CF is on then a lead byte of DBCS
  2634                                  ;
  2635                                  ; Use: INT 21h w/AH=63
  2636                                  ;
  2637                                  ; Vars:  _$P_DBCSEV_Seg(RW), _$P_DBCSEV_Off(RW)
  2638                                  ;
  2639                                  ;***************************************************************************
  2640                                  
  2641                                  _$P_Chk_DBCS:
  2642 000006D3 1E                      		push	ds
  2643 000006D4 56                      		push	si
  2644 000006D5 53                      		push	bx
  2645                                  
  2646 000006D6 833E[A970]00            		cmp	word [_$P_DBCSEV_SEG],0	; ALREADY SET ?
  2647 000006DB 7525                    		jne	short _$P_DBCS00
  2648                                  
  2649 000006DD 50                      		push	ax
  2650 000006DE 1E                      		push	ds
  2651 000006DF 51                      		push	cx
  2652 000006E0 52                      		push	dx
  2653 000006E1 57                      		push	di
  2654 000006E2 55                      		push	bp
  2655 000006E3 06                      		push	es
  2656 000006E4 31F6                    		xor	si,si
  2657 000006E6 8EDE                    		mov	ds,si
  2658 000006E8 B80063                  		mov	ax,6300h ; _$P_DOS_GetEV	; GET DBCS EV CALL
  2659 000006EB CD21                    		int	21h	; GET DOUBLE BYTE CHARACTER SET LEAD TABLE
  2660 000006ED 8CDB                    		mov	bx,ds
  2661 000006EF 09DB                    		or	bx,bx
  2662 000006F1 07                      		pop	es
  2663 000006F2 5D                      		pop	bp
  2664 000006F3 5F                      		pop	di
  2665 000006F4 5A                      		pop	dx
  2666 000006F5 59                      		pop	cx
  2667 000006F6 1F                      		pop	ds
  2668 000006F7 58                      		pop	ax
  2669 000006F8 7421                    		jz	short _$P_NON_DBCS
  2670                                  _$P_DBCS02:
  2671 000006FA 8936[A770]              		mov	[_$P_DBCSEV_OFF],si	; save EV offset
  2672 000006FE 891E[A970]              		mov	[_$P_DBCSEV_SEG],bx	; save EV segment
  2673                                  _$P_DBCS00:
  2674                                  		;lds	si, dword ptr cs:_$P_DBCSEV_OFF
  2675 00000702 C536[A770]              		lds	si,[_$P_DBCSEV_OFF]	; load EV offset and segment
  2676                                  _$P_DBCS_LOOP:
  2677 00000706 833C00                  		cmp	word [si],0		; zero vector?
  2678 00000709 7410                    		je	short _$P_NON_DBCS	; then exit
  2679 0000070B 3A04                    		cmp	al,[si]			
  2680 0000070D 7208                    		jb	short _$P_DBCS01	; Check if AL is in
  2681 0000070F 3A4401                  		cmp	al,[si+1]		;   range of
  2682 00000712 7703                    		ja	short _$P_DBCS01	;      the vector
  2683 00000714 F9                      		stc				; if yes, indicate DBCS and exit
  2684 00000715 EB05                    		jmp	short _$P_DBCS_EXIT
  2685                                  _$P_DBCS01:
  2686 00000717 46                      		inc	si			; add '2' to
  2687 00000718 46                      		inc	si			;  SI reg
  2688 00000719 EBEB                    		jmp	short _$P_DBCS_LOOP	; loop until zero vector found
  2689                                  _$P_NON_DBCS:
  2690 0000071B F8                      		clc				; indicate SBCS
  2691                                  _$P_DBCS_EXIT:
  2692 0000071C 5B                      		pop	bx
  2693 0000071D 5E                      		pop	si
  2694 0000071E 1F                      		pop	ds
  2695 0000071F C3                      		retn
  2696                                  
  2697                                  ;***********************************************************************
  2698                                  ;
  2699                                  ; _$P_Chk_Pos_Control
  2700                                  ;
  2701                                  ; Function: Parse CONTROL block for a positional
  2702                                  ;
  2703                                  ; Input:     ES:BX -> CONTROL block
  2704                                  ;	     psdata_seg:SI -> _$P_STRING_BUF
  2705                                  ;
  2706                                  ; Output:    None
  2707                                  ;
  2708                                  ; Use:	 _$P_Fill_Result, _$P_Check_Match_Flags
  2709                                  ;
  2710                                  ; Vars: _$P_Ordinal(W), _$P_RC(W)
  2711                                  ;
  2712                                  ;***********************************************************************
  2713                                  
  2714                                  _$P_Chk_Pos_Control:
  2715 00000720 50                      		push	ax
  2716                                  		;mov	ax,[es:bx] ; [es:bx+_$P_Match_Flag]
  2717 00000721 8B07                    		mov	ax,[bx] ; 09/11/2018
  2718 00000723 A90200                  		test	ax,2 ;_$P_Repeat		; repeat allowed?
  2719 00000726 7504                    		jnz	short _$P_CPC00		; then do not increment ORDINAL
  2720                                  		;inc	word [_$P_ordinal]
  2721 00000728 FE06[9E70]              		inc	byte [_$P_ordinal]	; update the ordinal
  2722                                  _$P_CPC00:
  2723 0000072C 803C00                  		cmp	byte [si],0 ;_$P_NULL	; no data?
  2724 0000072F 7516                    		jne	short _$P_CPC01
  2725 00000731 A90100                  		test	ax,1 ;_$P_Optional	; yes, then is it optional?
  2726 00000734 7507                    		jnz	short _$P_CPC02
  2727                                  		;mov	word [_$P_RC],2		; no, then error
  2728 00000736 C606[A070]02            		mov	byte [_$P_RC],2 ;_$P_Op_Missing
  2729 0000073B EB0D                    		jmp	short _$P_CPC_Exit
  2730                                  _$P_CPC02:
  2731 0000073D 50                      		push	ax
  2732                                  		;mov	al,_$P_String		;if it is optional return NULL
  2733                                  		;mov	ah,_$P_No_Tag
  2734 0000073E B803FF                  		mov	ax,0FF03h
  2735 00000741 E88A00                  		call	_$P_Fill_Result
  2736 00000744 58                      		pop	ax
  2737 00000745 EB03                    		jmp	short _$P_CPC_Exit
  2738                                  _$P_CPC01:
  2739 00000747 E8F400                  		call	_$P_Check_Match_Flags
  2740                                  _$P_CPC_Exit:
  2741 0000074A 58                      		pop	ax
  2742 0000074B C3                      		retn
  2743                                  
  2744                                  ;***********************************************************************
  2745                                  ;
  2746                                  ; _$P_Chk_Key_Control
  2747                                  ;
  2748                                  ; Function: Parse CONTROL block for a keyword
  2749                                  ;
  2750                                  ; Input:     ES:BX -> CONTROL block
  2751                                  ;	     psdata_seg:SI -> _$P_STRING_BUF
  2752                                  ;
  2753                                  ; Output:    CY = 1 : not match
  2754                                  ;
  2755                                  ; Use:	 _$P_Fill_Result, _$P_Search_KEYorSW, _$P_Check_Match_Flags
  2756                                  ;
  2757                                  ; Vars: _$P_RC(W), _$P_SaveSI_Cmpx(W), _$P_KEYorSW_Ptr(R), _$P_Flags(W)
  2758                                  ;
  2759                                  ;***********************************************************************
  2760                                  
  2761                                  _$P_Chk_Key_Control:
  2762                                  ;IF	KeySW					; (Check if keyword is supported)
  2763                                  ;		or	psdata_seg:_$P_Flags2,_$P_Key_Cmp 
  2764                                  ;					; Indicate keyword for later string comparison
  2765                                  ;		call	_$P_Search_KEYorSW 	; Search the keyword in the CONTROL block
  2766                                  ;		jc	_$P_Chk_Key_Err0   	;  not found, then try next CONTROL
  2767                                  ;
  2768                                  ;		and	psdata_seg:_$P_Flags2,0ffh-_$P_Key_Cmp ; reset the indicator previously set
  2769                                  ;
  2770                                  ;		push	ax			      ; keyword=
  2771                                  ;		mov	ax,psdata_seg:_$P_KEYorSW_Ptr ; ^       ^
  2772                                  ;		sub	ax,si			; SI	KEYorSW
  2773                                  ;		add	psdata_seg:_$P_SaveSI_Cmpx,ax ; update for complex, quoted or file spec.
  2774                                  ;		pop	ax
  2775                                  ;
  2776                                  ;		mov	si,psdata_seg:_$P_KEYorSW_Ptr ; set si just after equal char
  2777                                  ;		cmp	byte ptr psdata_seg:[si],_$P_NULL ; any data after equal?
  2778                                  ;		je	_$P_Chk_Key_Err1 	; if no, syntax error
  2779                                  ;
  2780                                  ;		call	_$P_Check_Match_Flags	; else, process match flags
  2781                                  ;		clc				
  2782                                  ;		jmp	short _$P_Chk_Key_Exit
  2783                                  ;
  2784                                  ;_$P_Chk_Key_Err0:
  2785                                  ;		stc				; not found in keyword synonym list
  2786                                  ;		jmp	short _$P_Chk_Key_Exit
  2787                                  ;
  2788                                  ;_$P_Chk_Key_Err1:
  2789                                  ;		mov	psdata_seg:_$P_RC,_$P_Syntax ; no parameter is not specified after "="
  2790                                  ;_$P_Chk_Key_ErrExit:
  2791                                  ;		push	ax
  2792                                  ;		mov	al,_$P_String		; set
  2793                                  ;		mov	ah,_$P_No_Tag		;    result
  2794                                  ;		call	_$P_Fill_Result		; 	 buffer
  2795                                  ;		pop	ax			
  2796                                  ;		clc
  2797                                  ;$_P_Chk_Key_Exit:
  2798                                  ;		retn
  2799                                  ;ELSE						; (of IF KeySW)
  2800 0000074C F9                      		stc				;   this logic works when the KeySW
  2801 0000074D C3                      		retn				;   is reset.
  2802                                  ;ENDIF						; (of KeySW)
  2803                                  
  2804                                  ;***********************************************************************
  2805                                  ;
  2806                                  ; _$P_Search_KEYorSW:
  2807                                  ;
  2808                                  ; Function: Seach specified keyword or switch from CONTROL
  2809                                  ;
  2810                                  ; Input:     ES:BX -> CONTROL block
  2811                                  ;	     psdata_seg:SI -> _$P_STRING_BUF
  2812                                  ;
  2813                                  ; Output:    CY = 1 : not match
  2814                                  ;
  2815                                  ; Use:	 _$P_String_Comp, _$P_MoveBP_NUL, _$P_Found_SYNONYM
  2816                                  ;
  2817                                  ;***********************************************************************
  2818                                  
  2819                                  _$P_Search_KEYorSW:
  2820 0000074E 55                      		push	bp
  2821 0000074F 51                      		push	cx
  2822                                  		;mov	cl,[es:bx+8] ; [es:bx+_$P_nid] ; Get synonym count
  2823 00000750 8A4F08                  		mov	cl,[bx+8] ; 09/11/2018
  2824 00000753 30ED                    		xor	ch,ch
  2825 00000755 E30D                    		jcxz	_$P_KEYorSW_Not_Found
  2826                                  		;lea	bp,es:[bx]._$P_KEYorSW	; BP points to the 1st synonym
  2827                                  		;lea	bp,[bx+_$P_KEYorSW]
  2828 00000757 8D6F09                  		lea	bp,[bx+9]
  2829                                  _$P_KEYorSW_Loop:
  2830 0000075A E83103                  		call	_$P_String_Comp
  2831 0000075D 7308                    		jnb	short _$P_KEYorSW_Found
  2832 0000075F E80D00                  		call	_$P_MoveBP_NUL
  2833 00000762 E2F6                    		loop	_$P_KEYorSW_Loop
  2834                                  _$P_KEYorSW_Not_Found:
  2835 00000764 F9                      		stc
  2836 00000765 EB05                    		jmp	short _$P_KEYorSW_Exit
  2837                                  _$P_KEYorSW_Found:
  2838 00000767 892E[B370]              		mov	[_$P_Found_SYNONYM],bp
  2839 0000076B F8                      		clc
  2840                                  _$P_KEYorSW_Exit:
  2841 0000076C 59                      		pop	cx
  2842 0000076D 5D                      		pop	bp
  2843 0000076E C3                      		retn
  2844                                  
  2845                                  ;***********************************************************************
  2846                                  ; _$P_MoveBP_NUL
  2847                                  ;***********************************************************************
  2848                                  
  2849                                  _$P_MoveBP_NUL:	; 09/11/2018
  2850                                  		;cmp	byte [es:bp],0 ;_$P_NULL ; Increment BP that points
  2851 0000076F 807E0000                		cmp	byte [bp],0  ; (SS = CS = DS = ES)		
  2852 00000773 7403                    		jz	short _$P_MBP_Exit	; to the synomym list
  2853 00000775 45                      		inc	bp			; until
  2854 00000776 EBF7                    		jmp	short _$P_MoveBP_NUL	; NULL encountered.
  2855                                  _$P_MBP_Exit:
  2856 00000778 45                      		inc	bp			; bp points to next to NULL
  2857 00000779 C3                      		retn
  2858                                  
  2859                                  ;***********************************************************************
  2860                                  ;
  2861                                  ; _$P_Chk_SW_Control
  2862                                  ;
  2863                                  ; Function: Parse CONTROL block for a switch
  2864                                  ;
  2865                                  ; Input:     ES:BX -> CONTROL block
  2866                                  ;	     psdata_seg:SI -> _$P_STRING_BUF
  2867                                  ;
  2868                                  ; Output:    CY = 1 : not match
  2869                                  ;
  2870                                  ; Use:	 _$P_Fill_Result, _$P_Search_KEYorSW, _$P_Check_Match_Flags
  2871                                  ;
  2872                                  ; Vars:  _$P_SaveSI_Cmpx(W), _$P_KEYorSW_Ptr(R), _$P_Flags(W)
  2873                                  ;
  2874                                  ;**********************************************************************
  2875                                  
  2876                                  _$P_Chk_SW_Control:
  2877                                  ;IF	SwSW					; (Check if switch is supported)
  2878 0000077A 800E[AC70]10            		or	byte [_$P_Flags2],10h	;_$P_Sw_Cmp
  2879                                  					; Indicate switch for later string comparison
  2880 0000077F E8CCFF                  		call	_$P_Search_KEYorSW ; Search the switch in the CONTROL block
  2881 00000782 723E                    		jc	short _$P_Chk_SW_Err0 ; not found, then try next CONTROL
  2882                                  					; reset the indicator previously set
  2883 00000784 8026[AC70]EF            		and	byte [_$P_Flags2],~10h ; not 10h  ; 0EFh ; 0FFh-_$P_Sw_Cmp
  2884                                  
  2885 00000789 50                      		push	ax			; /switch:
  2886 0000078A A1[AF70]                		mov	ax,[_$P_KEYorSW_Ptr]	; ^       ^
  2887 0000078D 29F0                    		sub	ax,si			; SI  KEYorSW
  2888 0000078F 0106[AD70]              		add	[_$P_SaveSI_Cmpx],ax	; update for complex list
  2889 00000793 58                      		pop	ax
  2890 00000794 8B36[AF70]              		mov	si,[_$P_KEYorSW_Ptr]	; set si at the end or colon
  2891 00000798 803C00                  		cmp	byte [si],0 ;_$P_NULL	; any data after colon
  2892 0000079B 751F                    		jne	short _$P_CSW00		; if yes, process match flags
  2893                                  						; if no, the switch terminated by colon?
  2894 0000079D 807CFF3A                		cmp	byte [si-1],':' ;_$P_Colon 
  2895 000007A1 7507                    		jne	short _$P_Chk_if_data_required ; if yes,
  2896                                  		;mov	word [_$P_RC],9 ; _$P_Syntax ; return syntax error
  2897 000007A3 C606[A070]09            		mov	byte [_$P_RC],9		
  2898 000007A8 EB1A                    		jmp	short _$P_Chk_SW_Exit
  2899                                  
  2900                                  _$P_Chk_if_data_required:			; no data, no colon
  2901                                  						; should have data? 
  2902                                  		;cmp	word [es:bx++_$P_Match_Flag],0 ; zero match flag means 
  2903 000007AA 833F00                  		cmp	word [bx],0		      ; switch followed by nothing is OK
  2904 000007AD 7415                    		je	short _$P_Chk_SW_Exit	; match flags not zero 
  2905                                  						;    so should have something 
  2906                                  						;       if optional bit is not on
  2907                                  		;test	es:[bx]._$P_Match_Flag,_$P_Optional
  2908                                  		;test	word [es:bx],1 ;_$P_Optional ; see if no value is valid
  2909 000007AF F7070100                		test	word [bx],1
  2910 000007B3 750F                    		jnz	short _$P_Chk_SW_Exit
  2911                                  
  2912                                  		;mov	word [_$P_RC],2	;_$P_Op_Missing ; return required operand missing
  2913 000007B5 C606[A070]02            		mov	byte [_$P_RC],2
  2914 000007BA EB08                    		jmp	short _$P_Chk_SW_Exit
  2915                                  _$P_CSW00:
  2916 000007BC E87F00                  		call	_$P_Check_Match_Flags	; process match flag
  2917 000007BF F8                      		clc				; indicate match
  2918 000007C0 EB0B                    		jmp	short _$P_Chk_SW_Single_Exit
  2919                                  _$P_Chk_SW_Err0:
  2920 000007C2 F9                      		stc				; not found in switch synonym list
  2921 000007C3 C3                      		retn
  2922                                  _$P_Chk_SW_Exit:
  2923 000007C4 50                      		push	ax
  2924                                  		;mov	al,_$P_String
  2925                                  		;mov	ah,_$P_No_Tag
  2926 000007C5 B803FF                  		mov	ax,0FF03h
  2927 000007C8 E80300                  		call	_$P_Fill_Result		; set result buffer
  2928 000007CB 58                      		pop	ax
  2929 000007CC F8                      		clc
  2930                                  _$P_Chk_SW_Single_Exit:
  2931 000007CD C3                      		retn
  2932                                  ;ELSE						;(of IF KeySW)
  2933                                  ;		stc				;  this logic works when the KeySW
  2934                                  ;		retn				;  is reset.
  2935                                  ;ENDIF						;(of KeySW)
  2936                                  
  2937                                  ;***********************************************************************
  2938                                  ;
  2939                                  ; _$P_Fill_Result
  2940                                  ;
  2941                                  ; Function: Fill the result buffer
  2942                                  ;
  2943                                  ; Input:    AH = Item tag
  2944                                  ;	    AL = type
  2945                                  ;		  AL = 1: CX,DX has 32bit number (CX = high)
  2946                                  ;		  AL = 2: DX has index(offset) into value list
  2947                                  ;		  AL = 6: DL has driver # (1-A, 2-B, ... , 26 - Z)
  2948                                  ;		  AL = 7: DX has year, CL has month and CH has date
  2949                                  ;		  AL = 8: DL has hours, DH has minutes, CL has seconds,
  2950                                  ;			  amd CH has hundredths
  2951                                  ;		  AL = else: psdata_seg:SI points to returned string buffer
  2952                                  ;	    ES:BX -> CONTROL block
  2953                                  ;
  2954                                  ; Output:   None
  2955                                  ;
  2956                                  ; Use:	_$P_Do_CAPS_String, _$P_Remove_Colon, _$P_Found_SYNONYM
  2957                                  ;
  2958                                  ; Vars: _$P_DX(W)
  2959                                  ;
  2960                                  ;***********************************************************************
  2961                                  
  2962                                  _$P_Fill_Result:		; 09/11/2018
  2963 000007CE 57                      		push	di
  2964                                  		;mov	di,[es:bx+_$P_Result_Buf] ; di points to result buffer
  2965                                  		;mov	di,[es:bx+4]
  2966 000007CF 8B7F04                  		mov	di,[bx+4]
  2967 000007D2 893E[A470]              		mov	[_$P_DX],di		; set returned result address
  2968                                  		;mov	[es:di],al ;[es:di+_$P_Type]	; store type
  2969                                  		;mov	[es:di+1],ah ;[es:di+_$P_Item_Tag] ; store item tag
  2970                                  		;mov	[es:di],ax
  2971 000007D6 8905                    		mov	[di],ax
  2972 000007D8 50                      		push	ax
  2973 000007D9 A1[B370]                		mov	ax,[_$P_Found_SYNONYM]	; if yes,
  2974                                  		;mov	[es:di+_$P_SYNONYM_Ptr],ax
  2975                                  		;mov	[es:di+2],ax		; then set it to the result
  2976 000007DC 894502                  		mov	[di+2],ax
  2977 000007DF 58                      		pop	ax
  2978                                  _$P_RLT04:
  2979 000007E0 3C01                    		cmp	al,1 ;_$P_Number		; if number
  2980 000007E2 7508                    		jne	short _$P_RLT00
  2981                                  _$P_RLT02:
  2982                                  		;mov	word ptr es:[di]._$P_Picked_Val,dx
  2983                                  		;mov	[es:di+4],dx		; then store 32bit number
  2984 000007E4 895504                  		mov	[di+4],dx
  2985                                  		;mov	word ptr es:[di+2]._$P_Picked_Val,cx
  2986                                  		;mov	[es:di+6],cx
  2987 000007E7 894D06                  		mov	[di+6],cx
  2988 000007EA EB50                    		jmp	short _$P_RLT_Exit
  2989                                  _$P_RLT00:
  2990 000007EC 3C02                    		cmp	al,2 ;_$P_List_Idx	; if list index
  2991 000007EE 7505                    		jne	short _$P_RLT01
  2992                                  		;mov	[es:di+4],dx		; then store list index
  2993 000007F0 895504                  		mov	[di+4],dx
  2994 000007F3 EB47                    		jmp	short _$P_RLT_Exit
  2995                                  _$P_RLT01:
  2996 000007F5 3C07                    		cmp	al,7 ;_$P_Date_F		; Date format?
  2997 000007F7 74EB                    		je	short _$P_RLT02
  2998 000007F9 3C08                    		cmp	al,8 ;_$P_Time_F		; Time format?
  2999 000007FB 74E7                    		je	short _$P_RLT02
  3000 000007FD 3C06                    		cmp	al,6 ;_$P_Drive		; drive format?
  3001 000007FF 7505                    		jne	short _$P_RLT03
  3002                                  		;mov	byte ptr es:[di]._$P_Picked_Val,dl
  3003                                  		;mov	[es:di+4],dl		; store drive number
  3004 00000801 885504                  		mov	[di+4],dl
  3005 00000804 EB36                    		jmp	short _$P_RLT_Exit
  3006                                  _$P_RLT03:
  3007 00000806 3C04                    		cmp	al,4 ;_$P_Complex	; complex format?
  3008 00000808 750C                    		jne	short _$P_RLT05
  3009 0000080A A1[AD70]                		mov	ax,[_$P_SaveSI_Cmpx]	; then get pointer in command buffer
  3010 0000080D 40                      		inc	ax			; skip left Parentheses
  3011                                  		;mov	[es:di+_$P_Picked_Val],ax
  3012 0000080E 894504                  		mov	[di+4],ax		; store offset
  3013                                  		;mov	[es:di+_$P_Picked_Val+2],ds
  3014 00000811 8C5D06                  		mov	[di+6],ds		; store segment
  3015 00000814 EB26                    		jmp	short _$P_RLT_Exit
  3016                                  _$P_RLT05:
  3017                                  		;mov	[es:di+_$P_Picked_Val],si
  3018 00000816 897504                  		mov	[di+4],si		; store offset of STRING_BUF
  3019                                  		;mov	word [es:di+_$P_Picked_Val+2],Psdata_Seg
  3020 00000819 8C4D06                  		mov	[di+6],cs		; store segment of STRING_BUF
  3021 0000081C 50                      		push	ax
  3022                                  		;test	byte [es:bx+_$P_Function_Flag],_$P_CAP_File
  3023 0000081D F6470201                		test	byte [bx+2],1		; need CAPS by file table?
  3024 00000821 7404                    		jz	short _$P_RLT_CAP00
  3025 00000823 B004                    		mov	al,4 ;_$P_DOSTBL_File	; use file upper case table
  3026 00000825 EB08                    		jmp	short _$P_RLT_CAP02
  3027                                  _$P_RLT_CAP00:
  3028                                  		;test	byte [es:bx+_$P_Function_Flag],_$P_CAP_Char
  3029 00000827 F6470202                		test	byte [bx+2],2		; need CAPS by char table?
  3030 0000082B 7405                    		jz	short _$P_RLT_CAP01
  3031 0000082D B002                    		mov	al,2 ;_$P_DOSTBL_Char	; use character upper case table
  3032                                  _$P_RLT_CAP02:
  3033 0000082F E8AE00                  		call	_$P_Do_CAPS_String	; process CAPS along the table
  3034                                  _$P_RLT_CAP01:
  3035 00000832 58                      		pop	ax
  3036                                  		;test	byte [es:bx+_$P_Function_Flag],_$P_Rm_Colon
  3037 00000833 F6470210                		test	byte [bx+2],10h		; removing colon at end?
  3038 00000837 7403                    		jz	short _$P_RLT_Exit
  3039 00000839 E88100                  		call	_$P_Remove_Colon	; then process it.	
  3040                                  _$P_RLT_Exit:
  3041 0000083C 5F                      		pop	di
  3042 0000083D C3                      		retn
  3043                                  
  3044                                  ;***********************************************************************
  3045                                  ;
  3046                                  ; _$P_Check_Match_Flags
  3047                                  ;
  3048                                  ; Function:  Check the match_flags and make the exit code and set the
  3049                                  ;	     result buffer
  3050                                  ;
  3051                                  ;	    Check for types in this order:
  3052                                  ;		Complex
  3053                                  ;		Date
  3054                                  ;		Time
  3055                                  ;		Drive
  3056                                  ;		Filespec
  3057                                  ;		Quoted String
  3058                                  ;		Simple String
  3059                                  ;
  3060                                  ; Input:     psdata_seg:SI -> _$P_STRING_BUF
  3061                                  ;	     ES:BX -> CONTROL block
  3062                                  ;
  3063                                  ; Output:    None
  3064                                  ;
  3065                                  ; Use:	     _$P_Value, P$_SValue, _$P_Simple_String, _$P_Date_Format
  3066                                  ;	     _$P_Time_Format, _$P_Complex_Format, _$P_File_Foemat
  3067                                  ;	     _$P_Drive_Format
  3068                                  ;
  3069                                  ;***********************************************************************
  3070                                  
  3071                                  _$P_Check_Match_Flags:
  3072 0000083E C606[6071]00            		mov	byte [_$P_err_flag],0 ;_$P_NULL	
  3073                                  						; clear filespec error flag.
  3074 00000843 50                      		push	ax
  3075                                  		;mov	ax,[es:bx] ; [es:bx+_$P_Match_Flag] 
  3076 00000844 8B07                    		mov	ax,[bx]			; load match flag(16bit) to ax
  3077 00000846 09C0                    		or	ax,ax			; test ax for zero
  3078 00000848 7515                    		jnz	short _$P_Mat
  3079 0000084A 50                      		push	ax
  3080 0000084B 53                      		push	bx
  3081 0000084C 52                      		push	dx
  3082 0000084D 57                      		push	di
  3083                                  		;mov	word [_$P_RC],9
  3084 0000084E C606[A070]09            		mov	byte [_$P_RC],9 ;_$P_Syntax
  3085                                  		;mov	ah,_$P_No_Tag ; 0FFh
  3086                                  		;mov	al,_$P_String ; 03h
  3087 00000853 B803FF                  		mov	ax,0FF03h
  3088 00000856 E875FF                  		call	_$P_Fill_Result
  3089 00000859 5F                      		pop	di
  3090 0000085A 5A                      		pop	dx
  3091 0000085B 5B                      		pop	bx
  3092 0000085C 58                      		pop	ax
  3093                                  		;jmp	short _$P_Bridge
  3094 0000085D EB49                    		jmp	short _$P_Match_Exit
  3095                                  _$P_Mat:
  3096 0000085F A90010                  		test	ax,1000h ;_$P_Date_S	; Date string	
  3097 00000862 740F                    		jz	short _$P_Match01
  3098                                  		;mov	word [_$P_RC],0
  3099 00000864 C606[A070]00            		mov	byte [_$P_RC],0 ;_$P_No_Error ; assume no error
  3100 00000869 E8B502                  		call	_$P_Date_Format
  3101                                  		;cmp	word [_$P_RC],9
  3102 0000086C 803E[A070]09            		cmp	byte [_$P_RC],9 ;_$P_Syntax ; if error, examine the next type
  3103                                  		;jne	short _$P_Bridge
  3104 00000871 7535                    		jne	short _$P_Match_Exit
  3105                                  _$P_Match01:
  3106                                  ;		jmp	short _$P_Match03		
  3107                                  ;_$P_Bridge:
  3108                                  ;		jmp	short _$P_Match_Exit
  3109                                  _$P_Match03:
  3110 00000873 A90080                  		test	ax,8000h ;_$P_Num_Val	; Numeric value
  3111 00000876 740F                    		jz	short _$P_Match04
  3112                                  		;mov	word [_$P_RC],0
  3113 00000878 C606[A070]00            		mov	byte [_$P_RC],0 ;_$P_No_Error ; assume no error
  3114 0000087D E8D600                  		call	_$P_Value		; do process
  3115                                  		;cmp	word [_$P_RC],9
  3116 00000880 803E[A070]09            		cmp	byte [_$P_RC],9		; if error, examine the next type
  3117 00000885 7521                    		jne	short _$P_Match_Exit
  3118                                  _$P_Match04:
  3119 00000887 A90040                  		test	ax,4000h ;_$P_SNum_Val	; Signed numeric value
  3120 0000088A 740F                    		jz	short _$P_Match05
  3121                                  		;mov	word [_$P_RC],0
  3122 0000088C C606[A070]00            		mov	byte [_$P_RC],0 ;_$P_No_Error ; assume no error
  3123 00000891 E8A200                  		call	_$P_SValue		; do process
  3124                                  		;cmp	word [_$P_RC],9
  3125 00000894 803E[A070]09            		cmp	byte [_$P_RC],9 ;_$P_Syntax ; if error, examine the next type
  3126 00000899 750D                    		jne	short _$P_Match_Exit
  3127                                  _$P_Match05:
  3128 0000089B A90020                  		test	ax,2000h ;_$P_Simple_S	; Signed numeric value
  3129 0000089E 7408                    		jz	short _$P_Match_Exit
  3130                                  		;mov	word [_$P_RC],0		; assume no error
  3131 000008A0 C606[A070]00            		mov	byte [_$P_RC],0 ;_$P_No_Error
  3132 000008A5 E8C401                  		call	_$P_Simple_String	; do process
  3133                                  _$P_Match_Exit:
  3134 000008A8 803E[6071]01            		cmp	byte [_$P_err_flag],1 ;_$P_error_filespec ; bad filespec?
  3135 000008AD 750C                    		jne	short _$P_Match2_Exit	; no, continue
  3136                                  		;cmp	word [_$P_RC],0
  3137 000008AF 803E[A070]00            		cmp	byte [_$P_RC],0 ;_$P_No_Error ; check for other errors?
  3138 000008B4 7505                    		jne	short _$P_Match2_Exit	; no, continue
  3139                                  		;mov	word [_$P_RC],9
  3140 000008B6 C606[A070]09            		mov	byte [_$P_RC],9 ;_$P_Syntax ; set error flag
  3141                                  _$P_Match2_Exit:
  3142 000008BB 58                      		pop	ax
  3143 000008BC C3                      		retn
  3144                                  
  3145                                  ;***********************************************************************
  3146                                  ;
  3147                                  ; _$P_Remove_Colon;
  3148                                  ;
  3149                                  ; Function: Remove colon at end
  3150                                  ;
  3151                                  ; Input:    psdata_seg:SI points to string buffer to be examined
  3152                                  ;
  3153                                  ; Output:   None
  3154                                  ;
  3155                                  ; Use:	_$P_Chk_DBCS
  3156                                  ;
  3157                                  ;***********************************************************************
  3158                                  
  3159                                  _$P_Remove_Colon:
  3160 000008BD 50                      		push	ax
  3161 000008BE 56                      		push	si
  3162                                  _$P_RCOL_Loop:
  3163 000008BF 8A04                    		mov	al,[si]			; get character
  3164 000008C1 08C0                    		or	al,al			; end of string?
  3165 000008C3 7418                    		jz	short _$P_RCOL_Exit	; if yes, just exit
  3166 000008C5 3C3A                    		cmp	al,':'			; is it colon?
  3167 000008C7 750B                    		jne	short _$P_RCOL00
  3168 000008C9 807C0100                		cmp	byte [si+1],0 ;_$P_NULL	; if so, next is NULL?
  3169 000008CD 7505                    		jne	short _$P_RCOL00	; no, then next char	
  3170 000008CF C60400                  		mov	byte [si],0		; yes, remove colon
  3171 000008D2 EB09                    		jmp	short _$P_RCOL_Exit	; and exit.
  3172                                  _$P_RCOL00:
  3173 000008D4 E8FCFD                  		call	_$P_Chk_DBCS		; if not colon, then check if
  3174 000008D7 7301                    		jnc	short _$P_RCOL01	; DBCS leading byte.
  3175 000008D9 46                      		inc	si			; if yes, skip trailing byte
  3176                                  _$P_RCOL01:
  3177 000008DA 46                      		inc	si			; si points to next byte
  3178 000008DB EBE2                    		jmp	short _$P_RCOL_Loop	; loop until NULL encountered
  3179                                  _$P_RCOL_Exit:
  3180 000008DD 5E                      		pop	si
  3181 000008DE 58                      		pop	ax
  3182 000008DF C3                      		retn
  3183                                  
  3184                                  ;***********************************************************************
  3185                                  ;
  3186                                  ; _$P_Do_CAPS_String;
  3187                                  ;
  3188                                  ; Function: Perform capitalization along with the file case map table
  3189                                  ;	    or character case map table.
  3190                                  ;
  3191                                  ; Input:    AL = 2 : Use character table
  3192                                  ;	    AL = 4 : Use file table
  3193                                  ;	    psdata_seg:SI points to string buffer to be capitalized
  3194                                  ;
  3195                                  ; Output:   None
  3196                                  ;
  3197                                  ; Use:	_$P_Do_CAPS_Char, _$P_Chk_DBCS
  3198                                  ;
  3199                                  ;***********************************************************************
  3200                                  
  3201                                  _$P_Do_CAPS_String:
  3202 000008E0 56                      		push	si
  3203 000008E1 52                      		push	dx
  3204 000008E2 88C2                    		mov	dl,al			; save info id
  3205                                  _$P_DCS_Loop:
  3206 000008E4 8A04                    		mov	al,[si]			; load character and
  3207 000008E6 E8EAFD                  		call	_$P_Chk_DBCS		; check if DBCS leading byte
  3208 000008E9 720B                    		jc	short _$P_DCS00		; if yes, do not need CAPS
  3209 000008EB 08C0                    		or	al,al			; end of string?
  3210 000008ED 740B                    		jz	short _$P_DCS_Exit	; then exit.
  3211 000008EF E80B00                  		call	_$P_Do_CAPS_Char	; Here a SBCS char need to be CAPS
  3212 000008F2 8804                    		mov	[si],al			; stored upper case char to buffer
  3213 000008F4 EB01                    		jmp	short _$P_DCS01		; process nexit
  3214                                  _$P_DCS00:
  3215 000008F6 46                      		inc	si			; skip DBCS leading and trailing byte
  3216                                  _$P_DCS01:
  3217 000008F7 46                      		inc	si			; si point to next byte
  3218 000008F8 EBEA                    		jmp	short _$P_DCS_Loop	; loop until NULL encountered
  3219                                  _$P_DCS_Exit:
  3220 000008FA 5A                      		pop	dx
  3221 000008FB 5E                      		pop	si
  3222 000008FC C3                      		retn
  3223                                  
  3224                                  ;***********************************************************************
  3225                                  ;
  3226                                  ; _$P_Do_CAPS_Char;
  3227                                  ;
  3228                                  ; Function: Perform capitalization along with the file case map table
  3229                                  ;	    or character case map table.
  3230                                  ;
  3231                                  ; Input:    DL = 2 : Use character table
  3232                                  ;	    DL = 4 : Use file table
  3233                                  ;	    AL = character to be capitalized
  3234                                  ;
  3235                                  ; Output:   None
  3236                                  ;
  3237                                  ; Use:	INT 21h /w AH=65h
  3238                                  ;
  3239                                  ;***********************************************************************
  3240                                  
  3241                                  _$P_Do_CAPS_Char:
  3242 000008FD 3C80                    		cmp	al,80h	;_$P_ASCII80 ; need upper case table?
  3243 000008FF 730B                    		jnb	short _$P_DCC_Go ; if no,
  3244 00000901 3C61                    		cmp	al,'a'		 ;   check if  "a" <= AL <= "z"
  3245 00000903 7230                    		jb	short _$P_CAPS_Ret
  3246 00000905 3C7A                    		cmp	al,'z'
  3247 00000907 772C                    		ja	short _$P_CAPS_Ret ;   if yes, make CAPS	
  3248 00000909 24DF                    		and	al,0DFh ;_$P_Make_Upper	;   else do nothing.
  3249 0000090B C3                      		retn
  3250                                  _$P_DCC_Go:
  3251 0000090C 53                      		push	bx
  3252 0000090D 06                      		push	es
  3253 0000090E 57                      		push	di
  3254                                  		;lea	di,[_$P_Char_CAP_Ptr]
  3255 0000090F BF[5B71]                		mov	di,_$P_Char_CAP_Ptr
  3256                                  _$P_DCC00:
  3257 00000912 3815                    		cmp	[di],dl		; already got table address?
  3258 00000914 7413                    		je	short _$P_DCC01	; if no,
  3259                                  
  3260                                  ;In this next section, ES will be used to pass a 5 byte workarea to INT 21h,
  3261                                  ; the GET COUNTYRY INFO call. 
  3262                                  
  3263 00000916 50                      		push	ax
  3264 00000917 51                      		push	cx
  3265 00000918 52                      		push	dx
  3266                                  		;push	cs
  3267                                  		;pop	es
  3268                                  				; ES:DI = pointer to output buffer
  3269 00000919 92                      		xchg	ax,dx
  3270 0000091A B465                    		mov	ah,65h ;_$P_DOS_Get_TBL
  3271                                  				; Get Extended Country Information
  3272 0000091C BBFFFF                  		mov	bx,-1 ; 0FFFFh ; _$P_DOSTBL_Def ; get active CON
  3273 0000091F B90500                  		mov	cx,5 ;_$P_DOSTBL_BL ; buffer length
  3274 00000922 89DA                    		mov	dx,bx ; -1 ; get for default code page
  3275 00000924 CD21                    		int	21h	; COUNTRY-DEPENDENT FILENAME CAPITALIZATION
  3276                                  				; AL = function	- (02h or 04h)
  3277 00000926 5A                      		pop	dx
  3278 00000927 59                      		pop	cx
  3279 00000928 58                      		pop	ax
  3280                                  _$P_DCC01:
  3281                                  				  ; [ES:DI] = country id (02h or 04h)
  3282 00000929 C45D01                  		les	bx,[di+1] ; [ES:DI+1] = pointer to uppercase table
  3283 0000092C 43                      		inc	bx	; add 2 to bx reg
  3284 0000092D 43                      		inc	bx	; to skip length field	
  3285 0000092E 2C80                    		sub	al,80h	; make char to index
  3286                                  		;xlat	byte ptr es:[bx]
  3287 00000930 26                      		es		; segment prefix (xlat byte ptr es:[bx])
  3288 00000931 D7                      		xlat		; perform case map
  3289 00000932 5F                      		pop	di
  3290 00000933 07                      		pop	es
  3291 00000934 5B                      		pop	bx
  3292                                  _$P_CAPS_Ret:
  3293 00000935 C3                      		retn
  3294                                  
  3295                                  ;***********************************************************************
  3296                                  ;
  3297                                  ; _$P_Value / _$P_SValue
  3298                                  ;
  3299                                  ; Function:  Make 32bit value from psdata_seg:SI and see value list
  3300                                  ;	     and make result buffer.
  3301                                  ;	     _$P_SValue is an entry point for the signed value
  3302                                  ;	     and this will simply call _$P_Value after the handling
  3303                                  ;	     of the sign character, "+" or "-"
  3304                                  ;
  3305                                  ; Input:     psdata_seg:SI -> _$P_STRING_BUF
  3306                                  ;	     ES:BX -> CONTROL block
  3307                                  ;
  3308                                  ; Output:    None
  3309                                  ;
  3310                                  ; Use:	_$P_Fill_Result, _$P_Check_OVF
  3311                                  ;
  3312                                  ; Vars: _$P_RC(W), _$P_Flags(RW)
  3313                                  ;
  3314                                  ;***********************************************************************
  3315                                  
  3316                                  _$P_SValue:				; when signed value here
  3317 00000936 50                      		push	ax
  3318 00000937 800E[AC70]80            		or	byte [_$P_Flags2],80h	; indicate a signed numeric
  3319                                  					; 0FFh - _$P_Neg
  3320 0000093C 8026[AC70]FD            		and	byte [_$P_Flags2],~2 ; not 2 ; assume positive value
  3321 00000941 8A04                    		mov	al,[si]		; get sign
  3322 00000943 3C2B                    		cmp	al,'+' ;_$P_Plus
  3323 00000945 7409                    		je	short _$P_SVal00
  3324 00000947 3C2D                    		cmp	al,'-'
  3325 00000949 7506                    		jne	short _$P_Sval01 ; else	
  3326 0000094B 800E[AC70]02            		or	byte [_$P_Flags2],2 ;_$P_Neg ; set this is negative value
  3327                                  _$P_SVal00:
  3328 00000950 46                      		inc	si		; skip sign char
  3329                                  _$P_Sval01:
  3330 00000951 E80200                  		call	_$P_Value	; and process value
  3331 00000954 58                      		pop	ax
  3332 00000955 C3                      		retn
  3333                                  
  3334                                  ; ----------------------------------------------------------------------------
  3335                                  
  3336                                  _$P_Value:
  3337 00000956 50                      		push	ax
  3338 00000957 51                      		push	cx
  3339 00000958 52                      		push	dx
  3340 00000959 56                      		push	si
  3341 0000095A 31C9                    		xor	cx,cx		; cx = higher 16 bits
  3342 0000095C 31D2                    		xor	dx,dx		; dx = lower 16 bits
  3343 0000095E 53                      		push	bx		; save control pointer
  3344                                  _$P_Value_Loop:
  3345 0000095F 8A04                    		mov	al,[si]		; get character
  3346 00000961 08C0                    		or	al,al		; end of line?
  3347 00000963 7438                    		jz	short _$P_Value00
  3348 00000965 E8F600                  		call	_$P_0099	; make asc(0..9) to bin(0..9)
  3349 00000968 722F                    		jc	short _$P_Value_Err0 ; error, exit
  3350 0000096A 30E4                    		xor	ah,ah
  3351 0000096C 89C5                    		mov	bp,ax		; save binary number
  3352 0000096E E81C00                  		call	_$P_Value_sub1	; 2*x
  3353 00000971 89D3                    		mov	bx,dx		; save low(2*x)
  3354 00000973 89C8                    		mov	ax,cx		; save high(2*x)
  3355 00000975 E81500                  		call	_$P_Value_sub1  ; 4*x
  3356 00000978 E81200                  		call	_$P_Value_sub1	; 8*x
  3357 0000097B 01DA                    		add	dx,bx		; 10*x
  3358 0000097D 11C1                    		adc	cx,ax		; 32bit ADD
  3359 0000097F E80F00                  		call	_$P_Value_sub2	; Overflow occurred?
  3360 00000982 01EA                    		add	dx,bp		; Add the current one degree decimal
  3361 00000984 83D100                  		adc	cx,0		; if carry, add 1 to high 16bit	
  3362 00000987 E80700                  		call	_$P_Value_sub2	; Overflow occurred?
  3363 0000098A 46                      		inc	si
  3364 0000098B EBD2                    		jmp	short _$P_Value_Loop
  3365                                  _$P_Value_sub1:
  3366 0000098D D1E2                    		shl	dx,1		; to have 2*x
  3367 0000098F D1D1                    		rcl	cx,1		; shift left w/ carry
  3368                                  _$P_Value_sub2:
  3369 00000991 E8B900                  		call	_$P_Check_OVF	; Overflow occurred?
  3370 00000994 7201                    		jc	short _$P_Value_sub2_err ; then error, exit
  3371 00000996 C3                      		retn
  3372                                  _$P_Value_sub2_err:
  3373 00000997 44                      		inc	sp		; skip return address on top of stack
  3374 00000998 44                      		inc	sp
  3375                                  _$P_Value_Err0:
  3376 00000999 5B                      		pop	bx		; retore control pointer
  3377 0000099A E9A000                  		jmp	_$P_Value_Err	; Bridge
  3378                                  _$P_Value00:
  3379 0000099D 5B                      		pop	bx
  3380 0000099E F606[AC70]02            		test	byte [_$P_Flags2],2 ;_$P_Neg ;   here cx,dx = 32bit value
  3381 000009A3 740A                    		jz	short _$P_Value01 ; was it negative?
  3382 000009A5 F7D1                    		not	cx		; +
  3383 000009A7 F7D2                    		not	dx		; |- Make 2's complemeny
  3384 000009A9 83C201                  		add	dx,1		; |
  3385 000009AC 83D100                  		adc	cx,0		; +
  3386                                  _$P_Value01:				; / nval = 0
  3387                                  		;mov	si,es:[bx]._$P_Value_List
  3388                                  		;mov	si,[es:bx+6]	; si points to value list
  3389 000009AF 8B7706                  		mov	si,[bx+6]
  3390                                  		;mov	al,[es:si]	; get nval
  3391 000009B2 8A04                    		mov	al,[si]
  3392 000009B4 3C00                    		cmp	al,0 ;_$P_nval_None ; no value list?
  3393 000009B6 7506                    		jne	short _$P_Value02
  3394                                  		;mov	al,_$P_Number	; Set type
  3395                                  		;mov	ah,_$P_No_Tag	; No ITEM_TAG set
  3396 000009B8 B801FF                  		mov	ax,0FF01h
  3397 000009BB E98700                  		jmp	_$P_Value_Exit
  3398                                  _$P_Value02:
  3399 000009BE 46                      		inc	si
  3400                                  		;mov	al,[es:si]	; al = number of range
  3401 000009BF 8A04                    		mov	al,[si]
  3402 000009C1 3C00                    		cmp	al,0 ;_$P_No_nrng
  3403 000009C3 7453                    		je	short _$P_Value03
  3404 000009C5 46                      		inc	si		; si points to 1st item_tag
  3405                                  _$P_Val02_Loop:
  3406 000009C6 F606[AC70]80            		test	byte [_$P_Flags2],80h ;_$P_Signed
  3407 000009CB 751A                    		jnz	short _$P_Val02_Sign
  3408                                  		;cmp	cx,[es:si+_$P_Val_XH]
  3409                                  		;cmp	cx,[es:si+3]	; comp cx with XH
  3410 000009CD 3B4C03                  		cmp	cx,[si+3]
  3411 000009D0 722F                    		jb	short _$P_Val02_Next
  3412 000009D2 7705                    		ja	short _$P_Val_In
  3413                                  		;cmp	dx,[es:si+_$P_Val_XL]
  3414                                  		;cmp	dx,[es:si+1]	; comp dx with XL
  3415 000009D4 3B5401                  		cmp	dx,[si+1]
  3416 000009D7 7228                    		jb	short _$P_Val02_Next
  3417                                  _$P_Val_In:
  3418                                  		;cmp	cx,[es:si+_$P_Val_YH]
  3419                                  		;cmp	cx,[es:si+7]	; comp cx with YH
  3420 000009D9 3B4C07                  		cmp	cx,[si+7]
  3421 000009DC 7723                    		ja	short _$P_Val02_Next
  3422 000009DE 7232                    		jb	short _$P_Val_Found
  3423                                  		;cmp	dx,[es:si+_$P_Val_YL]	
  3424                                  		;cmp	dx,[es:si+5]	; comp dx with YL
  3425 000009E0 3B5405                  		cmp	dx,[si+5]
  3426 000009E3 771C                    		ja	short _$P_Val02_Next
  3427 000009E5 EB2B                    		jmp	short _$P_Val_Found
  3428                                  _$P_Val02_Sign:
  3429                                  		;cmp	cx,[es:si+_$P_Val_XH]
  3430                                  		;cmp	cx,[es:si+3]	; comp cx with XH
  3431 000009E7 3B4C03                  		cmp	cx,[si+3]
  3432 000009EA 7C15                    		jl	short _$P_Val02_Next
  3433 000009EC 7F05                    		jg	short _$P_SVal_In
  3434                                  		;cmp	dx,[es:si+_$P_Val_XL]
  3435                                  		;cmp	dx,[es:si+1]	; comp dx with XL
  3436 000009EE 3B5401                  		cmp	dx,[si+1]
  3437 000009F1 7C0E                    		jl	short _$P_Val02_Next
  3438                                  _$P_SVal_In:
  3439                                  		;cmp	cx,[es:si+_$P_Val_YH]
  3440                                  		;cmp	cx,[es:si+7]	; comp cx with YH
  3441 000009F3 3B4C07                  		cmp	cx,[si+7]
  3442 000009F6 7F09                    		jg	short _$P_Val02_Next
  3443 000009F8 7C18                    		jl	short _$P_Val_Found
  3444                                  		;cmp	dx,[es:si+_$P_Val_YL]
  3445                                  		;cmp	dx,[es:si+5]	; comp dx with YL
  3446 000009FA 3B5405                  		cmp	dx,[si+5]
  3447 000009FD 7F02                    		jg	short _$P_Val02_Next
  3448 000009FF EB11                    		jmp	short _$P_Val_Found
  3449                                  _$P_Val02_Next:
  3450 00000A01 83C609                  		add	si,9 ;_$P_Len_Range 
  3451 00000A04 FEC8                    		dec	al		; loop nrng times in AL
  3452 00000A06 75BE                    		jnz	short _$P_Val02_Loop
  3453                                  				; / Not found
  3454                                  		;mov	word [_$P_RC],6	;_$P_Out_of_Range
  3455 00000A08 C606[A070]06            		mov	byte [_$P_RC],6
  3456                                  		;mov	al,_$P_Number	;
  3457                                  		;mov	ah,_$P_No_Tag	; No ITEM_TAG set
  3458 00000A0D B801FF                  		mov	ax,0FF01h
  3459 00000A10 EB33                    		jmp	short _$P_Value_Exit
  3460                                  _$P_Val_Found:
  3461 00000A12 B001                    		mov	al,1 ;_$P_Number
  3462                                  		;mov	ah,[es:si]	; found ITEM_TAG set
  3463 00000A14 8A24                    		mov	ah,[si]
  3464 00000A16 EB2D                    		jmp	short _$P_Value_Exit
  3465                                  _$P_Value03:				; / nval = 2
  3466 00000A18 B409                    		mov	ah,9 ;_$P_Len_Range 
  3467 00000A1A F6E4                    		mul	ah		; Skip nrng field
  3468 00000A1C 40                      		inc	ax
  3469 00000A1D 01C6                    		add	si,ax		; si points to nnval
  3470                                  		;mov	al,[es:si]	; get nnval
  3471 00000A1F 8A04                    		mov	al,[si]
  3472 00000A21 46                      		inc	si		; si points to 1st item_tag
  3473                                  _$P_Val03_Loop:
  3474                                  		;cmp	cx,[es:si+_$P_Val_XH]
  3475                                  		;cmp	cx,[es:si+3]	; comp cx with XH
  3476 00000A22 3B4C03                  		cmp	cx,[si+3]
  3477 00000A25 7505                    		jne	short _$P_Val03_Next
  3478                                  		;cmp	dx,[es:si+_$P_Val_XL]
  3479                                  		;cmp	dx,[es:si+1]	; comp dx with XL
  3480 00000A27 3B5401                  		cmp	dx,[si+1]
  3481 00000A2A 74E6                    		je	short _$P_Val_Found
  3482                                  _$P_Val03_Next:
  3483 00000A2C 83C605                  		add	si,5 ;_$P_Len_Value ; points to next value choice
  3484 00000A2F FEC8                    		dec	al		; loop nval times in AL
  3485 00000A31 75EF                    		jnz	short _$P_Val03_Loop ; / Not found
  3486                                  				; / Not found
  3487                                  		;mov	word [_$P_RC],7 ;_$P_Not_in_Val
  3488 00000A33 C606[A070]07            		mov	byte [_$P_RC],7
  3489                                  		;mov	al,_$P_Number	;
  3490                                  		;mov	ah,_$P_No_Tag	; No ITEM_TAG set
  3491 00000A38 B801FF                  		mov	ax,0FF01h
  3492 00000A3B EB08                    		jmp	short _$P_Value_Exit
  3493                                  _$P_Value_Err:				; / nval = 3 or else
  3494                                  		;mov	word [_$P_RC],9 ;_$P_Syntax
  3495 00000A3D C606[A070]09            		mov	byte [_$P_RC],9
  3496                                  		;mov	al,_$P_String	; Set type
  3497                                  		;mov	ah,_$P_No_Tag	; No ITEM_TAG set
  3498 00000A42 B803FF                  		mov	ax,0FF03h
  3499                                  _$P_Value_Exit:
  3500 00000A45 E886FD                  		call	_$P_Fill_Result
  3501 00000A48 5E                      		pop	si
  3502 00000A49 5A                      		pop	dx
  3503 00000A4A 59                      		pop	cx
  3504 00000A4B 58                      		pop	ax
  3505 00000A4C C3                      		retn
  3506                                  
  3507                                  ;***********************************************************************
  3508                                  ;
  3509                                  ; _$P_Check_OVF
  3510                                  ;
  3511                                  ; Function:  Check if overflow is occurred with consideration of
  3512                                  ;	     signed or un-signed numeric value
  3513                                  ;
  3514                                  ; Input:     Flag register
  3515                                  ;
  3516                                  ; Output:    CY = 1  :	Overflow
  3517                                  ;
  3518                                  ; Vars:     _$P_Flags(R)
  3519                                  ;
  3520                                  ;***********************************************************************
  3521                                  
  3522                                  _$P_Check_OVF:
  3523 00000A4D 9C                      		pushf
  3524 00000A4E F606[AC70]02            		test	byte [_$P_Flags2],2 ;_$P_Neg ; is it negative value ?
  3525 00000A53 7502                    		jnz	short _$P_COVF	; if no, check overflow
  3526 00000A55 9D                      		popf			; by the CY bit
  3527 00000A56 C3                      		retn
  3528                                  _$P_COVF:
  3529 00000A57 9D                      		popf			; else,
  3530 00000A58 7002                    		jo	short _$P_COVF00 ; check overflow by the OF
  3531 00000A5A F8                      		clc			; indicate it with CY bit
  3532 00000A5B C3                      		retn			; CY=0 means no overflow
  3533                                  _$P_COVF00:
  3534 00000A5C F9                      		stc			; and CY=1 means overflow
  3535 00000A5D C3                      		retn
  3536                                  
  3537                                  ;***********************************************************************
  3538                                  ;
  3539                                  ; _$P_0099;
  3540                                  ;
  3541                                  ; Function:  Make ASCII 0-9 to Binary 0-9
  3542                                  ;
  3543                                  ; Input:     AL = character code
  3544                                  ;
  3545                                  ; Output:    CY = 1 : AL is not number
  3546                                  ;	     CY = 0 : AL contains binary value
  3547                                  ;
  3548                                  ;***********************************************************************
  3549                                  
  3550                                  _$P_0099:
  3551 00000A5E 3C30                    		cmp	al, '0'
  3552 00000A60 7208                    		jb	short _$P_0099Err	; must be 0 =< al =< 9
  3553 00000A62 3C39                    		cmp	al, '9'
  3554 00000A64 7704                    		ja	short _$P_0099Err	; must be 0 =< al =< 9
  3555                                  
  3556 00000A66 2C30                    		sub	al, '0'			; make char -> bin
  3557 00000A68 F8                      		clc				; indicate no error
  3558 00000A69 C3                      		retn
  3559                                  _$P_0099Err:
  3560 00000A6A F9                      		stc				; indicate error
  3561 00000A6B C3                      		retn
  3562                                  
  3563                                  ; 10/11/2018
  3564                                  
  3565                                  ;***********************************************************************
  3566                                  ;
  3567                                  ; _$P_Simple_String
  3568                                  ;
  3569                                  ; Function:  See value list for the simple string
  3570                                  ;	     and make result buffer.
  3571                                  ;
  3572                                  ; Input:     psdata_seg:SI -> _$P_STRING_BUF
  3573                                  ;	     ES:BX -> CONTROL block
  3574                                  ;
  3575                                  ; Output:    None
  3576                                  ;
  3577                                  ; Use:	_$P_Fill_Result, _$P_String_Comp
  3578                                  ;
  3579                                  ; Vars: _$P_RC(W)
  3580                                  ;
  3581                                  ;***********************************************************************
  3582                                  
  3583                                  _$P_Simple_String:
  3584 00000A6C 50                      		push	ax
  3585 00000A6D 53                      		push	bx
  3586 00000A6E 52                      		push	dx
  3587 00000A6F 57                      		push	di
  3588                                  		;mov	di,es:[bx]._$P_Value_List
  3589                                  		;mov	di,[es:bx+6]	; di points to value list
  3590 00000A70 8B7F06                  		mov	di,[bx+6]
  3591                                  		;mov	al,[es:di]	; get nval
  3592 00000A73 8A05                    		mov	al,[di]
  3593 00000A75 08C0                    		or	al,al		; no value list?
  3594 00000A77 7504                    		jnz	short _$P_Sim01	; then
  3595 00000A79 B4FF                    		mov	ah,0FFh ;_$P_No_Tag ; No ITEM_TAG set
  3596 00000A7B EB07                    		jmp	short _$P_Sim_Exit ; and set result buffer
  3597                                  _$P_Sim01:
  3598                                  		;mov	word [_$P_RC],9	;_$P_Syntax
  3599 00000A7D C606[A070]09            		mov	byte [_$P_RC],9
  3600 00000A82 B4FF                    		mov	ah,0FFh		; No ITEM_TAG set
  3601                                  _$P_Sim_Exit:
  3602 00000A84 B003                    		mov	al,3 ;_$P_String	; Set type
  3603 00000A86 E845FD                  		call	_$P_Fill_Result
  3604 00000A89 5F                      		pop	di
  3605 00000A8A 5A                      		pop	dx
  3606 00000A8B 5B                      		pop	bx
  3607 00000A8C 58                      		pop	ax
  3608 00000A8D C3                      		retn
  3609                                  
  3610                                  ;***********************************************************************
  3611                                  ;
  3612                                  ; _$P_String_Comp:
  3613                                  ;
  3614                                  ; Function:  Compare two string
  3615                                  ;
  3616                                  ; Input:     psdata_seg:SI -> 1st string
  3617                                  ;	     ES:BP -> 2nd string  (Must be upper case)
  3618                                  ;	     ES:BX -> CONTROL block
  3619                                  ;
  3620                                  ; Output:    CY = 1 if not match
  3621                                  ;
  3622                                  ; Use:	_$P_Chk_DBCS, _$P_Do_CAPS_Char
  3623                                  ;
  3624                                  ; Vars: _$P_KEYor_SW_Ptr(W), _$P_Flags(R). _$P_KEYorSW_Ptr
  3625                                  ;
  3626                                  ;***********************************************************************
  3627                                  
  3628                                  _$P_String_Comp:
  3629 00000A8E 50                      		push	ax
  3630 00000A8F 55                      		push	bp
  3631 00000A90 52                      		push	dx
  3632 00000A91 56                      		push	si
  3633 00000A92 B202                    		mov	dl,2 ;_$P_DOSTBL_Char ; use character case map table
  3634                                  _$P_SCOM_Loop:
  3635 00000A94 8A04                    		mov	al,[si]		; get command character
  3636 00000A96 E83AFC                  		call	_$P_Chk_DBCS	; DBCS?
  3637 00000A99 7237                    		jc	short _$P_SCOM00 ; yes
  3638 00000A9B E85FFE                  		call	_$P_Do_CAPS_Char ; else, upper case map before comparison	
  3639 00000A9E F606[AC70]08            		test	byte [_$P_Flags2],8 ;_$P_Key_Cmp ; keyword search ?
  3640 00000AA3 740C                    		jz	short _$P_SCOM04
  3641 00000AA5 3C3D                    		cmp	al,'=' ;_$P_Keyword ; "=" is delimiter
  3642 00000AA7 751C                    		jne	short _$P_SCOM03 ;IF "=" on command line 
  3643                                  				 ; AND (bp+1=> char after the "=" in synonym list)
  3644                                  		;cmp	byte [es:bp+1],0 ;_$P_NULL ; at end of keyword string 
  3645 00000AA9 807E0100                		cmp	byte [bp+1],0		  ; in the control block THEN
  3646 00000AAD 7565                    		jne	short _$P_SCOM_Differ
  3647 00000AAF EB11                    		jmp	short _$P_SCOM05 ; keyword found in synonym list	
  3648                                  _$P_SCOM04:
  3649 00000AB1 F606[AC70]10            		test	byte [_$P_Flags2],10h ;_$P_SW_Cmp ; switch search ?
  3650 00000AB6 740D                    		jz	short _$P_SCOM03
  3651 00000AB8 3C3A                    		cmp	al,':' ;_$P_Colon ; ":" is delimiter, at end of switch on command line
  3652 00000ABA 7509                    		jne	short _$P_SCOM03 ; continue compares
  3653                                  		;cmp	byte [es:bp],0 ;_$P_NULL ; IF at end of switch on command AND
  3654 00000ABC 807E0000                		cmp	byte [bp],0	; at end of switch string in the control block THEN
  3655 00000AC0 7552                    		jne	short _$P_SCOM_Differ
  3656                                  _$P_SCOM05:				; found a match
  3657 00000AC2 46                      		inc	si		; si points to just after "=" or ":"
  3658 00000AC3 EB52                    		jmp	short _$P_SCOM_Same ; exit
  3659                                  _$P_SCOM03:
  3660                                  		;cmp	al,[es:bp]	; compare operand w/ a synonym
  3661 00000AC5 3A4600                  		cmp	al,[bp]	
  3662 00000AC8 751A                    		jne	short _$P_SCOM_Differ0 ; if different, check ignore colon option
  3663 00000ACA 08C0                    		or	al,al		; end of line
  3664 00000ACC 7449                    		jz	short _$P_SCOM_Same ; if so, exit
  3665 00000ACE 46                      		inc	si		; update operand pointer
  3666 00000ACF 45                      		inc	bp		; and synonym pointer
  3667 00000AD0 EB10                    		jmp	short _$P_SCOM01 ; loop until NULL or "=" or ":" found in case
  3668                                  _$P_SCOM00:
  3669                                  		;cmp	al,[es:bp]	; Here al is DBCS leading byte
  3670 00000AD2 3A4600                  		cmp	al,[bp]		; compare leading byte
  3671 00000AD5 753D                    		jne	short _$P_SCOM_Differ ; if not match, say different
  3672 00000AD7 46                      		inc	si		; else, load next byte
  3673 00000AD8 8A04                    		mov	al,[si]		; and
  3674 00000ADA 45                      		inc	bp
  3675                                  		;cmp	al,[es:bp+0]	; compare 2nd byte
  3676 00000ADB 3A4600                  		cmp	al,[bp]
  3677 00000ADE 7534                    		jnz	short _$P_SCOM_Differ ; if not match, say different, too
  3678 00000AE0 46                      		inc	si		; else update operand pointer
  3679 00000AE1 45                      		inc	bp		; and synonym pointer
  3680                                  _$P_SCOM01:
  3681 00000AE2 EBB0                    		jmp	short _$P_SCOM_Loop ; loop until NULL or "=" or "/" found in case
  3682                                  _$P_SCOM_Differ0:
  3683 00000AE4 F606[AC70]40            		test	byte [_$P_Flags2],40h ;_$P_SW
  3684 00000AE9 740D                    		jz	short _$P_not_applicable
  3685                                  		;test	es:[bx]._$P_Function_Flag,_$P_colon_is_not_necessary
  3686                                  		;test	word [es:bx+2],20h
  3687 00000AEB F747022000              		test	word [bx+2],20h
  3688 00000AF0 7406                    		jz	short _$P_not_applicable
  3689                                  		;cmp	byte [es:bp],0 ;_$P_NULL
  3690 00000AF2 807E0000                		cmp	byte [bp],0
  3691 00000AF6 741F                    		je	short _$P_SCOM_Same
  3692                                  _$P_not_applicable:
  3693                                  		;test	es:[bx]._$P_Match_Flag,_$P_Ig_Colon
  3694                                  		;test	word [es:bx],10h ; ignore colon option specified?	
  3695 00000AF8 F7071000                		test	word [bx],10h
  3696 00000AFC 7416                    		jz	short _$P_SCOM_Differ ; if no, say different.
  3697 00000AFE 3C3A                    		cmp	al,':' ;_$P_Colon ; End up with ":" and	
  3698 00000B00 7508                    		jne	short _$P_SCOM02 ; subseqently	
  3699                                  		;cmp	byte [es:bp+0],0 ; NULL?
  3700 00000B02 807E0000                		cmp	byte [bp],0
  3701 00000B06 750C                    		jne	short _$P_SCOM_Differ ; if no, say different
  3702 00000B08 EB0D                    		jmp	short _$P_SCOM_Same ; else, say same
  3703                                  _$P_SCOM02:
  3704 00000B0A 3C00                    		cmp	al,0 ;_$P_NULL	;end up NULL and :
  3705 00000B0C 7506                    		jne	short _$P_SCOM_Differ
  3706                                  		;cmp	byte [es:bp],':' ;_$P_Colon 
  3707 00000B0E 807E003A                		cmp	byte [bp],':'	; if no, say different
  3708 00000B12 7403                    		je	short _$P_SCOM_Same ; else, say same
  3709                                  _$P_SCOM_Differ:
  3710 00000B14 F9                      		stc			; indicate not found
  3711 00000B15 EB05                    		jmp	short _$P_SCOM_Exit
  3712                                  _$P_SCOM_Same:
  3713 00000B17 8936[AF70]              		mov	[_$P_KEYorSW_Ptr],si ; for later use by keyword or switch
  3714 00000B1B F8                      		clc			; indicate found
  3715                                  _$P_SCOM_Exit:
  3716 00000B1C 5E                      		pop	si
  3717 00000B1D 5A                      		pop	dx
  3718 00000B1E 5D                      		pop	bp
  3719 00000B1F 58                      		pop	ax
  3720 00000B20 C3                      		retn
  3721                                  
  3722                                  ;***********************************************************************
  3723                                  ;
  3724                                  ; _$P_Date_Format
  3725                                  ;
  3726                                  ; Function:  Convert a date string to DOS date format for int 21h
  3727                                  ;	     with format validation.
  3728                                  ;
  3729                                  ; Input:     psdata_seg:SI -> _$P_STRING_BUF
  3730                                  ;	     ES:BX -> CONTROL block
  3731                                  ;
  3732                                  ; Output:    None
  3733                                  ;
  3734                                  ; Use:	_$P_Fill_Result, _$P_Set_CDI, _$P_Get_DecNum
  3735                                  ;
  3736                                  ; Vars: _$P_RC(W), _$P_1st_Val(RW), _$P_2nd_Val(RW), _$P_3rd_Val(RW)
  3737                                  ;
  3738                                  ;***********************************************************************
  3739                                  
  3740                                  _$P_Date_Format:
  3741 00000B21 50                      		push	ax
  3742 00000B22 51                      		push	cx
  3743 00000B23 52                      		push	dx
  3744 00000B24 56                      		push	si
  3745 00000B25 53                      		push	bx
  3746 00000B26 56                      		push	si
  3747 00000B27 E89200                  		call	_$P_Set_CDI ; set country dependent information before process
  3748 00000B2A 5E                      		pop	si
  3749 00000B2B 31C0                    		xor	ax, ax
  3750 00000B2D A3[5371]                		mov	[_$P_1st_Val],ax ; set initial value	
  3751 00000B30 A3[5571]                		mov	[_$P_2nd_Val],ax
  3752 00000B33 A3[5771]                		mov	[_$P_3rd_Val],ax
  3753 00000B36 E89900                  		call	_$P_Get_DecNum	; get 1st number
  3754                                  		;jc	short _$P_DateF_Err0
  3755 00000B39 7270                    		jc	short _$P_DateF_Error
  3756 00000B3B A3[5371]                		mov	[_$P_1st_Val],ax
  3757 00000B3E 08DB                    		or	bl,bl		; end of line?
  3758 00000B40 7418                    		jz	short _$P_DateF_YMD
  3759 00000B42 E88D00                  		call	_$P_Get_DecNum	; get 2nd number
  3760 00000B45 7264                    		jc	short _$P_DateF_Error
  3761 00000B47 A3[5571]                		mov	[_$P_2nd_Val],ax
  3762 00000B4A 08DB                    		or	bl,bl		; end of line ?
  3763 00000B4C 740C                    		jz	short _$P_DateF_YMD
  3764 00000B4E E88100                  		call	_$P_Get_DecNum	; get 3rd number	
  3765                                  _$P_DateF_Err0:				; Bridge	
  3766 00000B51 7258                    		jc	short _$P_DateF_Error
  3767 00000B53 A3[5771]                		mov	[_$P_3rd_Val],ax
  3768 00000B56 08DB                    		or	bl,bl
  3769 00000B58 7551                    		jnz	short _$P_DateF_Error
  3770                                  _$P_DateF_YMD:
  3771                                  		;mov	bx,[_$P_Country_Info+_$P_CDI_DateF]
  3772 00000B5A 8B1E[3671]              		mov	bx,[_$P_Country_Info] ; get date format
  3773 00000B5E 83FB02                  		cmp	bx,2	; _$P_Date_YMD
  3774 00000B61 741F                    		je	short _$P_DateF00
  3775 00000B63 A1[5371]                		mov	ax,[_$P_1st_Val]
  3776 00000B66 08E4                    		or	ah,ah
  3777 00000B68 7541                    		jnz	short _$P_DateF_Error
  3778 00000B6A 88C1                    		mov	cl,al		; set month
  3779 00000B6C A1[5571]                		mov	ax,[_$P_2nd_Val]
  3780 00000B6F 08E4                    		or	ah,ah		; if overflow, error.
  3781 00000B71 7538                    		jnz	short _$P_DateF_Error
  3782 00000B73 88C5                    		mov	ch,al		; set date
  3783 00000B75 8B16[5771]              		mov	dx,[_$P_3rd_Val] ; set year
  3784 00000B79 83FB01                  		cmp	bx,1 ;_$P_Date_DMY ; from here format = MDY
  3785 00000B7C 7502                    		jne	short _$P_DateF01 ; if it is DMY
  3786 00000B7E 86E9                    		xchg	ch,cl		;  then swap M <-> D
  3787                                  _$P_DateF01:
  3788 00000B80 EB16                    		jmp	short _$P_DateF02
  3789                                  _$P_DateF00:				; / here format = YMD
  3790 00000B82 8B16[5371]              		mov	dx,[_$P_1st_Val] ; set year	
  3791 00000B86 A1[5571]                		mov	ax,[_$P_2nd_Val]
  3792 00000B89 08E4                    		or	ah,ah		; if overflow, error
  3793 00000B8B 751E                    		jnz	short _$P_DateF_Error
  3794 00000B8D 88C1                    		mov	cl,al		; set month
  3795 00000B8F A1[5771]                		mov	ax,[_$P_3rd_Val]
  3796 00000B92 08E4                    		or	ah,ah		; if overflow, error
  3797 00000B94 7515                    		jnz	short _$P_DateF_Error
  3798 00000B96 88C5                    		mov	ch,al		; set date
  3799                                  _$P_DateF02:
  3800 00000B98 83FA64                  		cmp	dx,100		; year is less that 100?
  3801 00000B9B 7304                    		jnb	short _$P_DateF03
  3802 00000B9D 81C26C07                		add	dx,1900		; set year 19xx
  3803                                  _$P_DateF03:
  3804 00000BA1 5B                      		pop	bx
  3805 00000BA2 5E                      		pop	si
  3806                                  		;mov	ah,_$P_No_Tag
  3807                                  		;mov	al,_$P_Date_F
  3808 00000BA3 B807FF                  		mov	ax,0FF07h	; set results buffer to date
  3809 00000BA6 E825FC                  		call	_$P_Fill_Result
  3810 00000BA9 EB0D                    		jmp	short _$P_Date_Format_Exit
  3811                                  _$P_DateF_Error:
  3812 00000BAB 5B                      		pop	bx		; recover CONTROL block
  3813 00000BAC 5E                      		pop	si		; recover string pointer
  3814                                  		;mov	ah,_$P_No_Tag	
  3815                                  		;mov	al,_$P_Date_F
  3816 00000BAD B803FF                  		mov	ax,0FF03h	; set results buffer to string
  3817 00000BB0 E81BFC                  		call	_$P_Fill_Result
  3818                                  		;mov	word [_$P_RC],9 ;_$P_Syntax
  3819 00000BB3 C606[A070]09            		mov	byte [_$P_RC],9 ; indicate syntax error
  3820                                  _$P_Date_Format_Exit:
  3821 00000BB8 5A                      		pop	dx
  3822 00000BB9 59                      		pop	cx
  3823 00000BBA 58                      		pop	ax
  3824 00000BBB C3                      		retn
  3825                                  
  3826                                  ;***********************************************************************
  3827                                  ;
  3828                                  ; _$P_Set_CDI:
  3829                                  ;
  3830                                  ; Function: Read CDI from DOS if it has not been read yet
  3831                                  ;
  3832                                  ; Input:    None
  3833                                  ;
  3834                                  ; Output:   psdata_seg:SI -> CDI
  3835                                  ;
  3836                                  ; Use:	INT 21h w/ AH = 38h
  3837                                  ;
  3838                                  ;***********************************************************************
  3839                                  
  3840                                  _$P_Set_CDI:
  3841                                  		;lea	si,[_$P_Country_Info]
  3842 00000BBC BE[3671]                		mov	si,_$P_Country_Info
  3843                                  		;cmp	word [cs:si+_$P_CDI_DateF],_$P_NeedToBeRead
  3844 00000BBF 833CFF                  		cmp	word [si],0FFFFh ; -1 ; already read?
  3845 00000BC2 750D                    		jne	short _$P_Set_CDI_Exit ; then do nothing
  3846                                  					;else read CDI thru DOS
  3847 00000BC4 1E                      		push	ds
  3848 00000BC5 52                      		push	dx
  3849 00000BC6 50                      		push	ax
  3850                                  		;push	cs
  3851                                  		;pop	ds
  3852 00000BC7 B80038                  		mov	ax,3800h ; _$P_DOS_Get_CDI ; get country information
  3853 00000BCA 89F2                    		mov	dx,si ; set offset of CDI in local data area
  3854 00000BCC CD21                    		int	21h	; GET COUNTRY-DEPENDENT INFORMATION
  3855                                  				; get current-country info
  3856                                  				; DS:DX	-> buffer for returned info
  3857 00000BCE 58                      		pop	ax
  3858 00000BCF 5A                      		pop	dx
  3859 00000BD0 1F                      		pop	ds
  3860                                  _$P_Set_CDI_Exit:
  3861 00000BD1 C3                      		retn
  3862                                  
  3863                                  ;***********************************************************************
  3864                                  ;
  3865                                  ; _$P_Get_DecNum:
  3866                                  ;
  3867                                  ; Function:  Read a chracter code from psdata_seg:SI until specified delimiter
  3868                                  ;	     or NULL encountered. And make a decimal number.
  3869                                  ;
  3870                                  ; Input:     psdata_seg:SI -> _$P_STRING_BUF
  3871                                  ;
  3872                                  ; Output:    BL = delimiter code or NULL
  3873                                  ;	     AX = Decimal number
  3874                                  ;	     SI advanced to the next number
  3875                                  ;	     CY = 1 : Syntax error, AL = Latest examined number
  3876                                  ;
  3877                                  ; Use:	_$P_0099
  3878                                  ;
  3879                                  ;***********************************************************************
  3880                                  
  3881                                  _$P_Get_DecNum:
  3882 00000BD2 51                      		push	cx
  3883 00000BD3 52                      		push	dx
  3884 00000BD4 31C9                    		xor	cx,cx		; cx will have final value
  3885                                  _$P_GetNum_Loop:
  3886 00000BD6 8A04                    		mov	al,[si]		; load character
  3887 00000BD8 08C0                    		or	al,al		; end of line?
  3888 00000BDA 743B                    		jz	short _$P_GetNum00 ; if yes, exit
  3889 00000BDC 803E[3571]00            		cmp	byte [_$P_Got_Time],0   ; is this numeric in a time field?
  3890 00000BE1 740F                    		je	short _$P_Do_Date_Delims ; no, go check out Date delimiters
  3891                                  
  3892                                  ; Determine which delimiter(s) to check for. Colon & period or period only
  3893                                   
  3894 00000BE3 80FB01                  		cmp	bl,1 ;_$P_colon_period	; Time
  3895 00000BE6 7504                    		jne	short _$P_Do_Time_Delim1 ; only check for period
  3896 00000BE8 3C3A                    		cmp	al,':' ;_$P_Colon	; Is this a valid delimiter?
  3897 00000BEA 7430                    		je	short _$P_GetNum01	; yes, exit
  3898                                  _$P_Do_Time_Delim1:
  3899 00000BEC 3C2E                    		cmp	al,'.' ;_$P_Period	; Is this a valid delimiter?
  3900 00000BEE 742C                    		je	short _$P_GetNum01	; yes, exit
  3901 00000BF0 EB0C                    		jmp	short _$P_Neither_Delims
  3902                                  _$P_Do_Date_Delims:
  3903                                  ;Regardless of the date delimiter character specified in the country
  3904                                  ;dependent information, check for the presence of any one of these
  3905                                  ;three field delimiters: "-", "/", or ".".
  3906 00000BF2 3C2D                    		cmp	al,'-' ;_$P_Minus	; is this a date delimiter character?
  3907 00000BF4 7426                    		je	short _$P_GetNum01	; if yes, exit
  3908 00000BF6 3C2F                    		cmp	al,'/' ;_$P_Slash	; is this a date delimiter character?	
  3909 00000BF8 7422                    		je	short _$P_GetNum01	; if yes, exit
  3910 00000BFA 3C2E                    		cmp	al,'.' ;_$P_Period	; is this a date delimiter character?
  3911 00000BFC 741E                    		je	short _$P_GetNum01	; if yes, exit
  3912                                  _$P_Neither_Delims:
  3913 00000BFE E85DFE                  		call	_$P_0099		; convert it to binary
  3914 00000C01 721D                    		jc	short _$P_GetNum_Exit	; if error exit
  3915 00000C03 B400                    		mov	ah,0
  3916 00000C05 91                      		xchg	ax,cx
  3917 00000C06 BA0A00                  		mov	dx,10
  3918 00000C09 F7E2                    		mul	dx			; ax = ax*10
  3919 00000C0B 09D2                    		or	dx,dx			; overflow
  3920 00000C0D 7510                    		jnz	short _$P_GetNum02	; then exit
  3921 00000C0F 01C8                    		add	ax,cx
  3922 00000C11 720D                    		jc	short _$P_GetNum_Exit
  3923 00000C13 91                      		xchg	ax,cx
  3924 00000C14 46                      		inc	si
  3925 00000C15 EBBF                    		jmp	short _$P_GetNum_Loop
  3926                                  _$P_GetNum00:
  3927 00000C17 88C3                    		mov	bl,al		; set bl to NULL
  3928                                  _$P_GetNum03:
  3929 00000C19 F8                      		clc			; indicate no error
  3930 00000C1A EB04                    		jmp	short _$P_GetNum_Exit
  3931                                  _$P_GetNum01:
  3932 00000C1C 46                      		inc	si
  3933 00000C1D EBFA                    		jmp	short _$P_GetNum03
  3934                                  _$P_GetNum02:
  3935 00000C1F F9                      		stc			; indicate error
  3936                                  _$P_GetNum_Exit:
  3937 00000C20 91                      		xchg	ax,cx		; return value
  3938 00000C21 5A                      		pop	dx
  3939 00000C22 59                      		pop	cx
  3940 00000C23 C3                      		retn
  3941                                  
  3942                                  ; ----------------------------------------------------------------------------
  3943                                  ; messages.c (FDISK, MSDOS 6.0, 1991)	
  3944                                  ; ----------------------------------------------------------------------------
  3945                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 13/11/2018)
  3946                                  
  3947                                  ;/*  */
  3948                                  ;/******************************************************************************/
  3949                                  ;/*Routine name:  PRELOAD_MESSAGES                                             */
  3950                                  ;/******************************************************************************/
  3951                                  ;/*                                                                            */
  3952                                  ;/*Description:   Preloads messages for Display_Msg and returns error code     */
  3953                                  ;/*               if incorrect DOS version, insuffient memory, or unable to    */
  3954                                  ;/*               to find messages.                                            */
  3955                                  ;/*                                                                            */
  3956                                  ;/*Called Procedures:    sysloadmsg                                            */
  3957                                  ;/*                      display_msg                                           */
  3958                                  ;/*                                                                            */
  3959                                  ;/*Change History: Created        5/30/87         DRM                          */
  3960                                  ;/*                                                                            */
  3961                                  ;/*Input: None                                                                 */
  3962                                  ;/*                                                                            */
  3963                                  ;/*Output: None                                                                */
  3964                                  ;/*                                                                            */
  3965                                  ;/******************************************************************************/
  3966                                  
  3967                                  ;char preload_messages()
  3968                                  
  3969                                  ;BEGIN
  3970                                  ;
  3971                                  ;char message_flag;
  3972                                  ;
  3973                                  ;     /* load all messages for FDISK */
  3974                                  ;     message_flag = c(TRUE);
  3975                                  ;     sysloadmsg(&regs,&regs);  		     /* load the messages */
  3976                                  ;
  3977                                  ;     if ((regs.x.cflag & CARRY_FLAG) == CARRY_FLAG) /* If msg load problem */
  3978                                  ;       BEGIN
  3979                                  ;        sysdispmsg(&regs,&regs); 		     /* write the error message */
  3980                                  ;        message_flag = FALSE;
  3981                                  ;       END
  3982                                  ;     return(message_flag);
  3983                                  ;
  3984                                  ;END
  3985                                  
  3986                                  preload_messages:
  3987                                  
  3988                                  	;%define message_flag bp-2
  3989                                  
  3990                                  		;push	bp
  3991                                  		;mov	bp,sp
  3992                                  		;sub	sp,2
  3993                                  		;;mov	[bp-2],1
  3994                                  		;mov	[message_flag],1
  3995                                  		;mov	ax,regs ;regs_x_ax
  3996                                  		;push	ax
  3997                                  		;push	ax
  3998                                  		;call	sysloadmsg
  3999                                  		;pop	bx
  4000                                  		;pop	bx
  4001                                  
  4002 00000C24 E80800                  		call	SYSLOADMSG ; 14/11/2018
  4003                                  
  4004                                  		;mov	al,[regs_x_cflag]
  4005                                  		;and	al,1
  4006                                  		;cmp	al,1
  4007                                  		;jne	short preloadmsg_ret
  4008                                  		; 14/11/2018
  4009 00000C27 7304                    		jnc	short preloadmsg_1
  4010                                  
  4011                                  		;mov	ax,regs ;regs_x_ax
  4012                                  		;push	ax
  4013                                  		;push	ax
  4014                                  		;call	sysdispmsg
  4015                                  		;pop	bx
  4016                                  		;pop	bx
  4017                                  		;;mov	[bp-2],0
  4018                                  		;mov	[message_flag],0
  4019                                  
  4020                                  		; 14/11/2018
  4021 00000C29 E8E101                  		call	SYSDISPMSG 
  4022                                  
  4023                                  		;sub	ax,ax
  4024                                  		;jmp	short preloadmsg_2
  4025 00000C2C F9                      		stc	
  4026                                  preloadmsg_1:
  4027 00000C2D C3                      		retn
  4028                                  ;preloadmsg_1:
  4029                                  		; 14/11/2018
  4030                                  		;;mov	ax,1
  4031                                  		;xor	ax,ax
  4032                                  		;inc	al
  4033 00000C2E C3                      		retn
  4034                                  ;preloadmsg_2:
  4035                                  		;;;mov	al,[bp-2]
  4036                                  		;;mov	al,[message_flag]
  4037                                  		;;mov	sp,bp
  4038                                  		;;pop	bp
  4039                                  		;;retn
  4040                                  		
  4041                                  		; 13/11/2018
  4042                                  		;cmp	al,1	
  4043                                  		;retn
  4044                                  
  4045                                  ;sysloadmsg:
  4046                                  ;		call	_sysloadmsg
  4047                                  ;		retn
  4048                                  
  4049                                  ; _msgret.asm (MSDOS 6.0, 1991)
  4050                                  ; ----------------------------------------------------------------------------
  4051                                  ; 14/11/2018
  4052                                  
  4053                                  ;_sysloadmsg:
  4054                                  ;
  4055                                  ;	%define inregs  bp+8
  4056                                  ;	%define outregs bp+10
  4057                                  ;
  4058                                  ;		push	bp
  4059                                  ;		mov	bp,sp
  4060                                  ;		push	di
  4061                                  ;		push	si
  4062                                  ;		mov	di,[inregs] 
  4063                                  ;		mov	ax,[di+10] ; regs.x.di
  4064                                  ;		push	ax
  4065                                  ;		mov	ax,[di]	   ; regs.x.ax	
  4066                                  ;		mov	bx,[di+2]  ; regs.x.bx	
  4067                                  ;		mov	cx,[di+4]  ; regs.x.cx	
  4068                                  ;		mov	dx,[di+6]  ; regs.x.dx	
  4069                                  ;		mov	si,[di+8]  ; regs.x.si	
  4070                                  ;		pop	di
  4071                                  ;		push	bp
  4072                                  ;		call	SYSLOADMSG
  4073                                  ;		pop	bp
  4074                                  ;		push	di
  4075                                  ;		mov	di,[outregs]
  4076                                  ;		mov	[di],ax	   ; regs.x.ax	
  4077                                  ;		mov	[di+2],bx  ; regs.x.bx
  4078                                  ;		mov	[di+4],cx  ; regs.x.cx		
  4079                                  ;		mov	[di+6],dx  ; regs.x.dx	
  4080                                  ;		mov	[di+8],si  ; regs.x.si	
  4081                                  ;		lahf
  4082                                  ;		mov	al,ah
  4083                                  ;		mov	[di+12],ax ; regs.x_cflag
  4084                                  ;		pop	ax
  4085                                  ;		mov	[di+10],ax ; regs.x.di	
  4086                                  ;		pop	si
  4087                                  ;		pop	di
  4088                                  ;		mov	sp,bp
  4089                                  ;		pop	bp
  4090                                  ;		retf
  4091                                  
  4092                                  SYSLOADMSG:
  4093                                  
  4094                                  		;push	ax
  4095                                  		;push	bx
  4096                                  		;push	dx
  4097                                  		;push	es
  4098                                  		;push	di
  4099 00000C2F 31C9                    		xor	cx,cx
  4100 00000C31 8EC1                    		mov	es,cx
  4101 00000C33 31FF                    		xor	di,di
  4102 00000C35 B82E12                  		mov	ax,122Eh
  4103 00000C38 B200                    		mov	dl,0
  4104 00000C3A CD2F                    		int	2Fh	; Multiplex - DOS 3+ internal -	GET OR SET ERROR TABLE ADDRESSES
  4105                                  				; DL = subfunction - get standard DOS error table (errors 00h-12h,50h-5Bh)
  4106                                  				; Return: ES:DI	-> error table
  4107 00000C3C 8C06[FC5C]              		mov	[$M_EXT_COMMAND+2],es
  4108 00000C40 893E[FA5C]              		mov	[$M_EXT_COMMAND],di
  4109 00000C44 B82E12                  		mov	ax,122Eh
  4110 00000C47 B202                    		mov	dl,2
  4111 00000C49 CD2F                    		int	2Fh	; Multiplex - DOS 3+ internal -	GET OR SET ERROR TABLE ADDRESSES
  4112                                  				; DL = subfunction - get parameter error table (errors 00h-0Ah)
  4113                                  				; ES:DI	-> error table
  4114 00000C4B 8C06[045D]              		mov	[$M_PARSE_COMMAND+2],es
  4115 00000C4F 893E[025D]              		mov	[$M_PARSE_COMMAND],di
  4116 00000C53 B82E12                  		mov	ax,122Eh
  4117 00000C56 B204                    		mov	dl,4
  4118 00000C58 CD2F                    		int	2Fh	; Multiplex - DOS 3+ internal -	GET OR SET ERROR TABLE ADDRESSES
  4119                                  				; DL = subfunction - get critical/SHARE	error table (errors 13h-2Bh)
  4120                                  				; ES:DI	-> error table
  4121 00000C5A 8C06[145D]              		mov	[$M_CRIT_COMMAND+2],es
  4122 00000C5E 893E[125D]              		mov	[$M_CRIT_COMMAND],di
  4123 00000C62 B82E12                  		mov	ax,122Eh
  4124 00000C65 B206                    		mov	dl,6
  4125 00000C67 CD2F                    		int	2Fh	; Multiplex - DOS 3+ internal -	GET OR SET ERROR TABLE ADDRESSES
  4126                                  				; DL = subfunction - get ??? error table
  4127                                  				; ES:DI	-> error table
  4128 00000C69 8C06[F85C]              		mov	[$M_EXT_FILE+2],es
  4129 00000C6D 893E[F65C]              		mov	[$M_EXT_FILE],di
  4130                                  		;call	_$M_CLS_1
  4131 00000C71 0E                      		push	cs ; *
  4132 00000C72 07                      		pop	es ; *
  4133 00000C73 BF[445F]                		mov	di,CLASS_1_msg_tbl ; 14/11/2018 ; *
  4134 00000C76 8C06[F45C]              		mov	[$M_EXT_ERR_ADDRS+2],es
  4135 00000C7A 893E[F25C]              		mov	[$M_EXT_ERR_ADDRS],di
  4136 00000C7E 8C06[105D]              		mov	[$M_CRIT_ADDRS+2],es
  4137 00000C82 893E[0E5D]              		mov	[$M_CRIT_ADDRS],di
  4138                                  		;call	_$M_CLS_2
  4139 00000C86 BF[5E5F]                		mov	di,CLASS_2_msg_tbl ; 14/11/2018
  4140 00000C89 8C06[085D]              		mov	[$M_PARSE_ADDRS+2],es
  4141 00000C8D 893E[065D]              		mov	[$M_PARSE_ADDRS],di
  4142 00000C91 B82E12                  		mov	ax,122Eh
  4143 00000C94 B208                    		mov	dl,8
  4144 00000C96 CD2F                    		int	2Fh	; Multiplex - DOS 3+ internal -	GET OR SET ERROR TABLE ADDRESSES
  4145                                  				; DL = subfunction - get ??? error table
  4146                                  				; Return: ES:DI	-> error table
  4147 00000C98 8C06[1C5D]              		mov	[$M_DISK_PROC_ADDR+2],es
  4148 00000C9C 893E[1A5D]              		mov	[$M_DISK_PROC_ADDR],di
  4149                                  		;mov	word [$M_CRLF],0A0Dh
  4150                                  		;mov	byte [$M_BUF_TERM],'$'
  4151                                  		;mov	word [$M_MSG_NUM],0
  4152                                  		;mov	[$M_DIVISOR],10
  4153                                  		;call	_$M_CLS_A
  4154 00000CA0 1E                      		push	ds ; *
  4155 00000CA1 07                      		pop	es ; *
  4156 00000CA2 BF[7C5D]                		mov	di,CLASS_A_msg_tbl ; 14/11/2018 ; *
  4157 00000CA5 8C06[205D]              		mov	[$M_CLASS_A_ADDRS+2],es
  4158 00000CA9 893E[1E5D]              		mov	[$M_CLASS_A_ADDRS],di
  4159                                  		;call	_$M_CLS_B
  4160 00000CAD BF[8C5E]                		mov	di,CLASS_B_msg_tbl ; 14/11/2018
  4161 00000CB0 8C06[245D]              		mov	[$M_CLASS_B_ADDRS+2],es
  4162 00000CB4 893E[225D]              		mov	[$M_CLASS_B_ADDRS],di
  4163                                  
  4164 00000CB8 E82100                  		call	_$M_GET_DBCS_VEC
  4165 00000CBB E83100                  		call	_$M_CHECKSTDIN
  4166 00000CBE E84300                  		call	_$M_CHECKSTDOUT
  4167                                  
  4168                                  		;push	cx
  4169 00000CC1 E80100                  		call	_$M_VERSION_CHECK
  4170                                  		;jc	short $MIF20
  4171                                  		;pop	cx
  4172                                  		;pop	di
  4173                                  		;pop	es
  4174                                  		;pop	dx
  4175                                  		;pop	bx
  4176                                  		;pop	ax
  4177                                  		;;retf
  4178                                  
  4179 00000CC4 C3                      		retn	 
  4180                                  ;$MIF20:
  4181                                  		;add	sp,12
  4182                                  		;stc
  4183                                  		;;retf
  4184                                  		;retn
  4185                                  
  4186                                  ; msgserver.asm (MSDOS 6.0, 1991)
  4187                                  ; ----------------------------------------------------------------------------
  4188                                  ; 14/11/2018
  4189                                  
  4190                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  4191                                  ;;
  4192                                  ;;  Proc Name:	$M_VERSION_CHECK
  4193                                  ;;
  4194                                  ;;  Function:	Determine if DOS version is within allowable limits
  4195                                  ;;
  4196                                  ;;  Inputs:	None
  4197                                  ;;
  4198                                  ;;  Outputs:	CARRY_FLAG = 1 if Incorrect DOS version
  4199                                  ;;		Registers set for SYSDISPMSG
  4200                                  ;;		CARRY_FLAG = 0 if Correct DOS version
  4201                                  ;;
  4202                                  ;;  Regs Changed: AX
  4203                                  ;;
  4204                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  4205                                  
  4206                                  _$M_VERSION_CHECK:
  4207 00000CC5 B430                    		mov	ah,30h
  4208 00000CC7 CD21                    		int	21h ; DOS - GET DOS VERSION
  4209                                  			; Return: AL = major version number
  4210                                  			;		(00h for DOS 1.x)
  4211 00000CC9 3C05                    		cmp	al,5		; IF DOS_MAJOR is correct
  4212 00000CCB 7202                    		jb	short $MIF27
  4213 00000CCD F8                      		clc			; Clear the carry flag
  4214 00000CCE C3                      		retn
  4215                                  $MIF27:
  4216 00000CCF BB0200                  		mov	bx,2		; Standard Error			
  4217 00000CD2 B80100                  		mov	ax,1		; Set message # 1		
  4218                                  		;mov	cx,0 ; NO_REPLACE ; No replacable parms
  4219 00000CD5 31C9                    		xor	cx,cx
  4220                                  		;MOV	DL,NO_INPUT
  4221                                  	    	;MOV	DH,UTILITY_MSG_CLASS
  4222                                  					; No input	
  4223 00000CD7 BA00FF                  		mov	dx,0FF00h	; Utility class message
  4224 00000CDA F9                      		stc			; Set Carry Flag
  4225 00000CDB C3                      		retn			; Return
  4226                                  
  4227                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  4228                                  ;;
  4229                                  ;;  Proc Name:	$M_GET_DBCS_VEC
  4230                                  ;;
  4231                                  ;;  Function:	Get the DBCS vector and save it for later use
  4232                                  ;;
  4233                                  ;;  Inputs:	None
  4234                                  ;;
  4235                                  ;;  Outputs:	None
  4236                                  ;;
  4237                                  ;;  Regs Changed:
  4238                                  ;;
  4239                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  4240                                  
  4241                                  _$M_GET_DBCS_VEC:
  4242                                  		;push	ax	; Save registers
  4243                                  		;push	si
  4244 00000CDC 1E                      		push	ds ; *
  4245 00000CDD B80063                  		mov	ax,6300h ; DOS function to get DBSC environment	
  4246                                  				 ; Get environment pointer
  4247 00000CE0 CD21                    		int	21h	; DOS - 3.2+ only
  4248                                  			    	; GET DOUBLE BYTE CHARACTER SET LEAD TABLE
  4249                                  		;push	ds
  4250                                  		;pop	es
  4251 00000CE2 8CD8                    		mov	ax,ds
  4252 00000CE4 1F                      		pop	ds ; *
  4253 00000CE5 7207                    		jc	short $MIF23
  4254                                  
  4255 00000CE7 8936[2A5D]              		mov	[$M_DBCS_VEC],si    ; Save DBCS Vector
  4256                                  		;mov	[$M_DBCS_VEC+2],es
  4257 00000CEB A3[2C5D]                		mov	[$M_DBCS_VEC+2],ax
  4258                                  $MIF23:
  4259                                  		;pop	si	; restore registers
  4260                                  		;pop	ax
  4261 00000CEE C3                      		retn
  4262                                  
  4263                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  4264                                  ;;
  4265                                  ;;  Proc Name:	$M_CHECKSTDIN
  4266                                  ;;
  4267                                  ;;  Function:
  4268                                  ;;
  4269                                  ;;  Inputs:	None
  4270                                  ;;
  4271                                  ;;  Outputs:
  4272                                  ;;
  4273                                  ;;  Regs Changed:
  4274                                  ;;
  4275                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  4276                                  
  4277                                  _$M_CHECKSTDIN:
  4278 00000CEF B80044                  	mov	ax,4400h	; Get info using IOCTL
  4279                                  	;mov	bx,0  ; STDIN	 
  4280 00000CF2 29DB                    	sub	bx,bx ; STDIN = 0
  4281                                  	;cwd
  4282 00000CF4 31D2                    	xor	dx,dx ; 19/11/2018
  4283 00000CF6 CD21                    	int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
  4284                                  			; BX = file or device handle
  4285 00000CF8 80E601                  	and	dh,1		; clear top 7 bits
  4286 00000CFB 80CE01                  	or	dh,1 ; $M_CRIT_ERR_MASK	 ; Turn on bit
  4287 00000CFE B80144                  	mov	ax,4401h ; Set info using IOCTL
  4288 00000D01 CD21                    	int	21h	; DOS -	2+ - IOCTL - SET DEVICE	INFORMATION
  4289                                  			; BX = device handle, (DH = 0)
  4290                                  			; DL = device information to set 
  4291                                  			;	(bits 0-7 from	function 0)
  4292 00000D03 C3                      	retn
  4293                                  
  4294                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  4295                                  ;;
  4296                                  ;;  Proc Name:	$M_CHECKSTDOUT
  4297                                  ;;
  4298                                  ;;  Function:
  4299                                  ;;
  4300                                  ;;  Inputs:	None
  4301                                  ;;
  4302                                  ;;  Outputs:
  4303                                  ;;
  4304                                  ;;  Regs Changed:
  4305                                  ;;
  4306                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  4307                                  
  4308                                  _$M_CHECKSTDOUT:
  4309                                  
  4310 00000D04 B80044                  	mov	ax,4400h	; Get info using IOCTL
  4311 00000D07 BB0100                  	mov	bx,1  ; STDOUT	 
  4312                                  	;cwd
  4313 00000D0A 31D2                    	xor	dx,dx ; 19/11/2018
  4314 00000D0C CD21                    	int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
  4315                                  			; BX = file or device handle
  4316 00000D0E 80E601                  	and	dh,1		; clear top 7 bits
  4317 00000D11 80CE01                  	or	dh,1 ; $M_CRIT_ERR_MASK	 ; Turn on bit
  4318 00000D14 B80144                  	mov	ax,4401h ; Set info using IOCTL
  4319 00000D17 CD21                    	int	21h	; DOS -	2+ - IOCTL - SET DEVICE	INFORMATION
  4320                                  			; BX = device handle, (DH = 0)
  4321                                  			; DL = device information to set 
  4322                                  			;	(bits 0-7 from	function 0)
  4323 00000D19 C3                      	retn
  4324                                  		
  4325                                  ; messages.c (FDISK, MSDOS 6.0, 1991)
  4326                                  ; ----------------------------------------------------------------------------	
  4327                                  
  4328                                  ;/*  */
  4329                                  ;/*---------------------------------------------------------------------------*/
  4330                                  ;/*                                                                           */
  4331                                  ;/*    Subroutine Name: display_msg                                           */
  4332                                  ;/*                                                                           */
  4333                                  ;/*    Subroutine Function:                                                   */
  4334                                  ;/*       Display the requested message to the standard output device         */
  4335                                  ;/*                                                                           */
  4336                                  ;/*    Input:                                                                 */
  4337                                  ;/*        (1) Number of the message to be displayed (see FDISK.SKL)          */
  4338                                  ;/*        (2) Number of substitution parameters (%1,%2)                      */
  4339                                  ;/*        (3) Offset of sublist control block                                */
  4340                                  ;/*        (4) Message Class, 0=no input, 1=input via INT 21 AH=1             */
  4341                                  ;/*                                                                           */
  4342                                  ;/*    Output:                                                                */
  4343                                  ;/*        The message is written to the standard output device.  If input    */
  4344                                  ;/*        was requested, the character code of the key pressed is returned   */
  4345                                  ;/*        in regs.x.ax.                                                      */
  4346                                  ;/*                                                                           */
  4347                                  ;/*    Normal exit: Message written to handle                                 */
  4348                                  ;/*                                                                           */
  4349                                  ;/*    Error exit: None                                                       */
  4350                                  ;/*                                                                           */
  4351                                  ;/*    Internal References:                                                   */
  4352                                  ;/*              None                                                         */
  4353                                  ;/*                                                                           */
  4354                                  ;/*    External References:                                                   */
  4355                                  ;/*              Sysdispmsg (module _msgret.sal)                              */
  4356                                  ;/*                                                                           */
  4357                                  ;/*---------------------------------------------------------------------------*/
  4358                                  
  4359                                  ;void display_msg(msgnum,msghan,msgparms,msgsub,msginput,msgclass)
  4360                                  ;int   msgnum;                         /*;AN000; message number              */
  4361                                  ;int   msghan;                         /*;AN000; output device               */
  4362                                  ;int   msgparms;                       /*;AN000; number of substitution parms*/
  4363                                  ;int   *msgsub;                        /*;AN000; offset of sublist           */
  4364                                  ;char  msginput;                       /*;AN000; 0=no input, else input func */
  4365                                  ;char  msgclass;                       /*;AN014; 0=no input, else input func */
  4366                                  ;
  4367                                  ;BEGIN
  4368                                  ;	regs.x.ax = u(msgnum);             /*;AN000; set registers           */
  4369                                  ;	regs.x.bx = u(msghan);             /*;AN000;                         */
  4370                                  ;	regs.x.cx = u(msgparms);           /*;AN000;                         */
  4371                                  ;	regs.h.dh = uc(msgclass);          /*;AN014;                         */
  4372                                  ;	regs.h.dl = uc(msginput);          /*;AN000;                         */
  4373                                  ;	regs.x.si = u(msgsub);             /*;AN000;                         */
  4374                                  ;	sysdispmsg(&regs,&regs);           /*;AN000;  write the messages     */
  4375                                  ;
  4376                                  ;	return;                            /*;AN000;                         */
  4377                                  ;END
  4378                                  
  4379                                  display_msg:
  4380                                  
  4381                                  	%define msgnum	 bp+4
  4382                                  	%define	msghan	 bp+6
  4383                                  	%define	msgparms bp+8
  4384                                  	%define	msgsub	 bp+10
  4385                                  	%define	msginput bp+12
  4386                                  	%define	msgclass bp+14
  4387                                  
  4388 00000D1A 55                      		push	bp
  4389 00000D1B 89E5                    		mov	bp,sp
  4390                                  
  4391                                  		;mov	ax,[msgnum]
  4392                                  		;mov	[regs_x_ax],ax
  4393                                  		;mov	ax,[msghan]
  4394                                  		;mov	[regs_x_bx],ax
  4395                                  		;mov	ax,[msgparms]
  4396                                  		;mov	[regs_x_cx],ax
  4397                                  		;mov	al,[msgclass]
  4398                                  		;mov	[regs_x_dx+1],al
  4399                                  		;mov	al,[msginput]
  4400                                  		;mov	[regs_x_dx],al
  4401                                  		;mov	ax,[msgsub]
  4402                                  		;mov	[regs_x_si],ax
  4403                                  		;mov	ax,regs ; regs_x_ax
  4404                                  		;push	ax ; outregs
  4405                                  		;push	ax ; inregs
  4406                                  		;call	sysdispmsg
  4407                                  		;pop	bx
  4408                                  		;pop	bx
  4409                                  
  4410                                  		;mov	sp,bp
  4411                                  		;pop	bp
  4412                                  		;retn
  4413                                  
  4414 00000D1D 57                      		push	di ; *
  4415 00000D1E 56                      		push	si ; **
  4416                                  
  4417 00000D1F 8B4604                  		mov	ax,[msgnum] ; ***
  4418 00000D22 8B5E06                  		mov	bx,[msghan] ; ***	
  4419 00000D25 8B4E08                  		mov	cx,[msgparms] ; ***
  4420 00000D28 8A760E                  		mov	dh,[msgclass] ; ***
  4421 00000D2B 8A560C                  		mov	dl,[msginput] ; ***
  4422 00000D2E 8B760A                  		mov	si,[msgsub] ; ***
  4423                                  
  4424 00000D31 E8D900                  		call	SYSDISPMSG ; 13/11/2018 ; * ; ** ; ***
  4425                                  
  4426 00000D34 5E                      		pop	si ; **
  4427 00000D35 5F                      		pop	di ; *
  4428                                  		
  4429 00000D36 89EC                    		mov	sp,bp
  4430 00000D38 5D                      		pop	bp
  4431                                  		
  4432 00000D39 C3                      		retn
  4433                                  
  4434                                  ;sysdispmsg:
  4435                                  ;		call	_sysdispmsg
  4436                                  ;		retn
  4437                                  
  4438                                  ; _msgret.asm (MSDOS 6.0, 1991)
  4439                                  ; ----------------------------------------------------------------------------
  4440                                  
  4441                                  ;_sysdispmsg:
  4442                                  ;
  4443                                  ;	;%define inregs  bp+8
  4444                                  ;	;%define outregs bp+10
  4445                                  ;
  4446                                  ;		push	bp
  4447                                  ;		mov	bp,sp
  4448                                  ;		push	di
  4449                                  ;		push	si
  4450                                  ;		mov	di,[inregs]
  4451                                  ;		mov	ax,[di+10] ; regs.x.di
  4452                                  ;		push	ax
  4453                                  ;		mov	ax,[di]	   ; regs.x.ax	
  4454                                  ;		mov	bx,[di+2]  ; regs.x.bx	
  4455                                  ;		mov	cx,[di+4]  ; regs.x.cx	
  4456                                  ;		mov	dx,[di+6]  ; regs.x.dx	
  4457                                  ;		mov	si,[di+8]  ; regs.x.si	
  4458                                  ;		pop	di
  4459                                  ;		push	bp
  4460                                  ;		call	SYSDISPMSG ; far call -> near call
  4461                                  ;		pop	bp
  4462                                  ;		push	di
  4463                                  ;		mov	di,[outregs]
  4464                                  ;		mov	[di],ax	   ; regs.x.ax	
  4465                                  ;		mov	[di+2],bx  ; regs.x.bx
  4466                                  ;		mov	[di+4],cx  ; regs.x.cx		
  4467                                  ;		mov	[di+6],dx  ; regs.x.dx	
  4468                                  ;		mov	[di+8],si  ; regs.x.si		
  4469                                  ;		lahf
  4470                                  ;		mov	al,ah
  4471                                  ;		mov	[di+12],ax ; regs.x_cflag		
  4472                                  ;		pop	ax
  4473                                  ;		mov	[di+10],ax ; regs.x.di	
  4474                                  ;		pop	si
  4475                                  ;		pop	di
  4476                                  ;		mov	sp,bp
  4477                                  ;		pop	bp
  4478                                  ;		retf
  4479                                  
  4480                                  ;/*  */
  4481                                  ;/******************************************************************************/
  4482                                  ;/*Routine name:  GET_YES_NO_VALUES                                            */
  4483                                  ;/******************************************************************************/
  4484                                  ;/*                                                                            */
  4485                                  ;/*Description:   Uses SYSGETMSG to get the translated values for Y and N      */
  4486                                  ;/*               for display purposes.                                        */
  4487                                  ;/*                                                                            */
  4488                                  ;/*Called Procedures:    sysgetmsg                                             */
  4489                                  ;/*                      sysdispmsg                                            */
  4490                                  ;/*                                                                            */
  4491                                  ;/*Change History: Created        5/11/88         DRM                          */
  4492                                  ;/*                                                                            */
  4493                                  ;/*Input: None                                                                 */
  4494                                  ;/*                                                                            */
  4495                                  ;/*Output: None                                                                */
  4496                                  ;/*                                                                            */
  4497                                  ;/******************************************************************************/
  4498                                  
  4499                                  ;char get_yes_no_values()
  4500                                  
  4501                                  ;BEGIN
  4502                                  ;
  4503                                  ;char           message_flag;
  4504                                  ;char far       *msg_buff;
  4505                                  ;
  4506                                  ;     message_flag = c(TRUE);
  4507                                  ;
  4508                                  ;     /* do sysgetmsg for 'Y' */
  4509                                  ;     regs.x.ax = YesMsg;
  4510                                  ;     regs.h.dh = uc(utility_msg_class);
  4511                                  ;     sysgetmsg(&regs,&segregs,&regs);
  4512                                  ;
  4513                                  ;     FP_OFF(msg_buff) = regs.x.si;
  4514                                  ;     FP_SEG(msg_buff) = segregs.ds;
  4515                                  ;
  4516                                  ;     Yes = *msg_buff;
  4517                                  ;
  4518                                  ;     if ((regs.x.cflag & CARRY_FLAG) != CARRY_FLAG)  /* If msg load problem */
  4519                                  ;          BEGIN
  4520                                  ;          /* do sysgetmsg for 'N' */
  4521                                  ;          regs.x.ax = NoMsg;
  4522                                  ;          regs.h.dh = uc(utility_msg_class);
  4523                                  ;          sysgetmsg(&regs,&segregs,&regs);
  4524                                  ;
  4525                                  ;          FP_OFF(msg_buff) = regs.x.si;
  4526                                  ;          FP_SEG(msg_buff) = segregs.ds;
  4527                                  ;
  4528                                  ;          No = *msg_buff;
  4529                                  ;
  4530                                  ;          END
  4531                                  ;
  4532                                  ;     if ((regs.x.cflag & CARRY_FLAG) == CARRY_FLAG)  /* If msg load problem */
  4533                                  ;       BEGIN
  4534                                  ;        sysdispmsg(&regs,&regs);		/* write the error message */
  4535                                  ;        message_flag = FALSE;
  4536                                  ;       END
  4537                                  ;
  4538                                  ;     return(message_flag);
  4539                                  ;
  4540                                  ;END
  4541                                  
  4542                                  ;get_yes_no_values:
  4543                                  ;
  4544                                  ;		;YesMsg	equ 9
  4545                                  ;		;NoMsg	equ 10
  4546                                  ;
  4547                                  ;	%define message_flag bp-6 ; word
  4548                                  ;	%define _msg_buf     bp-4 ; dword
  4549                                  ;
  4550                                  ;		push	bp
  4551                                  ;		mov	bp,sp
  4552                                  ;		sub	sp,6
  4553                                  ;		mov	byte [message_flag],1
  4554                                  ;		mov	[regs_x_ax],9 ; YesMsg
  4555                                  ;		mov	byte [regs_x_dx+1],0FFh ; 255 ; UTILITY_MSG_CLASS
  4556                                  ;		mov	ax,regs ; regs_x_ax
  4557                                  ;		push	ax
  4558                                  ;		mov	cx,segregs ; segregs_es
  4559                                  ;		push	cx
  4560                                  ;		push	ax
  4561                                  ;		call	sysgetmsg
  4562                                  ;		add	sp,6
  4563                                  ;		mov	ax,[regs_x_si]
  4564                                  ;		mov	[_msg_buf],ax
  4565                                  ;		mov	ax,[segregs_ds]
  4566                                  ;		mov	[_msg_buf+2],ax
  4567                                  ;		les	bx,[_msg_buf]
  4568                                  ;		mov	al,[es:bx]
  4569                                  ;		mov	[Yes],al
  4570                                  ;		mov	al,[regs_x_cflag]
  4571                                  ;		and	al,1
  4572                                  ;		cmp	al,1
  4573                                  ;		je	short gynv_1 ; *
  4574                                  ;		mov	[regs_x_ax],10 ; NoMsg
  4575                                  ;		mov	byte [regs_x_dx+1],0FFh ; 255 ; UTILITY_MSG_CLASS
  4576                                  ;		mov	ax,regs ; regs_x_ax
  4577                                  ;		push	ax ; outregs
  4578                                  ;		mov	cx,segregs ; segregs_es
  4579                                  ;		push	cx
  4580                                  ;		push	ax ; inregs
  4581                                  ;		call	sysgetmsg
  4582                                  ;		add	sp,6
  4583                                  ;		mov	ax,[regs_x_si]
  4584                                  ;		mov	[_msg_buf],ax
  4585                                  ;		mov	ax,[segregs_ds]
  4586                                  ;		mov	[_msg_buf+2],ax
  4587                                  ;		les	bx,[_msg_buf]
  4588                                  ;		mov	al,[es:bx]
  4589                                  ;		mov	[No],al
  4590                                  ;;gynv_1:
  4591                                  ;		mov	al,[regs_x_cflag]
  4592                                  ;		and	al,1
  4593                                  ;		cmp	al,1
  4594                                  ;		jne	short gynv_2
  4595                                  ;gynv_1: ; 13/11/2018 ; *				
  4596                                  ;		mov	ax,regs ; regs_x_ax
  4597                                  ;		push	ax ; outregs
  4598                                  ;		push	ax ; inregs
  4599                                  ;		call	sysdispmsg
  4600                                  ;		pop	bx
  4601                                  ;		pop	bx
  4602                                  ;		mov	byte [message_flag],0
  4603                                  ;gynv_2:
  4604                                  ;		mov	al,[message_flag]
  4605                                  ;		mov	sp,bp
  4606                                  ;		pop	bp
  4607                                  ;		retn
  4608                                  
  4609                                  get_yes_no_values:
  4610                                  
  4611                                  		;YesMsg	equ 9
  4612                                  		;NoMsg	equ 10
  4613                                  
  4614                                  	;%define message_flag bp-6 ; word
  4615                                  	;%define _msg_buf     bp-4 ; dword
  4616                                  
  4617                                  		;push	bp
  4618                                  		;mov	bp,sp
  4619                                  		;sub	sp,6
  4620                                  		;mov	byte [message_flag],1
  4621                                  
  4622 00000D3A B80900                  		mov	ax,9 ; YesMsg
  4623 00000D3D B6FF                    		mov	dh,0FFh ; 255 ; UTILITY_MSG_CLASS
  4624 00000D3F E82500                  		call	SYSGETMSG
  4625 00000D42 7218                    		jc	short gynv_1
  4626                                  		
  4627                                  		;or	cx,cx
  4628                                  		;jz	short gynv_1
  4629                                  
  4630                                  		;; DS:SI = Message address
  4631                                  		;mov	al,[SI]
  4632                                  		;; ES:DI = Message address
  4633 00000D44 268A05                  		mov	al,[ES:DI]		
  4634 00000D47 A2[D9C3]                		mov	[Yes],al
  4635                                  
  4636 00000D4A B80A00                  		mov	ax,10 ; NoMsg
  4637 00000D4D B6FF                    		mov	dh,0FFh ; 255 ; UTILITY_MSG_CLASS
  4638 00000D4F E81500                  		call	SYSGETMSG
  4639 00000D52 7208                    		jc	short gynv_1
  4640                                  
  4641                                  		;or	cx,cx
  4642                                  		;jz	short gynv_1
  4643                                  
  4644                                  		;; DS:SI = Message address
  4645                                  		;mov	al,[SI]
  4646                                  		;; ES:DI = Message address
  4647 00000D54 268A05                  		mov	al,[ES:DI]		
  4648 00000D57 A2[ACA0]                		mov	[No],al
  4649 00000D5A EB0A                    		jmp	short gynv_2
  4650                                  gynv_1:
  4651                                  		; 14/11/2018
  4652 00000D5C C606[D9C3]59            		mov	byte [Yes],'Y'
  4653 00000D61 C606[ACA0]4E            		mov	byte [No],'N'
  4654                                  		
  4655                                  		;call	SYSDISPMSG
  4656                                  		;mov	byte [message_flag],0
  4657                                  gynv_2:
  4658                                  		;mov	al,[message_flag]
  4659                                  		;mov	sp,bp
  4660                                  		;pop	bp
  4661                                  
  4662 00000D66 C3                      		retn
  4663                                  
  4664                                  ;sysgetmsg:
  4665                                  ;		call	_sysgetmsg
  4666                                  ;		retn
  4667                                  
  4668                                  ; _msgret.asm (MSDOS 6.0, 1991)
  4669                                  ; ----------------------------------------------------------------------------
  4670                                  
  4671                                  ;_sysgetmsg:
  4672                                  ;
  4673                                  ;	%define inregs  bp+8
  4674                                  ;	%define _seg_	bp+10
  4675                                  ;	%define outregs bp+12
  4676                                  ;
  4677                                  ;		push	bp
  4678                                  ;		mov	bp,sp
  4679                                  ;		push	di
  4680                                  ;		push	si
  4681                                  ;		mov	di,[inregs] 
  4682                                  ;		mov	ax,[di+10] ; regs.x.di
  4683                                  ;		push	ax
  4684                                  ;		mov	ax,[di]	   ; regs.x.ax	
  4685                                  ;		mov	bx,[di+2]  ; regs.x.bx	
  4686                                  ;		mov	cx,[di+4]  ; regs.x.cx	
  4687                                  ;		mov	dx,[di+6]  ; regs.x.dx	
  4688                                  ;		mov	si,[di+8]  ; regs.x.si	
  4689                                  ;		pop	di
  4690                                  ;		push	bp
  4691                                  ;		call	SYSGETMSG  ; far call -> near call
  4692                                  ;		pop	bp
  4693                                  ;		push	di
  4694                                  ;		mov	di,[_seg_] ; segregs
  4695                                  ;		;push	ax
  4696                                  ;		mov	[di],es	   ; segregs_es	
  4697                                  ;		mov	[di+6],ds  ; segregs_ds	
  4698                                  ;		;pop	ax
  4699                                  ;		pop	di
  4700                                  ;		push	di
  4701                                  ;		mov	di,[outregs]
  4702                                  ;		mov	[di],ax	   ; regs.x.ax	
  4703                                  ;		mov	[di+2],bx  ; regs.x.bx
  4704                                  ;		mov	[di+4],cx  ; regs.x.cx		
  4705                                  ;		mov	[di+6],dx  ; regs.x.dx	
  4706                                  ;		mov	[di+8],si  ; regs.x.si	
  4707                                  ;		lahf
  4708                                  ;		mov	al,ah
  4709                                  ;		mov	[di+12],ax ; regs.x_cflag
  4710                                  ;		pop	ax
  4711                                  ;		mov	[di+10],ax ; regs.x.di	
  4712                                  ;		pop	si
  4713                                  ;		pop	di
  4714                                  ;		mov	sp,bp
  4715                                  ;		pop	bp
  4716                                  ;		retf
  4717                                  
  4718                                  ; msgserv.asm (MSDOS 6.0, 1991)	
  4719                                  ; ----------------------------------------------------------------------------
  4720                                  
  4721                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  4722                                  ;;
  4723                                  ;;  Proc Name:	SYSGETMSG
  4724                                  ;;
  4725                                  ;;  Function:	The GET service returns the segment, offset and size of the
  4726                                  ;;		message text to the caller based on a message number.
  4727                                  ;;		The GET function will not display the message thus assumes
  4728                                  ;;		caller will handle replaceable parameters.
  4729                                  ;;
  4730                                  ;;  Inputs:
  4731                                  ;;
  4732                                  ;;  Outputs:
  4733                                  ;;
  4734                                  ;;  Psuedocode:
  4735                                  ;;		Call $M_GET_MSG_ADDRESS
  4736                                  ;;		IF MSG_NUM exists THEN
  4737                                  ;;		   Set DS:SI = MSG_TXT_PTR + 1
  4738                                  ;;		   CARRY_FLAG = 0
  4739                                  ;;		ELSE
  4740                                  ;;		   CARRY_FLAG = 1
  4741                                  ;;		ENDIF
  4742                                  ;;
  4743                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  4744                                  
  4745                                  SYSGETMSG:
  4746                                  		;push	ax		; Save changed regs
  4747                                  		;push	es
  4748                                  		;push	di
  4749                                  
  4750 00000D67 55                      		push	bp
  4751                                  
  4752 00000D68 E8CE00                  		call	_$M_GET_MSG_ADDRESS ; Scan thru classes to find message
  4753                                  		;jc	short $MIF31
  4754                                  
  4755 00000D6B 83F901                  		cmp	cx,1 ; 13/11/2018
  4756                                  					; Return message in ES:DI
  4757                                  		;;cmp	dh,0FFh ; UTILITY_MSG_CLASS
  4758                                  		;;clc
  4759                                  		;;je	short $MIF32
  4760                                  		;;push	es
  4761                                  		;;pop	ds
  4762                                  		;;jmp	short $MEN32
  4763                                  $MIF32:
  4764                                  		;push	es
  4765                                  		;pop	ds
  4766                                  $MEN32:
  4767                                  		;mov	si,di		; Return message in DS:SI	
  4768                                  $MIF31:
  4769 00000D6E 5D                      		pop	bp		; Restore changed regs
  4770                                  
  4771                                  		;pop	di
  4772                                  		;pop	es
  4773                                  		;pop	ax
  4774                                  		;retf
  4775                                  
  4776 00000D6F C3                      		retn ; 13/11/2018
  4777                                  
  4778                                  ; ----------------------------------------------------------------------------
  4779                                  ; fdparse.c (FDISK, MSDOS 6.0, 1991)	
  4780                                  ; ----------------------------------------------------------------------------
  4781                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 11/11/2018)
  4782                                  
  4783                                  ;/*  */
  4784                                  ;/******************************************************************************/
  4785                                  ;/*Routine name:  CHECK_DISK_VALIDITY                                          */
  4786                                  ;/******************************************************************************/
  4787                                  ;/*                                                                            */
  4788                                  ;/*Description:   Checks the return buffer from parse for the positional       */
  4789                                  ;/*               value to be equal to 0 or 1.                                 */
  4790                                  ;/*                                                                            */
  4791                                  ;/*Called Procedures:                                                          */
  4792                                  ;/*                                                                            */
  4793                                  ;/*Change History: Created        6/18/87         DRM                          */
  4794                                  ;/*                                                                            */
  4795                                  ;/*Input: None                                                                 */
  4796                                  ;/*                                                                            */
  4797                                  ;/*Output: None                                                                */
  4798                                  ;/*                                                                            */
  4799                                  ;/******************************************************************************/
  4800                                  
  4801                                  ;void check_disk_validity()
  4802                                  
  4803                                  ;BEGIN
  4804                                  ;	disk_flag = (FLAG)TRUE;
  4805                                  ;       cur_disk_buff = ((char)p_buff.p_value - 1);
  4806                                  ;       return;
  4807                                  ;END    
  4808                                  
  4809                                  check_disk_validity:
  4810 00000D70 C606[A4A0]01            		mov	byte [disk_flag],1
  4811 00000D75 A0[E8CB]                		mov	al,[p_buff_p_value]
  4812 00000D78 FEC8                    		dec	al
  4813 00000D7A A2[1DC4]                		mov	[cur_disk_buff],al
  4814 00000D7D C3                      		retn
  4815                                  
  4816                                  ;/*  */
  4817                                  ;/******************************************************************************/
  4818                                  ;/*Routine name:  PROCESS_SWITCH                                               */
  4819                                  ;/******************************************************************************/
  4820                                  ;/*                                                                            */
  4821                                  ;/*Description:   This function looks at the return buffer of the parse and    */
  4822                                  ;/*               determins the switch, places value in buffer, and sets       */
  4823                                  ;/*               flag for specific switch.                                    */
  4824                                  ;/*                                                                            */
  4825                                  ;/*Called Procedures:                                                          */
  4826                                  ;/*                                                                            */
  4827                                  ;/*Change History: Created        6/18/87         DRM                          */
  4828                                  ;/*                                                                            */
  4829                                  ;/*Input: None                                                                 */
  4830                                  ;/*                                                                            */
  4831                                  ;/*Output: None                                                                */
  4832                                  ;/*                                                                            */
  4833                                  ;/******************************************************************************/
  4834                                  
  4835                                  ;void process_switch()
  4836                                  
  4837                                  process_switch:
  4838 00000D7E A1[E4CC]                		mov	ax,[sp_buff_p_synonym] ; 11/11/2018
  4839 00000D81 B101                    		mov	cl,1 ; TRUE
  4840                                  
  4841                                  	; if (sp_buff.p_synonym == (unsigned)p_swi1.sp_switch1)
  4842                                          ;    BEGIN
  4843                                          ;     primary_flag = (FLAG)TRUE;
  4844                                          ;     primary_buff = (unsigned)sp_buff.p_value;
  4845                                          ;    END
  4846                                  
  4847                                  		;cmp	word [sp_buff_p_synonym],p_swi1_sp_switch1
  4848 00000D83 3D[FFA0]                		cmp	ax,p_swi1_sp_switch1
  4849 00000D86 750A                    		jne	short psw1
  4850                                  		;mov	byte [primary_flag],1
  4851 00000D88 880E[0EA1]              		mov	[primary_flag],cl
  4852 00000D8C A1[E6CC]                		mov	ax,[sp_buff_p_value]
  4853 00000D8F A3[DEC3]                		mov	[primary_buff],ax
  4854                                  psw1:
  4855                                  
  4856                                  	; if (sp_buff.p_synonym == (unsigned)p_swi1.sp_switch2)
  4857                                          ;    BEGIN
  4858                                          ;     extended_flag = (FLAG)TRUE;
  4859                                          ;     extended_buff = (unsigned)sp_buff.p_value;
  4860                                          ;    END               
  4861                                  
  4862                                  		;cmp	word [sp_buff_p_synonym],p_swi1_sp_switch2
  4863 00000D92 3D[04A1]                		cmp	ax,p_swi1_sp_switch2
  4864 00000D95 750A                    		jne	short psw2
  4865                                  		;mov	byte [extended_flag],1
  4866 00000D97 880E[E4C3]              		mov	[extended_flag],cl
  4867 00000D9B A1[E6CC]                		mov	ax,[sp_buff_p_value]
  4868 00000D9E A3[DAC3]                		mov	[extended_buff],ax
  4869                                  psw2:
  4870                                  		;cmp	word [sp_buff_p_synonym],p_swi1_sp_switch3
  4871 00000DA1 3D[09A1]                		cmp	ax,p_swi1_sp_switch3
  4872 00000DA4 750A                    		jne	short psw3
  4873                                  		;mov	byte [logical_flag],1
  4874 00000DA6 880E[E1C3]              		mov	[logical_flag],cl
  4875 00000DAA A1[E6CC]                		mov	ax,[sp_buff_p_value]
  4876 00000DAD A3[E0CB]                		mov	[logical_buff],ax
  4877                                  psw3:
  4878                                  		;cmp	word [sp_buff_p_synonym],p_swi2_sp_switch4
  4879 00000DB0 3D[19A1]                		cmp	ax,p_swi2_sp_switch4
  4880 00000DB3 7504                    		jne	short psw4
  4881                                  		;mov	byte [quiet_flag],1
  4882 00000DB5 880E[4EA1]              		mov	[quiet_flag],cl
  4883                                  psw4:
  4884                                  		;cmp	word [sp_buff_p_synonym],p_swi3_sp_switch5
  4885 00000DB9 3D[25A1]                		cmp	ax,p_swi3_sp_switch5
  4886 00000DBC 7504                    		jne	short psw5
  4887                                  		;mov	byte [status_flag],1
  4888 00000DBE 880E[E2C3]              		mov	[status_flag],cl
  4889                                  psw5:
  4890                                  		;cmp	word [sp_buff_p_synonym],p_swi4_sp_switch6
  4891 00000DC2 3D[39A1]                		cmp	ax,p_swi4_sp_switch6
  4892 00000DC5 7508                    		jne	short psw6
  4893 00000DC7 E80F00                  		call	DisplayOptionsExit ; Print options then exit
  4894                                  		; 16/11/2018
  4895 00000DCA 29C0                    		sub	ax,ax ; sub al,al
  4896 00000DCC E999F2                  		jmp	_exit
  4897                                  psw6:
  4898                                  
  4899                                  	; if (sp_buff.p_synonym == (unsigned)p_swi5.sp_switch7)
  4900                                          ;    BEGIN
  4901                                          ;     mbr_flag = (FLAG)TRUE;
  4902                                          ;    END
  4903                                  
  4904                                  		;cmp	word [sp_buff_p_synonym],p_swi5_sp_switch7
  4905 00000DCF 3D[47A1]                		cmp	ax,p_swi5_sp_switch7
  4906 00000DD2 7504                    		jne	short psw7
  4907                                  		;mov	byte [mbr_flag],1
  4908 00000DD4 880E[3CA1]              		mov	[mbr_flag],cl
  4909                                  psw7:
  4910 00000DD8 C3                      		retn
  4911                                  
  4912                                  ; 12/11/2018
  4913                                  
  4914                                  ;/************************************************************************/ 
  4915                                  ;/* DisplayOptionsExit           - Displays the options help message     */
  4916                                  ;/*                                lines onto standard output, and then  */
  4917                                  ;/*                                exits the program so the user can     */
  4918                                  ;/*                                retry the command.                    */
  4919                                  ;/*                                                                      */
  4920                                  ;/*      Inputs  : MSG_OPTIONS_FIRST - #defined with the number of the   */
  4921                                  ;/*                                    first message line to output.     */
  4922                                  ;/*                MSG_OPTIONS_LAST  - #defined with the number of the   */
  4923                                  ;/*                                    last message line to output.      */
  4924                                  ;/*                                                                      */
  4925                                  ;/*      Outputs : Options help lines as defined in FDISK.SKL            */
  4926                                  ;/*                Exits to DOS                                          */
  4927                                  ;/*                                                                      */
  4928                                  ;/*      Date    : 04/23/90  c-PaulB                                     */
  4929                                  ;/*      Version : DOS 5.00                                              */
  4930                                  ;/************************************************************************/
  4931                                  
  4932                                  ;void DisplayOptionsExit()
  4933                                  
  4934                                  ;BEGIN
  4935                                  ;	int	iMsgNbr;
  4936                                  ;
  4937                                  ;	/*
  4938                                  ;	 * Display each of the options message lines.
  4939                                  ;	 * Parse_message can't be used because it tries to display
  4940                                  ;	 * the text of an offending command.
  4941                                  ;	 */
  4942                                  ;
  4943                                  ;	for (iMsgNbr = MSG_OPTIONS_FIRST;     /* defined in parse.h */
  4944                                  ;		iMsgNbr <= MSG_OPTIONS_LAST;
  4945                                  ;		iMsgNbr++)
  4946                                  ;	BEGIN
  4947                                  ;	regs.x.ax = iMsgNbr;             /* message #     */
  4948                                  ;       regs.x.bx = STDOUT;              /* output handle */
  4949                                  ;       regs.x.cx = SUBCNT0;             /* # of subs     */
  4950                                  ;       regs.h.dl = No_Input;            /* input flag    */
  4951                                  ;       regs.h.dh = UTILITY_MSG_CLASS;   /* message class */
  4952                                  ;       regs.x.si = 0;                   /* sub list ptr  */
  4953                                  ;       sysdispmsg(&regs,&regs);
  4954                                  ;	END
  4955                                  ;
  4956                                  ;	/*
  4957                                  ;	 * Exit the program so the user can retry the command.
  4958                                  ;	 */
  4959                                  ;
  4960                                  ;	exit(ERR_LEVEL_0);
  4961                                  ;
  4962                                  ;END
  4963                                  
  4964                                  DisplayOptionsExit:
  4965                                  		; 14/11/2018 - Temporary
  4966 00000DD9 803E[4EA1]00            		cmp	byte [quiet_flag],0
  4967 00000DDE 7605                    		jna	short DisplayOptions
  4968                                  
  4969 00000DE0 E80A4F                  		call	print_fdisk_program_msg
  4970 00000DE3 EB27                    		jmp	short DisplayOptions_exit
  4971                                  	
  4972                                  DisplayOptions:
  4973                                  		MSG_OPTIONS_FIRST equ 300
  4974                                  		MSG_OPTIONS_LAST  equ 302
  4975                                  		
  4976                                  		;STDOUT	 equ 1
  4977                                  		;SUBCNT0 equ 0	
  4978                                  		;No_Input equ 0
  4979                                  		;UTILITY_MSG_CLASS equ 0FFh
  4980                                  	
  4981                                  		%define iMsgNbr bp-2
  4982                                  
  4983                                  		;push	bp
  4984 00000DE5 89E5                    		mov	bp,sp
  4985 00000DE7 83EC02                  		sub	sp,2
  4986 00000DEA C746FE2C01              		mov	word [iMsgNbr],MSG_OPTIONS_FIRST ; 300
  4987                                  displaynextopsrow:
  4988 00000DEF 8B46FE                  		mov	ax,[iMsgNbr]		    ; /* message # */
  4989                                  		;mov	[regs_x_ax],ax
  4990                                  		;mov	word [regs_x_bx],1
  4991 00000DF2 BB0100                  		mov	bx,1  ; STDOUT		    ; /* output handle */
  4992                                  		;mov	word [regs_x_cx],0
  4993 00000DF5 29C9                    		sub	cx,cx	; 0 ; SUBCNT0	    ; /* # of subs */
  4994                                  		;mov	byte [regs_x_dx],0
  4995 00000DF7 28D2                    		sub	dl,dl ; 0 ; No_Input 	    ; /* input flag */
  4996                                  		;mov	byte [regs_x_dx+1],0FFh
  4997 00000DF9 B6FF                    		mov	dh,0FFh ; UTILITY_MSG_CLASS ; /* message class */
  4998                                  		;mov	word [regs_x_si],0
  4999 00000DFB 29F6                    		sub	si,si ; 0		    ; /* sub list ptr */
  5000                                  		
  5001                                  		;mov	ax,[regs_x_ax]
  5002                                  		;push	ax ; outregs
  5003                                  		;push	ax ; inregs
  5004                                  		;call	sysdispmsg
  5005                                  		;pop	bx
  5006                                  		;pop	bx
  5007                                  
  5008 00000DFD E80D00                  		call	SYSDISPMSG  ; (msgserv.asm, MSDOS 6.0, 1991)
  5009                                  		
  5010 00000E00 FF46FE                  		inc	word [iMsgNbr]
  5011 00000E03 817EFE2E01              		cmp	word [iMsgNbr],MSG_OPTIONS_LAST ; 302
  5012 00000E08 7EE5                    		jle	short displaynextopsrow
  5013                                  		
  5014                                  		;sub	ax,ax
  5015                                  		;push	ax
  5016                                  		;call	_exit
  5017                                  		;pop	bx
  5018                                  
  5019 00000E0A 89EC                    		mov	sp,bp
  5020                                  		;pop	bp
  5021                                  DisplayOptions_exit:	; 16/11/2018
  5022 00000E0C C3                      		retn
  5023                                  ;DisplayOptions_exit:
  5024                                  ;		sub	ax,ax
  5025                                  ;		jmp	_exit
  5026                                  
  5027                                  ; ----------------------------------------------------------------------------
  5028                                  ; msgserv.asm (MSDOS 6.0, 1991)	
  5029                                  ; ----------------------------------------------------------------------------
  5030                                  ; Modified and simplified for NASM (by Erdogan Tan, 12/11/2018)
  5031                                  
  5032                                  ; sysmsg.inc (MSDOS 6.0, 1991)
  5033                                  ; ----------------------------------------------------------------------------
  5034                                  
  5035                                  ; SYSDISPMSG and SYSGETMSG Equates
  5036                                  
  5037                                  FALSE	equ 0		  ;;
  5038                                  TRUE	equ 1 ; NOT FALSE ;;    List message services and flags
  5039                                  
  5040                                  ; Control Characters For Message Skeleton file
  5041                                  
  5042                                  NULL			EQU	00H    ;; Null
  5043                                  BELL			EQU	07H    ;; Bell
  5044                                  TAB			EQU	09H    ;; Tab
  5045                                  LF			EQU	0AH    ;; Line Feed
  5046                                  HOME			EQU	0BH    ;; Home
  5047                                  FORMFD			EQU	0CH    ;; Form Feed
  5048                                  CR			EQU	0DH    ;; Carriage Return
  5049                                  COLON			EQU	3AH    ;; Colon
  5050                                  
  5051                                  MSG_SER_CLASS		EQU	00H    ;; Message Service Class (reserved)
  5052                                  EXT_ERR_CLASS		EQU	01H    ;; DOS Extended error class
  5053                                  PARSE_ERR_CLASS 	EQU	02H    ;; Parse error class
  5054                                  UTILITY_MSG_CLASS	EQU	0FFH   ;; Utility message class
  5055                                  
  5056                                  NO_HANDLE		EQU	0FFFFH ;; No handle specified
  5057                                  				       ;; (Use DOS functions 01H-09H only)
  5058                                  
  5059                                  NO_REPLACE		EQU	0000H  ;; No replacable parameters
  5060                                  
  5061                                  
  5062                                  ; SUBLIST Equates
  5063                                  
  5064                                    Sublist_Length	EQU	11     ;; Length of sublist structure
  5065                                    Reserved		EQU	0      ;; Reserved byte field
  5066                                  
  5067                                    Left_Align		EQU	0      ;;00xxxxxx
  5068                                    Right_Align		EQU	80h    ;;10xxxxxx
  5069                                  
  5070                                    Char_type		EQU	0      ;;axxx0000 - Character type
  5071                                    Char_Field_Char	EQU	0      ;;a0000000
  5072                                    Char_Field_ASCIIZ	EQU	10h    ;;a0010000
  5073                                  
  5074                                    Unsgn_Bin_Type	EQU	01h    ;;axxx0001 - Unsigned Binary to Decimal character
  5075                                    Unsgn_Bin_Byte	EQU	11h    ;;a0010001
  5076                                    Unsgn_Bin_Word	EQU	21h    ;;a0100001
  5077                                    Unsgn_Bin_DWord	EQU	31h    ;;a0110001
  5078                                  
  5079                                    Sgn_Bin_Type		EQU	02h    ;;axxx0010 - Signed Binary to Decimal character
  5080                                    Sgn_Bin_Byte		EQU	12h    ;;a0010010
  5081                                    Sgn_Bin_Word		EQU	22h    ;;a0100010
  5082                                    Sgn_Bin_DWord 	EQU	32h    ;;a0110010
  5083                                  
  5084                                    Bin_Hex_Type		EQU	03h    ;;axxx0011 - Unsigned Binary to Hexidecimal character
  5085                                    Bin_Hex_Byte		EQU	13h    ;;a0010011
  5086                                    Bin_Hex_Word		EQU	23h    ;;a0100011
  5087                                    Bin_Hex_DWord 	EQU	33h    ;;a0110011
  5088                                  
  5089                                    Date_Type		EQU	04h    ;;axxx0100 - Date to character using current country format
  5090                                    Date_MD		EQU	14h    ;;a0010100
  5091                                    Date_MDY_2		EQU	24h    ;;a0100100
  5092                                    Date_MDY_4		EQU	34h    ;;a0110100
  5093                                  
  5094                                    Time_Cty_Type 	EQU	05h    ;;axxx0101 - Time to character using current country format
  5095                                    Time_HHMM_Cty 	EQU	05h    ;;a0000101
  5096                                    Time_HHMMSS_Cty	EQU	15h    ;;a0010101
  5097                                    Time_HHMMSSHH_Cty	EQU	25h    ;;a0100101
  5098                                  
  5099                                    Time_24_Type		EQU	06h    ;;axxx0110 - Time to character using 24 hour format
  5100                                    Time_HHMM_24		EQU	06h    ;;a0000110
  5101                                    Time_HHMMSS_24	EQU	16h    ;;a0010110
  5102                                    Time_HHMMSSHH_24	EQU	26h    ;;a0100110
  5103                                  
  5104                                    $M_EXTPAR_Type	EQU	08h    ;;axxx1000 - Special case for extended parse replace format
  5105                                  
  5106                                  NO_INPUT		EQU	00H    ;; No input characters
  5107                                  DOS_KEYB_INP		EQU	01H    ;; DOS INT 21H - AH=01H := Keyboard Input
  5108                                  DOS_DIR_CON_INP 	EQU	07H    ;; DOS INT 21H - AH=07H := Direct Console Input Without Echo
  5109                                  DOS_CON_INP		EQU	08H    ;; DOS INT 21H - AH=08H := Console Input Without Echo (Check CTL-BK)
  5110                                  DOS_BUF_KEYB_INP	EQU	0AH    ;; DOS INT 21H - AH=0AH := Buffered Keyboard Input
  5111                                  DOS_CLR_KEYB_BUF	EQU	0CH    ;; DOS INT 21H - AH=0CH := Clear keyboard buffer
  5112                                  DOS_WRITE_HANDLE	EQU	40H    ;; DOS INT 21H - AH=40H := Write to a DOS handle
  5113                                  DOS_DISP_STRING 	EQU	09H    ;; DOS INT 21H - AH=09H := Display $ terminated string
  5114                                  DOS_DISP_CHAR		EQU	02H    ;; DOS INT 21H - AH=02H := Display Character
  5115                                  LOWEST_4CH_VERSION	EQU	0002H  ;; First DOS version to allow AH = 4CH Exit (VERSION 2.00)
  5116                                  
  5117                                  DOS_GET_DBCS_INFO	EQU   6300H    ;; DOS INT 21H - AX=6507H := Get DBCS Vector Table
  5118                                  DOS_GET_EXT_ERROR	EQU	59H    ;; DOS INT 21H - AH=59H := Get Extended Error
  5119                                  DOS_GET_EXT_ERROR_BX	EQU	00H    ;; DOS INT 21H - BX=0000H := Version 0
  5120                                  
  5121                                  DOS_EXTENDED_OPEN	EQU   6C00H    ;AN003; DOS INT 21H - AX=6C00H := Extended Open
  5122                                  NO_CRIT_OPEN		EQU   2000H    ;AN003; Extended Open Mode bit
  5123                                  NOT_EX_FAIL_EX_OPEN	EQU   0101H    ;AN003; Extended Open Flag
  5124                                  DOS_LSEEK_FILE		EQU   4200H    ;AN003; DOS INT 21H - AX=4200H := LSEEK file
  5125                                  DOS_READ_BYTE		EQU	3FH    ;AN003; DOS INT 21H - AH=3FH   := Read byte block
  5126                                  DOS_CLOSE_FILE		EQU	3EH    ;AN003; DOS INT 21H - AH=3EH   := Close file handle
  5127                                  
  5128                                  IFSFUNC_INSTALL_CHECK	EQU   0500H    ;AN006; IFSFUNC Installation Check
  5129                                  IFS_GET_ERR_TEXT	EQU   0502H    ;AN006; IFSFUNC Get Extended Error Text
  5130                                  IFSFUNC_INSTALLED	EQU    0FFH    ;AN006; Return code if IFSFUNC is installed
  5131                                  
  5132                                  EXT_ERR_39		EQU	39     ;; Insufficent Disk Space EXTENDED ERROR (changed from hex to decimal - eg d201)
  5133                                  ERROR_CLASS_39		EQU	01H    ;;   Error Class = 1
  5134                                  ACTION_39		EQU	04H    ;;   Suggested Action = 4
  5135                                  LOCUS_39		EQU	01H    ;;   Locus = 1
  5136                                  
  5137                                  DOS_GET_COUNTRY 	EQU	38H    ;; DOS INT 21H - AH=38H := Get Country Dependant Information
  5138                                  DOS_GET_VERSION 	EQU	30H    ;; DOS INT 21H - AH=30H := Get DOS Version number
  5139                                  DOS_IOCTL_GET_INFO	EQU	4400H  ;; DOS INT 21H - AH=4400H := I/O control for devices
  5140                                  DOS_IOCTL_SET_INFO	EQU	4401H  ;; DOS INT 21H - AH=4401H := I/O control for devices
  5141                                  DOS_GET_EXT_PARSE_ADD	EQU	122EH  ;; DOS INT 2FH - AX=122EH := Get Extended/Parse error address
  5142                                  DOS_GET_EXTENDED	EQU	00     ;; DOS INT 2FH - AX=122EH - DL=00 := Get Extended address
  5143                                  DOS_GET_PARSE		EQU	02     ;; DOS INT 2FH - AX=122EH - DL=02 := Get Parse address
  5144                                  DOS_GET_CRITICAL	EQU	04     ;; DOS INT 2FH - AX=122EH - DL=04 := Get Critical address
  5145                                  DOS_GET_FILE		EQU	06     ;; DOS INT 2FH - AX=122EH - DL=06 := Get File system dependant
  5146                                  DOS_GET_ADDR		EQU	08     ;; DOS INT 2FH - AX=122EH - DL=08 := Get Address of READ_DISK_PROC
  5147                                  DOS_SET_ADDR		EQU	09     ;; DOS INT 2FH - AX=122EH - DL=09 := Set Address of READ_DISK_PROC
  5148                                  LOW_NIB_MASK		EQU	0FH    ;; Mask out the high byte
  5149                                  DOS_CLR_KEYB_BUF_MASK	EQU	0C0H   ;; Check if high nibble is C Hex
  5150                                  $M_CON_INP		EQU	-1     ;; If DOS INT 21H Function 06H - DL := 0FFH for input
  5151                                  $M_CRIT_LO		EQU	19     ;; First Extended Error considered CRITICAL
  5152                                  $M_CRIT_HI		EQU	39     ;; Last Extended Error considered CRITICAL (EG - D191)
  5153                                  $M_AM			EQU	"a"    ;; Time format AM indicator
  5154                                  $M_PM			EQU	"p"    ;; Time format PM indicator
  5155                                  $M_NEG_SIGN		EQU	"-"    ;; Signed decimal number format negative indicator
  5156                                  $M_DEF_TIME_FORM	EQU	 1     ;; Default Time format - 24 hour
  5157                                  $M_DEF_DATE_FORM	EQU	 0     ;; Default Time format - 0 := USA format
  5158                                  $M_DEF_TIME_SEP 	EQU	":"    ;; Default Time separator - ":"
  5159                                  $M_DEF_DATE_SEP 	EQU	"-"    ;; Default Time separator - "-"
  5160                                  $M_DEF_DECI_SEP 	EQU	"."    ;; Default Time hundreds separator - "."
  5161                                  $M_TIMEDATE_PAD 	EQU	"0"    ;; Time/Date PAD character - "0" (ie 12:03p)
  5162                                  $M_MAX_2_YEAR		EQU	99     ;; Maximum 2 digit year
  5163                                  $M_SINGLE_CHAR		EQU	1      ;; A single character is this long      ^
  5164                                  $M_SPECIAL_CASE 	EQU	30H    ;; Special case for replacable parameters %0
  5165                                  $M_UNLIM_W		EQU	0      ;; Unlimited width character
  5166                                  $M_COMMA		EQU	","    ;; Default Thousand separate
  5167                                  $M_CR_LF		EQU	0A0DH  ;; Default CR/LF
  5168                                  $M_SPACE_HYP		EQU	"- "   ;; Default Space/Hyphan
  5169                                  $M_SPACE		EQU	" "    ;; Default Space
  5170                                  $M_NULL 		EQU	0      ;; Null
  5171                                  $M_FIRST_THOU		EQU	3      ;; Location of first thousand separator
  5172                                  $M_SECOND_THOU		EQU	6      ;; Location of second thousand separator
  5173                                  $M_THIRD_THOU		EQU	9      ;; Location of third thousand separator
  5174                                  $M_BASE10		EQU	10     ;; Base 10 for arthmetic
  5175                                  $M_BASE16		EQU	16     ;; Base 16 for arthmetic
  5176                                  $M_CLASS_NOT_EXIST	EQU	 0     ;; Does class exist?
  5177                                  $M_TERMINATING_FLAG	EQU	-1     ;; Is there any more classes?
  5178                                  $M_ADDR_SZ_NEAR 	EQU	2      ;; Size to increment if NEAR
  5179                                  $M_ADDR_SZ_FAR		EQU	4      ;; Size to increment if FAR
  5180                                  ;$M_SL			EQU   DS:[SI]  ;; Refer to SUBLIST as $M_SL
  5181                                  %define	$M_SL [SI] ; 13/11/2018	
  5182                                  $M_NO_HANDLE		EQU	-1     ;; No handle flag
  5183                                  $M_TEMP_BUF_SZ		EQU	64     ;; Size of temporary buffer	 ;AN003;
  5184                                  $M_NEXT_DBCS_VECTOR	EQU	2      ;; Amount to increment to get next vector
  5185                                  $M_DBCS_TERM		EQU    0000    ;; DBCS vector table terminating flag
  5186                                  $M_SPECIAL_MSG_NUM	EQU    0FFFFH  ;; Special generic message number
  5187                                  $M_CRLF_SIZE		EQU    2       ;; Size of the CR LF message
  5188                                  $M_NO_CRLF_MASK 	EQU  10000000B ;; Mask to supress CR LF
  5189                                  $M_ONE_REPLACE		EQU    1       ;; Indicate one replacement
  5190                                  $M_CRIT_ERR_MASK	EQU  00000001B ;; Mask to allow EOF/EOI Crit error
  5191                                  				       ;;
  5192                                  $M_ALIGN_MASK		EQU  10000000b ;; Mask for align
  5193                                  $M_TYPE_MASK		EQU  00001111b ;; Mask for types
  5194                                  $M_SIZE_MASK		EQU  00110000b ;; Mask for types
  5195                                  $M_TIME_MASK		EQU  00000001b ;; Mask for TIME
  5196                                  $M_DATE_MASK		EQU  00010000b ;; Mask for TIME
  5197                                  $M_BYTE 		EQU  00010000b ;; BYTE indicator
  5198                                  $M_WORD 		EQU  00100000b ;; WORD indicator
  5199                                  $M_DWORD		EQU  00110000b ;; DWORD indicator
  5200                                  
  5201                                  ; Standard reserved DOS handles
  5202                                  
  5203                                  _STDIN			EQU	0000H  ;; Standard Input device handle
  5204                                  _STDOUT			EQU	0001H  ;; Standard Output device handle
  5205                                  _STDERR			EQU	0002H  ;; Standard Error Output device handle
  5206                                  _STDAUX			EQU	0003H  ;; Standard Auxiliary device handle
  5207                                  _STDPRN			EQU	0004H  ;; Standard Printer device handle
  5208                                  
  5209                                  ; msghan.inc (MSDOS 6.0, 1991)
  5210                                  ; ----------------------------------------------------------------------------
  5211                                  
  5212                                  ; VALUES FOR THE MSG_DESC CONTROL BLOCK
  5213                                  ONE_SUBS       EQU   1		   	; ONE VARIABLE FIELD IN MESSAGE
  5214                                  TWO_SUBS       EQU   2		   	; TWO VARIABLE FIELDS IN MESSAGE
  5215                                  THREE_SUBS     EQU   3		   	; THREE VARIABLE FIELDS IN MESSAGE
  5216                                  CLASS_1        EQU   EXT_ERR_CLASS 	; CLASS 1 (DOS EXTENDED ERRORS)
  5217                                  CLASS_2        EQU   PARSE_ERR_CLASS 	; CLASS 2 (PARSE ERRORS)
  5218                                  CLASS_A        EQU   UTILITY_MSG_CLASS	; CLASS A TYPE MESSAGE
  5219                                  
  5220                                  ;THIS MESSAGE DESCRIPTOR CONTROL BLOCK IS GENERATED, ONE PER MESSAGE,
  5221                                  ;TO DEFINE THE SEVERAL PARAMETERS THAT ARE EXPECTED TO BE PASSED IN
  5222                                  ;CERTAIN REGISTERS WHEN THE SYSDISPMSG FUNCTION IS TO BE INVOKED.
  5223                                  
  5224                                  struc MSG_DESC
  5225                                  .MSG_NUM :	resw	0	   	; MESSAGE NUMBER (TO AX)
  5226 00000000 ????                    .MSG_HANDLE:	resw	_STDOUT	   	; HANDLE OF OUTPUT DEVICE (TO BX)
  5227                                  .MSG_SUBLIST:	resw	0	   	; POINTER TO SUBLIST (TO SI)
  5228                                  .MSG_COUNT:	resw	0	   	; SUBSTITUTION COUNT (TO CX)
  5229 00000002 <res 1FE00h>            .MSG_CLASS:	resw	CLASS_A << 8	; MESSAGE CLASS (IN HIGH BYTE, TO DH)
  5230                                  .size:				   	; LOW BYTE HAS 0 (FUNCTION "NO INPUT", TO DL)
  5231                                  endstruc
  5232                                  
  5233                                  ; VALUES FOR THE SUBLIST CONTROL BLOCK
  5234                                  PC_ID_0        EQU   0		   ; ID OF " - " TRAILER TO MESSAGE
  5235                                  PC_ID_1        EQU   1		   ; ID OF PERCENT VARIABLE FIELD
  5236                                  PC_ID_2        EQU   2		   ; ID OF PERCENT VARIABLE FIELD
  5237                                  PC_ID_3        EQU   3		   ; ID OF PERCENT VARIABLE FIELD
  5238                                  MAX_0	       EQU   0		   ; MAXIMUM WIDTH OF STRING FIELD (0=NO LIMIT)
  5239                                  MIN_1	       EQU   1		   ; MINIMUM WIDTH OF STRING FIELD
  5240                                  PAD_BLK        EQU   " "           ; CHAR FOR PAD FIELD
  5241                                  FILL_OFF       EQU   0		   ; TO BE REPLACED WITH ACTUAL OFFSET
  5242                                  FILL_SEG       EQU   0		   ; TO BE REPLACED WITH ACTUAL SEG ID
  5243                                  
  5244                                  struc SUBLIST
  5245 00000000 ??                      .SUB_SIZE:	resb 1 ;11	; SUBLIST SIZE (POINTER TO NEXT SUBLIST)
  5246 00000001 ??                      .SUB_RES:	resb 1 ;0	; RESERVED
  5247                                  				; NEXT FIELD IS TO BE USED AS A DOUBLE WORD
  5248 00000002 ????                    .SUB_VALUE:	resw 1 ;0	; TIME, DATE, OR PTR TO DATA ITEM
  5249 00000004 ????                    .SUB_VALUE_SEG:	resw 1 ;0	; SEG ID OF PTR
  5250                                  				; (ABOVE FIELD MUST BE FILLED AT EXECUTION TIME
  5251                                  				; IF THIS IS A .COM FILE)
  5252 00000006 ??                      .SUB_ID:	resb 1 ;0	; N OF %N
  5253 00000007 ??                      .SUB_FLAGS:	resb 1 ;0	; DATA TYPE FLAGS
  5254 00000008 ??                      .SUB_MAX_WIDTH:	resb 1 ;MAX_0	; MAXIMUM FIELD WIDTH (0=UNLIMITED)
  5255 00000009 ??                      .SUB_MIN_WIDTH:	resb 1 ;0	; MINIMUM FIELD WIDTH
  5256 0000000A ??                      .SUB_PAD_CHAR:	resb 1 ;PAD_BLK ; CHARACTER FOR PAD FIELD
  5257                                  .size:				; CAN BE " ", "0" OR ",".
  5258                                  endstruc			; "," CAUSES INSERTION OF THE ACTIVE
  5259                                  				; THOUSANDS SEPARATOR BETWEEN EVERY 3 DIGITS.
  5260                                  
  5261                                  ;		  BITS DEFINED FOR SUB_FLAGS ABOVE
  5262                                  ;			FORMAT = A0SSTTTT
  5263                                  ;				 ++ + +--- FIELD TYPE
  5264                                  ;				 || +--- DATA VARIABLE SIZE
  5265                                  ;				 |+--- RESERVED, MUST BE ZERO
  5266                                  ;				 +--- ALIGNMENT INDICATOR
  5267                                  ;SF_BITS     RECORD F_ALIGN:1,F_RES:1=0,F_SIZE:2,F_TYPE:4
  5268                                  
  5269                                  ;		F_ALIGN FIELD, ALIGNMENT INDICATOR
  5270                                  SF_LEFT 	  EQU	0	   ;AN000;LEFT ALIGN
  5271                                  SF_RIGHT	  EQU	1	   ;AN000;RIGHT ALIGN
  5272                                  
  5273                                  ;		F_RES FIELD, RESERVED, SHOULD BE ZERO
  5274                                  
  5275                                  ;		F_TYPE FIELD, FIELD TYPE
  5276                                  SF_CHAR 	  EQU	0000B	   ;AN000;TYPE IS CHARACTER
  5277                                  ;		F_SIZE FIELD,
  5278                                  SF_CH		  EQU	00B	   ;AN000;SINGLE CHARACTER
  5279                                  SF_ASCIIZ	  EQU	01B	   ;AN000;ASCIIZ STRING
  5280                                  
  5281                                  ;		F_TYPE FIELD, FIELD TYPE
  5282                                  SF_UN_BD	  EQU	0001B	   ;AN000;UNSIGNED BINARY TO DECIMAL CHARACTER
  5283                                  ;		F_SIZE FIELD,
  5284                                  SF_BYTE 	  EQU	01B	   ;AN000;DATA IS BYTE SIZED
  5285                                  SF_WORD 	  EQU	10B	   ;AN000;DATA IS WORD SIZED
  5286                                  SF_DWORD	  EQU	11B	   ;AN000;DATA IS DOUBLE WORD SIZED
  5287                                  
  5288                                  ;		F_TYPE FIELD, FIELD TYPE
  5289                                  SF_SIN_BD	  EQU	0010B	   ;AN000;SIGNED BINARY TO DECIMAL CHARACTER
  5290                                  ;		F_SIZE FIELD,
  5291                                  ;SF_BYTE	  EQU	01B	   ;DATA IS BYTE SIZED
  5292                                  ;SF_WORD	  EQU	10B	   ;DATA IS WORD SIZED
  5293                                  ;SF_DWORD	  EQU	11B	   ;DATA IS DOUBLE WORD SIZED
  5294                                  
  5295                                  ;		F_TYPE FIELD, FIELD TYPE
  5296                                  SF_UN_BH	  EQU	0011B	   ;AN000;UNSIGNED BINARY TO HEXADECIMAL CHARACTER
  5297                                  ;		F_SIZE FIELD,
  5298                                  ;SF_BYTE	  EQU	01B	   ;DATA IS BYTE SIZED
  5299                                  ;SF_WORD	  EQU	10B	   ;DATA IS WORD SIZED
  5300                                  ;SF_DWORD	  EQU	11B	   ;DATA IS DOUBLE WORD SIZED
  5301                                  
  5302                                  ;		F_TYPE FIELD, FIELD TYPE
  5303                                  SF_DATE 	  EQU	0100B	   ;AN000;DATE TO CHARACTER,
  5304                                  				   ; USING CURRENT COUNTRY FORMAT
  5305                                  				   ;SUB_VALUE HIGH=YEAR
  5306                                  				   ;SUB_VALUE LOW=MMDD
  5307                                  ;		F_SIZE FIELD,
  5308                                  SF_MD		  EQU	01B	   ;AN000;MONTH AND DAY ONLY
  5309                                  SF_MDY2 	  EQU	10B	   ;AN000;MONTH,DAY AND YEAR (2 DIGITS)
  5310                                  SF_MDY4 	  EQU	11B	   ;AN000;MONTH,DAY AND YEAR (4 DIGITS)
  5311                                  
  5312                                  ;		F_TYPE FIELD, FIELD TYPE
  5313                                  SF_TIME_12	  EQU	0101B	   ;AN000;TIME TO CHARACTER, 12 HOUR FORMAT
  5314                                  				   ; USING CURRENT COUNTRY FORMAT
  5315                                  				   ;SUB_VALUE HIGH=HHMM
  5316                                  				   ;SUB_VALUE LOW=SSHH
  5317                                  ;		F_SIZE FIELD,
  5318                                  SF_HHMM 	  EQU	00B	   ;AN000;HH:MM (ACTIVE TIME FORMAT)
  5319                                  SF_HHMMSS	  EQU	01B	   ;AN000;HH:MM:SS (ACTIVE TIME FORMAT)
  5320                                  SF_HHMMSSHH	  EQU	10B	   ;AN000;HH:MM:SS:HH
  5321                                  
  5322                                  ;		F_TYPE FIELD, FIELD TYPE
  5323                                  SF_TIME_24	  EQU	0110B	   ;AN000;TIME TO CHARACTER, 24 HOUR FORMAT
  5324                                  				   ; USING CURRENT COUNTRY FORMAT
  5325                                  				   ;SUB_VALUE HIGH=HHMM
  5326                                  				   ;SUB_VALUE LOW=SSHH
  5327                                  ;		F_SIZE FIELD,
  5328                                  ;SF_HHMM	  EQU	00B	   ;HH:MM (ACTIVE TIME FORMAT)
  5329                                  ;SF_HHMMSS	  EQU	01B	   ;HH:MM:SS (ACTIVE TIME FORMAT)
  5330                                  ;SF_HHMMSSHH	  EQU	10B	   ;HH:MM:SS:HH
  5331                                  
  5332                                  ;		THE NEXT GROUP ARE ALL CLASS "1" MESSAGES
  5333                                  
  5334                                  ;		PUBLIC MSGNUM_EXTERR;AN000;
  5335                                  ;MSGNUM_EXTERR  MSG_DESC <,STDERR,,,CLASS_1 SHL 8> ; ALL EXTENDED DOS ERRORS
  5336                                  ;				   ; ERROR NUMBER WILL NEED TO BE FILLED IN
  5337                                  
  5338                                  ;		THE NEXT GROUP ARE ALL CLASS "2" MESSAGES
  5339                                  
  5340                                  ;		PUBLIC MSGNUM_PARSE ; SO PARSE DRIVER CAN FIND IT
  5341                                  ;MSGNUM_PARSE   MSG_DESC <,STDERR,,,CLASS_2 SHL 8> ; ALL PARSING ERRORS
  5342                                  ;				   ; ERROR NUMBER WILL NEED TO BE FILLED IN
  5343                                  
  5344                                  ;		THE NEXT GROUP ARE ALL CLASS "A" MESSAGES
  5345                                  ;		THESE ARE THE "CANNED" MESSAGES ALWAYS PRESENT
  5346                                  
  5347                                  ;		PUBLIC MSGNUM_VER   ;
  5348                                  ;MSGNUM_VER	MSG_DESC <1,STDERR> ; "Incorrect DOS Version"
  5349                                  
  5350                                  ; msgserv.asm (MSDOS 6.0, 1991)	
  5351                                  ; ----------------------------------------------------------------------------
  5352                                  
  5353                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  5354                                  ;;
  5355                                  ;;  Proc Name:	SYSDISPMSG
  5356                                  ;;
  5357                                  ;;  Function:	The DISPLAY service will output a defined message to a handle
  5358                                  ;;		requested by the caller. It also provides function to display
  5359                                  ;;		messages when handles are not applicable (ie. DOS function calls
  5360                                  ;;		00h to 0Ah) Replaceable parameters are allowed and are
  5361                                  ;;		defined previous to entry.
  5362                                  ;;
  5363                                  ;;		It is assumes that a PRELOAD function has already determined
  5364                                  ;;		the addressibilty internally to the message retriever services.
  5365                                  ;;  Inputs:
  5366                                  ;;
  5367                                  ;;  Outputs:
  5368                                  ;;
  5369                                  ;;  Psuedocode:
  5370                                  ;;		Save registers needed later
  5371                                  ;;		Get address of the message requested
  5372                                  ;;		IF Message number exists THEN
  5373                                  ;;		  IF replacable parameters were specified THEN
  5374                                  ;;		     Display message with replacable parms
  5375                                  ;;		  ELSE
  5376                                  ;;		     Display string without replacable parms
  5377                                  ;;		  ENDIF
  5378                                  ;;		  IF character input was requested THEN
  5379                                  ;;		     Wait for character input
  5380                                  ;;		  ENDIF
  5381                                  ;;		  Clear CARRY FLAG
  5382                                  ;;		ELSE
  5383                                  ;;		   Set CARRY FLAG
  5384                                  ;;		ENDIF
  5385                                  ;;		Return
  5386                                  ;;
  5387                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  5388                                  
  5389                                  ; Input:
  5390                                  ; AX = MSG_DESC.MSG_NUM		; MESSAGE NUMBER
  5391                                  ; BX = MSG_DESC.MSG_HANDLE	; HANDLE OF OUTPUT DEVICE
  5392                                  ; CX = MSG_DESC.MSG_COUNT	; SUBSTITUTION COUNT
  5393                                  ; SI = MSG_DESC.MSG_SUBLIST	; POINTER TO SUBLIST
  5394                                  ; DH = MSG_DESC.MSG_CLASS	; MESSAGE CLASS
  5395                                  ; DL = 0
  5396                                  
  5397                                  SYSDISPMSG:
  5398 00000E0D 06                      		push	es	; Save registers and values needed later
  5399 00000E0E 55                      		push	bp
  5400                                  		;push	dx		
  5401                                  
  5402 00000E0F 89CD                    		mov	bp,cx		; Use BP to hold replace count
  5403                                  
  5404 00000E11 891E[2E5D]              		mov	[$M_HANDLE],bx	; Save handle
  5405 00000E15 8836[335D]              		mov	[$M_CLASS],dh	; Save class
  5406                                  
  5407                                  		; Get address of the message requested
  5408 00000E19 E81D00                  		call	_$M_GET_MSG_ADDRESS
  5409                                  
  5410 00000E1C 83F901                  		cmp	cx,1		; Was message found?
  5411                                  		;jb	short $MEN94	; NO
  5412 00000E1F 7215                    		jb	short $MIF104 	; CF = 1
  5413                                  				
  5414                                  					; YES, Message address in ES:DI
  5415                                  
  5416                                  		; Test if replacable parameters were specified
  5417 00000E21 09ED                    		or	bp,bp		; Were replacable parameters requested		
  5418 00000E23 7505                    		jnz	short $MIF94
  5419                                  
  5420                                  		; Display string without replacable parms
  5421 00000E25 E85904                  		call	_$M_DISPLAY_STRING ; No, great . . . Display message
  5422 00000E28 EB03                    		jmp	short $MEN94
  5423                                  $MIF94:
  5424                                  		; Display message with replacable parms		
  5425 00000E2A E80B01                  		call	_$M_DISPLAY_MESSAGE
  5426                                  $MEN94:
  5427                                  		;pop	dx		; Get Input/Class request
  5428 00000E2D 7207                    		jc	short $MIF104
  5429                                  
  5430 00000E2F 8A36[335D]              		mov	dh,[$M_CLASS]	; Restore class
  5431                                  
  5432 00000E33 E81F05                  		call	_$M_ADD_CRLF	; Check if we need to add the CR LF chars.
  5433                                  $MIF104:
  5434 00000E36 5D                      		pop	bp
  5435 00000E37 07                      		pop	es
  5436                                  
  5437                                  		;retf
  5438 00000E38 C3                      		retn
  5439                                  
  5440                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  5441                                  ;;
  5442                                  ;;	PROC NAME: $M_GET_MSG_ADDRESS
  5443                                  ;;
  5444                                  ;;	FUNCTION:  To scan thru classes to return pointer to the message header
  5445                                  ;;	INPUTS:    Access to $M_RES_ADDRESSES
  5446                                  ;;	OUTPUTS:   IF CX = 0 THEN Message was not found
  5447                                  ;;		   IF CX > 1 THEN ES:DI points to the specified message
  5448                                  ;;	REGS CHANGED: ES,DI,CX
  5449                                  ;;
  5450                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  5451                                  
  5452                                  _$M_GET_MSG_ADDRESS:
  5453 00000E39 56                      		push	si
  5454 00000E3A 53                      		push	bx
  5455 00000E3B 31F6                    		xor	si,si		; Use SI as an index
  5456 00000E3D 31C9                    		xor	cx,cx		; Use CX as an size
  5457                                  $MDO36:
  5458 00000E3F 80FEFF                  		cmp	dh,0FFh	 ; UTILITY_MSG_CLASS ; Were utility messages requested?
  5459 00000E42 7508                    		jne	short $MIF37	; No,
  5460 00000E44 C4BC[1E5D]              		les	di,[$M_CLASS_A_ADDRS+si] ; Yes, get address of class	
  5461 00000E48 8CC3                    		mov	bx,es
  5462 00000E4A EB25                    		jmp	short $MEN37
  5463                                  $MIF37:
  5464 00000E4C F6C602                  		test	dh,2	; PARSE_ERR_CLASS ; Were parse errors requested?
  5465 00000E4F 7408                    		jz	short $MIF39	; No, extended errors were specified
  5466                                  						 ; Yes
  5467 00000E51 C4BC[025D]              		les	di,[$M_PARSE_COMMAND+si] ; Get address of class
  5468 00000E55 8CC3                    		mov	bx,es
  5469 00000E57 EB18                    		jmp	short $MEN37
  5470                                  $MIF39:
  5471 00000E59 83F813                  		cmp	ax,13h ; $M_CRIT_LO	; Is this a critical error?
  5472 00000E5C 720D                    		jb	short $MIF41	; No,
  5473 00000E5E 83F827                  		cmp	ax,27h ; $M_CRIT_HI
  5474 00000E61 7708                    		ja	short $MIF41	; No,
  5475                                  						; Yes, (extended errors considered critical)
  5476 00000E63 C4BC[0E5D]              		les	di,[$M_CRIT_ADDRS+si]	; Get address of class
  5477 00000E67 8CC3                    		mov	bx,es
  5478 00000E69 EB06                    		jmp	short $MEN37
  5479                                  $MIF41:					; Extended Errors
  5480 00000E6B C4BC[F25C]              		les	di,[$M_EXT_ERR_ADDRS+si] ; Get address of class
  5481 00000E6F 8CC3                    		mov	bx,es
  5482                                  $MEN37:
  5483 00000E71 83FBFF                  		cmp	bx,0FFFFh ; $M_TERMINATING_FLAG	; Are we finished all classes?
  5484 00000E74 7516                    		jne	short $MIF46	; No,
  5485                                  						; Yes,
  5486 00000E76 80FEFF                  		cmp	dh,0FFh	; UTILITY_MSG_CLASS ; Was it a UTILITY class?
  5487 00000E79 7503                    		jne	short $MIF47	; No,
  5488 00000E7B F9                      		stc				; Yes, set the carry flag
  5489                                  		;jmp	short $MEN47
  5490 00000E7C EB1E                    		jmp	short $MEN36 ; 13/11/2018
  5491                                  		
  5492                                  $MIF47:
  5493 00000E7E A3[365D]                		mov	[$M_MSG_NUM],ax		; Save message number
  5494 00000E81 B8FFFF                  		mov	ax,0FFFFh ; $M_SPECIAL_MSG_NUM	; Set special message number
  5495 00000E84 BD0100                  		mov	bp,1  ; $M_ONE_REPLACE	; Set one replace in message
  5496 00000E87 31F6                    		xor	si,si			; Reset the SI index to start again
  5497 00000E89 F8                      		clc
  5498                                  $MEN47:
  5499                                  		;jmp	short $MEN46
  5500 00000E8A EB0C                    		jmp	short $MIF49 ; 13/11/2018
  5501                                  $MIF46:
  5502 00000E8C 83FB00                  		cmp	bx,0 ; $M_CLASS_NOT_EXIST ; Does this class exist?	
  5503 00000E8F 7403                    		je	short $MIF51	; No,
  5504                                  						; Yes,	
  5505 00000E91 E84600                  		call	_$M_FIND_SPECIFIED_MSG	; Try to find the message 
  5506                                  $MIF51:
  5507 00000E94 83C604                  		add	si,4 ; $M_ADDR_SZ_FAR	; Get next class
  5508 00000E97 F8                      		clc
  5509                                  ;$MEN46:
  5510                                  		;jc	short $MEN36
  5511                                  $MIF49: ; 13/11/2018
  5512 00000E98 09C9                    		or	cx,cx			; Was the message found?
  5513                                  		;jnz	short $MEN36		; Yes,
  5514                                  		;jmp	short $MDO36
  5515 00000E9A 74A3                    		jz	short $MDO36 ; 13/11/2018 ; No,
  5516                                  $MEN36:
  5517 00000E9C 9C                      		pushf	 ; not necessary ; * 	; Save the flag state
  5518 00000E9D 80FE01                  		cmp	dh,1 ; EXT_ERR_CLASS	; Was an extended error requested?
  5519 00000EA0 7525                    		jne	short $MIF56
  5520 00000EA2 52                      		push	dx		; Save all needed registers
  5521 00000EA3 55                      		push	bp
  5522 00000EA4 51                      		push	cx
  5523 00000EA5 06                      		push	es
  5524 00000EA6 57                      		push	di
  5525 00000EA7 50                      		push	ax
  5526 00000EA8 B80005                  		mov	ax,0500h	; Check if IFSFUNC is installed
  5527 00000EAB CD2F                    		int	2Fh	; Multiplex - DOS 3+ CRITICAL ERROR HANDLER - INSTALLATION CHECK
  5528                                  				; Return: AL = 00h not installed, OK to	install
  5529                                  				; 01h not installed, can't install
  5530                                  				; FFh installed
  5531 00000EAD 3CFF                    		cmp	al,0FFh		; Is it installed?
  5532 00000EAF 58                      		pop	ax		; Restore msg number
  5533                                  		;jne	short $MIF57	; No,
  5534 00000EB0 7208                    		jb	short $MEN58 ; 13/11/2018 ; cf = 1
  5535                                  					; Yes,
  5536 00000EB2 93                      		xchg	ax, bx		; BX is the extended error number
  5537 00000EB3 B80205                  		mov	ax,0502h	; AX is the multiplex number
  5538                                  					; Call IFSFUNC	
  5539 00000EB6 CD2F                    		int	2Fh	; Multiplex - DOS 3+ CRITICAL ERROR HANDLER -
  5540                                  		;jmp	short $MEN57
  5541                                  ;$MIF57:
  5542                                  ;		stc
  5543                                  ;$MEN57:				; Was there an update?
  5544 00000EB8 7305                    		jnc	short $MIF60	; No,
  5545                                  $MEN58: ; 13/11/2018		
  5546 00000EBA 5F                      		pop	di		; Restore old pointer
  5547 00000EBB 07                      		pop	es
  5548 00000EBC 59                      		pop	cx
  5549 00000EBD EB06                    		jmp	short $MEN60
  5550                                  $MIF60:
  5551 00000EBF 83C406                  		add	sp,6		; Throw away old pointer
  5552 00000EC2 E80600                  		call	_$M_SET_LEN_IN_CX ; Get the length of the ASCIIZ string
  5553                                  $MEN60:
  5554 00000EC5 5D                      		pop	bp		; Restore other Regs
  5555 00000EC6 5A                      		pop	dx
  5556                                  $MIF56:
  5557                                  ;		jmp	short _$M_POPF
  5558                                  ;_$M_MYRET:
  5559                                  ;		iret
  5560                                  
  5561                                  		; 12/11/2018
  5562                                  
  5563 00000EC7 9D                      		popf		; * ; not necessary
  5564                                  
  5565 00000EC8 5B                      		pop	bx 	; *
  5566 00000EC9 5E                      		pop	si	; *
  5567 00000ECA C3                      		retn		; *
  5568                                  
  5569                                  ;_$M_POPF:				; Restore the flag state
  5570                                  		;push	cs
  5571                                  		;call	_$M_MYRET
  5572                                  		;pop	bx
  5573                                  		;pop	si
  5574                                  
  5575                                  		;;retf
  5576                                  		;retn
  5577                                  
  5578                                  ;_$M_MYRET:	iret
  5579                                  		
  5580                                  ; ----------------------------------------------------------------------------
  5581                                  		
  5582                                  				; Get the length of the ASCIIZ string
  5583                                  _$M_SET_LEN_IN_CX:			;
  5584 00000ECB 57                      		push	di		; Save position
  5585 00000ECC 50                      		push	ax		;
  5586 00000ECD B9FFFF                  		mov	cx,-1		; Set CX for decrements
  5587 00000ED0 30C0                    		xor	al,al		; Prepare compare register
  5588 00000ED2 F2AE                    		repne scasb		; Scan for zero
  5589 00000ED4 F7D1                    		not	cx		; Change decrement into number
  5590 00000ED6 49                      		dec	cx		; Don't include the zero
  5591 00000ED7 58                      		pop	ax		;
  5592 00000ED8 5F                      		pop	di		; Restore position
  5593 00000ED9 C3                      		retn			;
  5594                                  
  5595                                  ; ----------------------------------------------------------------------------
  5596                                  
  5597                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  5598                                  ;;
  5599                                  ;;	PROC NAME: $M_FIND_SPECIFIED_MSG
  5600                                  ;;
  5601                                  ;;	FUNCTION:  To scan thru message headers until message is found
  5602                                  ;;	INPUTS:    ES:DI points to beginning of msg headers
  5603                                  ;;		   CX contains the number of messages in class
  5604                                  ;;		   DH contains the message class
  5605                                  ;;	OUPUTS:    IF CX = 0 THEN Message was not found
  5606                                  ;;		   IF CX > 1 THEN ES:DI points to header of specified message
  5607                                  ;;
  5608                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  5609                                  
  5610                                  _$M_FIND_SPECIFIED_MSG:
  5611 00000EDA 83FB01                  		cmp	bx,1		; Do we have an address to CALL?
  5612 00000EDD 751F                    		jne	short $MIF64
  5613                                  					; Do we have an address to CALL?
  5614 00000EDF 833E[1A5D]FF            		cmp	word [$M_DISK_PROC_ADDR], -1 ; 0FFFFh
  5615 00000EE4 7418                    		je	short $MIF64
  5616                                  					; Yes
  5617                                  				; Are we displaying a default Ext Err?
  5618 00000EE6 83F8FF                  		cmp	ax,0FFFFh ; $M_SPECIAL_MSG_NUM
  5619 00000EE9 750B                    		jne	short $MIF65	 ;No
  5620                                  
  5621 00000EEB 50                      		push	ax		; Reset the special message number
  5622 00000EEC A1[365D]                		mov	ax,[$M_MSG_NUM] ; Get the old message number
  5623                                  				 ; Call the READ_DISK_PROC to get error text	
  5624 00000EEF FF1E[1A5D]              		call	far [$M_DISK_PROC_ADDR]
  5625 00000EF3 58                      		pop	ax		; Reset the special message number
  5626 00000EF4 EB04                    		jmp	short $MEN65
  5627                                  $MIF65:
  5628                                  		;CALL	DWORD PTR $M_RT.$M_DISK_PROC_ADDR
  5629                                  					; Call the READ_DISK_PROC to get error text 
  5630 00000EF6 FF1E[1A5D]              		call	far [$M_DISK_PROC_ADDR]
  5631                                  $MEN65:
  5632                                  		;jmp	short $MEN64
  5633 00000EFA 7330                    		jnc	short $MIF88	; *
  5634                                  		; cf = 1
  5635 00000EFC EB19                    		jmp	short $MDO76	; *	
  5636                                  $MIF64:
  5637 00000EFE 31C9                    		xor	cx,cx		; CX = 0 will allow us to
  5638 00000F00 80FEFF                  		cmp	dh,0FFh ; UTILITY_MSG_CLASS
  5639 00000F03 7406                    		je	short $MIF69
  5640                                  		;MOV	CL,BYTE PTR ES:[DI].$M_NUM_CLS_MSG 
  5641 00000F05 268A4D03                		mov	cl,[es:di+3]	; Get number of messages in class
  5642 00000F09 EB09                    		jmp	short $MEN69
  5643                                  $MIF69:
  5644                                  		;CMP	BYTE PTR ES:[DI].$M_CLASS_ID,DH
  5645 00000F0B 263835                  		cmp	[es:di],dh	; Check if class still exists at
  5646 00000F0E 7504                    		jne	short $MEN69
  5647                                  					; pointer (hopefully)
  5648                                  		;MOV	CL,BYTE PTR ES:[DI].$M_NUM_CLS_MSG
  5649 00000F10 268A4D03                		mov	cl,[es:di+3]	; Get number of messages in class
  5650                                  $MEN69:
  5651                                  					;  go on to the next class
  5652 00000F14 83C704                  		add	di,4 ; $M_CLASS_ID_SZ ; Point past the class header
  5653                                  		;stc			; Flag that we haven't found anything yet
  5654                                  		
  5655                                  		;jmp	short $MDO76 	; *
  5656                                  ;$MEN64:
  5657                                  		;;jnc	short $MIF86	; Have we found anything yet?
  5658                                  		
  5659                                  		;jnc	short $MIF88	; *	
  5660                                  		
  5661                                  		;;clc			; No, reset carry
  5662                                  $MDO76:
  5663 00000F17 09C9                    		or	cx,cx		; Do we have any to check?
  5664                                  		;jz	short $MEN76	; No, return with CX = 0
  5665                                  		
  5666 00000F19 7417                    		jz	short $MIF91 	; *
  5667                                  		
  5668                                  		;cmp	dh,0FFh	; UTILITY_MSG_CLASS
  5669                                  		;je	short $MIF78
  5670                                  
  5671                                  		;;CMP	AX,WORD PTR ES:[DI].$M_NUM
  5672                                  		;cmp	ax,[es:di]	; Is this the message requested?
  5673                                  		;jmp	short $MEN78
  5674                                  ;$MIF78:
  5675 00000F1B 263B05                  		cmp	ax,[es:di]	; Is this the message requested?
  5676                                  ;$MEN78:
  5677                                  		;jne	short $MIF76
  5678                                  		;jmp	short $MSR76
  5679 00000F1E 7408                    		je	short $MSR77	; *
  5680                                  ;$MIF76:
  5681 00000F20 49                      		dec	cx		; No, well do we have more to check?	
  5682                                  		;jz	short $MEN76
  5683 00000F21 740F                    		jz	short $MIF91	; * ; No, return with CX = 0	
  5684 00000F23 83C704                  		add	di,4		    ; Yes, skip past msg header
  5685 00000F26 EBEF                    		jmp	short $MDO76
  5686                                  ;$MEN76:
  5687                                  		;stc
  5688                                  		;jmp	short $MIF86	; *
  5689                                  ;$MSR76:
  5690                                  ;		jc	short $MIF86
  5691                                  $MSR77: 				; *
  5692                                  		;cmp	dh,0FFh
  5693                                  		;clc
  5694                                  		;jnz	short $+2  ; $MIF87
  5695                                  ;$MIF87:
  5696                                  		;ADD	DI,WORD PTR ES:[DI].$M_TXT_PTR
  5697 00000F28 26037D02                		add	di,[es:di+2]	; Prepare ES:DI pointing to the message
  5698                                  ;$MIF86:
  5699                                  ;		jc	short $MIF91	; Did we find the message?
  5700                                  $MIF88:					; *
  5701 00000F2C 30ED                    		xor	ch,ch
  5702 00000F2E 268A0D                  		mov	cl,[es:di]	; Move size into CX
  5703 00000F31 47                      		inc	di		; Increment past length
  5704                                  $MIF91:
  5705 00000F32 C606[305D]00            		mov	byte [$M_SIZE],0 ; Reset variable	
  5706 00000F37 C3                      		retn
  5707                                  
  5708                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  5709                                  ;;
  5710                                  ;;	PROC NAME: $M_DISPLAY_MESSAGE
  5711                                  ;;
  5712                                  ;;	FUNCTION:  Will display or write entire message (with replacable parameters)
  5713                                  ;;	INPUTS:    ES:DI points to beginning of message
  5714                                  ;;		   DS:SI points to first sublist structure in chain
  5715                                  ;;		   BX contains the handle to write to (if applicable)
  5716                                  ;;		   CX contains the length of string to write (before substitutions)
  5717                                  ;;		   BP contains the count of replacables
  5718                                  ;;
  5719                                  ;;	OUTPUTS:
  5720                                  ;;	REGS USED: All
  5721                                  ;;
  5722                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  5723                                  
  5724                                  _$M_DISPLAY_MESSAGE:
  5725                                  					; Note: DS:SI -> message
  5726                                  $MDO165:
  5727 00000F38 31D2                    		xor	dx,dx		; Set size = 0
  5728 00000F3A 09C9                    		or	cx,cx
  5729 00000F3C 741F                    		jz	short $MEN167
  5730                                  
  5731                                  		;mov	ah,"%" ; 25h	; Prepare to scan for %
  5732                                  	    	;mov	al,0
  5733 00000F3E B80025                  		mov	ax,2500h
  5734                                  
  5735                                  $MDO167:				; Scan through string until %
  5736 00000F41 263825                  		cmp	[es:di],ah	; Is this character NOT a %
  5737 00000F44 750A                    		jne	short $MLL168	; No,
  5738 00000F46 26386501                		cmp	[es:di+1],ah	; Is the next character also a %
  5739 00000F4A 7404                    		je	short $MLL168	; Yes,
  5740 00000F4C 38E0                    		cmp	al,ah		; Was the character before a %
  5741 00000F4E 750D                    		jne	short $MEN167	; No, GREAT found it
  5742                                  $MLL168:
  5743 00000F50 268A05                  		mov	al,[es:di]	; Yes, (to any of the above)
  5744 00000F53 E81504                  		call	_$M_IS_IT_DBCS	; Is this character the first part of a DBCS?
  5745 00000F56 7301                    		jnc	short $MIF169	; No,
  5746                                  					; Yes,
  5747 00000F58 47                      		inc	di		; Increment past second part
  5748                                  $MIF169:
  5749 00000F59 47                      		inc	di		; Next character in string
  5750 00000F5A 42                      		inc	dx		; Size = Size + 1
  5751                                  		
  5752                                  		;dec	cx		; Decrement total size
  5753                                  		;jnz	short $MDO167		
  5754                                  		
  5755 00000F5B E2E4                    		loop	$MDO167		
  5756                                  					; Exit scan if we're at the end of the line
  5757                                  $MEN167:
  5758 00000F5D 56                      		push	si		; Save beginning of sublists
  5759 00000F5E 87CA                    		xchg	cx,dx		; Get size of message to display (tot sz in DX)
  5760 00000F60 09ED                    		or	bp,bp		; Do we have any replacables to do?
  5761 00000F62 7433                    		jz	short $MSR175	; No,
  5762                                  					; Yes,
  5763 00000F64 4D                      		dec	bp		; Decrement number of replacables
  5764                                  
  5765                                  	; Search through sublists to find applicable one
  5766                                  
  5767 00000F65 833E[365D]00            		cmp	word [$M_MSG_NUM],0 ;$M_NULL ; Is this an Extended/Parse case
  5768 00000F6A 752B                    		jne	short $MSR175	; No,	
  5769                                  $MDO175:				; Yes,
  5770                                  		;MOV	AL,$M_SL.$M_S_ID
  5771 00000F6C 8A4406                  		mov	al,[si+6] ; $M_S_ID ; Get ID byte
  5772 00000F6F 0430                    		add	al,'0'		; Convert to ASCII
  5773 00000F71 263A4501                		cmp	al,[es:di+1]	; Is this the right sublist?
  5774 00000F75 7502                    		jne	short $MIF175	; No,
  5775 00000F77 EB1E                    		jmp	short $MSR175	; Yes,
  5776                                  $MIF175:
  5777 00000F79 3C30                    		cmp	al,'0' ; $M_SPECIAL_CASE ; Does this sublist have ID = 0
  5778 00000F7B 7504                    		jne	short $MLL178	; No,
  5779                                  					; Yes,
  5780 00000F7D 09D2                    		or	dx,dx		; Are we at the end of the message?
  5781 00000F7F 7404                    		jz	short $MEN175	; No,
  5782                                  $MLL178:
  5783 00000F81 0334                    		add	si,[si]
  5784 00000F83 EBE7                    		jmp	short $MDO175
  5785                                  $MEN175:
  5786                                  		;CMP	$M_RT.$M_CLASS,UTILITY_MSG_CLASS
  5787 00000F85 803E[335D]FF            		cmp	byte [$M_CLASS],0FFh ; Is it a utility message?
  5788 00000F8A 7508                    		jne	short $MIF180	; No,
  5789                                  					; Yes,
  5790 00000F8C 42                      		inc	dx		; Remember to display CR,LF
  5791 00000F8D 42                      		inc	dx		;   at the end of the message
  5792 00000F8E 49                      		dec	cx		; Adjust message length
  5793 00000F8F 49                      		dec	cx
  5794 00000F90 4F                      		dec	di		; Adjust ending address of message
  5795 00000F91 4F                      		dec	di
  5796 00000F92 EB03                    		jmp	short $MSR175
  5797                                  $MIF180:
  5798 00000F94 BAFFFF                  		mov	dx,-1		; Set special case
  5799                                  
  5800                                  	; Prepare and display this part of message
  5801                                  $MSR175:
  5802 00000F97 57                      		push	di		; Save pointer to replace number
  5803 00000F98 29CF                    		sub	di,cx		; Determine beginning of string
  5804 00000F9A E8E402                  		call	_$M_DISPLAY_STRING ; Display string until % (or end)
  5805 00000F9D 5F                      		pop	di		; Get back pointer to replace number
  5806 00000F9E 59                      		pop	cx		; Clean up stack in case error
  5807 00000F9F 7302                    		jnc	short $MXL3
  5808                                  					; Fail if carry was set
  5809 00000FA1 EB7C                    		jmp	$MEN165
  5810                                  $MXL3:
  5811 00000FA3 51                      		push	cx
  5812 00000FA4 89D1                    		mov	cx,dx		; Get the size of the rest of the message
  5813                                  		;CMP	$M_SL.$M_S_ID,$M_SPECIAL_CASE-30H
  5814 00000FA6 807C0600                		cmp	byte [si+6],0	; Is this the %0 case?
  5815 00000FAA 740D                    		je	short $MIF187	; Yes,
  5816                                  					; No,
  5817 00000FAC 09C9                    		or	cx,cx		; Are we finished the whole message?
  5818 00000FAE 7406                    		jz	short $MIF188	; Yes
  5819                                  					; No,
  5820 00000FB0 49                      		dec	cx		; Decrement total size (%)
  5821 00000FB1 49                      		dec	cx		; Decrement total size (#)
  5822 00000FB2 47                      		inc	di		; Go past %
  5823 00000FB3 47                      		inc	di		; Go past replace number
  5824 00000FB4 EB01                    		jmp	short $MEN188	; (Note this will not leave because INC)
  5825                                  $MIF188:
  5826 00000FB6 5E                      		pop	si		; Get back pointer to beginning of SUBLISTs
  5827                                  $MEN188:				; 
  5828 00000FB7 EB10                    		jmp	short $MEN187	; (Note this will not leave because INC)
  5829                                  $MIF187:
  5830 00000FB9 09C9                    		or	cx,cx		; Are we finished the whole message?
  5831 00000FBB 7503                    		jnz	short $MIF192	; No,
  5832 00000FBD 5E                      		pop	si
  5833 00000FBE EB09                    		jmp	short $MEN187
  5834                                  $MIF192:
  5835 00000FC0 83F9FF                  		cmp	cx,-1 ; 0FFFFh	; Are we at the end of the message?
  5836 00000FC3 7502                    		jne	short $MIF194	; No,
  5837 00000FC5 31C9                    		xor	cx,cx
  5838                                  $MIF194:
  5839 00000FC7 09FF                    		or	di,di		; Turn ZF off
  5840                                  $MEN187:
  5841 00000FC9 7454                    		jz	short $MEN165
  5842 00000FCB 55                      		push	bp		; Save the replace count
  5843 00000FCC 57                      		push	di
  5844 00000FCD 06                      		push	es
  5845 00000FCE 51                      		push	cx		; Save size of the rest of the message
  5846 00000FCF 31C9                    		xor	cx,cx		; Reset CX used for character count
  5847                                  
  5848                                  	; Determine what action is required on parameter
  5849                                  
  5850                                  		;CMP	$M_RT.$M_MSG_NUM,$M_NULL
  5851 00000FD1 833E[365D]00            		cmp	word [$M_MSG_NUM],0  ; Is this an Extended/Parse case
  5852 00000FD6 752B                    		jne	short $MIF199
  5853                                  		
  5854                                  		;TEST	BYTE PTR $M_SL.$M_S_FLAG,NOT Char_Type AND $M_TYPE_MASK
  5855 00000FD8 F644070F                		test	byte [si+7],0Fh
  5856 00000FDC 7508                    		jnz	short $MIF200
  5857                                  
  5858                                  	; Character type requested
  5859                                  
  5860                                  		;LES	DI,DWORD PTR $M_SL.$M_S_VALUE
  5861 00000FDE C47C02                  		les	di,[si+2]	; Load pointer to replacing parameter
  5862 00000FE1 E84701                  		call	_$M_CHAR_REPLACE
  5863 00000FE4 EB18                    		jmp	short $MIF202
  5864                                  $MIF200:
  5865                                  		;TEST	BYTE PTR $M_SL.$M_S_FLAG,NOT Sgn_Bin_Type AND $M_TYPE_MASK
  5866 00000FE6 F644070D                		test	byte [si+7],0Dh
  5867 00000FEA 740C                    		jz	short $MLL202
  5868                                  
  5869                                  		;TEST	BYTE PTR $M_SL.$M_S_FLAG,NOT Unsgn_Bin_Type AND $M_TYPE_MASK
  5870 00000FEC F644070E                		test	byte [si+7],0Eh
  5871 00000FF0 7406                    		jz	short $MLL202
  5872                                  
  5873                                  		;TEST 	BYTE PTR $M_SL.$M_S_FLAG,NOT Bin_Hex_Type AND $M_TYPE_MASK
  5874 00000FF2 F644070C                		test	byte [si+7],0Ch
  5875 00000FF6 7506                    		jnz	short $MIF202
  5876                                  
  5877                                  	; Numeric type requested
  5878                                  $MLL202:
  5879                                  		;LES	DI,DWORD PTR $M_SL.$M_S_VALUE
  5880 00000FF8 C47C02                  		les	di,[si+2]
  5881 00000FFB E85501                  		call	_$M_BIN2ASC_REPLACE
  5882                                  		;jmp	short $+2
  5883                                  $MIF202:
  5884                                  	; With the replace information of the Stack, display the replaceable field
  5885                                  
  5886 00000FFE E85200                  		call	_$M_DISPLAY_REPLACE	; Display the replace
  5887 00001001 EB03                    		jmp	short $MEN199
  5888                                  $MIF199:
  5889                                  	; None of the above - Extended/Parse replace
  5890                                  
  5891 00001003 E82000                  		call	_$M_EXT_PAR_REPLACE
  5892                                  $MEN199:
  5893                                  	; We must go back and complete the message after the replacable parameter
  5894                                  	;   if there is any left
  5895                                  
  5896 00001006 7207                    		jc	short $MIF211 ; IF there was an error displaying then EXIT
  5897 00001008 59                      		pop	cx	; Get size of the rest of the message
  5898 00001009 07                      		pop	es	; Get address of the rest of the message
  5899 0000100A 5F                      		pop	di
  5900 0000100B 5D                      		pop	bp	; Get replacment count
  5901 0000100C 5E                      		pop	si	; ELSE get address of first sublist structure
  5902 0000100D EB06                    		jmp	short $MEN211
  5903                                  $MIF211:
  5904 0000100F 83C40A                  		add	sp,10	; Clean up stack if error
  5905 00001012 F9                      		stc
  5906 00001013 EB0A                    		jmp	short $MEN165
  5907                                  $MEN211:
  5908                                  		;CMP	$M_RT.$M_MSG_NUM,$M_NULL
  5909 00001015 833E[365D]00            		cmp	word [$M_MSG_NUM],0 ; Is this an Extended/Parse case
  5910 0000101A 7503                    		jne	short $MEN165 
  5911                                  		;jb	short $MEN165
  5912                                  				; Go back and display the rest of the message
  5913 0000101C E919FF                  		jmp	_$M_DISPLAY_MESSAGE
  5914                                  $MEN165:
  5915 0000101F C706[365D]0000          		mov	word [$M_MSG_NUM],0 ; Reset message number to null
  5916 00001025 C3                      		retn			    ; then Return
  5917                                  
  5918                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  5919                                  ;;
  5920                                  ;;	PROC NAME: $M_EXT_PAR_REPLACE
  5921                                  ;;
  5922                                  ;;	FUNCTION:
  5923                                  ;;	INPUTS:
  5924                                  ;;	OUPUTS:
  5925                                  ;;
  5926                                  ;;	REGS USED:
  5927                                  ;;
  5928                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  5929                                  
  5930                                  _$M_EXT_PAR_REPLACE:
  5931 00001026 31D2                    		xor	dx,dx		; Prepare for get binary value (HIGH)
  5932 00001028 A1[365D]                		mov	ax,[$M_MSG_NUM]	; Prepare for get binary value (LOW)
  5933 0000102B C706[385D]0A00          		mov	word [$M_DIVISOR],10 ; Set default divisor
  5934 00001031 E8E401                  		call	_$M_CONVERT2ASC
  5935                                  		; cx = number of characters
  5936                                  		; bx = 0
  5937                                  $MDO215:
  5938 00001034 58                      		pop	ax		; Get character in register
  5939                                  					; Move char into the buffer
  5940 00001035 8887[3A5D]              		mov	[$M_TEMP_BUF+bx],al ; "$$$$$$$"
  5941 00001039 43                      		inc	bx		; Increase buffer count
  5942 0000103A 83FB40                  		cmp	bx,64 ; $M_TEMP_BUF_SZ	; Is buffer full?
  5943 0000103D 7503                    		jne	short $MIF216
  5944                                  					; Yes,
  5945 0000103F E8CE00                  		call	_$M_FLUSH_BUF	; Flush the buffer
  5946                                  		; bx = 0
  5947                                  $MIF216:
  5948 00001042 FEC9                    		dec	cl		; Have we completed replace?
  5949 00001044 75EE                    		jnz	short $MDO215	; No, get next char from stack
  5950 00001046 B80D0A                  		mov	ax,0A0Dh ; $M_CR_LF ; Move char into the buffer	
  5951 00001049 8987[3A5D]              		mov	[$M_TEMP_BUF+bx],ax ; "$$$$$$$"
  5952 0000104D 43                      		inc	bx		; Increase buffer count
  5953 0000104E 43                      		inc	bx
  5954 0000104F E8BE00                  		call	_$M_FLUSH_BUF	; Flush the buffer
  5955 00001052 C3                      		retn
  5956                                  
  5957                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  5958                                  ;;
  5959                                  ;;	PROC NAME: $M_DISPLAY_REPLACE
  5960                                  ;;
  5961                                  ;;	FUNCTION:
  5962                                  ;;	INPUTS:
  5963                                  ;;	OUPUTS:
  5964                                  ;;
  5965                                  ;;	REGS USED:
  5966                                  ;;
  5967                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  5968                                  
  5969                                  _$M_DISPLAY_REPLACE:
  5970 00001053 31DB                    		xor	bx,bx
  5971                                  			 ; Is this the special case (convert to ASCII)
  5972                                  		;CMP	$M_SL.$M_S_ID,$M_SPECIAL_CASE-30H
  5973 00001055 807C0600                		cmp	byte [si+6],0
  5974 00001059 7511                    		jnz	short $MIF276
  5975                                  		;MOV	WORD PTR $M_RT.$M_TEMP_BUF[BX],$M_SPACE_HYP
  5976 0000105B C787[3A5D]202D          		mov	word [$M_TEMP_BUF+bx],2D20h ; Move in a " -"
  5977 00001061 43                      		inc	bx		; Increment count
  5978 00001062 43                      		inc	bx
  5979 00001063 C687[3A5D]20            		mov	byte [$M_TEMP_BUF+bx],' ' ; Move in a " "
  5980 00001068 43                      		inc	bx		; Increment count
  5981                                  				; Write out " - " to prepare for special case	
  5982 00001069 E8A400                  		call	_$M_FLUSH_BUF 
  5983                                  $MIF276:
  5984 0000106C 5D                      		pop	bp		; Remember the return address
  5985 0000106D 31DB                    		xor	bx,bx	; Use BX for buffer count
  5986 0000106F 31D2                    		xor	dx,dx	; Use DX for count of parms taken off the stack
  5987                                  		;MOV	$M_RT.$M_SIZE,CL
  5988 00001071 880E[305D]              		mov	[$M_SIZE],cl	; Save size to later clear stack
  5989                                  		;MOV	AL,BYTE PTR $M_SL.$M_S_MINW
  5990 00001075 8A4409                  		mov	al,[si+9]	; Get the minimum width
  5991 00001078 38C8                    		cmp	al,cl		; Do we need pad chars added?
  5992 0000107A 761E                    		jbe	short $MIF278	; No,
  5993                                  					; Yes,
  5994 0000107C 28C8                    		sub	al,cl		; Calculate how many pad chars are needed.
  5995 0000107E 88C6                    		mov	dh,al		; Save the number of pad characters
  5996                                  		;TEST	BYTE PTR $M_SL.$M_S_FLAG,Right_Align
  5997 00001080 F6440780                		test	byte [si+7],80h	; Was replaceable parm to be right aligned?
  5998 00001084 7414                    		jz	short $MIF278	; No,
  5999                                  $MDO280:
  6000 00001086 8A440A                  		mov	al,[si+0Ah]	; Yes,
  6001 00001089 8887[3A5D]              		mov	[$M_TEMP_BUF+bx],al ; Begin filling buffer with pad chars
  6002 0000108D 43                      		inc	bx
  6003 0000108E 83FB40                  		cmp	bx,64		; Is buffer full?
  6004 00001091 7503                    		jne	short $MIF281
  6005 00001093 E87A00                  		call	_$M_FLUSH_BUF	; Flush the buffer
  6006                                  $MIF281:
  6007 00001096 FECE                    		dec	dh		; Have we filled with enough pad chars?
  6008 00001098 75EC                    		jnz	short $MDO280	; No, next pad character
  6009                                  $MIF278:
  6010                                  		;CMP	BYTE PTR $M_SL.$M_S_MAXW,$M_UNLIM_W
  6011 0000109A 807C0800                		cmp	byte [si+8],0	; Is maximum width unlimited?
  6012 0000109E 740D                    		jz	short $MIF286	; Yes,
  6013 000010A0 384C08                  		cmp	[si+8],cl	; Will we exceed maximum width?
  6014 000010A3 7308                    		jnb	short $MIF286	; No,
  6015                                  					; Yes,
  6016 000010A5 2A4C08                  		sub	cl,[si+8]	; Calculate how many extra chars	
  6017 000010A8 88CA                    		mov	dl,cl		; Remember how many chars to pop off
  6018                                  		;MOV	CL,BYTE PTR $M_SL.$M_S_MAXW
  6019 000010AA 8A4C08                  		mov	cl,[si+8]	; Set new string length
  6020                                  $MIF286:
  6021 000010AD 09C9                    		or	cx, cx
  6022 000010AF 7424                    		jz	short $MIF290
  6023                                  $MDO291:				; Begin filling buffer with string
  6024                                  		;TEST	BYTE PTR $M_SL.$M_S_FLAG,NOT Char_Type AND $M_TYPE_MASK
  6025 000010B1 F644070F                		test	byte [si+7],0Fh
  6026 000010B5 750C                    		jnz	short $MIF292
  6027                                  		;TEST	$M_SL.$M_S_FLAG,Char_field_ASCIIZ AND $M_SIZE_MASK
  6028 000010B7 F6440710                		test	byte [si+7],10h	; Is this replace a ASCIIZ string?
  6029 000010BB 7406                    		jz	short $MIF292
  6030                                  					; Yes,
  6031 000010BD 268A05                  		mov	al,[es:di]	; Get first character from string
  6032 000010C0 47                      		inc	di		; Next character in string
  6033 000010C1 EB01                    		jmp	short $MEN292
  6034                                  $MIF292:
  6035 000010C3 58                      		pop	ax		; Get character in register
  6036                                  $MEN292:
  6037 000010C4 8887[3A5D]              		mov	[$M_TEMP_BUF+bx],al ; Move char into the buffer
  6038 000010C8 43                      		inc	bx		; Increase buffer count
  6039 000010C9 83FB40                  		cmp	bx,64		; Is buffer full?
  6040 000010CC 7503                    		jnz	short $MIF295
  6041 000010CE E83F00                  		call	_$M_FLUSH_BUF	; Flush the buffer
  6042                                  $MIF295:
  6043 000010D1 FEC9                    		dec	cl		; Have we completed replace?
  6044 000010D3 75DC                    		jnz	short $MDO291
  6045                                  $MIF290:
  6046                                  		;TEST	BYTE PTR $M_SL.$M_S_FLAG,Right_Align
  6047 000010D5 F6440780                		test	byte [si+7],80h ; Was replaceable parm to be left aligned?
  6048 000010D9 7518                    		jnz	short $MIF299	; No, (right aligned)
  6049                                  					; Yes,
  6050 000010DB 08F6                    		or	dh,dh		; Do we need pad chars added?	
  6051 000010DD 7414                    		jz	short $MIF299
  6052                                  $MDO301:
  6053                                  		;MOV	AL,BYTE PTR $M_SL.$M_S_PAD
  6054 000010DF 8A440A                  		mov	al,[si+0Ah]	; Begin filling buffer with pad chars
  6055 000010E2 8887[3A5D]              		mov	[$M_TEMP_BUF+bx],al ; Move in a pad char
  6056 000010E6 43                      		inc	bx
  6057 000010E7 83FB40                  		cmp	bx,64		; Is buffer full?
  6058 000010EA 7503                    		jnz	short $MIF302
  6059 000010EC E82100                  		call	_$M_FLUSH_BUF	; Flush the buffer
  6060                                  $MIF302:
  6061 000010EF FECE                    		dec	dh		; Have we filled with enough pad chars?
  6062 000010F1 75EC                    		jnz	short $MDO301
  6063                                  $MIF299:
  6064                                  		;TEST	BYTE PTR $M_SL.$M_S_FLAG,NOT Char_Type AND $M_TYPE_MASK
  6065 000010F3 F644070F                		test	byte [si+7],0Fh
  6066 000010F7 7506                    		jnz	short $MIF307
  6067                                  		;TEST	$M_SL.$M_S_FLAG,Char_field_ASCIIZ AND $M_SIZE_MASK	
  6068 000010F9 F6440710                		test	byte [si+7],10h	; Is this replace a ASCIIZ string?
  6069                                  		;jz	short $MIF307
  6070                                  		;jmp	short $MEN307
  6071 000010FD 750C                    		jnz	short $MEN307
  6072                                  $MIF307:
  6073 000010FF 08D2                    		or	dl,dl
  6074 00001101 7408                    		jz	short $MEN307
  6075                                  $MDO310:				; Clean Up stack using spare variable
  6076 00001103 8F06[345D]              		pop	word [$M_RETURN_ADDR]
  6077 00001107 FECA                    		dec	dl		; Are we done?
  6078 00001109 75F8                    		jnz	short $MDO310
  6079                                  $MEN307:
  6080 0000110B E80200                  		call	_$M_FLUSH_BUF	; Flush the buffer for the final time
  6081 0000110E 55                      		push	bp		; Restore the return address
  6082 0000110F C3                      		retn
  6083                                  
  6084                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  6085                                  ;;
  6086                                  ;;	PROC NAME: $M_FLUSH_BUFFER
  6087                                  ;;
  6088                                  ;;	FUNCTION: Display the contents of the temporary buffer
  6089                                  ;;	INPUTS: DI contains the number of bytes to display
  6090                                  ;;	OUTPUTS: BX reset to zero
  6091                                  ;;
  6092                                  ;;	REGS USED:
  6093                                  ;;
  6094                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  6095                                  
  6096                                  _$M_FLUSH_BUF:
  6097 00001110 51                      		push	cx		; Save changed regs
  6098 00001111 06                      		push	es
  6099 00001112 57                      		push	di
  6100 00001113 1E                      		push	ds
  6101 00001114 07                      		pop	es		; Set ES pointing to buffer
  6102 00001115 89D9                    		mov	cx,bx		; Set number of bytes to display
  6103 00001117 31DB                    		xor	bx,bx		; Reset buffer counter
  6104                                  		;LEA	DI,$M_RT.$M_TEMP_BUF
  6105 00001119 8D3E[3A5D]              		lea	di,[$M_TEMP_BUF] ; Reset buffer location pointer
  6106 0000111D E86101                  		call	_$M_DISPLAY_STRING ; Display the buffer
  6107 00001120 7204                    		jc	short $MIF314	; Error?
  6108 00001122 5F                      		pop	di		; No, Restore changed regs
  6109 00001123 07                      		pop	es
  6110 00001124 59                      		pop	cx
  6111 00001125 C3                      		retn
  6112                                  $MIF314:				; Yes,
  6113 00001126 83C406                  		add	sp,6		; Fix stack
  6114 00001129 F9                      		stc			; Set cf to indicate Error
  6115 0000112A C3                      		retn			; Return
  6116                                  
  6117                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  6118                                  ;;
  6119                                  ;;	PROC NAME: $M_CHAR_REPLACE
  6120                                  ;;
  6121                                  ;;	FUNCTION: Will prepare a single char or ASCIIZ string for replace
  6122                                  ;;	INPUTS: DS:SI points at corresponding SUBLIST
  6123                                  ;;		ES:DI contains the VALUE from SUBLIST
  6124                                  ;;	OUTPUTS: CX contains number of characters on stack
  6125                                  ;;		 Top of stack  --> Last character
  6126                                  ;;					. . .
  6127                                  ;;		 Bot of stack  --> First character
  6128                                  ;;
  6129                                  ;;	OTHER REGS Revised: AX
  6130                                  ;;
  6131                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  6132                                  
  6133                                  _$M_CHAR_REPLACE:
  6134 0000112B 5D                      		pop	bp		; Save return address
  6135                                  		;TEST	$M_SL.$M_S_FLAG,NOT Char_Field_Char AND $M_SIZE_MASK
  6136 0000112C F6440730                		test	byte [si+7],30h ; Was Character specified?	
  6137 00001130 7512                    		jnz	short $MDO321
  6138 00001132 268A05                  		mov	al,[es:di]	; Get the character
  6139 00001135 50                      		push	ax		; Put it on the stack
  6140 00001136 41                      		inc	cx		; Increase the count
  6141 00001137 E83102                  		call	_$M_IS_IT_DBCS	; Is this the first byte of a DB character
  6142 0000113A 7306                    		jnc	short $MIF318	; No,
  6143                                  					; Yes,
  6144 0000113C 268A4501                		mov	al,[es:di+1]	; Get the next character
  6145 00001140 50                      		push	ax		; Put it on the stack
  6146 00001141 F8                      		clc
  6147                                  $MIF318:				; No, it was an ASCIIZ string
  6148 00001142 EB0D                    		jmp	short $MEN317
  6149                                  $MDO321:
  6150 00001144 268A05                  		mov	al,[es:di]	; Get the character
  6151 00001147 08C0                    		or	al,al		; Is it the NULL?
  6152 00001149 7404                    		jz	short $MEN321
  6153 0000114B 47                      		inc	di		; Next character
  6154 0000114C 41                      		inc	cx		; Increment the count
  6155 0000114D EBF5                    		jmp	short $MDO321
  6156                                  $MEN321:
  6157 0000114F 29CF                    		sub	di,cx		; Set DI at the beginning of the string
  6158                                  $MEN317:
  6159 00001151 55                      		push	bp		; Restore return address
  6160 00001152 C3                      		retn
  6161                                  
  6162                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  6163                                  ;;
  6164                                  ;;	PROC NAME: $M_BIN2ASC_REPLACE
  6165                                  ;;
  6166                                  ;;	FUNCTION: Convert a signed or unsigned binary number to an ASCII string
  6167                                  ;;		  and prepare to display
  6168                                  ;;	INPUTS: DS:SI points at corresponding SUBLIST
  6169                                  ;;		ES:DI contains the VALUE from SUBLIST
  6170                                  ;;	OUTPUTS: CX contains number of characters on stack
  6171                                  ;;		 Top of stack  --> Last character
  6172                                  ;;					. . .
  6173                                  ;;		 Bot of stack  --> First character
  6174                                  ;;	OTHER REGS Revised: BX,DX,AX
  6175                                  ;;
  6176                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  6177                                  
  6178                                  _$M_BIN2ASC_REPLACE:
  6179 00001153 5D                      		pop	bp		; Save return address
  6180 00001154 31C0                    		xor	ax,ax		; Prepare for get binary value (LOW)
  6181                                  		;xor	dx,dx
  6182 00001156 99                      		cwd			; Prepare for get binary value (HIGH)
  6183                                  		;MOV	$M_RT.$M_DIVISOR,$M_BASE16
  6184 00001157 C706[385D]1000          		mov	word [$M_DIVISOR],16 ; Set default divisor
  6185 0000115D 31DB                    		xor	bx,bx		; Use BX as the NEG flag (if applicable)
  6186                                  		;TEST	$M_SL.$M_S_FLAG,NOT $M_BYTE AND $M_SIZE_MASK
  6187 0000115F F6440720                		test	byte [si+7],20h ; Was BYTE specified?
  6188 00001163 7524                    		jnz	short $MIF325	; No,
  6189                                  					; Yes,
  6190 00001165 268A05                  		mov	al,[es:di]	; Setup byte in AL
  6191                                  		;TEST	$M_SL.$M_S_FLAG,NOT Sgn_Bin_Type AND $M_TYPE_MASK
  6192 00001168 F644070D                		test	byte [si+7],0Dh ; Was Signed binary specified?
  6193 0000116C 750D                    		jnz	short $MIF326	; No,
  6194                                  					; Yes,
  6195 0000116E A880                    		test	al,80h		; Is this number negative?
  6196 00001170 7403                    		jz	short $MIF327	; No,
  6197                                  					; Yes,	
  6198 00001172 43                      		inc	bx		; Remember that it was negative		
  6199 00001173 247F                    		and	al,7Fh		; Make it positive
  6200                                  $MIF327:
  6201                                  		;MOV	$M_RT.$M_DIVISOR,$M_BASE10
  6202 00001175 C706[385D]0A00          		mov	word [$M_DIVISOR],10
  6203                                  $MIF326:
  6204                                  		;TEST	$M_SL.$M_S_FLAG,NOT Unsgn_Bin_Type AND $M_TYPE_MASK
  6205 0000117B F644070E                		test	byte [si+7],0Eh	; Was Unsigned binary specified?
  6206 0000117F 7506                    		jnz	short $MIF330	; No,
  6207 00001181 C706[385D]0A00          		mov	word [$M_DIVISOR],10 ; Yes,
  6208                                  $MIF330:
  6209 00001187 EB54                    		jmp	short $MIF345
  6210                                  $MIF325:
  6211                                  		;TEST	$M_SL.$M_S_FLAG,NOT $M_WORD AND $M_SIZE_MASK
  6212 00001189 F6440710                		test	byte [si+7],10h	; Was WORD specified?
  6213 0000118D 7526                    		jnz	short $MIF333	; No,
  6214                                  					; Yes,
  6215 0000118F 268B05                  		mov	ax,[es:di]	; Setup byte in AX
  6216                                  		;TEST	$M_SL.$M_S_FLAG,NOT Sgn_Bin_Type AND $M_TYPE_MASK
  6217 00001192 F644070D                		test	byte [si+7],0Dh	; Was Signed binary specified?
  6218 00001196 750F                    		jnz	short $MIF334	; No,
  6219                                  					; Yes,
  6220 00001198 F6C480                  		test	ah,80h		; Is this number negative?
  6221 0000119B 7404                    		jz	short $MIF335
  6222 0000119D 43                      		inc	bx		; Remember that it was negative
  6223 0000119E 80E47F                  		and	ah,7Fh		; Make it positive
  6224                                  $MIF335:
  6225 000011A1 C706[385D]0A00          		mov	word [$M_DIVISOR],10
  6226                                  $MIF334:
  6227                                  		;TEST	$M_SL.$M_S_FLAG,NOT Unsgn_Bin_Type AND $M_TYPE_MASK
  6228 000011A7 F644070E                		test	byte [si+7],0Eh	; Was Unsigned binary specified?
  6229                                  		;jnz	short $MIF338	; No,
  6230 000011AB 7530                    		jnz	short $MIF345	
  6231                                  				; Yes,
  6232                                  		; MOV	$M_RT.$M_DIVISOR,$M_BASE10
  6233 000011AD C706[385D]0A00          		mov	word [$M_DIVISOR],10
  6234                                  $MIF338:
  6235 000011B3 EB28                    		jmp	short $MIF345
  6236                                  $MIF333:
  6237 000011B5 268B05                  		mov	ax,[es:di]	; Setup Double word in DX:AX
  6238 000011B8 268B5502                		mov	dx,[es:di+2]
  6239                                  		;TEST	$M_SL.$M_S_FLAG,NOT Sgn_Bin_Type AND $M_TYPE_MASK
  6240 000011BC F644070D                		test	byte [si+7],0Dh ; Was Signed binary specified?
  6241 000011C0 750F                    		jnz	short $MIF341	; No,
  6242                                  					; Yes,
  6243 000011C2 F6C680                  		test	dh,80h		; Is this number negative?
  6244 000011C5 7404                    		jz	short $MIF342	; No,
  6245                                  					; yes,
  6246 000011C7 43                      		inc	bx		; Remember that it was negative		
  6247 000011C8 80E67F                  		and	dh,7Fh		; Make it positive
  6248                                  $MIF342:
  6249 000011CB C706[385D]0A00          		mov	word [$M_DIVISOR],10
  6250                                  $MIF341:
  6251                                  		;TEST	$M_SL.$M_S_FLAG,NOT Unsgn_Bin_Type AND $M_TYPE_MASK
  6252 000011D1 F644070E                		test	byte [si+7],0Eh ; Was Unsigned binary specified?
  6253 000011D5 7506                    		jnz	short $MIF345	; No,
  6254                                  					; Yes,
  6255 000011D7 C706[385D]0A00          		mov	word [$M_DIVISOR],10
  6256                                  $MIF345:
  6257                                  		; Thousand separator bit ? 
  6258                                  		; (This code portion is not existing in MSDOS 6.0 files.)
  6259 000011DD F6440740                		test	byte [si+7],40h ; Reserved bit (for MSDOS 6.0 sublist)
  6260 000011E1 7428                    		jz	short $MIF346
  6261 000011E3 50                      		push	ax
  6262 000011E4 52                      		push	dx
  6263 000011E5 B438                    		mov	ah,38h
  6264 000011E7 30C0                    		xor	al,al
  6265 000011E9 8D16[3A5D]              		lea	dx,[$M_TEMP_BUF]
  6266 000011ED CD21                    		int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
  6267                                  				; get current-country info ; (*)
  6268                                  				; DS:DX	-> buffer for returned info
  6269 000011EF 7305                    		jnc	short $MEN325
  6270 000011F1 C606[415D]2C            		mov	byte [$M_THOU_SEPARA],',' ; [$M_TEMP_BUF+7]
  6271                                  $MEN325:
  6272                                  			;DOS Country Info (DOS 3.0+) (*)
  6273                                  			
  6274                                  		      ;Offset  Size  Description
  6275                                  			;00    word  Date and time format
  6276                                  			;	0 = month day year, hh:mm:ss (USA)
  6277                                  			;	1 = day month year, hh:mm:ss (Europe)
  6278                                  			;	2 = year month day, hh:mm:ss (Japan)
  6279                                  			;02  5 bytes ASCIIZ currency symbol
  6280                                  			;07  2 bytes ASCIIZ thousands separator
  6281                                  			;09  2 bytes ASCIIZ decimal separator
  6282                                  			;0B  2 bytes ASCIIZ date separator
  6283                                  			;0D  2 bytes ASCIIZ time separator
  6284                                  			;0F    byte  Currency symbol format
  6285                                  			;	0 = symbol leads, without space
  6286                                  			;	1 = symbol follows, without space
  6287                                  			;	2 = symbol leads, one space
  6288                                  			;	3 = symbol follows, one space
  6289                                  			;	4 = symbol replace decimal separator
  6290                                  			;10    byte  Number of digits after decimal
  6291                                  			;11    byte  Time format
  6292                                  			;	Bit 0 = 0 12 hour clock
  6293                                  			;	      = 1 24 hour clock
  6294                                  			;12    dword Case map call address
  6295                                  			;16  2 bytes ASCIIZ data list separator
  6296                                  			;18  10 bytes Reserved
  6297                                  
  6298 000011F6 8A440A                  		mov	al,[si+10] ; get sublist pad_char
  6299 000011F9 89C7                    		mov	di,ax	; save pad_char
  6300 000011FB 5A                      		pop	dx
  6301 000011FC 58                      		pop	ax
  6302 000011FD C6440A2C                		mov	byte [si+10],',' ; set pad_char to ',' for using thous. sep.
  6303 00001201 E81400                  		call	_$M_CONVERT2ASC
  6304 00001204 89F8                    		mov	ax,di	; restore pad_char 
  6305 00001206 88440A                  		mov	[si+10],al
  6306 00001209 EB03                    		jmp	short $MIF347
  6307                                  $MIF346:			; Default number displaying (without thous. sep.)
  6308 0000120B E80A00                  		call	_$M_CONVERT2ASC
  6309                                  $MIF347:
  6310 0000120E 09DB                    		or	bx,bx		; Was number negative?
  6311 00001210 7404                    		jz	short $MIF349	; No,
  6312                                  					; Yes,
  6313 00001212 BA2D00                  		mov	dx,'-'		; Put "-" on the stack with the number
  6314 00001215 52                      		push	dx
  6315                                  $MIF349:
  6316 00001216 55                      		push	bp		; Restore return address
  6317 00001217 C3                      		retn
  6318                                  
  6319                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  6320                                  ;;
  6321                                  ;;	PROC NAME: $M_CONVERT2ASC
  6322                                  ;;
  6323                                  ;;	FUNCTION: Convert a binary number to a ASCII string
  6324                                  ;;	INPUTS: DX:AX contains the number to be converted
  6325                                  ;;		$M_RT_DIVISOR contains the divisor
  6326                                  ;;	OUTPUTS: CX contains the number of characters
  6327                                  ;;		Top of stack  --> Last character
  6328                                  ;;				     . . .
  6329                                  ;;		Bot of stack  --> First character
  6330                                  ;;	REGS USED:
  6331                                  ;;
  6332                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  6333                                  
  6334                                  		; CX = 0
  6335                                  _$M_CONVERT2ASC:
  6336 00001218 8F06[345D]              		pop	word [$M_RETURN_ADDR]	; Save Return Address
  6337 0000121C 31DB                    		xor	bx,bx		; Use BX as a swapping register
  6338 0000121E 93                      		xchg	ax,bx		; Initialize - Low Word in BX
  6339 0000121F 92                      		xchg	ax,dx		;            - High Word in AX
  6340                                  $MDO145:				; DO UNTIL Low Word becomes zero
  6341 00001220 F736[385D]              		div	word [$M_DIVISOR] ; Divide High Word by divisor
  6342 00001224 93                      		xchg	ax,bx		; Setup to divide Low Word using remainder
  6343                                  					;   and save reduced High Word in BX
  6344 00001225 F736[385D]              		div	word [$M_DIVISOR] ; Divide Low Word by divisor
  6345 00001229 83FA09                  		cmp	dx,9		; Make a digit of the remainder	
  6346 0000122C 7605                    		jbe	short $MIF146	; IF 10 to 15,
  6347 0000122E 80C237                  		add	dl,37h ; '7'	;    Make A to F ASCII
  6348 00001231 EB03                    		jmp	short $MEN146
  6349                                  $MIF146:				; IF 0 to 9,
  6350 00001233 80C230                  		add	dl,'0'		;    Make 0 to 9 ASCII
  6351                                  $MEN146:
  6352 00001236 52                      		push	dx		; Save the digit on the stack
  6353 00001237 41                      		inc	cx		; Count that digit
  6354 00001238 09C0                    		or	ax,ax		; Are we done?
  6355 0000123A 7504                    		jnz	short $MLL149
  6356 0000123C 09DB                    		or	bx,bx		; AX and BX must be ZERO!!
  6357 0000123E 7439                    		jz	short $MEN145
  6358                                  $MLL149:
  6359 00001240 83F903                  		cmp	cx,3		; Are we at the first thousands mark
  6360 00001243 750D                    		jne	short $MIF150	; No,
  6361                                  					; Yes,
  6362                                  		;CMP	$M_SL.$M_S_PAD,$M_COMMA
  6363 00001245 807C0A2C                		cmp	byte [si+10],',' ; Is the pad character a comma?
  6364 00001249 7505                    		jne	short $MIF151	; No,
  6365                                  					; Yes,
  6366 0000124B FF36[415D]              		push	word [$M_THOU_SEPARA] ; Insert a thousand separator
  6367 0000124F 41                      		inc	cx
  6368                                  $MIF151:
  6369 00001250 EB22                    		jmp	short $MEN150
  6370                                  $MIF150:
  6371 00001252 83F907                  		cmp	cx,7		; Are we at the second thousands mark
  6372 00001255 750D                    		jne	short $MIF154
  6373                                  					; Yes,
  6374 00001257 807C0A2C                		cmp	byte [si+10],','  ; Is the pad character a comma?
  6375 0000125B 7505                    		jne	short $MIF155
  6376                                  					; Yes,
  6377 0000125D FF36[415D]              		push	word [$M_THOU_SEPARA] ; Insert a thousand separator
  6378 00001261 41                      		inc	cx
  6379                                  $MIF155:
  6380 00001262 EB10                    		jmp	short $MEN150
  6381                                  $MIF154:
  6382 00001264 83F90B                  		cmp	cx,11		; Are we at the third thousands mark
  6383 00001267 750B                    		jne	short $MEN150	; No,
  6384                                  					; Yes,
  6385 00001269 807C0A2C                		cmp	byte [si+10],',' ; Is the pad character a comma?
  6386 0000126D 7505                    		jnz	short $MEN150	; No,
  6387                                  					; Yes,
  6388 0000126F FF36[415D]              		push	word [$M_THOU_SEPARA] ; Insert a thousand separator
  6389 00001273 41                      		inc	cx
  6390                                  $MEN150:
  6391 00001274 93                      		xchg	ax,bx		; Setup to divide the reduced High Word
  6392                                  					;   and Revised Low Word
  6393 00001275 31D2                    		xor	dx,dx		; Reset remainder
  6394 00001277 EBA7                    		jmp	short $MDO145	; NEXT
  6395                                  $MEN145:
  6396 00001279 31C0                    		xor	ax,ax		; Reset remainder
  6397                                  		;xor	dx,dx
  6398 0000127B 99                      		cwd			; Reset remainder
  6399 0000127C FF36[345D]              		push	word [$M_RETURN_ADDR] ;	Restore Return Address
  6400 00001280 C3                      		retn			; Return
  6401                                  
  6402                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  6403                                  ; 
  6404                                  ;;
  6405                                  ;;	PROC NAME: $M_DISPLAY_STRING
  6406                                  ;;
  6407                                  ;;	FUNCTION:  Will display or write string
  6408                                  ;;	INPUTS:    ES:DI points to beginning of message
  6409                                  ;;		   CX contains the length of string to write (if applicable)
  6410                                  ;;	OUTPUTS:   None
  6411                                  ;;	REGS Revised: None
  6412                                  ;;
  6413                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  6414                                  
  6415                                  _$M_DISPLAY_STRING:
  6416 00001281 50                      		push	ax
  6417 00001282 53                      		push	bx
  6418 00001283 52                      		push	dx
  6419                                  		;MOV	BX,$M_RT.$M_HANDLE
  6420 00001284 8B1E[2E5D]              		mov	bx,[$M_HANDLE]	; Retrieve handle
  6421 00001288 83FBFF                  		cmp	bx,0FFFFh ; -1	; Was there a handle specified?
  6422                                  		;jne	short $MIF107
  6423 0000128B 741C                    		je	short $MIF107 ; * ; No, display $ terminated string
  6424                                  		;call	_$M_DISPLAY_$_STRING
  6425                                  		;;jmp	short $MEN107
  6426                                  ;$MIF107:
  6427 0000128D E86E00                  		call	_$M_DISPLAY_H_STRING ; Yes, display string to handle	
  6428 00001290 730B                    		jnc	short $MIF110 ; *  ; Was there an error?
  6429                                  $MEN107:
  6430                                  		;jnc	short $MIF110
  6431                                  					; Yes,
  6432 00001292 B459                    		mov	ah,59h		; Get extended error
  6433 00001294 BB0000                  		mov	bx,0
  6434 00001297 CD21                    		int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
  6435                                  				; BX = version code (0000h for DOS 3.x)
  6436 00001299 30E4                    		xor	ah,ah		; Clear AH
  6437 0000129B EB07                    		jmp	short $MEN111 ; *
  6438                                  		;add	sp,6
  6439                                  		;stc
  6440                                  		;;jmp	short $MIF112
  6441                                  		;retn ; *
  6442                                  ;$MIF110:
  6443                                  		;cmp	bx,0FFFFh ; -1
  6444                                  		;je	short $MIF112
  6445                                  $MIF110: ; *
  6446                                  		; BX <> -1
  6447 0000129D 39C8                    		cmp	ax,cx		; Was it ALL written?
  6448 0000129F 740B                    		je	short $MIF112	; Yes
  6449                                  					; No,
  6450 000012A1 E8A800                  		call	_$M_GET_EXT_ERR_39 ; Set Extended error
  6451                                  $MEN111: ; *		
  6452 000012A4 83C406                  		add	sp,6		; Clean up stack
  6453 000012A7 F9                      		stc			; Flag that there was an error
  6454 000012A8 C3                      		retn ; *
  6455                                  
  6456                                  $MIF107: ; *
  6457                                  		; BX = -1	; Display $ terminated string
  6458 000012A9 E80400                  		call	_$M_DISPLAY_$_STRING ; *
  6459                                  		;jc	short $MEN107	     ; *	
  6460                                  $MIF112:
  6461                                  		;jc	short $MIF117
  6462 000012AC 5A                      		pop	dx		; Restore regs
  6463 000012AD 5B                      		pop	bx
  6464 000012AE 58                      		pop	ax
  6465                                  $MIF117:
  6466 000012AF C3                      		retn
  6467                                  
  6468                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  6469                                  ;;
  6470                                  ;;	PROC NAME: $M_DISPLAY_$_STRING
  6471                                  ;;
  6472                                  ;;	FUNCTION:  Will display a $ terminated string
  6473                                  ;;	INPUTS:    ES:DI points to beginning of message text (not the length)
  6474                                  ;;	OUPUTS:    None
  6475                                  ;;	REGS USED: AX,DX
  6476                                  ;;
  6477                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  6478                                  
  6479                                  _$M_DISPLAY_$_STRING:
  6480 000012B0 1E                      		push	ds
  6481 000012B1 06                      		push	es
  6482 000012B2 1F                      		pop	ds
  6483                                  
  6484 000012B3 83F901                  		cmp	cx,1		; Is this a single character?
  6485 000012B6 751B                    		jne	short $MIF119	; No,
  6486                                  
  6487 000012B8 B402                    		mov	ah,2
  6488 000012BA 268A15                  		mov	dl,[es:di]
  6489 000012BD CD21                    		int	21h	; DOS -	DISPLAY	OUTPUT
  6490                                  				; DL = character to send to standard output
  6491 000012BF 1F                      		pop	ds
  6492 000012C0 88D0                    		mov	al,dl
  6493 000012C2 E8A600                  		call	_$M_IS_IT_DBCS
  6494 000012C5 1E                      		push	ds
  6495 000012C6 06                      		push	es
  6496 000012C7 1F                      		pop	ds
  6497                                  		;jnc	short $MIF120
  6498 000012C8 7317                    		jnc	short $MEN119 ; *
  6499 000012CA 268A5501                		mov	dl,[es:di+1]
  6500 000012CE CD21                    		int	21h		; DOS -
  6501 000012D0 F8                      		clc
  6502                                  ;$MIF120:
  6503 000012D1 EB0E                    		jmp	short $MEN119
  6504                                  $MIF119:
  6505                                  		;mov	ah,2		; DOS Function to display CHARACTER
  6506                                  ;$MDO123:
  6507 000012D3 09C9                    		or	cx,cx		; Are there any left to display?
  6508 000012D5 740A                    		jz	short $MEN119	; No, (CF=0 ; *) 
  6509                                  				
  6510 000012D7 B402                    		mov	ah,2 ; *
  6511                                  					; Yes,	
  6512                                  $MDO123: ; *
  6513 000012D9 268A15                  		mov	dl,[es:di] 	; Get the character
  6514 000012DC CD21                    		int	21h	; DOS -	DISPLAY	OUTPUT
  6515                                  				; DL = character to send to standard output
  6516 000012DE 47                      		inc	di		; Set pointer to next character
  6517 000012DF E2F8                    		loop	$MDO123
  6518                                  $MEN119:
  6519                                  		;clc	; *
  6520 000012E1 1F                      		pop	ds
  6521                                  		; cf = 0
  6522 000012E2 C3                      		retn
  6523                                  
  6524                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  6525                                  ;
  6526                                  ; Scan_ctrlZ : This routine looks through the string to be printed and 
  6527                                  ; truncates it at the Ctrl-Z if any present.
  6528                                  ;
  6529                                  ;	ENTRY:	ds:dx = String to be displayed
  6530                                  ;		cx = number of chars to be displayed
  6531                                  ;
  6532                                  ;	EXIT:	cx = number of chars to be displayed
  6533                                  ;
  6534                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  6535                                  
  6536                                  Scan_CtrlZ:
  6537 000012E3 57                      		push	di
  6538 000012E4 50                      		push	ax
  6539 000012E5 06                      		push	es
  6540 000012E6 53                      		push	bx
  6541 000012E7 89D7                    		mov	di,dx
  6542 000012E9 1E                      		push	ds
  6543 000012EA 07                      		pop	es		; es:di points at string
  6544 000012EB 89CB                    		mov	bx,cx		; save current count
  6545 000012ED B01A                    		mov	al,1Ah
  6546 000012EF FC                      		cld
  6547 000012F0 F2AE                    		repne scasb		; find first Ctrl-Z
  6548 000012F2 7503                    		jnz	short noCtrlZ	; no CtrlZ found in string
  6549 000012F4 29CB                    		sub	bx,cx		; bx = new count to display
  6550 000012F6 4B                      		dec	bx
  6551                                  noCtrlZ:
  6552 000012F7 89D9                    		mov	cx,bx		; cx = actual display count
  6553 000012F9 5B                      		pop	bx
  6554 000012FA 07                      		pop	es
  6555 000012FB 58                      		pop	ax
  6556 000012FC 5F                      		pop	di
  6557 000012FD C3                      		retn
  6558                                  
  6559                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  6560                                  ;;
  6561                                  ;;	PROC NAME: $M_DISPLAY_H_STRING
  6562                                  ;;
  6563                                  ;;	FUNCTION:  Will display a string to a specified handle
  6564                                  ;;	INPUTS:    ES:DI points to beginning of message
  6565                                  ;;		   CX contains the number of bytes to write
  6566                                  ;;		   BX contains the handle to write to
  6567                                  ;;	OUPUTS:    None
  6568                                  ;;	REGS USED: AX,DX
  6569                                  ;;
  6570                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  6571                                  
  6572                                  _$M_DISPLAY_H_STRING:
  6573 000012FE 31C0                    		xor	ax,ax		; Set number of bytes written to 0
  6574 00001300 09C9                    		or	cx,cx		; For performance, don't write if not necessary
  6575 00001302 7447                    		jz	short $MIF127	; Any chars to write?
  6576 00001304 1E                      		push	ds		; Yes,
  6577 00001305 06                      		push	es
  6578 00001306 1F                      		pop	ds		; Set DS to segment of message text
  6579                                  					; DOS function to write to a handle
  6580 00001307 B440                    		mov	ah,40h ; DOS_WRITE_HANDLE
  6581 00001309 89FA                    		mov	dx,di		; Pointer to data to write
  6582 0000130B 83F901                  		cmp	cx,1		; Is this a single character?
  6583 0000130E 7522                    		jne	short $MIF128
  6584                                  					; Yes,
  6585 00001310 CD21                    		int	21h	; DOS -	2+ - WRITE TO FILE WITH	HANDLE
  6586                                  				; BX = file handle, CX = number	of bytes to write,
  6587                                  				; DS:DX -> buffer
  6588 00001312 1F                      		pop	ds		; Restore DS
  6589 00001313 50                      		push	ax
  6590 00001314 268A05                  		mov	al,[es:di]	; Get the character
  6591 00001317 E85100                  		call	_$M_IS_IT_DBCS	; Is this the first byte of a DB character
  6592 0000131A 58                      		pop	ax
  6593 0000131B 1E                      		push	ds
  6594 0000131C 06                      		push	es		; Set DS to segment of message text
  6595 0000131D 1F                      		pop	ds
  6596 0000131E 7306                    		jnc	short $MIF129
  6597 00001320 F8                      		clc			; Clear the DBCS indicator		
  6598 00001321 B440                    		mov	ah,40h		; DOS function to write to a handle
  6599 00001323 42                      		inc	dx		; Point to next character
  6600 00001324 CD21                    		int	21h	; DOS -	2+ - WRITE TO FILE WITH	HANDLE
  6601                                  				; BX = file handle, CX = number	of bytes to write, 
  6602                                  				; DS:DX -> buffer
  6603                                  $MIF129:
  6604                                  
  6605                                  ; If the single char happened to be a Ctrl-Z, the dos write would return
  6606                                  ; 0 chars written making the caller think there was an error writing. To 
  6607                                  ; avoid this, we check if the single char was a Ctrl-Z and if so, return that
  6608                                  ; the char was written, thus fooling the caller.
  6609                                  
  6610 00001326 9C                      		pushf			 ; save flags
  6611 00001327 26803D1A                		cmp	byte [es:di],1Ah ; is char a Ctrl-Z?
  6612 0000132B 7502                    		jne	short $MEN129	 ; no, continue
  6613 0000132D 89C8                    		mov	ax,cx		 ; yes, fake as if it was written
  6614                                  $MEN129:
  6615                                  		;jmp	short _$M_Popf
  6616 0000132F 9D                      		popf	; *		 ; restore flags
  6617 00001330 EB18                    		jmp	short $MEN128
  6618                                  ;_$M_Mret:
  6619                                  ;		iret
  6620                                  ;_$M_Popf:
  6621                                  		;push	cs
  6622                                  		;call	_$M_Mret
  6623                                  		;jmp	short $MEN128
  6624                                  $MIF128:
  6625                                  
  6626                                  ; Prescan the string looking for Ctrl-Z. We terminate the message the moment 
  6627                                  ; we hit a Ctrl-Z. cx will contain the number of characters to be printed.
  6628                                  
  6629 00001332 55                      		push	bp
  6630 00001333 51                      		push	cx
  6631 00001334 E8ACFF                  		call	Scan_CtrlZ	; cx = count without Ctrl-Z
  6632 00001337 89CD                    		mov	bp,cx		; store no ^Z count in bp 
  6633 00001339 59                      		pop	cx		; get old count back
  6634                                  				; Write String at DS:SI to handle
  6635 0000133A CD21                    		int	21h	; DOS -
  6636 0000133C 720B                    		jc	short m_cnt_ok	;error, return with carry set
  6637                                  chk_count:				;no error, adjust return count
  6638                                  
  6639                                  ; If we are writing to con and there is a Ctrl-Z in the string, the
  6640                                  ; return count will be much less and if this returns to the caller we can get
  6641                                  ; spurious error messages. We check here if the count returned is same as
  6642                                  ; original count or same as the count if we stop at Ctrl-Z. In the second
  6643                                  ; case, we fake it as if all bytes have been written. If the return count
  6644                                  ; does not match either count, then we had some other disk error (such as
  6645                                  ; insufficient disk space) and we pass it through
  6646                                  
  6647 0000133E 39C1                    		cmp	cx,ax		; have all bytes been written?
  6648 00001340 7407                    		je	short m_cnt_ok	; there was an error writing
  6649 00001342 39C5                    		cmp	bp,ax		; count = Ctrl-Z count?
  6650 00001344 F8                      		clc			; no error either way
  6651 00001345 7502                    		jne	short m_cnt_ok	; no, pass it through
  6652 00001347 89C8                    		mov	ax,cx		; return old count
  6653                                  m_cnt_ok:
  6654 00001349 5D                      		pop	bp
  6655                                  $MEN128:
  6656 0000134A 1F                      		pop	ds
  6657                                  $MIF127:
  6658 0000134B C3                      		retn
  6659                                  
  6660                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  6661                                  ;;
  6662                                  ;;	PROC NAME: $M_GET_EXT_ERR_39
  6663                                  ;;
  6664                                  ;;	FUNCTION:  Will set registers for extended error #39
  6665                                  ;;	INPUTS:    None
  6666                                  ;;	OUPUTS:    AX,BX,CX set
  6667                                  ;;	REGS USED:
  6668                                  ;;
  6669                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  6670                                  
  6671                                  _$M_GET_EXT_ERR_39:
  6672 0000134C B82700                  		mov	ax,39
  6673                                  					; Bug!? 12/11/2018 (Erdogan Tan)
  6674                                  		;MOV	BX,(ERROR_CLASS_39 SHR 8) + ACTION_39  ;!?
  6675                                  						; BH = 1, BL = 4 ; !?
  6676                                  		;MOV	BX,(ERROR_CLASS_39 SHL 8) + ACTION_39
  6677                                  		;mov	bx,4
  6678 0000134F BB0401                  		mov	bx,0104h ; * BugFix
  6679                                  		;MOV	CH,LOCUS_39
  6680 00001352 B501                    		mov	ch,1
  6681 00001354 C3                      		retn
  6682                                  
  6683                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  6684                                  ;;
  6685                                  ;;	PROC NAME: $M_ADD_CRLF
  6686                                  ;;
  6687                                  ;;	FUNCTION:  Will decide whether to display a CRLF
  6688                                  ;;	INPUTS:    DX contains the Input/Class requested
  6689                                  ;;	OUTPUTS:   None
  6690                                  ;;	REGS Revised: CX,ES,DI
  6691                                  ;;
  6692                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  6693                                  
  6694                                  _$M_ADD_CRLF:				; Is it a utility message? 
  6695 00001355 80FEFF                  		cmp	dh,0FFh ; UTILITY_MSG_CLASS
  6696 00001358 7410                    		je	short $MIF135	; Yes,
  6697                                  					; No,
  6698 0000135A F6C680                  		test	dh,80h ; $M_NO_CRLF_MASK ; Are we to supress the CR LF?
  6699 0000135D 750B                    		jnz	short $MIF135 ; Yes,
  6700                                  				      ; No,	
  6701 0000135F 1E                      		push	ds
  6702 00001360 07                      		pop	es		; Set ES to data segment
  6703                                  		;lea	di,[$M_CRLF]
  6704 00001361 BF[315D]                		mov	di,$M_CRLF	; Point at CRLF message
  6705 00001364 B90200                  		mov	cx,2		; Set the message size
  6706 00001367 E817FF                  		call	_$M_DISPLAY_STRING ; Display the CRLF
  6707                                  $MIF135:
  6708 0000136A C3                      		retn
  6709                                  
  6710                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  6711                                  ;;
  6712                                  ;;	PROC NAME: $M_IS_IT_DBCS
  6713                                  ;;
  6714                                  ;;	FUNCTION:  Will decide whether character is Single or Double Byte
  6715                                  ;;	INPUTS:    AL contains the byte to be checked
  6716                                  ;;	OUPUTS:    Carry flag = 0 if byte is NOT in DBCS range
  6717                                  ;;		   Carry flag = 1 if byte IS in DBCS range
  6718                                  ;;	REGS USED: All restored
  6719                                  ;;
  6720                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  6721                                  
  6722                                  _$M_IS_IT_DBCS:
  6723 0000136B 06                      		push	es		; Save ES, DI registers
  6724 0000136C 57                      		push	di
  6725                                  		;LES	DI,$M_RT.$M_DBCS_VEC
  6726 0000136D C43E[2A5D]              		les	di,[$M_DBCS_VEC] ; 15/11/2018
  6727 00001371 09FF                    		or	di,di		; Was the DBCS vector set?
  6728 00001373 7418                    		jz	short $MIF138
  6729                                  $MDO139:
  6730                                  		;CMP	WORD PTR ES:[DI],$M_DBCS_TERM
  6731 00001375 26833D00                		cmp	word [es:di],0	; Is this the terminating flag?
  6732                                  		;clc
  6733 00001379 7412                    		je	short $MIF138	; Yes,
  6734                                  					; No,
  6735 0000137B 263A05                  		cmp	al,[es:di]	; Does the character fall in the DBCS range?
  6736 0000137E 7209                    		jb	short $MIF141
  6737 00001380 263A4501                		cmp	al,[es:di+1]	; Does the character fall in the DBCS range?
  6738 00001384 7703                    		ja	short $MIF141
  6739 00001386 F9                      		stc			; Yes, Set carry flag
  6740                                  		; Bug!: Never returns with cf = 1 ; 12/11/2018 (Erdogan Tan) ; *
  6741 00001387 EB04                    		jmp	short $MIF138 ; * BugFix
  6742                                  $MIF141:
  6743 00001389 47                      		inc	di		; Go to next vector
  6744 0000138A 47                      		inc	di
  6745 0000138B EBE8                    		jmp	short $MDO139
  6746                                  $MIF138:
  6747 0000138D 5F                      		pop	di
  6748 0000138E 07                      		pop	es
  6749 0000138F C3                      		retn
  6750                                  
  6751                                  ; ----------------------------------------------------------------------------
  6752                                  
  6753                                  ;_$M_CLS_A:	; proc far
  6754                                  		;push	cs
  6755                                  		;pop	es
  6756                                  		;lea	di,[CLASS_A_msg_tbl]
  6757                                  		;mov	di,CLASS_A_msg_tbl
  6758                                  		;add	cx,278
  6759                                  		;;retf
  6760                                  		;retn
  6761                                  
  6762                                  ; ----------------------------------------------------------------------------
  6763                                  
  6764                                  ;_$M_CLS_B:	; proc far
  6765                                  		;push	cs
  6766                                  		;pop	es
  6767                                  		;lea	di,[CLASS_B_msg_tbl]
  6768                                  		;mov	di,CLASS_B_msg_tbl
  6769                                  		;add	cx,189
  6770                                  		;;retf
  6771                                  		;retn
  6772                                  
  6773                                  ; ----------------------------------------------------------------------------
  6774                                  
  6775                                  ;_$M_CLS_1:	;proc far
  6776                                  		;push	cs
  6777                                  		;pop	es
  6778                                  		;lea	di,[CLASS_1_msg_tbl]
  6779                                  		;mov	di,CLASS_1_msg_tbl
  6780                                  		;add	cx,32
  6781                                  		;;retf
  6782                                  		;retn
  6783                                  
  6784                                  ; ----------------------------------------------------------------------------
  6785                                  
  6786                                  ;_$M_CLS_2:	;proc far
  6787                                  		;push	cs
  6788                                  		;pop	es
  6789                                  		;lea	di,[CLASS_2_msg_tbl]
  6790                                  		;mov	di,CLASS_2_msg_tbl
  6791                                  		;add	cx,29
  6792                                  		;;retf
  6793                                  		;retn
  6794                                  
  6795                                  ; ----------------------------------------------------------------------------
  6796                                  
  6797                                  ; ----------------------------------------------------------------------------
  6798                                  ; fdparse.c (FDISK, MSDOS 6.0, 1991)	
  6799                                  ; ----------------------------------------------------------------------------
  6800                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 14/11/2018)
  6801                                  
  6802                                  ;/************************************************************************/
  6803                                  ;/* Parse_Message                - This routine will print only those    */
  6804                                  ;/*                                messages that require 1 replaceable   */
  6805                                  ;/*                                parm.                                 */
  6806                                  ;/*                                                                      */
  6807                                  ;/*      Inputs  : Msg_Num       - number of applicable message          */
  6808                                  ;/*                Handle        - display type                          */
  6809                                  ;/*                Message_Type  - type of message to display            */
  6810                                  ;/*                Replace_Parm  - pointer to parm to replace            */
  6811                                  ;/*                                                                      */
  6812                                  ;/*      Outputs : message                                               */
  6813                                  ;/*                                                                      */
  6814                                  ;/*      Date    : 03/28/88                                              */
  6815                                  ;/*      Version : DOS 4.00                                              */
  6816                                  ;/************************************************************************/
  6817                                  
  6818                                  ;void Parse_msg(Msg_Num,Handle,Message_Type) 
  6819                                  
  6820                                  	;int             Msg_Num;
  6821                                  	;int             Handle;
  6822                                  	;unsigned char   Message_Type; 
  6823                                  
  6824                                  Parse_msg:
  6825                                  	; char    far *Cmd_Ptr; 
  6826                                  
  6827                                  	;%define _Cmd_Ptr    bp-4
  6828                                  	%define Msg_Num      bp+4
  6829                                  	%define	Handle       bp+6
  6830                                  	%define	Message_Type bp+8
  6831                                  
  6832 00001390 55                      		push	bp
  6833 00001391 89E5                    		mov	bp,sp
  6834                                  		;sub	sp,4
  6835                                  		;sub	sp-2 ; *
  6836                                  		;mov	ax,segregs_es
  6837                                  		;push	ax
  6838                                  		;call	segread ; segread(&segregs);  
  6839                                  		;pop	bx
  6840                                  
  6841                                  		;FP_SEG(Cmd_Ptr) = segregs.ds;
  6842                                  		;FP_OFF(Cmd_Ptr) = regs.x.si;
  6843                                  		;*Cmd_Ptr        = '\0';
  6844                                  
  6845                                  		;;mov	ax,[segregs_ds]
  6846                                  		;;mov	[_Cmd_Ptr+2],ax
  6847                                  		;mov	[_Cmd_Ptr+2],ds
  6848                                  		;;mov	ax,[regs_x_si]
  6849                                  		;;mov	[_Cmd_Ptr],ax
  6850                                  		;mov	[_Cmd_Ptr],si
  6851                                  		;les	bx,[_Cmd_Ptr]
  6852                                  		;mov	byte [es:bx],0
  6853                                  		;mov	bx,sp ; *
  6854                                  		;mov	byte [bx],0 ; *
  6855 00001393 C60400                  		mov	byte [si],0
  6856                                  
  6857                                  		;FP_SEG(sublistp[0].value) = segregs.ds;
  6858                                  		;FP_OFF(sublistp[0].value) = Parse_Ptr;     
  6859                                  
  6860                                  		;mov	ax,[segregs_ds]
  6861                                  		;mov	[sublistp_value_seg],ax
  6862 00001396 8C1E[EEA0]              		mov	[sublistp_value_seg],ds ; [sublistp_value+2]
  6863 0000139A A1[EECB]                		mov	ax,[Parse_Ptr]
  6864 0000139D A3[ECA0]                		mov	[sublistp_value],ax
  6865                                  
  6866                                  		;sublistp[0].size      = Sublist_Length;
  6867                                  		;sublistp[0].reserved  = Reserved;
  6868                                  		;sublistp[0].id        = 0;
  6869                                  		;sublistp[0].flags     = Char_Field_ASCIIZ+Left_Align;
  6870                                  		;sublistp[0].max_width = 80;
  6871                                  		;sublistp[0].min_width = 01;
  6872                                  		;sublistp[0].pad_char  = Blank;
  6873                                  
  6874 000013A0 C606[EAA0]0B            		mov	byte [sublistp_size],11
  6875 000013A5 C606[F1A0]10            		mov	byte [sublistp_flags],10h ; Char_Field_ASCIIZ+Left_Align
  6876 000013AA C606[F2A0]50            		mov	byte [sublistp_max_width],80
  6877 000013AF C606[F3A0]01            		mov	byte [sublistp_min_width],1
  6878 000013B4 C606[F4A0]20            		mov	byte [sublistp_pad_char], ' '
  6879                                  
  6880                                  		;regs.x.ax = Msg_Num;
  6881                                  		;regs.x.bx = Handle;
  6882                                  		;regs.x.cx = SubCnt1;
  6883                                  		;regs.h.dl = No_Input;
  6884                                  		;regs.h.dh = Message_Type;
  6885                                  		;regs.x.si = (unsigned int)&sublistp[0];   
  6886                                  
  6887                                  		;mov	ax,[Msg_Num]
  6888                                  		;mov	[regs_x_ax],ax
  6889                                  		;mov	ax,[Handle]
  6890                                  		;mov	[regs_x_bx],ax
  6891                                  		;mov	[regs_x_cx],1
  6892 000013B9 28C0                    		sub	al,al ; 0
  6893 000013BB A2[EBA0]                		mov	[sublistp_res],al ; 0
  6894 000013BE A2[F0A0]                		mov	[sublistp_id],al ; 0
  6895                                  		;mov	[regs_x_dx],al
  6896                                  		;mov	al,[Message_Type]
  6897                                  		;mov	[regs_x_dx+1],al
  6898                                  		;mov	word [regs_x_si],sublistp_size
  6899                                  		;mov	ax,regs ; regs_x_ax
  6900                                  		;push	ax
  6901                                  		;push	ax
  6902                                  		;call	sysdispmsg  ; sysdispmsg(&regs,&regs);
  6903                                  		;pop	bx
  6904                                  		;pop	bx
  6905                                  
  6906 000013C1 57                      		push	di ; *
  6907 000013C2 56                      		push	si ; **
  6908                                  
  6909 000013C3 8B4604                  		mov	ax,[Msg_Num]	  ; ***
  6910 000013C6 8B5E06                  		mov	bx,[Handle]	  ; ***
  6911 000013C9 B90100                  		mov	cx,1 ; SubCnt1	  ; ***   
  6912 000013CC 8A7608                  		mov	dh,[Message_Type] ; ***
  6913                                  		;mov	dl,0 ; No_Input   ; ***
  6914 000013CF 28D2                    		sub	dl,dl
  6915 000013D1 BE[EAA0]                		mov	si,sublistp_size  ; ***
  6916                                  
  6917 000013D4 E836FA                  		call	SYSDISPMSG ; *, **, ***
  6918                                  
  6919 000013D7 5E                      		pop	si ; **
  6920 000013D8 5F                      		pop	di ; *
  6921                                  
  6922 000013D9 89EC                    		mov	sp,bp
  6923 000013DB 5D                      		pop	bp
  6924 000013DC C3                      		retn	; return;
  6925                                  
  6926                                  ; ----------------------------------------------------------------------------
  6927                                  ; fdisk.c (FDISK, MSDOS 6.0, 1991)	
  6928                                  ; ----------------------------------------------------------------------------
  6929                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 15/11/2018)
  6930                                  
  6931                                  ;/*  */
  6932                                  ; ----------------------------------------------------------------------------
  6933                                  ;char check_valid_environment()
  6934                                  
  6935                                  check_valid_environment:
  6936                                  			; /* See if the net is there */
  6937 000013DD B800B8                  		mov	ax,0B800h ; NETWORK - INSTALLATION CHECK
  6938 000013E0 CD2F                    		int	2Fh
  6939                                  			;Return:
  6940                                  			;  AL = status
  6941                                  			;	00h -> not installed
  6942                                  			;	>00h -> installed
  6943                                  			;  BX = installed component flags (test in this order!)
  6944                                  			;	bit 6   server
  6945                                  			;	bit 2   messenger
  6946                                  			;	bit 7   receiver
  6947                                  			;	bit 3   redirector
  6948                                  			;	bit 1   LANPUP (LANtastic 4.0)
  6949                                  		
  6950                                  		; /* See if server is loaded, otherwise okay */
  6951 000013E2 20C0                    		and	al,al
  6952 000013E4 741E                    		jz	short cve_true ; not installed, ok
  6953                                  
  6954 000013E6 F6C340                  		test	bl,40h  ; bit 6, server
  6955 000013E9 7419                    		jz	short cve_true ; not server running, ok
  6956                                  		
  6957                                  		; Error ! 
  6958                                  		; (FDISK must not be used in a network while the server is running.)
  6959                                  		;mov	al,0FFh
  6960 000013EB B8FF00                  		mov	ax,0FFh ; msgclass = 0FFh, UTILTY_MSG_CLASS
  6961 000013EE 50                      		push	ax
  6962 000013EF 28C0                    		sub	al,al ; 0
  6963 000013F1 A2[13C4]                		mov	[no_fatal_error],al ; FALSE
  6964 000013F4 50                      		push	ax	; msginput = 0, (noinput)
  6965                                  		;sub	ax,ax
  6966 000013F5 50                      		push	ax	; msgsub = 0,  (nosubptr)
  6967 000013F6 50                      		push	ax	; msgparms = 0, (nosubcnt)
  6968 000013F7 B002                    		mov	al,2	; msghan = 2, STDERR (DosStdEr)
  6969 000013F9 50                      		push	ax
  6970 000013FA B004                    		mov	al,4	; msgnum = 4, "Cannot FDISK with network loaded"
  6971 000013FC 50                      		push	ax
  6972                                  
  6973 000013FD E81AF9                  		call	display_msg
  6974 00001400 83C40C                  		add	sp,12
  6975                                  cve_false:
  6976                                  		;sub	al,al ; 0
  6977 00001403 F9                      		stc
  6978                                  cve_true:
  6979 00001404 C3                      		retn
  6980                                  ;cve_true:
  6981                                  		;mov	al,1
  6982                                  		;;clc	
  6983                                  		;retn
  6984                                  
  6985                                  ; ----------------------------------------------------------------------------
  6986                                  ; video.c (FDISK, MSDOS 6.0, 1991)	
  6987                                  ; ----------------------------------------------------------------------------
  6988                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 15/11/2018)
  6989                                  
  6990                                  ;/*  */
  6991                                  ;/*                                                                         */
  6992                                  ;/***************************************************************************/
  6993                                  ;/* Initializes the screen and stores the lower right hand corner           */
  6994                                  ;/* of the screen in the global variable LowerRightHandCorner. This         */
  6995                                  ;/* is which is used for screen clears. If the screen is in graphics mode,  */
  6996                                  ;/* it is changed to BW 40x25. This procedure is only called once at program*/
  6997                                  ;/* start. Also saves the current screen                                    */
  6998                                  ;/***************************************************************************/
  6999                                  ;/*                                                                         */
  7000                                  
  7001                                  init_video_information:
  7002 00001405 C606[D8C3]00            		mov	byte [mono_flag],0 ; FALSE
  7003                                  
  7004                                  		; /* Get the current video state */
  7005 0000140A B40F                    		mov	ah,0Fh
  7006 0000140C CD10                    		int	10h
  7007                                  		
  7008                                  		; /* Save the mode and display page */
  7009 0000140E A2[92A0]                		mov	[video_mode],al
  7010 00001411 883E[2EA1]              		mov	[display_page],bh
  7011                                  
  7012                                  		; get_video_attribute();
  7013 00001415 E87100                  		call	get_video_attribute
  7014                                  
  7015                                  		; if (status_flag == FALSE)
  7016 00001418 803E[E2C3]00            		cmp	byte [status_flag],0
  7017 0000141D 7521                    		jne	short ivi_3
  7018                                  
  7019                                  		; /* assume color mode */
  7020 0000141F B003                    		mov	al,3
  7021                                  
  7022                                  		; /* See if we are in MONOCHROME mode */
  7023 00001421 803E[92A0]07            		cmp	byte [video_mode],7  ; Text 80x25 chars	Monochrome
  7024 00001426 7407                    		je	short ivi_1
  7025                                  			; Graphics 640x350 Monochrome
  7026 00001428 803E[92A0]0F            		cmp	byte [video_mode],0Fh
  7027 0000142D 7507                    		jne	short ivi_2
  7028                                  
  7029                                  ivi_1:		; /* Nope,set to BW80x25*/
  7030 0000142F B002                    		mov	al,2	; Text 80x25 chars Greyscale
  7031 00001431 C606[D8C3]01            		mov	byte [mono_flag],1
  7032                                  ivi_2:
  7033                                  		; /* go set the new mode */
  7034                                  		;mov	ah,0
  7035 00001436 28E4                    		sub	ah,ah
  7036 00001438 CD10                    		int	10h
  7037                                  		
  7038                                  		; /* Set the display page */
  7039 0000143A B405                    		mov	ah,5
  7040                                  		;mov	al,0
  7041 0000143C 28C0                    		sub	al,al
  7042 0000143E CD10                    		int	10h
  7043                                  ivi_3:
  7044 00001440 C3                      		retn
  7045                                  
  7046                                  ;/*  */
  7047                                  ;/***************************************************************************/
  7048                                  ;/* Resets the video mode to the original value 			    */
  7049                                  ;/***************************************************************************/
  7050                                  
  7051                                  ;void reset_video_information()
  7052                                  
  7053                                  reset_video_information:
  7054                                  		;  /* Do this if we are not using the /STATUS switch */
  7055                                  		; if (status_flag == FALSE)
  7056                                  		
  7057 00001441 803E[E2C3]00            		cmp	byte [status_flag],0
  7058 00001446 7515                    		jne	short rvi_ret
  7059                                  
  7060                                  		; /* Clear display with colors that were present when FDISK was invoked */
  7061 00001448 8A3E[1EC4]              		mov	bh,[video_attribute]
  7062                                  		;sub	cx,cx ; cl = start (upper left) column
  7063                                  			      ; ch = start (top) row				
  7064                                  		;mov	dl,24 ; dl = end (lower right) column
  7065                                  		;mov	dh,79 ; dh = end (bottom) row
  7066                                  		;mov	al,0  ; lines
  7067                                  		;mov	ah,6 ; SCROLL_UP ; BIOS scroll up function
  7068                                  		;	 		 ; BIOS video call
  7069                                  		;int	10h	; - VIDEO - SCROLL PAGE	UP
  7070                                  				; AL = number of lines to scroll window	
  7071                                  				;	(0 = blank whole window)
  7072                                  				; BH = attributes to be	used on	blanked	lines
  7073                                  				; CH,CL	= row,column of	upper left corner of window to scroll
  7074                                  				; DH,DL	= row,column of	lower right corner of window
  7075                                  
  7076 0000144C E81200                  		call	RVI_CLS ; 16/11/2018
  7077                                  		
  7078                                  		; /* Reset the video mode */
  7079 0000144F 30E4                    		xor	ah,ah ; 0 ; SET MODE
  7080 00001451 A0[92A0]                		mov	al,[video_mode]
  7081 00001454 CD10                    		int	10h
  7082                                  
  7083                                  		; /* Set the page */
  7084 00001456 B405                    		mov	ah,5
  7085 00001458 A0[2EA1]                		mov	al,[display_page]
  7086 0000145B CD10                    		int	10h
  7087                                  rvi_ret:
  7088 0000145D C3                      		retn
  7089                                  
  7090                                  ; ============================================================================
  7091                                  ;  CLS (clear screen, clear whole video page)
  7092                                  ; ============================================================================
  7093                                  ; 16/11/2018
  7094                                  
  7095                                  CLS:
  7096 0000145E E80D00                  		call	CLS_ATTRIBUTE ; Set cls (scroll) page attribute in bh		
  7097                                  RVI_CLS:
  7098                                  		; INPUT: bh = Page (blanked line) attributes
  7099                                  
  7100 00001461 29C9                    		sub	cx,cx ; cl = start (upper left) column
  7101                                  			      ; ch = start (top) row			
  7102 00001463 B24F                    		mov	dl,79 ; dl = end (lower right) column
  7103 00001465 B618                    		mov	dh,24 ; dh = end (bottom) row	
  7104 00001467 B000                    		mov	al,0  ; lines
  7105 00001469 B406                    		mov	ah,6 ; SCROLL_UP ; BIOS scroll up function
  7106                                  			 		 ; BIOS video call
  7107 0000146B CD10                    		int	10h	; - VIDEO - SCROLL PAGE	UP
  7108                                  				; AL = number of lines to scroll window	
  7109                                  				;	(0 = blank whole window)
  7110                                  				; BH = attributes to be	used on	blanked	lines
  7111                                  				; CH,CL	= row,column of	upper left corner of window to scroll
  7112                                  				; DH,DL	= row,column of	lower right corner of window
  7113 0000146D C3                      		retn
  7114                                  
  7115                                  ; cls_attribute
  7116                                  ; ----------------------------------------------------------------------------
  7117                                  ; 16/11/2018
  7118                                  
  7119                                  CLS_ATTRIBUTE:
  7120 0000146E 803E[E2C3]01            		cmp	byte [status_flag],1
  7121 00001473 7506                    		jne	short clscr_1
  7122                                  
  7123 00001475 8A3E[1EC4]              		mov	bh,[video_attribute]
  7124 00001479 EB0D                    		jmp	short clscr_3
  7125                                  clscr_1:
  7126 0000147B 803E[D8C3]01            		cmp	byte [mono_flag],1
  7127 00001480 7504                    		jne	short clscr_2
  7128 00001482 B707                    		mov	bh,7	; GRAY_ON_BLACK
  7129 00001484 EB02                    		jmp	short clscr_3
  7130                                  clscr_2:
  7131 00001486 B717                    		mov	bh,17h	; WHITE_ON_BLUE
  7132                                  clscr_3:
  7133 00001488 C3                      		retn
  7134                                  
  7135                                  
  7136                                  ;/*****************************************************************************/
  7137                                  ;/*Routine name:  GET_VIDEO_ATTRIBUTE                                         */
  7138                                  ;/*****************************************************************************/
  7139                                  ;/*                                                                           */
  7140                                  ;/*Description:   This routine will invoke interrupt 10 function 08h to       */
  7141                                  ;/*               get the current attributes at the cursor position in order  */
  7142                                  ;/*               to restore the correct colors when returning out of FDISK.  */
  7143                                  ;/*                                                                           */
  7144                                  ;/*Called Procedures:    none                                                 */
  7145                                  ;/*                                                                           */
  7146                                  ;/*                                                                           */
  7147                                  ;/*Change History: Created        3/11/88         DRM                         */
  7148                                  ;/*                                                                           */
  7149                                  ;/*Input: None                                                                */
  7150                                  ;/*                                                                           */
  7151                                  ;/*Output: None                                                               */
  7152                                  ;/*                                                                           */
  7153                                  ;/*****************************************************************************/
  7154                                  
  7155                                  ;void get_video_attribute()
  7156                                  
  7157                                  get_video_attribute:	; /* Get current attributes */
  7158 00001489 B408                    		mov	ah,8 ; CURRENT_VIDEO_ATTRIBUTE
  7159 0000148B 8A3E[2EA1]              		mov	bh,[display_page]
  7160 0000148F CD10                    		int	10h
  7161 00001491 8826[1EC4]              		mov	[video_attribute],ah ; 16/11/2018
  7162 00001495 C3                      		retn
  7163                                  
  7164                                  ;/*  */
  7165                                  ; ============================================================================
  7166                                  ;  CLEAR SCREEN
  7167                                  ; ============================================================================
  7168                                  ; 15/11/2018
  7169                                  
  7170                                  ;void clear_screen(TopRow,LeftCol,BotRow,RightCol)
  7171                                  
  7172                                  ;unsigned     TopRow;
  7173                                  ;unsigned     LeftCol;
  7174                                  ;unsigned     BotRow;
  7175                                  ;unsigned     RightCol;
  7176                                  
  7177                                  ;BEGIN
  7178                                  
  7179                                  ;char    attribute;
  7180                                  ;char    *attribute_ptr = &attribute;
  7181                                  
  7182                                  ;	if (status_flag == TRUE)
  7183                                  ;		attribute = video_attribute;
  7184                                  ;	else
  7185                                  ;		{
  7186                                  ;  		if (mono_flag == TRUE) 
  7187                                  ;      		attribute = GRAY_ON_BLACK;
  7188                                  ;   		else
  7189                                  ;       	attribute = WHITE_ON_BLUE;
  7190                                  ;		}
  7191                                  ;  VIOSCROLLUP(TopRow,LeftCol,BotRow,RightCol,u(0),attribute_ptr,u(0));
  7192                                  ;  return;
  7193                                  ;END
  7194                                  
  7195                                  clear_screen: ; (clear_screen_down, clear screen rows)
  7196                                  
  7197                                  		%define	TopRow   bp+4
  7198                                  		%define LeftCol  bp+6
  7199                                  		%define BotRow   bp+8
  7200                                  		%define	RightCol bp+10	
  7201                                  
  7202 00001496 55                      		push	bp
  7203 00001497 89E5                    		mov	bp,sp
  7204                                  
  7205 00001499 53                      		push	bx
  7206 0000149A 51                      		push	cx
  7207 0000149B 52                      		push	dx
  7208                                  		;push	si
  7209                                  		;push	di
  7210                                  		;push	ds
  7211                                  		;push	es
  7212                                  		;push	ss
  7213                                  		;push	bp
  7214                                  
  7215                                  ;		cmp	byte [status_flag],1
  7216                                  ;		jne	short clscr_1
  7217                                  ;
  7218                                  ;		mov	bh,[video_attribute]
  7219                                  ;		jmp	short clscr_3
  7220                                  ;clscr_1:
  7221                                  ;		cmp	byte [mono_flag],1
  7222                                  ;		jne	short clscr_2
  7223                                  ;		mov	bh,7	; GRAY_ON_BLACK
  7224                                  ;		jmp	short clscr_3
  7225                                  ;clscr_2:
  7226                                  ;		mov	bh,17h	; WHITE_ON_BLUE
  7227                                  
  7228 0000149C E8CFFF                  		call	CLS_ATTRIBUTE ; 16/11/2018
  7229                                  		
  7230                                  		; bh = Attribute for erased lines
  7231                                  ;clscr_3:
  7232 0000149F 28C0                    		sub	al,al ; # of lines to scroll (0 = whole window)
  7233                                  		
  7234                                  		; ... VIOSCROLLUP ...
  7235                                  
  7236                                  ; video.asm (MSDOS 6.0, 1991)
  7237                                  ; ----------------------------------------------------------------------------
  7238                                  ; 15/11/2018 - Modified for NASM syntax & FDISK subroutines (by Erdogan Tan)
  7239                                  
  7240                                  ; ============================================================================
  7241                                  ; void VideoScrollUp( int StartRow, int StartCol, int EndRow, int EndCol,
  7242                                  ;                     int Lines, int Attrib )
  7243                                  ; ============================================================================
  7244                                  
  7245                                  VideoScrollUp:
  7246                                  VIOSCROLLUP:
  7247                                  		; bh =  Attribute for erased lines
  7248                                  		; al =  # of lines to scroll
  7249                                  	
  7250                                  		;;mov	al,[Lines]	 ; # of lines to scroll
  7251                                  
  7252                                  		;cmp	al,25
  7253                                  		;jg 	short vioscrollup_1
  7254                                  
  7255 000014A1 8A560A                  		mov	dl,[RightCol]	 ; Put ending column in DL
  7256                                  	
  7257                                  		;cmp	dl,80
  7258                                  		;jg 	short vioscrollup_1
  7259                                  
  7260 000014A4 8A7608                  		mov	dh,[BotRow]	 ; Put ending row in DH
  7261                                  
  7262                                  		;cmp	dh,25
  7263                                  		;jg 	short vioscrollup_1
  7264                                  
  7265 000014A7 8A6E04                  		mov	ch,[TopRow]	 ; Put starting row in CH
  7266 000014AA 8A4E06                  		mov	cl,[LeftCol]	 ; Put starting column in CL
  7267                                  
  7268                                  		;;mov	bh,[Attrib]	 ; Attribute for erased lines
  7269                                  	
  7270 000014AD B406                    		mov	AH,6 ; SCROLL_UP ; BIOS scroll up function
  7271                                  			 		 ; BIOS video call
  7272 000014AF CD10                    		int	10h	; - VIDEO - SCROLL PAGE	UP
  7273                                  				; AL = number of lines to scroll window	
  7274                                  				;	(0 = blank whole window)
  7275                                  				; BH = attributes to be	used on	blanked	lines
  7276                                  				; CH,CL	= row,column of	upper left corner of window to scroll
  7277                                  				; DH,DL	= row,column of	lower right corner of window
  7278                                  ;		sub	ax,ax ; 0
  7279                                  ;		jmp	short vioscrollup_2
  7280                                  ;vioscrollup_1:
  7281                                  ;		mov	ax,2
  7282                                  ;vioscrollup_2:
  7283                                  		;pop	bp
  7284                                  		;pop	ss
  7285                                  		;pop	es
  7286                                  		;pop	ds
  7287                                  		;pop	di
  7288                                  		;pop	si
  7289 000014B1 5A                      		pop	dx
  7290 000014B2 59                      		pop	cx
  7291 000014B3 5B                      		pop	bx
  7292 000014B4 89EC                    		mov	sp,bp
  7293 000014B6 5D                      		pop	bp
  7294                                  		;retn	12
  7295 000014B7 C20800                  		retn	8	; return and clean stack
  7296                                  
  7297                                  ; ----------------------------------------------------------------------------
  7298                                  ; int13.c (FDISK, MSDOS 6.0, 1991)	
  7299                                  ; ----------------------------------------------------------------------------
  7300                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 16/11/2018)
  7301                                  
  7302                                  ;/*  */
  7303                                  ; ----------------------------------------------------------------------------
  7304                                  ;char get_disk_info()
  7305                                  ;BEGIN
  7306                                  ;   unsigned char   i;
  7307                                  ;   /* Initialize values */
  7308                                  ;   number_of_drives = uc(0);
  7309                                  ;   for (i=uc(0); i < uc(MAX_HDISK); i++)
  7310                                  ;     BEGIN
  7311                                  ;        total_disk[i] = u(0);
  7312                                  ;        total_mbytes[i] = f(0);
  7313                                  ;        max_sector[i] = uc(0);
  7314                                  ;        max_head[i] = u(0);
  7315                                  ;     END
  7316                                  ;   /* See how many drives there are */
  7317                                  ;   if (get_drive_parameters(uc(0x80)))
  7318                                  ;      BEGIN
  7319                                  ;        /* Get the drive parameters for all drives */
  7320                                  ;        for (i = uc(0); i < number_of_drives;i++)
  7321                                  ;           BEGIN
  7322                                  ;            if (get_drive_parameters(uc(0x80)+i))
  7323                                  ;              BEGIN
  7324                                  ;                /* Save drive parameters */
  7325                                  ;                max_sector[i] = ((unsigned char)(regs.h.cl & 0x3F));
  7326                                  ;                max_head[i] = ((unsigned)(regs.h.dh +1));
  7327                                  ;                total_disk[i] = ((((unsigned)(regs.h.cl & 0xc0)) << 2) | regs.h.ch) + 1;
  7328                                  ;                total_mbytes[i] = cylinders_to_mbytes(total_disk[i],i);
  7329                                  ;              END
  7330                                  ;           else
  7331                                  ;              BEGIN
  7332                                  ;               good_disk[i] = FALSE;
  7333                                  ;               return(FALSE);
  7334                                  ;              END
  7335                                  ;          END
  7336                                  ;       return(TRUE);
  7337                                  ;      END
  7338                                  ;   else
  7339                                  ;      /* No drives present */
  7340                                  ;      BEGIN
  7341                                  ;        no_fatal_error = FALSE;
  7342                                  ;        return(FALSE);
  7343                                  ;      END
  7344                                  ;END
  7345                                  
  7346                                  get_disk_info:
  7347                                  		;%define _i_ bp-2
  7348                                  
  7349                                  		;push	bp
  7350                                  		;mov	bp,sp
  7351                                  
  7352                                  		;sub	sp,2
  7353                                  		;xor	ax,ax ; [_i_] = 0 ; 19/11/2018
  7354                                  		;push	ax
  7355                                  
  7356 000014BA 31ED                    		xor	bp,bp ; [_i_] = 0
  7357                                  
  7358                                  		;push	si
  7359                                  
  7360                                  		; /* Initialize values */
  7361                                  
  7362                                  		;sub	al,al
  7363 000014BC 29C0                    		sub	ax,ax ; 19/11/2018	
  7364 000014BE A2[E3C3]                		mov	[number_of_drives],al ; 0
  7365                                  
  7366                                  		;mov	[_i_],al ; 0
  7367 000014C1 31DB                    		xor	bx,bx ; 0
  7368                                  		;jmp	short gdi_2
  7369                                  gdi_1:
  7370                                  		;mov	bl,[_i_]
  7371                                  		;sub	bh,bh
  7372 000014C3 88BF[AEA0]              		mov	[max_sector+bx],bh ; 0
  7373                                  		;sub	ax,ax
  7374                                  		;shl	bx,1
  7375 000014C7 D0E3                    		shl	bl,1 ; 19/11/2018
  7376 000014C9 8987[C6A0]              		mov	[total_disk+bx],ax ; 0
  7377 000014CD 8987[D6A0]              		mov	[total_mbytes+bx],ax ; 0
  7378 000014D1 8987[B6A0]              		mov	[max_head+bx],ax ; 0
  7379                                  		;inc	byte [_i]
  7380 000014D5 D0EB                    		shr	bl,1 ; 19/11/2018
  7381 000014D7 FEC3                    		inc	bl
  7382                                  gdi_2:
  7383                                  		;cmp	byte [_i_],8 ; MAX_HDISK
  7384 000014D9 80FB08                  		cmp	bl,8 ; Max. 8 hard disks
  7385 000014DC 72E5                    		jb	short gdi_1
  7386                                  
  7387                                  		; /* See how many drives there are */
  7388                                  
  7389                                  		;mov	al,80h
  7390                                  		;push	ax
  7391 000014DE B280                    		mov	dl,80h
  7392 000014E0 E84E00                  		call	get_drive_parameters
  7393                                  		;pop	bx
  7394                                  		;or	al,al
  7395                                  		;jz	short gdi_7 ; AL = 0 -> Error, no hard disks present
  7396                                  
  7397                                  		; AL = 1 -> 1 or 2 or more hard disks present
  7398                                  
  7399                                  		; /* Get the drive parameters for all drives */
  7400                                  
  7401                                  		;mov	byte [_i_],0
  7402                                  		;sub	bp,bp ; [_i_] = 0
  7403                                  		;jmp	short gdi_4
  7404                                  
  7405                                  		; 14/12/2018
  7406 000014E3 3C01                    		cmp	al,1
  7407 000014E5 7317                    		jnb	short gdi_4 ; bp = 0
  7408                                  	
  7409                                  		; cf = 1 ; *
  7410                                  ;gdi_7:
  7411                                  		;/* No drives present */
  7412                                  
  7413                                  		;sub	al,al
  7414 000014E7 A2[13C4]                		mov	[no_fatal_error],al ; 0 ; FALSE
  7415                                  ;gdi_8:
  7416                                  		;stc ; *
  7417                                  ;gdi_9:
  7418                                  		;pop	si
  7419                                  		;mov	sp,bp
  7420                                  		;pop	bp
  7421                                  	
  7422 000014EA C3                      		retn
  7423                                  
  7424                                  gdi_3:
  7425                                  		;inc	byte [_i_]
  7426 000014EB 45                      		inc	bp
  7427                                  ;gdi_4:
  7428                                  		;mov	al,[_i_]
  7429                                  		;mov	dl,[_i_]
  7430 000014EC 89EA                    		mov	dx,bp ; [_i_]
  7431                                  		;cmp	[number_of_drives],al
  7432                                  		;cmp	[number_of_drives],dl
  7433                                  		;jbe	short gdi_6
  7434 000014EE 3A16[E3C3]              		cmp	dl,[number_of_drives]
  7435                                  		;jnb	short gdi_6
  7436 000014F2 733A                    		jnb	short gdi_5 ; cf=0, success return (14/12/2018)
  7437                                  		;add	al,80h
  7438 000014F4 80C280                  		add	dl,80h
  7439                                  		;push	ax
  7440 000014F7 E83700                  		call	get_drive_parameters
  7441                                  		;pop	bx
  7442                                  		;or	al,al
  7443                                  		;jz	short gdi_5
  7444                                  		; 14/12/2018
  7445 000014FA 3C01                    		cmp	al,1
  7446                                  		;jb	short gdi_5
  7447 000014FC 7232                    		jb	short gdi_6 ; cf=1, error return (14/12/2018)	
  7448                                  gdi_4: 			; 14/12/2018		
  7449                                  		; /* Save drive parameters */
  7450                                  
  7451                                  		;mov	al,[regs_x_cx]
  7452 000014FE 88C8                    		mov	al,cl
  7453 00001500 243F                    		and	al,3Fh
  7454                                  		;mov	bl,[_i_]
  7455                                  		;sub	bh,bh
  7456 00001502 89EB                    		mov	bx,bp ; 17/11/2018
  7457 00001504 8887[AEA0]              		mov	[max_sector+bx],al
  7458                                  		;mov	al,[regs_x_dx+1]
  7459 00001508 88F0                    		mov	al,dh
  7460 0000150A 28E4                    		sub	ah,ah
  7461 0000150C 40                      		inc	ax
  7462                                  		;shl	bx,1
  7463                                  		;shl	bl,1 ; 19/11/2018
  7464                                  		;mov	[max_head+bx],ax  ; Heads (<= 256)	  	
  7465                                  
  7466                                  		; 19/11/2018
  7467 0000150D 89DE                    		mov	si,bx  ; Drive number (0 to 7)
  7468 0000150F D1E6                    		shl	si,1
  7469 00001511 8984[B6A0]              		mov	[max_head+si],ax  ; Heads (<= 256)	
  7470                                  
  7471                                  		;mov	al,[regs_x_cx]
  7472 00001515 88C8                    		mov	al,cl ; 19/11/2018
  7473 00001517 25C000                  		and	ax,0C0h
  7474 0000151A D1E0                    		shl	ax,1
  7475 0000151C D1E0                    		shl	ax,1
  7476                                  		;mov	cl,[regs_x_cx+1]
  7477                                  		;sub	ch,ch
  7478                                  		;or	ax,cx
  7479 0000151E 88E8                    		mov	al,ch
  7480 00001520 40                      		inc	ax
  7481                                  		;mov	[total_disk+bx],ax ; cylinders (<= 1024)
  7482 00001521 8984[C6A0]              		mov	[total_disk+si],ax ; 19/11/2018	
  7483                                  	
  7484                                  		;mov	cl,[_i_]
  7485                                  		;;sub	ch,ch
  7486                                  		;mov	cx,bp ; [_i_]
  7487                                  		;push	cx
  7488                                  		;push	ax
  7489                                  		;mov	si,bx ; 19/11/2018
  7490                                  		;;mov	bl,[_i]
  7491                                  		;;xor	bh,bh
  7492                                  		;mov	bx,bp  ; Disk/Drive number (0 to 7) 
  7493 00001525 E83E00                  		call	cylinders_to_mbytes
  7494                                  		;pop	bx
  7495                                  		;pop	bx
  7496 00001528 8984[D6A0]              		mov	[total_mbytes+si],ax
  7497 0000152C EBBD                    		jmp	short gdi_3
  7498                                  ;gdi_5:
  7499                                  		; cf = 1  ; 14/12/2018
  7500                                  		;;sub	al,al
  7501                                  		;;mov	bl,[_i_]
  7502                                  		;;sub	bh,bh
  7503                                  		;; ss = ds ; 19/11/2018
  7504                                  		;;mov	bx,bp ; [_i_]
  7505                                  		;;;mov	[good_disk+bx],al ; 0 ; FALSE
  7506                                  		;mov	[good_disk+bp],al ; 19/11/2018
  7507                                  		;;jmp	short gdi_8
  7508                                  		; 14/12/2018
  7509                                  		;stc
  7510                                  		;retn
  7511                                  ;gdi_6:
  7512                                  gdi_5:
  7513                                  		; cf = 0 ; 14/12/2018
  7514 0000152E B001                    		mov	al,1
  7515                                  		;jmp	short gdi_8
  7516                                  		; 14/12/2018
  7517                                  		;clc ; *
  7518                                  		;jmp	short gdi_9
  7519                                  gdi_6:
  7520 00001530 C3                      		retn
  7521                                  ;gdi_7:
  7522                                  ;		;/* No drives present */
  7523                                  ;
  7524                                  ;		;sub	al,al
  7525                                  ;		mov	[no_fatal_error],al ; 0 ; FALSE
  7526                                  ;gdi_8:
  7527                                  ;		stc ; *
  7528                                  ;gdi_9:
  7529                                  ;		;pop	si
  7530                                  ;		
  7531                                  ;		;mov	sp,bp
  7532                                  ;		;pop	bp
  7533                                  ;		
  7534                                  ;		retn
  7535                                  
  7536                                  
  7537                                  ;/*  */
  7538                                  ; ----------------------------------------------------------------------------
  7539                                  ;char get_drive_parameters(drive)
  7540                                  ;
  7541                                  ;unsigned char   drive;
  7542                                  ;
  7543                                  ;BEGIN
  7544                                  ;    /* See how many drives there are */
  7545                                  ;    regs.h.ah = uc(DISK_INFO);
  7546                                  ;    regs.h.dl = drive;
  7547                                  ;    DiskIo(&regs,&regs,&segregs);
  7548                                  ;
  7549                                  ;    /* See if any drives exist */
  7550                                  ;    if ((regs.h.dl == uc(0)) || ((regs.x.cflag & 1) == u(1)))
  7551                                  ;       BEGIN
  7552                                  ;        display(error_1);
  7553                                  ;        return(FALSE);
  7554                                  ;       END
  7555                                  ;    else
  7556                                  ;       BEGIN
  7557                                  ;        /* Save the number of drives */
  7558                                  ;        number_of_drives = regs.h.dl;
  7559                                  ;        if (number_of_drives > MAX_HDISK)
  7560                                  ;            number_of_drives = MAX_HDISK;
  7561                                  ;        return(TRUE);
  7562                                  ;       END
  7563                                  ;END
  7564                                  
  7565                                  get_drive_parameters:
  7566                                  		;push	bp
  7567                                  		;mov	bp,sp
  7568                                  
  7569                                  		;push	es
  7570                                  		;push	di
  7571                                  
  7572                                  		;mov	dl,[bp+4] ; hard disk drive number (80h = C:)
  7573 00001531 B408                    		mov	ah,8 ; Return Disk parameters
  7574 00001533 CD13                    		int	13h
  7575                                  			; AL = 0
  7576                                  			; CF = 1, Error
  7577                                  			;	AH = Error Code (>0)
  7578                                  			; CF = 0, NO error
  7579                                  			;	AH = 0
  7580                                  			; 	CH = Lower 8 bits of last cylinder number 
  7581                                  			;	CL = Sector number (bit 0 to bit 6) 
  7582                                  			;	     and High two bits of last cylinder number
  7583                                  			;	     (bits 7 and bit 8)
  7584                                  			;	DH = Last head number	
  7585                                  			;	DL = Number of hard disk drives
  7586                                  			; ES:DI = BIOS DPT address (Ref: AMIBIOS guide, 1993)	
  7587 00001535 9F                      		lahf
  7588                                  
  7589 00001536 1E                      		push	ds
  7590 00001537 07                      		pop	es
  7591                                  
  7592                                  		;cmp	dl,0
  7593 00001538 08D2                    		or	dl,dl
  7594 0000153A 7405                    		jz	short gdprm_1
  7595                                  
  7596 0000153C 80E401                  		and	ah,1 ; check cf
  7597 0000153F 7415                    		jz	short gdprm_2
  7598                                  gdprm_1:
  7599                                  		; 22/12/2022
  7600                                  		; clear screen (black background)
  7601 00001541 B707                    		mov	bh, 7
  7602 00001543 E81BFF                  		call	RVI_CLS
  7603 00001546 C606[D8C3]01            		mov	byte [mono_flag],1
  7604                                  
  7605                                  		;push	word [error_1_seg]
  7606 0000154B 1E                      		push	ds ; 17/11/2018
  7607 0000154C FF36[849E]              		push	word [error_1_off]
  7608 00001550 E8D100                  		call	display
  7609                                  		;pop	bx ; 19/11/2018 (!*!*)
  7610                                  		;pop	bx
  7611                                  
  7612                                  		;sub	al,al
  7613 00001553 29C0                    		sub	ax,ax ; 0
  7614                                  		;jmp	short gdprm_4
  7615                                  			; CF = 0, AL = 0 
  7616 00001555 C3                      		retn
  7617                                  gdprm_2:
  7618 00001556 80FA08                  		cmp	dl,8
  7619 00001559 7602                    		jbe	short gdprm_3
  7620 0000155B B208                    		mov	dl,8
  7621                                  gdprm_3:
  7622 0000155D 8816[E3C3]              		mov	[number_of_drives],dl
  7623                                  		;mov	al,1
  7624 00001561 31C0                    		xor	ax,ax ; 14/12/2018
  7625 00001563 FEC0                    		inc	al  ; CF = 0, AL = 1	
  7626                                  gdprm_4:
  7627                                  		;pop	di
  7628                                  		;pop	es
  7629                                  
  7630                                  		;;mov	sp,bp
  7631                                  		;pop	bp
  7632                                  
  7633 00001565 C3                      		retn
  7634                                  
  7635                                  ; ----------------------------------------------------------------------------
  7636                                  ;
  7637                                  ;;; Temporary: 19/11/2018
  7638                                  ;display:
  7639                                  ;		pop	ax ; return address
  7640                                  ;		pop	si ; offset error_1_msg
  7641                                  ;		pop	bx ; segment	
  7642                                  ;		;mov	si, error_1_msg
  7643                                  ;		push	ax 
  7644                                  ;		jmp	print_msg
  7645                                  ;
  7646                                  ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  7647                                  ;
  7648                                  ;error_1_msg:
  7649                                  ;		db	0Dh,0Ah
  7650                                  ;		db	'No fixed disks present!'
  7651                                  ;		db	0Dh,0Ah,0
  7652                                  ;error_1_off:
  7653                                  ;		dw 	error_1_msg
  7654                                  ;
  7655                                  ; ----------------------------------------------------------------------------
  7656                                  
  7657                                  ; ----------------------------------------------------------------------------
  7658                                  ; convert.c (FDISK, MSDOS 6.0, 1991)	
  7659                                  ; ----------------------------------------------------------------------------
  7660                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 16/11/2018)
  7661                                  
  7662                                  ;/*  */
  7663                                  ;/*******************************************************************************/
  7664                                  ;/*Routine name:  CYLINDERS_TO_MBYTES                                           */
  7665                                  ;/*******************************************************************************/
  7666                                  ;/*                                                                             */
  7667                                  ;/*Description:   This routine will take input of cylinders and convert         */
  7668                                  ;/*               it to MBytes.                                                 */
  7669                                  ;/*                                                                             */
  7670                                  ;/*                                                                             */
  7671                                  ;/*Called Procedures:                                                           */
  7672                                  ;/*                                                                             */
  7673                                  ;/*                                                                             */
  7674                                  ;/*Change History: Created        5/16/87         DRM                           */
  7675                                  ;/*                                                                             */
  7676                                  ;/*Input: Cylinders_in                                                          */
  7677                                  ;/*                                                                             */
  7678                                  ;/*Output: MBytes_out                                                           */
  7679                                  ;/*                                                                             */
  7680                                  ;/*                                                                             */
  7681                                  ;/*                                                                             */
  7682                                  ;/*******************************************************************************/
  7683                                  
  7684                                  ;XFLOAT	   cylinders_to_mbytes(cylinders_in,which_disk)
  7685                                  ;
  7686                                  ;unsigned	cylinders_in;
  7687                                  ;char		which_disk;
  7688                                  ;
  7689                                  ;BEGIN
  7690                                  ;
  7691                                  ;unsigned	 mbytes_out;
  7692                                  ;/*C34 unsigned long    number_of_bytes; */
  7693                                  ;unsigned long	 number_of_sectors;
  7694                                  ;unsigned long	 number_of_tracks;
  7695                                  ;unsigned long	 bytes_in_one_sector;
  7696                                  ;
  7697                                  ;     bytes_in_one_sector = BYTES_PER_SECTOR;
  7698                                  ;     number_of_tracks = (ul(cylinders_in) * ul(max_head[which_disk]));
  7699                                  ;     number_of_sectors = (number_of_tracks * ul(max_sector[which_disk]));
  7700                                  ;/*C34 number_of_bytes = (ul(number_of_sectors) * ul(bytes_in_one_sector)); */
  7701                                  ;/*C34 mbytes_out =  f(number_of_bytes / ONE_MEG);                          */
  7702                                  ;/*C34 if ((number_of_bytes % ONE_MEG) >= (ONE_MEG / 2)) mbytes_out++;      */
  7703                                  ;     mbytes_out = numsecs_to_mbytes(number_of_sectors);                 /*C34*/
  7704                                  ;     return(mbytes_out);
  7705                                  ;
  7706                                  ;END
  7707                                  
  7708                                  cylinders_to_mbytes:
  7709                                  
  7710                                  		; INPUT: BX = Disk/Drive number (0 to 7)
  7711                                  		;	 AX = Cylinders (Total or partition's cylinder count)	
  7712                                  
  7713                                  		;push	bp
  7714                                  		;mov	bp,sp
  7715                                  		
  7716                                  		;mov	al,[bp+6] ; Disk/Drive number (0 to 7)
  7717                                  		;cbw
  7718                                  		;mov	bx,ax
  7719                                  		
  7720                                  		;mov	bl,[bp+6]
  7721                                  		;xor	bh,bh
  7722                                  
  7723                                  		;shl	bx,1
  7724 00001566 D0E3                    		shl	bl,1  ; word index	
  7725                                  
  7726                                  		;mov	cx,ax
  7727                                  		;mov	ax,[max_head+bx]
  7728                                  		;mul	word [bp+4]
  7729 00001568 8B97[B6A0]              		mov	dx,[max_head+bx]
  7730 0000156C F7E2                    		mul	dx
  7731                                  			; dx:ax = Number of tracks (cylinders*heads)
  7732                                  
  7733                                  		;mov	bx,cx
  7734                                  		;shr	bx,1 ; byte index
  7735 0000156E D0EB                    		shr	bl,1 ; 11/12/2018
  7736 00001570 8A8F[AEA0]              		mov	cl,[max_sector+bx]
  7737 00001574 28ED                    		sub	ch,ch
  7738                                  		;sub	bx,bx ; 0
  7739 00001576 28DB                    		sub	bl,bl ; 11/12/2018
  7740 00001578 53                      		push	bx ; yh - multiplier_hw
  7741 00001579 51                      		push	cx ; yl - multiplier_lw
  7742 0000157A 52                      		push	dx ; xh - multiplicand_hw
  7743 0000157B 50                      		push	ax ; xl - multiplicand_lw
  7744 0000157C E85C00                  		call	mul32
  7745                                  			; dx:ax = Number of sectors 
  7746                                  		;push	dx
  7747                                  		;push	ax
  7748 0000157F E80100                  		call	numsecs_to_mbytes
  7749                                  			; AX = disk capacity as mega bytes
  7750                                  		;pop	bx
  7751                                  		;pop	bx
  7752                                  
  7753                                  		;mov	sp,bp
  7754                                  		;pop	bp
  7755                                  
  7756 00001582 C3                      		retn
  7757                                  
  7758                                  ; ----------------------------------------------------------------------------
  7759                                  
  7760                                  ;XFLOAT	   numsecs_to_mbytes(numsecs)
  7761                                  ;unsigned  long numsecs;
  7762                                  ;{
  7763                                  ;
  7764                                  ;unsigned long	 bytes_in_one_sector;
  7765                                  ;/*C34 unsigned long    number_of_bytes; */
  7766                                  ;unsigned         sectors_in_one_meg;					/*C34*/
  7767                                  ;unsigned	 mbytes_out;
  7768                                  ;
  7769                                  ;     bytes_in_one_sector = BYTES_PER_SECTOR;
  7770                                  ;/*C34 number_of_bytes = (numsecs * ul(bytes_in_one_sector));        */
  7771                                  ;/*C34 mbytes_out =  f((number_of_bytes + ul(ONE_MEG/2)) / ONE_MEG); */
  7772                                  ;     sectors_in_one_meg = u(ONE_MEG / bytes_in_one_sector);            /*C34*/
  7773                                  ;     mbytes_out = f((numsecs + ul(sectors_in_one_meg/2)) / sectors_in_one_meg)
  7774                                  ;									/*C34*/
  7775                                  ;     return(mbytes_out);
  7776                                  ;}
  7777                                  
  7778                                  numsecs_to_mbytes:
  7779                                  		; INPUT: DX:AX = Sector count (32 bit)
  7780                                  		;   OUT:    AX = Mega bytes	
  7781                                  		;push	bp
  7782                                  		;mov	bp,sp
  7783                                  		;mov	ax,[bp+4] ; sector count lw
  7784                                  		;mov	dx,[bp+6] ; sector count hw
  7785                                  
  7786                                  	;sectors_in_one_meg = u(ONE_MEG / bytes_in_one_sector);
  7787                                  	;mbytes_out = f((numsecs + ul(sectors_in_one_meg/2)) / sectors_in_one_meg)
  7788                                  
  7789 00001583 050004                  		add	ax,1024 ; round up
  7790 00001586 83D200                  		adc	dx,0
  7791                                  			; DX:AX = (X kilo byte)*2 sectors
  7792 00001589 B10B                    		mov	cl,11 ; / 2048
  7793 0000158B E87F00                  		call	shr32
  7794                                  			; (X kilo bytes)*2 / 2048 = X/1024 mega bytes
  7795                                  		;mov	sp,bp
  7796                                  		;pop	bp
  7797 0000158E C3                      		retn
  7798                                  
  7799                                  ; ----------------------------------------------------------------------------
  7800                                  
  7801                                  ;unsigned  mbytes_to_percent(mbytes_used, total_cap)
  7802                                  ;unsigned  mbytes_used;
  7803                                  ;XFLOAT    total_cap;
  7804                                  ;
  7805                                  ;BEGIN
  7806                                  ;
  7807                                  ;unsigned      percentage_out;
  7808                                  ;
  7809                                  ;unsigned long large_number;
  7810                                  ;
  7811                                  ;	if (mbytes_used) {
  7812                                  ;		large_number = ( mbytes_used * 100L ) +total_cap/2;
  7813                                  ;		percentage_out = (unsigned) (large_number/total_cap);
  7814                                  ;		if (percentage_out > u(100)) percentage_out = u(100);
  7815                                  ;	}
  7816                                  ;	else percentage_out = 0;
  7817                                  ;    	return(percentage_out);
  7818                                  ;END
  7819                                  
  7820                                  mbytes_to_percent:
  7821                                  		; 21/11/2018
  7822                                  
  7823                                  	;%define percent    bp-2
  7824                                  	%define partmbytes  bp+4  ; mbytes_used
  7825                                  	%define	totalmbytes bp+6  ; total_cap	
  7826                                  
  7827 0000158F 55                      		push	bp
  7828 00001590 89E5                    		mov	bp,sp
  7829                                  		;xor	bx,bx ; 0
  7830                                  		;push	bx
  7831                                  		
  7832                                  		;if (mbytes_used) {
  7833                                  
  7834                                  		;cmp	word [partmbytes],0
  7835                                  		;je	short mtp_0
  7836                                  
  7837 00001592 8B4604                  		mov	ax,[partmbytes]
  7838 00001595 09C0                    		or	ax,ax
  7839 00001597 741C                    		jz	short mtp_0
  7840                                  
  7841                                  		;large_number = ( mbytes_used * 100L ) +total_cap/2;
  7842                                  
  7843                                  		;mov	ax,[totalmbytes]
  7844                                  		;sub	dx,dx
  7845                                  		;push	dx ; divisor_hw = 0
  7846                                  		;push	ax ; divisor_lw
  7847                                  		;;;push	ax ;* divisor (16 bit)
  7848 00001599 8B4E06                  		mov	cx,[totalmbytes] ; divisor (16 bit)
  7849                                  		;mov	ax,100
  7850                                  		;mul	word [partmbytes] ; X
  7851 0000159C BA6400                  		mov	dx,100
  7852 0000159F F7E2                    		mul	dx		
  7853                                  
  7854                                  		;mov	cx,[totalmbytes]
  7855                                  		;shr	cx,1
  7856                                  		;add	ax,cx
  7857                                  		
  7858                                  		;;;mov	bx,[totalmbytes]  ; Y
  7859 000015A1 89CB                    		mov	bx,cx
  7860 000015A3 D1EB                    		shr	bx,1 ; 1/2 Y
  7861 000015A5 01D8                    		add	ax,bx ; ((100*X)/Y)+(0.5)*Y/Y
  7862 000015A7 83D200                  		adc	dx,0
  7863                                  		
  7864                                  		;percentage_out = (unsigned) (large_number/total_cap);
  7865                                  
  7866                                  		;;;pop	cx ;* 21/11/2018 - divisor (16 bit)
  7867                                  		;push	dx ; dividend_hw
  7868                                  		;push	ax ; dividend_lw
  7869                                  		;call	div32
  7870                                  
  7871                                  		; dx:ax = dividend (32 bit)
  7872                                  		; cx = divisor (16 bit)
  7873 000015AA E86900                  		call	div32
  7874                                  		;mov	[percent],ax
  7875                                  
  7876                                  		;if (percentage_out > u(100)) percentage_out = u(100);
  7877                                  
  7878 000015AD 83F864                  		cmp	ax,100
  7879 000015B0 7603                    		jbe	short mtp_0
  7880                                  		;mov	word [percent],100
  7881 000015B2 B86400                  		mov	ax,100
  7882                                  		;jmp	short mtp_1
  7883                                  mtp_0:
  7884                                  		;mov	word [percent],0
  7885                                  mtp_1:
  7886                                  		;mov	ax,[percent]
  7887                                  		;mov	sp,bp
  7888 000015B5 5D                      		pop	bp
  7889                                  
  7890 000015B6 C20400                  		retn	4 ; 06/01/2019
  7891                                  
  7892                                  ; ----------------------------------------------------------------------------
  7893                                  
  7894                                  ; 26/11/2018
  7895                                  
  7896                                  ;/*  */
  7897                                  ;/*******************************************************************************/
  7898                                  ;/*Routine name:  CYLINDERS_TO_PERCENT                                          */
  7899                                  ;/*******************************************************************************/
  7900                                  ;/*                                                                             */
  7901                                  ;/*Description:   This routine will take input of cylinders and convert         */
  7902                                  ;/*               it to Percent.                                                */
  7903                                  ;/*                                                                             */
  7904                                  ;/*                                                                             */
  7905                                  ;/*Called Procedures:                                                           */
  7906                                  ;/*                                                                             */
  7907                                  ;/*                                                                             */
  7908                                  ;/*Change History: Created        5/16/87         DRM                           */
  7909                                  ;/*                                                                             */
  7910                                  ;/*Input: Cylinders_in                                                          */
  7911                                  ;/*                                                                             */
  7912                                  ;/*Output: percent_out                                                          */
  7913                                  ;/*                                                                             */
  7914                                  ;/*                                                                             */
  7915                                  ;/*******************************************************************************/
  7916                                  
  7917                                  ;unsigned  cylinders_to_percent(cylinders_in,total_cylinders)
  7918                                  ;
  7919                                  ;unsigned      cylinders_in;
  7920                                  ;unsigned      total_cylinders;
  7921                                  ;
  7922                                  ;BEGIN
  7923                                  ;
  7924                                  ;unsigned      percentage_out;
  7925                                  ;
  7926                                  ;/* SR; 9/26/89; Changed from double to unsigned long */
  7927                                  ;unsigned long large_number;
  7928                                  ;
  7929                                  ;    /* This is the same as (cyl_in / tot_cyl) * 100 to get the percentage */
  7930                                  ;    /* because * 100 is really 100/1 which is (cyl_in*100)/(tot_cyl*1).   */
  7931                                  ;
  7932                                  ;	 /* SR; 9/26/89; Check for cylinders_in = 0 because round off errors
  7933                                  ;		may cause total_cylinders = 1 but cylinders_in = 0 */
  7934                                  ;    if (cylinders_in == 0)
  7935                                  ;	 percentage_out = 0;
  7936                                  ;    else if (total_cylinders == 0)
  7937                                  ;            percentage_out = 0;
  7938                                  ;         else
  7939                                  ;            BEGIN
  7940                                  ;	       /* SR; 9/26/89; Changed double to unsigned long */
  7941                                  ;	       large_number = (unsigned long)(ul(cylinders_in) * 100l);
  7942                                  ;	       percentage_out = u(large_number / total_cylinders);
  7943                                  ;            END
  7944                                  ;    /* this should round up to the next percent if more than .5 percent */
  7945                                  ;
  7946                                  ;	 /* SR; 9/26/89; Need type cast to long or results truncated */
  7947                                  ;    if ((((long)cylinders_in * 100l) % total_cylinders) >= (total_cylinders / 2))
  7948                                  ;       percentage_out++;
  7949                                  ;    if (percentage_out > u(100)) percentage_out = u(100);
  7950                                  ;    return(percentage_out);
  7951                                  ;END
  7952                                  
  7953                                  cylinders_to_percent:
  7954                                  		; 26/11/2018
  7955                                  		; INPUT:
  7956                                  		;	bx = Number of cylinders (of partition) -dividend-
  7957                                  		;	cx = Total cylinders -divisor-
  7958                                  		; OUTPUT:
  7959                                  		;	ax = Percentage
  7960                                  		;
  7961                                  		; Modified registers: ax,bx,cx,dx	
  7962                                  
  7963                                  		;;%define percentage_out bp-6
  7964                                  		;;%define percentage_out bp-2 ; **
  7965                                  		;%define cylinders_in	bp+4
  7966                                  		;%define total_cylinders bp+6
  7967                                  
  7968                                  		;push	bp
  7969                                  		;mov	bp,sp
  7970                                  		;;sub	sp,6
  7971 000015B9 31C0                    		xor	ax,ax ; 26/11/2018 ; **
  7972                                  		;push	ax
  7973                                  
  7974                                  		;  if (cylinders_in == 0)
  7975                                  		;	 percentage_out = 0;
  7976                                  		;  else if (total_cylinders == 0)
  7977                                  		;           percentage_out = 0;
  7978                                  		;       else
  7979                                  
  7980                                  		;cmp	word [cylinders_in],0
  7981                                  		;cmp	[cylinders_in],ax ; 0
  7982                                  		;ja	short ctpc_2
  7983                                  		;mov	bx,[cylinders_in]
  7984 000015BB 09DB                    		or	bx,bx
  7985                                  		; 11/12/2018
  7986                                  		;jnz	short ctpc_2
  7987 000015BD 741B                    		jz	short ctpc_6 ; ax = 0 = percentage_out 
  7988                                  ctpc_1:
  7989                                  		;;mov	word [percentage_out],0
  7990                                  		;;mov	[percentage_out],ax ; 0
  7991                                  		;;jmp	short ctpc_3
  7992                                  		; 11/12/2018
  7993                                  		;jmp	short ctpc_6 ; ax = 0 = percentage_out
  7994                                  ctpc_2:
  7995                                  		;cmp	word [total_cylinders],0
  7996                                  		;je	short ctpc_1	
  7997                                  	
  7998                                  		;mov	cx,[total_cylinders]
  7999 000015BF 09C9                    		or	cx,cx
  8000                                  		; 11/12/2018
  8001                                  		;jz	short ctpc_1
  8002                                  			; cx = Divisor
  8003 000015C1 7417                    		jz	short ctpc_6
  8004                                  
  8005                                  		;large_number = (unsigned long)(ul(cylinders_in) * 100l);
  8006                                  		;percentage_out = u(large_number / total_cylinders);
  8007                                  		
  8008                                  		;mov	ax,[total_cylinders]
  8009                                  		;sub	dx,dx
  8010                                  		;push	dx
  8011                                  		;push	ax
  8012                                   
  8013 000015C3 B86400                  		mov	ax,100
  8014                                  		;mul	word [cylinders_in] ; 100*cylinders_in
  8015 000015C6 F7E3                    		mul	bx ; [cylinders_in] 
  8016                                  
  8017                                  		;push	dx
  8018                                  		;push	ax
  8019                                  			; dx:ax = Dividend
  8020                                  
  8021 000015C8 E84B00                  		call	div32	 ; 100*cylinders_in / total_cylinders
  8022                                  			; DX:AX = Quotient
  8023                                  			; BX = Remainder
  8024                                  
  8025                                  		;mov	[percentage_out],ax
  8026                                  		
  8027                                  		; ax = percentage_out	
  8028                                  ctpc_3:
  8029                                  
  8030                                  	;    if ((((long)cylinders_in * 100l) % total_cylinders) >= (total_cylinders / 2))
  8031                                  	;       percentage_out++;
  8032                                  	;    if (percentage_out > u(100)) percentage_out = u(100);
  8033                                  	;    return(percentage_out);
  8034                                  
  8035                                  		;mov	ax,[total_cylinders]
  8036                                  		;sub	dx,dx
  8037                                  		;push	dx
  8038                                  		;push	ax
  8039                                  		;mov	ax,100
  8040                                  		;mul	word [cylinders_in]
  8041                                  
  8042                                  		;push	dx
  8043                                  		;push	ax
  8044                                  		;call	_mod32
  8045                                  
  8046                                  		;mov	cx,[total_cylinders]
  8047 000015CB D1E9                    		shr	cx,1	; total_cylinders/2
  8048                                  		;sub	bx,bx
  8049                                  		;cmp	dx,bx	; Remainder
  8050                                  		;jl	short ctpc_5
  8051                                  		;jg	short ctpc_4
  8052                                  		;cmp	ax,cx
  8053                                  		;jb	short ctpc_5
  8054 000015CD 39CB                    		cmp	bx,cx	; is remainder >= total_cylinders/2 ?
  8055 000015CF 7201                    		jb	short ctpc_5 ; No. 
  8056                                  ctpc_4:
  8057                                  		;inc	word [percentage_out] ; Yes, (x.5)% --> (x+1)%
  8058 000015D1 40                      		inc	ax
  8059                                  ctpc_5:
  8060                                  		;cmp	word [percentage_out],100
  8061 000015D2 83F864                  		cmp	ax,100
  8062 000015D5 7603                    		jbe	short ctpc_6
  8063                                  		;mov	word [percentage_out],100  ;  max. 100% (no 101%)
  8064 000015D7 B86400                  		mov	ax,100
  8065                                  ctpc_6:
  8066                                  		;;mov	ax,[percentage_out]
  8067                                  		;pop	ax ; [percentage_out]
  8068                                  		;;mov	sp,bp
  8069                                  		;pop	bp
  8070 000015DA C3                      		retn
  8071                                  
  8072                                  ; ----------------------------------------------------------------------------
  8073                                  
  8074                                  ; 32 bit multiplication (Microsoft C 6.0 runtime library, MSDOS 6.0, 1991)
  8075                                  ; ============================================================================
  8076                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 16/11/2018)
  8077                                  
  8078                                  mul32:
  8079                                  	%define MULTIPLICAND_L	bp+4  ; xl
  8080                                  	%define MULTIPLICAND_H	bp+6  ; xh
  8081                                  	%define MULTIPLIER_L	bp+8  ; yl
  8082                                  	%define MULTIPLIER_H	bp+10 ; yh
  8083                                  
  8084 000015DB 55                      		push	bp
  8085 000015DC 89E5                    		mov	bp,sp
  8086 000015DE 8B4606                  		mov	ax,[MULTIPLICAND_H] ; yh
  8087 000015E1 8B4E0A                  		mov	cx,[MULTIPLIER_H]   ; xh
  8088 000015E4 09C1                    		or	cx,ax
  8089 000015E6 8B4E08                  		mov	cx,[MULTIPLIER_L]   ; yl
  8090 000015E9 7509                    		jnz	short mul32_1
  8091                                  mul32_0:
  8092 000015EB 8B4604                  		mov	ax,[MULTIPLICAND_L] ; xl
  8093 000015EE F7E1                    		mul	cx ; xl*yl
  8094 000015F0 5D                      		pop	bp
  8095 000015F1 C20800                  		retn	8
  8096                                  mul32_1:
  8097 000015F4 53                      		push	bx
  8098 000015F5 F7E1                    		mul	cx ; xh*yl
  8099 000015F7 89C3                    		mov	bx,ax ; (xh*yl)
  8100 000015F9 8B4604                  		mov	ax,[MULTIPLICAND_L] ; xl 
  8101 000015FC F7660A                  		mul	word [MULTIPLIER_H] ; yh
  8102 000015FF 01C3                    		add	bx,ax ; (xh*yl)+(xl*yh)
  8103 00001601 8B4604                  		mov	ax,[MULTIPLICAND_L] ; xl
  8104 00001604 F7E1                    		mul	cx ; xl*yl
  8105 00001606 01DA                    		add	dx,bx ; (H(xl*yl)+(xh*yl)+(xl*yh))
  8106                                  			      ; ax = L(xl*yl)	
  8107 00001608 5B                      		pop	bx
  8108 00001609 5D                      		pop	bp
  8109 0000160A C20800                  		retn	8
  8110                                  			; 132*9
  8111                                  			; yl = 32, yh = 1
  8112                                  			; xl = 9, xh = 0
  8113                                  			; xh*yl = 0, xl*yh = 9
  8114                                  			; 32*9 = 288, H(xl*yl) = 2, L(xl*yl) = 88 (AA)
  8115                                  			; 2+9 = 11 (BB)
  8116                                  			; 132*9 = 1188 (BBAA)
  8117                                  
  8118                                  ; 32 bit shift (Microsoft C 6.0 runtime library, MSDOS 6.0, 1991)	
  8119                                  ; ============================================================================
  8120                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 16/11/2018)
  8121                                  
  8122                                  shr32:
  8123                                  		;xor	ch,ch
  8124                                  		;jcxz	short shr32_1
  8125                                  shr32_0:
  8126 0000160D D1EA                    		shr	dx,1
  8127 0000160F D1D8                    		rcr	ax,1
  8128                                  		;loop	shr32_0
  8129 00001611 FEC9                    		dec	cl
  8130 00001613 75F8                    		jnz	short shr32_0
  8131                                  shr32_1:
  8132 00001615 C3                      		retn
  8133                                  
  8134                                  ; 32 bit division (Microsoft C 6.0 runtime library, MSDOS 6.0, 1991)	
  8135                                  ; ============================================================================
  8136                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 21/11/2018)
  8137                                  
  8138                                  ;	%define dividend_lw bp+4
  8139                                  ;	%define dividend_hw bp+6
  8140                                  ;	%define divisor_lw  bp+8
  8141                                  ;	%define divisor_hw  bp+10
  8142                                  ;
  8143                                  ;		push	bp
  8144                                  ;		mov	bp,sp
  8145                                  ;		push	bx
  8146                                  ;		push	si
  8147                                  ;		mov	ax,[divisor_hw]
  8148                                  ;		or	ax,ax
  8149                                  ;		jnz	short div32_0
  8150                                  ;		mov	cx,[divisor_lw]
  8151                                  ;		mov	ax,[dividend_hw]
  8152                                  ;		xor	dx,dx
  8153                                  ;		div	cx
  8154                                  ;		mov	bx,ax
  8155                                  ;		mov	ax,[dividend_lw]
  8156                                  ;		div	cx
  8157                                  ;		mov	dx,bx
  8158                                  ;		jmp	short div32_4
  8159                                  ;div32_0:
  8160                                  ;		mov	cx,ax
  8161                                  ;		mov	bx,[divisor_lw]
  8162                                  ;		mov	dx,[dividend_hw]
  8163                                  ;		mov	ax,[dividend_lw]
  8164                                  ;div32_1:
  8165                                  ;		shr	cx,1
  8166                                  ;		rcr	bx,1
  8167                                  ;		shr	dx,1
  8168                                  ;		rcr	ax,1
  8169                                  ;		or	cx,cx
  8170                                  ;		jnz	short div32_1
  8171                                  ;		div	bx
  8172                                  ;		mov	si,ax
  8173                                  ;		mul	word [divisor_hw]
  8174                                  ;		xchg	ax,cx
  8175                                  ;		mov	ax,[divisor_lw]
  8176                                  ;		mul	si
  8177                                  ;		add	dx,cx
  8178                                  ;		jc	short div32_2
  8179                                  ;		cmp	dx,[dividend_hw]
  8180                                  ;		ja	short div32_2
  8181                                  ;		jb	short div32_3
  8182                                  ;		cmp	ax,[dividend_lw]
  8183                                  ;		jbe	short div32_3
  8184                                  ;div32_2:
  8185                                  ;		dec	si
  8186                                  ;div32_3:
  8187                                  ;		xor	dx,dx
  8188                                  ;		xchg	ax,si
  8189                                  ;div32_4:
  8190                                  ;		pop	si
  8191                                  ;		pop	bx
  8192                                  ;		pop	bp
  8193                                  ;		retn	8
  8194                                  
  8195                                  ; 11/12/2018
  8196                                  div32:
  8197                                  		; 21/11/2018
  8198                                  		; DX:AX = Dividend
  8199                                  		; CX = Divisor
  8200                                  
  8201 00001616 89C3                    		mov	bx,ax  ; dividend_lw	
  8202 00001618 89D0                    		mov	ax,dx  ; dividend_hw
  8203 0000161A 31D2                    		xor	dx,dx
  8204 0000161C F7F1                    		div	cx	
  8205 0000161E 93                      		xchg	bx,ax
  8206 0000161F F7F1                    		div	cx
  8207                                  		;mov	dx,bx
  8208 00001621 87D3                    		xchg	dx,bx
  8209                                  
  8210                                  		; DX:AX = Quotient
  8211                                  		; BX = Remainder 
  8212                                  
  8213 00001623 C3                      		retn
  8214                                  
  8215                                  ; Remainder after 32 bit signed division (Microsoft C 6.0 runtime library)	
  8216                                  ; ============================================================================
  8217                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 26/11/2018)
  8218                                  
  8219                                  ;;Note: This subroutine is not needed for assembly language programming
  8220                                  ;; because, remainder is ready after a 32 bit division in dx (for 32/16 div)
  8221                                  ;; or bx (for 32/32 division, div32) register.
  8222                                  ; (as above!!) 
  8223                                  
  8224                                  ;_mod32:
  8225                                  ;	%define _dividend_lw_ bp+4
  8226                                  ;	%define _dividend_hw_ bp+6
  8227                                  ;	%define _divisor_lw_  bp+8
  8228                                  ;	%define _divisor_hw_  bp+10	
  8229                                  ;
  8230                                  ;		push	bp
  8231                                  ;		mov	bp,sp
  8232                                  ;		push	bx
  8233                                  ;		push	di
  8234                                  ;		xor	di,di
  8235                                  ;		mov	ax,[_dividend_hw_]
  8236                                  ;		or	ax,ax
  8237                                  ;		jge	short _mod32_0
  8238                                  ;		inc	di
  8239                                  ;		mov	dx,[_dividend_lw_]
  8240                                  ;		neg	ax
  8241                                  ;		neg	dx
  8242                                  ;		sbb	ax,0
  8243                                  ;		mov	[_dividend_hw_],ax
  8244                                  ;		mov	[_dividend_lw_],dx
  8245                                  ;_mod32_0:
  8246                                  ;		mov	ax,[_divisor_hw_]
  8247                                  ;		or	ax,ax
  8248                                  ;		jge	short _mod32_1
  8249                                  ;		mov	dx,[_divisor_lw_]
  8250                                  ;		neg	ax
  8251                                  ;		neg	dx
  8252                                  ;		sbb	ax,0
  8253                                  ;		mov	[_divisor_hw_],ax
  8254                                  ;		mov	[_divisor_lw_],dx
  8255                                  ;_mod32_1:
  8256                                  ;		or	ax,ax
  8257                                  ;		jnz	short _mod32_2
  8258                                  ;		mov	cx,[_divisor_lw_]
  8259                                  ;		mov	ax,[_dividend_hw_]
  8260                                  ;		xor	dx,dx
  8261                                  ;		div	cx
  8262                                  ;		mov	ax,[_dividend_lw_]
  8263                                  ;		div	cx
  8264                                  ;		mov	ax,dx
  8265                                  ;		xor	dx,dx
  8266                                  ;		dec	di
  8267                                  ;		jns	short _mod32_6
  8268                                  ;		jmp	short _mod32_7
  8269                                  ;_mod32_2:
  8270                                  ;		mov	bx,ax
  8271                                  ;		mov	cx,[_divisor_lw_]
  8272                                  ;		mov	dx,[_dividend_hw_]
  8273                                  ;		mov	ax,[_dividend_lw_]
  8274                                  ;_mod32_3:
  8275                                  ;		shr	bx,1
  8276                                  ;		rcr	cx,1
  8277                                  ;		shr	dx,1
  8278                                  ;		rcr	ax,1
  8279                                  ;		or	bx,bx
  8280                                  ;		jnz	short _mod32_3
  8281                                  ;		div	cx
  8282                                  ;		mov	cx,ax
  8283                                  ;		mul	[_divisor_hw_]
  8284                                  ;		xchg	ax,cx
  8285                                  ;		mul	[_divisor_lw_]
  8286                                  ;		add	dx,cx
  8287                                  ;		jb	short _mod32_4
  8288                                  ;		cmp	dx,[_dividend_hw_]
  8289                                  ;		ja	short _mod32_4
  8290                                  ;		jb	short _mod32_5
  8291                                  ;		cmp	ax,[_dividend_lw_]
  8292                                  ;		jbe	short _mod32_5
  8293                                  ;_mod32_4:
  8294                                  ;		sub	ax,[_divisor_lw_]
  8295                                  ;		sbb	dx,[_divisor_hw_]
  8296                                  ;_mod32_5:
  8297                                  ;		sub	ax,[_dividend_lw_]
  8298                                  ;		sbb	dx,[_dividend_hw_]
  8299                                  ;		dec	di
  8300                                  ;		jns	short _mod32_7
  8301                                  ;_mod32_6:
  8302                                  ;		neg	dx
  8303                                  ;		neg	ax
  8304                                  ;		sbb	dx,0
  8305                                  ;_mod32_7:
  8306                                  ;		; DX:AX = Remainder
  8307                                  ;		pop	di
  8308                                  ;		pop	bx
  8309                                  ;		pop	bp
  8310                                  ;		retn	8
  8311                                  
  8312                                  ;=============================================================================
  8313                                  ;DOSEXIT (doscall.h, MSDOS 6.0, 1991) & 
  8314                                  ;=============================================================================
  8315                                  
  8316                                  ; doscall.h (doscall.h, fdisk, MSDOS 6.0, 1991)
  8317                                  ; ----------------------------------------------------------------------------
  8318                                  ;/***	DosExit - Exit a program
  8319                                  ; *
  8320                                  ; *	This call is issued when a thread completes its execution.
  8321                                  ; *	The current thread is ended.
  8322                                  ; */
  8323                                  ;
  8324                                  ;extern void far pascal DOSEXIT (
  8325                                  ;	unsigned,			/* 0=end current thread, 1=end all */
  8326                                  ;	unsigned );			/* Result Code to save for DosCwait */
  8327                                  
  8328                                  ; dos.asm (MSDOS 6.0, lib\common, 1991)
  8329                                  ;*--------------------------------------------------------------------------*
  8330                                  ;*                                                                          *
  8331                                  ;*  DosExit(ec);                                                            *
  8332                                  ;*                                                                          *
  8333                                  ;*  Terminate program                                                       *
  8334                                  ;*                                                                          *
  8335                                  ;*--------------------------------------------------------------------------*
  8336                                  
  8337                                  ;cProc DosExit, <FAR, PUBLIC>
  8338                                  ;ParmW   ec
  8339                                  ;cBegin
  8340                                  ;        mov     al,byte ptr ec
  8341                                  ;        mov     ah,4Ch
  8342                                  ;        int     21h
  8343                                  ;cEnd
  8344                                  
  8345                                  
  8346                                  ; DOSEXIT (IBM PC-DOS 7.0, FDISK, segment 2, 005DFh)
  8347                                  ; ----------------------------------------------------------------------------
  8348                                  
  8349                                  ;DOSEXIT:	;proc near (Erdogan Tan)	; proc far (Original)
  8350                                  ;
  8351                                  ;%define ret_code bp+4 ; bp+6 ; word
  8352                                  ;%define end_op	  bp+6 ; bp+8 ; word
  8353                                  ;
  8354                                  ;		push	bp
  8355                                  ;		mov	bp,sp
  8356                                  ;		push	bx
  8357                                  ;		push	cx
  8358                                  ;		push	dx
  8359                                  ;		push	si
  8360                                  ;		push	di
  8361                                  ;		push	ds
  8362                                  ;		push	es
  8363                                  ;		push	ss
  8364                                  ;		push	bp
  8365                                  ;		mov	ax,[end_op]
  8366                                  ;		cmp	ax,1
  8367                                  ;		jg	short dosexit_0
  8368                                  ;		mov	ax,[ret_code]
  8369                                  ;		mov	ah,4Ch
  8370                                  ;		int	21h		; DOS -	2+ - QUIT WITH EXIT CODE (EXIT)
  8371                                  ;					; AL = exit code
  8372                                  ;		xor	ax, ax
  8373                                  ;dosexit_0:
  8374                                  ;		pop	bp
  8375                                  ;		pop	ss
  8376                                  ;		pop	es
  8377                                  ;		pop	ds
  8378                                  ;		pop	di
  8379                                  ;		pop	si
  8380                                  ;		pop	dx
  8381                                  ;		pop	cx
  8382                                  ;		pop	bx
  8383                                  ;		mov	sp,bp
  8384                                  ;		pop	bp
  8385                                  ;		;retf	4
  8386                                  ;		retn	4
  8387                                  
  8388                                  ; ----------------------------------------------------------------------------
  8389                                  ; display.c (FDISK, MSDOS 6.0, 1991)	
  8390                                  ; ----------------------------------------------------------------------------
  8391                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 16/11/2018)
  8392                                  			
  8393                                  ;/*  */
  8394                                  ;/******************* START OF SPECIFICATIONS *******************/
  8395                                  ;/*                                                             */
  8396                                  ;/* SUBROUTINE NAME: DISPLAY                                    */
  8397                                  ;/*                                                             */
  8398                                  ;/* DESCRIPTIVE NAME: Display full screen interface messages    */
  8399                                  ;/*                                                             */
  8400                                  ;/* FUNCTION: Displays messages and handles control characters  */
  8401                                  ;/*                                                             */
  8402                                  ;/* NOTES:                                                      */
  8403                                  ;/*  FDISK MESSAGES                                             */
  8404                                  ;/* Portions of the screen that are handled in the msg are      */
  8405                                  ;/* indicated on the listing of the screen with the message     */
  8406                                  ;/* name given.  If the text message is defined in another      */
  8407                                  ;/* screen, then the name is followed by a "#" character        */
  8408                                  ;/*                                                             */
  8409                                  ;/* NOTE TO TRANSLATORS The characters inside the <> and the [] */
  8410                                  ;/* are control characters and should not be translated.  The   */
  8411                                  ;/* Control characters are defined as follows:                  */
  8412                                  ;/*                                                             */
  8413                                  ;/* <H> - Highlight the following text                          */
  8414                                  ;/* <R> - Regular text                                          */
  8415                                  ;/* <B> - Blink the following text                              */
  8416                                  ;/* <O> - Turn blinking off                                     */
  8417                                  ;/* <Y> - Print YES character, as set by define                 */
  8418                                  ;/* <N> - Print NO character, as set by define                  */
  8419                                  ;/* <W> - Sound the beep                                        */
  8420                                  ;/* <S> - Save cursor position for later use                    */
  8421                                  ;/* <I> - Insert character from insert[] string. This string    */
  8422                                  ;/*       must be set up prior to displaying the message. The   */
  8423                                  ;/*       first <I> will insert Insert[0], the second           */
  8424                                  ;/*       insert[1], etc....This will move the cursor one       */
  8425                                  ;/*       position. The insert[] string will be initialized     */
  8426                                  ;/*                                                             */
  8427                                  ;/* Multiple control characters can be between the <>.          */
  8428                                  ;/*                                                             */
  8429                                  ;/* The ^####^indicates Row and column for the text and has the */
  8430                                  ;/* format of [rrcc] where the numbers are decimal and zero     */
  8431                                  ;/* based (first row/col is 00.  The numbers are in decimal,    */
  8432                                  ;/* and must be 2 characters, which means rows/cols 0-9 should  */
  8433                                  ;/* be listed as 00-09.  For example, the 5th row, 3rd column   */
  8434                                  ;/* on the screen would be listed as ^0402^.                    */
  8435                                  ;/*                                                             */
  8436                                  ;/* The column number is always the column desired.  The row    */
  8437                                  ;/* number is an offset from the previous row.  For example, if */
  8438                                  ;/* the text just printed is on row 6, and the next text should */
  8439                                  ;/* be printed 2 rows down in column 0, then the control strin  */
  8440                                  ;/* would be ^0201^.  The first row specified in the message is */
  8441                                  ;/* assumed to be based off of row 0, it would actually specify */
  8442                                  ;/* the actual row for the start of the msg to be printed.      */
  8443                                  ;/*                                                             */
  8444                                  ;/* ENTRY POINTS: display(*message_name);                       */
  8445                                  ;/*      LINKAGE: Near call                                     */
  8446                                  ;/*                                                             */
  8447                                  ;/* INPUT: char *message_name                                   */
  8448                                  ;/*                                                             */
  8449                                  ;/* EXIT-NORMAL:                                                */
  8450                                  ;/*                                                             */
  8451                                  ;/* EXIT-ERROR:                                                 */
  8452                                  ;/*                                                             */
  8453                                  ;/* EFFECTS:                                                    */
  8454                                  ;/* input_row changed if <S> control character in message       */
  8455                                  ;/* input_col changed if <S> control character in message       */
  8456                                  ;/*                                                             */
  8457                                  ;/* INTERNAL REFERENCES:                                        */
  8458                                  ;/*   ROUTINES:                                                 */
  8459                                  ;/*                                                             */
  8460                                  ;/* EXTERNAL REFERENCES:                                        */
  8461                                  ;/*   ROUTINES:                                                 */
  8462                                  ;/*                                                             */
  8463                                  ;/* viowrtcharstratt();                                         */
  8464                                  ;/******************** END OF SPECIFICATIONS ********************/
  8465                                  ;/*  */
  8466                                  
  8467                                  ;void display(s)
  8468                                  ;
  8469                                  ;char far *s;
  8470                                  ;
  8471                                  ;BEGIN
  8472                                  ;       unsigned      row;
  8473                                  ;       unsigned      col;
  8474                                  ;       char          attribute;
  8475                                  ;       char far      *attribute_ptr = &attribute;
  8476                                  ;       unsigned      insert_count;
  8477                                  ;
  8478                                  ;       /* Initialize row and col, and index into array */
  8479                                  ;       row = u(0);							/* AC000 */
  8480                                  ;       col = u(0);							/* AC000 */
  8481                                  ;       insert_count = u(0);						/* AC000 */
  8482                                  ;       /* check for a request to display a null string */
  8483                                  ;       if (*s == c('\0'))						/* AC000 */
  8484                                  ;          BEGIN
  8485                                  ;           /* Message string error */
  8486                                  ;           insert[0] = c('1');						/* AC000 */
  8487                                  ;           display(debug_msg);
  8488                                  ;          END
  8489                                  ;       else
  8490                                  ;          BEGIN
  8491                                  ;           /* There is data there, lets go handle it */
  8492                                  ;
  8493                                  ;			  if (status_flag == TRUE )
  8494                                  ;				attribute = video_attribute;
  8495                                  ;			  else
  8496                                  ;           			attribute = c(0x00);			/* AC000 */
  8497                                  ;
  8498                                  ;           /* Go until end of string */
  8499                                  ;           while (*s != c('\0'))                                       /* AC000 */
  8500                                  ;              BEGIN
  8501                                  ;
  8502                                  ;               /* Check for any imbedded control strings */
  8503                                  ;               switch (*s)
  8504                                  ;                  BEGIN
  8505                                  ;                   /* Check for control characters */
  8506                                  ;                   case '<':
  8507                                  ;			BEGIN
  8508                                  ;                         s++;
  8509                                  ;                         while ( (*s != c('>')) && (*s != c('\0')) ) /* AC000 */
  8510                                  ;			      BEGIN
  8511                                  ;                             	switch (*s++)
  8512                                  ;				     BEGIN
  8513                                  ;					case 'H': if (status_flag == FALSE)
  8514                                  ;						     {				
  8515                                  ;						       if (mono_flag == TRUE)				     /* AN006 */
  8516                                  ;                                                      	  attribute = (attribute & 0x80) | HIWHITE_ON_BLACK; /* AN006 */
  8517                                  ;                                                      else						     /* AN006 */
  8518                                  ;                                                      	  attribute = (attribute & 0x80) | HIWHITE_ON_BLUE;  /* AC006 */
  8519                                  ;						     }
  8520                                  ;						  else
  8521                                  ;						       attribute = (attribute & 0x80) | video_attribute;
  8522                                  ;						       break;
  8523                                  ;					case 'R': if (status_flag == FALSE)
  8524                                  ;						     {				
  8525                                  ;						       if (mono_flag == TRUE)				  /* AN006 */
  8526                                  ;                                                         attribute = (attribute & 0x80) | GRAY_ON_BLACK; /* AN006 */
  8527                                  ;                                                      else						  /* AN006 */
  8528                                  ;							  attribute = (attribute & 0x80) | WHITE_ON_BLUE; /* AC006 */
  8529                                  ;						     }
  8530                                  ;						  else
  8531                                  ;						       attribute = (attribute & 0x80) | video_attribute;
  8532                                  ;						       break;
  8533                                  ;					case 'B': attribute |= 0x80;
  8534                                  ;                                                 break;
  8535                                  ;					case 'O': attribute &= 0x7F;
  8536                                  ;                                                 break;
  8537                                  ;					case 'W': DOSBEEP(u(900),u(400)); /* AC000 */
  8538                                  ;                                                 break;
  8539                                  ;					case 'I': if (status_flag == TRUE)
  8540                                  ;						    attribute = video_attribute;
  8541                                  ;						  else
  8542                                  ;						    BEGIN
  8543                                  ;							/* display next element in the array */
  8544                                  ;                                                  	if ((mono_flag == TRUE) && (attribute == c(0x00)))  /* AN006 */
  8545                                  ;                                                      	   attribute = c(GRAY_ON_BLACK);		    /* AN006 */
  8546                                  ;                                                  	if ((mono_flag == FALSE) && (attribute == c(0x00))) /* AN006 */
  8547                                  ;                                                      	   attribute = c(WHITE_ON_BLUE);		    /* AC006 */
  8548                                  ;						    END
  8549                                  ;              					  VIOWRTCHARSTRATT(pinsert+insert_count++,u(1),row,col++,attribute_ptr,u(0));
  8550                                  ;                                                 break;
  8551                                  ;					case 'Y':                                                          /* AC011 */
  8552                                  ;                                                 BEGIN
  8553                                  ;                                                   /* display YES character in next location */
  8554                                  ;                                                   if ((mono_flag == TRUE) && (attribute == c(0x00)))      /* AN006 */
  8555                                  ;                                                      attribute = c(GRAY_ON_BLACK);                       /* AN006 */
  8556                                  ;                                                   if ((mono_flag == FALSE) && (attribute == c(0x00)))     /* AN006 */
  8557                                  ;                                                      attribute = c(WHITE_ON_BLUE);                       /* AC006 */
  8558                                  ;                                                   VIOWRTCHARSTRATT(&Yes,u(1),row,col++,attribute_ptr,u(0)); /* AC000 */
  8559                                  ;                                                   break;
  8560                                  ;                                                 END
  8561                                  ;					case 'N':                                                          /* AC011 */
  8562                                  ;                                                 BEGIN
  8563                                  ;                                                   /* display NO character in next location */
  8564                                  ;                                                   if ((mono_flag == TRUE) && (attribute == c(0x00)))      /* AN006 */
  8565                                  ;                                                      attribute = c(GRAY_ON_BLACK);                       /* AN006 */
  8566                                  ;                                                   if ((mono_flag == FALSE) && (attribute == c(0x00)))     /* AN006 */
  8567                                  ;                                                      attribute = c(WHITE_ON_BLUE);                       /* AC006 */
  8568                                  ;                                                   VIOWRTCHARSTRATT(&No,u(1),row,col++,attribute_ptr,u(0)); /* AC000 */
  8569                                  ;                                                   break;
  8570                                  ;                                                 END
  8571                                  ;					case 'S':
  8572                                  ;                                                 BEGIN
  8573                                  ;                                                   input_row = row;
  8574                                  ;                                                   input_col = col;
  8575                                  ;                                                   break;
  8576                                  ;                                                 END
  8577                                  ;					case 'C':
  8578                                  ;                                                 BEGIN
  8579                                  ;                                                   /* Clear from current position to end of line */
  8580                                  ;                                                   clear_screen(row,col,row,u(79)); /* AC000 */
  8581                                  ;                                                   break;
  8582                                  ;                                                 END
  8583                                  ;					case '\0':
  8584                                  ;                                                 BEGIN
  8585                                  ;                                                   /* Message string error - string ended in the middle of control string*/
  8586                                  ;                                                   insert[0] = c('7');	/* AC000 */
  8587                                  ;                                                   display(debug_msg);
  8588                                  ;                                                   break;
  8589                                  ;						  END
  8590                                  ;					default:
  8591                                  ;                                                 BEGIN
  8592                                  ;                                                   /* Message string error - no valid control char found */
  8593                                  ;                                                   insert[0] = c('6');	/* AC000 */
  8594                                  ;                                                   display(debug_msg);
  8595                                  ;                                                   break;
  8596                                  ;                                                 END
  8597                                  ;				   END /* Switch */
  8598                                  ;			     END /* While */
  8599                                  ;			     /* Get the pointer past the '>' */
  8600                                  ;                            s++;
  8601                                  ;                            break;
  8602                                  ;                        END /* control characters */
  8603                                  ;
  8604                                  ;                   /* Check for row,col */
  8605                                  ;                   case '':                                           /* AC000 */
  8606                                  ;			BEGIN
  8607                                  ;			     s++;
  8608                                  ;                            /* determine the row to put the message on */
  8609                                  ;                            if ( !isdigit(*s) )
  8610                                  ;				BEGIN
  8611                                  ;				   /* Message string error */
  8612                                  ;                                  insert[0] = c('2');                  /* AC000 */
  8613                                  ;                                  display(debug_msg);
  8614                                  ;				END
  8615                                  ; 			     else
  8616                                  ;				BEGIN
  8617                                  ;                                  row = row+((unsigned)(((*s++ - '0')*10)));
  8618                                  ;                                  if ( !isdigit(*s) )
  8619                                  ;                                     BEGIN
  8620                                  ;                                       /* Message string error */
  8621                                  ;                                       insert[0] = c('2');               /* AC000 */
  8622                                  ;                                       display(debug_msg);
  8623                                  ;                                     END
  8624                                  ;                                  else
  8625                                  ;                                     BEGIN
  8626                                  ;                                       row = row+((unsigned)(*s++ - '0'));
  8627                                  ;                                       /* determine the col to put the message on */
  8628                                  ;                                       if ( !isdigit(*s) )
  8629                                  ;                                          BEGIN
  8630                                  ;                                            /* Message string error */
  8631                                  ;                                            insert[0] = c('3');          /* AC000 */
  8632                                  ;                                            display(debug_msg);
  8633                                  ;                                          END
  8634                                  ;					else
  8635                                  ;                                          BEGIN
  8636                                  ;                                            col = ((unsigned)(*s++ - '0'));
  8637                                  ;                                            if ( !isdigit(*s) )
  8638                                  ;                                               BEGIN
  8639                                  ;                                                 /* Message string error */
  8640                                  ;                                                 insert[0] = c('3');      /* AC000 */
  8641                                  ;                                                 display(debug_msg);
  8642                                  ;                                               END
  8643                                  ;					     else
  8644                                  ;                                                BEGIN
  8645                                  ;                                                 col = ((unsigned)((col* 10) + (*s++ - '0')));
  8646                                  ;                                                 if (*s++ != c(''))      /* AC000 */
  8647                                  ;                                                    BEGIN
  8648                                  ;                                                      /* Message string error */
  8649                                  ;                                                      insert[0] = c('4');  /* AC000 */
  8650                                  ;                                                      display(debug_msg);
  8651                                  ;                                                    END /* 2nd sq bracket */
  8652                                  ;                                                 END /* 2nd digit col */
  8653                                  ;                                               END /* 1st digit col */
  8654                                  ;                                           END /* 2nd digit row */
  8655                                  ;                                       END /* 1st digit row */
  8656                                  ;                              		break;
  8657                                  ;				END
  8658                                  ;                   /* Handle anything else */
  8659                                  ;                   default:
  8660                                  ;			BEGIN
  8661                                  ;			   /* See if attribute set to anything */
  8662                                  ;                          if ((mono_flag == FALSE) && (attribute == c(0x00)))	/* AN006 */
  8663                                  ;			      attribute = c(WHITE_ON_BLUE);			/* AC006 */
  8664                                  ;			   if ((mono_flag == TRUE) && (attribute == c(0x00)))	/* AN006 */
  8665                                  ;			      attribute = c(GRAY_ON_BLACK);			/* AN006 */
  8666                                  ;		   ;#ifdef DBCS    /* MSKK01 07/18/89 */
  8667                                  ;		   ;       VIOWRTCHARSTRATT(s,u(1),row,col++,attribute_ptr,u(0)); /* AC000 */
  8668                                  ;			   if (IsDBCSLeadByte( (unsigned char)*s ))
  8669                                  ;			      VIOWRTCHARSTRATT(++s,u(1),row,col++,attribute_ptr,u(0)); /* AC000 */
  8670                                  ;			   s++;
  8671                                  ;		   ;#else
  8672                                  ;                          VIOWRTCHARSTRATT(s++,u(1),row,col++,attribute_ptr,u(0)); /* AC000 */
  8673                                  ;		   ;#endif
  8674                                  ;                          break;
  8675                                  ;                       END
  8676                                  ;                  END
  8677                                  ;              END /* End of string check */
  8678                                  ;          END /* No characters in string check */
  8679                                  ;       return;
  8680                                  ;
  8681                                  ;END
  8682                                  
  8683                                  ; 19/11/2018
  8684                                  
  8685                                  display:
  8686                                  		%define	col 	      bp-12 ; word
  8687                                  		%define	insert_count  bp-10 ; word
  8688                                  		%define attribute_ptr bp-8  ; dword
  8689                                  		%define	row 	      bp-4  ; word
  8690                                  		%define attribute     bp-2  ; word
  8691                                  
  8692                                  		%define _s_ 	      bp+4  ; arg_0, dword
  8693                                  
  8694 00001624 55                      		push	bp
  8695 00001625 89E5                    		mov	bp,sp
  8696 00001627 83EC0C                  		sub	sp,12
  8697                                  
  8698 0000162A 8D46FE                  		lea	ax,[attribute]
  8699 0000162D 8946F8                  		mov	[attribute_ptr],ax
  8700 00001630 8C56FA                  		mov	[attribute_ptr+2],ss
  8701                                  
  8702                                  		;/* Initialize row and col, and index into array */
  8703 00001633 29C0                    		sub	ax,ax ; 0
  8704 00001635 8946FC                  		mov	[row],ax
  8705 00001638 8946F4                  		mov	[col],ax
  8706 0000163B 8946F6                  		mov	[insert_count],ax
  8707                                  
  8708 0000163E 8846FE                  		mov	[attribute],al ; 0 ; 19/11/2018
  8709                                  		
  8710                                  		;/* check for a request to display a null string */
  8711                                  		
  8712                                  		;if (*s == c('\0')) 
  8713 00001641 C45E04                  		les	bx,[_s_]
  8714 00001644 26803F00                		cmp	byte [es:bx],0
  8715 00001648 7510                    		jne	short display_1
  8716                                  		;/* Message string error */
  8717 0000164A C606[F4CC]31            		mov	byte [insert],'1'
  8718                                  		;push	word [debug_msg_seg]
  8719 0000164F 1E                      		push	ds ; 17/11/2018
  8720 00001650 FF36[CE9E]              		push	word [debug_msg_off]
  8721 00001654 E8CDFF                  		call	display
  8722                                  		;pop	bx	; 19/11/2018 ; (!*!*)
  8723                                  		;pop	bx
  8724 00001657 E98302                  		jmp	display_43
  8725                                  display_1:
  8726                                  		;/* There is data there, lets go handle it */
  8727                                  
  8728                                  		;if (status_flag == TRUE )
  8729                                  		; 	attribute = video_attribute;
  8730                                  
  8731 0000165A 803E[E2C3]01            		cmp	byte [status_flag],1 ; TRUE
  8732 0000165F 7508                    		jne	short display_2
  8733 00001661 A0[1EC4]                		mov	al,[video_attribute]
  8734 00001664 8846FE                  		mov	[attribute],al
  8735 00001667 EB03                    		jmp	short display_3 ; 19/11/2018
  8736                                  ;display_2:
  8737                                  ;		;else
  8738                                  ;		;	attribute = c(0x00);
  8739                                  ;
  8740                                  ;		;mov	byte [attribute],0 ; 19/11/2018
  8741                                  ;display_3:
  8742                                  display_2:	;/* Go until end of string */
  8743                                  
  8744                                  		; while (*s != c('\0')) 
  8745 00001669 C45E04                  		les	bx,[_s_]
  8746                                  		;cmp	byte [es:bx],0
  8747                                  		;jne	short display_4
  8748                                  display_3:
  8749                                  		; 19/11/2018
  8750 0000166C 268A07                  		mov	al,[es:bx]
  8751 0000166F 08C0                    		or	al,al
  8752 00001671 7503                    		jnz	short display_4		
  8753 00001673 E96702                  		jmp	display_43
  8754                                  display_4:
  8755                                  		;/* Check for any imbedded control strings */
  8756                                  		
  8757                                  		;switch (*s)
  8758                                  		
  8759                                  		; /* Check for control characters */
  8760                                  		;mov	al,[es:bx]
  8761                                  		;cbw
  8762                                  		;sub	ax,6
  8763 00001676 30E4                    		xor	ah,ah
  8764 00001678 2C06                    		sub	al,6 ; Check for char 06h (ACK)
  8765 0000167A 7503                    		jnz	short sc_default ; default : 
  8766 0000167C E9C401                  		jmp	display_36 ; case '': 
  8767                                  sc_default:
  8768                                  		;sub	ax,'6' ; '<' (3Ch)
  8769 0000167F 2C36                    		sub	al,'6' ; 19/11/2018
  8770 00001681 743F                    		jz	short display_7  ; case '<':
  8771                                  
  8772                                  		;/* Handle anything else */
  8773                                  ;default:
  8774                                  		;/* See if attribute set to anything */
  8775 00001683 803E[D8C3]00            		cmp	byte [mono_flag],0 ; FALSE
  8776 00001688 7511                    		jne	short display_5
  8777                                  			;&&
  8778 0000168A 807EFE00                		cmp	byte [attribute],0
  8779                                  		;jne	short display_5
  8780 0000168E 7515                    		jne	short display_6 ; 19/11/2018
  8781 00001690 C646FE17                		mov	byte [attribute],17h ; WHITE_ON_BLUE
  8782                                  ;display_5:
  8783 00001694 803E[D8C3]01            		cmp	byte [mono_flag],1 ; TRUE
  8784 00001699 750A                    		jne	short display_6
  8785                                  			;&&
  8786                                  display_5: ; 19/11/2018
  8787 0000169B 807EFE00                		cmp	byte [attribute],0
  8788 0000169F 7504                    		jne	short display_6
  8789 000016A1 C646FE07                		mov	byte [attribute],7 ; GRAY_ON_BLACK
  8790                                  display_6:
  8791                                  		;VIOWRTCHARSTRATT(s++,u(1),row,col++,attribute_ptr,u(0))
  8792 000016A5 06                      		push	es
  8793 000016A6 53                      		push	bx
  8794 000016A7 FF4604                  		inc	word [_s_]
  8795 000016AA B80100                  		mov	ax,1
  8796 000016AD 50                      		push	ax
  8797 000016AE FF76FC                  		push	word [row]
  8798 000016B1 FF76F4                  		push	word [col]			
  8799                                  		;inc	word [col]
  8800 000016B4 FE46F4                  		inc	byte [col]
  8801                                  		;push	ss ; 17/11/2018
  8802 000016B7 FF76FA                  		push	word [attribute_ptr+2]	; segment
  8803 000016BA FF76F8                  		push	word [attribute_ptr]	; offset
  8804                                  		; 19/11/2018
  8805                                  		;sub	ax,ax ; 0
  8806                                  		;push	ax
  8807 000016BD E82302                  		call	VIOWRTCHARSTRATT
  8808                                  		;jmp	short display_3
  8809 000016C0 EBA7                    		jmp	short display_2 ; 19/11/2018
  8810                                  display_7:
  8811                                  ;case '<':
  8812                                  		;s++;
  8813 000016C2 FF4604                  		inc	word [_s_]
  8814                                  sc_break:
  8815                                  		;while ( (*s != c('>')) && (*s != c('\0')) ) /* AC000 */
  8816                                  
  8817 000016C5 C45E04                  		les	bx,[_s_]
  8818 000016C8 268A07                  		mov	al,[es:bx]
  8819                                  		;cmp	byte ptr [es:bx],'>'
  8820 000016CB 3C3E                    		cmp	al,'>'
  8821 000016CD 7503                    		jne	short display_8 ; &&
  8822 000016CF E96B01                  		jmp	display_35
  8823                                  display_8:
  8824                                  		;cmp	byte [es:bx], 0
  8825                                  		;jne	short display_9
  8826 000016D2 20C0                    		and	al,al	; cmp al,0
  8827 000016D4 7503                    		jnz	short display_9
  8828 000016D6 E96401                  		jmp	display_35
  8829                                  display_9:
  8830                                  		;switch (*s++)
  8831 000016D9 FF4604                  		inc	word [_s_]
  8832                                  		;mov	al,[es:bx] ; 19/11/2018
  8833                                  		;cbw
  8834                                  		;cmp	ax,'Y'
  8835 000016DC 3C59                    		cmp	al,'Y'
  8836 000016DE 7503                    		jne	short display_10
  8837 000016E0 E9DF00                  		jmp	case_Y  ; case 'Y'
  8838                                  display_10:
  8839 000016E3 7733                    		ja	short display_17
  8840                                  		; 19/11/2018
  8841                                  		;or	al,al
  8842                                  		;jnz	short display_11
  8843                                  		;jmp	case_0  ; case '\0'
  8844                                  display_11:
  8845 000016E5 2C42                    		sub	al,'B'
  8846 000016E7 7503                    		jnz	short display_12
  8847 000016E9 E98A00                  		jmp	display_25  ; case 'B'
  8848                                  display_12:
  8849                                  		; AL > 0 and AL < 'Y'-'B'
  8850 000016EC FEC8                    		dec	al ; AL = 1 ('C'-'B') ?
  8851 000016EE 7503                    		jnz	short display_13
  8852 000016F0 E93701                  		jmp	case_C	; case 'C'
  8853                                  display_13:	
  8854 000016F3 2C05                    		sub	al,5 ; AL = 5 ('H'-'C') ?
  8855 000016F5 7430                    		jz	short display_19 ; case 'H'
  8856 000016F7 FEC8                    		dec	al
  8857 000016F9 7503                    		jnz	short display_14
  8858 000016FB E98C00                  		jmp	case_I ; case 'I'
  8859                                  display_14:
  8860 000016FE 2C05                    		sub	al,5 ; AL = 5 ('N'-'I') ?
  8861 00001700 7503                    		jnz	short display_15
  8862 00001702 E9DD00                  		jmp	case_N	; case 'N'
  8863                                  display_15:
  8864 00001705 FEC8                    		dec	al   ; 'O' ?
  8865 00001707 7474                    		jz	short display_26  ; case 'O'
  8866 00001709 2C03                    		sub	al,3 ; 'R' ?
  8867 0000170B 7449                    		jz	short display_23  ; case 'R'	
  8868 0000170D FEC8                    		dec	al
  8869 0000170F 7503                    		jnz	short display_16
  8870 00001711 E90701                  		jmp	case_S  ; case 'S'
  8871                                  display_16:
  8872 00001714 2C04                    		sub	al,4  ; 'W' ?
  8873 00001716 746C                    		jz	short case_W ; case 'W'
  8874                                  display_17:
  8875                                  ;default:
  8876                                  		;/* Message string error - no valid control char found */
  8877 00001718 C606[F4CC]36            		mov	byte [insert],'6'
  8878                                  display_18:
  8879                                  		;push	word [debug_msg_seg]
  8880 0000171D 1E                      		push	ds ; 17/11/2018 
  8881 0000171E FF36[CE9E]              		push	word [debug_msg_off]
  8882 00001722 E8FFFE                  		call	display
  8883                                  		;pop	bx	; 19/11/2018 ; (!*!*)
  8884                                  		;pop	bx
  8885 00001725 EB9E                    		jmp	short sc_break
  8886                                  display_19:
  8887                                  ;case 'H':	;if (status_flag == FALSE)
  8888 00001727 803E[E2C3]00            		cmp	byte [status_flag],0
  8889 0000172C 751D                    		jne	short display_22
  8890 0000172E 803E[D8C3]01            		cmp	byte [mono_flag],1
  8891 00001733 7509                    		jne	short display_20
  8892                                  		;attribute = (attribute & 0x80) | HIWHITE_ON_BLACK;
  8893 00001735 8A46FE                  		mov	al,[attribute]
  8894 00001738 248F                    		and	al,8Fh
  8895 0000173A 0C0F                    		or	al,0Fh ; HIWHITE_ON_BLACK
  8896 0000173C EB07                    		jmp	short display_21
  8897                                  display_20:
  8898 0000173E 8A46FE                  		mov	al,[attribute]
  8899                                  		;attribute = (attribute & 0x80) | WHITE_ON_BLUE;
  8900 00001741 249F                    		and	al,9Fh
  8901 00001743 0C1F                    		or	al,1Fh ; WHITE_ON_BLUE
  8902                                  display_21:
  8903 00001745 8846FE                  		mov	byte [attribute],al
  8904 00001748 E97AFF                  		jmp	sc_break
  8905                                  display_22:	
  8906                                  		;(status_flag == TRUE)
  8907                                  		;attribute = (attribute & 0x80) | video_attribute;
  8908 0000174B 8A46FE                  		mov	al,[attribute]
  8909 0000174E 2480                    		and	al,80h
  8910 00001750 0A06[1EC4]              		or	al,[video_attribute]
  8911 00001754 EBEF                    		jmp	short display_21
  8912                                  display_23:
  8913                                  ;case 'R':
  8914                                  		;if (status_flag == FALSE)
  8915 00001756 803E[E2C3]00            		cmp	byte [status_flag],0
  8916 0000175B 75EE                    		jne	short display_22
  8917                                  		;if (mono_flag == TRUE) 
  8918 0000175D 803E[D8C3]01            		cmp	byte [mono_flag],1
  8919 00001762 7509                    		jne	short display_24
  8920                                  		;attribute = (attribute & 0x80) | GRAY_ON_BLACK
  8921 00001764 8A46FE                  		mov	al,[attribute]
  8922 00001767 2487                    		and	al,87h
  8923 00001769 0C07                    		or	al,7  ; GRAY_ON_BLACK
  8924 0000176B EBD8                    		jmp	short display_21
  8925                                  display_24:
  8926                                  		;attribute = (attribute & 0x80) | WHITE_ON_BLUE;
  8927 0000176D 8A46FE                  		mov	al,[attribute]
  8928 00001770 2497                    		and	al,97h
  8929 00001772 0C17                    		or	al,17h	; WHITE_ON_BLUE
  8930 00001774 EBCF                    		jmp	short display_21
  8931                                  display_25:
  8932                                  ; case 'B':	;attribute |= 0x80;
  8933 00001776 804EFE80                		or	byte [attribute],80h
  8934 0000177A E948FF                  		jmp	sc_break
  8935                                  display_26:
  8936                                  ;case 'O':	;attribute &= 0x7F;
  8937 0000177D 8066FE7F                		and	byte [attribute],7Fh
  8938 00001781 E941FF                  		jmp	sc_break
  8939                                  case_W:
  8940                                  		;DOSBEEP(u(900),u(400))
  8941                                  		;mov	ax,900
  8942                                  		;push	ax
  8943                                  		;mov	ax,400
  8944                                  		;push	ax
  8945 00001784 E8C001                  		call	DOSBEEP  ; 01/01/2019
  8946 00001787 E93BFF                  		jmp	sc_break
  8947                                  case_I:
  8948                                  		;if (status_flag == TRUE)
  8949 0000178A 803E[E2C3]01            		cmp	byte [status_flag],1
  8950 0000178F 7508                    		jne	short display_27
  8951                                  				;attribute = video_attribute;
  8952 00001791 A0[1EC4]                		mov	al,[video_attribute]
  8953 00001794 8846FE                  		mov	[attribute],al
  8954 00001797 EB1D                    		jmp	short display_29
  8955                                  
  8956                                  display_27:
  8957                                  		;(status_flag == FALSE)
  8958                                  
  8959                                  		;/* display next element in the array */
  8960                                  
  8961                                  		;if ((mono_flag == TRUE) &&
  8962 00001799 803E[D8C3]01            		cmp	byte [mono_flag],1
  8963 0000179E 750C                    		jne	short display_28
  8964                                  		; (attribute == c(0x00)))
  8965 000017A0 807EFE00                		cmp	byte [attribute],0
  8966                                  		;jne	short display_28
  8967 000017A4 7510                    		jne	short display_29 ; 17/11/2018
  8968                                  		;attribute = c(GRAY_ON_BLACK);      
  8969 000017A6 C646FE07                		mov	byte [attribute],7 ; GRAY_ON_BLACK
  8970 000017AA EB0A                    		jmp	short display_29 ; 17/11/2018
  8971                                  ;display_28:
  8972                                  ;		;if ((mono_flag == FALSE) &&
  8973                                  ;		cmp	byte [mono_flag],0
  8974                                  ;		jne	short display_29
  8975                                  display_28: ; 17/11/2018
  8976                                  		;(attribute == c(0x00)))
  8977 000017AC 807EFE00                		cmp	byte [attribute],0
  8978 000017B0 7504                    		jne	short display_29
  8979                                  		;attribute = c(WHITE_ON_BLUE);
  8980 000017B2 C646FE17                		mov	byte [attribute],17h ; WHITE_ON_BLUE
  8981                                  display_29:
  8982                                  		;VIOWRTCHARSTRATT(pinsert+insert_count++,u(1),row,col++,attribute_ptr,u(0));	
  8983                                  
  8984                                  		; pinsert+insert_count++
  8985 000017B6 8B46F6                  		mov	ax,[insert_count]
  8986 000017B9 FF46F6                  		inc	word [insert_count]
  8987 000017BC 0306[9870]              		add	ax,[pinsert]
  8988 000017C0 EB3E                    		jmp	short display_34
  8989                                  case_Y:
  8990                                  		;/* display YES character in next location */
  8991                                  
  8992 000017C2 803E[D8C3]01            		cmp	byte [mono_flag],1 ; TRUE
  8993 000017C7 750A                    		jne	short display_30
  8994                                  			; &&
  8995 000017C9 807EFE00                		cmp	byte [attribute],0
  8996                                  		;jne	short display_30
  8997 000017CD 750E                    		jne	short display_31 ; 17/11/2018
  8998                                  		;if ((mono_flag == TRUE) && (attribute == c(0x00))) 
  8999 000017CF C646FE07                		mov	byte [attribute],7 ;attribute = c(GRAY_ON_BLACK);
  9000                                  ;display_30:	
  9001                                  ;		;if ((mono_flag == FALSE) && (attribute == c(0x00)))
  9002                                  ;		cmp	byte [mono_flag],0  ; FALSE
  9003                                  ;		jne	short display_31
  9004                                  			; &&
  9005                                  display_30: ; 17/11/2018
  9006 000017D3 807EFE00                		cmp	byte [attribute],0
  9007 000017D7 7504                    		jne	short display_31
  9008 000017D9 C646FE17                		mov	byte [attribute], 17h ;attribute = c(WHITE_ON_BLUE);
  9009                                  display_31:
  9010                                  		;VIOWRTCHARSTRATT(&Yes,u(1),row,col++,attribute_ptr,u(0));
  9011                                  
  9012 000017DD B8[D9C3]                		mov	ax,Yes	; &YES, offset Yes
  9013 000017E0 EB1E                    		jmp	short display_34
  9014                                  case_N:
  9015                                  		;/* display NO character in next location */
  9016                                  
  9017 000017E2 803E[D8C3]01            		cmp	byte [mono_flag],1 ; TRUE
  9018 000017E7 750A                    		jne	short display_32
  9019                                  			; &&
  9020 000017E9 807EFE00                		cmp	byte [attribute],0
  9021                                  		;jne	short display_32
  9022 000017ED 750E                    		jne	short display_33 ; 17/11/2018
  9023                                  		;if ((mono_flag == TRUE) && (attribute == c(0x00))) 
  9024 000017EF C646FE07                		mov	byte [attribute],7 ;attribute = c(GRAY_ON_BLACK);
  9025                                  ;display_32:
  9026                                  ;		;if ((mono_flag == FALSE) && (attribute == c(0x00))) 
  9027                                  ;		cmp	byte [mono_flag],0 ; FALSE
  9028                                  ;		jne	short display_33
  9029                                  			; &&
  9030                                  display_32: ; 17/11/2018	
  9031 000017F3 807EFE00                		cmp	byte [attribute],0
  9032 000017F7 7504                    		jne	short display_33
  9033 000017F9 C646FE17                		mov	byte [attribute],17h ;attribute = c(WHITE_ON_BLUE);
  9034                                  display_33:
  9035 000017FD B8[ACA0]                		mov	ax,No	; &NO, offset No
  9036                                  
  9037                                  		;VIOWRTCHARSTRATT(&No,u(1),row,col++,attribute_ptr,u(0));
  9038                                  display_34:
  9039                                  		;VIOWRTCHARSTRATT(pinsert+insert_count++,u(1),row,col++,attribute_ptr,u(0));
  9040                                  		;VIOWRTCHARSTRATT(&Yes,u(1),row,col++,attribute_ptr,u(0));
  9041                                  
  9042                                  		; String address (far) to be written
  9043 00001800 1E                      		push	ds
  9044 00001801 50                      		push	ax ; pinsert+insert_count++ (display_29) or &YES (display_31)
  9045                                  			   ; or &NO (display_33)
  9046                                  		; Length of string	
  9047 00001802 B80100                  		mov	ax,1
  9048 00001805 50                      		push	ax
  9049                                  		; Starting row position for output
  9050 00001806 FF76FC                  		push	word [row]
  9051                                  		; Starting column position for output
  9052 00001809 FF76F4                  		push	word [col]
  9053                                  		;inc	word [col]
  9054 0000180C FE46F4                  		inc	byte [col]
  9055                                  		; Attribute address (far) to be replicated
  9056 0000180F FF76FA                  		push	word [attribute_ptr+2] ; segment
  9057 00001812 FF76F8                  		push	word [attribute_ptr] ; offset
  9058                                  		; Video handle (!is not used!)
  9059                                  		;sub	ax,ax
  9060                                  		;push	ax
  9061 00001815 E8CB00                  		call	VIOWRTCHARSTRATT
  9062 00001818 E9AAFE                  		jmp	sc_break
  9063                                  case_S:
  9064                                  ;case 'S':
  9065 0000181B 8B46FC                  		mov	ax,[row]
  9066 0000181E A3[4CA1]                		mov	[input_row],ax
  9067 00001821 8B46F4                  		mov	ax,[col]
  9068 00001824 A3[AAA0]                		mov	[input_col],ax
  9069 00001827 E99BFE                  		jmp	sc_break
  9070                                  case_C:
  9071                                  ;case 'C':
  9072                                  		; /* Clear from current position to end of line */
  9073                                  		
  9074                                  		;clear_screen(row,col,row,u(79)); 
  9075 0000182A B84F00                  		mov	ax,79
  9076 0000182D 50                      		push	ax
  9077 0000182E FF76FC                  		push	word [row]
  9078 00001831 FF76F4                  		push	word [col]
  9079 00001834 FF76FC                  		push	word [row]
  9080 00001837 E85CFC                  		call	clear_screen ; clear_screen_down
  9081                                  		;add	sp,8
  9082 0000183A E988FE                  		jmp	sc_break
  9083                                  ;case_0:	
  9084                                  ;;case '\0': 
  9085                                  ;	;/* Message string error - string ended in the middle of control string*/
  9086                                  ;		mov	byte [insert],'7'
  9087                                  ;		jmp	display_18
  9088                                  display_35:
  9089                                  		; /* Get the pointer past the '>' */
  9090                                  		;s++;
  9091 0000183D FF4604                  		inc	word [_s_]
  9092                                  		;break;
  9093                                  		;jmp	display_3
  9094 00001840 E926FE                  		jmp	display_2 ; 19/11/2018
  9095                                  		;END /* control characters */
  9096                                  display_36:	
  9097                                  		;/* Check for row,col */
  9098                                  ;case '':
  9099                                  		;s++;
  9100 00001843 FF4604                  		inc	word [_s_]
  9101                                  
  9102                                  		;/* determine the row to put the message on */
  9103                                  
  9104                                  		;if ( !isdigit(*s) )
  9105 00001846 8B5E04                  		mov	bx,[_s_]
  9106 00001849 268A07                  		mov	al,[es:bx]
  9107                                  		;cbw
  9108 0000184C 89C3                    		mov	bx,ax
  9109 0000184E F687[0A9F]04            		test	byte [isdigit+bx],4
  9110 00001853 741D                    		jz	short display_37
  9111                                  		
  9112                                  		;row = row+((unsigned)(((*s++ - '0')*10)));
  9113                                  		;mov	bx,[_s_]
  9114 00001855 FF4604                  		inc	word [_s_]
  9115                                  		;mov	al,10
  9116                                  		;imul	byte [es:bx]
  9117 00001858 2C30                    		sub	al,'0' ; 19/11/2018
  9118 0000185A B30A                    		mov	bl,10
  9119 0000185C F6E3                    		mul	bl 
  9120                                  		;sub	ax,480 ; 1E0h (10*ASC('0'))
  9121 0000185E 0146FC                  		add	[row],ax
  9122                                  		
  9123                                  		;if ( !isdigit(*s) )
  9124 00001861 8B5E04                  		mov	bx,[_s_]
  9125 00001864 268A07                  		mov	al,[es:bx] ; **
  9126                                  		;cbw	
  9127 00001867 30E4                    		xor	ah,ah ; 19/11/2018
  9128 00001869 89C3                    		mov	bx,ax
  9129 0000186B F687[0A9F]04            		test	byte [isdigit+bx],4
  9130 00001870 7507                    		jnz	short display_38
  9131                                  display_37:
  9132                                  		;/* Message string error */
  9133 00001872 C606[F4CC]32            		mov	byte [insert],'2'
  9134 00001877 EB33                    		jmp	short display_40
  9135                                  display_38:
  9136                                  		;row = row+((unsigned)(*s++ - '0'));
  9137                                  		;mov	bx,[_s_] ; **
  9138 00001879 FF4604                  		inc	word [_s_]
  9139                                  		;mov	al,[es:bx] ; **
  9140                                  		;;cbw
  9141                                  		;;sub	ax,'0'
  9142 0000187C 2C30                    		sub	al,'0'
  9143                                  		;xor	ah,ah
  9144 0000187E 0146FC                  		add	[row],ax
  9145                                  		
  9146                                  		;/* determine the col to put the message on */
  9147                                  
  9148                                  		;if ( !isdigit(*s) )
  9149 00001881 8B5E04                  		mov	bx,[_s_]
  9150 00001884 268A07                  		mov	al,[es:bx] ; **
  9151                                  		;cbw
  9152 00001887 89C3                    		mov	bx,ax
  9153 00001889 F687[0A9F]04            		test	byte [isdigit+bx],4
  9154 0000188E 7417                    		jz	short display_39
  9155                                  
  9156                                  		;col = ((uns/igned)(*s++ - '0'));
  9157                                  		;mov	bx,[_s_] ; **
  9158 00001890 FF4604                  		inc	word [_s_]
  9159                                  		;mov	al,[es:bx]
  9160                                  		;;cbw
  9161                                  		;;sub	ax,'0'
  9162 00001893 2C30                    		sub	al,'0' ; **
  9163                                  		;xor	ah,ah
  9164 00001895 8946F4                  		mov	[col],ax
  9165                                  		
  9166                                  		;if ( !isdigit(*s) )
  9167 00001898 8B5E04                  		mov	bx,[_s_]
  9168 0000189B 268A07                  		mov	al,[es:bx]
  9169                                  		;cbw
  9170 0000189E 89C3                    		mov	bx,ax ; *
  9171 000018A0 F687[0A9F]04            		test	byte [isdigit+bx],4
  9172 000018A5 7510                    		jnz	short display_41
  9173                                  display_39:	
  9174                                  		;/* Message string error */
  9175 000018A7 C606[F4CC]33            		mov	byte [insert],'3'
  9176                                  display_40:
  9177                                  		;push	word [debug_msg_seg]
  9178 000018AC 1E                      		push	ds ; 17/11/2018
  9179 000018AD FF36[CE9E]              		push	word [debug_msg_off]
  9180 000018B1 E870FD                  		call	display
  9181                                  		;pop	bx ; 19/11/2018 ; (!*!*)
  9182                                  		;pop	bx
  9183                                  		;jmp	display_3
  9184 000018B4 E9B2FD                  		jmp	display_2 ; 19/11/2018
  9185                                  display_41:
  9186                                  		;col = ((unsigned)((col* 10) + (*s++ - '0')));
  9187                                  		;mov	ax,10
  9188                                  		;mul	word [col]
  9189                                  		; 19/11/2018
  9190 000018B7 B00A                    		mov	al,10
  9191 000018B9 F666F4                  		mul	byte [col]
  9192                                  		;mov	bx,[_s_]
  9193 000018BC FF4604                  		inc	word [_s_]
  9194                                  		;mov	cx,ax ; 19/11/2018
  9195                                  		;mov	al,[es:bx]
  9196                                  		;;cbw
  9197                                  		;;add	cx,ax
  9198                                  		;;sub	cx,'0'
  9199                                  		;sub	al,'0'
  9200                                  		;xor	ah,ah
  9201                                  		;add	cx,ax
  9202                                  		; 19/11/2018
  9203 000018BF 80EB30                  		sub	bl,'0' ; *
  9204                                  		;add	cx,bx ; *
  9205                                  		;mov	[col],cx
  9206 000018C2 01D8                    		add	ax,bx ; *
  9207 000018C4 8946F4                  		mov	[col],ax
  9208                                  
  9209                                  		;if (*s++ != c('')) 
  9210 000018C7 8B5E04                  		mov	bx,[_s_]
  9211 000018CA FF4604                  		inc	word [_s_]
  9212 000018CD 26803F06                		cmp	byte [es:bx],6
  9213 000018D1 7503                    		jne	short display_42
  9214                                  		;jmp	display_3
  9215 000018D3 E993FD                  		jmp	display_2 ; 19/11/2018
  9216                                  display_42:
  9217                                  		;/* Message string error */
  9218 000018D6 C606[F4CC]34            		mov	byte [insert],'4'
  9219 000018DB EBCF                    		jmp	short display_40
  9220                                  display_43:
  9221 000018DD 89EC                    		mov	sp,bp
  9222 000018DF 5D                      		pop	bp
  9223                                  		;retn
  9224 000018E0 C20400                  		retn	4 ; 19/11/2018 (!*!*)
  9225                                  
  9226                                  ; video.asm (MSDOS 6.0, 1991)
  9227                                  ; ----------------------------------------------------------------------------
  9228                                  ; 17/11/2018 - Modified for NASM syntax & FDISK subroutines (by Erdogan Tan)
  9229                                  
  9230                                  ; doscall.h (FDISK, MSDOS 6.0, 1991)
  9231                                  
  9232                                  ;/***	VioWrtCharStrAtt - Write Character String With Attribute
  9233                                  ; *
  9234                                  ; *	Write a character string with repeated attribute to the display
  9235                                  ; */
  9236                                  
  9237                                  ;extern unsigned far pascal VIOWRTCHARSTRATT (
  9238                                  ;	char far *,			/* String to be written */
  9239                                  ;	unsigned,			/* Length of string */
  9240                                  ;	unsigned,			/* Starting position for output (row) */
  9241                                  ;	unsigned,			/* Starting position for output (col) */
  9242                                  ;	char far *,			/* Attribute to be replicated */
  9243                                  ;	unsigned );			/* Vio Handle */
  9244                                  
  9245                                  ; ============================================================================
  9246                                  ; Write string (with specified attribute) at specified cursor position
  9247                                  ; ============================================================================
  9248                                  ; Disassembled from (PCDOS 7.0) FDISK.COM (Segment 3, Offset 00C3h)
  9249                                  ; Modified for NASM syntax & FDISK (v2) subroutines (by Erdogan Tan)
  9250                                  ; 17/11/2018
  9251                                  
  9252                                  VIOWRTCHARSTRATT:  ; near procedure  (it was FAR proc in original FDISK.COM)	
  9253                                  
  9254                                  	;%define _hnd-	bp+4  ; word   ; Vio Handle (!is not used!)
  9255                                  	 	
  9256                                  	%define _atr_	bp+4  ; bp+6  ; dword  ; Attribute ptr
  9257                                  	%define _col_	bp+8  ; bp+10 ; word   ; Column 
  9258                                  	%define _row_	bp+10 ; bp+12 ; word   ; Row	
  9259                                  	%define	_cnt_	bp+12 ; bp+14 ; word   ; Count
  9260                                  	%define _str_	bp+14 ; bp+16 ; dword  ; String ptr
  9261                                  
  9262 000018E3 55                      		push	bp
  9263 000018E4 89E5                    		mov	bp,sp
  9264                                  
  9265 000018E6 53                      		push	bx
  9266 000018E7 51                      		push	cx
  9267 000018E8 52                      		push	dx
  9268 000018E9 56                      		push	si
  9269 000018EA 57                      		push	di
  9270 000018EB 1E                      		push	ds
  9271                                  		;push	es
  9272                                  		;push	ss
  9273                                  		;push	bp
  9274                                  
  9275 000018EC 28FF                    		sub	bh,bh		; Video page 0
  9276                                  		;sub	ax,ax
  9277                                  		;mov	dx,[_col_]	; Put screen column in DL
  9278 000018EE 8A5608                  		mov	dl,[_col_]
  9279                                  
  9280 000018F1 80FA50                  		cmp	dl,80		; Column limit check
  9281                                  		;jg	short viowchratt_2
  9282 000018F4 7342                    		jnb	short viowchratt_2 ; 10/12/2018
  9283                                  		;mov	ax,[_row_]
  9284                                  		;cmp	al,25		; Row limit check
  9285 000018F6 8A760A                  		mov	dh,[_row_]
  9286 000018F9 80FE19                  		cmp	dh,25
  9287                                  		;jg	short viowchratt_2
  9288 000018FC 733A                    		jnb	short viowchratt_2 ; 10/12/2018
  9289                                  		
  9290                                  		; Set cursor to Row,Col
  9291                                  		;mov	dh,al		; Put screen row in DH
  9292 000018FE B402                    		mov	ah,2		; BIOS set cursor function
  9293                                  		
  9294                                  		;push	bx
  9295                                  		;push	cx
  9296                                  		;push	dx
  9297                                  		;push	si
  9298                                  		;push	di
  9299                                  		;push	ds
  9300                                  		;push	es
  9301                                  		;push	ss
  9302                                  		;push	bp
  9303                                  				; - VIDEO - SET	CURSOR POSITION
  9304 00001900 CD10                    		int	10h	; DH,DL	= row, column (0,0 = upper left)
  9305                                  				; BH = page number
  9306                                  		;pop	bp
  9307                                  		;pop	ss
  9308                                  		;pop	es
  9309                                  		;pop	ds
  9310                                  		;pop	di
  9311                                  		;pop	si
  9312                                  		;pop	dx
  9313                                  		;pop	cx
  9314                                  		;pop	bx
  9315                                  
  9316 00001902 C57604                  		lds	si,[_atr_]
  9317 00001905 8A1C                    		mov	bl,[si] 	; Attribute or color of character
  9318 00001907 C5760E                  		lds	si,[_str_]
  9319 0000190A 8B7E0C                  		mov	di,[_cnt_] 	; String length (count of string characters)
  9320                                  viowchratt_0:
  9321                                  		;mov	al,[si] 	; ASCII code of character to be written
  9322 0000190D AC                      		lodsb	; 17/11/2017
  9323                                  
  9324 0000190E B409                    		mov	ah,9 		; Function: Write character or attribute 
  9325                                  					;           at current cursor position
  9326 00001910 B90100                  		mov	cx,1		; Number of repetitions
  9327                                  		
  9328                                  		;push	bx
  9329                                  		;push	cx
  9330                                  		;push	dx
  9331                                  		;push	si
  9332                                  		;push	di
  9333                                  		;push	ds
  9334                                  		;push	es
  9335                                  		;push	ss
  9336                                  		;push	bp
  9337                                  				; - VIDEO - WRITE ATTRIBUTES/CHARACTERS	AT CURSOR POSITION
  9338 00001913 CD10                    		int	10h	; AL = character, BH = display page
  9339                                  				; BL = attributes of character (alpha modes) or	color (graphics	modes)
  9340                                  				; CX = number of times to write	character
  9341                                  		;pop	bp
  9342                                  		;pop	ss
  9343                                  		;pop	es
  9344                                  		;pop	ds
  9345                                  		;pop	di
  9346                                  		;pop	si
  9347                                  		;pop	dx
  9348                                  		;pop	cx
  9349                                  		;pop	bx
  9350                                  		
  9351                                  		;inc	si		; next char (ptr) ; 17/11/2017
  9352 00001915 4F                      		dec	di		; decrease count
  9353 00001916 FEC2                    		inc	dl		; next column
  9354 00001918 80FA50                  		cmp	dl,80		; column limit check
  9355 0000191B 750E                    		jne	short viowchratt_1 ; ok
  9356 0000191D FEC6                    		inc	dh		; next row (and)
  9357 0000191F B200                    		mov	dl,0		; column 0
  9358 00001921 80FE19                  		cmp	dh,25		; Check row limit
  9359 00001924 7505                    		jne	short viowchratt_1 ; ok
  9360 00001926 B80100                  		mov	ax,1		; Error 1 (string could not be written completely)
  9361 00001929 EB10                    		jmp	short viowchratt_3
  9362                                  		;nop
  9363                                  viowchratt_1:
  9364 0000192B B402                    		mov	ah,2		; BIOS set cursor function
  9365                                  
  9366                                  		;push	bx
  9367                                  		;push	cx
  9368                                  		;push	dx
  9369                                  		;push	si
  9370                                  		;push	di
  9371                                  		;push	ds
  9372                                  		;push	es
  9373                                  		;push	ss
  9374                                  		;push	bp
  9375                                  		
  9376 0000192D CD10                    		int	10h	; - VIDEO - SET	CURSOR POSITION
  9377                                  				; DH,DL	= row, column (0,0 = upper left)
  9378                                  				; BH = page number
  9379                                  		;pop	bp
  9380                                  		;pop	ss
  9381                                  		;pop	es
  9382                                  		;pop	ds
  9383                                  		;pop	di
  9384                                  		;pop	si
  9385                                  		;pop	dx
  9386                                  		;pop	cx
  9387                                  		;pop	bx
  9388                                  		
  9389 0000192F 83FF00                  		cmp	di,0	; is countdown completed?
  9390 00001932 75D9                    		jne	short viowchratt_0 ; No
  9391                                  				; Yes	
  9392 00001934 29C0                    		sub	ax,ax	; OK (successful, string written completely)
  9393                                  
  9394 00001936 EB03                    		jmp	short viowchratt_3 ; 17/11/2018 
  9395                                  viowchratt_2:
  9396 00001938 B80200                  		mov	ax,2	; Error 2 (invalid column or row value)
  9397                                  viowchratt_3:
  9398                                  		;pop	bp
  9399                                  		;pop	ss
  9400                                  		;pop	es
  9401 0000193B 1F                      		pop	ds
  9402 0000193C 5F                      		pop	di
  9403 0000193D 5E                      		pop	si
  9404 0000193E 5A                      		pop	dx
  9405 0000193F 59                      		pop	cx
  9406 00001940 5B                      		pop	bx
  9407 00001941 89EC                    		mov	sp,bp
  9408 00001943 5D                      		pop	bp
  9409                                  		;retn	16	; ? (with video handle) ?
  9410 00001944 C20E00                  		retn	14	; (without video handle)
  9411                                  
  9412                                  ; DOSBEEP (IBM PC-DOS 7.0 FDISK.COM)
  9413                                  ; ----------------------------------------------------------------------------
  9414                                  ; 17/11/2018 - Modified for NASM syntax & FDISK subroutines (by Erdogan Tan)
  9415                                  
  9416                                  ; ============================================================================
  9417                                  ; DOSBEEP
  9418                                  ; ============================================================================
  9419                                  ; Disassembled from (PCDOS 7.0) FDISK.COM (Segment 2, Offset 0000h)
  9420                                  ; Modified for NASM syntax & FDISK (v2) subroutines (by Erdogan Tan)
  9421                                  ; 17/11/2018 
  9422                                  
  9423                                  ; doscall.h (FDISK, MSDOS 6.0, 1991)
  9424                                  
  9425                                  ;/***	DosBeep - Generate Sound From Speaker */
  9426                                  ;
  9427                                  ;extern unsigned far pascal DOSBEEP (
  9428                                  ;	unsigned,			/* Hertz (25H-7FFFH) */
  9429                                  ;	unsigned );			/* Length of sound  in ms */
  9430                                  
  9431                                  DOSBEEP:	; near procedure (it was FAR proc in original FDISK.COM)	
  9432                                  
  9433                                  	%define	duration  bp+4 ; bp+6 (far return) ; word
  9434                                  	%define frequency bp+6 ; bp+8 (far return) ; word
  9435                                  
  9436                                  		;push	bp
  9437                                  		;mov	bp,sp
  9438                                  		
  9439 00001947 53                      		push	bx
  9440 00001948 51                      		push	cx
  9441 00001949 52                      		push	dx
  9442                                  		
  9443                                  		;push	si
  9444                                  		;push	di
  9445                                  		;push	ds
  9446                                  		;push	es
  9447                                  		;push	ss
  9448                                  		;push	bp
  9449                                  
  9450                                  		; 01/01/2019 (same frequency and duration for all DOSBEEPs)
  9451 0000194A BB8403                  		mov	bx,900 ; frequency
  9452 0000194D B99001                  		mov	cx,400 ; duration	
  9453                                  
  9454                                  		; set mode control register
  9455                                  
  9456 00001950 B0B6                    		mov	al,0B6h ; 10-11-011-0b
  9457                                  				;  10b - timer counter 2
  9458                                  				;  11b - write LSB then MSB
  9459                                  				; 011b - mode 3 - generate square wave
  9460                                  				;   0b - binary counter
  9461                                  
  9462 00001952 E643                    		out	43h,al	; Timer	8253-5 (AT: 8254.2).
  9463                                  
  9464 00001954 BA1200                  		mov	dx,12h 	 ; 18
  9465 00001957 B87029                  		mov	ax,2970h ; 10608
  9466                                  			; DX:AX = 122970h ; 1190256 (!?)
  9467                                  				; Note: This dividend value was/is 1193180 commonly
  9468                                  
  9469                                  		; 01/01/2019 (900 Hertz and 400 milliseconds for all DOSBEEPs)
  9470                                  
  9471                                  		;mov	cx,[frequency]	; value of frequency into CX
  9472                                  		;mov	bx,37	; Minimum 37 Hz
  9473                                  		;cmp	cx,bx
  9474                                  		;jl	short dosbeep_3 ; not a proper value (very low)
  9475                                  		;mov	bx,32767 ; Maximum 32767 Hz
  9476                                  		;cmp	cx,bx
  9477                                  		;jg	short dosbeep_3 ; not a proper value (very high)
  9478                                  
  9479                                  		;div	cx
  9480 0000195A F7F3                    		div	bx	; 01/01/2019
  9481 0000195C E642                    		out	42h,al	; counter 2 divisor, LSB
  9482 0000195E 88E0                    		mov	al,ah
  9483 00001960 E642                    		out	42h,al	; counter 2 divisor, MSB
  9484                                  
  9485                                  		; turn the sound on
  9486                                  
  9487 00001962 E461                    		in	al,61h  ; read PPI port
  9488                                  				
  9489                                  				; PC/XT	PPI port B bits:
  9490                                  				; 0: Tmr 2 gate	--> OR	03H=spkr ON
  9491                                  				; 1: Tmr 2 data	-|  AND	0FCh=spkr OFF
  9492                                  				; 3: 1=read high switches
  9493                                  				; 4: 0=enable RAM parity checking
  9494                                  				; 5: 0=enable I/O channel check
  9495                                  				; 6: 0=hold keyboard clock low
  9496                                  				; 7: 0=enable kbrd
  9497                                  
  9498 00001964 88C4                    		mov	ah,al	; save PPI port bits/status
  9499                                  
  9500 00001966 0C03                    		or	al,3	; set bits 0 and 1 of port 61h to 1
  9501 00001968 E661                    		out	61h,al	; turn speaker and timer 2 clock on
  9502                                  
  9503                                  		;mov	cx,[duration] ; value of the duration into CX
  9504                                  dosbeep_1:
  9505 0000196A BBC400                  		mov	bx,196  ; factor to convert milliseconds to loop count
  9506                                  				; (196 may be experimental, depending on CPU speed)
  9507                                  dosbeep_2:
  9508 0000196D 4B                      		dec	bx
  9509 0000196E 75FD                    		jnz	short dosbeep_2  
  9510                                  				; delay depends on countdown start value and CPU speed 
  9511 00001970 E2F8                    		loop	dosbeep_1
  9512                                  
  9513 00001972 88E0                    		mov	al,ah	; restore port 61h bits/status
  9514 00001974 E661                    		out	61h,al	; (turn off speaker, restore frq)
  9515                                  
  9516 00001976 29C0                    		sub	ax,ax ; 0
  9517                                  ;		jmp	short dosbeep_4  ; OK
  9518                                  ;		;nop
  9519                                  ;dosbeep_3:
  9520                                  ;		mov	ax,2	; Error (invalid freq values)
  9521                                  dosbeep_4:
  9522                                  		;pop	bp
  9523                                  		;pop	ss
  9524                                  		;pop	es
  9525                                  		;pop	ds
  9526                                  		;pop	di
  9527                                  		;pop	si
  9528                                  		
  9529 00001978 5A                      		pop	dx
  9530 00001979 59                      		pop	cx
  9531 0000197A 5B                      		pop	bx
  9532                                  
  9533                                  		;mov	sp,bp
  9534                                  		;pop	bp
  9535                                  		;retf	4
  9536                                  		;retn	4	; return and clean stack
  9537                                  
  9538 0000197B C3                      		retn	; 01/01/2019
  9539                                  
  9540                                  ; ----------------------------------------------------------------------------
  9541                                  ; fdisk.c (FDISK, MSDOS 6.0, 1991)	
  9542                                  ; ----------------------------------------------------------------------------
  9543                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 20/11/2018)
  9544                                  
  9545                                  ; 26/11/2018
  9546                                  ; hdisk.h ; MSDOS 6.0, 1991
  9547                                  ;/***************************************************************************/
  9548                                  ;/* Hard disk partition record																*/
  9549                                  ;/***************************************************************************/
  9550                                  ;
  9551                                  ;struct	Part
  9552                                  ;{
  9553                                  ;   unsigned char  BootIndicator;   /* If 80h means this is boot partition */
  9554                                  ;   unsigned char  StartHead;	    /* Partition starting head based 0     */
  9555                                  ;   unsigned char  StartSector;	    /* Partition starting sector based 1   */
  9556                                  ;   unsigned char  StartCylinder;   /* Partion starting track based 0      */
  9557                                  ;   	
  9558                                  ;   unsigned char  SystemIndicator; /* Partition type signature field      */
  9559                                  ;   unsigned char  EndHead; 	    /* Partition ending head based 0       */
  9560                                  ;   unsigned char  EndSector;	    /* Partition ending sector based 1     */
  9561                                  ;   unsigned char  EndCylinder;	    /* Partition ending track based 0      */
  9562                                  ;   
  9563                                  ;   unsigned long  RelativeSector;  /* Physcial starting sector based 0    */
  9564                                  ;   unsigned long  TotalSectors;    /* Total physical sectors in partition */
  9565                                  ;};
  9566                                  
  9567                                  
  9568                                  ; 23/11/2018
  9569                                  
  9570                                  ; Partition Table Entry Structure (at offset 1BEh in MasterBoot sector)
  9571                                  
  9572                                  struc pt_entry	; partition
  9573 00000000 ??                      .boot_ind: 	resb 1	; Active (bootable, 80h) or not (0)
  9574 00000001 ??                      .start_head:	resb 1	; Beginning head
  9575 00000002 ??                      .start_sector:	resb 1	; Beginning sector (6 bits, bits 0 to 5)
  9576                                  			; and high 2 bits of beginning cylinder
  9577 00000003 ??                      .start_cyl:	resb 1  ; Low 8 bits of beginning cylinder (total 10 bits)
  9578 00000004 ??                      .sys_id:	resb 1	; Partition (File System) ID (Type)
  9579 00000005 ??                      .end_head:	resb 1	; Ending head
  9580 00000006 ??                      .end_sector:	resb 1	; Ending sector (6 bits, bits 0 to 5)
  9581                                  			; and high 2 bits of ending cylinder
  9582 00000007 ??                      .end_cyl:	resb 1  ; Low 8 bits of ending cylinder (total 10 bits)
  9583 00000008 ????????                .rel_sec:	resd 1	; First sector relative to start of disk
  9584 0000000C ????????                .num_sec:	resd 1	; Number of sectors in partition
  9585                                  .entry_size:
  9586                                  endstruc
  9587                                  
  9588                                  	; FDISK Partition Data (46 bytes)
  9589                                  
  9590                                  struc pt_data	; partition_data
  9591 00000000 ??                      .boot_ind:	resb 1	; Active (Bootable) partition indicator
  9592 00000001 ??                      .start_head:	resb 1	; Start head (0 to 255)
  9593 00000002 ??                      .start_sector:	resb 1	; Start sector (1 to 63)
  9594 00000003 ????                    .start_cyl:	resw 1	; Start cylinder (0 to 1023)
  9595 00000005 ??                      .sys_id:	resb 1	; System (Partition, File System) ID
  9596 00000006 ??                      .end_head:	resb 1	; End head (0 to 255)
  9597 00000007 ??                      .end_sector:	resb 1	; End sector (1 to 63)	
  9598 00000008 ????                    .end_cyl:	resw 1	; End cylinder (0 to 1023)
  9599 0000000A ????                    .rec_sec_lw:	resw 1	; Beginning sector (LBA) of partition (low 16 bits)
  9600 0000000C ????                    .rel_sec_hw:	resw 1	; High 16 bits of beginning sector address	
  9601 0000000E ????                    .num_sec_lw:	resw 1	; Partition size in sectors (low 16 bits)
  9602 00000010 ????                    .num_sec_hw:	resw 1	; High 16 bits of sector count
  9603 00000012 ??                      .not_used:	resb 1	; (This struc byte is) not used in current FDISK
  9604 00000013 ??                      .changed:	resb 1	; Partition data changed flag
  9605 00000014 ????                    .mbytes_used:	resw 1	; Partition size in megabytes
  9606 00000016 ????                    .percent_used:	resw 1	; Percentage of total disk capacity (for partition)
  9607 00000018 <res Ch>                .vol_label:	resb 12 ; Volume label
  9608 00000024 <res 9h>                .system:	resb 9	; Partition (File System) name for partition ID 
  9609 0000002D ??                      .drive_letter:	resb 1	; Logical DOS drive letter (C,D,...)
  9610                                  .size:	; = 46 bytes
  9611                                  endstruc
  9612                                  
  9613                                  ;/*  */
  9614                                  ;void init_partition_tables()
  9615                                  ;BEGIN
  9616                                  ;
  9617                                  ;unsigned i;
  9618                                  ;unsigned char j;
  9619                                  ;/*C00 unsigned k;       */
  9620                                  ;/*C00 unsigned l;       */
  9621                                  ;unsigned partition_location;
  9622                                  ;char temp;
  9623                                  ;char more_drives_exist;
  9624                                  ;char num_logical_drives;
  9625                                  ;/*C00 unsigned insert;  */
  9626                                  ;unsigned index;
  9627                                  ;unsigned char active_primary_count;                                     /*C32*/
  9628                                  ;unsigned char pri_part;                                                 /*C32*/
  9629                                  ;
  9630                                  ;	/* initialize first drive found to "C" */
  9631                                  ;	next_letter = c(SEA);						/* AC000 */
  9632                                  ;
  9633                                  ;	/* initialize primary partition count */
  9634                                  ;/*C32   primary_partition_count = 0; */
  9635                                  ;
  9636                                  ;	/* Look at both disks */
  9637                                  ;	for (j = uc(0); j < number_of_drives; j++)                      /* AC000 */
  9638                                  ;	   BEGIN
  9639                                  ;
  9640                                  ;	    /* initialize variables */                                  /*C32*/
  9641                                  ;	    primary_partition_count = 0;                                /*C32*/
  9642                                  ;	    active_primary_count = 0;                                   /*C32*/
  9643                                  ;	    pri_part = 0xFF;                                            /*C32*/
  9644                                  ;
  9645                                  ;	    /* Initialize the cur_disk field to the drive in question so */
  9646                                  ;	    /* that the calls to the partition information routines will work */
  9647                                  ;	    cur_disk = ((char)(j));
  9648                                  ;
  9649                                  ;	    /* Read in the master boot record and see if it was okay */
  9650                                  ;	    if (read_boot_record(u(0),j,uc(0),uc(1)))                  /* AC000 */
  9651                                  ;	       BEGIN
  9652                                  ;
  9653                                  ;		/* See if there was a valid boot record there */
  9654                                  ;		if ((boot_record[510] == uc(0x55)) && (boot_record[511] == uc(0xAA))) /* AC000 */
  9655                                  ;		   BEGIN
  9656                                  ;
  9657                                  ;		    /* What was on the disk is a valid boot record, so save it */
  9658                                  ;		    for (i=u(0);i < u(BYTES_PER_SECTOR); i++)           /* AC000 */
  9659                                  ;		       BEGIN
  9660                                  ;			master_boot_record[j][i] = boot_record[i];
  9661                                  ;		       END
  9662                                  ;		   END
  9663                                  ;		/* We've now got a copy of the master boot record saved. Now we need */
  9664                                  ;		/* to translate what in the boot record to the area that it's going  */
  9665                                  ;		/* to be worked on (part_table) */
  9666                                  ;
  9667                                  ;		/* Read in the data from the master boot record partition entries*/
  9668                                  ;		for (i=u(0); i < u(4); i++)                             /* AC000 */
  9669                                  ;		   BEGIN
  9670                                  ;		    index = i*16;
  9671                                  ;
  9672                                  ;		    /* Get boot ind */
  9673                                  ;		    part_table[j][i].boot_ind = master_boot_record[j][0x1BE+index];
  9674                                  ;
  9675                                  ;		    /* Start head */
  9676                                  ;		    part_table[j][i].start_head = master_boot_record[j][0x1BF+index];
  9677                                  ;
  9678                                  ;		    /* Start sector - unscramble it from INT 13 format*/
  9679                                  ;		    part_table[j][i].start_sector= (master_boot_record[j][0x1C0+index] & 0x3F);
  9680                                  ;
  9681                                  ;		    /* Start cyl - unscramble it from INT 13 format*/
  9682                                  ;		    part_table[j][i].start_cyl= ((((unsigned)master_boot_record[j][0x1C0+index]) & 0x00C0) << 2)
  9683                                  ;						+ ((unsigned)master_boot_record[j][0x1C1+index]);
  9684                                  ;
  9685                                  ;		    /* System id */
  9686                                  ;		    part_table[j][i].sys_id = master_boot_record[j][0x1C2+index];
  9687                                  ;
  9688                                  ;		    /* End head */
  9689                                  ;		    part_table[j][i].end_head = master_boot_record[j][0x1C3+index];
  9690                                  ;
  9691                                  ;		    /* End sector - unscramble it from INT 13 format*/
  9692                                  ;		    part_table[j][i].end_sector= (master_boot_record[j][0x1C4+index] & 0x3F);
  9693                                  ;
  9694                                  ;		    /* End cyl - unscramble it from INT 13 format*/
  9695                                  ;		    part_table[j][i].end_cyl= ((((unsigned)master_boot_record[j][0x1C4+index]) & 0x00C0) << 2)
  9696                                  ;						+ ((unsigned)master_boot_record[j][0x1C5+index]);
  9697                                  ;
  9698                                  ;		    /* Relative sectors */
  9699                                  ;
  9700                                  ;		    part_table[j][i].rel_sec =
  9701                                  ;		       ((unsigned long)master_boot_record[j][0x1C9+index]) << 24;
  9702                                  ;
  9703                                  ;		    part_table[j][i].rel_sec = part_table[j][i].rel_sec +
  9704                                  ;		       (((unsigned long)master_boot_record[j][0x1C8+index]) << 16);
  9705                                  ;
  9706                                  ;		    part_table[j][i].rel_sec = part_table[j][i].rel_sec +
  9707                                  ;		       (((unsigned long)master_boot_record[j][0x1C7+index]) << 8);
  9708                                  ;
  9709                                  ;		    part_table[j][i].rel_sec = part_table[j][i].rel_sec +
  9710                                  ;		       ((unsigned long)master_boot_record[j][0x1C6+index]);
  9711                                  ;
  9712                                  ;		    /* Number of sectors */
  9713                                  ;		    part_table[j][i].num_sec =
  9714                                  ;		       ((unsigned long)master_boot_record[j][0x1CD+index]) << 24;
  9715                                  ;
  9716                                  ;		    part_table[j][i].num_sec = part_table[j][i].num_sec +
  9717                                  ;		       (((unsigned long)master_boot_record[j][0x1CC+index]) << 16);
  9718                                  ;
  9719                                  ;		    part_table[j][i].num_sec = part_table[j][i].num_sec +
  9720                                  ;		       (((unsigned long)master_boot_record[j][0x1CB+index]) << 8);
  9721                                  ;
  9722                                  ;		    part_table[j][i].num_sec = part_table[j][i].num_sec +
  9723                                  ;		       ((unsigned long)master_boot_record[j][0x1CA+index]);
  9724                                  ;
  9725                                  ;		    part_table[j][i].mbytes_used = (unsigned)
  9726                                  ;		       numsecs_to_mbytes(part_table[j][i].num_sec);
  9727                                  ;
  9728                                  ;		    part_table[j][i].percent_used =
  9729                                  ;		       mbytes_to_percent(part_table[j][i].mbytes_used,total_mbytes[cur_disk]);
  9730                                  ;
  9731                                  ;		    /* Set drive letter */
  9732                                  ;		    if ( (part_table[j][i].sys_id == DOS12) ||  /* AN000 */
  9733                                  ;			 (part_table[j][i].sys_id == DOS16) ||  /* AN000 */
  9734                                  ;			 (part_table[j][i].sys_id == DOSNEW)   ) /* AN000 */
  9735                                  ;		       {
  9736                                  ;/*C32                  part_table[j][i].drive_letter = next_letter++;*/  /* AN000 */
  9737                                  ;			part_table[j][i].drive_letter = c(' ');         /*C32*/ /* AN000 */
  9738                                  ;			if ((primary_partition_count == 0) ||           /*C32*/
  9739                                  ;			    ((part_table[j][i].boot_ind == 0x80) &&     /*C32*/
  9740                                  ;			     (active_primary_count == 0)))              /*C32*/
  9741                                  ;			    pri_part = c(i);                            /*C32*/
  9742                                  ;			if (part_table[j][i].boot_ind == 0x80)          /*C32*/
  9743                                  ;			    active_primary_count++;                     /*C32*/
  9744                                  ;			primary_partition_count++; /*Keep track of partition number */
  9745                                  ;		       }
  9746                                  ;
  9747                                  ;		    /* Set changed flag */
  9748                                  ;		    part_table[j][i].changed = FALSE;
  9749                                  ;		   END
  9750                                  ;		if (pri_part != 0xFF)                                   /*C32*/
  9751                                  ;		   {                                                    /*C32*/
  9752                                  ;		    part_table[j][pri_part].drive_letter = next_letter++; /*C32*/
  9753                                  ;		    get_volume(j,pri_part);                             
  9754                                  ;		   }                                                    /*C32*/
  9755                                  ;	       END
  9756                                  ;	    else
  9757                                  ;	       BEGIN
  9758                                  ;		return;
  9759                                  ;	       END
  9760                                  ;	   END
  9761                                  ;
  9762                                  ;	/* Look at both disks */
  9763                                  ;	for (j = uc(0); j < number_of_drives; j++)                     /* AC000 */
  9764                                  ;	   BEGIN
  9765                                  ;
  9766                                  ;	    /* Initialize the cur_disk field to the drive in question so */
  9767                                  ;	    /* that the calls to the partition information routines will work */
  9768                                  ;	    cur_disk = ((char)(j));
  9769                                  ;
  9770                                  ;	    /* Read in the master boot record and see if it was okay */
  9771                                  ;	    if (read_boot_record(u(0),j,uc(0),uc(1)))                  /* AC000 */
  9772                                  ;	       BEGIN
  9773                                  ;		/* Now, go read in extended partition info */
  9774                                  ;		if (find_partition_type(uc(EXTENDED)))                 /* AC000 */
  9775                                  ;		   BEGIN
  9776                                  ;		    /* Initialize the array to zero's - include one dummy entry */
  9777                                  ;		    for (i=u(0); i < u(24); i++)                       /* AC000 */
  9778                                  ;		       BEGIN
  9779                                  ;			ext_table[j][i].boot_ind = uc(0);              /* AC000 */
  9780                                  ;			ext_table[j][i].start_head = uc(0);            /* AC000 */
  9781                                  ;			ext_table[j][i].start_sector = uc(0);          /* AC000 */
  9782                                  ;			ext_table[j][i].start_cyl = u(0);              /* AC000 */
  9783                                  ;			ext_table[j][i].sys_id = uc(0);                /* AC000 */
  9784                                  ;			ext_table[j][i].end_head = uc(0);              /* AC000 */
  9785                                  ;			ext_table[j][i].end_sector = uc(0);            /* AC000 */
  9786                                  ;			ext_table[j][i].end_cyl = u(0);                /* AC000 */
  9787                                  ;			ext_table[j][i].rel_sec = ul(0);               /* AC000 */
  9788                                  ;			ext_table[j][i].num_sec = ul(0);               /* AC000 */
  9789                                  ;			ext_table[j][i].mbytes_used = f(0);            /* AN000 */
  9790                                  ;			ext_table[j][i].percent_used = u(0);           /* AN000 */
  9791                                  ;			ext_table[j][i].changed = FALSE;
  9792                                  ;			ext_table[j][i].drive_letter = NUL;            /* AN000 */
  9793                                  ;
  9794                                  ;			strcpy(ext_table[cur_disk][i].system,NUL);     /* AN000 */
  9795                                  ;			strcpy(ext_table[cur_disk][i].vol_label,NUL);  /* AN000 */
  9796                                  ;
  9797                                  ;		       END
  9798                                  ;
  9799                                  ;		    /* Find where the first extended boot record is */
  9800                                  ;		    temp = find_partition_location(uc(EXTENDED));      /* AC000 */
  9801                                  ;		    partition_location = part_table[j][temp].start_cyl;
  9802                                  ;
  9803                                  ;		    /* Go find extended boot records as long as there are more of them */
  9804                                  ;		    more_drives_exist = TRUE;
  9805                                  ;
  9806                                  ;		    /* Init the number of logical drives, for a array index */
  9807                                  ;		    num_logical_drives = c(0);                        /* AC000 */
  9808                                  ;
  9809                                  ;		    while (more_drives_exist)
  9810                                  ;		       BEGIN
  9811                                  ;		       /* Assume we won't find another logical drive */
  9812                                  ;		       more_drives_exist = FALSE;
  9813                                  ;
  9814                                  ;			 /*Read in the extended boot record */
  9815                                  ;			 if (read_boot_record(partition_location,
  9816                                  ;					      j,
  9817                                  ;					      uc(0),
  9818                                  ;					      uc(1)))   /* AC000 */
  9819                                  ;			    BEGIN
  9820                                  ;			     load_logical_drive(num_logical_drives,j);
  9821                                  ;
  9822                                  ;
  9823                                  ;			     /* find the next logical drive */
  9824                                  ;			     for (i = u(0); i < u(4); i++)            /* AC000 */
  9825                                  ;				BEGIN
  9826                                  ;				 index = i*16;
  9827                                  ;				 /* See if a sys id byte of extended exists */
  9828                                  ;				 if (boot_record[0x1C2+index] == uc(EXTENDED))   /* AC000 */
  9829                                  ;				    BEGIN
  9830                                  ;				     /* Found another drive, now get its location */
  9831                                  ;				     partition_location= (((((unsigned)(boot_record[0x1C0 + index])) & 0x00C0) << 2));
  9832                                  ;				     partition_location = partition_location + ((unsigned)(boot_record[0x1C1+index]));
  9833                                  ;
  9834                                  ;				     /* Indicate we found another one */
  9835                                  ;				     more_drives_exist = TRUE;
  9836                                  ;
  9837                                  ;				     /* Up the count of found ones */
  9838                                  ;				     /* SR; 9/28/89; The count should be
  9839                                  ;					incremented only if there is a
  9840                                  ;					logical drive defined */
  9841                                  ;				     if (ext_table[j][num_logical_drives].sys_id != 0)
  9842                                  ;					 num_logical_drives++;
  9843                                  ;				     break;
  9844                                  ;				    END
  9845                                  ;				END
  9846                                  ;			    END
  9847                                  ;		       END
  9848                                  ;		   END
  9849                                  ;	       END
  9850                                  ;	   END
  9851                                  ;
  9852                                  ;	/* Look at all disks */                                         /*C32*/
  9853                                  ;	for (j = uc(0); j < number_of_drives; j++)                      /*C32*/
  9854                                  ;	   BEGIN                                                        /*C32*/
  9855                                  ;									/*C32*/
  9856                                  ;	    /* Look at all active primary partitions */                 /*C32*/
  9857                                  ;	    for (i=u(0); i < u(4); i++)                                 /*C32*/
  9858                                  ;	       BEGIN                                                    /*C32*/
  9859                                  ;		/* Set drive letter */                                  /*C32*/
  9860                                  ;		if (((part_table[j][i].sys_id == DOS12) ||              /*C32*/	/* AN000 */
  9861                                  ;		     (part_table[j][i].sys_id == DOS16) ||              /*C32*/	/* AN000 */
  9862                                  ;		     (part_table[j][i].sys_id == DOSNEW)) &&            /*C32*/	/* AN000 */
  9863                                  ;		    (part_table[j][i].boot_ind == 0x80))                /*C32*/	/* AN000 */
  9864                                  ;		   {                                                    /*C32*/
  9865                                  ;		    if (part_table[j][i].drive_letter == c(' '))        /*C32*/
  9866                                  ;		       {                                                /*C32*/
  9867                                  ;			part_table[j][i].drive_letter = next_letter++;  /*C32*/	/* AN000 */
  9868                                  ;			get_volume(j,i);                                /*C32*/
  9869                                  ;		       }                                                /*C32*/
  9870                                  ;		   }                                                    /*C32*/
  9871                                  ;	       END                                                      /*C32*/
  9872                                  ;									/*C32*/
  9873                                  ;	    /* Look at all non-active primary partitions */             /*C32*/
  9874                                  ;	    for (i=u(0); i < u(4); i++)                                 /*C32*/
  9875                                  ;	       BEGIN                                                    /*C32*/
  9876                                  ;		/* Set drive letter */                                  /*C32*/
  9877                                  ;		if (((part_table[j][i].sys_id == DOS12) ||              /*C32*/	/* AN000 */
  9878                                  ;		     (part_table[j][i].sys_id == DOS16) ||              /*C32*/	/* AN000 */
  9879                                  ;		     (part_table[j][i].sys_id == DOSNEW)) &&            /*C32*/	/* AN000 */
  9880                                  ;		    (part_table[j][i].boot_ind != 0x80))                /*C32*/	/* AN000 */
  9881                                  ;		   {                                                    /*C32*/
  9882                                  ;		    if (part_table[j][i].drive_letter == c(' '))        /*C32*/
  9883                                  ;		       {                                                /*C32*/
  9884                                  ;			part_table[j][i].drive_letter = next_letter++;  /*C32*/	/* AN000 */
  9885                                  ;			get_volume(j,i);                                /*C32*/
  9886                                  ;		       }                                                /*C32*/
  9887                                  ;		   }                                                    /*C32*/
  9888                                  ;	       END                                                      /*C32*/
  9889                                  ;	   END                                                          /*C32*/
  9890                                  ;
  9891                                  ;	return;
  9892                                  ;END
  9893                                  
  9894                                  init_partition_tables:
  9895                                  		; 23/11/2018
  9896                                  
  9897                                  	%define pt_num_sec_lw	     bp-22 ; word, unsigned int
  9898                                  	%define pt_num_sec_hw	     bp-20 ; word, unsigned int
  9899                                  	%define pt_rel_sec_temp_lw   bp-18 ; word, unsigned int
  9900                                  	%define pt_rel_sec_temp_hw   bp-16 ; word, unsigned int
  9901                                  	; 15/12/2018
  9902                                  	;%define more_drives_exist   bp-14 ; byte, unsigned int
  9903                                  	%define char_j		     bp-12 ; byte, char
  9904                                  	%define	unsigned_i	     bp-10 ; word, unsigned int
  9905                                  	%define active_primary_count bp-8  ; byte, unsigned char
  9906                                  	%define num_logical_drives   bp-6  ; byte, char	
  9907                                  	%define partition_location   bp-4  ; word, unsigned int	
  9908                                  	%define char_pri_part        bp-2  ; word, unsigned char
  9909                                  
  9910                                  		; 14/12/2018
  9911                                  	;%define ext_part_num	     bp-24 ; byte, char
  9912                                  		; 15/12/2018
  9913                                  	%define ext_part_num	     bp-14 ; byte, char
  9914                                  
  9915                                  		;push	bp
  9916 0000197C 89E5                    		mov	bp,sp
  9917                                  		;;;sub	sp,26
  9918                                  		;;sub	sp,22 ; 20/11/2018
  9919                                  		;sub	sp,24 ; 14/12/2018
  9920 0000197E 83EC16                  		sub	sp,22 ; 15/12/2018 
  9921                                  
  9922                                  		;push	di
  9923                                  		;push	si
  9924                                  
  9925                                  		;/* initialize first drive found to "C" */
  9926 00001981 C606[2DA1]43            		mov	byte [next_letter],'C'
  9927                                  ipt_for1_0:
  9928                                  		;/* Look at both disks */
  9929                                  		;for (j = uc(0); j < number_of_drives; j++)
  9930                                  		
  9931                                  		; 11/12/2018
  9932                                  		;mov	byte [char_j],0
  9933                                  		;jmp	ipt_for1_1
  9934 00001986 31C0                    		xor	ax,ax
  9935 00001988 8946F4                  		mov	[char_j],ax ; 0
  9936                                  ipt_for1_next:
  9937                                  		;/* initialize variables */ 
  9938 0000198B C606[DCC3]00            		mov	byte [primary_partition_count],0
  9939 00001990 C646FEFF                		mov	byte [char_pri_part],0FFh
  9940                                  	;/* Initialize the cur_disk field to the drive in question so */
  9941                                  	;/* that the calls to the partition information routines will work */
  9942 00001994 A2[E2CB]                		mov	[cur_disk],al
  9943                                  	;/* Read in the master boot record and see if it was okay */
  9944                                  	;if (read_boot_record(u(0),j,uc(0),uc(1)))
  9945                                  		;mov	cl,1
  9946 00001997 B90100                  		mov	cx,1 ; 11/12/2018
  9947 0000199A 51                      		push	cx ; uc(1)
  9948 0000199B 28C9                    		sub	cl,cl
  9949 0000199D 884EF8                  		mov	[active_primary_count],cl
  9950 000019A0 51                      		push	cx ; uc(0)
  9951 000019A1 50                      		push	ax ; j
  9952 000019A2 29C0                    		sub	ax,ax
  9953 000019A4 50                      		push	ax ; u(0)
  9954 000019A5 E85406                  		call	read_boot_record
  9955                                  		;add	sp,8	; 22/12/2018
  9956                                  		;or	al,al
  9957                                  		;jnz	short ipt_1
  9958 000019A8 7303                    		jnc	short ipt_1 ; 27/11/2018
  9959 000019AA E9BE02                  		jmp	ipt_26
  9960                                  ipt_1:
  9961                                  	;/* See if there was a valid boot record there */
  9962                                  	;if ((boot_record[510] == uc(0x55)) && (boot_record[511] == uc(0xAA)))
  9963                                  		;cmp	byte [boot_record+1FEh],55h
  9964                                  		;jne	short ipt_3
  9965                                  		;cmp	byte [boot_record+1FFh],0AAh
  9966                                  		;jne	short ipt_3
  9967                                  		;mov	word [unsigned_i],0
  9968                                  
  9969                                  		; 14/12/2018
  9970 000019AD 8B5EF4                  		mov	bx,[char_j]
  9971 000019B0 89DA                    		mov	dx,bx	; Disk/Drive number (0 to 7)
  9972 000019B2 C1E309                  		shl	bx,9	; * 512 ; FDISK MBR offset
  9973                                  
  9974                                  		; 23/11/2018
  9975 000019B5 813E[DECB]55AA          		cmp	word [boot_record+1FEh],0AA55h
  9976 000019BB 750C                    		jne	short ipt_3
  9977                                  ;ipt_2:
  9978                                  	;/* What was on the disk is a valid boot record, so save it */
  9979                                  	; for (i=u(0);i < u(BYTES_PER_SECTOR); i++)
  9980                                  	;     master_boot_record[j][i] = boot_record[i];
  9981                                  
  9982                                  		;mov	bx,[unsigned_i]
  9983                                  		;mov	al,[boot_record+bx]
  9984                                  		;mov	cl,9
  9985                                  		;mov	dl,[char_j]
  9986                                  		;sub	dh,dh
  9987                                  		;mov	si,dx
  9988                                  		;shl	si,cl
  9989                                  		;mov	[master_boot_record+bx+si],al
  9990                                  		;inc	word [unsigned_i]
  9991                                  		;cmp	word [unsigned_i],512
  9992                                  		;jb	short ipt_2
  9993                                  
  9994                                  		; 20/11/2018
  9995                                  		;mov	bl,[char_j] ; Drive number (0 to 7)
  9996                                  		;xor	bh,bh
  9997                                  		; 14/12/2018
  9998                                  		;mov	bx,[char_j] ; 11/12/2018
  9999                                  		;mov	dx,bx ; 21/11/2018	
 10000                                  		;shl	bx,9 ; * 512
 10001                                  		
 10002 000019BD 8DBF[925F]              		lea	di,[master_boot_record+bx] ; mbr 0 to mbr 7
 10003 000019C1 BE[E0C9]                		mov	si,boot_record
 10004 000019C4 B90001                  		mov	cx,256
 10005 000019C7 F3A5                    		rep	movsw
 10006                                  ipt_3:
 10007                                  	;/* We've now got a copy of the master boot record saved. Now we need */
 10008                                  	;/* to translate what in the boot record to the area that it's going  */
 10009                                  	;/* to be worked on (part_table) */
 10010                                  
 10011 000019C9 C746F60000              		mov	word [unsigned_i],0
 10012                                  ipt_4:
 10013                                     		; index = i*16;
 10014                                  		;
 10015                                  		; /* Get boot ind */
 10016                                  		; part_table[j][i].boot_ind = master_boot_record[j][0x1BE+index];
 10017                                  
 10018                                  		;mov	al,[char_j] ; drive number 
 10019                                  		;sub	ah,ah
 10020                                  		;mov	cl,9
 10021                                  		;mov	dx,ax
 10022                                  		;shl	ax,cl
 10023                                  
 10024                                  		; 21/11/2018	
 10025                                  		; bx = drive number * 512
 10026 000019CE B104                    		mov	cl,4
 10027                                  		;mov	bx,[unsigned_i]
 10028                                  		;shl	bx,cl
 10029                                  		;add	bx,ax
 10030                                  		; 14/12/2018
 10031 000019D0 8B46F6                  		mov	ax,[unsigned_i] ; partition (partition table entry) number
 10032                                  		;shl	ax,cl
 10033 000019D3 D2E0                    		shl	al,cl ; 16*PartitionTableEntryNum	
 10034 000019D5 01C3                    		add	bx,ax ; MasterBoot Offset (for drive) + PT Entry offset
 10035                                  		;mov	al,[master_boot_record+1BEh+bx] ; Partition Table Entry address
 10036 000019D7 8DB7[5061]              		lea	si,[master_boot_record+1BEh+bx] ; 1BEh = Partition Table offset 
 10037 000019DB AC                      		lodsb 
 10038                                  		;xor	ah,ah
 10039 000019DC 89C1                    		mov	cx,ax
 10040                                  		;mov	ax,dx ; Drive Number (0 to 7)
 10041                                  		;shl	ax,1
 10042                                  		;shl	ax,1  ; Drive Number * 4
 10043 000019DE 88D0                    		mov	al,dl
 10044 000019E0 D0E0                    		shl	al,1
 10045 000019E2 D0E0                    		shl	al,1
 10046                                  		;add	ax,[unsigned_i] ; partition index number
 10047 000019E4 0246F6                  		add	al,[unsigned_i]
 10048                                  		;mov	si,46
 10049                                  		;mul	si
 10050                                  		;mov	si,ax
 10051                                  		;mov	di,46 ; FDISK partition data/parameters (structure) size
 10052                                  		;mul	di
 10053 000019E7 B42E                    		mov	ah,46
 10054 000019E9 F6E4                    		mul	ah
 10055 000019EB 89C7                    		mov	di,ax
 10056                                  		;mov	[part_table_boot_ind+si],cl
 10057 000019ED 888D[20C4]              		mov	[part_table_boot_ind+di],cl
 10058                                  
 10059                                  		;/* Start head */
 10060                                  		;mov	al,[master_boot_record+1BFh+bx]
 10061 000019F1 AC                      		lodsb
 10062                                  		;mov	[part_table_start_head+si],al
 10063 000019F2 8885[21C4]              		mov	[part_table_start_head+di],al
 10064                                  
 10065                                  		;/* Start sector - unscramble it from INT 13 format*/
 10066                                  		;mov	al,[master_boot_record+1C0h+bx]
 10067                                  		;mov	cx,ax
 10068 000019F6 AC                      		lodsb
 10069 000019F7 88C1                    		mov	cl,al
 10070 000019F9 243F                    		and	al,3Fh
 10071                                  		;mov	[part_table_start_sector+si],al
 10072 000019FB 8885[22C4]              		mov	[part_table_start_sector+di],al
 10073                                  
 10074                                  		;/* Start cylinder - unscramble it from INT 13 format*/
 10075                                  		;mov	al,[master_boot_record+1C1h+bx]
 10076 000019FF AC                      		lodsb
 10077                                  		;sub	ah,ah
 10078                                  		;and	cx,0C0h
 10079                                  		; 11/12/2018
 10080                                  		;and	cl,0C0h 
 10081                                  		; ch = 0
 10082 00001A00 D1E1                    		shl	cx,1
 10083 00001A02 D1E1                    		shl	cx,1  ; 000000??00000000b ; high two bits
 10084                                  		;add	cx,ax
 10085 00001A04 88C1                    		mov	cl,al ; low 8 bits of cylinder
 10086                                  		;mov	[part_table_start_cyl+si],cx
 10087 00001A06 898D[23C4]              		mov	[part_table_start_cyl+di],cx
 10088                                  
 10089                                  		;/* System id */
 10090                                  		;mov	al,[master_boot_record+1C2h+bx]
 10091 00001A0A AC                      		lodsb
 10092                                  		;mov	[part_table_sys_id+si],al
 10093 00001A0B 8885[25C4]              		mov	[part_table_sys_id+di],al
 10094                                  
 10095                                  		;/* End head */
 10096                                  		;mov	al,[master_boot_record+1C3h+bx]
 10097 00001A0F AC                      		lodsb
 10098                                  		;mov	[part_table_end_head+si],al
 10099 00001A10 8885[26C4]              		mov	[part_table_end_head+di],al
 10100                                  
 10101                                  		;/* End sector - unscramble it from INT 13 format*/
 10102                                  		;mov	al,[master_boot_record+1C4h+bx]
 10103 00001A14 AC                      		lodsb
 10104                                  		;mov	cx,ax
 10105 00001A15 88C1                    		mov	cl,al
 10106 00001A17 243F                    		and	al,3Fh
 10107                                  		;mov	[part_table_end_sector+si],al
 10108 00001A19 8885[27C4]              		mov	[part_table_end_sector+di],al
 10109                                  
 10110                                  		;/* End cylinder - unscramble it from INT 13 format*/
 10111                                  		;mov	al,[master_boot_record+1C5h+bx]
 10112 00001A1D AC                      		lodsb
 10113 00001A1E 81E1C000                		and	cx,0C0h
 10114 00001A22 D1E1                    		shl	cx,1
 10115 00001A24 D1E1                    		shl	cx,1  ; 000000??00000000b ; high two bits	
 10116                                  		;add	cx,ax
 10117 00001A26 88C1                    		mov	cl,al ; low 8 bits of cylinder
 10118                                  		;mov	[part_table_end_cyl+si],cx
 10119 00001A28 898D[28C4]              		mov	[part_table_end_cyl+di],cx
 10120                                  
 10121                                  		;/* Relative sectors */
 10122                                  
 10123                                  		;mov	al,[master_boot_record+1C9h+bx]
 10124                                  		;mov	ah,al
 10125                                  		;sub	al,al
 10126                                  		;sub	cx,cx
 10127                                  		;mov	[part_table_rec_sec_lw+si],cx
 10128                                  		;mov	[part_table_rel_sec_hw+si],ax
 10129                                  		;mov	dl,[master_boot_record+1C8h+bx]
 10130                                  		;sub	dh,dh
 10131                                  		;sub	di,di
 10132                                  		;add	cx,di
 10133                                  		;adc	ax,dx
 10134                                  		;mov	[part_table_rec_sec_lw+si],cx
 10135                                  		;mov	[part_table_rel_sec_hw+si],ax
 10136                                  		;mov	dx,ax
 10137                                  		;mov	al,[master_boot_record+1C7h+bx]
 10138                                  		;sub	ah,ah
 10139                                  		;mov	di,dx
 10140                                  		;;sub	dx,dx
 10141                                  		;mov	[pt_rel_sec_temp_lw],cx
 10142                                  		;mov	[pt_rel_sec_temp_hw],di
 10143                                  		;mov	cl,8
 10144                                  		;mov	di,bx
 10145                                  		;call	shl32
 10146                                  		;add	ax,[pt_rel_sec_temp_lw]
 10147                                  		;adc	dx,[pt_rel_sec_temp_hw]
 10148                                  		;mov	[part_table_rec_sec_lw+si],ax
 10149                                  		;mov	[part_table_rel_sec_hw+si],dx
 10150                                  		;mov	cl,[master_boot_record+1C6h+di]
 10151                                  		;sub	ch,ch
 10152                                  		;add	ax,cx
 10153                                  		;adc	dx,0
 10154                                  
 10155                                  		; 21/11/2018
 10156 00001A2C AD                      		lodsw	; mov ax,[master_boot_record+1C6h+bx]
 10157                                  		;mov	dx,ax ; *
 10158 00001A2D 8985[2AC4]              		mov	[part_table_rel_sec_lw+di],ax ; 06/01/2019
 10159                                  
 10160 00001A31 AD                      		lodsw ; ** ; mov ax,[master_boot_record+1C8h+bx]; 
 10161                                  		;xchg	ax,dx
 10162                                  		; DX:AX = part_table_rel_sec (32 bit LBA value)
 10163                                  				
 10164                                  		;mov	[part_table_rel_sec_lw+si],ax
 10165                                  		;mov	[part_table_rel_sec_hw+si],dx
 10166                                  
 10167                                  		; 06/01/2019
 10168 00001A32 8985[2CC4]              		mov	[part_table_rel_sec_hw+di],ax ; high word ; **
 10169                                  
 10170                                  		;/* Number of sectors */
 10171                                  
 10172                                  		;mov	al,[master_boot_record+1CDh+di]
 10173                                  		;mov	ah,al
 10174                                  		;sub	al,al
 10175                                  		;sub	cx,cx
 10176                                  		;mov	[part_table_num_sec_lw+si],cx
 10177                                  		;mov	[part_table_num_sec_hw+si],ax
 10178                                  		;mov	dl,[master_boot_record+1CCh+di]
 10179                                  		;sub	dh,dh
 10180                                  		;sub	bx,bx
 10181                                  		;add	cx,bx
 10182                                  		;adc	ax,dx
 10183                                  		;mov	[part_table_num_sec_lw+si],cx
 10184                                  		;mov	[part_table_num_sec_hw+si],ax
 10185                                  		;mov	dx,ax
 10186                                  		;mov	al,[master_boot_record+1CBh+di]
 10187                                  		;sub	ah,ah
 10188                                  		;mov	bx,dx
 10189                                  		;sub	dx,dx
 10190                                  		;mov	[pt_num_sec_lw],cx
 10191                                  		;mov	[pt_num_sec_hw],bx
 10192                                  		;mov	cl,8
 10193                                  		;call	shl32
 10194                                  		;add	ax,[pt_num_sec_lw]
 10195                                  		;adc	dx,[pt_num_sec_hw]
 10196                                  		;mov	[part_table_num_sec_lw+si],ax
 10197                                  		;mov	[part_table_num_sec_hw+si],dx
 10198                                  		;mov	cl,[master_boot_record+1CAh+di]
 10199                                  		;sub	ch,ch
 10200                                  		;add	ax,cx
 10201                                  		;adc	dx,0
 10202                                  
 10203 00001A36 AD                      		lodsw	; mov ax,[master_boot_record+1CAh+bx]
 10204 00001A37 89C2                    		mov	dx,ax ; ***
 10205                                  
 10206 00001A39 AD                      		lodsw	; mov ax,[master_boot_record+1CCh+bx]
 10207 00001A3A 92                      		xchg	ax,dx ; ****
 10208                                  		; DX:AX = part_table_num_sec (32 bit LBA value)
 10209                                  		
 10210                                  		;mov	[part_table_num_sec_lw+si],ax
 10211                                  		;mov	[part_table_num_sec_hw+si],dx
 10212                                  
 10213 00001A3B 8985[2EC4]              		mov	[part_table_num_sec_lw+di],ax ; low word  ; ***
 10214 00001A3F 8995[30C4]              		mov	[part_table_num_sec_hw+di],dx ; high word ; ****		
 10215                                  
 10216                                  	;part_table[j][i].mbytes_used = (unsigned)
 10217                                  	;  numsecs_to_mbytes(part_table[j][i].num_sec);
 10218                                  
 10219                                  		;push	dx ; ****
 10220                                  		;;push	word [part_table_num_sec_lw+si]
 10221                                  		;push	ax ; ***
 10222                                  		;call	numsecs_to_mbytes
 10223                                  		;pop	bx
 10224                                  		;pop	bx
 10225                                  
 10226 00001A43 E83DFB                  		call	numsecs_to_mbytes ; 21/11/2018
 10227                                  
 10228                                  		;mov	[part_table_mbytes_used+si],ax
 10229 00001A46 8985[34C4]              		mov	[part_table_mbytes_used+di],ax ; =*=
 10230                                  
 10231                                  	; part_table[j][i].percent_used =
 10232                                  	;   mbytes_to_percent(part_table[j][i].mbytes_used,total_mbytes[cur_disk]);
 10233                                  
 10234                                  		;mov	al,[cur_disk]
 10235                                  		;cbw
 10236                                  		;mov	bx,ax
 10237                                  		; 14/12/2018
 10238 00001A4A 30FF                    		xor	bh,bh
 10239 00001A4C 8A1E[E2CB]              		mov	bl,[cur_disk]
 10240 00001A50 D1E3                    		shl	bx,1
 10241 00001A52 FFB7[D6A0]              		push	word [total_mbytes+bx]
 10242                                  		;;push	word [part_table_mbytes_used+si]
 10243                                  		;push	word [part_table_mbytes_used+di]
 10244 00001A56 50                      		push	ax ; =*= ; 14/12/2018
 10245 00001A57 E835FB                  		call	mbytes_to_percent
 10246                                  		;pop	bx ; 06/01/2019
 10247                                  		;pop	bx
 10248                                  		;mov	[part_table_percent_used+si],ax
 10249 00001A5A 8985[36C4]              		mov	[part_table_percent_used+di],ax
 10250                                  
 10251                                  		;/* Set drive letter */
 10252                                  
 10253                                  		;if ( (part_table[j][i].sys_id == DOS12) ||
 10254                                  		;     (part_table[j][i].sys_id == DOS16) ||
 10255                                  		;     (part_table[j][i].sys_id == DOSNEW)   )
 10256                                  		;       {
 10257                                  
 10258                                  		;cmp	byte [part_table_sys_id+si],1 ; DOS12
 10259                                  		;je	short ipt_5
 10260                                  		;cmp	byte [part_table_sys_id+si],4 ; DOS16
 10261                                  		;je	short ipt_5
 10262                                  		;cmp	byte [part_table_sys_id+si],6 ; DOSNEW
 10263                                  		;jne	short ipt_9
 10264                                  
 10265                                  		; 22/11/2018
 10266 00001A5E 8A46F4                  		mov	al,[char_j] ; Drive number (0 to 7)
 10267                                  		;sub	ah,ah
 10268 00001A61 D0E0                    		shl	al,1
 10269 00001A63 D0E0                    		shl	al,1
 10270 00001A65 0246F6                  		add	al,[unsigned_i] ; PT entry number (0 to 3)
 10271                                  		; ax = partition index (0 to 31)
 10272 00001A68 B12E                    		mov	cl,46 ; Partition data (structure) size
 10273 00001A6A F6E1                    		mul	cl
 10274 00001A6C 89C3                    		mov	bx,ax ; Partition data offset 
 10275                                  
 10276 00001A6E 8A85[25C4]              		mov	al,[part_table_sys_id+di] ; 06/01/2019
 10277                                  
 10278                                  		;cmp	byte [part_table_sys_id+di],1 ; FAT12
 10279 00001A72 3C01                    		cmp	al,1
 10280 00001A74 7408                    		je	short ipt_5
 10281                                  		;cmp	byte [part_table_sys_id+di],4 ; FAT16
 10282 00001A76 3C04                    		cmp	al,4
 10283 00001A78 7404                    		je	short ipt_5
 10284                                  		;cmp	byte [part_table_sys_id+di],6 ; FAT16 big
 10285 00001A7A 3C06                    		cmp	al,6
 10286 00001A7C 7526                    		jne	short ipt_9
 10287                                  ipt_5:
 10288                                  		;mov	al,[char_j] ; Drive number (0 to 7)
 10289                                  		;sub	ah,ah
 10290                                  		;shl	ax,1
 10291                                  		;shl	ax,1
 10292                                  		;add	ax,[unsigned_i] ; PT entry number (0 to 3)
 10293                                  		; ax = partition index (0 to 31) 
 10294                                  		;mov	cx,46 ; Partition data (structure) size
 10295                                  		;mul	cx
 10296                                  		;mov	bx,ax ; Partition data offset
 10297                                  		
 10298                                  		;part_table[j][i].drive_letter = c(' ');  
 10299 00001A7E C687[4DC4]20            		mov	byte [part_table_drive_letter+bx],' '
 10300                                  
 10301                                  		;if ((primary_partition_count == 0) ||
 10302                                  		;   ((part_table[j][i].boot_ind == 0x80) &&
 10303                                  		;     (active_primary_count == 0)))
 10304                                  		;	pri_part = c(i);
 10305                                  		;	if (part_table[j][i].boot_ind == 0x80)
 10306                                  		;	   active_primary_count++;
 10307                                  		;	primary_partition_count++; /*Keep track of partition number */
 10308                                  		;	}
 10309                                  
 10310 00001A83 803E[DCC3]00            		cmp	byte [primary_partition_count],0
 10311 00001A88 740D                    		je	short ipt_6
 10312 00001A8A 80BF[20C4]80            		cmp	byte [part_table_boot_ind+bx],80h
 10313                                  		;jne	short ipt_7
 10314 00001A8F 750F                    		jne	short ipt_8 ; 22/11/2018
 10315 00001A91 807EF800                		cmp	byte [active_primary_count],0
 10316                                  		;jne	short ipt_7
 10317 00001A95 7706                    		ja	short ipt_7
 10318                                  ipt_6:
 10319 00001A97 8A46F6                  		mov	al,[unsigned_i]
 10320 00001A9A 8846FE                  		mov	[char_pri_part],al
 10321                                  ipt_7:
 10322                                  		; 22/11/2018
 10323                                  		;mov	al,[char_j]
 10324                                  		;sub	ah,ah
 10325                                  		;shl	ax,1
 10326                                  		;shl	ax,1
 10327                                  		;add	ax,[unsigned_i]
 10328                                  		;mul	cx
 10329                                  		;mov	bx,ax
 10330                                  
 10331                                  		;cmp	byte [part_table_boot_ind+bx],80h
 10332                                  		;jne	short ipt_8
 10333                                  
 10334 00001A9D FE46F8                  		inc	byte [active_primary_count]
 10335                                  ipt_8:
 10336 00001AA0 FE06[DCC3]              		inc	byte [primary_partition_count]
 10337                                  ipt_9:
 10338                                  		;mov	al,[char_j]
 10339                                  		;sub	ah,ah
 10340                                  		;shl	ax,1
 10341                                  		;shl	ax,1
 10342                                  		;add	ax,[unsigned_i]
 10343                                  		;mov	cx,46 ; Partition data (structure) size	
 10344                                  		;mul	cx
 10345                                  		;mov	bx,ax
 10346                                  	
 10347                                  		;/* Set changed flag */
 10348 00001AA4 C687[33C4]00            		mov	byte [part_table_changed+bx],0
 10349                                  	
 10350                                  		;inc	word [unsigned_i]
 10351 00001AA9 FE46F6                  		inc	byte [unsigned_i]
 10352                                  		;cmp	word [unsigned_i],4
 10353 00001AAC 807EF604                		cmp	byte [unsigned_i],4
 10354 00001AB0 730B                    		jnb	short ipt_10
 10355                                  
 10356                                  		; 22/11/2018
 10357                                  		;mov	bl,[char_j] ; Drive number (0 to 7)
 10358                                  		;xor	bh,bh
 10359                                  
 10360                                  		; 11/12/2018
 10361 00001AB2 8B5EF4                  		mov	bx,[char_j]
 10362                                  	
 10363 00001AB5 89DA                    		mov	dx,bx	; 21/11/2018	
 10364 00001AB7 C1E309                  		shl	bx,9	; Drive number * 512
 10365                                  
 10366 00001ABA E911FF                  		jmp	ipt_4
 10367                                  ipt_10:
 10368                                  		; 23/11/2018
 10369                                  		;if (pri_part != 0xFF) 
 10370 00001ABD 807EFEFF                		cmp	byte [char_pri_part],0FFh
 10371 00001AC1 7425                    		je	short ipt_11
 10372                                  
 10373                                  	;part_table[j][pri_part].drive_letter = next_letter++;
 10374                                  	;get_volume(j,pri_part);
 10375                                  
 10376 00001AC3 8A46F4                  		mov	al,[char_j] ; Disk/Drive number (0 to 7)
 10377                                  		;sub	ah,ah
 10378                                  		;shl	ax,1
 10379                                  		;shl	ax,1
 10380 00001AC6 D0E0                    		shl	al,1
 10381 00001AC8 D0E0                    		shl	al,1
 10382 00001ACA 8A4EFE                  		mov	cl,[char_pri_part]
 10383                                  		;sub	ch,ch
 10384                                  		;add	ax,cx
 10385 00001ACD 00C8                    		add	al,cl
 10386                                  		;mov	bx,46 ; Partition data (structure) size	
 10387                                  		;imul	bx
 10388 00001ACF B32E                    		mov	bl,46
 10389 00001AD1 F6E3                    		mul	bl
 10390 00001AD3 89C3                    		mov	bx,ax
 10391 00001AD5 A0[2DA1]                		mov	al,[next_letter]
 10392 00001AD8 FE06[2DA1]              		inc	byte [next_letter]
 10393 00001ADC 8887[4DC4]              		mov	[part_table_drive_letter+bx],al
 10394                                  
 10395                                  		; 14/12/2018
 10396                                  		;push	cx
 10397 00001AE0 88CC                    		mov	ah,cl  ; Partition number
 10398 00001AE2 8A46F4                  		mov	al,[char_j] ; Disk/Drive number
 10399                                  		;push	ax
 10400 00001AE5 E88601                  		call	get_volume
 10401                                  		;pop	bx
 10402                                  		;pop	bx
 10403                                  ipt_11:
 10404 00001AE8 FE46F4                  		inc	byte [char_j]
 10405                                  ipt_for1_1:
 10406                                  		;/* Look at both disks */
 10407                                  
 10408 00001AEB 8A46F4                  		mov	al,[char_j] ; Drive number (0 to 7)
 10409 00001AEE 3806[E3C3]              		cmp	[number_of_drives],al
 10410 00001AF2 7603                    		jna	short ipt_for2_0
 10411 00001AF4 E994FE                  		jmp	ipt_for1_next
 10412                                  ipt_for2_0:
 10413                                  		; 23/11/2018
 10414                                  		; Initializing logical dos drives (in extended partitions)
 10415                                  
 10416                                  		;mov	byte [char_j],0
 10417                                  		;jmp	short ipt_for2_1
 10418                                  		; 11/12/2018
 10419 00001AF7 31C0                    		xor	ax,ax
 10420 00001AF9 8846F4                  		mov	[char_j],al ; 0
 10421 00001AFC EB53                    		jmp	short ipt_for2_next
 10422                                  ipt_12:
 10423                                  		;inc	word [unsigned_i]
 10424 00001AFE FE46F6                  		inc	byte [unsigned_i] ; Partition number (0 to 3)
 10425                                  ipt_in_while_for_1:
 10426                                  		;cmp	word [unsigned_i],4
 10427 00001B01 807EF604                		cmp	byte [unsigned_i],4 ; Partition number (0 to 3)
 10428                                  		; 15/12/2018
 10429                                  		;jb	short ipt_in_while_for_next
 10430                                  		;jmp	ipt_while_more_drives_exist
 10431 00001B05 733C                    		jnb	short ipt_while_end
 10432                                  		
 10433                                  ipt_in_while_for_next:
 10434                                  		;    /* See if a sys id byte of extended exists */
 10435                                  		;    if (boot_record[0x1C2+index] == uc(EXTENDED))
 10436                                  		;	BEGIN
 10437                                  		;	  /* Found another drive, now get its location */
 10438                                  		;	  partition_location = (((((unsigned)(boot_record[0x1C0 + index])) & 0x00C0) << 2));
 10439                                  		;	  partition_location = partition_location + ((unsigned)(boot_record[0x1C1+index]));
 10440                                  
 10441 00001B07 B104                    		mov	cl,4
 10442 00001B09 8B5EF6                  		mov	bx,[unsigned_i] ; Partition number (0 to 3)
 10443                                  		;shl	bx,cl ; 16 * PTE number ; (= Partition Table offset from 1BEh. 0,16,32,48,64)
 10444 00001B0C D2E3                    		shl	bl,cl
 10445 00001B0E 80BF[A2CB]05            		cmp	byte [boot_record+1C2h+bx],5 ; System ID, EXTENDED 
 10446 00001B13 75E9                    		jne	short ipt_12
 10447 00001B15 8A87[A0CB]              		mov	al,[boot_record+1C0h+bx] ; Partition Table Offset + sector byte
 10448 00001B19 25C000                  		and	ax,0C0h  ; Bit 6 and 7 are cylinder bits 8 and 9
 10449 00001B1C D1E0                    		shl	ax,1
 10450 00001B1E D1E0                    		shl	ax,1 ; (bits 8 and 9)
 10451                                  		;mov	cl,[boot_record+1C1h+bx] ; Partition Table Offset + cylinder (low) byte
 10452                                  		;sub	ch,ch
 10453                                  		;add	ax,cx
 10454 00001B20 8A87[A1CB]              		mov	al,[boot_record+1C1h+bx] ; 23/11/2018
 10455 00001B24 8946FC                  		mov	[partition_location],ax ; start cylinder 
 10456                                  
 10457                                  		;	  /* Indicate we found another one */
 10458                                  		;	  more_drives_exist = TRUE;
 10459                                  
 10460                                  		; 15/12/2018
 10461                                  		;mov	byte [more_drives_exist],1 ; TRUE
 10462                                  
 10463                                  		;mov	al,[num_logical_drives]
 10464                                  		;cbw
 10465                                  		;mov	cx,ax
 10466                                  		;mov	cl,[num_logical_drives] ; 0 to 23
 10467                                  
 10468                                  		;	  /* Up the count of found ones */
 10469                                  		;	  /* SR; 9/28/89; The count should be incremented 
 10470                                  		;	     only if there is a logical drive defined */
 10471                                  		;	  if (ext_table[j][num_logical_drives].sys_id != 0)
 10472                                  		;	     num_logical_drives++;
 10473                                  		;	     break;
 10474                                  
 10475 00001B27 B018                    		mov	al,24 ; 24 logical drives per disk (and 1 extended partition per disk)
 10476 00001B29 F666F4                  		mul	byte [char_j] ; Disk/Drive number (0 to 7)
 10477                                  		;add	ax,cx
 10478                                  		;add	al,cl ; Logical partition index
 10479 00001B2C 0246FA                  		add	al,[num_logical_drives] ; 19/12/2018
 10480                                  		;mov	cx,46
 10481                                  		;imul	cx
 10482 00001B2F B12E                    		mov	cl,46 ; Logical partition data (structure) size
 10483 00001B31 F6E1                    		mul	cl
 10484 00001B33 89C3                    		mov	bx,ax ; Logical partition data address
 10485 00001B35 80BF[5DA1]00            		cmp	byte [ext_table_sys_id+bx],0  ; System ID
 10486 00001B3A 7502                    		jne	short ipt_13
 10487                                  		;jmp	ipt_while_more_drives_exist
 10488 00001B3C EB4A                    		jmp	ipt_in_while ; 15/12/2018
 10489                                  ipt_13:
 10490 00001B3E FE46FA                  		inc	byte [num_logical_drives]
 10491                                  
 10492                                  		;jmp	ipt_while_more_drives_exist
 10493 00001B41 EB45                    		jmp	ipt_in_while ; 15/12/2018
 10494                                  
 10495                                  ipt_while_end:
 10496 00001B43 FE46F4                  		inc	byte [char_j]
 10497                                  ipt_for2_1:
 10498                                  	;/* Initialize the cur_disk field to the drive in question so */
 10499                                  	;/* that the calls to the partition information routines will work */
 10500 00001B46 8A46F4                  		mov	al,[char_j]
 10501 00001B49 3806[E3C3]              		cmp	[number_of_drives],al
 10502 00001B4D 7702                    		ja	short ipt_for2_next
 10503 00001B4F EB5C                    		jmp	ipt_16
 10504                                  ipt_for2_next:
 10505 00001B51 A2[E2CB]                		mov	[cur_disk],al
 10506                                  		; ah = 0 ; 11/12/2018
 10507                                  
 10508                                  	;/* Read in the master boot record and see if it was okay */
 10509                                  	; if (read_boot_record(u(0),j,uc(0),uc(1)))    
 10510                                  		;mov	cl,1
 10511                                  		; 11/12/2018
 10512 00001B54 31C9                    		xor 	cx,cx
 10513 00001B56 FEC1                    		inc	cl ; 1
 10514 00001B58 51                      		push	cx
 10515                                  		;sub	cl,cl
 10516 00001B59 FEC9                    		dec	cl ; 0
 10517 00001B5B 51                      		push	cx
 10518 00001B5C 50                      		push	ax
 10519                                  		;sub	ax,ax
 10520 00001B5D 28C0                    		sub	al,al ; 11/12/2018
 10521 00001B5F 50                      		push	ax
 10522 00001B60 E89904                  		call	read_boot_record
 10523                                  		;add	sp,8	; 22/12/2018
 10524                                  		;or	al,al
 10525                                  		;jz	short ipt_while_end
 10526 00001B63 72DE                    		jc	short ipt_while_end ; 27/11/2018
 10527                                  	
 10528                                  	;/* Now, go read in extended partition info */
 10529                                  	; if (find_partition_type(uc(EXTENDED)))      
 10530 00001B65 B005                    		mov	al,EXTENDED ; 5
 10531                                  		;push	ax
 10532 00001B67 E85A02                  		call	find_partition_type
 10533                                  		;pop	bx
 10534                                  		;or	al,al
 10535                                  		;jz	short ipt_while_end
 10536 00001B6A 72D7                    		jc	short ipt_while_end ; 24/11/2018
 10537                                  
 10538                                  		; 14/12/2018
 10539                                  		;mov	[ext_part_num],cl ; 0 to 3 
 10540 00001B6C 88C8                    		mov	al,cl ; 15/12/2018
 10541                                  
 10542                                  	;/* Initialize the array to zero's - include one dummy entry */
 10543                                  	; for (i=u(0); i < u(24); i++)
 10544                                  	;     BEGIN
 10545                                  	;	ext_table[j][i].boot_ind = uc(0);
 10546                                  	;	ext_table[j][i].start_head = uc(0);
 10547                                  	;	ext_table[j][i].start_sector = uc(0);
 10548                                  	;	ext_table[j][i].start_cyl = u(0);
 10549                                  	;	ext_table[j][i].sys_id = uc(0);
 10550                                  	;	ext_table[j][i].end_head = uc(0);
 10551                                  	;	ext_table[j][i].end_sector = uc(0);
 10552                                  	;	ext_table[j][i].end_cyl = u(0);
 10553                                  	;	ext_table[j][i].rel_sec = ul(0);
 10554                                  	;	ext_table[j][i].num_sec = ul(0);
 10555                                  	;	ext_table[j][i].mbytes_used = f(0);
 10556                                  	;	ext_table[j][i].percent_used = u(0);
 10557                                  	;	ext_table[j][i].changed = FALSE;
 10558                                  	;	ext_table[j][i].drive_letter = NUL;
 10559                                  	;
 10560                                  	;	strcpy(ext_table[cur_disk][i].system,NUL);
 10561                                  	;	strcpy(ext_table[cur_disk][i].vol_label,NUL);
 10562                                  	;     END
 10563                                  
 10564                                  		;;mov	word [unsigned_i],0
 10565                                  		;mov	byte [unsigned_i],0
 10566                                  ipt_14:
 10567                                  ;		mov	al,24 ; 24 logical drives
 10568                                  ;		mul	byte [char_j] ; Disk/Driver number (0 to 7)
 10569                                  ;		;add	ax,[unsigned_i]
 10570                                  ;		add	al,[unsigned_i] ; 23/11/2018
 10571                                  ;		;mov	cx,46
 10572                                  ;		mov	cl,46
 10573                                  ;		;mul	cx
 10574                                  ;		mul	cl
 10575                                  ;		mov	bx,ax ; Logical disk drive -partition- data offset
 10576                                  ;		;sub	al,al ; 0
 10577                                  ;		sub	ax,ax ; 0
 10578                                  ;		mov	[ext_table_boot_ind+bx],al
 10579                                  ;		mov	[ext_table_start_head+bx],al
 10580                                  ;		mov	[ext_table_start_sector+bx],al
 10581                                  ;		;mov	[ext_table_start_cyl+bx],0
 10582                                  ;		mov	[ext_table_start_cyl+bx],ax
 10583                                  ;		mov	[ext_table_sys_id+bx],al
 10584                                  ;		mov	[ext_table_end_head+bx],al
 10585                                  ;		mov	[ext_table_end_sector+bx],al
 10586                                  ;		;mov	[ext_table_end_cyl+bx],0
 10587                                  ;		mov	[ext_table_end_cyl+bx],ax
 10588                                  ;		;sub	ax,ax ; 0
 10589                                  ;		mov	[ext_table_rel_sec_hw+bx],ax
 10590                                  ;		mov	[ext_table_rel_sec_lw+bx],ax
 10591                                  ;		mov	[ext_table_num_sec_hw+bx],ax
 10592                                  ;		mov	[ext_table_num_sec_lw+bx],ax
 10593                                  ;		mov	[ext_table_mbytes_used+bx],ax
 10594                                  ;		mov	[ext_table_percent_used+bx],ax
 10595                                  ;		sub	al,al
 10596                                  ;		mov	[ext_table_changed+bx],al
 10597                                  ;		mov	[ext_table_drive_letter+bx],al
 10598                                  ;		;sub	ax,ax ; 0
 10599                                  ;		;push	ax ; NUL
 10600                                  ;		mov	al,24
 10601                                  ;		;imul	byte [cur_disk]
 10602                                  ;		mul	byte [cur_disk] ; 23/11/2018
 10603                                  ;		;add	ax,[unsigned_i] ; Current logical drive index (0 to 23)
 10604                                  ;		add	al,[unsigned_i]
 10605                                  ;		;mul	cx
 10606                                  ;		mul	cl ; cl = 46
 10607                                  ;		;;;mov	dx,ax ; *
 10608                                  ;		;add	ax,ext_table_system ; Partition (File System) ID address
 10609                                  ;		;push	ax
 10610                                  ;		;call	strcpy
 10611                                  ;		;pop	bx
 10612                                  ;		;pop	bx
 10613                                  ;		
 10614                                  ;		; 23/11/2018 - clear Volume Name field (12 bytes)
 10615                                  ;		mov	di,ext_table_vol_label 
 10616                                  ;		add	di,ax
 10617                                  ;		;sub	al,al
 10618                                  ;		sub	ax,ax ; 0
 10619                                  ;		;mov	cl,6 ; 6 words, 12 bytes
 10620                                  ;		;;ch = 0
 10621                                  ;		;rep	stosw
 10622                                  ;		; System ID field -9 bytes- is just after Volume Name field
 10623                                  ;		; ! Clear Volume Name and System ID fields. (21 bytes) !	
 10624                                  ;		mov	cl,10 ; 10 words
 10625                                  ;		rep	stosw
 10626                                  ;		stosb	      ; +1 bytes = 12+9 bytes		
 10627                                  ;		
 10628                                  ;		;sub	ax,ax ; 0
 10629                                  ;		;push	ax ; NUL
 10630                                  ;		;mov	al,24
 10631                                  ;		;;imul	byte [cur_disk]
 10632                                  ;		;mul	byte [cur_disk]
 10633                                  ;		;;add	ax,[unsigned_i]
 10634                                  ;		;add	al,[unsigned_i]
 10635                                  ;		;;mov	cx,46
 10636                                  ;		;;mul	cx
 10637                                  ;		;mov	cl,46
 10638                                  ;		;mul	cl
 10639                                  ;		;;;mov	ax,dx ; *
 10640                                  ;		;add	ax,ext_table_vol_label ; Volume name address
 10641                                  ;		
 10642                                  ;		;push	ax
 10643                                  ;		;call	strcpy
 10644                                  ;		;pop	bx
 10645                                  ;		;pop	bx
 10646                                  ;
 10647                                  ;		;; 23/11/2018 - clear Partition (File System) ID field (9 bytes)
 10648                                  ;		;;mov	di,ext_table_system
 10649                                  ;		;;add	di,ax ; (Already) System ID field is just after Volume Name field
 10650                                  ;		;;;sub	ax,ax
 10651                                  ;		;mov	cl,9 ; 9 bytes
 10652                                  ;		;;ch = 0
 10653                                  ;		;rep	stosb
 10654                                  ;
 10655                                  ;		;inc	word [unsigned_i]
 10656                                  ;		inc	byte [unsigned_i]
 10657                                  ;		;cmp	word [unsigned_i],24
 10658                                  ;		cmp	byte [unsigned_i],24
 10659                                  ;		jnb	short ipt_15
 10660                                  ;		jmp	ipt_14
 10661                                  
 10662                                  		; 14/12/2018
 10663                                  		; (bss -extended partition data area- already has been cleared)
 10664                                  		;		
 10665                                  		;; 23/11/2018
 10666                                  		;; Clear Logical Drive/Partition data area for current disk
 10667                                  		;mov	di,ext_table_boot_ind ; Start of logical drives data
 10668                                  		;mov	al,24
 10669                                  		;mul	byte [cur_disk]
 10670                                  		;mov	cl,46
 10671                                  		;mul	cl
 10672                                  		;; ax =  offset from ext_table_boot_ind
 10673                                  		;add	di,ax ; Start of logical drives data (for current disk)
 10674                                  		;
 10675                                  		;xor	ax,ax ; 0
 10676                                  		;mov	cx,(24*46)/2 ; 24 logical drives per extended partition (per disk) 
 10677                                  		;rep	stosw	; clear 552 words instead of 1104 bytes
 10678                                  
 10679                                  ipt_15:
 10680                                  	;/* Find where the first extended boot record is */
 10681                                  	; temp = find_partition_location(uc(EXTENDED));
 10682                                  	; partition_location = part_table[j][temp].start_cyl;
 10683                                  		
 10684                                  		; 14/12/2018
 10685                                  		;mov	al,5 ; EXTENDED
 10686                                  		;;push	ax
 10687                                  		;call	find_partition_location
 10688                                  		;;pop	bx
 10689                                  
 10690                                  		;mov	al,[ext_part_num] ; 14/12/2018
 10691                                  		; 15/12/2018
 10692                                  		; AL = Partition number of extended partition (in MBR)
 10693                                  
 10694                                  		; 24/11/2018
 10695                                  			 ; AL = Partition number (0 to 3)
 10696                                  			 ; 	or AL =	0FFh (not found)
 10697                                  			 ; BX = Partition data (structure) offset ; =*=
 10698                                  		;cbw
 10699                                  		; ax = partition number (0 to 3) of extended partition
 10700 00001B6E 8A4EF4                  		mov	cl,[char_j] ; Disk number (0 to 7)
 10701                                  		;sub	ch,ch
 10702                                  		;shl	cx,1
 10703                                  		;shl	cx,1
 10704 00001B71 D0E1                    		shl	cl,1
 10705 00001B73 D0E1                    		shl	cl,1 ; 4 * disk number (every disk/MBR has 4 partition table entries) 
 10706                                  		;add	ax,cx ; Partition index in FDISK partitions data
 10707 00001B75 00C8                    		add	al,cl
 10708                                  		;mov	cx,46
 10709                                  		;imul	cx
 10710 00001B77 B12E                    		mov	cl,46
 10711 00001B79 F6E1                    		mul	cl
 10712 00001B7B 89C3                    		mov	bx,ax ; Partition data (structure) offset -of extended partition-
 10713                                   
 10714 00001B7D 8B87[23C4]              		mov	ax,[part_table_start_cyl+bx]
 10715 00001B81 8946FC                  		mov	[partition_location],ax ; start cylinder of extended partition
 10716                                  
 10717                                  	;/* Go find extended boot records as long as there are more of them */
 10718                                  	; 	more_drives_exist = TRUE;
 10719                                  	;
 10720                                  	;/* Init the number of logical drives, for a array index */
 10721                                  	; 	num_logical_drives = c(0);
 10722                                  
 10723                                  		;mov	byte [more_drives_exist],1  ; TRUE
 10724 00001B84 C646FA00                		mov	byte [num_logical_drives],0
 10725                                  
 10726                                  		; 15/12/2018
 10727                                  		;jmp	short ipt_in_while ; 23/11/2018
 10728                                  
 10729                                  ; 15/12/2018
 10730                                  ;ipt_while_more_drives_exist:
 10731                                  ;
 10732                                  ;	;while (more_drives_exist)
 10733                                  ;	;	BEGIN
 10734                                  ;	;	/* Assume we won't find another logical drive */
 10735                                  ;	;	more_drives_exist = FALSE;
 10736                                  ;
 10737                                  ;		cmp	byte [more_drives_exist],0
 10738                                  ;		jne	short ipt_in_while
 10739                                  ;		jmp	ipt_while_end
 10740                                  
 10741                                  ipt_in_while:
 10742                                  		; 15/12/2018
 10743                                  		;mov	byte [more_drives_exist],0
 10744                                  
 10745                                  	;	/*Read in the extended boot record */
 10746                                  	;	if (read_boot_record(partition_location,j,uc(0),uc(1)))
 10747                                  	;	BEGIN
 10748                                  	;	   load_logical_drive(num_logical_drives,j);
 10749                                  
 10750                                  		;mov	al,1
 10751 00001B88 B80100                  		mov	ax,1 ; 11/12/2018
 10752 00001B8B 50                      		push	ax
 10753 00001B8C 28C0                    		sub	al,al ; 0
 10754 00001B8E 50                      		push	ax
 10755 00001B8F 8A46F4                  		mov	al,[char_j] ; Disk number (0 to 7)
 10756 00001B92 50                      		push	ax
 10757 00001B93 FF76FC                  		push	word [partition_location]
 10758 00001B96 E86304                  		call	read_boot_record
 10759                                  		;add	sp,8	; 22/12/2018
 10760                                  		;or	al,al
 10761                                  		;jz	short ipt_while_more_drives_exist
 10762                                  		;jc	short ipt_while_more_drives_exist ; 27/11/2018
 10763 00001B99 72A8                    		jc	short ipt_while_end
 10764                                  		;
 10765 00001B9B 8A46F4                  		mov	al,[char_j]
 10766 00001B9E 50                      		push	ax
 10767 00001B9F 8A46FA                  		mov	al,[num_logical_drives]
 10768 00001BA2 50                      		push	ax
 10769 00001BA3 E84302                  		call	load_logical_drive
 10770                                  		;pop	bx ; 06/01/2019
 10771                                  		;pop	bx
 10772                                  ipt_in_while_for:
 10773                                  		;  /* find the next logical drive */
 10774                                  		;  for (i = u(0); i < u(4); i++)
 10775                                  		;      BEGIN
 10776                                  		;      index = i*16;
 10777                                  
 10778                                  		;mov	word [unsigned_i],0
 10779 00001BA6 C646F600                		mov	byte [unsigned_i],0 ; Partition number (0 to 3)
 10780                                  		;jmp	ipt_in_while_for_1
 10781                                  		; 14/12/2018
 10782 00001BAA E95AFF                  		jmp	ipt_in_while_for_next
 10783                                  ipt_16:
 10784                                  		; 23/11/2018
 10785                                  		; Set drive letters and volume names
 10786                                  
 10787 00001BAD C646F400                		mov	byte [char_j],0
 10788 00001BB1 EB55                    		jmp	short ipt_22
 10789                                  ipt_17:
 10790                                  		;inc	word [unsigned_i]
 10791 00001BB3 FE46F6                  		inc	byte [unsigned_i]
 10792                                  ipt_18:
 10793                                  		;cmp	word [unsigned_i],4
 10794 00001BB6 807EF604                		cmp	byte [unsigned_i],4
 10795 00001BBA 7349                    		jnb	short ipt_21
 10796                                  ipt_19:		
 10797                                  		; 23/11/2018
 10798                                  		;/* Look at all non-active primary partitions */  
 10799                                  
 10800 00001BBC 8A46F4                  		mov	al,[char_j] ; Disk number
 10801                                  		;sub	ah,ah
 10802                                  		;shl	ax,1
 10803                                  		;shl	ax,1
 10804 00001BBF D0E0                    		shl	al,1
 10805 00001BC1 D0E0                    		shl	al,1 ; 4 partition table entries per disk/MBR
 10806                                  		;add	ax,[unsigned_i]
 10807 00001BC3 0246F6                  		add	al,[unsigned_i]
 10808                                  		;mov	cx,46
 10809                                  		;mul	cx
 10810 00001BC6 B12E                    		mov	cl,46 ; Partition data (structure) size
 10811 00001BC8 F6E1                    		mul	cl
 10812 00001BCA 89C3                    		mov	bx,ax ; Partition data address
 10813 00001BCC 80BF[25C4]01            		cmp	byte [part_table_sys_id+bx],1 ; DOS12
 10814 00001BD1 740E                    		je	short ipt_20
 10815 00001BD3 80BF[25C4]04            		cmp	byte [part_table_sys_id+bx],4 ; DOS16
 10816 00001BD8 7407                    		je	short ipt_20
 10817 00001BDA 80BF[25C4]06            		cmp	byte [part_table_sys_id+bx],6 ; DOSNEW
 10818 00001BDF 75D2                    		jne	short ipt_17
 10819                                  ipt_20:
 10820                                  		;mov	al,[char_j]
 10821                                  		;sub	ah,ah
 10822                                  		;shl	ax,1
 10823                                  		;shl	ax,1
 10824                                  		;add	ax,[unsigned_i]
 10825                                  		;mul	cx
 10826                                  		;mov	bx,ax
 10827 00001BE1 80BF[20C4]80            		cmp	byte [part_table_boot_ind+bx],80h
 10828 00001BE6 74CB                    		je	short ipt_17
 10829 00001BE8 80BF[4DC4]20            		cmp	byte [part_table_drive_letter+bx],' '
 10830 00001BED 75C4                    		jne	short ipt_17
 10831 00001BEF A0[2DA1]                		mov	al,[next_letter]
 10832 00001BF2 FE06[2DA1]              		inc	byte [next_letter]
 10833 00001BF6 8887[4DC4]              		mov	[part_table_drive_letter+bx],al
 10834                                  		
 10835                                  		; 14/12/2018
 10836                                  		;push	word [unsigned_i]
 10837 00001BFA 8A66F6                  		mov	ah,[unsigned_i] ; Partition number		
 10838 00001BFD 8A46F4                  		mov	al,[char_j] ; Disk number
 10839                                  		;push	ax
 10840 00001C00 E86B00                  		call	get_volume
 10841                                  		;pop	bx
 10842                                  		;pop	bx
 10843 00001C03 EBAE                    		jmp	short ipt_17
 10844                                  ipt_21:
 10845 00001C05 FE46F4                  		inc	byte [char_j]
 10846                                  ipt_22:
 10847                                  		; 23/11/2018
 10848                                  		;/* Look at all active primary partitions */
 10849                                  
 10850                                  		;mov	al,[char_j]
 10851 00001C08 A0[E3C3]                		mov	al,[number_of_drives]
 10852                                  		;cmp	byte [number_of_drives],al
 10853                                  		;jbe	short ipt_26
 10854 00001C0B 3A46F4                  		cmp	al,[char_j]
 10855 00001C0E 765B                    		jna	short ipt_26 ; 10/12/2018
 10856                                  		;mov	word [unsigned_i],0
 10857 00001C10 C646F600                		mov	byte [unsigned_i],0
 10858                                  ipt_23:
 10859 00001C14 8A46F4                  		mov	al,[char_j] ; Disk number (0 to 7)
 10860                                  		;sub	ah,ah
 10861                                  		;shl	ax,1
 10862                                  		;shl	ax,1
 10863 00001C17 D0E0                    		shl	al,1
 10864 00001C19 D0E0                    		shl	al,1 ; 4 partition entries in a MBR
 10865                                  		;add	ax,[unsigned_i]
 10866 00001C1B 0246F6                  		add	al,[unsigned_i] ; Partition index (for current disk)
 10867                                  		;mov	cx,46
 10868                                  		;mul	cx
 10869 00001C1E B12E                    		mov	cl,46
 10870 00001C20 F6E1                    		mul	cl
 10871 00001C22 89C3                    		mov	bx,ax	; Partition data offset
 10872 00001C24 80BF[25C4]01            		cmp	byte [part_table_sys_id+bx],1 ; DOS12 (FAT12)
 10873 00001C29 740E                    		je	short ipt_24
 10874 00001C2B 80BF[25C4]04            		cmp	byte [part_table_sys_id+bx],4 ; DOS16 (FAT16)
 10875 00001C30 7407                    		je	short ipt_24
 10876 00001C32 80BF[25C4]06            		cmp	byte [part_table_sys_id+bx],6 ; DOSNEW (FAT16 big)
 10877 00001C37 7522                    		jne	short ipt_25
 10878                                  ipt_24:
 10879                                  		;mov	al,[char_j]
 10880                                  		;sub	ah,ah
 10881                                  		;shl	ax,1
 10882                                  		;shl	ax,1
 10883                                  		;add	ax,[unsigned_i]
 10884                                  		;mul	cx
 10885                                  		;mov	bx,ax
 10886                                  
 10887 00001C39 80BF[20C4]80            		cmp	byte [part_table_boot_ind+bx],80h ; ACTIVE ?
 10888 00001C3E 751B                    		jne	short ipt_25
 10889 00001C40 80BF[4DC4]20            		cmp	byte [part_table_drive_letter+bx],' '
 10890 00001C45 7514                    		jne	short ipt_25
 10891 00001C47 A0[2DA1]                		mov	al,[next_letter]
 10892 00001C4A FE06[2DA1]              		inc	byte [next_letter]
 10893 00001C4E 8887[4DC4]              		mov	[part_table_drive_letter+bx],al
 10894                                  		; 14/12/2018
 10895                                  		;push	word [unsigned_i]
 10896 00001C52 8A66F6                  		mov	ah,[unsigned_i] ; Partition number		
 10897 00001C55 8A46F4                  		mov	al,[char_j] ; Disk number
 10898                                  		;push	ax
 10899 00001C58 E81300                  		call	get_volume
 10900                                  		;pop	bx
 10901                                  		;pop	bx
 10902                                  ipt_25:
 10903                                  		;inc	word [unsigned_i]
 10904 00001C5B FE46F6                  		inc	byte [unsigned_i]
 10905                                  		;cmp	word [unsigned_i],4
 10906 00001C5E 807EF604                		cmp	byte [unsigned_i],4
 10907 00001C62 72B0                    		jb	short ipt_23
 10908                                  		;mov	word [unsigned_i],0
 10909 00001C64 C646F600                		mov	byte [unsigned_i],0
 10910                                  		;jmp	ipt_18
 10911 00001C68 E951FF                  		jmp	ipt_19 ; 23/11/2018
 10912                                  ipt_26:
 10913                                  		; 23/11/2018
 10914                                  		;pop	si
 10915                                  		;pop	di
 10916 00001C6B 89EC                    		mov	sp,bp
 10917                                  		;pop	bp
 10918 00001C6D C3                      		retn
 10919                                  
 10920                                  ; ----------------------------------------------------------------------------
 10921                                  
 10922                                  ; convert.c (FDISK, MSDOS 6.0, 1991)
 10923                                  
 10924                                  ;numsecs_to_mbytes:
 10925                                  ;		; INPUT: DX:AX = Sector count (32 bit)	
 10926                                  ;		;push	bp
 10927                                  ;		;mov	bp,sp
 10928                                  ;		;mov	ax,[bp+4] ; sector count lw
 10929                                  ;		;mov	dx,[bp+6] ; sector count hw
 10930                                  ;
 10931                                  ;	;sectors_in_one_meg = u(ONE_MEG / bytes_in_one_sector);
 10932                                  ;	;mbytes_out = f((numsecs + ul(sectors_in_one_meg/2)) / sectors_in_one_meg)
 10933                                  ;
 10934                                  ;		add	ax,1024 ; round up
 10935                                  ;		adc	dx,0
 10936                                  ;			; DX:AX = (X kilo byte)*2 sectors
 10937                                  ;		mov	cl,11 ; / 2048
 10938                                  ;		call	shr32
 10939                                  ;			; (X kilo bytes)*2 / 2048 = X/1024 mega bytes
 10940                                  ;		;mov	sp,bp
 10941                                  ;		;pop	bp
 10942                                  ;		retn
 10943                                  
 10944                                  ; ----------------------------------------------------------------------------
 10945                                  
 10946                                  ; convert.c (FDISK, MSDOS 6.0, 1991)
 10947                                  
 10948                                  ;mbytes_to_percent:
 10949                                  ;		; 21/11/2018
 10950                                  ;
 10951                                  ;	;%define percent    bp-2
 10952                                  ;	%define partmbytes  bp+4  ; mbytes_used
 10953                                  ;	%define	totalmbytes bp+6  ; total_cap	
 10954                                  ;
 10955                                  ;		push	bp
 10956                                  ;		mov	bp,sp
 10957                                  ;		;xor	bx,bx ; 0
 10958                                  ;		;push	bx
 10959                                  ;		
 10960                                  ;		;if (mbytes_used) {
 10961                                  ;
 10962                                  ;		;cmp	word [partmbytes],0
 10963                                  ;		;je	short mtp_0
 10964                                  ;		mov	ax,[partmbytes]
 10965                                  ;		or	ax,ax
 10966                                  ;		jz	short mtp_0
 10967                                  ;
 10968                                  ;		;large_number = ( mbytes_used * 100L ) +total_cap/2;
 10969                                  ;
 10970                                  ;		;mov	ax,[totalmbytes]
 10971                                  ;		;sub	dx,dx
 10972                                  ;		;push	dx ; divisor_hw = 0
 10973                                  ;		;push	ax ; divisor_lw
 10974                                  ;		;;;push	ax ;* divisor (16 bit)
 10975                                  ;		mov	cx,[totalmbytes] ; divisor (16 bit)
 10976                                  ;		;mov	ax,100
 10977                                  ;		;mul	word [partmbytes] ; X
 10978                                  ;		mov	dx,100
 10979                                  ;		mul	dx		
 10980                                  ;
 10981                                  ;		;mov	cx,[totalmbytes]
 10982                                  ;		;shr	cx,1
 10983                                  ;		;add	ax,cx
 10984                                  ;		
 10985                                  ;		;;;mov	bx,[totalmbytes]  ; Y
 10986                                  ;		mov	bx,cx
 10987                                  ;		shr	bx,1 ; 1/2 Y
 10988                                  ;		add	ax,bx ; ((100*X)/Y)+(0.5)*Y/Y
 10989                                  ;		adc	dx,0
 10990                                  ;		
 10991                                  ;		;percentage_out = (unsigned) (large_number/total_cap);
 10992                                  ;
 10993                                  ;		;;;pop	cx ;* 21/11/2018 - divisor (16 bit)
 10994                                  ;		;push	dx ; dividend_hw
 10995                                  ;		;push	ax ; dividend_lw
 10996                                  ;		;call	div32
 10997                                  ;
 10998                                  ;		; dx:ax = dividend (32 bit)
 10999                                  ;		; cx = divisor (16 bit)
 11000                                  ;		call	div32
 11001                                  ;		;mov	[percent],ax
 11002                                  ;
 11003                                  ;		;if (percentage_out > u(100)) percentage_out = u(100);
 11004                                  ;
 11005                                  ;		cmp	ax,100
 11006                                  ;		jbe	short mtp_0
 11007                                  ;		;mov	word [percent],100
 11008                                  ;		mov	ax,100
 11009                                  ;		;jmp	short mtp_1
 11010                                  ;mtp_0:
 11011                                  ;		;mov	word [percent],0
 11012                                  ;mtp_1:
 11013                                  ;		;mov	ax,[percent]
 11014                                  ;		;mov	sp,bp
 11015                                  ;		pop	bp
 11016                                  ;
 11017                                  ;		retn	
 11018                                  
 11019                                  ; ----------------------------------------------------------------------------
 11020                                  
 11021                                  ;div32:
 11022                                  ;	%define dividend_lw bp+4
 11023                                  ;	%define dividend_hw bp+6
 11024                                  ;	%define divisor_lw  bp+8
 11025                                  ;	%define divisor_hw  bp+10
 11026                                  ;
 11027                                  ;		push	bp
 11028                                  ;		mov	bp,sp
 11029                                  ;		push	bx
 11030                                  ;		push	si
 11031                                  ;		mov	ax,[divisor_hw]
 11032                                  ;		or	ax,ax
 11033                                  ;		jnz	short div32_0
 11034                                  ;		mov	cx,[divisor_lw]
 11035                                  ;		mov	ax,[dividend_hw]
 11036                                  ;		xor	dx,dx
 11037                                  ;		div	cx
 11038                                  ;		mov	bx,ax
 11039                                  ;		mov	ax,[dividend_lw]
 11040                                  ;		div	cx
 11041                                  ;		mov	dx,bx
 11042                                  ;		jmp	short div32_4
 11043                                  ;div32_0:
 11044                                  ;		mov	cx,ax
 11045                                  ;		mov	bx,[divisor_lw]
 11046                                  ;		mov	dx,[dividend_hw]
 11047                                  ;		mov	ax,[dividend_lw]
 11048                                  ;div32_1:
 11049                                  ;		shr	cx,1
 11050                                  ;		rcr	bx,1
 11051                                  ;		shr	dx,1
 11052                                  ;		rcr	ax,1
 11053                                  ;		or	cx,cx
 11054                                  ;		jnz	short div32_1
 11055                                  ;		div	bx
 11056                                  ;		mov	si,ax
 11057                                  ;		mul	word [divisor_hw]
 11058                                  ;		xchg	ax,cx
 11059                                  ;		mov	ax,[divisor_lw]
 11060                                  ;		mul	si
 11061                                  ;		add	dx,cx
 11062                                  ;		jc	short div32_2
 11063                                  ;		cmp	dx,[dividend_hw]
 11064                                  ;		ja	short div32_2
 11065                                  ;		jb	short div32_3
 11066                                  ;		cmp	ax,[dividend_lw]
 11067                                  ;		jbe	short div32_3
 11068                                  ;div32_2:
 11069                                  ;		dec	si
 11070                                  ;div32_3:
 11071                                  ;		xor	dx,dx
 11072                                  ;		xchg	ax,si
 11073                                  ;div32_4:
 11074                                  ;		pop	si
 11075                                  ;		pop	bx
 11076                                  ;		pop	bp
 11077                                  ;		retn	8
 11078                                  
 11079                                  ;		mov	cx,[divisor_lw]
 11080                                  ;		mov	ax,[dividend_hw]
 11081                                  ;		xor	dx,dx
 11082                                  ;		div	cx
 11083                                  ;		mov	bx,ax
 11084                                  ;		mov	ax,[dividend_lw]
 11085                                  ;		div	cx
 11086                                  ;		mov	dx,bx
 11087                                  ;		jmp	short div32_4
 11088                                  ;
 11089                                  ;div32:
 11090                                  ;		; 21/11/2018
 11091                                  ;		; DX:AX = Dividend
 11092                                  ;		; CX = Divisor
 11093                                  ;
 11094                                  ;		mov	bx,ax  ; dividend_lw	
 11095                                  ;		mov	ax,dx  ; dividend_hw
 11096                                  ;		xor	dx,dx
 11097                                  ;		div	cx	
 11098                                  ;		xchg	bx,ax
 11099                                  ;		div	cx
 11100                                  ;		;mov	dx,bx
 11101                                  ;		xchg	dx,bx
 11102                                  ;
 11103                                  ;		; DX:AX = Quotient
 11104                                  ;		; BX = Remainder
 11105                                  ;
 11106                                  ;		retn
 11107                                  
 11108                                  ; ----------------------------------------------------------------------------
 11109                                  ; fdisk.c (FDISK, MSDOS 6.0, 1991)	
 11110                                  ; ----------------------------------------------------------------------------
 11111                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 23/11/2018)
 11112                                  
 11113                                  ;/*  */
 11114                                  ;void get_volume(j,i)                                                    
 11115                                  ;									/*C21*/
 11116                                  ;unsigned char j;                                                        
 11117                                  ;unsigned i;                                                             
 11118                                  ;									/*C21*/
 11119                                  ;BEGIN                                                                   
 11120                                  ;									/*C21*/
 11121                                  ;char     volume_label[13];                                              
 11122                                  ;unsigned k;                                                             
 11123                                  ;unsigned length;                                                        
 11124                                  ;									/*C21*/
 11125                                  ;    /* See if the disk has already been formated */                     
 11126                                  ;    if (check_format(part_table[j][i].drive_letter) == TRUE )           
 11127                                  ;       BEGIN                                                            
 11128                                  ;	/* get volume and system info */                                
 11129                                  ;									/*C21*/
 11130                                  ;	for (k = u(0); k < u(12); k++)                                  
 11131                                  ;	   BEGIN                                                        
 11132                                  ;	    part_table[j][i].vol_label[k]=u(0);                         
 11133                                  ;	   END                                                          
 11134                                  ;									/*C21*/
 11135                                  ;	for (k = u(0); k < u(9); k++)                                   
 11136                                  ;	   BEGIN                                                        
 11137                                  ;	    part_table[j][i].system[k]=u(0);                            
 11138                                  ;	   END                                                          
 11139                                  ;									/*C21*/
 11140                                  ;	get_volume_string(part_table[j][i].drive_letter,&volume_label[0]);
 11141                                  ;									/*C21*/
 11142                                  ;	for (k = u(0); k < strlen(volume_label); k++)                   
 11143                                  ;	   BEGIN                                                        
 11144                                  ;	    part_table[j][i].vol_label[k]=volume_label[k];              
 11145                                  ;	   END                                                          
 11146                                  ;									/*C21*/
 11147                                  ;	/* Now try to get it using GET MEDIA ID */                      
 11148                                  ;	if (get_fs_and_vol(part_table[j][i].drive_letter))              
 11149                                  ;	   BEGIN                                                        
 11150                                  ;	    for (k=u(0); k < u(8); k++)                                 
 11151                                  ;	       BEGIN                                                    
 11152                                  ;		if (dx_buff.file_system[k] != ' ')                      
 11153                                  ;		    length = k+1;                                       
 11154                                  ;	       END                                                      
 11155                                  ;	    strncpy(part_table[j][i].system,&dx_buff.file_system[0],u(length));
 11156                                  ;	   END                                                          
 11157                                  ;	else                                                            
 11158                                  ;	   BEGIN                                                        
 11159                                  ;	    if (part_table[j][i].num_sec > (unsigned long)FAT16_SIZE)   
 11160                                  ;		strcpy(part_table[j][i].system,FAT16);                  
 11161                                  ;	    else                                                        
 11162                                  ;		strcpy(part_table[j][i].system,FAT12);                  
 11163                                  ;	   END                                                          
 11164                                  ;       END                                                              
 11165                                  ;    else                                                                
 11166                                  ;       BEGIN                                                            
 11167                                  ;	/* set up to no file system or volume label */                  
 11168                                  ;	strcpy(part_table[j][i].vol_label,NOVOLUME);                    
 11169                                  ;	strcpy(part_table[j][i].system,NOFORMAT);                       
 11170                                  ;      END                                                              
 11171                                  ;   return;                                                             
 11172                                  ;END 
 11173                                  
 11174                                  ;NOTE: 'get_volume' is not compatible with MSDOS 3.3 (and Retro DOS v3.0)
 11175                                  ;	(23/11/2018 - Erdogan Tan)
 11176                                  ; Solution: For MSDOS 3.3 or Retro DOS v3.0, this FDISK code must be modified
 11177                                  ; to exclude volume name in partition table (displaying, deleting) procedures.
 11178                                  
 11179                                  get_volume:
 11180                                  
 11181                                  	;%define _k_	    bp-18 ; unsigned integer (word)
 11182                                  	;%define vol_label  bp-16 ; char volume_label(13) ; 13 bytes
 11183                                  	;%define _length_   bp-2  ; unsigned integer (word)	 
 11184                                  
 11185                                  	%define vol_label   bp-14 ; char volume_label(13) ; 13 bytes ; *****
 11186                                  
 11187                                  	;%define j_disk	    bp+4  ; unsigned char (byte)	
 11188                                  	;%define i_partition bp+6  ; unsigned integer (word)
 11189                                  
 11190                                  		; 14/12/2018
 11191                                  		; INPUT:
 11192                                  		;   AL = Disk/Drive number (0 to 7)
 11193                                  		;   AH = Partition number (0 to 3)		
 11194                                  
 11195 00001C6E 55                      		push	bp
 11196 00001C6F 89E5                    		mov	bp,sp
 11197                                  		;sub	sp,18
 11198 00001C71 83EC0E                  		sub	sp,14 ; *****
 11199                                  		;push	si
 11200                                  		;push	di ; *
 11201                                  		
 11202                                  		; 14/12/2018
 11203                                  		;mov	al,[j_disk] ; Disk number (0 to 7)
 11204                                  		; AL = Disk number		
 11205                                  
 11206                                  		;sub	ah,ah
 11207                                  		;shl	ax,1
 11208                                  		;shl	ax,1
 11209                                  		;add	ax,[i_partition] ; Partition number (0 to 3)
 11210                                  
 11211 00001C74 D0E0                    		shl	al,1
 11212 00001C76 D0E0                    		shl	al,1
 11213                                  		
 11214                                  		;14/12/2018		
 11215                                  		;add	al,[i_partition]
 11216 00001C78 00E0                    		add	al,ah  ; ah = Partition number
 11217                                  
 11218                                  		;mov	cx,46
 11219                                  		;mul	cx
 11220 00001C7A B92E00                  		mov	cx,46
 11221 00001C7D F6E1                    		mul	cl
 11222                                  		;mov	bx,ax
 11223 00001C7F 89C6                    		mov	si,ax ; ** ; 12/12/2018
 11224                                  
 11225                                  		;mov	al,[part_table_drive_letter+bx]
 11226 00001C81 8A84[4DC4]              		mov	al,[part_table_drive_letter+si]
 11227                                  		; 24/11/2018
 11228                                  		;push	ax
 11229 00001C85 E8AC00                  		call	check_format
 11230                                  		;pop	bx
 11231                                  		;dec	al
 11232                                  		;jz	short gv_1
 11233                                  
 11234 00001C88 7302                    		jnc	short gv_1
 11235 00001C8A EB73                    		jmp	gv_11
 11236                                  gv_1:
 11237                                  		;mov	word [_k_],0
 11238                                  gv_2:
 11239                                  ;		;mov	al,[j_disk]
 11240                                  ;		;sub	ah,ah
 11241                                  ;		;shl	ax,1
 11242                                  ;		;shl	ax,1
 11243                                  ;		;add	ax,[i_partition]
 11244                                  ;		;mov	cx,46
 11245                                  ;		;mul	cx
 11246                                  ;		;mov	si,ax ; ** ; 12/12/2018
 11247                                  ;		mov	bx,[_k_]
 11248                                  ;		mov	byte [part_table_vol_label+bx+si],0
 11249                                  ;		;inc	word [_k_]
 11250                                  ;		inc	byte [_k_]
 11251                                  ;		;cmp	word [_k_],12
 11252                                  ;		cmp	byte [_k_],12
 11253                                  ;		jb	short gv_2
 11254                                  ;		;mov	word [_k_],0
 11255                                  ;		mov	byte [_k_],0
 11256                                  
 11257                                  ;		; 23/11/2018
 11258                                  ;		xor	ax,ax
 11259                                  ;		mov	di,part_table_vol_label ; *
 11260                                  ;		add	di,si ; ** ; 12/12/2018
 11261                                  ;		;mov	cx,6
 11262                                  ;		mov	cl,6
 11263                                  ;		rep	stosw
 11264                                  
 11265                                  		; 23/11/2018
 11266 00001C8C 31C0                    		xor	ax,ax
 11267 00001C8E BF[38C4]                		mov	di,part_table_vol_label ; *
 11268 00001C91 01F7                    		add	di,si ; ** ; 12/12/2018
 11269                                  			; clear 12+9 bytes vol_label & system fields
 11270                                  		;mov	cl,10
 11271 00001C93 B90A00                  		mov	cx,10 ; 17/12/2018 (ch>0)
 11272 00001C96 F3AB                    		rep	stosw ; clear 20 bytes
 11273 00001C98 AA                      		stosb	      ; and then clear +1 byte (total 21 bytes) 		
 11274                                  gv_3:
 11275                                  ;		;mov	al,[j_disk]
 11276                                  ;		;;sub	ah,ah
 11277                                  ;		;;shl	ax,1
 11278                                  ;		;;shl	ax,1
 11279                                  ;		;shl	al,1
 11280                                  ;		;shl	al,1
 11281                                  ;		;;add	ax,[i_partition]
 11282                                  ;		;add	al,[i_partition]
 11283                                  ;		;;;mov	cl,46
 11284                                  ;		;mul	cx
 11285                                  ;		;mov	si,ax ; ** ; 12/12/2018
 11286                                  ;		mov	bx,[_k_]
 11287                                  ;		mov	byte [part_table_system+bx+si],0
 11288                                  ;		inc	word [_k_]
 11289                                  ;		cmp	word [_k_],9
 11290                                  ;		jb	short gv_3
 11291                                  
 11292                                  ;		; 23/11/2018
 11293                                  ;		;xor	ax,ax
 11294                                  ;		;mov	di,part_table_system ; *
 11295                                  ;		;add	di,si ; ** ; 12/12/2018
 11296                                  ;		  ; part_table_system is just after
 11297                                  ;		  ; part_table_volume_label
 11298                                  ;		  ; (di already points to part_table_system+si)	
 11299                                  ;		;mov	cx,9
 11300                                  ;		mov	cl,9
 11301                                  ;		rep	stosb
 11302                                  
 11303                                  	;get_volume_string(part_table[j][i].drive_letter,&volume_label[0])
 11304                                  
 11305 00001C99 8D46F2                  		lea	ax,[vol_label]
 11306 00001C9C 50                      		push	ax
 11307                                  
 11308                                  		;mov	al,[j_disk]
 11309                                  		;sub	ah,ah
 11310                                  		;shl	ax,1
 11311                                  		;shl	ax,1
 11312                                  		;add	ax,[i_partition]
 11313                                  		;mov	cx,46
 11314                                  		;mul	cx
 11315                                  		;mov	bx,ax
 11316                                  		;mov	si,ax ; ** ; 12/12/2018
 11317                                  
 11318                                  		;mov	al,[part_table_drive_letter+bx]
 11319 00001C9D 8A84[4DC4]              		mov	al,[part_table_drive_letter+si]
 11320 00001CA1 50                      		push	ax
 11321 00001CA2 E8B800                  		call	get_volume_string
 11322                                  		;pop	bx ; 05/01/2019
 11323                                  		;pop	bx
 11324                                  
 11325                                  		;;mov	word [_k_],0
 11326                                  		;mov	byte [_k_],0
 11327                                  		;jmp	short gv_5
 11328                                  ;gv_4:
 11329                                  		;mov	si,[_k_]
 11330                                  		;mov	al,[vol_label+si]
 11331                                  		;mov	cx,ax
 11332                                  		;mov	al,[j_disk]
 11333                                  		;sub	ah,ah
 11334                                  		;shl	ax,1
 11335                                  		;shl	ax,1
 11336                                  		;add	ax,[i_partition]
 11337                                  		;mov	bx,46
 11338                                  		;mul	bx
 11339                                  		;mov	bx,ax
 11340                                  		;mov	[part_table_vol_label+bx+si],cl
 11341                                  		;inc	word [_k_]
 11342                                  ;gv_5:
 11343                                  		;lea	ax,[vol_label]
 11344                                  		;push	ax
 11345                                  		;call	strlen
 11346                                  		;pop	bx
 11347                                  		;cmp	ax,[_k_]
 11348                                  		;ja	short gv_4
 11349                                  
 11350                                  		; 23/11/2018
 11351                                  		; Copy/Move volume name to partition data field
 11352 00001CA5 89F7                    		mov	di,si ; ** ; 12/12/2018
 11353 00001CA7 81C7[38C4]              		add	di,part_table_vol_label
 11354 00001CAB 56                      		push	si ; ** ; 12/12/2018
 11355 00001CAC 8D76F2                  		lea	si,[vol_label]
 11356                                  		;call	strlen
 11357                                  		; cx = string length (except terminating zero)
 11358                                  		;jcxz	gv_5
 11359                                  		;;cmp	cx,12
 11360                                  		;;ja	short gv_4
 11361                                  		;mov	cx,12
 11362                                  ;gv_4:
 11363                                  		;rep	movsb
 11364                                  ;gv_5:
 11365                                  		; 05/01/2019
 11366 00001CAF B10C                    		mov	cl,12
 11367                                  gv_4:
 11368 00001CB1 AC                      		lodsb
 11369 00001CB2 20C0                    		and	al,al
 11370 00001CB4 7403                    		jz	short gv_5
 11371 00001CB6 AA                      		stosb
 11372                                  		;jmp	short gv_4
 11373 00001CB7 E2F8                    		loop	gv_4
 11374                                  gv_5:
 11375                                  		;mov	al,[j_disk]
 11376                                  		;sub	ah,ah
 11377                                  		;shl	ax,1
 11378                                  		;shl	ax,1
 11379                                  		;add	ax,[i_partition]
 11380                                  		;mov	cx,46
 11381                                  		;mul	cx
 11382                                  		;mov	bx,ax
 11383                                  		;;pop	dx ; **
 11384                                  		;;pop	bx,dx ; **
 11385                                  
 11386 00001CB9 5F                      		pop	di ; ** ; 12/12/2018
 11387                                  
 11388                                  		;mov	bx,di ; **
 11389                                  		;mov	al,[part_table_drive_letter+bx]
 11390 00001CBA 8A85[4DC4]              		mov	al,[part_table_drive_letter+di] ; 12/12/2018
 11391                                  		;push	ax
 11392 00001CBE E8E700                  		call	get_fs_and_vol
 11393                                  		;pop	bx
 11394                                  		;or	al,al
 11395                                  		;jz	short gv_8
 11396 00001CC1 721F                    		jc	short gv_8 ; 24/11/2018
 11397                                  
 11398                                  		;mov	word [_k_],0
 11399 00001CC3 31DB                    		xor	bx,bx ; *****
 11400                                  gv_6:
 11401                                  		;mov	bx,[_k_] ; *****
 11402 00001CC5 80BF[8AA0]20            		cmp	byte [dx_buff_file_system+bx],' '
 11403 00001CCA 7403                    		je	short gv_7
 11404                                  		;lea	ax,[bx+1]
 11405                                  		;mov	[_length_],ax
 11406 00001CCC 8D4F01                  		lea	cx,[bx+1] ; *****
 11407                                  gv_7:
 11408                                  		;inc	word [_k_]
 11409                                  		;inc	byte [_k_]
 11410 00001CCF FEC3                    		inc	bl ; *****
 11411                                  		;cmp	word [_k_],8
 11412                                  		;cmp	byte [_k_],8
 11413 00001CD1 80FB08                  		cmp	bl,8 ; *****
 11414 00001CD4 72EF                    		jb	short gv_6
 11415                                  
 11416                                  ;		push	word [_length_] ; n
 11417                                  ;		mov	ax,dx_buff_file_system
 11418                                  ;		push	ax  		; src	
 11419                                  ;
 11420                                  ;		mov	al,[j_disk]
 11421                                  ;		;sub	ah,ah
 11422                                  ;		;shl	ax,1
 11423                                  ;		;shl	ax,1
 11424                                  ;		;add	ax,[i_partition]
 11425                                  ;		shl	al,1
 11426                                  ;		shl	al,1
 11427                                  ;		add	al,[i_partition]
 11428                                  ;		
 11429                                  ;		;mov	cx,46
 11430                                  ;		;mul	cx
 11431                                  ;		mov	cl,46
 11432                                  ;		mul	cl
 11433                                  ;
 11434                                  ;		mov	dx,ax ; ***	
 11435                                  ;
 11436                                  ;		add	ax,part_table_system
 11437                                  ;		push	ax		 ; dest
 11438                                  ;
 11439                                  ;		call	strncpy  ; strncpy (dest,src,n)
 11440                                  ;		add	sp,6
 11441                                  ;		jmp	short gv_13
 11442                                  
 11443                                  		; 23/11/2018
 11444                                  ;		mov	ah,46
 11445                                  ;		mul	ah
 11446                                  ;		;mov	dx,ax ; **
 11447                                  		
 11448                                  		;mov	cx,[_length_] ; *****
 11449                                  		;jcxz	short gv_8
 11450                                  
 11451 00001CD6 BE[8AA0]                		mov	si,dx_buff_file_system
 11452                                  		;mov	di,ax
 11453                                  		; 12/12/2018
 11454                                  		;mov	di,dx ; **
 11455                                  		; DI = Partition data/structure offset
 11456 00001CD9 81C7[44C4]              		add	di,part_table_system
 11457 00001CDD E84100                  		call	strncpy
 11458                                  			; cx = 0
 11459 00001CE0 EB2E                    		jmp	short gv_13
 11460                                  gv_8:
 11461                                  		;mov	al,[j_disk]
 11462                                  		;sub	ah,ah
 11463                                  		;;shl	ax,1
 11464                                  		;;shl	ax,1
 11465                                  		;;add	ax,[i_partition]
 11466                                  		;shl	al,1
 11467                                  		;shl	al,1
 11468                                  		;add	al,[i_partition]
 11469                                  		
 11470                                  		;;mov	cx,46
 11471                                  		;;mul	cx
 11472                                  		;mov	cl,46
 11473                                  		;mul	cl
 11474                                  		;mov	bx,ax
 11475                                  
 11476                                  		; 12/12/2018
 11477                                  		;mov	bx,dx; **
 11478                                  	
 11479                                  		; DI = Partition data/structure offset ; **
 11480                                  		
 11481 00001CE2 B8[755F]                		mov	ax,FAT16 ; "FAT16   " ; !*!
 11482                                  
 11483                                  		;cmp	word [part_table_num_sec_hw+bx],0
 11484 00001CE5 83BD[30C4]00            		cmp	word [part_table_num_sec_hw+di],0
 11485                                  		;jne	short gv_9
 11486 00001CEA 770B                    		ja	short gv_9
 11487                                  		;cmp	word [part_table_num_sec_lw+bx],32680
 11488 00001CEC 81BD[2EC4]A87F          		cmp	word [part_table_num_sec_lw+di],32680
 11489                                  		;jbe	short gv_10
 11490 00001CF2 7703                    		ja	short gv_9 ; !*!
 11491 00001CF4 B8[7E5F]                		mov	ax,FAT12 ; "FAT12   " ; !*!
 11492                                  gv_9:
 11493                                  		;;mov	ax,FAT16 ; "FAT16   " ; !*!
 11494                                  		;push	ax
 11495                                  		;add	bx,part_table_system
 11496                                  		;push	bx
 11497                                  
 11498                                  		; 12/12/2018
 11499 00001CF7 89C6                    		mov	si,ax	; strcpy, source
 11500                                  		;mov	di,bx	; strcpy, destination	
 11501 00001CF9 81C7[44C4]              		add	di,part_table_system
 11502                                  
 11503 00001CFD EB0E                    		jmp	short gv_12
 11504                                  gv_10:
 11505                                  		;mov	ax,FAT12 ; "FAT12   "
 11506                                  		;push	ax
 11507                                  		;mov	al,[j_disk]
 11508                                  		;sub	ah,ah
 11509                                  		;shl	ax,1
 11510                                  		;shl	ax,1
 11511                                  		;add	ax,[i_partition]
 11512                                  		;mul	cx
 11513                                  		;add	ax,part_table_system
 11514                                  		;push	ax
 11515                                  		;jmp	short gv_12
 11516                                  gv_11:
 11517 00001CFF 56                      		push	si ; ** ; 12/12/2018
 11518                                  
 11519                                  		;mov	ax,NOVOLUME
 11520                                  		;push	ax
 11521                                  			
 11522                                  		; 05/01/2019			
 11523                                  		;mov	si,NOVOLUME ; ****
 11524                                  
 11525                                  ;		mov	al,[j_disk]
 11526                                  ;		;sub	ah,ah
 11527                                  ;		;shl	ax,1
 11528                                  ;		;shl	ax,1
 11529                                  ;		;add	ax,[i_partition]
 11530                                  ;		shl	al,1
 11531                                  ;		shl	al,1
 11532                                  ;		add	al,[i_partition]
 11533                                  ;		
 11534                                  ;		;mov	cx,46
 11535                                  ;		;mul	cx
 11536                                  ;		mov	cl,46
 11537                                  ;		mul	cl
 11538                                  ;
 11539                                  ;		;;mov	cx,ax
 11540                                  ;		;mov	si,ax
 11541                                  ;		;add	ax,part_table_vol_label
 11542                                  ;		;push	ax
 11543                                  ;		;;mov	si,cx
 11544                                  ;		;call	strcpy
 11545                                  ;		;pop	bx
 11546                                  ;		;pop	bx
 11547                                  ;	
 11548                                  ;		;mov	dx,ax ; **
 11549                                  		
 11550                                  		;mov	di,dx ; ** ; ****
 11551                                  		
 11552 00001D00 5F                      		pop	di ; ** ; 12/12/2018
 11553                                  
 11554                                  		; 05/01/2019
 11555                                  		;add	di,part_table_vol_label
 11556                                  		
 11557                                  		; 05/01/2019
 11558                                  		;call	strcpy 
 11559                                  
 11560 00001D01 C685[38C4]00            		mov	byte [di+part_table_vol_label],0 ; NOVOLUME
 11561                                  	
 11562                                  		;mov	ax,UNKNOWN ; "UNKNOWN "
 11563                                  		;push	ax
 11564                                  
 11565 00001D06 BE[885F]                		mov	si,UNKNOWN ; ****	
 11566                                  		
 11567                                  		;add	si,part_table_system
 11568                                  		;push	si
 11569                                  		
 11570                                  		;mov	di,dx ; ** ; ****
 11571 00001D09 81C7[44C4]              		add	di,part_table_system ; 05/01/2019
 11572                                  gv_12:
 11573 00001D0D E81D00                  		call	strcpy
 11574                                  		;pop	bx
 11575                                  		;pop	bx
 11576                                  gv_13:
 11577                                  		;pop	di ; *
 11578                                  		;pop	si
 11579 00001D10 89EC                    		mov	sp,bp
 11580 00001D12 5D                      		pop	bp
 11581 00001D13 C3                      		retn
 11582                                  
 11583                                  ; strlen (Microsoft C 6.0 runtime library, MSDOS 6.0, 1991)	
 11584                                  ; ============================================================================
 11585                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 23/11/2018)
 11586                                  
 11587                                  ; Get (ASCIIZ) string length (except terminating null/zero character)
 11588                                  
 11589                                  ;strlen
 11590                                  ;------
 11591                                  ;size_t strlen ( const char * str );
 11592                                  ;Get string length
 11593                                  ;Returns the length of the C string str.
 11594                                  
 11595                                  ;The length of a C string is determined by the terminating null-character: 
 11596                                  ;A C string is as long as the number of characters between the beginning 
 11597                                  ;of the string and the terminating null character 
 11598                                  ;(without including the terminating null character itself).
 11599                                   
 11600                                  strlen:	
 11601                                  		;push	bp
 11602                                  		;mov	bp,sp
 11603                                  		;mov	dx,di
 11604                                  		;mov	ax,ds
 11605                                  		;mov	es,ax
 11606                                  		;mov	di,[bp+4] ; String address
 11607                                  		; 23/11/2018	
 11608 00001D14 89F7                    		mov	di,si ; String address
 11609                                  		;xor	ax,ax
 11610 00001D16 30C0                    		xor	al,al
 11611 00001D18 B9FFFF                  		mov	cx,65535 ; 0FFFFh
 11612 00001D1B F2AE                    		repne scasb
 11613 00001D1D F7D1                    		not	cx
 11614 00001D1F 49                      		dec	cx ; except terminating null character
 11615                                  		;xchg	ax,cx
 11616                                  		;mov	di,dx
 11617                                  		;pop	bp
 11618                                  		; cx = string length
 11619 00001D20 C3                      		retn
 11620                                  
 11621                                  ; strncpy (Microsoft C 6.0 runtime library, MSDOS 6.0, 1991)	
 11622                                  ; ============================================================================
 11623                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 23/11/2018)
 11624                                  
 11625                                  ; char *strncpy(char *dest, const char *src, size_t n)
 11626                                  
 11627                                  ;strncpy
 11628                                  ;-------
 11629                                  ;char * strncpy ( char * destination, const char * source, size_t num );
 11630                                  ;Copy characters from string
 11631                                  ;Copies the first num characters of source to destination. 
 11632                                  ;If the end of the source C string (which is signaled by a null-character)
 11633                                  ;is found before num characters have been copied, destination is padded with zeros
 11634                                  ;until a total of num characters have been written to it.
 11635                                  ;
 11636                                  ;No null-character is implicitly appended at the end of destination if 
 11637                                  ;source is longer than num. Thus, in this case, 
 11638                                  ;destination shall not be considered a null terminated C string
 11639                                  ;(reading it as such would overflow).
 11640                                  ;destination and source shall not overlap 
 11641                                  ;(see memmove for a safer alternative when overlapping).
 11642                                  
 11643                                  strncpy:
 11644                                  	;%define _dest_	bp+4 ; word ; destination address pointer
 11645                                  	;%define _src	bp+6 ; word ; source address pointer 	
 11646                                  	;%define _n_	bp+8 ; word ; length (n characters/bytes)
 11647                                  
 11648                                  		;push	bp
 11649                                  		;mov	bp,sp
 11650                                  		;;push	di
 11651                                  		;;;push	si
 11652                                  		;;push	ds
 11653                                  		;;pop	es
 11654                                  		;mov	di,[_dest_]
 11655                                  		;mov	si,[_src_]
 11656                                  		;mov	bx,di
 11657                                  		;mov	cx,[_n_]
 11658                                  		;jcxz	short strncpy_2
 11659                                  strncpy_0:
 11660 00001D21 AC                      		lodsb
 11661 00001D22 08C0                    		or	al,al
 11662 00001D24 7404                    		jz	short strncpy_1
 11663 00001D26 AA                      		stosb
 11664 00001D27 E2F8                    		loop	strncpy_0
 11665 00001D29 C3                      		retn ; 11/12/2018
 11666                                  ;strncpy_1:
 11667                                  		;xor	al,al
 11668                                  strncpy_1: ; 23/11/2018
 11669 00001D2A F3AA                    		rep	stosb
 11670                                  strncpy_2:
 11671                                  		;mov	ax,bx
 11672                                  		;pop	si
 11673                                  		;pop	di
 11674                                  		;mov	sp,bp
 11675                                  		;pop	bp
 11676 00001D2C C3                      		retn
 11677                                  
 11678                                  ; strcpy (Microsoft C 6.0 runtime library, MSDOS 6.0, 1991)	
 11679                                  ; ============================================================================
 11680                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 23/11/2018)
 11681                                  
 11682                                  ;strcpy
 11683                                  ;------
 11684                                  ;char * strcpy ( char * destination, const char * source );
 11685                                  ;Copy string
 11686                                  ;Copies the C string pointed by source into the array pointed by destination, 
 11687                                  ; including the terminating null character (and stopping at that point).
 11688                                  ;
 11689                                  ;To avoid overflows, the size of the array pointed by destination shall be 
 11690                                  ;long enough to contain the same C string as source 
 11691                                  ;(including the terminating null character), and should not overlap
 11692                                  ;in memory with source.
 11693                                  
 11694                                  strcpy:
 11695                                  	;%define _destination_ bp+4 ; word
 11696                                  	;%define _source_      bp+6 ; word
 11697                                  
 11698                                  		;push	bp
 11699                                  		;mov	bp,sp
 11700                                  		;mov	dx,di
 11701                                  		;mov	bx,si
 11702                                  		;mov	si,[_source_]
 11703                                  		;mov	di,si
 11704                                  		;mov	ax,ds
 11705                                  		;mov	es,ax
 11706                                  		;xor	ax,ax
 11707                                  		;xor	al,al
 11708                                  		;mov	cx,65535 ; 0FFFFh
 11709                                  		;repne scasb
 11710                                  		;not	cx
 11711                                  		;mov	di,[_destination_]
 11712                                  		;mov	ax,di
 11713                                  		;test	al,1
 11714                                  		;jz	short strcpy_0
 11715                                  		;movsb
 11716                                  		;dec	cx
 11717                                  ;strcpy_0:
 11718                                  		;shr	cx,1
 11719                                  		;rep movsw
 11720                                  		;adc	cx,cx
 11721                                  		;rep movsb
 11722                                  		;mov	si,bx
 11723                                  		;mov	di,dx
 11724                                  		;pop	bp
 11725                                  		;retn
 11726                                  strcpy_1:
 11727                                  		; 23/11/2018
 11728 00001D2D AC                      		lodsb
 11729 00001D2E AA                      		stosb
 11730 00001D2F 20C0                    		and	al,al
 11731 00001D31 75FA                    		jnz	short strcpy_1
 11732                                  strcpy_2:
 11733 00001D33 C3                      		retn
 11734                                  
 11735                                  ; ----------------------------------------------------------------------------
 11736                                  ; convert.c (FDISK, MSDOS 6.0, 1991)	
 11737                                  ; ----------------------------------------------------------------------------
 11738                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 24/11/2018)
 11739                                  	
 11740                                  ;/*  */
 11741                                  ;/*******************************************************************************/
 11742                                  ;/*Routine name:  CHECK_FORMAT                                                  */
 11743                                  ;/*******************************************************************************/
 11744                                  ;/*                                                                             */
 11745                                  ;/*Description:   This routine will invoke INT21 44h (Block Generic IOCTL       */
 11746                                  ;/*               Subfunction) call to see if the drive has been previously     */
 11747                                  ;/*               formatted by using a undocumented call.                       */
 11748                                  ;/*                                                                             */
 11749                                  ;/*Called Procedures:                                                           */
 11750                                  ;/*                                                                             */
 11751                                  ;/*Change History: Created        2/07/88         DRM                           */
 11752                                  ;/*                                                                             */
 11753                                  ;/*Input: input_drive                                                           */
 11754                                  ;/*                                                                             */
 11755                                  ;/*Output: pointer to dx register                                               */
 11756                                  ;/*                                                                             */
 11757                                  ;/*******************************************************************************/
 11758                                  
 11759                                  ;FLAG check_format(input_drive)                                          /*AN002*/
 11760                                  ;
 11761                                  ;         char input_drive;                                              /*AN002*/
 11762                                  ;
 11763                                  ;BEGIN                                                                   /*AN002*/
 11764                                  ;
 11765                                  ;         char formatted;                                                /*AN002*/
 11766                                  ;
 11767                                  ;/*C32    if (input_drive <= 'Z') */                                     /*C30*/
 11768                                  ;         if ((input_drive >= 'C') && (input_drive <= 'Z'))              /*C32*/
 11769                                  ;         {                                                              /*C30*/
 11770                                  ;         /* Set up registers for Generic IOCTL INT21 (44h) check media */
 11771                                  ;         regs.x.ax = u(GENERIC_IOCTL);                                  /*AN002*/
 11772                                  ;         regs.h.bh = uc(ZERO);                                          /*AN002*/
 11773                                  ;         regs.h.bl = (((unsigned char)input_drive - 'A') + 1);          /*AN002*/
 11774                                  ;         regs.x.cx = u(SPECIAL_FUNCTION);                               /*AN002*/
 11775                                  ;         regs.x.dx = (unsigned)&disk_access;                            /*AN002*/
 11776                                  ;         segread(&segregs);                                             /*AN002*/
 11777                                  ;         intdosx(&regs,&regs,&segregs);                                 /*AN002*/
 11778                                  ;
 11779                                  ;         /* see if buffer returned good or not */
 11780                                  ;         if (disk_access.dac_access_flag == ZERO)                       /*AN002*/
 11781                                  ;            formatted = FALSE;                                          /*AN002*/
 11782                                  ;         else                                                           /*AN002*/
 11783                                  ;            formatted = TRUE;                                           /*AN002*/
 11784                                  ;         }                                                              /*C30*/
 11785                                  ;         else                                                           /*C30*/
 11786                                  ;            formatted = FALSE;                                          /*C30*/
 11787                                  ;
 11788                                  ;          return(formatted);                                            /*AN002*/
 11789                                  ;
 11790                                  ;END                                                                     /*AN002*/
 11791                                  
 11792                                  
 11793                                  ;INT 21H, Function 44H, Sub function 0DH 
 11794                                  ;I/O Ctrl --> generic I/O control for block devices
 11795                                  
 11796                                  ;Call with: 
 11797                                  ;	AH = 44H
 11798                                  ;	AL = 0DH
 11799                                  ;	BL = drive code (0 =default, 1=A,2=B, etc.)
 11800                                  ;	CH = category (major) code:
 11801                                  ;		08H = disk drive
 11802                                  ;		48H = FAT32 disk drive
 11803                                  ;	CL = function (minor) code:
 11804                                  ;		40H = Set Drive Parameters
 11805                                  ;		41H = Write Track
 11806                                  ;		42H = Format and Verify Track
 11807                                  ;		46H = Set Volume Serial Number	
 11808                                  ;		47H = Set Access Flag 
 11809                                  ;		60H = Get Device Parameters
 11810                                  ;		61H = Read Track
 11811                                  ;		62H = Verify track
 11812                                  ;		66H = Get Volume Serial Number
 11813                                  ;		67H = Get Access Flag
 11814                                  ;
 11815                                  ;	DS: DX = segment: offset of parameter block 
 11816                                  ;
 11817                                  ;Returns: 
 11818                                  ;	If function successful
 11819                                  ;	   Carry flag = clear
 11820                                  ;	   And if called with CL = 60H or 61H
 11821                                  ;	   DS: DX = segment: offset of parameter block
 11822                                  ;
 11823                                  ;	If function unsuccessful 
 11824                                  ;	   Carry flag = set
 11825                                  ;	   AX = error code
 11826                                  ;
 11827                                  ;Comments:
 11828                                  ;	This sub function provides a general-purpose mechanism for communication 
 11829                                  ;	between application programs and block-device drivers. Allows a program 
 11830                                  ;	to inspect or change device parameters for a logical drive and to read, 
 11831                                  ;	write, format, and verify disk tracks in a hardware-independent manner.
 11832                                  ;
 11833                                  ;Format of parameter block for functions 47h, 67h:
 11834                                  ;
 11835                                  ;Offset  Size    Description
 11836                                  ; 00h    BYTE    special-function field (must be zero)
 11837                                  ; 01h    BYTE    disk-access flag, nonzero if access allowed by driver
 11838                                  ;
 11839                                  ;Format of parameter block for functions 46h, 66h:
 11840                                  ;
 11841                                  ;Offset  Size    Description
 11842                                  ; 00h    WORD    (call) info level (should be 0000h)
 11843                                  ; 02h    DWORD   disk serial number (binary)
 11844                                  ; 06h  11 BYTEs   volume label or "NO NAME    "
 11845                                  ; 11h   8 BYTEs   filesystem type "FAT12   " or "FAT16   "
 11846                                  ;
 11847                                  ;(generally CL=66h only, but MS-DOS 5.0 will write the
 11848                                  ;given filesystem type to the disk)
 11849                                  
 11850                                  check_format:
 11851                                  ;	%define formatted   bp-2
 11852                                  ;	%define input_drive bp+4
 11853                                  ;
 11854                                  ;		push	bp
 11855                                  ;		mov	bp,sp
 11856                                  ;		sub	sp,2
 11857                                  ;		cmp	byte [input_drive],'C'
 11858                                  ;		jl	short chkf_1
 11859                                  ;		cmp	byte [input_drive],'Z'
 11860                                  ;		jg	byte short chkf_1
 11861                                  ;		mov	byte [dac_access_flag],0
 11862                                  ;		mov	word [regs_x_ax],440Dh
 11863                                  ;		mov	byte [regs_x_bx+1],0 ; bh
 11864                                  ;		mov	al,[input_drive]
 11865                                  ;		sub	al,40h
 11866                                  ;		mov	[regs_x_bx],al ; bl
 11867                                  ;		mov	word [regs_x_cx],867h
 11868                                  ;		mov	word [regs_x_dx],disk_access
 11869                                  ;		mov	ax,segregs ;segregs_es
 11870                                  ;		push	ax
 11871                                  ;		call	segread
 11872                                  ;		pop	bx
 11873                                  ;		mov	ax,segregs ;segregs_es
 11874                                  ;		push	ax
 11875                                  ;		mov	ax,regs	;regs_x_ax
 11876                                  ;		push	ax
 11877                                  ;		push	ax
 11878                                  ;		call	intdosx
 11879                                  ;		add	sp,6
 11880                                  ;		cmp	byte [dac_access_flag],0
 11881                                  ;		jz	short chkf_1
 11882                                  ;		mov	byte [formatted],1
 11883                                  ;		jmp	short chkf_2
 11884                                  ;chkf_1:
 11885                                  ;		mov	byte [formatted],0
 11886                                  ;chkf_2:
 11887                                  ;		mov	al,[formatted]
 11888                                  ;		mov	sp,bp
 11889                                  ;		pop	bp
 11890                                  ;		retn
 11891                                  
 11892                                  		; 24/11/2018
 11893                                  		;xor	bh,bh
 11894                                  		;mov	bl,al ; [input_drive]
 11895                                  		;xor	al,al
 11896                                  		; 17/12/2018
 11897 00001D34 30E4                    		xor	ah,ah
 11898 00001D36 89C3                    		mov	bx,ax ; al = [input_drive]
 11899 00001D38 30C0                    		xor	al,al
 11900 00001D3A A2[E1CC]                		mov	[dac_access_flag],al ; 0
 11901 00001D3D 80FB43                  		cmp	bl,'C'
 11902 00001D40 721A                    		jb	short chkf_2
 11903 00001D42 80FB5A                  		cmp	bl,'Z'
 11904 00001D45 7713                    		ja	short chkf_1
 11905 00001D47 80EB40                  		sub	bl,40h
 11906 00001D4A B96708                  		mov	cx,0867h
 11907 00001D4D 52                      		push	dx ; * DX is in use by the caller
 11908 00001D4E BA[E0CC]                		mov	dx,disk_access
 11909 00001D51 B80D44                  		mov	ax,440Dh
 11910 00001D54 CD21                    		int	21h
 11911 00001D56 5A                      		pop	dx ; * 
 11912 00001D57 A0[E1CC]                		mov	al,[dac_access_flag]
 11913                                  chkf_1:
 11914 00001D5A 3C01                    		cmp	al,1
 11915                                  			; cf = 1 -> not formatted (AL=0)
 11916                                  			; cf = 0 -> formatted (AL>0)
 11917                                  chkf_2:
 11918 00001D5C C3                      		retn
 11919                                  
 11920                                  ;/*  */
 11921                                  ;/*******************************************************************************/
 11922                                  ;/*Routine name:  GET_VOLUME_STRING                                             */
 11923                                  ;/*******************************************************************************/
 11924                                  ;/*                                                                             */
 11925                                  ;/*Description:   This routine will invoke INT21 4Eh (Find First Matching File) */
 11926                                  ;/*               and return the disk volume label.                             */
 11927                                  ;/*                                                                             */
 11928                                  ;/*Called Procedures:                                                           */
 11929                                  ;/*                                                                             */
 11930                                  ;/*Change History: Created        6/01/87         DRM                           */
 11931                                  ;/*                                                                             */
 11932                                  ;/*Input: input_drive                                                           */
 11933                                  ;/*                                                                             */
 11934                                  ;/*Output: volume_out                                                           */
 11935                                  ;/*                                                                             */
 11936                                  ;/*******************************************************************************/
 11937                                  
 11938                                  ;void get_volume_string(input_drive,vol_label_addr)                     /*AN000*/
 11939                                  ;        char input_drive;                                              /*AN000*/
 11940                                  ;        char *vol_label_addr;                                          /*AN000*/
 11941                                  ;BEGIN                                                                  /*AN000*/
 11942                                  ;
 11943                                  ;         char  first_string[13];                                       /*AC000*/
 11944                                  ;         char  find_first_buffer[50];                                  /*AN000*/
 11945                                  ;         unsigned i,j;                                                 /*AC000*/
 11946                                  ;
 11947                                  ;         /* clear out any garbage in volume label field */
 11948                                  ;         for (i = u(0); i < u(12); i++)                                /*AN015*/
 11949                                  ;             BEGIN                                                     /*AN015*/
 11950                                  ;                 vol_label_addr[i] = u(0);                             /*AN015*/
 11951                                  ;             END                                                       /*AN015*/
 11952                                  ;
 11953                                  ;         /* Point the DTA to our buffer so we can get the FindFirst output */
 11954                                  ;         regs.h.ah = uc(0x1A);                                         /*AN000*/
 11955                                  ;         regs.x.dx = (unsigned)&find_first_buffer[0];                  /*AN000*/
 11956                                  ;         segread(&segregs);
 11957                                  ;         intdosx(&regs,&regs,&segregs);                                /*AN000*/
 11958                                  ;
 11959                                  ;         /* Find the first volume id */
 11960                                  ;         first_string[0] = input_drive;       /* Find the vol label - AN000*/
 11961                                  ;         first_string[1] = (char) '\0';
 11962                                  ;         strcat(first_string,FILE_NAME);                               /*AN000*/
 11963                                  ;         regs.h.ah = uc(FIND_FIRST_MATCH);                             /*AN000*/
 11964                                  ;         regs.x.cx = u(VOL_LABEL);                                     /*AN000*/
 11965                                  ;         regs.x.dx = (unsigned)&first_string[0];                       /*AN000*/
 11966                                  ;         intdos(&regs,&regs);                                		/*AN000*/
 11967                                  ;
 11968                                  ;/* AC000 The following is modified to take care of "." in the middle of the */
 11969                                  ;/*name */
 11970                                  ;
 11971                                  ;         if ((regs.x.cflag & CARRY_FLAG) != CARRY_FLAG)                /*AN000*/
 11972                                  ;           BEGIN                                                       /*AN000*/
 11973                                  ;           for (i=j=u(0); i < strlen (&find_first_buffer[30]) ; i++)   /*AN000*/
 11974                                  ;               BEGIN                                                   /*AN000*/
 11975                                  ;               if (find_first_buffer[30+i] != PERIOD)                  /*AN003*/
 11976                                  ;                       vol_label_addr[i-j] = find_first_buffer[30+i];  /*AN000*/
 11977                                  ;               else                                                    /*AN000*/
 11978                                  ;                       j = u(1);                                       /*AN000*/
 11979                                  ;               END                                                     /*AN000*/
 11980                                  ;           END                                                         /*AN000*/
 11981                                  ;         return;                                                       /*AN000*/
 11982                                  ;END                                                                    /*AN000*/
 11983                                  
 11984                                  ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
 11985                                  
 11986                                  ; Attributes: bp-based frame
 11987                                  
 11988                                  get_volume_string:
 11989                                  
 11990                                  	;;%define first_string	  bp-68  ; char first_string[13];
 11991                                  	;%define first_string	  bp-70  ; 24/11/2018 (db 'C:\????????.???',0)
 11992                                  	;%define _jj_		  bp-54	 ; unsigned j;	
 11993                                  	;%define _ii_		  bp-52	 ; unsigned i;
 11994                                  	;%define find_first_buffer bp-50	 ; char find_first_buffer[50];
 11995                                  	;%define _input_drive_	  bp+4 ; char input_drive;
 11996                                  	;%define vol_label_addr	  bp+6 ; char *vol_label_addr;
 11997                                  
 11998                                  		; 17/12/2018
 11999                                  	%define first_string	  bp-60  ; (db 'C:\????????.???',0)
 12000                                  	%define find_first_buffer bp-44	 ; char find_first_buffer[44];
 12001                                  	%define _input_drive_	  bp+4 ; char input_drive;
 12002                                  	%define vol_label_addr	  bp+6 ; char *vol_label_addr;
 12003                                  
 12004 00001D5D 55                      		push	bp
 12005 00001D5E 89E5                    		mov	bp,sp
 12006                                  		;sub	sp,68
 12007                                  		;sub	sp,70	; 24/11/2018
 12008                                  
 12009 00001D60 83EC3C                  		sub	sp,60	; 17/12/2018
 12010                                  
 12011                                  		; 12/12/2018
 12012                                  		;push	di
 12013 00001D63 56                      		push	si ; * SI is in use by the caller
 12014                                  
 12015                                  		;/* clear out any garbage in volume label field */
 12016                                  		;mov	word [_ii_],0
 12017                                  gvs_1:
 12018                                  		;mov	bx,[_ii_]
 12019                                  		;mov	si,[vol_label_addr]
 12020                                  		;mov	byte [bx+si],0
 12021                                  		;inc	byte [_ii_]
 12022                                  		;cmp	byte [_ii_],12
 12023                                  		;jb	short gvs_1
 12024                                  
 12025 00001D64 8B7E06                  		mov	di,[vol_label_addr]
 12026                                  		; 05/01/2019
 12027 00001D67 B90600                  		mov	cx,6
 12028 00001D6A 31C0                    		xor	ax,ax
 12029 00001D6C F3AB                    		rep	stosw
 12030                                  
 12031                                  		;/* Point the DTA to our buffer 
 12032                                  		;   so we can get the FindFirst output */
 12033                                  
 12034                                  		;mov	byte [regs_x_ax+1],1Ah
 12035                                  		;lea	ax,[find_first_buffer]
 12036                                  		;mov	[regs_x_dx],ax
 12037                                  		;mov	ax,segregs ;segregs_es
 12038                                  		;push	ax
 12039                                  		;call	segread
 12040                                  		;pop	bx
 12041                                  		;mov	ax,segregs ;segregs_es
 12042                                  		;push	ax
 12043                                  		;mov	ax,regs	;regs_x_ax
 12044                                  		;push	ax
 12045                                  		;push	ax
 12046                                  		;call	intdosx
 12047                                  		;add	sp,6
 12048                                  
 12049 00001D6E B41A                    		mov	ah,1Ah  ; Set DTA address
 12050 00001D70 8D56D4                  		lea	dx,[find_first_buffer]
 12051 00001D73 CD21                    		int	21h		
 12052                                  
 12053                                  		;/* Find the first volume id */
 12054                                  
 12055 00001D75 8A4604                  		mov	al,[_input_drive_]
 12056                                  		;mov	[first_string],al
 12057                                  		;mov	byte [first_string+1],0
 12058                                  		
 12059                                  		;mov	ax,FILE_NAME ; ":\????????.???"
 12060                                  		;push	ax
 12061                                  		;lea	ax,[first_string]
 12062                                  		;push	ax
 12063                                  		;call	strcat
 12064                                  		;pop	bx
 12065                                  		;pop	bx
 12066                                  
 12067 00001D78 8D7EC4                  		lea	di,[first_string]
 12068 00001D7B AA                      		stosb    ; al = 'C' (or 'D' ...)
 12069                                  
 12070 00001D7C BE[8970]                		mov	si,FILE_NAME ; ":\????????.???"
 12071                                  ;starcat_loop:
 12072                                  		;lodsb
 12073                                  		;stosb
 12074                                  		;or	al,al
 12075                                  		;jnz	short starcat_loop
 12076                                  
 12077                                  		;mov	cx,15 ; db ':\????????.???',0
 12078 00001D7F B10F                    		mov	cl,15
 12079 00001D81 F3A4                    		rep	movsb			
 12080                                  			; [first_string] = 'C:\????????.???',0
 12081                                  
 12082                                  		; Find First Matching File
 12083                                  		; (Find Volume Name)
 12084                                  
 12085                                  		;mov	byte [regs_x_ax+1],4Eh
 12086                                  		;mov	word [regs_x_cx],8
 12087                                  		;lea	ax,[first_string]
 12088                                  		;mov	[regs_x_dx],ax
 12089                                  		;mov	ax,regs_x_ax
 12090                                  		;push	ax
 12091                                  		;push	ax
 12092                                  		;call	intdos
 12093                                  		;pop	bx
 12094                                  		;pop	bx
 12095                                  		;mov	al,[regs_x_cflag]
 12096                                  		;and	al,1
 12097                                  		;cmp	al,1
 12098                                  		;je	short gvs_5
 12099                                  
 12100 00001D83 B44E                    		mov	ah,4Eh  ; Find First File
 12101                                  		;mov	cx,8 ; attribute (volume name)
 12102 00001D85 B108                    		mov	cl,8
 12103 00001D87 8D56C4                  		lea	dx,[first_string]  ; ASCIIZ file name address
 12104 00001D8A CD21                    		int	21h
 12105 00001D8C 7213                    		jc	short gvs_5
 12106                                  		
 12107                                  		; take care of "." in the middle of the name */
 12108                                  
 12109                                  		;sub	ax,ax
 12110                                  		;mov	[_jj_],ax
 12111                                  		;;mov	[_ii_],ax
 12112                                  		;mov	[_ii_],al
 12113                                  
 12114                                  		; 24/11/2018
 12115                                  		;lea	ax,[find_first_buffer+30]
 12116                                  		;push	ax
 12117                                  		;call	strlen
 12118                                  		;pop	bx
 12119                                  
 12120 00001D8E 8D76F2                  		lea	si,[find_first_buffer+30]
 12121 00001D91 E880FF                  		call	strlen	; /**/
 12122                                  			; CX = string length (except terminating null)
 12123                                  		; 17/12/2018 (lodsb,stosb,loop)
 12124                                  		;xor	si,si ; mov word [_ii_],0
 12125                                  		;xor	dx,dx ; mov word [_jj_],0
 12126 00001D94 8B7E06                  		mov	di,[vol_label_addr]
 12127                                   		;jmp	short gvs_4
 12128 00001D97 EB00                    		jmp	short gvs_3 
 12129                                  gvs_2:
 12130                                  		;mov	byte [_jj_],1
 12131                                  		;mov	dl,1	 ; 17/12/2018
 12132                                  ;gvs_3:
 12133                                  		;inc	byte [_ii_]
 12134                                  		;inc	si ; 17/12/2018
 12135                                  ;gvs_4:
 12136                                  		;lea	ax,[find_first_buffer+30]
 12137                                  		;push	ax
 12138                                  		;call	strlen
 12139                                  		;pop	bx
 12140                                  		
 12141                                  		;cmp	ax,[_ii_]
 12142                                  		;cmp	al,[_ii_]
 12143                                  		;cmp	cx,[_ii_] ; /**/
 12144                                  
 12145                                  		;cmp	cx,si
 12146                                  		;jbe	short gvs_5  ; jna
 12147                                  
 12148                                  		; 17/12/2018
 12149                                  		;cmp	si,cx
 12150                                  		;jnb	short gvs_5 ; 12/12/2018
 12151                                  
 12152                                  		;mov	si,[_ii_]
 12153                                  		;cmp	byte [si+find_first_buffer+30],'.'
 12154                                  		;je	short gvs_2
 12155                                  		;mov	al,[si+find_first_buffer+30]
 12156                                  gvs_3:		
 12157                                  		; 17/12/2018
 12158 00001D99 AC                      		lodsb
 12159 00001D9A 3C2E                    		cmp	al,'.'
 12160 00001D9C 7401                    		je	short gvs_4
 12161                                  		
 12162                                  		;mov	bx,si
 12163                                  		;sub	bx,[_jj_]
 12164                                  		;sub	bx,dx
 12165                                  		;mov	si,[vol_label_addr]
 12166                                  		;mov	[bx+si],al
 12167                                  		;add	bx,di
 12168                                  		;mov	[bx],al
 12169                                  
 12170                                  		; 05/01/2019
 12171 00001D9E AA                      		stosb
 12172                                  gvs_4:	
 12173 00001D9F E2F8                    		loop	gvs_3 ; 17/12/2018
 12174                                  gvs_5:
 12175 00001DA1 5E                      		pop	si ; * ; 12/12/2018
 12176                                  		;pop	di
 12177 00001DA2 89EC                    		mov	sp,bp
 12178 00001DA4 5D                      		pop	bp
 12179 00001DA5 C20400                  		retn	4 ; 05/01/2019
 12180                                  
 12181                                  ;/*  */
 12182                                  ;/*******************************************************************************/
 12183                                  ;/*Routine name:  GET_FS_AND_VOL                                                */
 12184                                  ;/*******************************************************************************/
 12185                                  ;/*                                                                             */
 12186                                  ;/*Description:   This routine will invoke INT21 44h (Block Generic IOCTL       */
 12187                                  ;/*               Subfunction) call to get volume label and file system type.   */
 12188                                  ;/*                                                                             */
 12189                                  ;/*Called Procedures:                                                           */
 12190                                  ;/*                                                                             */
 12191                                  ;/*Change History: Created        6/01/87         DRM                           */
 12192                                  ;/*                                                                             */
 12193                                  ;/*Input: input_drive                                                           */
 12194                                  ;/*                                                                             */
 12195                                  ;/*Output: pointer to dx register                                               */
 12196                                  ;/*                                                                             */
 12197                                  ;/*******************************************************************************/
 12198                                  ;
 12199                                  ;FLAG get_fs_and_vol(input_drive)                                        /*AN000*/
 12200                                  ;
 12201                                  ;         char input_drive;                                              /*AN000*/
 12202                                  ;
 12203                                  ;BEGIN                                                                   /*AN000*/
 12204                                  ;
 12205                                  ;         char output;
 12206                                  ;
 12207                                  ;         /* Set up registers for Generic IOCTL INT21 (44h) get media ID */
 12208                                  ;         regs.x.ax = u(GENERIC_IOCTL);                                  /*AN000*/
 12209                                  ;         regs.h.bh = uc(ZERO);                                          /*AN000*/
 12210                                  ;         regs.h.bl = (((unsigned char)input_drive - 'A') + 1);          /*AN000*/
 12211                                  ;         regs.x.cx = u(GET_MEDIA_ID);                                   /*AN000*/
 12212                                  ;         regs.x.dx = (unsigned)&dx_buff;                                /*AN000*/
 12213                                  ;         segread(&segregs);
 12214                                  ;         intdosx(&regs,&regs,&segregs);                                 /*AN000*/
 12215                                  ;
 12216                                  ;         /* see if carry flag was zero or one */
 12217                                  ;         if ((regs.x.cflag & CARRY_FLAG) == CARRY_FLAG)                 /*AN000*/
 12218                                  ;            output = FALSE;                                             /*AN000*/
 12219                                  ;         else                                                           /*AN000*/
 12220                                  ;            output = TRUE;                                              /*AN000*/
 12221                                  ;
 12222                                  ;         return(output);                                                /*AN000*/
 12223                                  ;                                                                        /*AN000*/
 12224                                  ;END
 12225                                  
 12226                                  get_fs_and_vol:
 12227                                  	;%define _output_     bp-2  ; char
 12228                                  	;%define _inputdrive_ bp+4  ; char
 12229                                  
 12230                                  		;push	bp
 12231                                  		;mov	bp,sp
 12232                                  		;;sub	sp,2
 12233                                  		;xor	bx,bx	; mov word [_output_],0
 12234                                  		;push	bx
 12235                                  		
 12236                                  		;push	dx ; 12/12/2018	
 12237                                  
 12238 00001DA8 88C3                    		mov	bl,al ; 05/01/2019
 12239                                  
 12240                                  		;mov	[regs_x_ax],440Dh
 12241 00001DAA B80D44                  		mov	ax,440Dh ; IOCTL - Generic Block Device Request
 12242                                  
 12243                                  		;mov	byte [regs_x_bx+1],0 ; bh
 12244                                  
 12245                                  		;mov	al,[_inputdrive_] ; [bp+4]
 12246                                  		;sub	al,40h
 12247                                  		;mov	[regs_x_bx],al ; bl
 12248                                  
 12249                                  		;xor	bh,bh
 12250                                  		;mov	bl,[_inputdrive_] ; [bp+4]
 12251                                  
 12252 00001DAD 80EB40                  		sub	bl,40h ; drive number (0 = default, 1 = 'A', 3 = 'C' ..)
 12253                                  		
 12254                                  		;mov	word [regs_x_cx],866h
 12255                                  		;mov	word [regs_x_dx],dx_buff
 12256                                  		
 12257                                  		;mov	ax,segregs ; segregs_es
 12258                                  		;push	ax
 12259                                  		;call	segread
 12260                                  		;pop	bx
 12261                                  		;mov	ax,segregs ; segregs_es
 12262                                  		;push	ax
 12263                                  		;mov	ax,regs ; regs_x_ax
 12264                                  		;push	ax
 12265                                  		;push	ax
 12266                                  		;call	intdosx
 12267                                  		;add	sp,6
 12268                                  
 12269 00001DB0 B96608                  		mov	cx,0866h   ; Get fs name and volume serial number
 12270 00001DB3 BA[79A0]                		mov	dx,dx_buff ; buffer
 12271 00001DB6 CD21                    		int	21h
 12272                                  
 12273                                  		;mov	al,[regs_x_cflag]
 12274                                  		;and	al,1
 12275                                  		;cmp	al,1
 12276                                  		;jne	short gfsv_1
 12277                                  		;mov	word [_output_],0 ; [bp-2]
 12278                                  
 12279 00001DB8 7304                    		jnc	short gfsv_1
 12280 00001DBA 29C0                    		sub	ax,ax		
 12281 00001DBC EB03                    		jmp	short gvsv_2
 12282                                  gfsv_1:
 12283                                  		;mov	byte [_output_],1
 12284 00001DBE B80100                  		mov	ax,1
 12285                                  gvsv_2:
 12286                                  		;mov	al,[_output_]
 12287                                  
 12288                                  		;pop 	dx ; 12/12/2018
 12289                                  
 12290 00001DC1 3C01                    		cmp	al,1 	
 12291                                  		;mov	sp,bp
 12292                                  		;pop	bp
 12293                                  			; CF = 1 -> Error
 12294                                  			; CF = 0 -> OK (fs name is in dx_buffer)
 12295 00001DC3 C3                      		retn
 12296                                  
 12297                                  ; strcat (Microsoft C 6.0 runtime library, MSDOS 6.0, 1991)	
 12298                                  ; ============================================================================
 12299                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 24/11/2018)
 12300                                  
 12301                                  ;strcat
 12302                                  ;------
 12303                                  ;char * strcat ( char * destination, const char * source );
 12304                                  ;Concatenate strings
 12305                                  ;Appends a copy of the source string to the destination string. 
 12306                                  ;The terminating null character in destination is overwritten by 
 12307                                  ;the first character of source, and a null-character is included at 
 12308                                  ;the end of the new string formed by the concatenation of both in destination.
 12309                                  ;
 12310                                  ;Destination and source shall not overlap.
 12311                                  
 12312                                  ;strcat:
 12313                                  ;	%define _destination_	bp+4
 12314                                  ;	%define _source_	bp+6
 12315                                  ;
 12316                                  ;		push	bp
 12317                                  ;		mov	bp,sp
 12318                                  ;		mov	dx,di
 12319                                  ;		mov	bx,si
 12320                                  ;		mov	ax,ds
 12321                                  ;		mov	es,ax
 12322                                  ;		mov	di,[_destination_]
 12323                                  ;		xor	ax,ax
 12324                                  ;		mov	cx,65535 ; 0FFFFh
 12325                                  ;		repne scasb
 12326                                  ;		lea	si,[di-1]
 12327                                  ;		mov	di,[_source_]
 12328                                  ;		mov	cx,65535 ; 0FFFFh
 12329                                  ;		repne scasb
 12330                                  ;		not	cx
 12331                                  ;		sub	di,cx
 12332                                  ;		xchg	di,si
 12333                                  ;		mov	ax,[_destination_]
 12334                                  ;		test	si,1
 12335                                  ;		jz	short strcat_0
 12336                                  ;		movsb
 12337                                  ;		dec	cx
 12338                                  ;strcat_0:
 12339                                  ;		shr	cx,1
 12340                                  ;		rep movsw
 12341                                  ;		adc	cx,cx
 12342                                  ;		rep movsb
 12343                                  ;		mov	si,bx
 12344                                  ;		mov	di,dx
 12345                                  ;		pop	bp
 12346                                  ;		retn
 12347                                  
 12348                                  ; ----------------------------------------------------------------------------
 12349                                  ; partinfo.c (FDISK, MSDOS 6.0, 1991)	
 12350                                  ; ----------------------------------------------------------------------------
 12351                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 24/11/2018)
 12352                                  
 12353                                  ;/*  */
 12354                                  ;char find_partition_type(type)
 12355                                  ;
 12356                                  ;unsigned char type;
 12357                                  ;
 12358                                  ;BEGIN
 12359                                  ; char  i;
 12360                                  ;
 12361                                  ;/*  Look at all four partition entries for system id byte that matches */
 12362                                  ; for (i = c(0); i < c(4);i++)                                   /*AC000*/
 12363                                  ;    BEGIN
 12364                                  ;
 12365                                  ;     /* if we find a match, do a TRUE return */
 12366                                  ;     if (part_table[cur_disk][i].sys_id == type)
 12367                                  ;        BEGIN
 12368                                  ;         return(TRUE);
 12369                                  ;         break;
 12370                                  ;        END
 12371                                  ;    END
 12372                                  ; /* Did not find one, return FALSE */
 12373                                  ; return(FALSE);
 12374                                  ;END
 12375                                  
 12376                                  find_partition_type:
 12377                                  		; 14/12/2018
 12378                                  		; INPUT:
 12379                                  		;   AL = Partition type (File system ID)
 12380                                  		;   [current_disk] = Current disk/drive number
 12381                                  
 12382                                  		; Modified registers: ax,bx,cx ; 24/01/2019
 12383                                  
 12384                                  		; 24/11/2018
 12385 00001DC4 31C9                    		xor	cx,cx
 12386 00001DC6 EB07                    		jmp	short fpt_2
 12387                                  fpt_1:
 12388 00001DC8 FEC1                    		inc	cl
 12389 00001DCA 80F904                  		cmp	cl,4
 12390 00001DCD 7318                    		jnb	short fpt_3
 12391                                  fpt_2:
 12392                                  		;xor	ah,ah
 12393 00001DCF 50                      		push	ax  ; al = Requested partition ID
 12394                                  
 12395 00001DD0 A0[E2CB]                		mov	al,[cur_disk] ; disk number (0 to 7)
 12396 00001DD3 D0E0                    		shl	al,1
 12397 00001DD5 D0E0                    		shl	al,1 ; 4 partition (table entries) per disk
 12398 00001DD7 00C8                    		add	al,cl ; Partition number (0 to 3)
 12399 00001DD9 B32E                    		mov	bl,46
 12400 00001DDB F6E3                    		mul	bl
 12401 00001DDD 89C3                    		mov	bx,ax
 12402                                  
 12403 00001DDF 58                      		pop	ax 
 12404                                  
 12405 00001DE0 3887[25C4]              		cmp	[part_table_sys_id+bx],al
 12406 00001DE4 75E2                    		jne	short fpt_1
 12407                                  
 12408                                  		;mov	al,1
 12409                                  			; cl < 4
 12410 00001DE6 C3                      		retn
 12411                                  fpt_3:
 12412                                  		;sub	al,al ; 0
 12413 00001DE7 F9                      		stc
 12414                                  			; cl = 4
 12415 00001DE8 C3                      		retn
 12416                                  
 12417                                  ; ----------------------------------------------------------------------------
 12418                                  
 12419                                  ;/*  */
 12420                                  ;char find_partition_location(type)
 12421                                  ;
 12422                                  ;unsigned char type;
 12423                                  ;
 12424                                  ;BEGIN
 12425                                  ; char  i;
 12426                                  ;
 12427                                  ;/*  Look at all four partition entries for system id byte that matches */
 12428                                  ; for (i = c(0); i < c(4);i++)                                   /*AC000*/
 12429                                  ;    BEGIN
 12430                                  ;
 12431                                  ;    /* if we find a match, do a TRUE return */
 12432                                  ;     if (part_table[cur_disk][i].sys_id == type)
 12433                                  ;        BEGIN
 12434                                  ;         return(i);
 12435                                  ;         break;
 12436                                  ;        END
 12437                                  ;    END
 12438                                  ; /* Did not find one, return */
 12439                                  ; return(c(NOT_FOUND));                                          /*AC000*/
 12440                                  ;END
 12441                                  
 12442                                  ;find_partition_location:
 12443                                  ;		; 24/11/2018
 12444                                  ;		xor	cx,cx
 12445                                  ;		jmp	short fpl_2
 12446                                  ;fpl_1:
 12447                                  ;		inc	cl
 12448                                  ;		cmp	cl,4
 12449                                  ;		jnb	short fpl_3
 12450                                  ;fpl_2:
 12451                                  ;		;xor	ah,ah
 12452                                  ;		push	ax  ; al = Requested partition ID
 12453                                  ;
 12454                                  ;		mov	al,[cur_disk] ; disk number (0 to 7)
 12455                                  ;		shl	al,1
 12456                                  ;		shl	al,1 ; 4 partition (table entries) per disk
 12457                                  ;		add	al,cl ; Partition number (0 to 3)
 12458                                  ;		mov	bl,46
 12459                                  ;		mul	bl
 12460                                  ;		mov	bx,ax
 12461                                  ;
 12462                                  ;		pop	ax 
 12463                                  ;
 12464                                  ;		cmp	[part_table_sys_id+bx],al
 12465                                  ;		jne	short fpl_1
 12466                                  ;
 12467                                  ;		mov	al,cl
 12468                                  ;		retn
 12469                                  ;fpl_3:
 12470                                  ;		mov	al,0FFh
 12471                                  ;		;stc
 12472                                  ;		retn
 12473                                  
 12474                                  ; 14/12/2018 
 12475                                  ; [ No need to find_partition_location for FDISK2.COM ..
 12476                                  ; .. because 'find_partition_type' returns with partition number in CL. ]
 12477                                  
 12478                                  ;find_partition_location:
 12479                                  		;call	find_partition_type
 12480                                  		;jc	short fpl_1
 12481                                  		;
 12482                                  		;mov	al,cl ; Partition number (0 to 3)
 12483                                  		;retn
 12484                                  ;fpl_1:
 12485                                  		;mov	al,0FFh
 12486                                  		;retn
 12487                                  
 12488                                  ; ----------------------------------------------------------------------------
 12489                                  ; fdisk.c (FDISK, MSDOS 6.0, 1991)	
 12490                                  ; ----------------------------------------------------------------------------
 12491                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 25/11/2018)		
 12492                                  		
 12493                                  ; 25/11/2018
 12494                                  
 12495                                  ;/*  */
 12496                                  ;void load_logical_drive(point,drive)
 12497                                  ;
 12498                                  ;char   point;
 12499                                  ;unsigned char   drive;
 12500                                  ;
 12501                                  ;BEGIN
 12502                                  ;
 12503                                  ;char        volume_label[13];                                           	/* AC000 */
 12504                                  ;unsigned    ext_part_num;                                               	/* AN000 */
 12505                                  ;unsigned    i;
 12506                                  ;/*C00 unsigned j; */                                                       	/* AN000 */
 12507                                  ;unsigned    k;                                                          	/* AN000 */
 12508                                  ;unsigned    length;                                                     	/* AN000 */
 12509                                  ;unsigned    index;
 12510                                  ;/*C00 unsigned dx_pointer; */                                               	/* AN000 */
 12511                                  ;unsigned    partition_location;                                         	/* AN000 */
 12512                                  ;
 12513                                  ;	/* Check to see if anything is there */
 12514                                  ;	if ((boot_record[510] == uc(0x55)) && (boot_record[511] == uc(0xAA)))	/* AC000 */
 12515                                  ;	    BEGIN
 12516                                  ;	    /* The boot record is there - read in the logical drive if it is there */
 12517                                  ;	    for (i = u(0); i < u(4); i++)                               /* AC000 */
 12518                                  ;		BEGIN
 12519                                  ;
 12520                                  ;		index = i*16;
 12521                                  ;		/* See if it is a defined extended drive*/
 12522                                  ;		if ((boot_record[0x1C2 + index] != uc(0)) && (boot_record[0x1C2 + index] != uc(EXTENDED))) 
 12523                                  ;		    BEGIN
 12524                                  ;		    /* Get boot ind */
 12525                                  ;		    ext_table[drive][point].boot_ind = boot_record[0x1BE + index];
 12526                                  ;
 12527                                  ;		    /* Start head */
 12528                                  ;		    ext_table[drive][point].start_head = boot_record[0x1BF + index];
 12529                                  ;
 12530                                  ;		    /* Start sector - unscramble it from INT 13 format*/
 12531                                  ;		    ext_table[drive][point].start_sector= (boot_record[0x1C0 + index] & 0x3F);
 12532                                  ;
 12533                                  ;		    /* Start cyl - unscramble it from INT 13 format*/
 12534                                  ;		    ext_table[drive][point].start_cyl= ((((unsigned)boot_record[0x1C0+index]) & 0x00C0) << 2)
 12535                                  ;						+ ((unsigned)boot_record[0x1C1+index]);
 12536                                  ;
 12537                                  ;		    /* System id */
 12538                                  ;		    ext_table[drive][point].sys_id = boot_record[0x1C2+index];
 12539                                  ;
 12540                                  ;		    /* End head */
 12541                                  ;		    ext_table[drive][point].end_head = boot_record[0x1C3+index];
 12542                                  ;
 12543                                  ;		    /* End sector - unscramble it from INT 13 format*/
 12544                                  ;		    ext_table[drive][point].end_sector= (boot_record[0x1C4+index] & 0x3F);
 12545                                  ;
 12546                                  ;		    /* End cyl - unscramble it from INT 13 format*/
 12547                                  ;		    ext_table[drive][point].end_cyl= ((((unsigned)boot_record[0x1C4+index]) & 0x00C0) << 2)
 12548                                  ;						+ ((unsigned)boot_record[0x1C5+index]);
 12549                                  ;
 12550                                  ;		    /* Relative sectors */
 12551                                  ;		    ext_table[drive][point].rel_sec =
 12552                                  ;			((unsigned long)boot_record[0x1C9+index]) << 24;
 12553                                  ;
 12554                                  ;		    ext_table[drive][point].rel_sec =
 12555                                  ;			ext_table[drive][point].rel_sec+(((unsigned long)boot_record[0x1C8+index]) << 16);
 12556                                  ;
 12557                                  ;		    ext_table[drive][point].rel_sec =
 12558                                  ;			ext_table[drive][point].rel_sec + (((unsigned long)boot_record[0x1C7+index]) << 8);
 12559                                  ;
 12560                                  ;		    ext_table[drive][point].rel_sec =
 12561                                  ;			ext_table[drive][point].rel_sec + ((unsigned long)boot_record[0x1C6+index]);
 12562                                  ;
 12563                                  ;		    /* Number of sectors */
 12564                                  ;		    ext_table[drive][point].num_sec =
 12565                                  ;			((unsigned long)boot_record[0x1CD+index]) << 24;
 12566                                  ;
 12567                                  ;		    ext_table[drive][point].num_sec =
 12568                                  ;			ext_table[drive][point].num_sec+(((unsigned long)boot_record[0x1CC+index]) << 16);
 12569                                  ;
 12570                                  ;		    ext_table[drive][point].num_sec =
 12571                                  ;			ext_table[drive][point].num_sec + (((unsigned long)boot_record[0x1CB+index]) << 8);
 12572                                  ;
 12573                                  ;		    ext_table[drive][point].num_sec =
 12574                                  ;			ext_table[drive][point].num_sec + ((unsigned long)boot_record[0x1CA+index]);
 12575                                  ;
 12576                                  ;		    ext_table[drive][point].mbytes_used =
 12577                                  ;			cylinders_to_mbytes(((ext_table[drive][point].end_cyl - ext_table[drive][point].start_cyl)+1),
 12578                                  ;					      cur_disk);                /* AN004 */
 12579                                  ;
 12580                                  ;		    ext_part_num = find_partition_location(uc(EXTENDED));
 12581                                  ;
 12582                                  ;		    ext_table[drive][point].percent_used =
 12583                                  ;			cylinders_to_percent(((ext_table[drive][point].end_cyl-ext_table[drive][point].start_cyl)+1),
 12584                                  ;			((part_table[drive][ext_part_num].end_cyl-part_table[drive][ext_part_num].start_cyl)+1));
 12585                                  ;
 12586                                  ;		    ext_table[drive][point].drive_letter = next_letter++;                   /* AN000 */
 12587                                  ;
 12588                                  ;		    partition_location = ext_table[drive][point].start_cyl;
 12589                                  ;
 12590                                  ;		    if (read_boot_record(ext_table[drive][point].start_cyl,
 12591                                  ;					 drive,
 12592                                  ;					 ext_table[drive][point].start_head,
 12593                                  ;					 ext_table[drive][point].start_sector));
 12594                                  ;			 BEGIN                                                             /* AN000 */
 12595                                  ;			 /* See if the disk has already been formated */
 12596                                  ;			 if (check_format(ext_table[drive][point].drive_letter) == TRUE )       /* AN002 */
 12597                                  ;			     BEGIN                                                         /* AN000 */
 12598                                  ;			     /* get volume and system info */
 12599                                  ;
 12600                                  ;			     /* AC000 Just for cleaning up purposes */
 12601                                  ;
 12602                                  ;			     for (k = u(0); k < u(12); k++)                                     /* AC000 */
 12603                                  ;				 BEGIN                                                          /* AC000 */
 12604                                  ;				     ext_table[drive][point].vol_label[k]=u(0);                 /* AC000 */
 12605                                  ;				 END                                                            /* AC000 */
 12606                                  ;
 12607                                  ;			     for (k = u(0); k < u(9); k++)                                      /* AC000 */
 12608                                  ;				 BEGIN                                                          /* AC000 */
 12609                                  ;				     ext_table[drive][point].system[k]=u(0);                    /* AC000 */
 12610                                  ;				 END                                                            /* AC000 */
 12611                                  ;
 12612                                  ;			     get_volume_string(ext_table[drive][point].drive_letter,&volume_label[0]);
 12613                                  ;
 12614                                  ;			      for (k = u(0); k < strlen(volume_label); k++)                     /* AC000 AC015 */
 12615                                  ;				   BEGIN                                                        /* AC000 AC015 */
 12616                                  ;				     ext_table[drive][point].vol_label[k]=volume_label[k];      /* AC000 AC015 */
 12617                                  ;				   END                                                          /* AC000 AC015 */
 12618                                  ;
 12619                                  ;			     /* Now try to get it using GET MEDIA ID function */
 12620                                  ;			     if (get_fs_and_vol(ext_table[drive][point].drive_letter))     /* AN000 */
 12621                                  ;
 12622                                  ;				BEGIN                                                      /* AN000 */
 12623                                  ;				/* AC000 Just use more conceptually simple logic */
 12624                                  ;				for (k=u(0); k < u(8); k++)                                     /* AC000 */
 12625                                  ;
 12626                                  ;				    BEGIN                                                       /* AC000 */
 12627                                  ;				      if (dx_buff.file_system[k] != ' ')                        /* AC000 */
 12628                                  ;						length = k+1;                                   /* AC000 */
 12629                                  ;				    END                                                         /* AC000 */
 12630                                  ;
 12631                                  ;				strncpy(ext_table[drive][point].system,&dx_buff.file_system[0],u(length));
 12632                                  ;				END                                                        /* AN000 */
 12633                                  ;
 12634                                  ;			      else                                                         /* AN000 */
 12635                                  ;
 12636                                  ;				BEGIN                                                      /* AN000 */
 12637                                  ;				if (ext_table[drive][point].num_sec > (unsigned long)FAT16_SIZE) /* AN000 */
 12638                                  ;				    strcpy(ext_table[drive][point].system,FAT16);          /* AN000 */
 12639                                  ;				else
 12640                                  ;				    strcpy(ext_table[drive][point].system,FAT12);          /* AN000 */
 12641                                  ;				END                                                        /* AN000 */
 12642                                  ;			     END                                                           /* AN000 */
 12643                                  ;			 else                                                              /* AN000 */
 12644                                  ;			     BEGIN                                                         /* AN000 */
 12645                                  ;			     /* set up array to say no file system or volume label */
 12646                                  ;			     strcpy(ext_table[drive][point].vol_label,NOVOLUME);           /* AN000 */
 12647                                  ;			     strcpy(ext_table[drive][point].system,NOFORMAT);              /* AN000 */
 12648                                  ;			     END                                                           /* AN000 */
 12649                                  ;
 12650                                  ;			 regs.x.dx = u(0);
 12651                                  ;			 regs.x.ax = NETWORK_IOCTL;
 12652                                  ;			 regs.h.bl = ((ext_table[drive][point].drive_letter - 'A') + 1);
 12653                                  ;			 intdos(&regs,&regs);
 12654                                  ;			 if (regs.x.dx & 0x1000) strcpy(ext_table[drive][point].vol_label,REMOTE);
 12655                                  ;			 END
 12656                                  ;		    read_boot_record(ext_table[drive][point].start_cyl,
 12657                                  ;				     drive,
 12658                                  ;				     uc(0),
 12659                                  ;				     uc(1));						/* AN000 */
 12660                                  ;		    END
 12661                                  ;		END
 12662                                  ;	    END
 12663                                  ;
 12664                                  ;	return;
 12665                                  ;
 12666                                  ;END
 12667                                  
 12668                                  load_logical_drive:
 12669                                  
 12670                                  	;;%define tempnumsec_lw bp-34
 12671                                  	;;%define tempnumsec_hw bp-32
 12672                                  	;;%define temprelsec_lw bp-30
 12673                                  	;;%define temprelsec_hw bp-28
 12674                                  	;;%define _int_k        bp-26
 12675                                  	;%define _int_i	        bp-24
 12676                                  	;;%define _int_index_   bp-22
 12677                                  	;%define _char_vol_label_ bp-20 ; char volume_label[13]
 12678                                  	;;%define ext_part_num  bp-6
 12679                                  	;;%define _int_length_  bp-4
 12680                                  	;;;%define _partition_location_ bp-2 ; not used!
 12681                                  	;%define _bx_	        bp-2 ; **
 12682                                  
 12683                                  	;%define _point_	bp+4
 12684                                  	%define numlogdrvs	bp+4  ; 14/12/2018
 12685                                  	%define _drive_		bp+6
 12686                                  
 12687                                  	%define _char_vol_label_ bp-18 ; char volume_label[13]
 12688                                  	%define _int_i	         bp-4
 12689                                  	%define _bx_	         bp-2 ; **
 12690                                  
 12691 00001DE9 55                      		push	bp
 12692 00001DEA 89E5                    		mov	bp,sp
 12693                                  		;sub	sp,34
 12694 00001DEC 83EC12                  		sub	sp,18 ; 26/11/2018
 12695                                  		
 12696                                  		; 15/12/2018
 12697                                  		;push	di
 12698                                  		;push	si
 12699                                  
 12700                                  		;cmp	byte [boot_record+1FEh],55h
 12701                                  		;jne	short lld_1
 12702                                  		;cmp	byte [boot_record+1FFh],0AAh
 12703                                  		;je	short lld_for1
 12704 00001DEF 813E[DECB]55AA          		cmp	word [boot_record+1FEh],0AA55h
 12705 00001DF5 7403                    		je	short lld_for1		
 12706                                  lld_1:
 12707 00001DF7 E9FC01                  		jmp	lld_17
 12708                                  lld_for1:
 12709                                  		;mov	word [_int_i],0
 12710                                  		; 15/12/2018
 12711                                  		;jmp	lld_for1_1
 12712 00001DFA 31DB                    		xor	bx,bx		
 12713 00001DFC 895EFC                  		mov	[_int_i],bx ; 0
 12714                                  		;jmp	lld_for1_next
 12715 00001DFF E9FB00                  		jmp	lld_for1_if
 12716                                  
 12717                                  lld_2:
 12718                                  		;;mov	al,[numlogdrvs]
 12719                                  		;;cbw
 12720                                  		;;mov	cx,ax
 12721                                  		;;mov	cl,al
 12722                                  		;mov	cl,[numlogdrvs] ; 14/12/2018
 12723                                  		;mov	al,24
 12724                                  		;mul	byte [_drive_] 
 12725                                  		;;add	ax,cx
 12726                                  		;add	al,cl
 12727                                  		;;mov	cx,46
 12728                                  		;;;imul	cx
 12729                                  		;;mul	cx
 12730                                  		;mov	cx,46
 12731                                  		;mul	cl
 12732                                  		;mov	bx,ax ; *
 12733                                  		
 12734                                  		;mov	[_bx_],ax ; **
 12735                                  
 12736                                  		; 15/12/2018
 12737                                  		; bx = [_bx_]
 12738                                  		
 12739 00001E02 C687[85A1]20            		mov	byte [ext_table_drive_letter+bx],' '
 12740                                  lld_3:
 12741                                  		;mov	al,[numlogdrvs]
 12742                                  		;cbw
 12743                                  		;mov	cx,ax
 12744                                  		;mov	al,24
 12745                                  		;mul	[_drive_]
 12746                                  		;add	ax,cx
 12747                                  		;mov	cx,46
 12748                                  		;imul	cx
 12749                                  		;mov	bx,ax ; *
 12750                                  		
 12751 00001E07 30ED                    		xor	ch,ch ; 11/12/2018
 12752                                  
 12753                                  		; Read logical DOS drive's boot sector
 12754                                  
 12755                                  	;if (read_boot_record(ext_table[drive][point].start_cyl,
 12756                                  	;		 drive,
 12757                                  	;		 ext_table[drive][point].start_head,
 12758                                  	;		 ext_table[drive][point].start_sector));
 12759                                  
 12760                                  		; 15/12/2018	
 12761                                  		; ??? - What for we read this boot sector ?
 12762                                  		; (There is not any error check or any bs parameter
 12763                                  		; using after this boot sector reading !?)
 12764                                  
 12765 00001E09 8B87[5BA1]              		mov	ax,[ext_table_start_cyl+bx]
 12766                                  		;mov	[_partition_location_],ax ; not used!
 12767 00001E0D 8A8F[5AA1]              		mov	cl,[ext_table_start_sector+bx]
 12768 00001E11 51                      		push	cx
 12769 00001E12 8A8F[59A1]              		mov	cl,[ext_table_start_head+bx]
 12770 00001E16 51                      		push	cx
 12771 00001E17 8A4E06                  		mov	cl,[_drive_]
 12772 00001E1A 51                      		push	cx
 12773 00001E1B 50                      		push	ax
 12774 00001E1C E8DD01                  		call	read_boot_record
 12775                                  		;add	sp,8 ; 22/12/2018
 12776                                  
 12777                                  lld_for1_if_chk_format:
 12778                                  		;mov	al,[numlogdrvs]
 12779                                  		;cbw
 12780                                  		;mov	cx,ax
 12781                                  		;mov	al,24
 12782                                  		;mul	[_drive_]
 12783                                  		;add	ax,cx
 12784                                  		;mov	cx,46
 12785                                  		;imul	cx
 12786                                  		;mov	bx,ax
 12787                                  
 12788 00001E1F 8B5EFE                  		mov	bx,[_bx_] ; **		
 12789                                  
 12790 00001E22 8A87[85A1]              		mov	al,[ext_table_drive_letter+bx]
 12791                                  		;push	ax
 12792 00001E26 E80BFF                  		call	check_format
 12793                                  		;pop	bx
 12794                                  		;dec	al
 12795                                  		;jz	short lld_for1_if_chk_format_true
 12796 00001E29 7302                    		jnc	short lld_for1_if_chk_format_true ; 27/11/2018
 12797 00001E2B EB77                    		jmp	lld_for1_if_chk_format_false
 12798                                  
 12799                                  lld_for1_if_chk_format_true:
 12800                                  
 12801                                  		;for (k = u(0); k < u(12); k++)
 12802                                  		;    BEGIN
 12803                                  		;	ext_table[drive][point].vol_label[k]=u(0);
 12804                                  		;    END
 12805                                  
 12806                                  		;mov	word [_int_k],0
 12807                                  lld_4:
 12808                                  		;mov	al,[numlogdrvs]
 12809                                  		;cbw
 12810                                  		;mov	cx,ax
 12811                                  		;mov	al,24
 12812                                  		;mul	[_drive_]
 12813                                  		;add	ax,cx
 12814                                  		;mov	cx,46
 12815                                  		;mul	cx
 12816                                  		;mov	si,ax
 12817                                  		
 12818                                  		;mov	si,[_bx_] ; **
 12819                                  
 12820                                  		;mov	bx,[_int_k]
 12821                                  		;mov	byte [ext_table_vol_label+bx+si],0
 12822                                  		;inc	byte [_int_k]
 12823                                  		;cmp	byte [_int_k],12
 12824                                  		;jb	short lld_4
 12825                                  
 12826                                  		; 26/11/2018
 12827                                  
 12828                                  		;mov	cx,12
 12829 00001E2D B91500                  		mov	cx,21 ; 12+9  ; +**+
 12830 00001E30 8B7EFE                  		mov	di,[_bx_]
 12831 00001E33 81C7[70A1]              		add	di,ext_table_vol_label
 12832 00001E37 30C0                    		xor	al,al
 12833 00001E39 F3AA                    		rep	stosb
 12834                                  
 12835                                  		; for (k = u(0); k < u(9); k++)
 12836                                  		;     BEGIN
 12837                                  		;	ext_table[drive][point].system[k]=u(0);
 12838                                  		;     END
 12839                                  
 12840                                  		;mov	byte [_int_k],0
 12841                                  lld_5:
 12842                                  		;mov	al,[numlogdrvs]
 12843                                  		;cbw
 12844                                  		;mov	cx,ax
 12845                                  		;mov	al,24
 12846                                  		;mul	[_drive_]
 12847                                  		;add	ax,cx
 12848                                  		;mov	cx,46
 12849                                  		;mul	cx
 12850                                  		;mov	si,ax
 12851                                  
 12852                                  		;mov	si,[_bx_] ; **
 12853                                  
 12854                                  		;mov	bx,[_int_k]
 12855                                  		;mov	byte [ext_table_system+bx+si],0
 12856                                  		;inc	byte [_int_k]
 12857                                  		;cmp	byte [_int_k],9
 12858                                  		;jb	short lld_5
 12859                                  
 12860                                  		; 26/11/2018
 12861                                  		;mov	cx,9 ; +**+
 12862                                  		;mov	di,[_bx_]
 12863                                  		;add	di,ext_table_system
 12864                                  		;xor	al,al
 12865                                  		;rep	stosb
 12866                                  
 12867                                  		;get_volume_string(ext_table[drive][point].drive_letter,&volume_label[0]);
 12868                                  		
 12869 00001E3B 8D46EE                  		lea	ax,[_char_vol_label_]
 12870 00001E3E 50                      		push	ax
 12871                                  				
 12872                                  		;mov	al,[numlogdrvs]
 12873                                  		;cbw
 12874                                  		;mov	cx,ax
 12875                                  		;mov	al,24
 12876                                  		;mul	[_drive_]
 12877                                  		;add	ax,cx
 12878                                  		;mov	cx,46
 12879                                  		;imul	cx
 12880                                  		;mov	bx,ax
 12881                                  		
 12882 00001E3F 8B5EFE                  		mov	bx,[_bx_] ; **
 12883                                  		
 12884 00001E42 8A87[85A1]              		mov	al,[ext_table_drive_letter+bx]
 12885 00001E46 50                      		push	ax
 12886 00001E47 E813FF                  		call	get_volume_string
 12887                                  		;pop	bx  ; 05/01/2019
 12888                                  		;pop	bx
 12889                                  
 12890                                  		;for (k = u(0); k < strlen(volume_label); k++)
 12891                                  		;    BEGIN
 12892                                  		;	ext_table[drive][point].vol_label[k]=volume_label[k];
 12893                                  		;    END 
 12894                                  
 12895                                  		;mov	byte [_int_k],0
 12896                                  		;jmp	short lld_7
 12897                                  lld_6:
 12898                                  		;mov	si,[_int_k]
 12899                                  		;mov	al,[si+_char_vol_label_]
 12900                                  		;;mov	cx,ax
 12901                                  		;;mov	cl,al
 12902                                  
 12903                                  		;;mov	al,[numlogdrvs]
 12904                                  		;;cbw
 12905                                  		;;mov	dx,ax
 12906                                  		;;mov	al,24
 12907                                  		;;mul	byte [_drive_]
 12908                                  		;;add	ax,dx
 12909                                  		;;mov	bx,46
 12910                                  		;;mul	bx
 12911                                  		;;mov	bx,ax
 12912                                  
 12913                                  		;mov	bx,[_bx_] ; **
 12914                                  
 12915                                  		;;mov	byte [ext_table_vol_label+bx+si],cl
 12916                                  		;mov	byte [ext_table_vol_label+bx+si],al
 12917                                  
 12918                                  		;inc	byte [_int_k]
 12919                                  lld_7:
 12920                                  		;; 26/11/2018
 12921                                  		;;lea	ax,[_char_vol_label_]  ; char volume_label[13];
 12922                                  		;;push	ax
 12923                                  
 12924                                  		;lea	si,[_char_vol_label_]
 12925                                  		;call	strlen
 12926                                  		;;pop	bx
 12927                                  		;;cmp	ax,[_int_k]
 12928                                  		;cmp	cx,[_int_k]
 12929                                  		;ja	short lld_6
 12930                                  
 12931                                  		;;mov	al,[numlogdrvs]
 12932                                  		;;cbw
 12933                                  		;;mov	cx,ax
 12934                                  		;;mov	al,24
 12935                                  		;;mul	byte [_drive_]
 12936                                  		;;add	ax,cx
 12937                                  		;;mov	cx,46
 12938                                  		;;imul	cx
 12939                                  		;;mov	bx,ax
 12940                                  				
 12941 00001E4A 8D76EE                  		lea	si,[_char_vol_label_]
 12942 00001E4D 8B7EFE                  		mov	di,[_bx_] ; **
 12943 00001E50 81C7[70A1]              		add	di,ext_table_vol_label
 12944 00001E54 E8D6FE                  		call	strcpy	; 26/11/2018
 12945                                  		
 12946 00001E57 8B5EFE                  		mov	bx,[_bx_] ; **
 12947                                  
 12948 00001E5A 8A87[85A1]              		mov	al,[ext_table_drive_letter+bx]
 12949                                  		;push	ax
 12950 00001E5E E847FF                  		call	get_fs_and_vol
 12951                                  		;pop	bx
 12952                                  		;or	al,al
 12953                                  		;jz	short lld_10
 12954 00001E61 7223                    		jc	short lld_10 ; 26/11/2018
 12955                                  
 12956                                  		;for (k=u(0); k < u(8); k++)
 12957                                  		;    BEGIN
 12958                                  		;     if (dx_buff.file_system[k] != ' ')
 12959                                  		;	 length = k+1;
 12960                                  		;    END
 12961                                  		;
 12962                                  		; strncpy(ext_table[drive][point].system,&dx_buff.file_system[0],u(length));
 12963                                  
 12964                                  		; 26/11/2018
 12965                                  		;mov	byte [_int_k],0
 12966 00001E63 31DB                    		xor	bx,bx
 12967 00001E65 31C9                    		xor	cx,cx
 12968                                  lld_8:
 12969                                  		;mov	bx,[_int_k]
 12970 00001E67 80BF[8AA0]20            		cmp	byte [dx_buff_file_system+bx],' '
 12971 00001E6C 7402                    		je	short lld_9
 12972                                  		;lea	ax,[bx+1]
 12973                                  		;mov	[_int_length_],ax
 12974 00001E6E FEC1                    		inc	cl
 12975                                  lld_9:
 12976                                  		;inc	byte [_int_k]
 12977 00001E70 FEC3                    		inc	bl
 12978                                  		;cmp	byte [_int_k],8
 12979 00001E72 80FB08                  		cmp	bl,8
 12980 00001E75 72F0                    		jb	short lld_8
 12981                                  		
 12982                                  		;push	word [_int_length_]
 12983                                  		;mov	cx,[_int_length_] ; copy length for strncpy ; 26/11/2018
 12984                                  		
 12985                                  		;mov	ax,dx_buff_file_system
 12986                                  		;push	ax
 12987                                  		
 12988                                  		;mov	al,[numlogdrvs]
 12989                                  		;cbw
 12990                                  		;mov	cx,ax
 12991                                  		;mov	al,24
 12992                                  		;mul	[_drive_]
 12993                                  		;add	ax,cx
 12994                                  		;mov	cx,46
 12995                                  		;imul	cx
 12996                                  
 12997                                  		; 26/11/2018
 12998                                  
 12999                                  		;mov	ax,[_bx_] ; **
 13000                                  
 13001                                  		;add	ax,ext_table_system
 13002                                  		;push	ax
 13003                                  		;call	strncpy
 13004                                  		;add	sp,6
 13005                                  
 13006 00001E77 BE[8AA0]                		mov	si,dx_buff_file_system  ; source
 13007 00001E7A 8B7EFE                  		mov	di,[_bx_]
 13008 00001E7D 81C7[7CA1]              		add	di,ext_table_system	; destination
 13009                                  			;cx = number of characters to be copied
 13010 00001E81 E89DFE                  		call	strncpy
 13011                                  
 13012 00001E84 EB30                    		jmp	short lld_14
 13013                                  
 13014                                  lld_10:
 13015                                  		;mov	al,[numlogdrvs]
 13016                                  		;cbw
 13017                                  		;mov	cx,ax
 13018                                  		;mov	al,24
 13019                                  		;mul	[_drive_]
 13020                                  		;add	ax,cx
 13021                                  		;mov	cx,46
 13022                                  		;imul	cx
 13023                                  		;mov	bx,ax
 13024                                  
 13025                                  		; 26/11/2018
 13026                                  		;mov	bx,[_bx_] ; **
 13027 00001E86 8B7EFE                  		mov	di,[_bx_] ; **
 13028                                  		; 14/12/2018
 13029 00001E89 81C7[7CA1]              		add	di,ext_table_system
 13030                                  
 13031 00001E8D BE[755F]                		mov	si,extFAT16 ; 14/12/2018
 13032                                  		;cmp	word [ext_table_num_sec_hw+bx],0
 13033 00001E90 83BD[68A1]00            		cmp	word [ext_table_num_sec_hw+di],0
 13034                                  		;jnz	short lld_11
 13035 00001E95 751C                    		jnz	short lld_13 ; 14/12/2018
 13036                                  		;cmp	word [ext_table_num_sec_lw+bx],32680
 13037 00001E97 81BD[66A1]A87F          		cmp	word [ext_table_num_sec_lw+di],32680
 13038                                  		;jbe	short lld_12
 13039                                  		; 14/12/2018
 13040 00001E9D 7714                    		ja	short lld_13
 13041 00001E9F BE[7E5F]                		mov	si,extFAT12
 13042 00001EA2 EB0F                    		jmp	short lld_13	
 13043                                  ; 14/12/2018
 13044                                  ;lld_11:	
 13045                                  ;		;mov	ax,extFAT16 ; "FAT16   "
 13046                                  ;		;push	ax
 13047                                  ;		;add	bx,ext_table_system
 13048                                  ;		;push	bx
 13049                                  ;
 13050                                  ;		mov	si,extFAT16
 13051                                  ;		
 13052                                  ;		;add	di,ext_table_system
 13053                                  ;		
 13054                                  ;		jmp	short lld_13
 13055                                  ;
 13056                                  ;lld_12:
 13057                                  ;		;mov	ax,extFAT12 ; "FAT12   "
 13058                                  ;		;push	ax
 13059                                  ;
 13060                                  ;		;mov	al,[numlogdrvs]
 13061                                  ;		;cbw
 13062                                  ;		;mov	cx,ax
 13063                                  ;		;mov	al,24
 13064                                  ;		;mul	[_drive_]
 13065                                  ;		;add	ax,cx
 13066                                  ;		;mov	cx,46
 13067                                  ;		;imul	cx
 13068                                  ;		
 13069                                  ;		; 26/11/2018
 13070                                  ;		;mov	ax,[_bx_] ; **
 13071                                  ;
 13072                                  ;		;add	ax,ext_table_system
 13073                                  ;		;push	ax
 13074                                  ;
 13075                                  ;		mov	si,extFAT12
 13076                                  ;		
 13077                                  ;		;mov	di,[_bx_] ; **
 13078                                  ;		;add	di,ext_table_system
 13079                                  ;
 13080                                  ;		jmp	short lld_13
 13081                                  
 13082                                  lld_for1_if_chk_format_false:
 13083                                  		;mov	ax,extNOVOLUME
 13084                                  		;push	ax
 13085                                  
 13086                                  		;mov	al,[numlogdrvs]
 13087                                  		;cbw
 13088                                  		;mov	cx,ax
 13089                                  		;mov	al,24
 13090                                  		;mul	byte [_drive_]
 13091                                  		;add	ax,cx
 13092                                  		;mov	cx,46
 13093                                  		;imul	cx
 13094                                  		;mov	cx,ax
 13095                                  
 13096                                  		; 26/11/2018
 13097                                  		;mov	ax,[_bx_] ; **
 13098                                  		;mov	si,ax
 13099                                  		;add	ax,ext_table_vol_label
 13100                                  		;push	ax
 13101                                  		;;mov	si,cx
 13102                                  		;call	strcpy
 13103                                  		;pop	bx
 13104                                  		;pop	bx
 13105                                  
 13106                                  		; 05/01/2019
 13107                                  		;mov	si,extNOVOLUME
 13108 00001EA4 8B7EFE                  		mov	di,[_bx_] ; **
 13109                                  		;add	di,ext_table_vol_label
 13110                                  		;call	strcpy
 13111                                  
 13112 00001EA7 C685[70A1]00            		mov	byte [di+ext_table_vol_label],0 ; extNOVOLUME
 13113                                  		
 13114                                  		;mov	ax,extUNKNOWN ;	"UNKNOWN "
 13115                                  		;push	ax
 13116                                  
 13117                                  		;add	si,ext_table_system
 13118                                  		;push	si
 13119                                  
 13120 00001EAC BE[885F]                		mov	si,extUNKNOWN
 13121                                  		;mov	di,[_bx_] ; **
 13122                                  		; 05/01/2019
 13123 00001EAF 81C7[7CA1]              		add	di,ext_table_system ; =*
 13124                                  lld_13:
 13125 00001EB3 E877FE                  		call	strcpy
 13126                                  		;pop	bx
 13127                                  		;pop	bx
 13128                                  lld_14:
 13129                                  		;mov	word [regs_x_dx],0
 13130                                  		;mov	word [regs_x_ax],4409h
 13131                                  		
 13132                                  		;mov	al,[numlogdrvs]
 13133                                  		;cbw
 13134                                  		;mov	cx,ax
 13135                                  		;mov	al,24
 13136                                  		;mul	[_drive_]
 13137                                  		;add	ax,cx
 13138                                  		;mov	cx,46
 13139                                  		;imul	cx
 13140                                  		;mov	bx,ax
 13141                                  
 13142                                  		; 26/11/2018
 13143                                  
 13144                                  		;mov	bx,[_bx_] ; **
 13145                                  
 13146                                  		;mov	al,[ext_table_drive_letter+bx]
 13147                                  		;sub	al,40h
 13148                                  		;mov	[regs_x_bx],al
 13149                                  		;mov	ax,regs ; regs_x_ax
 13150                                  		;push	ax
 13151                                  		;push	ax
 13152                                  		;;mov	si,bx
 13153                                  		;mov	di,bx ; 26/11/2018 ; **
 13154                                  		;call	intdos
 13155                                  		;pop	bx
 13156                                  		;pop	bx
 13157                                  		;test	byte [regs_x_dx+1],10h
 13158                                  		;jz	short lld_15
 13159                                  
 13160                                  		; 14/12/2018
 13161 00001EB6 8B7EFE                  		mov	di,[_bx_] ; **
 13162                                  
 13163                                  		; DOS 3.1+ - IOCTL - CHECK IF BLOCK DEVICE REMOTE
 13164 00001EB9 B80944                  		mov	ax,4409h
 13165 00001EBC 8A9D[85A1]              		mov	bl,[ext_table_drive_letter+di] ; **
 13166 00001EC0 80EB40                  		sub	bl,40h
 13167 00001EC3 CD21                    		int	21h
 13168 00001EC5 F6C610                  		test	dh,10h ; DX bit 12, 'Drive is Remote' flag
 13169 00001EC8 740B                    		jz	short lld_15
 13170                                  			; Note: DX = 0800h (MSDOS) or 
 13171                                  			;	DX = 4800h (WINDOWS 95) --> RAM Drive
 13172                                  		
 13173                                  		; ah = 0 ?
 13174                                  
 13175                                  		;push	word [REMOTE]
 13176                                  		;add	si,ext_table_vol_label
 13177                                  		;push	si
 13178                                  
 13179 00001ECA 8B36[D69E]              		mov	si,[REMOTE]
 13180                                  
 13181                                  		;mov	di,[_bx_] ; ** ; 14/12/2018
 13182                                  
 13183 00001ECE 81C7[70A1]              		add	di,ext_table_vol_label ; **
 13184                                  
 13185 00001ED2 E858FE                  		call	strcpy
 13186                                  		;pop	bx
 13187                                  		;pop	bx
 13188                                  
 13189                                  		; ah = 0 ?
 13190                                  lld_15:
 13191                                  		;read_boot_record(ext_table[drive][point].start_cyl,
 13192                                  		;		     drive,
 13193                                  		;		     uc(0),
 13194                                  		;		     uc(1));              
 13195                                  
 13196                                  		;mov	al,1
 13197 00001ED5 B80100                  		mov	ax,1 ; 11/12/2018 (ah = 0)
 13198 00001ED8 50                      		push	ax
 13199 00001ED9 28C0                    		sub	al,al ; 0
 13200 00001EDB 50                      		push	ax
 13201 00001EDC 8A4606                  		mov	al,[_drive_]
 13202 00001EDF 50                      		push	ax
 13203                                  		
 13204                                  		;mov	al,[numlogdrvs]
 13205                                  		;cbw
 13206                                  		;mov	cx,ax
 13207                                  		;mov	al,24
 13208                                  		;mul	byte [_drive_]
 13209                                  		;add	ax,cx
 13210                                  		;mov	cx,46
 13211                                  		;imul	cx
 13212                                  		;mov	bx,ax
 13213                                  		
 13214 00001EE0 8B5EFE                  		mov	bx,[_bx_] ; **
 13215                                  
 13216 00001EE3 FFB7[5BA1]              		push	word [ext_table_start_cyl+bx]
 13217 00001EE7 E81201                  		call	read_boot_record
 13218                                  		;add	sp,8 ; 22/12/2018
 13219                                  
 13220                                  lld_for1_if_false:
 13221 00001EEA FE46FC                  		inc	byte [_int_i]
 13222                                  lld_for1_1:
 13223 00001EED 807EFC04                		cmp	byte [_int_i],4
 13224 00001EF1 7203                    		jb	short lld_for1_next
 13225 00001EF3 E90001                  		jmp	lld_17
 13226                                  
 13227                                  lld_for1_next:
 13228 00001EF6 B104                    		mov	cl,4
 13229 00001EF8 8B5EFC                  		mov	bx,[_int_i]
 13230 00001EFB D3E3                    		shl	bx,cl ; * 16
 13231                                  		; 26/11/2018
 13232                                  		;mov	[_int_index_],bx ; index = i*16;
 13233                                  lld_for1_if:
 13234                                  	;if ((boot_record[0x1C2 + index] != uc(0)) && 
 13235                                  	;	(boot_record[0x1C2 + index] != uc(EXTENDED))) 
 13236                                  
 13237                                  		;cmp	byte [boot_record+1C2h+bx],0 
 13238                                  		;je	short lld_for1_if_false
 13239                                  		;cmp	byte [boot_record+1C2h+bx],EXTENDED ; 5
 13240                                  		;je	short lld_for1_if_false
 13241                                  
 13242                                  		;mov	al,[boot_record+1C2h+bx]  ; Partition ID
 13243                                  		;or	al,al
 13244                                  		;jz	short lld_for1_if_false
 13245                                  		;cmp	al,EXTENDED ; 5
 13246                                  		;je	short lld_for1_if_false
 13247                                  
 13248                                  		; 15/12/2018
 13249                                  		; Here we are checking partition 0 to 3 of
 13250                                  		; (extended partition table of) extended volume.
 13251                                  		; (Partition 1,2 and 3 must have a ZERO or 
 13252                                  		; EXTENDED DOS partition ID while Partition 0 has a
 13253                                  		; valid DOS partition ID.)
 13254                                  		; [Otherwise, previous logical dos partition data 
 13255                                  		; would be overwritten, but logical drive letter 
 13256                                  		; would be changed to next letter!?]
 13257                                  
 13258                                  		; (For valid scheme: If there are 2 or more Logical 
 13259                                  		; DOS partitions.. partition -table entry- 0 must 
 13260                                  		; have DOS partition ID; partition 1 must have 
 13261                                  		; Extended DOS partition ID; partition 3 and 4 
 13262                                  		; must be empty in the extended partition table of 
 13263                                  		; the first -extended volume- logical dos partition.)
 13264                                  
 13265                                  		; (It seem as Extended DOS partition construction logic 
 13266                                  		; is defective. Instead of this defective construction,
 13267                                  		; it would be better if extended partition -boot sector- table
 13268                                  		; would have same construction with masterboot partition table.)
 13269                                  		; [Erdogan Tan, 15/12/2018]		
 13270                                  	
 13271 00001EFD 8A97[A2CB]              		mov	dl,[boot_record+1C2h+bx]  ; Partition ID ; /**/	
 13272 00001F01 08D2                    		or	dl,dl
 13273 00001F03 74E5                    		jz	short lld_for1_if_false
 13274 00001F05 80FA05                  		cmp	dl,EXTENDED ; 5
 13275 00001F08 74E0                    		je	short lld_for1_if_false
 13276                                  
 13277                                  lld_for1_if_true:
 13278                                  		;mov	al,[numlogdrvs]
 13279                                  		;cbw
 13280                                  		;mov	cx,24
 13281                                  		;mov	dx,ax
 13282                                  		;mov	al,[_drive_]
 13283                                  		;sub	ah,ah
 13284                                  		;mov	si,dx
 13285                                  		;mov	di,46
 13286                                  		;mov	bx,ax
 13287                                  		;mul	cx
 13288                                  		;add	ax,si
 13289                                  		;imul	di
 13290                                  		;mov	si,ax
 13291                                  
 13292                                  		; 15/12/2018
 13293                                  		;mov	cl,[numlogdrvs] ; Logical drive index
 13294 00001F0A B018                    		mov	al,24
 13295 00001F0C F66606                  		mul	byte [_drive_] 
 13296                                  		;;add	ax,cx
 13297                                  		;add	al,cl
 13298 00001F0F 024604                  		add	al,[numlogdrvs] ; 19/12/2018
 13299 00001F12 B92E00                  		mov	cx,46
 13300 00001F15 F6E1                    		mul	cl
 13301 00001F17 89C6                    		mov	si,ax ; ** ; (([_drive_]*24)+[_numlogdrvs])*46
 13302                                  		
 13303 00001F19 8946FE                  		mov	[_bx_],ax
 13304                                  
 13305                                  		; 14/12/2018
 13306                                  		;mov	[ext_table_sys_id+si],al ; /**/
 13307                                  		; 15/12/2018
 13308 00001F1C 8894[5DA1]              		mov	[ext_table_sys_id+si],dl ; /**/		
 13309                                  
 13310                                  		;/* Get boot ind */
 13311                                  		;ext_table[drive][point].boot_ind = boot_record[0x1BE + index];
 13312                                  		;mov	di,[_int_index_]
 13313                                  		;mov	al,[boot_record+1BEh+di]
 13314 00001F20 8A87[9ECB]              		mov	al,[boot_record+1BEh+bx]
 13315 00001F24 8884[58A1]              		mov	[ext_table_boot_ind+si],al
 13316                                  
 13317                                  		;/* Start head */
 13318                                  		;ext_table[drive][point].start_head = boot_record[0x1BF + index];
 13319                                  		;mov	al,[boot_record+1BFh+di]
 13320 00001F28 8A87[9FCB]              		mov	al,[boot_record+1BFh+bx]
 13321 00001F2C 8884[59A1]              		mov	[ext_table_start_head+si],al
 13322                                  
 13323                                  		;/* Start sector - unscramble it from INT 13 format*/
 13324                                  		;ext_table[drive][point].start_sector= (boot_record[0x1C0 + index] & 0x3F);
 13325                                  		;mov	al,[boot_record+1C0h+di]
 13326 00001F30 8A87[A0CB]              		mov	al,[boot_record+1C0h+bx]
 13327                                  		;mov	cx,ax
 13328 00001F34 88C1                    		mov	cl,al ; 15/12/2018
 13329 00001F36 243F                    		and	al,3Fh
 13330 00001F38 8884[5AA1]              		mov	[ext_table_start_sector+si],al
 13331                                      		;/* Start cyl - unscramble it from INT 13 format*/
 13332                                  		;  ext_table[drive][point].start_cyl= ((((unsigned)boot_record[0x1C0+index]) & 0x00C0) << 2)
 13333                                  		;	+ ((unsigned)boot_record[0x1C1+index]);
 13334                                  		;and	cx,0C0h
 13335 00001F3C 80E1C0                  		and	cl,0C0h ; 15/12/2018
 13336 00001F3F D1E1                    		shl	cx,1
 13337 00001F41 D1E1                    		shl	cx,1
 13338                                  		;;mov	al,[boot_record+1C1h+di]
 13339                                  		;mov	al,[boot_record+1C1h+bx]
 13340                                  		;;sub	ah,ah
 13341                                  		;;add	cx,ax
 13342                                  		;mov	cl,al
 13343 00001F43 8A8F[A1CB]              		mov	cl,[boot_record+1C1h+bx] ; 15/12/2018
 13344 00001F47 898C[5BA1]              		mov	[ext_table_start_cyl+si],cx
 13345                                  
 13346                                  		;/* System id */
 13347                                  		;ext_table[drive][point].sys_id = boot_record[0x1C2+index];
 13348                                  		;mov	al,[boot_record+1C2h+di]
 13349                                  		; 14/12/2018
 13350                                  		;mov	al,[boot_record+1C2h+bx]
 13351                                  		;mov	[ext_table_sys_id+si],al ; /**/
 13352                                  
 13353                                  		;/* End head */
 13354                                  		;ext_table[drive][point].end_head = boot_record[0x1C3+index];
 13355                                  		;mov	al,[boot_record+1C3h+di]
 13356 00001F4B 8A87[A3CB]              		mov	al,[boot_record+1C3h+bx]
 13357 00001F4F 8884[5EA1]              		mov	[ext_table_end_head+si],al
 13358                                  
 13359                                  		;/* End sector - unscramble it from INT 13 format*/
 13360                                  		;ext_table[drive][point].end_sector= (boot_record[0x1C4+index] & 0x3F);
 13361                                  		;mov	al,[boot_record+1C4h+di]
 13362 00001F53 8A87[A4CB]              		mov	al,[boot_record+1C4h+bx]
 13363                                  		;mov	cx,ax
 13364 00001F57 88C1                    		mov	cl,al
 13365 00001F59 243F                    		and	al,3Fh
 13366 00001F5B 8884[5FA1]              		mov	[ext_table_end_sector+si],al
 13367                                  		;/* End cyl - unscramble it from INT 13 format*/
 13368                                  		;ext_table[drive][point].end_cyl= ((((unsigned)boot_record[0x1C4+index]) & 0x00C0) << 2)
 13369                                  		;	+ ((unsigned)boot_record[0x1C5+index]);
 13370 00001F5F 81E1C000                		and	cx,0C0h
 13371 00001F63 D1E1                    		shl	cx,1
 13372 00001F65 D1E1                    		shl	cx,1
 13373                                  		;;mov	al,[boot_record+1C5h+di]
 13374                                  		;mov	al,[boot_record+1C5h+bx]
 13375                                  		;;add	cx,ax
 13376                                  		;mov	cl,al
 13377 00001F67 8A8F[A5CB]              		mov	cl,[boot_record+1C5h+bx] ; 15/12/2018
 13378 00001F6B 898C[60A1]              		mov	[ext_table_end_cyl+si],cx
 13379                                  
 13380                                  		;/* Relative sectors */
 13381                                  		;ext_table[drive][point].rel_sec = ((unsigned long)boot_record[0x1C9+index]) << 24;
 13382                                  		;ext_table[drive][point].rel_sec =
 13383                                  		;    ext_table[drive][point].rel_sec+(((unsigned long)boot_record[0x1C8+index]) << 16);
 13384                                  		;ext_table[drive][point].rel_sec =
 13385                                  		;    ext_table[drive][point].rel_sec+(((unsigned long)boot_record[0x1C7+index]) << 8);
 13386                                  		;ext_table[drive][point].rel_sec =
 13387                                  		;    ext_table[drive][point].rel_sec+((unsigned long)boot_record[0x1C6+index]);
 13388                                  
 13389                                  		;mov	al,[boot_record+1C9h+di]
 13390                                  		;mov	ah,al
 13391                                  		;sub	al,al
 13392                                  		;sub	cx,cx
 13393                                  		;mov	[ext_table_rel_sec_lw+si],cx
 13394                                  		;mov	[ext_table_rel_sec_hw+si],ax
 13395                                  		;mov	dl,[boot_record+1C8h+di]
 13396                                  		;sub	dh,dh
 13397                                  		;sub	di,di
 13398                                  		;add	cx,di
 13399                                  		;adc	ax,dx
 13400                                  		;mov	[ext_table_rel_sec_lw+si],cx
 13401                                  		;mov	[ext_table_rel_sec_hw+si],ax
 13402                                  		;mov	di,[_int_index_]
 13403                                  		;mov	dx,ax
 13404                                  		;mov	al,[boot_record+1C7h+di]
 13405                                  		;sub	ah,ah
 13406                                  		;mov	di,dx
 13407                                  		;sub	dx,dx
 13408                                  		;mov	[temprelsec_lw],cx
 13409                                  		;mov	[temprelsec_hw],di
 13410                                  		;mov	cl,8
 13411                                  		;mov	di,bx
 13412                                  		;call	shl32
 13413                                  		;add	ax,[temprelsec_lw]
 13414                                  		;adc	dx,[temprelsec_hw]
 13415                                  		;mov	[ext_table_rel_sec_lw+si], ax
 13416                                  		;mov	[ext_table_rel_sec_hw+si], dx
 13417                                  		;mov	bx,[_int_index_]
 13418                                  		;mov	cl,[boot_record+1C6h+bx]
 13419                                  		;sub	ch,ch
 13420                                  		;add	ax,cx
 13421                                  		;adc	dx,0
 13422                                  		;mov	[ext_table_rel_sec_lw+si],ax
 13423                                  		;mov	[ext_table_rel_sec_hw+si],dx
 13424                                  
 13425                                  		; 26/11/2018
 13426                                  		;mov	ax,[boot_record+1C6h+di]
 13427                                  		;mov	dx,[boot_record+1C8h+di]
 13428 00001F6F 8B87[A6CB]              		mov	ax,[boot_record+1C6h+bx]
 13429 00001F73 8B97[A8CB]              		mov	dx,[boot_record+1C8h+bx]
 13430 00001F77 8984[62A1]              		mov	[ext_table_rel_sec_lw+si],ax
 13431 00001F7B 8994[64A1]              		mov	[ext_table_rel_sec_hw+si],dx
 13432                                  
 13433                                  		;/* Number of sectors */
 13434                                  		;ext_table[drive][point].num_sec = ((unsigned long)boot_record[0x1CD+index]) << 24;
 13435                                  		;ext_table[drive][point].num_sec =
 13436                                  		;    ext_table[drive][point].num_sec+(((unsigned long)boot_record[0x1CC+index]) << 16);
 13437                                  		;ext_table[drive][point].num_sec =
 13438                                  		;    ext_table[drive][point].num_sec+(((unsigned long)boot_record[0x1CB+index]) << 8);
 13439                                  		;ext_table[drive][point].num_sec =
 13440                                  		;    ext_table[drive][point].num_sec + ((unsigned long)boot_record[0x1CA+index]);
 13441                                  
 13442                                  		;mov	al,[boot_record+1CDh+bx]
 13443                                  		;mov	ah,al
 13444                                  		;sub	al,al
 13445                                  		;sub	cx,cx
 13446                                  		;mov	[ext_table_num_sec_lw+si],cx
 13447                                  		;mov	[ext_table_num_sec_hw+si],ax
 13448                                  		;mov	dl,[boot_record+1CCh+bx]
 13449                                  		;sub	dh,dh
 13450                                  		;sub	bx,bx
 13451                                  		;add	cx,bx
 13452                                  		;adc	ax,dx
 13453                                  		;mov	[ext_table_num_sec_lw+si],cx
 13454                                  		;mov	[ext_table_num_sec_hw+si],ax
 13455                                  		;mov	bx,[_int_index_]
 13456                                  		;mov	dx,ax
 13457                                  		;mov	al,[boot_record+1CBh+bx]
 13458                                  		;sub	ah,ah
 13459                                  		;mov	bx,dx
 13460                                  		;sub	dx,dx
 13461                                  		;mov	[tempnumsec_lw],cx
 13462                                  		;mov	[tempnumsec_hw],bx
 13463                                  		;mov	cl,8
 13464                                  		;call	shl32
 13465                                  		;add	ax,[tempnumsec_lw]
 13466                                  		;adc	dx,[tempnumsec_hw]
 13467                                  		;mov	[ext_table_num_sec_lw+si],ax
 13468                                  		;mov	[ext_table_num_sec_hw+si],dx
 13469                                  		;mov	bx,[_int_index_]
 13470                                  		;mov	cl,[boot_record+1CAh+bx]
 13471                                  		;sub	ch,ch
 13472                                  		;add	ax,cx
 13473                                  		;adc	dx,0
 13474                                  		;mov	[ext_table_num_sec_lw+si],ax
 13475                                  		;mov	[ext_table_num_sec_hw+si],dx
 13476                                  
 13477                                  		; 26/11/2018
 13478                                  		;mov	ax,[boot_record+1CAh+di]
 13479                                  		;mov	dx,[boot_record+1CCh+di]
 13480 00001F7F 8B87[AACB]              		mov	ax,[boot_record+1CAh+bx]
 13481 00001F83 8B97[ACCB]              		mov	dx,[boot_record+1CCh+bx]
 13482 00001F87 8984[66A1]              		mov	[ext_table_num_sec_lw+si],ax
 13483 00001F8B 8994[68A1]              		mov	[ext_table_num_sec_hw+si],dx
 13484                                  
 13485                                  	;ext_table[drive][point].mbytes_used =
 13486                                  	; cylinders_to_mbytes(((ext_table[drive][point].end_cyl - ext_table[drive][point].start_cyl)+1),
 13487                                  	; 			cur_disk);
 13488                                  
 13489 00001F8F 89DF                    		mov	di,bx ; [_int_index_] ; ****
 13490                                  			; bh = 0
 13491                                  
 13492                                  		;mov	al,[cur_disk]
 13493                                  		;push	ax
 13494                                  		
 13495 00001F91 8A1E[E2CB]              		mov	bl,[cur_disk]
 13496                                  		;xor	bh,bh ; 0
 13497                                  			;bx = Disk drive Number 0 to 7
 13498                                  
 13499 00001F95 8B84[60A1]              		mov	ax,[ext_table_end_cyl+si]
 13500 00001F99 2B84[5BA1]              		sub	ax,[ext_table_start_cyl+si]
 13501 00001F9D 40                      		inc	ax
 13502                                  			; ax = number of cylinders (partition size in cylinders)
 13503                                  		;push	ax
 13504 00001F9E E8C5F5                  		call	cylinders_to_mbytes
 13505                                  			; ax = partition size in megabytes
 13506                                  		;pop	bx
 13507                                  		;pop	bx
 13508 00001FA1 8984[6CA1]              		mov	[ext_table_mbytes_used+si],ax
 13509                                  
 13510                                  		; 14/12/2018
 13511                                  		;mov	al,5 ; EXTENDED
 13512                                  		;;push	ax
 13513                                  		;call	find_partition_location
 13514                                  		;;pop	bx
 13515                                  		;	; al = partition number (0 to 3) or 0FFh (not found)
 13516                                  
 13517                                  		; 26/11/2018	
 13518                                  		;cbw
 13519                                  		;mov	[ext_part_num],ax
 13520                                  		
 13521                                  		; 14/12/2018
 13522                                  		; get partition entry number of extended dos partion
 13523                                   		; 	(on current disk/drive)
 13524 00001FA5 B005                    		mov	al,5
 13525 00001FA7 E81AFE                  		call	find_partition_type
 13526                                  		; CL = partition number (index), 0 to 3 or 4 (not found)
 13527                                  
 13528                                  		;mov	ax,di ; [_drive_] ; Drive number (0 to 7)
 13529                                  		;shl	ax,1
 13530                                  		;shl	ax,1
 13531                                  		;add	ax,[ext_part_num]
 13532                                  
 13533                                  		; 14/12/2018
 13534 00001FAA 8A4606                  		mov	al,[_drive_]
 13535 00001FAD D0E0                    		shl	al,1
 13536 00001FAF D0E0                    		shl	al,1
 13537 00001FB1 00C8                    		add	al,cl ; Partition (entry) number (0 to 3)
 13538                                  		;mov	cx,46
 13539                                  		;mul	cx
 13540 00001FB3 B12E                    		mov	cl,46
 13541 00001FB5 F6E1                    		mul	cl
 13542 00001FB7 89C3                    		mov	bx,ax
 13543                                  		
 13544                                  		;mov	ax,[part_table_end_cyl+bx]
 13545                                  		;sub	ax,[part_table_start_cyl+bx]
 13546                                  		;inc	ax
 13547                                  		;push	ax
 13548                                  
 13549 00001FB9 8B8F[28C4]              		mov	cx,[part_table_end_cyl+bx]
 13550 00001FBD 2B8F[23C4]              		sub	cx,[part_table_start_cyl+bx]
 13551 00001FC1 41                      		inc	cx 
 13552                                  			; cx = Total cylinders (of extended partition)
 13553                                  		
 13554                                  		;mov	ax,[ext_table_end_cyl+si]
 13555                                  		;;sub	ax,[ext_table_start_cyl+si]
 13556                                  		;inc	ax
 13557                                  		;push	ax
 13558                                  		
 13559 00001FC2 8B9C[60A1]              		mov	bx,[ext_table_end_cyl+si]
 13560 00001FC6 2B9C[5BA1]              		sub	bx,[ext_table_start_cyl+si]
 13561 00001FCA 43                      		inc	bx
 13562                                  			; bx = Number of logical drive/partition cylinders 
 13563                                  
 13564 00001FCB E8EBF5                  		call	cylinders_to_percent   ; (100*bx/cx)%
 13565                                  		;pop	bx
 13566                                  		;pop	bx
 13567 00001FCE 8984[6EA1]              		mov	[ext_table_percent_used+si],ax ; percentage (<=100)
 13568                                  		
 13569                                  		;mov	bx,[_int_index_]
 13570                                  		;mov	bx,di ; [_int_index_] ; ****
 13571                                  
 13572                                  		; 26/11/2018
 13573                                  
 13574                                  		;cmp	byte [boot_record+1C2h+bx],1
 13575                                  		;je	short lld_16
 13576                                  		;cmp	byte [boot_record+1C2h+bx],4
 13577                                  		;je	short lld_16
 13578                                  		;cmp	byte [boot_record+1C2h+bx],6
 13579                                  		;je	short lld_16
 13580                                  
 13581                                  		;mov	al,[bx+boot_record+1C2h] ; Partition/System ID	
 13582 00001FD2 8A85[A2CB]              		mov	al,[di+boot_record+1C2h] ; ****	
 13583                                  
 13584                                  		; 15/12/2018
 13585 00001FD6 8B5EFE                  		mov	bx,[_bx_] ; **
 13586                                  
 13587 00001FD9 3C01                    		cmp	al,DOS12  ; 1		
 13588 00001FDB 740B                    		je	short lld_16
 13589 00001FDD 3C04                    		cmp	al,DOS16  ; 4
 13590 00001FDF 7407                    		je	short lld_16
 13591 00001FE1 3C06                    		cmp	al,DOSNEW ; 6 
 13592 00001FE3 7403                    		je	short lld_16
 13593                                  
 13594 00001FE5 E91AFE                  		jmp	lld_2
 13595                                  lld_16:
 13596                                  		;mov	al,[numlogdrvs]
 13597                                  		;cbw
 13598                                  		;mov	cx,ax
 13599                                  		;mov	al,24
 13600                                  		;mul	[_drive_]
 13601                                  		;add	ax,cx
 13602                                  		;mov	cx,46
 13603                                  		;imul	cx
 13604                                  		;mov	bx,ax
 13605                                  
 13606                                  		; 15/12/2018
 13607                                  		;mov	bx,[_bx_] ; **
 13608                                  
 13609 00001FE8 A0[2DA1]                		mov	al,[next_letter]
 13610 00001FEB FE06[2DA1]              		inc	byte [next_letter]
 13611 00001FEF 8887[85A1]              		mov	[ext_table_drive_letter+bx],al
 13612 00001FF3 E911FE                  		jmp	lld_3
 13613                                  lld_17:
 13614                                  		; 15/12/2018
 13615                                  		;pop	si
 13616                                  		;pop	di
 13617                                  		
 13618 00001FF6 89EC                    		mov	sp,bp
 13619 00001FF8 5D                      		pop	bp
 13620 00001FF9 C20400                  		retn	4 ; 06/01/2019
 13621                                  
 13622                                  ; ----------------------------------------------------------------------------
 13623                                  ; int13.c (FDISK, MSDOS 6.0, 1991)	
 13624                                  ; ----------------------------------------------------------------------------
 13625                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 26/11/2018)
 13626                                  
 13627                                  ;/*  */
 13628                                  ;char read_boot_record(cylinder,which_disk,which_head,which_sector) /* AC000 */
 13629                                  ;
 13630                                  ;unsigned        cylinder;
 13631                                  ;unsigned char   which_disk;
 13632                                  ;unsigned char   which_head;					  /* AN000 */
 13633                                  ;unsigned char   which_sector;					  /* AN000 */
 13634                                  ;
 13635                                  ;BEGIN
 13636                                  ;
 13637                                  ;   char far *buffer_pointer = boot_record;
 13638                                  ;
 13639                                  ;   /* Setup read, always on a cylinder boundary */
 13640                                  ;   regs.h.ah = uc(READ_DISK);                                    /* AC000 */
 13641                                  ;   regs.h.al = uc(1);                                            /* AC000 */
 13642                                  ;   regs.h.dh = which_head;                                       /* AC000 */
 13643                                  ;   regs.h.cl = which_sector;                                     /* AC000 */
 13644                                  ;
 13645                                  ;   /* Specify the disk */
 13646                                  ;   regs.h.dl = which_disk + 0x80;
 13647                                  ;
 13648                                  ;   /* Need to scramble CX so that sectors and cyl's are in INT 13 format */
 13649                                  ;
 13650                                  ;   if (cylinder > u(255))                                        /* AC000 */
 13651                                  ;      BEGIN
 13652                                  ;       regs.h.cl = regs.h.cl | ((char)((cylinder /256) << 6));
 13653                                  ;      END
 13654                                  ;   regs.h.ch = (unsigned char)(cylinder & 0xFF);
 13655                                  ;
 13656                                  ;   /* Point at the place to write the boot record */
 13657                                  ;   regs.x.bx = FP_OFF(buffer_pointer);
 13658                                  ;   segregs.es = FP_SEG(buffer_pointer);
 13659                                  ;
 13660                                  ;   /* read in the boot record */
 13661                                  ;   DiskIo(&regs,&regs,&segregs);			         /* AC000 */
 13662                                  ;   /* Check for error reading it */
 13663                                  ;   if ((regs.x.cflag & 1) != u(1))                              /* AC000 */
 13664                                  ;      BEGIN
 13665                                  ;       return(TRUE);
 13666                                  ;      END
 13667                                  ;   else
 13668                                  ;      BEGIN
 13669                                  ;       /* Tell user there was an error */
 13670                                  ;       good_disk[which_disk] = FALSE;
 13671                                  ;       clear_screen(u(0),u(0),u(24),u(79));			 /* AC000 */
 13672                                  ;       return(FALSE);
 13673                                  ;      END
 13674                                  ;END
 13675                                  
 13676                                  read_boot_record:
 13677                                  		; 26/11/2018
 13678                                  	
 13679                                  	;%define rbs_buffer   bp-4  ; word
 13680                                  	;%define rbs_segment  bp-2  ; word
 13681                                  	%define rbs_cylinder bp+4  ; word
 13682                                  	%define rbs_disk     bp+6  ; byte
 13683                                  	%define rbs_head     bp+8  ; byte
 13684                                  	%define rbs_sector   bp+10 ; byte
 13685                                  
 13686                                  		; Modified registers: ax,bx,cx,dx
 13687                                  
 13688 00001FFC 55                      		push	bp
 13689 00001FFD 89E5                    		mov	bp,sp
 13690                                  		;sub	sp,4 ; 11/12/2018
 13691                                  
 13692                                  		;mov	word [rbs_buffer],boot_record
 13693                                  		;mov	[rbs_segment],ds
 13694                                  		
 13695 00001FFF BB[E0C9]                		mov	bx,boot_record
 13696                                  		;push	ds
 13697                                  		;pop	es
 13698                                  	
 13699                                  		;mov	byte [regs_x_ax+1],2 ; read
 13700                                  		;mov	byte [regs_x_ax],1   ; 1 sector
 13701                                  	
 13702                                  		;mov	al,[rbs_head]
 13703                                  		;mov	[regs_x_dx+1],al
 13704 00002002 8A7608                  		mov	dh,[rbs_head]	; Head (0 to 255)		
 13705                                  
 13706                                  		;mov	al,[rbs_sector]
 13707                                  		;mov	[regs_x_cx], al
 13708 00002005 8A4E0A                  		mov	cl,[rbs_sector]	; Sector (1 to 63)	
 13709                                  
 13710                                  		;mov	al,[rbs_disk]
 13711                                  		;add	al,80h
 13712                                  		;mov	[regs_x_dx],al
 13713 00002008 8A5606                  		mov	dl,[rbs_disk]
 13714 0000200B 80C280                  		add	dl,80h	; Hard disk drive number (80h to 87h)	
 13715                                  
 13716                                  		;cmp	word [rbs_cylinder],255
 13717                                  		;jbe	short read_bs_1
 13718                                  		
 13719 0000200E 8B4604                  		mov	ax,[rbs_cylinder] ; Cylinder (0 to 1023)
 13720 00002011 88C5                    		mov	ch,al  ; cylinder (low 8 bits)
 13721 00002013 3DFF00                  		cmp	ax,255
 13722 00002016 7608                    		jbe	short read_bs_1
 13723                                  		
 13724 00002018 D1E8                    		shr	ax,1
 13725 0000201A D1E8                    		shr	ax,1
 13726 0000201C 24C0                    		and	al,0C0h		 ; bits 8 and 9 of cylinder
 13727                                  		;or	[regs_x_cx],al	 ; -->
 13728 0000201E 08C1                    		or	cl,al		 ; bits 6 and 7 of sector
 13729                                  read_bs_1:
 13730                                  		;mov	al,[rbs_cylinder]
 13731                                  		;mov	[regs_x_cx+1],al
 13732                                  		
 13733                                  		;mov	ax,[rbs_buffer]
 13734                                  		;mov	[regs_x_bx],ax
 13735                                  		;mov	ax,[rbs_segment]
 13736                                  		;mov	[segregs_es],ax
 13737                                  		
 13738                                  		;mov	ax,segregs ;segregs_es
 13739                                  		;push	ax
 13740                                  		;mov	ax,regs	   ; regs_x_ax
 13741                                  		;push	ax
 13742                                  		;push	ax
 13743                                  		;call	DiskIo
 13744                                  		;add	sp,6
 13745                                  		;mov	al,[regs_x_cflag]
 13746                                  		;and	al,1
 13747                                  		;cmp	al,1
 13748                                  		;je	short read_bs_2
 13749                                  		;mov	al,1
 13750                                  		;jmp	short read_bs_3
 13751                                  
 13752 00002020 B80102                  		mov	ax,0201h	; Read 1 sector (CHS read)
 13753 00002023 CD13                    		int	13h
 13754 00002025 7204                    		jc	short read_bs_2
 13755                                  
 13756 00002027 B001                    		mov	al,1 ; TRUE
 13757 00002029 EB0D                    		jmp	short read_bs_3
 13758                                  read_bs_2:
 13759                                  		; 11/12/2018
 13760                                  		;mov	bl,[rbs_disk]
 13761                                  		;sub	bh,bh
 13762 0000202B 8B5E06                  		mov	bx,[rbs_disk]
 13763                                  
 13764 0000202E 88BF[50A1]              		mov	[good_disk+bx],bh ; 0
 13765                                  
 13766                                  		;mov	ax,79
 13767                                  		;push	ax	 ; Bottom Rigth Column (79)  
 13768                                  		;mov	ax,24
 13769                                  		;push	ax	 ; Bottom Row (24)
 13770                                  		;sub	ax,ax ; 0
 13771                                  		;push	ax	 ; Top Left Column (0)	
 13772                                  		;push	ax	 ; Top Row (0)
 13773                                  		;
 13774                                  		;call	clear_screen
 13775                                  
 13776                                  		; Clear screen (clear whole video page)
 13777 00002032 E829F4                  		call	CLS
 13778                                  
 13779 00002035 28C0                    		sub	al,al ; FALSE
 13780 00002037 F9                      		stc	; cf = 1  (error!)
 13781                                  read_bs_3:
 13782                                  		;mov	sp,bp ; 11/12/2018
 13783 00002038 5D                      		pop	bp
 13784                                  		;retn
 13785 00002039 C20800                  		retn	8 ; 22/12/2018
 13786                                  
 13787                                  ; ---------------------------------------------------------------------------
 13788                                  
 13789                                  ;/*  */
 13790                                  ;void DiskIo(InRegs,OutRegs,SegRegs)
 13791                                  ;union   REGS    *InRegs;
 13792                                  ;union   REGS    *OutRegs;
 13793                                  ;struct  SREGS   *SegRegs;
 13794                                  ;
 13795                                  ;BEGIN
 13796                                  ;   int86x((int)DISK,InRegs,OutRegs,SegRegs);		/* AC000 */
 13797                                  ;   return;
 13798                                  ;
 13799                                  ;END
 13800                                  
 13801                                  ;DiskIo:
 13802                                  ;	%define _InRegs_  bp+4
 13803                                  ;	%define _OutRegs_ bp+6
 13804                                  ;	%define _SegRegs_ bp+8
 13805                                  ;
 13806                                  ;		push	bp
 13807                                  ;		mov	bp,sp
 13808                                  ;		push	word [_SegRegs_]
 13809                                  ;		push	word [_OutRegs_]
 13810                                  ;		push	word [_InRegs_]
 13811                                  ;		mov	ax,13h
 13812                                  ;		push	ax
 13813                                  ;		call	int86x
 13814                                  ;		mov	sp,bp
 13815                                  ;		pop	bp
 13816                                  ;		retn
 13817                                  
 13818                                  ; int86x (Microsoft C 6.0 runtime library, MSDOS 6.0, 1991)	
 13819                                  ; ============================================================================
 13820                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 26/11/2018)
 13821                                  
 13822                                  ;int86x:
 13823                                  ;
 13824                                  ;	%define call_int	bp-16 ; dword
 13825                                  ;	%define int_opcode	bp-12 ; word
 13826                                  ;	%define retf_opcode_1	bp-10 ; byte
 13827                                  ;	%define inc_sp_opcode	bp-9  ; byte	
 13828                                  ;	%define retf_opcode_2	bp-8  ; byte
 13829                                  ;
 13830                                  ;	%define _disk_int_	bp+4  ; word
 13831                                  ;	%define _in_regs_	bp+6  ; word
 13832                                  ;	%define _out_regs_	bp+8  ; word
 13833                                  ;	%define _seg_regs_	bp+10  ;word
 13834                                  ;
 13835                                  ;		push	bp
 13836                                  ;		mov	bp,sp
 13837                                  ;		push	si
 13838                                  ;		push	di
 13839                                  ;		push	ds
 13840                                  ;		sub	sp,10
 13841                                  ;		mov	byte [int_opcode],0CDh
 13842                                  ;		mov	ax,[_disk_int_]
 13843                                  ;		mov	byte ptr [int_opcode+1],al
 13844                                  ;		cmp	al,25h
 13845                                  ;		je	short int86x_25h_26h
 13846                                  ;		cmp	al,26h
 13847                                  ;		je	short int86x_25h_26h
 13848                                  ;		mov	byte [retf_opcode_1],0CBh ; RETF
 13849                                  ;		jmp	short int86x_dos_func
 13850                                  ;int86x_25h_26h:
 13851                                  ;		mov	byte [retf_opcode_2],0CBh ; RETF
 13852                                  ;		mov	byte [inc_sp_opcode],44h  ; INC SP
 13853                                  ;		mov	byte [retf_opcode_1],44h  ; INC SP
 13854                                  ;int86x_dos_func:
 13855                                  ;		mov	[call_int+2],ss
 13856                                  ;		lea	ax,[int_opcode]
 13857                                  ;		mov	[call_int],ax
 13858                                  ;		mov	di,[_in_regs_]
 13859                                  ;		mov	ax,[di]
 13860                                  ;		mov	bx,[di+2]
 13861                                  ;		mov	cx,[di+4]
 13862                                  ;		mov	dx,[di+6]
 13863                                  ;		mov	si,[di+8]
 13864                                  ;		push	word [di+10]
 13865                                  ;		mov	di,[_seg_regs_]
 13866                                  ;		mov	es,[di]
 13867                                  ;		mov	ds,[di+6]
 13868                                  ;		pop	di
 13869                                  ;		push	bp
 13870                                  ;		call	far [call_int]
 13871                                  ;		pop	bp
 13872                                  ;		cld
 13873                                  ;		push	di
 13874                                  ;		push	ds
 13875                                  ;		push	ss
 13876                                  ;		pop	ds
 13877                                  ;		mov	di,[_seg_regs_]
 13878                                  ;		mov	[di],es
 13879                                  ;		pop	word [di+6]
 13880                                  ;		mov	di,[_out_regs_]
 13881                                  ;		mov	[di],ax
 13882                                  ;		mov	[di+2],bx
 13883                                  ;		mov	[di+4],cx
 13884                                  ;		mov	[di+6],dx
 13885                                  ;		mov	[di+8],si
 13886                                  ;		pop	word [di+10]
 13887                                  ;		jc	short int86x_dos_func_err
 13888                                  ;		xor	si,si
 13889                                  ;		jmp	short int86x_retn
 13890                                  ;int86x_dos_func_err:
 13891                                  ;		call	int86_err_conv
 13892                                  ;		mov	si,1
 13893                                  ;		mov	ax,[di]
 13894                                  ;int86x_retn:
 13895                                  ;		mov	[di+12],si
 13896                                  ;		add	sp,10
 13897                                  ;		pop	ds
 13898                                  ;		pop	di
 13899                                  ;		pop	si
 13900                                  ;		mov	sp,bp
 13901                                  ;		pop	bp
 13902                                  ;		retn
 13903                                  
 13904                                  ; ---------------------------------------------------------------------------
 13905                                  
 13906                                  ;int86_err_conv:
 13907                                  ;		xor	ah,ah
 13908                                  ;		call	error_conversion
 13909                                  ;		retn
 13910                                  
 13911                                  ; ---------------------------------------------------------------------------
 13912                                  
 13913                                  ;error_conversion:
 13914                                  ;		mov	[_doserrno],al
 13915                                  ;		or	ah,ah
 13916                                  ;		jnz	short errconv_5
 13917                                  ;		cmp	[_dosvermajor],3
 13918                                  ;		jb	short errconv_1
 13919                                  ;		cmp	al,22h
 13920                                  ;		jnb	short errconv_2
 13921                                  ;		cmp	al,20h
 13922                                  ;		jb	short errconv_1
 13923                                  ;		mov	al,5
 13924                                  ;		jmp	short errconv_3
 13925                                  ;errconv_1:
 13926                                  ;		cmp	al,13h
 13927                                  ;		jbe	short errconv_3
 13928                                  ;errconv_2:
 13929                                  ;		mov	al,13h
 13930                                  ;errconv_3:
 13931                                  ;		mov	bx,err_conv_tbl
 13932                                  ;		xlat
 13933                                  ;errconv_4:
 13934                                  ;		cbw
 13935                                  ;		mov	[errno],ax
 13936                                  ;		retn
 13937                                  ;errconv_5:
 13938                                  ;		mov	al,ah
 13939                                  ;		jmp	short errconv_4
 13940                                  
 13941                                  ; ----------------------------------------------------------------------------
 13942                                  ; vdisplay.c (FDISK, MSDOS 6.0, 1991)	
 13943                                  ; ----------------------------------------------------------------------------
 13944                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 27/11/2018)
 13945                                  
 13946                                  ;/******************************************************************************/
 13947                                  ;/*Routine name:  CHANGE_CURRENT_DRIVE                                         */
 13948                                  ;/******************************************************************************/
 13949                                  ;/*                                                                            */
 13950                                  ;/*Description:   This routine will change the current drive for FDISK         */
 13951                                  ;/*               to any valid drive (up to 7). It will also display a        */
 13952                                  ;/*               menu with disk information on all disks available for        */
 13953                                  ;/*               the system be FDISKed.                                       */
 13954                                  ;/*                                                                            */
 13955                                  ;/*Called Procedures:    Display                                               */
 13956                                  ;/*                      Find_part_free_space                                  */
 13957                                  ;/*                      Sort_Ext_Table                                        */
 13958                                  ;/*                      Get_Num_Input                                         */
 13959                                  ;/*                      Clear_Screen                                          */
 13960                                  ;/*                                                                            */
 13961                                  ;/*Change History: Created        1/06/89         DRM                          */
 13962                                  ;/*                                                                            */
 13963                                  ;/*Input:  None                                                                */
 13964                                  ;/*                                                                            */
 13965                                  ;/*Output: None                                                                */
 13966                                  ;/*                                                                            */
 13967                                  ;/******************************************************************************/
 13968                                  ;
 13969                                  ;void change_current_drive()                                         /* BN000 */
 13970                                  ;
 13971                                  ;BEGIN                                                               /* BN000 */
 13972                                  ;
 13973                                  ;    unsigned    i;                                                  /* BN000 */
 13974                                  ;/*C00 unsigned    j;    */                                          /* BN000 */
 13975                                  ;    unsigned    k;                                                  /* BN000 */
 13976                                  ;/*C32 char        drive_letter;         */                          /* BN000 */
 13977                                  ;/*C32 char        primary_drive_letter; */                          /* BN000 */
 13978                                  ;    char        drive_num;                                          /* BN000 */
 13979                                  ;    char        temp;                                               /* BN000 */
 13980                                  ;/*C11 char        temp1; */                                         /* BN000 */
 13981                                  ;    unsigned    temp1;                                                  /*C11*/
 13982                                  ;    unsigned    mbytes_free;                                            /*C11*/
 13983                                  ;    unsigned    percent_used;                                           /*C11*/
 13984                                  ;    unsigned    insert_offset;                                      /* BN000 */
 13985                                  ;    unsigned    input;                                              /* BN000 */
 13986                                  ;    char        max_input;                                          /* BN000 */
 13987                                  ;/*C00 char        blanks[9]; */                                     /* BN000 */
 13988                                  ;
 13989                                  ;    /* Initialize some variables */
 13990                                  ;    insert_offset = 0;                                              /* BN000 */
 13991                                  ;    drive_num = c(0);                                               /* BN000 */
 13992                                  ;/*C32  primary_drive_letter = c(SEA); */                            /* BN000 */
 13993                                  ;
 13994                                  ;   /* get the current drive letters */                                 /*C32*/
 13995                                  ;   get_letters();                                                      /*C32*/
 13996                                  ;
 13997                                  ;    /* Clear the whole screen for display */
 13998                                  ;    clear_screen(u(0),u(0),u(24),u(79));                            /* BN000 */
 13999                                  ;
 14000                                  ;    /* initialize all the inserts to blanks */
 14001                                  ;/*C19  memset(insert,c(' '),(31*15)); */                            /* BN000 */
 14002                                  ;    memset(insert,c(' '),(32*15));                                      /*C19*/
 14003                                  ;
 14004                                  ;    /* Save current disk */
 14005                                  ;    temp = cur_disk;                                                /* BN000 */
 14006                                  ;
 14007                                  ;    /* Display the heading */
 14008                                  ;    if (status_flag == FALSE)                                       /* BN000 */
 14009                                  ;        display(menu_47);                                           /* BN000 */
 14010                                  ;    else                                                            /* BN000 */
 14011                                  ;        display(menu_54);                                           /* BN000 */
 14012                                  ;
 14013                                  ;    /* Figure out which drive letter the extended partitions begin with  */
 14014                                  ;/*C32  drive_letter = (c(SEA) + primary_partition_count); */        /* BN000 */
 14015                                  ;
 14016                                  ;    /* Get the drive information in ascending order and put into array */
 14017                                  ;    for (i=u(0); i < u(number_of_drives); i++)                      /* BN000 */
 14018                                  ;
 14019                                  ;        BEGIN                                                       /* BN000 */
 14020                                  ;
 14021                                  ;        /* find freespace on current drive and display drive information */
 14022                                  ;        cur_disk = c(i);                                            /* BN000 */
 14023                                  ;/*C11   temp1 = find_part_free_space(PRIMARY); */                   /* BN000 */
 14024                                  ;        temp1 = part_table[cur_disk][0].mbytes_used +                   /*C11*/
 14025                                  ;                part_table[cur_disk][1].mbytes_used +                   /*C11*/
 14026                                  ;                part_table[cur_disk][2].mbytes_used +                   /*C11*/
 14027                                  ;                part_table[cur_disk][3].mbytes_used;                    /*C11*/
 14028                                  ;        if (temp1 < total_mbytes[cur_disk])                             /*C11*/
 14029                                  ;            mbytes_free = total_mbytes[cur_disk] - temp1;               /*C11*/
 14030                                  ;        else                                                            /*C11*/
 14031                                  ;            mbytes_free = u(0);                                         /*C11*/
 14032                                  ;        temp1 = part_table[cur_disk][0].percent_used +                  /*C11*/
 14033                                  ;                part_table[cur_disk][1].percent_used +                  /*C11*/
 14034                                  ;                part_table[cur_disk][2].percent_used +                  /*C11*/
 14035                                  ;                part_table[cur_disk][3].percent_used;                   /*C11*/
 14036                                  ;        if (temp1 < u(100))                                             /*C11*/
 14037                                  ;            percent_used = temp1;                                       /*C11*/
 14038                                  ;        else                                                            /*C11*/
 14039                                  ;            percent_used = u(100);                                      /*C11*/
 14040                                  ;        insert_offset += sprintf(&insert[insert_offset],"%1.0d%c%c%4.0d%4.0d%3.0d%%",
 14041                                  ;            (cur_disk + 1),
 14042                                  ;            ' ',
 14043                                  ;            ' ',
 14044                                  ;            total_mbytes[cur_disk],
 14045                                  ;/*C11       free_space[temp1].mbytes_unused,               */
 14046                                  ;/*C11       (u(100) - free_space[temp1].percent_unused));  */       /* BN000 */
 14047                                  ;            mbytes_free,                                                /*C11*/
 14048                                  ;            percent_used);                                              /*C11*/
 14049                                  ;        drive_num++;                                                /* BN000 */
 14050                                  ;
 14051                                  ;        /* Sort the partitions */
 14052                                  ;        sort_part_table(c(4));                                      /* BN000 */
 14053                                  ;        /* Now look at the partitions in order */
 14054                                  ;        for (k=u(0); k < u(4); k++)                                 /* BN000 */
 14055                                  ;            BEGIN                                                   /* BN000 */
 14056                                  ;            /* see if there is a primary partition */
 14057                                  ;            if( (part_table[cur_disk][sort[k]].sys_id == DOSNEW) ||
 14058                                  ;                (part_table[cur_disk][sort[k]].sys_id == DOS16) ||
 14059                                  ;                (part_table[cur_disk][sort[k]].sys_id == DOS12) )
 14060                                  ;                BEGIN                                               /* BN000 */
 14061                                  ;                insert_offset += sprintf(&insert[insert_offset],"%c%c%c%4.0d%8c",
 14062                                  ;                    ' ',
 14063                                  ;/*C32               c(primary_drive_letter),               */
 14064                                  ;/*C32               (drive_letter == c(' ') ) ? ' ' : ':', */
 14065                                  ;                    part_table[cur_disk][sort[k]].drive_letter,         /*C32*/
 14066                                  ;                    (part_table[cur_disk][sort[k]].drive_letter == c(' ') ) ? ' ' : ':',
 14067                                  ;                    part_table[cur_disk][sort[k]].mbytes_used,
 14068                                  ;                    ' ');                                           /* BN000 */
 14069                                  ;                    drive_num++;                                    /* BN000 */
 14070                                  ;/*C32               primary_drive_letter++; */                      /* BN000 */
 14071                                  ;                END                                                 /* BN000 */
 14072                                  ;            END                                                     /* BN000 */
 14073                                  ;
 14074                                  ;        /* loop thru the partitions, only print stuff if it is there */
 14075                                  ;
 14076                                  ;        /* Get the drives in order by location on disk */
 14077                                  ;        sort_ext_table(c(23));                                      /* BN000 */
 14078                                  ;
 14079                                  ;        for (k=u(0); k < u(23); k++)                                /* BN000 */
 14080                                  ;            BEGIN                                                   /* BN000 */
 14081                                  ;            /* if last drive letter was Z, print spaces */
 14082                                  ;/*C32       if ((drive_letter > c('Z')) ) */
 14083                                  ;/*C32            drive_letter = c(' ');   */                        /* BN000 */
 14084                                  ;            /* If it has a size, print it */
 14085                                  ;            if ( (ext_table[cur_disk][sort[k]].mbytes_used != u(0)) ||
 14086                                  ;                 (ext_table[cur_disk][sort[k]].percent_used != u(0)) ) /* BN000 */
 14087                                  ;
 14088                                  ;                BEGIN
 14089                                  ;                insert_offset += sprintf(&insert[insert_offset],"%c%c%c%4.0d%8c",
 14090                                  ;                    ' ',
 14091                                  ;/*C32               drive_letter, */
 14092                                  ;/*C32               (drive_letter == c(' ') ) ? ' ' : ':', */
 14093                                  ;                    ext_table[cur_disk][sort[k]].drive_letter,          /*C32*/
 14094                                  ;                    (ext_table[cur_disk][sort[k]].drive_letter == c(' ') ) ? ' ' : ':', /*C32*/
 14095                                  ;                    ext_table[cur_disk][sort[k]].mbytes_used,
 14096                                  ;                    ' ');                                           /* BN000 */
 14097                                  ;                    drive_num++;                                    /* BN000 */
 14098                                  ;/*C32               drive_letter++; */                              /* BN000 */
 14099                                  ;                END                                                 /* BN000 */
 14100                                  ;            END                                                     /* BN000 */
 14101                                  ;        END                                                         /* BN000 */
 14102                                  ;
 14103                                  ;    /* Display the column of drives */
 14104                                  ;    BEGIN                                                           /* BN000 */
 14105                                  ;
 14106                                  ;    if ( drive_num > 0 )                                            /* BN000 */
 14107                                  ;        BEGIN                                                       /* BN000 */
 14108                                  ;        pinsert = &insert[0];                                       /* BN000 */
 14109                                  ;        display(menu_48);                                           /* BN000 */
 14110                                  ;        END                                                         /* BN000 */
 14111                                  ;
 14112                                  ;    if ( drive_num > 8 )                                            /* BN000 */
 14113                                  ;        BEGIN                                                       /* BN000 */
 14114                                  ;        pinsert = &insert[8*15];                                    /* BN000 */
 14115                                  ;        display(menu_49);                                           /* BN000 */
 14116                                  ;        END                                                         /* BN000 */
 14117                                  ;
 14118                                  ;    if ( drive_num > 16 )                                           /* BN000 */
 14119                                  ;        BEGIN                                                       /* BN000 */
 14120                                  ;        pinsert = &insert[16*15];                                   /* BN000 */
 14121                                  ;        display(menu_50);                                           /* BN000 */
 14122                                  ;        END                                                         /* BN000 */
 14123                                  ;
 14124                                  ;    if ( drive_num > 24 )                                           /* BN000 */
 14125                                  ;        BEGIN                                                       /* BN000 */
 14126                                  ;        pinsert = &insert[24*15];                                   /* BN000 */
 14127                                  ;        display(menu_51);                                           /* BN000 */
 14128                                  ;        END                                                         /* BN000 */
 14129                                  ;    pinsert = &insert[0];                                           /* BN000 */
 14130                                  ;    END                                                             /* BN000 */
 14131                                  ;
 14132                                  ;   /* display Mbytes = line */
 14133                                  ;   display(menu_52);                                               /* BN000 */
 14134                                  ;
 14135                                  ;    /* reset current disk back to original */
 14136                                  ;    cur_disk = temp;                                                /* BN000 */
 14137                                  ;
 14138                                  ;    if (status_flag == FALSE)                                       /* BN000 */
 14139                                  ;        BEGIN
 14140                                  ;        /* Display prompt of which disk */
 14141                                  ;        sprintf(insert,"%1.0d%1.0d",number_of_drives,(cur_disk+1)); /* BN000 */
 14142                                  ;        display(menu_53);                                           /* BN000 */
 14143                                  ;
 14144                                  ;        /* ESC line at bottom of screen */
 14145                                  ;        display(menu_11);                                           /* BN000 */
 14146                                  ;
 14147                                  ;        max_input = c(number_of_drives);                            /* BN000 */
 14148                                  ;
 14149                                  ;        valid_input = (FLAG)FALSE;                                  /* BN000 */
 14150                                  ;
 14151                                  ;       /* Get the input from screen */
 14152                                  ;        while (!valid_input)                                        /* BN000 */
 14153                                  ;            BEGIN                                                   /* BN000 */
 14154                                  ;            input = get_num_input(c(cur_disk+1),max_input,input_row,input_col);
 14155                                  ;            clear_screen(u(21),u(0),u(23),u(79));                   /* BN000 */
 14156                                  ;
 14157                                  ;           /* set current disk to zero base */
 14158                                  ;           if (input != u(ESC)) cur_disk = c(input-'1');           /* BN000 */
 14159                                  ;            END                                                     /* BN000 */
 14160                                  ;
 14161                                  ;        /* clear the screen before going back to main menu */
 14162                                  ;        clear_screen(u(0),u(0),u(24),u(79));                        /* BN000 */
 14163                                  ;        END                                                         /* BN000 */
 14164                                  ;    return;                                                         /* BN000 */
 14165                                  ;END                                                                 /* BN000 */
 14166                                  
 14167 0000203C 0000                    usp: dw 0
 14168                                  
 14169                                  change_current_drive:
 14170                                  				; 12/12/2018
 14171                                  	%define _k		bp-16 ; bp-20 ; unsigned int
 14172                                  	%define _insert_offset	bp-14 ; bp-18 ; unsigned int
 14173                                  	%define _i		bp-12 ; bp-16 ; unsigned int
 14174                                  	%define _drive_num	bp-10 ; bp-14 ; char
 14175                                  	%define _temp_		bp-8  ; bp-10 ; char
 14176                                  	%define _mbytes_free	bp-6  ; bp-8  ; unsigned int
 14177                                  	%define _max_input	bp-4  ; bp-6  ; unsigned int
 14178                                  	;%define _percent_used	bp-4  ;	bp-4  ; unsigned int
 14179                                  	%define _input_		bp-2  ; bp-2  ; unsigned int
 14180                                  
 14181 0000203E 55                      		push	bp
 14182 0000203F 89E5                    		mov	bp,sp
 14183                                  		;sub	sp,20
 14184 00002041 83EC10                  		sub	sp,16 ; 12/12/2018
 14185 00002044 56                      		push	si
 14186                                  
 14187                                  		;/* Initialize some variables */
 14188                                  		;mov	word [_drive_num],0
 14189 00002045 31C0                    		xor	ax,ax ; 0
 14190 00002047 8946F6                  		mov	[_drive_num],ax ; 0		
 14191 0000204A 8946F2                  		mov	[_insert_offset],ax ; 0
 14192                                  
 14193                                  		;/* get the current drive letters */ 
 14194 0000204D E89007                  		call	get_letters
 14195                                  		
 14196                                  		;/* Clear the whole screen for display */
 14197                                  		;mov	ax,79
 14198                                  		;push	ax
 14199                                  		;mov	ax,24
 14200                                  		;push	ax
 14201                                  		;sub	ax,ax ; 0
 14202                                  		;mov	[_insert_offset],ax
 14203                                  		;push	ax
 14204                                  		;push	ax
 14205                                  		;call	clear_screen
 14206                                  		;;add	sp,8
 14207                                  
 14208                                  		; Clear screen (clear whole video page)
 14209 00002050 E80BF4                  		call	CLS
 14210                                  
 14211                                  		;/* initialize all the inserts to blanks */
 14212                                  		;memset(insert,c(' '),(32*15));            
 14213                                  
 14214                                  		;mov	ax,480
 14215                                  		;push	ax
 14216                                  		;mov	ax,' '
 14217                                  		;push	ax
 14218                                  		;mov	ax,insert
 14219                                  		;push	ax
 14220                                  		;call	memset
 14221                                  		;add	sp,6
 14222                                  
 14223                                  		; 01/12/2018
 14224                                  		; memset shortcut
 14225 00002053 B020                    		mov	al,' '
 14226 00002055 B9E001                  		mov	cx,480
 14227 00002058 BF[F4CC]                		mov	di,insert
 14228                                  		;push	ds
 14229                                  		;pop	es
 14230 0000205B F3AA                    		rep	stosb
 14231                                  
 14232                                  		;/* Save current disk */
 14233 0000205D A0[E2CB]                		mov	al,[cur_disk]
 14234 00002060 8846F8                  		mov	[_temp_],al
 14235                                  
 14236                                  		;/* Display the heading */
 14237                                  		;if (status_flag == FALSE)
 14238                                  		;   display(menu_47);
 14239                                  		;else
 14240                                  		;   display(menu_54);
 14241                                  
 14242 00002063 803E[E2C3]00            		cmp	byte [status_flag],0
 14243 00002068 7507                    		jne	short ccd_1
 14244                                  		;push	word [menu_47_segment]
 14245 0000206A 1E                      		push	ds
 14246 0000206B FF36[579E]              		push	word [menu_47_offset]
 14247 0000206F EB05                    		jmp	short ccd_2
 14248                                  ccd_1:
 14249                                  		;push	word [menu_54_segment]
 14250 00002071 1E                      		push	ds
 14251 00002072 FF36[659E]              		push	word [menu_54_offset]
 14252                                  ccd_2:
 14253 00002076 E8ABF5                  		call	display
 14254                                  		;pop	bx
 14255                                  		;pop	bx
 14256                                  
 14257                                  	;/* Get the drive information in ascending order and put into array */
 14258                                  	;for (i=u(0); i < u(number_of_drives); i++)  
 14259                                  
 14260 00002079 C746F40000              		mov	word [_i],0
 14261 0000207E E92901                  		jmp	ccd_20
 14262                                  ccd_3:
 14263 00002081 C746FA0000              		mov	word [_mbytes_free],0
 14264                                  ccd_4:
 14265                                  	;temp1 = part_table[cur_disk][0].percent_used +
 14266                                  	;        part_table[cur_disk][1].percent_used +
 14267                                  	;        part_table[cur_disk][2].percent_used +
 14268                                  	;        part_table[cur_disk][3].percent_used;
 14269                                  	;if (temp1 < u(100))
 14270                                  	;   percent_used = temp1;
 14271                                  	;else
 14272                                  	;   percent_used = u(100);
 14273                                  
 14274                                  		;mov	al,[cur_disk]
 14275                                  		;cbw
 14276                                  		;;imul	cx
 14277                                  		;mul	cx ; 184, 4*46
 14278                                  		;mov	bx,ax
 14279                                  		;mov	ax,[part_table_percent_used+bx]
 14280                                  		;add	ax,[pt_part4_percent_used+bx]
 14281                                  		;add	ax,[pt_part3_percent_used+bx]
 14282                                  		;add	ax,[pt_part2_percent_used+bx]
 14283                                  
 14284                                  		; 27/11/2018 (si from ccd_20)
 14285 00002086 8B84[36C4]              		mov	ax,[part_table_percent_used+si] ; +***
 14286 0000208A 0384[C0C4]              		add	ax,[pt_part4_percent_used+si]
 14287 0000208E 0384[92C4]              		add	ax,[pt_part3_percent_used+si]
 14288 00002092 0384[64C4]              		add	ax,[pt_part2_percent_used+si]
 14289                                  		
 14290                                  		;cmp	ax,100
 14291                                  		;jnb	short ccd_5
 14292                                  		;mov	[_percent_used],ax
 14293                                  		;jmp	short ccd_6
 14294                                  		
 14295                                  		; 09/12/2018
 14296 00002096 83F864                  		cmp	ax,100
 14297 00002099 7603                    		jna	short ccd_5
 14298 0000209B B86400                  		mov	ax,100
 14299                                  ccd_5:
 14300                                  		;mov	word [_percent_used],100
 14301                                  		; 12/12/2018
 14302                                  		;mov	[_percent_used],ax ; 09/12/2018	
 14303                                  ccd_6:
 14304                                  	;insert_offset += sprintf(&insert[insert_offset],"%1.0d%c%c%4.0d%4.0d%3.0d%%",
 14305                                  	;    (cur_disk + 1),' ',' ',total_mbytes[cur_disk],mbytes_free,percent_used);                                              /*C11*/
 14306                                  	;drive_num++;
 14307                                  
 14308                                  		;push	word [_percent_used]
 14309 0000209E 50                      		push	ax ; 12/12/2018 
 14310 0000209F FF76FA                  		push	word [_mbytes_free]
 14311 000020A2 A0[E2CB]                		mov	al,[cur_disk]
 14312 000020A5 98                      		cbw
 14313                                  		;mov	bx,ax
 14314                                  		;shl	bx,1
 14315                                  		; 27/11/2018 (bx from ccd_21)
 14316 000020A6 FFB7[D6A0]              		push	word [total_mbytes+bx] ; ++***
 14317                                  		;mov	cx,' '
 14318 000020AA B120                    		mov	cl,' ' ; 01/12/2018
 14319 000020AC 51                      		push	cx
 14320 000020AD 51                      		push	cx
 14321 000020AE 40                      		inc	ax
 14322 000020AF 50                      		push	ax
 14323 000020B0 B8[0F70]                		mov	ax,cd_pt_row_format ; "%1.0d%c%c%4.1d%4.1d%3.1d%%"
 14324 000020B3 50                      		push	ax
 14325 000020B4 8B46F2                  		mov	ax,[_insert_offset]
 14326 000020B7 05[F4CC]                		add	ax,insert
 14327 000020BA 50                      		push	ax
 14328 000020BB E80702                  		call	sprintf
 14329 000020BE 83C410                  		add	sp,16
 14330 000020C1 0146F2                  		add	[_insert_offset],ax
 14331 000020C4 FE46F6                  		inc	byte [_drive_num]
 14332                                  
 14333                                  		;/* Sort the partitions */
 14334                                  		;sort_part_table(c(4));
 14335                                  		;mov	al,4
 14336                                  		;push	ax
 14337 000020C7 B104                    		mov	cl,4 ; 12/12/2018
 14338 000020C9 E8D908                  		call	sort_part_table
 14339                                  		;pop	bx
 14340                                  
 14341                                  		;/* Now look at the partitions in order */
 14342                                  		;for (k=u(0); k < u(4); k++)
 14343                                  
 14344 000020CC C746F00000              		mov	word [_k],0
 14345 000020D1 EB32                    		jmp	short ccd_10
 14346                                  ccd_7:
 14347                                  		; 28/11/2018
 14348                                  		; al = ' ', ah = 0
 14349 000020D3 80BF[4DC4]20            		cmp	byte [part_table_drive_letter+bx],' '
 14350 000020D8 7402                    		je	short ccd_8
 14351                                  		;mov	ax,':'
 14352 000020DA B03A                    		mov	al,':'
 14353                                  ccd_8:
 14354 000020DC 50                      		push	ax
 14355 000020DD 8A87[4DC4]              		mov	al,[part_table_drive_letter+bx]
 14356                                  		;cbw
 14357 000020E1 50                      		push	ax
 14358                                  		;mov	ax,' '
 14359 000020E2 B020                    		mov	al,' '
 14360 000020E4 50                      		push	ax
 14361 000020E5 B8[2A70]                		mov	ax,drv_mb_row_format ; "%c%c%c%4.1d%8c"
 14362 000020E8 50                      		push	ax
 14363 000020E9 8B46F2                  		mov	ax,[_insert_offset]
 14364 000020EC 05[F4CC]                		add	ax,insert
 14365 000020EF 50                      		push	ax
 14366 000020F0 E8D201                  		call	sprintf
 14367 000020F3 83C40E                  		add	sp,14
 14368 000020F6 0146F2                  		add	[_insert_offset],ax
 14369                                  
 14370 000020F9 FE46F6                  		inc	byte [_drive_num]
 14371                                  ccd_9:
 14372 000020FC FE46F0                  		inc	byte [_k]
 14373                                  ;ccd_10:
 14374 000020FF 807EF004                		cmp	byte [_k],4
 14375 00002103 7336                    		jnb	short ccd_13
 14376                                  ccd_10: 			; 09/12/2018
 14377                                  
 14378                                  		;/* see if there is a primary partition */
 14379                                  		;if( (part_table[cur_disk][sort[k]].sys_id == DOSNEW) ||
 14380                                  		;    (part_table[cur_disk][sort[k]].sys_id == DOS16) ||
 14381                                  		;    (part_table[cur_disk][sort[k]].sys_id == DOS12) )
 14382                                  
 14383                                  		; 28/11/2018
 14384                                  
 14385                                  		;mov	al,[cur_disk]
 14386                                  		;cbw
 14387                                  		;shl	ax,1
 14388                                  		;shl	ax,1
 14389                                  		;mov	cx,ax
 14390 00002105 8A0E[E2CB]              		mov	cl,[cur_disk]
 14391                                  		;xor	ch,ch
 14392                                  		; 01/12/2018
 14393 00002109 D0E1                    		shl	cl,1
 14394 0000210B D0E1                    		shl	cl,1
 14395                                  
 14396 0000210D 8B5EF0                  		mov	bx,[_k]
 14397 00002110 8A87[F0C3]              		mov	al,[sort+bx] ; 07/12/2018
 14398                                  
 14399                                  		;cbw
 14400                                  		;add	ax,cx
 14401 00002114 00C8                    		add	al,cl
 14402                                  		;mov	cx,46
 14403                                  		;imul	cx
 14404 00002116 B12E                    		mov	cl,46
 14405 00002118 F6E1                    		mul	cl
 14406                                  
 14407 0000211A 89C3                    		mov	bx,ax ;+++**
 14408                                  
 14409 0000211C 80BF[25C4]06            		cmp	byte [part_table_sys_id+bx],DOSNEW ; 6
 14410 00002121 740E                    		je	short ccd_11
 14411 00002123 80BF[25C4]04            		cmp	byte [part_table_sys_id+bx],DOS16  ; 4
 14412 00002128 7407                    		je	short ccd_11
 14413 0000212A 80BF[25C4]01            		cmp	byte [part_table_sys_id+bx],DOS12  ; 1
 14414 0000212F 75CB                    		jne	short ccd_9
 14415                                  ccd_11:
 14416                                  	;insert_offset += sprintf(&insert[insert_offset],"%c%c%c%4.0d%8c",
 14417                                  	;	' ',part_table[cur_disk][sort[k]].drive_letter,
 14418                                  	;	(part_table[cur_disk][sort[k]].drive_letter == c(' ') ) ? ' ' : ':',
 14419                                  	;	part_table[cur_disk][sort[k]].mbytes_used,' '); 
 14420                                  	; drive_num++;
 14421                                  
 14422 00002131 B82000                  		mov	ax,' '
 14423 00002134 50                      		push	ax
 14424                                  
 14425                                  		; 28/11/2018
 14426                                  		;mov	al,[cur_disk]
 14427                                  		;cbw
 14428                                  		;shl	ax,1
 14429                                  		;shl	ax,1
 14430                                  		;mov	bx,[_k]
 14431                                  		;mov	cx,ax
 14432                                  		;mov	al,[sort+bx] ; 07/12/2018
 14433                                  		;cbw
 14434                                  		;add	ax,cx
 14435                                  		;mov	cx,46
 14436                                  		;imul	cx
 14437                                  		;mov	bx,ax ; +++**
 14438                                  		
 14439 00002135 FFB7[34C4]              		push	word [part_table_mbytes_used+bx]
 14440                                  		;cmp	byte [part_table_drive_letter+bx],' '
 14441                                  		;;je	short ccd_12
 14442                                  		;jmp	short ccd_7
 14443                                  		;je	short ccd_8
 14444 00002139 EB98                    		jmp	short ccd_7
 14445                                  ;ccd_12:
 14446                                  		;mov	ax,' ' ; 28/11/2018
 14447                                  		;jmp	short ccd_8
 14448                                  ccd_13:
 14449                                  		;/* Get the drives in order by location on disk */
 14450                                  		;sort_ext_table(c(23));   
 14451                                  
 14452                                  		;mov	al,23
 14453                                  		;push	ax
 14454 0000213B B117                    		mov	cl,23 ; 12/12/2018
 14455 0000213D E8CF08                  		call	sort_ext_table
 14456                                  		;pop	bx
 14457                                  
 14458                                  		;for (k=u(0); k < u(23); k++)
 14459                                  
 14460 00002140 C646F000                		mov	byte [_k],0
 14461 00002144 EB32                    		jmp	short ccd_17
 14462                                  ccd_14:
 14463                                  		; 01/12/2018
 14464                                  		;mov	ax,':'
 14465                                  
 14466                                  		; al = ' ', ah = 0
 14467 00002146 80BF[85A1]20            		cmp	byte [ext_table_drive_letter+bx],' '
 14468 0000214B 7402                    		je	short ccd_15
 14469                                  		;mov	ax,':'
 14470 0000214D B03A                    		mov	al,':'
 14471                                  ccd_15:
 14472 0000214F 50                      		push	ax
 14473 00002150 8A87[85A1]              		mov	al,[ext_table_drive_letter+bx]
 14474                                  		;cbw
 14475 00002154 50                      		push	ax
 14476                                  		;mov	ax,' '
 14477 00002155 B020                    		mov	al,' '
 14478 00002157 50                      		push	ax
 14479 00002158 B8[3970]                		mov	ax,cdrv_mb_format ; "%c%c%c%4.1d%8c"
 14480 0000215B 50                      		push	ax
 14481 0000215C 8B46F2                  		mov	ax,[_insert_offset]
 14482 0000215F 05[F4CC]                		add	ax,insert
 14483 00002162 50                      		push	ax
 14484 00002163 E85F01                  		call	sprintf
 14485 00002166 83C40E                  		add	sp,14
 14486 00002169 0146F2                  		add	[_insert_offset],ax
 14487                                  
 14488 0000216C FE46F6                  		inc	byte [_drive_num]
 14489                                  ccd_16:
 14490 0000216F FE46F0                  		inc	byte [_k]
 14491                                  ;ccd_17:
 14492 00002172 807EF017                		cmp	byte [_k],23
 14493 00002176 732F                    		jnb	short ccd_19
 14494                                  ccd_17: 		; 13/12/2018
 14495                                  		;/* If it has a size, print it */
 14496                                  		;if ( (ext_table[cur_disk][sort[k]].mbytes_used != u(0)) ||
 14497                                  		;     (ext_table[cur_disk][sort[k]].percent_used != u(0)) )
 14498                                  
 14499 00002178 B018                    		mov	al,24
 14500                                  		;imul	byte [cur_disk]
 14501 0000217A F626[E2CB]              		mul	byte [cur_disk] ; 0 to 7
 14502 0000217E 8B5EF0                  		mov	bx,[_k]
 14503 00002181 89C1                    		mov	cx,ax ; ah = 0 (ax<=168)
 14504 00002183 8A87[F0C3]              		mov	al,[sort+bx] ; 07/12/2018
 14505                                  		;cbw
 14506                                  		;add	ax,cx
 14507 00002187 00C8                    		add	al,cl
 14508                                  		;mov	cx,46
 14509                                  		;imul	cx
 14510 00002189 B12E                    		mov	cl,46
 14511 0000218B F6E1                    		mul	cl
 14512 0000218D 89C3                    		mov	bx,ax ; +++**+
 14513 0000218F 83BF[6CA1]00            		cmp	word [ext_table_mbytes_used+bx],0
 14514 00002194 7507                    		jne	short ccd_18
 14515 00002196 83BF[6EA1]00            		cmp	word [ext_table_percent_used+bx],0
 14516 0000219B 74D2                    		je	short ccd_16
 14517                                  ccd_18:
 14518                                  	;insert_offset += sprintf(&insert[insert_offset],"%c%c%c%4.0d%8c",' ',
 14519                                  	;   ext_table[cur_disk][sort[k]].drive_letter,
 14520                                  	;   (ext_table[cur_disk][sort[k]].drive_letter == c(' ') ) ? ' ' : ':',
 14521                                  	;   ext_table[cur_disk][sort[k]].mbytes_used,' ');
 14522                                  	;drive_num++;
 14523                                  
 14524 0000219D B82000                  		mov	ax,' '
 14525 000021A0 50                      		push	ax
 14526                                  		
 14527                                  		; 01/12/2018
 14528                                  
 14529                                  		;mov	al,24
 14530                                  		;;imul	byte [cur_disk]
 14531                                  		;mul	byte [cur_disk]
 14532                                  		;mov	bx,[_k]
 14533                                  		;mov	cx,ax
 14534                                  		;mov	al,[sort+bx] ; 07/12/2018
 14535                                  		;cbw
 14536                                  		;add	ax,cx
 14537                                  		;mov	cx,46
 14538                                  		;;imul	cx
 14539                                  		;mul	cx
 14540                                  		;mov	bx,ax ; +++**+
 14541                                  		
 14542 000021A1 FFB7[6CA1]              		push	word [ext_table_mbytes_used+bx]
 14543                                  		;cmp	byte [ext_table_drive_letter+bx],' '
 14544                                  		;jne	short ccd_14
 14545                                  		;mov	ax,' '
 14546                                  		;jmp	short ccd_15
 14547 000021A5 EB9F                    		jmp	short ccd_14 ; 01/12/2018
 14548                                  ccd_19:
 14549 000021A7 FE46F4                  		inc	byte [_i]
 14550                                  ccd_20:
 14551                                  	;/* find freespace on current drive and display drive information */
 14552                                  		;cur_disk = c(i);
 14553                                  		;mov	al,[number_of_drives]
 14554                                  		;sub	ah,ah
 14555                                  		;;cmp	ax,[_i]
 14556                                  		;cmp	al,[_i] ; 01/12/2018
 14557                                  		;jbe	short ccd_22
 14558                                  		;mov	al,[_i]
 14559                                  		;mov	[cur_disk],al
 14560                                  
 14561                                  		; 10/12/2018
 14562                                  		;mov	al,[_i]
 14563                                  		;sub	ah,ah
 14564 000021AA 8B46F4                  		mov	ax,[_i] ; 12/12/2018
 14565 000021AD 3A06[E3C3]              		cmp	al,[number_of_drives]
 14566 000021B1 7333                    		jnb	short ccd_22
 14567                                  
 14568 000021B3 A2[E2CB]                		mov	[cur_disk],al	
 14569                                  
 14570                                  	;temp1 = part_table[cur_disk][0].mbytes_used +
 14571                                  	;        part_table[cur_disk][1].mbytes_used +
 14572                                  	;        part_table[cur_disk][2].mbytes_used +
 14573                                  	;        part_table[cur_disk][3].mbytes_used;
 14574                                  
 14575                                  	;if (temp1 < total_mbytes[cur_disk])
 14576                                  	;   mbytes_free = total_mbytes[cur_disk] - temp1
 14577                                  	;else
 14578                                  	;   mbytes_free = u(0);
 14579                                  
 14580                                  		;cbw
 14581 000021B6 B9B800                  		mov	cx,184 ; 4*46
 14582 000021B9 89C3                    		mov	bx,ax  ; [cur_disk], 0 to 7
 14583                                  		;imul	cx
 14584                                  		;mul	cx
 14585 000021BB F6E1                    		mul	cl
 14586 000021BD 89C6                    		mov	si,ax
 14587 000021BF 8B84[34C4]              		mov	ax,[part_table_mbytes_used+si] ; +***
 14588 000021C3 0384[BEC4]              		add	ax,[pt_part4_mbytes_used+si]
 14589 000021C7 0384[90C4]              		add	ax,[pt_part3_mbytes_used+si]
 14590 000021CB 0384[62C4]              		add	ax,[pt_part2_mbytes_used+si]
 14591 000021CF D1E3                    		shl	bx,1
 14592 000021D1 3B87[D6A0]              		cmp	ax,[total_mbytes+bx]
 14593 000021D5 7203                    		jb	short ccd_21
 14594 000021D7 E9A7FE                  		jmp	ccd_3
 14595                                  ccd_21:
 14596 000021DA 2B87[D6A0]              		sub	ax,[total_mbytes+bx] ; ++***
 14597 000021DE F7D8                    		neg	ax
 14598 000021E0 8946FA                  		mov	[_mbytes_free],ax
 14599 000021E3 E9A0FE                  		jmp	ccd_4
 14600                                  ccd_22:
 14601                                  		;/* Display the column of drives */
 14602                                  	
 14603                                  		;if ( drive_num > 0 )
 14604                                  		;     BEGIN
 14605                                  		;     pinsert = &insert[0];
 14606                                  		;     display(menu_48);
 14607                                  		;     END
 14608                                  
 14609 000021E6 807EF600                		cmp	byte [_drive_num],0
 14610                                  		;jle	short ccd_23
 14611 000021EA 764A                    		jna	short ccd_26 ; 01/12/2018
 14612                                  		
 14613 000021EC C706[9870][F4CC]        		mov	word [pinsert],insert
 14614                                  
 14615                                  		;push	word [menu_48_segment]
 14616 000021F2 1E                      		push	ds
 14617 000021F3 FF36[599E]              		push	word [menu_48_offset]
 14618 000021F7 E82AF4                  		call	display
 14619                                  		;pop	bx
 14620                                  		;pop	bx
 14621                                  ccd_23:
 14622                                  		;if ( drive_num > 8 )
 14623                                  		;     BEGIN
 14624                                  		;     pinsert = &insert[8*15];
 14625                                  		;     display(menu_49);
 14626                                  		;     END             
 14627                                  
 14628 000021FA 807EF608                		cmp	byte [_drive_num],8
 14629                                  		;jle	short ccd_24
 14630 000021FE 7636                    		jna	short ccd_26 ; 01/12/2018
 14631                                  
 14632 00002200 C706[9870][6CCD]        		mov	word [pinsert],insert+120
 14633                                  
 14634                                  		;push	word [menu_49_segment]
 14635 00002206 1E                      		push	ds
 14636 00002207 FF36[5B9E]              		push	word [menu_49_offset]
 14637 0000220B E816F4                  		call	display
 14638                                  		;pop	bx
 14639                                  		;pop	bx
 14640                                  ccd_24:
 14641                                  		;if ( drive_num > 16 )
 14642                                  		;     BEGIN
 14643                                  		;     pinsert = &insert[16*15];
 14644                                  		;     display(menu_50);
 14645                                  		;     END
 14646                                  
 14647 0000220E 807EF610                		cmp	byte [_drive_num],16
 14648                                  		;jle	short ccd_25
 14649 00002212 7622                    		jna	short ccd_26 ; 01/12/2018
 14650                                  
 14651 00002214 C706[9870][E4CD]        		mov	word [pinsert],insert+240
 14652                                  
 14653                                  		;push	word [menu_50_segment]
 14654 0000221A 1E                      		push	ds
 14655 0000221B FF36[5D9E]              		push	word [menu_50_offset]
 14656 0000221F E802F4                  		call	display
 14657                                  		;pop	bx
 14658                                  		;pop	bx
 14659                                  ccd_25:
 14660                                  		;if ( drive_num > 24 )
 14661                                  		;     BEGIN
 14662                                  		;     pinsert = &insert[24*15];
 14663                                  		;     display(menu_51);
 14664                                  		;     END
 14665                                  		;pinsert = &insert[0];  
 14666                                  
 14667 00002222 807EF618                		cmp	byte [_drive_num],24
 14668                                  		;jle	short ccd_26
 14669 00002226 760E                    		jna	short ccd_26 ; 01/12/2018
 14670                                  
 14671 00002228 C706[9870][5CCE]        		mov	word [pinsert],insert+360
 14672                                  
 14673                                  		;push	word [menu_51_segment]
 14674 0000222E 1E                      		push	ds
 14675 0000222F FF36[5F9E]              		push	word [menu_51_offset]
 14676 00002233 E8EEF3                  		call	display
 14677                                  		;pop	bx
 14678                                  		;pop	bx
 14679                                  ccd_26:
 14680 00002236 C706[9870][F4CC]        		mov	word [pinsert],insert
 14681                                  
 14682                                  		;/* display Mbytes = line */
 14683                                  		;display(menu_52);
 14684                                  		;push	word [menu_52_segment]
 14685 0000223C 1E                      		push	ds
 14686 0000223D FF36[619E]              		push	word [menu_52_offset]
 14687 00002241 E8E0F3                  		call	display
 14688                                  		;pop	bx
 14689                                  		;pop	bx
 14690                                  
 14691                                  		;/* reset current disk back to original */
 14692                                  		;cur_disk = temp;  
 14693 00002244 8A46F8                  		mov	al,[_temp_]
 14694 00002247 A2[E2CB]                		mov	[cur_disk],al
 14695                                  
 14696                                  		;if (status_flag == FALSE)  
 14697 0000224A 803E[E2C3]00            		cmp	byte [status_flag],0
 14698 0000224F 756F                    		jne	short ccd_30 ; 09/12/2018
 14699                                  ccd_27:
 14700                                  		;/* Display prompt of which disk */
 14701                                  		;sprintf(insert,"%1.0d%1.0d",number_of_drives,(cur_disk+1));
 14702                                  		;display(menu_53); 
 14703                                  
 14704                                  		;cbw
 14705                                  		;inc	ax
 14706 00002251 28E4                    		sub	ah,ah
 14707 00002253 FEC0                    		inc	al  ; [cur_disk] + 1
 14708 00002255 50                      		push	ax
 14709 00002256 A0[E3C3]                		mov	al,[number_of_drives]
 14710                                  		;sub	ah,ah
 14711 00002259 50                      		push	ax
 14712 0000225A B8[4870]                		mov	ax,cdrive_format ; "%1.0d%1.0d"
 14713 0000225D 50                      		push	ax
 14714 0000225E B8[F4CC]                		mov	ax,insert
 14715 00002261 50                      		push	ax
 14716 00002262 E86000                  		call	sprintf
 14717 00002265 83C408                  		add	sp,8
 14718                                  
 14719                                  		;push	word [menu_53_segment]
 14720 00002268 1E                      		push	ds
 14721 00002269 FF36[639E]              		push	word [menu_53_offset]
 14722 0000226D E8B4F3                  		call	display
 14723                                  		;pop	bx
 14724                                  		;pop	bx
 14725                                  
 14726                                  		;/* ESC line at bottom of screen */
 14727                                  		;display(menu_11);                            
 14728                                  		
 14729                                  		;;push	word [menu_11_segment]
 14730                                  		;push	ds
 14731                                  		;push	word [menu_11_offset]
 14732                                  		;call	display
 14733                                  		;;pop	bx
 14734                                  		;;pop	bx
 14735                                  
 14736 00002270 E8FB0B                  		call	display_menu_11 ; 31/12/2018
 14737                                  
 14738                                  		;max_input = c(number_of_drives);
 14739 00002273 A0[E3C3]                		mov	al,[number_of_drives]
 14740 00002276 8846FC                  		mov	[_max_input],al
 14741                                  		;valid_input = (FLAG)FALSE;
 14742 00002279 C606[ECCB]00            		mov	byte [valid_input],0
 14743                                  ccd_28:
 14744                                  		;/* Get the input from screen */
 14745                                  	;input = get_num_input(c(cur_disk+1),max_input,input_row,input_col);
 14746                                  
 14747 0000227E FF36[AAA0]              		push	word [input_col]
 14748 00002282 FF36[4CA1]              		push	word [input_row]
 14749 00002286 8A46FC                  		mov	al,[_max_input]
 14750 00002289 50                      		push	ax
 14751 0000228A A0[E2CB]                		mov	al,[cur_disk]
 14752 0000228D FEC0                    		inc	al
 14753 0000228F 50                      		push	ax
 14754 00002290 E8E107                  		call	get_num_input
 14755                                  		;add	sp,8 ; 15/12/2018
 14756                                  		;cbw	 ; *-* 
 14757 00002293 8946FE                  		mov	[_input_],ax ;*-*
 14758                                  
 14759                                  		;clear_screen(u(21),u(0),u(23),u(79));
 14760                                  
 14761 00002296 B84F00                  		mov	ax,79	; Right Column = 79
 14762 00002299 50                      		push	ax	
 14763 0000229A B81700                  		mov	ax,23	; Bottom Row = 23
 14764 0000229D 50                      		push	ax	
 14765 0000229E 29C0                    		sub	ax,ax	; Left Column = 0
 14766 000022A0 50                      		push	ax	
 14767 000022A1 B81500                  		mov	ax,21	; Top Row = 21
 14768 000022A4 50                      		push	ax
 14769 000022A5 E8EEF1                  		call	clear_screen  ; (clear_screen_down, clear screen rows)
 14770                                  		;add	sp,8
 14771                                  
 14772                                  		;/* set current disk to zero base */
 14773                                  		;if (input != u(ESC)) cur_disk = c(input-'1');
 14774                                  
 14775                                  		;cmp	word [_input_],1Bh ; *-*
 14776 000022A8 807EFE1B                		cmp	byte [_input_],1Bh  ; ESC
 14777 000022AC 7408                    		je	short ccd_29
 14778 000022AE 8A46FE                  		mov	al,[_input_]
 14779 000022B1 2C31                    		sub	al,'1'
 14780 000022B3 A2[E2CB]                		mov	[cur_disk],al
 14781                                  ccd_29:
 14782                                  		;/* Get the input from screen */
 14783                                  		;while (!valid_input)
 14784                                  
 14785 000022B6 803E[ECCB]00            		cmp	byte [valid_input],0
 14786 000022BB 74C1                    		je	short ccd_28
 14787                                  
 14788                                  		;/* clear the screen before going back to main menu */
 14789                                  		;clear_screen(u(0),u(0),u(24),u(79)); 
 14790                                  
 14791                                  		;mov	ax,79
 14792                                  		;push	ax
 14793                                  		;mov	ax,24
 14794                                  		;push	ax
 14795                                  		;sub	ax,ax
 14796                                  		;push	ax
 14797                                  		;push	ax
 14798                                  		;call	clear_screen
 14799                                  		;add	sp,8
 14800                                  
 14801                                  		; Clear screen (clear whole video page)
 14802 000022BD E89EF1                  		call	CLS
 14803                                  ccd_30:
 14804                                  
 14805                                  ;;temporary - 13/12/2018
 14806                                  ;push cs
 14807                                  ;pop ds
 14808                                  ;mov si,insert
 14809                                  ;mov ah,4Eh
 14810                                  ;mov bx,7
 14811                                  ;lccd1:
 14812                                  ;lodsb
 14813                                  ;and al,al
 14814                                  ;jz short lccd2
 14815                                  ;int 10h
 14816                                  ;jmp short lccd1
 14817                                  ;lccd2:
 14818                                  ;xor ax,ax
 14819                                  ;int 16h	
 14820 000022C0 5E                      		pop	si
 14821 000022C1 89EC                    		mov	sp,bp
 14822 000022C3 5D                      		pop	bp
 14823 000022C4 C3                      		retn
 14824                                  
 14825                                  ; memset function (Microsoft C 6.0 runtime library)	
 14826                                  ; ============================================================================
 14827                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 01/12/2018)
 14828                                  
 14829                                  ; http://www.cplusplus.com/reference/cstring/memset/
 14830                                  ;
 14831                                  ;function	;<cstring>
 14832                                  ;memset:
 14833                                  ;
 14834                                  ;void * memset ( void * ptr, int value, size_t num );
 14835                                  ;
 14836                                  ;Fill block of memory
 14837                                  ;Sets the first num bytes of the block of memory pointed by ptr to the specified value 
 14838                                  ;	(interpreted as an unsigned char).
 14839                                  ;
 14840                                  ;Parameters:
 14841                                  ;	ptr:	Pointer to the block of memory to fill.
 14842                                  ;	value:	Value to be set. The value is passed as an int, 
 14843                                  ;		but the function fills the block of memory using 
 14844                                  ;		the unsigned char conversion of this value.
 14845                                  ;	num:	Number of bytes to be set to the value.
 14846                                  ;		size_t is an unsigned integral type.
 14847                                  ;
 14848                                  ;Return Value:
 14849                                  ;	ptr is returned.
 14850                                  
 14851                                  ;memset:
 14852                                  ;	%define	_ptr	bp+4
 14853                                  ;	%define	_value	bp+6
 14854                                  ;	%define _num	bp+8
 14855                                  ;
 14856                                  ;		push	bp
 14857                                  ;		mov	bp,sp
 14858                                  ;		mov	dx,di
 14859                                  ;		mov	ax,ds
 14860                                  ;		mov	es,ax
 14861                                  ;		mov	di,[_ptr]
 14862                                  ;		mov	bx,di
 14863                                  ;		mov	cx,[_num]
 14864                                  ;		jcxz	short memset_2
 14865                                  ;		mov	al,[_value]
 14866                                  ;		mov	ah,al
 14867                                  ;		test	di,1
 14868                                  ;		jz	short metset_1
 14869                                  ;		stosb
 14870                                  ;		dec	cx
 14871                                  ;metset_1:
 14872                                  ;		shr	cx,1
 14873                                  ;		rep stosw
 14874                                  ;		adc	cx,cx
 14875                                  ;		rep stosb
 14876                                  ;memset_2:
 14877                                  ;		mov	di,dx
 14878                                  ;		xchg	ax,bx
 14879                                  ;		pop	bp
 14880                                  ;		retn
 14881                                  
 14882                                  ; sprintf function (Microsoft C 6.0 runtime library)	
 14883                                  ; ============================================================================
 14884                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 01/12/2018)
 14885                                  
 14886                                  ; http://www.cplusplus.com/reference/cstdio/sprintf/
 14887                                  ;
 14888                                  ;function	;<cstdio>
 14889                                  ;sprintf:
 14890                                  ;
 14891                                  ;int sprintf ( char * str, const char * format, ... );
 14892                                  ;
 14893                                  ;Write formatted data to string
 14894                                  ; Composes a string with the same text that would be printed if 
 14895                                  ; format was used on printf, but instead of being printed, 
 14896                                  ; the content is stored as a C string in the buffer pointed by str.
 14897                                  ;
 14898                                  ;Parameters:
 14899                                  ;	str:	Pointer to a buffer where the resulting C-string is stored.
 14900                                  ;		The buffer should be large enough to contain the resulting string.
 14901                                  ;	format:	C string that contains a format string that follows 
 14902                                  ;		the same specifications as format in printf (see printf for details).
 14903                                  ;
 14904                                  ;	... (additional arguments)
 14905                                  ;
 14906                                  ;		Depending on the format string, the function may expect 
 14907                                  ;		a sequence of additional arguments, each containing a value 
 14908                                  ;		to be used to replace a format specifier in the format string 
 14909                                  ;		(or a pointer to a storage location, for n).
 14910                                  ;		There should be at least as many of these arguments 
 14911                                  ;		as the number of values specified in the format specifiers. 
 14912                                  ;		Additional arguments are ignored by the function.
 14913                                  ;Return Value:
 14914                                  ;	On success, the total number of characters written is returned. 
 14915                                  ;	This count does not include the additional null-character 
 14916                                  ;	automatically appended at the end of the string.
 14917                                  ;	On failure, a negative number is returned.
 14918                                  
 14919                                  ; sprintf and _doprnt from PORTABLE C Compiler (8086.zip,1983-1987)
 14920                                  ; ----------------------------------------------------------------------------
 14921                                  ;			   8086/nlib86/stdio/doprnt.c  ; 1982	 
 14922                                  ;			   8086/nlib86/stdio/sprintf.c ; 1982
 14923                                  ;
 14924                                  ; https://www.tuhs.org/Archive/Applications/Portable_CC/  
 14925                                  ; (01/12/2018)
 14926                                  ;
 14927                                  ;Index of /Archive/Applications/Portable_CC
 14928                                  ;
 14929                                  ;  Name           Last modified	   Size    Description
 14930                                  ;----------     ----------------  ------- -------------
 14931                                  ;286.zip	2002-08-09 12:38   169K	 
 14932                                  ;8086.zip	2002-08-09 12:38   1.3M	 ; **this**
 14933                                  ;16032.zip	2002-08-09 12:39   305K	 
 14934                                  ;68000.zip	2002-08-09 12:40   504K	 
 14935                                  ;README		2002-08-10 10:10    145
 14936                                  ;	 
 14937                                  ;Apache/2.4.18 (Ubuntu) Server at www.tuhs.org Port 443
 14938                                  
 14939                                  ;
 14940                                  ; https://www.tuhs.org/Archive/Applications/Portable_CC/README
 14941                                  ;
 14942                                  ; Al Kossow sent in these versions of the portable C compiler for the 8086,
 14943                                  ; Z8000, and 68000 done by MIT's Laboratory for Computer Science. Enjoy.
 14944                                  ;
 14945                                  
 14946                                  ; stdio.h
 14947                                  ;---------
 14948                                  ;
 14949                                  ;#define	BUFSIZ	512
 14950                                  ;#define	_NFILE	20
 14951                                  ;# ifndef FILE
 14952                                  ;extern	struct	_iobuf {
 14953                                  ;	char	*_ptr;
 14954                                  ;	int	_cnt;
 14955                                  ;	char	*_base;
 14956                                  ;	char	_flag;
 14957                                  ;	char	_file;
 14958                                  ;} _iob[_NFILE];
 14959                                  ;# endif
 14960                                  ;
 14961                                  ;#define _IOREAD  01	; 01h
 14962                                  ;#define _IOWRT	  02	; 02h	
 14963                                  ;#define _IONBF	  04	; 04h
 14964                                  ;#define _IOMYBUF 010	; 08h
 14965                                  ;#define _IOEOF	  020	; 10h
 14966                                  ;#define _IOERR	  040	; 20h
 14967                                  ;#define _IOSTRG  0100	; 40h
 14968                                  
 14969                                  ;#define NULL	0
 14970                                  ;#define FILE	struct _iobuf
 14971                                  ;#define EOF	(-1)
 14972                                  ;
 14973                                  ;#define stdin	(&_iob[0])
 14974                                  ;#define stdout	(&_iob[1])
 14975                                  ;#define stderr	(&_iob[2])
 14976                                  ;#define getc(p)   (--(p)->_cnt>=0? *(p)->_ptr++&0377:_filbuf(p))
 14977                                  ;#define getchar() getc(stdin)
 14978                                  ;#define putc(x,p) (--(p)->_cnt>=0? ((int)(*(p)->_ptr++=(unsigned)(x))):_flsbuf((unsigned)(x),p))
 14979                                  ;#define putchar(x) putc(x,stdout)
 14980                                  ;#define feof(p)   (((p)->_flag&_IOEOF)!=0)
 14981                                  ;#define ferror(p) (((p)->_flag&_IOERR)!=0)
 14982                                  ;#define fileno(p) (p)->_file
 14983                                  ;
 14984                                  ;FILE	*fopen();
 14985                                  ;FILE	*freopen();
 14986                                  ;FILE	*fdopen();
 14987                                  ;long	ftell();
 14988                                  ;char	*fgets();
 14989                                  
 14990                                  
 14991                                  ; sprintf.c
 14992                                  ;-----------
 14993                                  ; 
 14994                                  ;#include	<stdio.h>
 14995                                  ;
 14996                                  ;char *sprintf(str, fmt, args)
 14997                                  ;char *str, *fmt;
 14998                                  ;{
 14999                                  ;	struct _iobuf _strbuf;
 15000                                  ;
 15001                                  ;	_strbuf._flag = _IOWRT+_IOSTRG;
 15002                                  ;	_strbuf._ptr = str;
 15003                                  ;	_strbuf._cnt = 32767;
 15004                                  ;	_doprnt(fmt, &args, &_strbuf);
 15005                                  ;	putc('\0', &_strbuf);
 15006                                  ;	return(str);
 15007                                  ;}
 15008                                  
 15009                                  ; SPRINTF.C (VCCRT2.ZIP) - Microsoft Visual C++ 1.0 Run-Time Library Sources
 15010                                  ; ----------------------------------------------------------------------------
 15011                                  ; Microsoft(R) Visual C++ Version 1.0 Run-Time Library Sources (1993)
 15012                                  ;
 15013                                  ; Downloaded From : The Programmer's Corner (www.pcorner.com) - 01/12/2018 -
 15014                                  
 15015                                  ;/****************************************************************************
 15016                                  ;#ifndef _COUNT_
 15017                                  ;*int sprintf(string, format, ...) - print formatted data to string
 15018                                  ;#else
 15019                                  ;*int _snprintf(string, cnt, format, ...) - print formatted data to string
 15020                                  ;#endif
 15021                                  ;*
 15022                                  ;*Purpose:
 15023                                  ;*   Prints formatted data to the using the format string to
 15024                                  ;*   format data and getting as many arguments as called for
 15025                                  ;*   Sets up a FILE so file i/o operations can be used, make string look
 15026                                  ;*   like a huge buffer to it, but _flsbuf will refuse to flush it if it
 15027                                  ;*   fills up.  Appends '\0' to make it a true string.
 15028                                  ;*   _output does the real work here
 15029                                  ;*
 15030                                  ;*   Allocate the 'fake' _iob[] entryit statically instead of on
 15031                                  ;*   the stack so that other routines can assume that _iob[] entries are in
 15032                                  ;*   are in DGROUP and, thus, are near.
 15033                                  ;*
 15034                                  ;#ifdef _COUNT_
 15035                                  ;*   The _snprintf() flavor takes a count argument that is
 15036                                  ;*   the max number of bytes that should be written to the
 15037                                  ;*   user's buffer.
 15038                                  ;#endif
 15039                                  ;*
 15040                                  ;*   Multi-thread: (1) Since there is no stream, this routine must never try
 15041                                  ;*   to get the stream lock (i.e., there is no stream lock either). (2)
 15042                                  ;*   Also, since there is only one staticly allocated 'fake' iob, we must
 15043                                  ;*   lock/unlock to prevent collisions.
 15044                                  ;*
 15045                                  ;*Entry:
 15046                                  ;*   char *string - pointer to place to put output
 15047                                  ;#ifdef _COUNT_
 15048                                  ;*   size_t count - max number of bytes to put in buffer
 15049                                  ;#endif
 15050                                  ;*   char *format - format string to control data format/number of arguments
 15051                                  ;*   followed by list of arguments, number and type controlled by
 15052                                  ;*   format string
 15053                                  ;*
 15054                                  ;*Exit:
 15055                                  ;*   returns number of characters printed
 15056                                  ;*
 15057                                  ;*Exceptions:
 15058                                  ;*
 15059                                  ;****************************************************************************/
 15060                                  
 15061                                  ;#ifndef _COUNT_
 15062                                  ;
 15063                                  ;int 
 15064                                  ;sprintf (char *string, const char *format, ...)
 15065                                  ;
 15066                                  ;#else
 15067                                  ;
 15068                                  ;int 
 15069                                  ;_snprintf (char *string, size_t count, const char *format, ...)
 15070                                  ;
 15071                                  ;#endif
 15072                                  ;
 15073                                  ;{
 15074                                  ;   static FILE _NEAR_ str;
 15075                                  ;   REG1 FILE _NEAR_ *outfile = &str;
 15076                                  ;   va_list arglist;
 15077                                  ;   REG2 int retval;
 15078                                  ;
 15079                                  ;   va_start(arglist, format);
 15080                                  ;
 15081                                  ;   assert(string != NULL);
 15082                                  ;   assert(format != NULL);
 15083                                  ;
 15084                                  ;   outfile->_flag = _IOWRT|_IOSTRG;
 15085                                  ;   outfile->_ptr = outfile->_base = string;
 15086                                  ;#ifndef _COUNT_
 15087                                  ;   outfile->_cnt = MAXSTR;
 15088                                  ;#else
 15089                                  ;   outfile->_cnt = count;
 15090                                  ;#endif
 15091                                  ;
 15092                                  ;   retval = _output(outfile,format,arglist);
 15093                                  ;
 15094                                  ;   putc('\0',outfile); /* no-lock version */
 15095                                  ;
 15096                                  ;   return(retval);
 15097                                  ;}
 15098                                  
 15099                                  ; NASM structure format of _strbuf (_iobuf structure)
 15100                                  struc	_strbuf
 15101 00000000 ????                    ._ptr:	resw 1	; pointer ; char *_ptr;
 15102 00000002 ????                    ._cnt:	resw 1	; integer ; int	 _cnt;
 15103 00000004 ????                    ._base: resw 1 	; pointer ; char *_base;
 15104 00000006 ??                      ._flag:	resb 1  ; char    ; char _flag;
 15105 00000007 ??                      ._file: resb 1  ; char    ; char _file;	
 15106                                  .size:
 15107                                  endstruc
 15108                                  
 15109                                  ;; IBM PC-DOS 7.0 FDISK.COM (!unpacked!) segment 0 (code segment), Offset 70BEh. 
 15110                                  
 15111                                  sprintf:
 15112                                  
 15113                                  	%define _printf_buff	bp+4
 15114                                  	%define _printf_format	bp+6
 15115                                  	%define _printf_arg	bp+8
 15116                                  
 15117 000022C5 55                      		push	bp
 15118 000022C6 89E5                    		mov	bp,sp
 15119                                  		;sub	sp,2 ; ?
 15120                                  
 15121 000022C8 57                      		push	di ; *
 15122 000022C9 56                      		push	si ; **
 15123                                  
 15124                                  	; _strbuf._flag = _IOWRT+_IOSTRG;
 15125                                  	; _strbuf._ptr = str;
 15126                                  	; _strbuf._cnt = 32767;
 15127                                  
 15128                                  		; 13/12/2018
 15129                                  		;mov	byte [_strbuf_flag],42h ; _IOWRT + _IOSTRG
 15130                                  	
 15131 000022CA 8B4604                  		mov	ax,[_printf_buff] ; insert + x
 15132                                  
 15133                                  		;mov	[_strbuf_base],ax
 15134                                  
 15135                                  		;mov	si,strbuf ; _strbuf_ptr
 15136                                  		;mov	[si],ax
 15137                                  		;mov	word [_strbuf_cnt],32767
 15138                                  
 15139                                  		; 13/12/2018
 15140 000022CD A3[F0CC]                		mov	[outbuf_ptr],ax
 15141                                  		;mov	cx,insert+800
 15142                                  		;sub	cx,ax
 15143                                  		;mov	[outbuf_cnt],cx
 15144                                  		
 15145                                  		; 17/12/2018
 15146                                  		; ( 'number_in_msg' procedure -buffer- fixup)
 15147 000022D0 3D[F4CC]                		cmp	ax,insert
 15148 000022D3 7305                    		jnb	short sprintf_buf_set_2
 15149                                  sprintf_buf_set_1:
 15150                                  		;mov	cx,32
 15151 000022D5 B90400                  		mov	cx,4
 15152 000022D8 EB09                    		jmp	short sprintf_buf_set_3
 15153                                  sprintf_buf_set_2:
 15154 000022DA B9[14D0]                		mov	cx,insert+800
 15155 000022DD 39C8                    		cmp	ax,cx
 15156 000022DF 73F4                    		jnb	short sprintf_buf_set_1
 15157 000022E1 29C1                    		sub	cx,ax
 15158                                  sprintf_buf_set_3:
 15159 000022E3 890E[F2CC]              		mov	[outbuf_cnt],cx
 15160                                  		 		
 15161                                  		; _doprnt(fmt, &args, &_strbuf); ; Portable C Compiler
 15162                                  
 15163                                  		; retval = _output(outfile,format,arglist); ; Microsoft C Compiler
 15164                                  
 15165 000022E7 8D4608                  		lea	ax,[_printf_arg] 
 15166 000022EA 50                      		push	ax
 15167 000022EB FF7606                  		push	word [_printf_format]
 15168                                  		;mov	ax,si ; 13/12/2018
 15169                                  		;push	ax
 15170                                  		;call	_doprnt
 15171 000022EE E81E00                  		call	_output ; 02/12/2018
 15172                                  		;add	sp,6		
 15173 000022F1 83C404                  		add	sp,4 ; 13/12/2018
 15174                                  
 15175                                  		;mov	di,ax
 15176                                  
 15177                                  		; 13/12/2018
 15178 000022F4 50                      		push	ax ; ***
 15179 000022F5 B000                    		mov	al,0
 15180 000022F7 E84D04                  		call	putc
 15181                                  	
 15182                                  		; putc('\0', &_strbuf);
 15183                                  		; putc('\0',outfile); /* no-lock version */
 15184                                  
 15185                                  ;#define putc(x,p) (--(p)->_cnt>=0? ((int)(*(p)->_ptr++=(unsigned)(x))):_flsbuf((unsigned)(x),p))
 15186                                  
 15187                                  ;#define putc(_c,_stream)  (--(_stream)->_cnt >= 0 ;    ? 0xff & (*(_stream)->_ptr++ = (char)(_c)) :  _flsbuf((_c),(_stream)))
 15189                                  
 15190                                  		;dec	word [_strbuf_cnt]
 15191                                  		;js	short sprintf_0
 15192                                  		;mov	bx,[_strbuf_ptr]
 15193                                  		;inc	word [_strbuf_ptr]
 15194                                  		;mov	byte [bx],0
 15195                                  		;jmp	short sprintf_1
 15196                                  		;;nop
 15197                                  		;;align 2
 15198                                  ;sprintf_0:
 15199                                  		;push	si ; p = &_strbuf
 15200                                  		;sub	ax,ax ; 0
 15201                                  		;push	ax ; x = 0
 15202                                  		;call	_flsbuf
 15203                                  		;add	sp,4
 15204                                  ;sprintf_1:
 15205                                  		;mov	ax,di ; return(retval);
 15206 000022FA 58                      		pop	ax ; *** ; 13/12/2018
 15207                                  
 15208 000022FB 5E                      		pop	si ; **
 15209 000022FC 5F                      		pop	di ; *
 15210                                  
 15211                                  		;mov	sp,bp
 15212 000022FD 5D                      		pop	bp
 15213 000022FE C3                      		retn
 15214                                  
 15215                                  ;***
 15216                                  ;stdio.inc - Definitions and declarations needed by the STDIO functions
 15217                                  ;	     written in assembler.
 15218                                  ;
 15219                                  ;	Copyright (c) 1988-1992, Microsoft Corporation. All rights reserved.
 15220                                  ;
 15221                                  ;Purpose:
 15222                                  ;	Analog of STDIO.H and FILE2.H for assembler routines.
 15223                                  ;
 15224                                  ;*******************************************************************************
 15225                                  
 15226                                  ; Miscellaneous constants
 15227                                  
 15228                                  ;BUFSIZ		equ	200h
 15229                                  ;EOF		equ	0FFFFh
 15230                                  
 15231                                  ; Element structure for _iob array
 15232                                  
 15233                                  ;_iobuf	struc
 15234                                  ;
 15235                                  ;if sizeD				; far data
 15236                                  ;	_ptr		dd	?
 15237                                  ;	_cnt		dw	?
 15238                                  ;	_base		dd	?
 15239                                  ;	_flag		db	?
 15240                                  ;	_file		db	?
 15241                                  ;
 15242                                  ;else					; near data
 15243                                  ;	_ptr		dw	?
 15244                                  ;	_cnt		dw	?
 15245                                  ;	_base		dw	?
 15246                                  ;	_flag		db	?
 15247                                  ;	_file		db	?
 15248                                  ;endif
 15249                                  ;
 15250                                  ;_iobuf	ends
 15251                                  
 15252                                  ; Size of _iob element (i.e., size of stream structure)
 15253                                  
 15254                                  ;if sizeD				; far data
 15255                                  ;
 15256                                  ;_STREAMSZ	equ	12
 15257                                  ;
 15258                                  ;else					; near data
 15259                                  ;
 15260                                  ;_STREAMSZ	equ	8
 15261                                  ;
 15262                                  ;endif
 15263                                  
 15264                                  ; Element structure for _iob2 array
 15265                                  ;
 15266                                  ;_iobuf2 struc
 15267                                  ;
 15268                                  ;	_flag2		db     ?
 15269                                  ;	_charbuf	db     ?
 15270                                  ;	_bufsiz 	dw     ?
 15271                                  ;	_tmpnum 	dw     ?
 15272                                  ;
 15273                                  ;if sizeD
 15274                                  ;	_padding	db     6 dup (?)
 15275                                  ;else
 15276                                  ;	_padding	db     2 dup (?)
 15277                                  ;endif
 15278                                  ;
 15279                                  ;_iobuf2 ends
 15280                                  
 15281                                  ; Standard streams
 15282                                  ;
 15283                                  ;stdin		equ	dataOFFSET _iob
 15284                                  ;stdout		equ	dataOFFSET _iob + _STREAMSZ
 15285                                  ;stderr		equ	dataOFFSET _iob + 2 * _STREAMSZ
 15286                                  ;stdaux		equ	dataOFFSET _iob + 3 * _STREAMSZ
 15287                                  ;stdprn		equ	dataOFFSET _iob + 4 * _STREAMSZ
 15288                                  
 15289                                  ;; Flags
 15290                                  ;
 15291                                  ;_IOREAD 	equ	01h
 15292                                  ;_IOWRT		equ	02h
 15293                                  ;
 15294                                  ;_IOFBF		equ	0h
 15295                                  ;_IOLBF		equ	040h
 15296                                  ;_IONBF		equ	04h
 15297                                  ;
 15298                                  ;_IOMYBUF	equ	08h
 15299                                  ;_IOEOF		equ	010h
 15300                                  ;_IOERR		equ	020h
 15301                                  ;_IOSTRG 	equ	040h
 15302                                  ;_IORW		equ	080h
 15303                                  ;
 15304                                  ;_IOYOURBUF	equ	01h
 15305                                  ;_IOFEOF 	equ	08h
 15306                                  ;_IOFLRTN	equ	10h
 15307                                  ;_IOCTRLZ	equ	20h
 15308                                  ;_IOCOMMIT	equ	40h
 15309                                  
 15310                                  ; _FLSBUF.ASM (VCCRT2.ZIP) - Microsoft Visual C++ 1.0 Run-Time Library Sources
 15311                                  ; ----------------------------------------------------------------------------
 15312                                  ; Microsoft(R) Visual C++ Version 1.0 Run-Time Library Sources (1993)
 15313                                  ;
 15314                                  ; Downloaded From : The Programmer's Corner (www.pcorner.com) - 01/12/2018 -
 15315                                  
 15316                                  ;***
 15317                                  ;_flsbuf.asm - flush buffer and output character.
 15318                                  ;
 15319                                  ;	Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
 15320                                  ;
 15321                                  ;Purpose:
 15322                                  ;	defines _flsbuf() - flush a file buffer and output a character.
 15323                                  ;	If no buffer, make one.
 15324                                  ;
 15325                                  ;*******************************************************************************
 15326                                  ;
 15327                                  ;--- C VERSION OF ROUTINE
 15328                                  ;
 15329                                  ; #include <stdio.h>
 15330                                  ; #include <register.h>
 15331                                  ; #include <file2.h>
 15332                                  ; #include <assertm.h>
 15333                                  ; #include <malloc.h>
 15334                                  ; #include <msdos.h>
 15335                                  ; #include <internal.h>
 15336                                  ; #include <dos.h>
 15337                                  ; #ifdef MTHREAD
 15338                                  ; #include <os2dll.h>
 15339                                  ; #endif
 15340                                  ;
 15341                                  ; int cdecl _LOAD_DS
 15342                                  ; _flsbuf (ch, str)
 15343                                  ; int ch;
 15344                                  ; FILE *str;
 15345                                  ; {
 15346                                  ;     REG1 FILE _NEAR_ *stream;
 15347                                  ;     FILE2 _NEAR_ *stream2;
 15348                                  ;     REG2 int charcount;
 15349                                  ;     REG3 int written;
 15350                                  ;     int fh;
 15351                                  ;
 15352                                  ;     assert(str,"str==NULL");
 15353                                  ;
 15354                                  ;     /* Init file handle and pointers */
 15355                                  ;     stream = (FILE _NEAR_ *) FP_OFF(str);
 15356                                  ;     fh = fileno(stream);
 15357                                  ;     stream2 = &(_iob2_(stream));
 15358                                  ;
 15359                                  ;     if (!inuse(stream) || stream->_flag & _IOSTRG) {
 15360                                  ;	  stream->_flag |= _IOERR;
 15361                                  ;	  return(-1);
 15362                                  ;     }
 15363                                  ;
 15364                                  ;     if (stream->_flag & _IOREAD) {
 15365                                  ;	  stream->_flag |= _IOERR;
 15366                                  ;	  stream->_cnt = 0;
 15367                                  ;	  return(-1);
 15368                                  ;     }
 15369                                  ;
 15370                                  ;     stream->_flag |= _IOWRT;
 15371                                  ;     stream->_flag &= ~_IOEOF;
 15372                                  ;     written = charcount = stream->_cnt = 0;
 15373                                  ;
 15374                                  ;     /* Get a buffer for this stream, if necessary. */
 15375                                  ;     if (!anybuf2(stream,stream2)) {
 15376                                  ;
 15377                                  ;	  /* Do NOT get a buffer if (1) stream is stdout/stderr, and
 15378                                  ;	     (2) stream is NOT a tty.
 15379                                  ;	     [If stdout/stderr is a tty, we do NOT set up single char buffering.
 15380                                  ;	     This is so that later temporary buffering will not be thwarted
 15381                                  ;	     by the _IONBF bit being set (see _stbuf/_ftbuf usage).]
 15382                                  ;	  */
 15383                                  ; #ifdef  OS2
 15384                                  ;	  if (!( ((stream==stdout) || (stream==stderr))
 15385                                  ; #else
 15386                                  ;	  if (!( ((stream==stdout) || (stream==stderr) || (stream==stdprn))
 15387                                  ; #endif
 15388                                  ;		  && (isatty(fh)) ))
 15389                                  ;
 15390                                  ;		      _getbuf(stream);
 15391                                  ;
 15392                                  ;	  } /* end !anybuf() */
 15393                                  ;
 15394                                  ;     /* If big buffer is assigned to stream... */
 15395                                  ;     if (bigbuf2(stream,stream2)) {
 15396                                  ;	  assert(stream->_ptr - stream->_base >= 0, "inconsistent IOB fields");
 15397                                  ;
 15398                                  ;	  charcount = stream->_ptr - stream->_base;
 15399                                  ;	  stream->_ptr = stream->_base + 1;
 15400                                  ;	  stream->_cnt = stream2->_bufsiz - 1;
 15401                                  ;
 15402                                  ;	  if (charcount > 0)
 15403                                  ;	      written = _write(fh, stream->_base, charcount);
 15404                                  ;	  else
 15405                                  ;	      if (_osfile[fh] & FAPPEND)
 15406                                  ;		  _lseek(fh,0L,SEEK_END);
 15407                                  ;
 15408                                  ;	  *stream->_base = ch;
 15409                                  ;	  }
 15410                                  ;
 15411                                  ;     /* Perform single character output (either _IONBF or no buffering) */
 15412                                  ;     else {
 15413                                  ;	  charcount = 1;
 15414                                  ;	  written = _write(fh, &ch, charcount);
 15415                                  ;	  }
 15416                                  ;
 15417                                  ;     /* See if the write() was successful. */
 15418                                  ;     if (written != charcount) {
 15419                                  ;	  stream->_flag |= _IOERR;
 15420                                  ;	  return(-1);
 15421                                  ;	  }
 15422                                  ;
 15423                                  ;     return(ch & 0xff);
 15424                                  ; }
 15425                                  ;
 15426                                  ;
 15427                                  ;--- END OF C VERSION
 15428                                  ;
 15429                                  
 15430                                  ;msdos.inc - MS-DOS definitions for C runtime
 15431                                  ;----------------------------------------------
 15432                                  ; __osfile flag values for DOS file handles
 15433                                  ;
 15434                                  ;FOPEN	 equ	01H		; file handle open
 15435                                  ;FEOFLAG equ	02H		; end of file has been encountered
 15436                                  ;FCRLF	 equ	04H		; CR-LF across read buffer (in text mode)
 15437                                  ;FPIPE	 equ	08H		; file handle refers to a pipe
 15438                                  ;FRDONLY equ	10H		; file handle associated with read only file
 15439                                  ;FAPPEND equ	20H		; file handle opened O_APPEND
 15440                                  ;FDEV	 equ	40H		; file handle refers to device
 15441                                  ;FTEXT	 equ	80H		; file handle is in text mode
 15442                                  
 15443                                  ;; IBM PC-DOS 7.0 FDISK.COM (!unpacked!) segment 0 (code segment), Offset 7654h. 
 15444                                  
 15445                                  ;*******************************************************************************
 15446                                  ;int _flsbuf(ch, stream) - flush buffer and output character.
 15447                                  ;
 15448                                  ;Purpose:
 15449                                  ;	flush a buffer if this stream has one. if not, try to get one. put the
 15450                                  ;	next output char (ch) into the buffer (or output it immediately if this
 15451                                  ;	stream can't have a buffer). called only from putc. intended for use
 15452                                  ;	only within library.
 15453                                  ;
 15454                                  ;	[NOTE 1: It is valid for this module to assign a value directly to
 15455                                  ;	_flag2 instead of simply twiddling bits in the case where we are
 15456                                  ;	initializing an i/o buffer.]
 15457                                  ;
 15458                                  ;	[NOTE 2: Multi-thread - It is assumed that the caller has aquired
 15459                                  ;	the stream lock.]
 15460                                  ;
 15461                                  ;	[NOTE 3: The code depends on _iob[] and _iob2[] being near arrays of
 15462                                  ;	the total size and element size.]
 15463                                  ;
 15464                                  ;Entry:
 15465                                  ;	FILE *stream - stream to flish and write on
 15466                                  ;	char ch - character to output.
 15467                                  ;
 15468                                  ;Exit:
 15469                                  ;	returns -1 if FILE is actually a string, or if can't write ch to
 15470                                  ;	unbuffered file, or if we flush a buffer but the number of chars
 15471                                  ;	written doesn't agree with buffer size.  Otherwise returns ch.
 15472                                  ;	all fields in FILE struct can be affected except _file.
 15473                                  ;
 15474                                  ;Uses:	ax, bx, cx, dx
 15475                                  ;
 15476                                  ;Exceptions:
 15477                                  ;
 15478                                  ;*******************************************************************************
 15479                                  
 15480                                  ; 14/12/2018 (no need to _flshbuf for FDISK2.COM)
 15481                                  
 15482                                  ;_flsbuf:
 15483                                  ;
 15484                                  ;	%define _c_	bp+4
 15485                                  ;	%define _strm_	bp+6
 15486                                  ;
 15487                                  ;		push	bp
 15488                                  ;		mov	bp,sp
 15489                                  ;		push	si
 15490                                  ;		push	di
 15491                                  ;
 15492                                  ;	; Set:
 15493                                  ;	;	si = stream (= _iob entry)
 15494                                  ;	;	al = stream->_flag
 15495                                  ;
 15496                                  ;		mov	si,[_strm_]
 15497                                  ;		mov	al,[si+6]    ; [_strbuf_flag]
 15498                                  ;
 15499                                  ;	;**
 15500                                  ;	; Check that either _IOWRT or _IORW is set, and _IOSTRG is not set.
 15501                                  ;
 15502                                  ;		test	al,82h ; _IOWRT OR _IORW 
 15503                                  ;		jz	short flsbuf_4 ; reterror
 15504                                  ;		test	al,40h ; _IOSTRG
 15505                                  ;		jnz	short flsbuf_4 ; reterorr
 15506                                  ;;**
 15507                                  ;; Set the _cnt field to 0. This isn't need in the case of a 'big' buffer and
 15508                                  ;; is overwritten in that case. However, it is needed in all other cases and
 15509                                  ;; this is the cheapest place to do it.
 15510                                  ;
 15511                                  ;		mov	word [si+2],0 ; [si]._cnt ; reset _cnt field to 0
 15512                                  ;;**
 15513                                  ;; Check that _IOREAD is not set or, if it is, then so is _IOEOF. Note that
 15514                                  ;; _IOREAD and IOEOF both being set implies switching from read to write at
 15515                                  ;; end-of-file, which is allowed by ANSI. Note that resetting the _cnt and
 15516                                  ;; _ptr fields amounts to doing an fflush() on the stream in this case. Note
 15517                                  ;; also that the _cnt field has to be reset to 0 for the error path as well
 15518                                  ;; (i.e., _IOREAD set but _IOEOF not set) as well as the non-error path.
 15519                                  ;
 15520                                  ;		test	al,1	; _IOREAD
 15521                                  ;		jz	short flsbuf_1 ; set_flag
 15522                                  ;		test	al,10h	; _IOEOF ; ; at end-of-file?
 15523                                  ;		jz	short flsbuf_4 ; reterror ; no, go do error return
 15524                                  ;		mov	cx,[si+4]      ; [si]._base
 15525                                  ;				       ; reset _ptr field to _base field
 15526                                  ;		mov	[si],cx	;[si]._ptr 
 15527                                  ;
 15528                                  ;		and	al,~1 ; NOT _IOREAD ; clear _IOREAD bit
 15529                                  ;flsbuf_1:
 15530                                  ;		;**
 15531                                  ;		; Set _IOWRT and clear _IOEOF
 15532                                  ;;set_flag:
 15533                                  ;		or	al,2	; _IOWRT
 15534                                  ;		and	al,~10h ; NOT _IOEOF
 15535                                  ;		mov	[si+6],al ; [si]._flag
 15536                                  ;	;**
 15537                                  ;	; Set:
 15538                                  ;	;	di = _iob2 entry (aka stream2)
 15539                                  ;	;	bx = stream->_file (= file handle)
 15540                                  ;
 15541                                  ;		mov	di,si
 15542                                  ;		;sub	di,STDIN ; _iob
 15543                                  ;		sub	di,_iob	; 07/12/2018
 15544                                  ;		add	di,_iob2	; di = stream2 corresponding to stream
 15545                                  ;		xor	bx,bx
 15546                                  ;		mov	bl,[si+7] ; [si]._file	; bx = file handle for stream
 15547                                  ;	;**
 15548                                  ;	; Test the buffering flags and branch accordingly
 15549                                  ;
 15550                                  ;		test	al,8 ; _IOMYBUF
 15551                                  ;		jnz	short flsbuf_6 ; bigbuf
 15552                                  ;		test	al,4 ; _IONBF
 15553                                  ;		jnz	short flsbuf_3 ; singlechar
 15554                                  ;
 15555                                  ;		test	byte [di],1 ; test [di]._flag2,_IOYOURBUF
 15556                                  ;		jnz	short flsbuf_6 ; bigbuf
 15557                                  ;	;**
 15558                                  ;	; No buffering is in place at all. Check to see if the stream is stdout,
 15559                                  ;	; stderr or, in DOS only, stdprn. If it is and if it is attached to a device,
 15560                                  ;	; go do single character output. Otherwise, go try to buffer it.
 15561                                  ;
 15562                                  ;		cmp	si,STDOUT
 15563                                  ;		je	short flsbuf_2	; testdev
 15564                                  ;		cmp	si,STDERR
 15565                                  ;		je	short flsbuf_2	; testdev
 15566                                  ;		cmp	si,STDPRN
 15567                                  ;		jne	short flsbuf_5	; dogetbuf
 15568                                  ;flsbuf_2:
 15569                                  ;;testdev:
 15570                                  ;		;test	byte ptr [bx + dataOFFSET _osfile],FDEV
 15571                                  ;		test	byte [bx+_osfile],40h ; FDEV
 15572                                  ;		jz	short flsbuf_5	; dogetbuf
 15573                                  ;flsbuf_3:
 15574                                  ;;try_again:	;if (iop->_flag&_IONBF) {
 15575                                  ;		;	c1 = c;
 15576                                  ;		;	rn = 1;
 15577                                  ;		;	n = write(fileno(iop), &c1, rn);
 15578                                  ;		;	iop->_cnt = 0;
 15579                                  ;	;**
 15580                                  ;	; Single character output (either _IONBF or no buffering at all).
 15581                                  ;singlechar:
 15582                                  ;		mov	cx,1	 ; rn
 15583                                  ;		push	cx
 15584                                  ;		lea	di,[_c_] ; &c1 ; [char] ; ss:di = address of char
 15585                                  ;		push	di
 15586                                  ;		push	bx	 ; fileno(iop)
 15587                                  ;		call	_write	 ; write(handle,&char,1)
 15588                                  ;		add	sp,6
 15589                                  ;		mov	cx,1	 ; rn	; set cx = 1 = number of chars...
 15590                                  ;			; ax = n
 15591                                  ;		jmp	short flsbuf_8  ; doret
 15592                                  ;					; ...that should have been written
 15593                                  ;flsbuf_4:
 15594                                  ;	;**
 15595                                  ;	; Set up a return of -1 to indicate that an error has occurred and jump
 15596                                  ;	; to done. Set the error flag on the stream.
 15597                                  ;;reterorr:
 15598                                  ;		mov	ax,-1	; return -1 to indicate error
 15599                                  ;		;or	[si]._flag,_IOERR ; set error flag
 15600                                  ;		or	byte [si+6],20h ; iop->_flag |= _IOERR
 15601                                  ;		jmp	short flsbuf_10	; done ; return(EOF) 
 15602                                  ;flsbuf_5:
 15603                                  ;	;**
 15604                                  ;	; The stream is unbuffered, try to buffer it. Then, check the buffering
 15605                                  ;	; flags again and branch accordingly.
 15606                                  ;;dogetbuf:
 15607                                  ;		push	bx		; save file handle
 15608                                  ;		;push	si	; 09/12/2018
 15609                                  ;		call	_getbuf 	; _getbuf(stream)
 15610                                  ;		;pop	bx		; clean off arg
 15611                                  ;		pop	bx		; restore file handle
 15612                                  ;
 15613                                  ;		;test	[si]._flag,_IOMYBUF ; did we get a 'big' buffer?
 15614                                  ;		;jz	short singlechar    ; no, single char buffering
 15615                                  ;
 15616                                  ;		test	byte [si+6],8	; _IOMYBUF
 15617                                  ;		jz	short flsbuf_3	; try_again
 15618                                  ;flsbuf_6:
 15619                                  ;	;**
 15620                                  ;	; The stream has a 'big' buffer. Empty it with a write().
 15621                                  ;; bigbuf:
 15622                                  ;		mov	cx,[si]   ; [si]._ptr
 15623                                  ;		mov	dx,[si+4] ; [si]._base	
 15624                                  ;		sub	cx,dx	  ; cx = number of chars in stream buffer
 15625                                  ;		inc	dx
 15626                                  ;		mov	[si],dx	  ; [si]._ptr ; set _ptr to _base + 1
 15627                                  ;		mov	dx,[di+2] ; [di]._bufsiz 	
 15628                                  ;		dec	dx		
 15629                                  ;		mov	[si+2],	dx ; [si]._cnt ; set _cnt to _bufsiz - 1
 15630                                  ;		jcxz	flsbuf_9 ; dolseek ; no chars in buffer to write
 15631                                  ;
 15632                                  ;		push	cx	; save count
 15633                                  ;
 15634                                  ;		push	cx	; push args
 15635                                  ;		push	word [si+4] ; [si]._base
 15636                                  ;		push	bx
 15637                                  ;		call	_write
 15638                                  ;		add	sp,6	; clean off args
 15639                                  ;
 15640                                  ;		pop	cx	; restore count
 15641                                  ;flsbuf_7:
 15642                                  ;		;**
 15643                                  ;		; Place 'char' in the stream buffer
 15644                                  ;;bufchar:
 15645                                  ;		mov	di,[si+4] ; [si]._base
 15646                                  ;		mov	dx,[_c_]  ; [char]
 15647                                  ;		mov	[di],dl
 15648                                  ;flsbuf_8:
 15649                                  ;		;if (rn != n) {
 15650                                  ;		;	iop->_flag |= _IOERR;
 15651                                  ;		;	return(EOF);
 15652                                  ;		;}
 15653                                  ;		;return(c);
 15654                                  ;	;**
 15655                                  ;	; Test the results of the call to write() (i.e., compare ax and cx). If
 15656                                  ;	; successful, return char. Otherwise, return -1.
 15657                                  ;
 15658                                  ;		cmp	ax,cx ; ax = n, cx = rn
 15659                                  ;		jne	short flsbuf_4  ; != ; reterror
 15660                                  ;
 15661                                  ;		;return(c);	
 15662                                  ;		xor	ax,ax
 15663                                  ;		mov	al,[_c_] ; [char]
 15664                                  ;		jmp	short flsbuf_10 ; done
 15665                                  ;flsbuf_9:
 15666                                  ;	;**
 15667                                  ;	; There are no characters in the stream buffer. If the FAPPEND bit is set
 15668                                  ;	; in the _osfile entry, position the file pointer at the end of the file.
 15669                                  ;;dolseek:
 15670                                  ;		xor	ax,ax		; needed for both branchings below
 15671                                  ;		;test	byte ptr [bx + dataOFFSET _osfile],FAPPEND
 15672                                  ;		test	byte [bx+_osfile],20h
 15673                                  ;		jz	short flsbuf_7 ; bufchar
 15674                                  ;		
 15675                                  ;		mov	cx,2	; SEEK_END
 15676                                  ;		push	cx		; push args
 15677                                  ;		push	ax		; note that ax is 0
 15678                                  ;		push	ax
 15679                                  ;		push	bx
 15680                                  ;		call	_lseek		; _lseek(handle,0L,SEEK_END)
 15681                                  ;		add	sp,8
 15682                                  ;		xor	ax,ax
 15683                                  ;		mov	cx,ax		; set ax = cx = 0
 15684                                  ;		;jmp	short bufchar
 15685                                  ;		jmp	short flsbuf_7
 15686                                  ;flsbuf_10:
 15687                                  ;;done:
 15688                                  ;		pop	di
 15689                                  ;		pop	si
 15690                                  ;		pop	bp
 15691                                  ;		retn
 15692                                  
 15693                                  ; OUTPUT.ASM (VCCRT2.ZIP) - Microsoft Visual C++ 1.0 Run-Time Library Sources
 15694                                  ; ----------------------------------------------------------------------------
 15695                                  ; Microsoft(R) Visual C++ Version 1.0 Run-Time Library Sources (1993)
 15696                                  ;
 15697                                  ; Downloaded From : The Programmer's Corner (www.pcorner.com) - 01/12/2018 -
 15698                                  
 15699                                  ; 06/12/2018
 15700                                  
 15701                                  ;***
 15702                                  ;output.asm - formatted output for printf, etc.
 15703                                  ;
 15704                                  ;	Copyright (c) 1988-1992, Microsoft Corporation. All rights reserved.
 15705                                  ;
 15706                                  ;Purpose:
 15707                                  ;	defines _output() for formatted output by *printf.
 15708                                  ;	if CPRFLAG is defined, defines cprintf instead.
 15709                                  ;
 15710                                  ;******************************************************************************
 15711                                  
 15712                                  ; size of conversion buffer (ANSI-specified minimum is 509)
 15713                                  BUFSIZE 	equ	512		; size of buffer for conversions
 15714                                  
 15715                                  ; flag definitions for flag 1
 15716                                  FL_SIGN 	equ	01h		; put plus/minus sign in front
 15717                                  FL_SIGNSP	equ	02h		; put space/minus sign in front
 15718                                  FL_LEFT 	equ	04h		; left justify
 15719                                  FL_LEADZERO	equ	08h		; pad with leading zeros
 15720                                  FL_LONG 	equ	10h		; long value given (def: short)
 15721                                  FL_FAR		equ	20h		; far pointer given (def: model dep.)
 15722                                  FL_SIGNED	equ	40h		; signed data given (def: unsigned)
 15723                                  FL_ALTERNATE	equ	80h		; alternate form requested
 15724                                  
 15725                                  ; flag definitions for flag 2
 15726                                  FL_NEGATIVE	equ	01h		; value is negative
 15727                                  FL_FORCEOCTAL	equ	02h		; force 0 in front (for octals only)
 15728                                  FL_LONGDOUBLE	equ	04h		; long double value given
 15729                                  FL_SHORT	equ	08h		; short value given
 15730                                  FL_NEAR 	equ	10h		; near ptr given (useful only for %p)
 15731                                  
 15732                                  ; possible state values
 15733                                  ST_NORMAL	equ	0		; normal state -- just output char
 15734                                  ST_PERCENT	equ	1		; just read percent sign
 15735                                  ST_FLAG 	equ	2		; just read flag character
 15736                                  ST_WIDTH	equ	3		; just read width specification char
 15737                                  ST_DOT		equ	4		; just read dot
 15738                                  ST_PRECIS	equ	5		; just read precision spec. char
 15739                                  ST_SIZE 	equ	6		; just read size specification char
 15740                                  ST_TYPE 	equ	7		; just read type specification
 15741                                  
 15742                                  ; define character type values
 15743                                  CH_OTHER	equ	0		; character with no special meaning
 15744                                  CH_PERCENT	equ	1		; '%'
 15745                                  CH_DOT		equ	2		; '.'
 15746                                  CH_STAR 	equ	3		; '*'
 15747                                  CH_ZERO 	equ	4		; '0'
 15748                                  CH_DIGIT	equ	5		; '1'..'9'
 15749                                  CH_FLAG 	equ	6		; ' ', '+', '-', '#'
 15750                                  CH_SIZE 	equ	7		; 'h', 'l', 'L', 'N', 'F'
 15751                                  CH_TYPE 	equ	8		; type specification character
 15752                                  
 15753                                  ;*******************************************************************************
 15754                                  ;int _output(stream, format, argptr) - formatted output (used internally only)
 15755                                  ;
 15756                                  ;Purpose:
 15757                                  ;	_output performs printf-style output onto a stream.  It is called
 15758                                  ;	by printf/fprintf/sprintf/vprintf/vfprintf/vsprintf to do the
 15759                                  ;	dirty work.  In multi-thread situations, _output assumes that
 15760                                  ;	the given stream is already locked.
 15761                                  ;
 15762                                  ;	Algorithm:
 15763                                  ;	   The format string is parsed by using a finite-state machine
 15764                                  ;	   based on the current state and the current character read
 15765                                  ;	   from the format string.  Thus, looping is on a per-character
 15766                                  ;	   basis, not a per conversion specifier basis.  Once the format
 15767                                  ;	   specifying character is read, output is performed.
 15768                                  ;
 15769                                  ;Entry:
 15770                                  ;	FILE *stream	-    stream for output
 15771                                  ;	char *format	-    printf-style format string
 15772                                  ;	void *argptr	-    pointer to the list of subsidiary arguments
 15773                                  ;
 15774                                  ;Exit:
 15775                                  ;	If no output error occurs, returns the number of characters written
 15776                                  ;	If an I/O error occurs, -1 is returned.
 15777                                  ;
 15778                                  ;Uses:
 15779                                  ;	Performs I/O on the given stream by using the assembly
 15780                                  ;	equivalent of getc/_getc_lk macros.
 15781                                  ;
 15782                                  ;*******************************************************************************
 15783                                  
 15784                                  ;jump table based on current state
 15785 000022FF [6423]                  jumptable:	dw normal_state
 15786 00002301 [6F23]                  		dw percent_state
 15787 00002303 [8323]                  		dw flag_state
 15788 00002305 [B723]                  		dw width_state
 15789 00002307 [E323]                  		dw dot_state
 15790 00002309 [EB23]                  		dw precis_state
 15791 0000230B [1424]                  		dw size_state
 15792 0000230D [4624]                  		dw type_state
 15793                                  
 15794                                  ;cProc	output, <NEAR>, <>	      ; static, near routine
 15795                                  ;        parmDP  format
 15796                                  ;    ifdef _WINDOWS
 15797                                  ;        parmD   arglist
 15798                                  ;    else
 15799                                  ;        parmDP  arglist
 15800                                  ;    endif
 15801                                  ;
 15802                                  ;else		; defining normal _output routine
 15803                                  ;
 15804                                  ;cProc	_output, <PUBLIC>, <>
 15805                                  ;	parmDP	stream
 15806                                  ;	parmDP	format
 15807                                  ;	parmDP  arglist
 15808                                  ;
 15809                                  ;endif ;CPRFLAG
 15810                                  ;
 15811                                  ;; define local variables manually (ick!) -- because we need stack checking
 15812                                  ;
 15813                                  ;ifdef _WINDOWS
 15814                                  ;    if    sizeC
 15815                                  ;	BASE equ <(bp-2)>
 15816                                  ;    else
 15817                                  ;	BASE equ <bp>
 15818                                  ;    endif ;sizeC
 15819                                  ;else
 15820                                  ;	BASE equ <bp>
 15821                                  ;endif ;_WINDOWS
 15822                                  ;
 15823                                  ;hexadd		equ	byte ptr [BASE-1]	  ; offset to add when hex converting
 15824                                  ;char		equ	byte ptr [BASE-2]	  ; character just read
 15825                                  ;flags		equ	word ptr [BASE-4]	  ; flag word (byte equates below)
 15826                                  ;flags2		equ	byte ptr [BASE-3]	  ; flag byte 2
 15827                                  ;flags1		equ	byte ptr [BASE-4]	  ; flag byte 1
 15828                                  ;state		equ	byte ptr [BASE-5]	  ; state we're in
 15829                                  ;radix		equ	byte ptr [BASE-6]	  ; radix to convert by
 15830                                  ;charsout	equ	word ptr [BASE-8]	  ; chars written so far
 15831                                  ;fldwidth	equ	word ptr [BASE-10]	  ; selected width
 15832                                  ;precision	equ	word ptr [BASE-12]	  ; selected precision
 15833                                  ;prefix		equ	byte ptr [BASE-14]	  ; up to two-byte prefix
 15834                                  ;prfxlen 	equ	word ptr [BASE-16]	  ; length of prefix
 15835                                  ;capexp		equ	word ptr [BASE-18]	  ; capital exponent?
 15836                                  ;buffer		equ	byte ptr [BASE-20-BUFSIZE]; buffer for conversions
 15837                                  ;
 15838                                  ;LOCALDATSIZE	equ	20+BUFSIZE	; amount of local data
 15839                                  ;
 15840                                  ; begin procedure
 15841                                  ;
 15842                                  ;cBegin _output
 15843                                  
 15844                                  LOCALDATSIZE	equ	20+BUFSIZE	; Visual C++ Version 1.0 Run-Time Library
 15845                                  					; OUTPUT.ASM
 15846                                  
 15847                                  ; IBM PC-DOS 7.0 FDISK.COM Segment 0 (Code Segment), Offset 7744h
 15848                                  
 15849                                  _output:
 15850                                  
 15851                                  	;%define output_buff bp-369	; IBM PC-DOS 7.0 FDISK.COM
 15852                                  	%define output_buff  bp-532	; Visual C++ Version 1.0 Run-Time Library
 15853                                  					; OUTPUT.ASM
 15854                                  	%define capexp	  bp-18
 15855                                  	%define prfxlen   bp-16
 15856                                  	%define prefix	  bp-14
 15857                                  	%define precision bp-12
 15858                                  	%define fldwidth  bp-10
 15859                                  	%define charsout  bp-8
 15860                                  	%define radix	  bp-6
 15861                                  	%define state	  bp-5
 15862                                  	%define flags	  bp-4
 15863                                  	%define char	  bp-2
 15864                                  	%define hexadd	  bp-1
 15865                                  
 15866                                  	;%define stream	  bp+4	
 15867                                  	;%define format	  bp+6
 15868                                  	;%define arglist  bp+8
 15869                                  
 15870                                  	; 13/12/2018
 15871                                  	%define format	bp+4
 15872                                  	%define arglist	bp+6
 15873                                  	
 15874 0000230F 55                      		push	bp
 15875 00002310 89E5                    		mov	bp,sp
 15876                                  		
 15877                                  		;mov	ax,369 ; PC-DOS 7.0 FDISK.COM
 15878 00002312 B81402                  		mov	ax,LOCALDATSIZE ; 532
 15879 00002315 E8AA04                  		call	_chkstk		; allocate local data
 15880                                  		
 15881 00002318 56                      		push	si
 15882 00002319 57                      		push	di
 15883 0000231A 31C0                    		xor	ax,ax ; 0
 15884 0000231C 8946F8                  		mov	[charsout],ax	; charsout = 0
 15885 0000231F 8846FB                  		mov	[state],al	; state = 0
 15886                                  
 15887                                  		; beginning of main loop	
 15888                                  loopagain:
 15889                                  
 15890                                  ;if sizeD
 15891                                  ;	les	si, format
 15892                                  ;	lods	byte ptr es:[si]
 15893                                  ;else
 15894                                  ;	mov	si, format
 15895                                  ;	lodsb
 15896                                  ;endif
 15897 00002322 8B7604                  		mov	si,[format]
 15898 00002325 AC                      		lodsb
 15899 00002326 897604                  		mov	[format],si
 15900 00002329 8846FE                  		mov	[char],al	; char = *format++
 15901 0000232C 08C0                    		or	al,al		; char == '\0'?
 15902 0000232E 7406                    		jz	short output_done ; yes - end loop
 15903 00002330 837EF800                		cmp	word [charsout],0 ; charsout < 0
 15904 00002334 7D06                    		jge	short output_loopok ; no - don't end loop
 15905                                  output_done:
 15906 00002336 8B46F8                  		mov	ax,[charsout]	; return chars written
 15907 00002339 E9D403                  		jmp	output_return
 15908                                  
 15909                                  output_loopok:
 15910 0000233C BB[0AA0]                		mov	bx,lookuptable	; bx points to lookup table
 15911 0000233F 2C20                    		sub	al,' ' ; 20h	; al = char - ' '
 15912 00002341 3C58                    		cmp	al,'X'		; beyond end of table?
 15913 00002343 7705                    		ja	short output_main1 ; yes, make it other char
 15914 00002345 D7                      		xlat			; al = lookuptable[al]
 15915 00002346 240F                    		and	al,0Fh		; keep low nybble -- al has char class
 15916 00002348 EB02                    		jmp	short output_main2
 15917                                  
 15918                                  output_main1:
 15919 0000234A B000                    		mov	al,0  ; CH_OTHER ; not in table, must be other
 15920                                  output_main2:
 15921 0000234C B103                    		mov	cl,3
 15922 0000234E D2E0                    		shl	al,cl		; al *= 8
 15923 00002350 0246FB                  		add	al,[state]	; al += state
 15924 00002353 D7                      		xlat			; al = lookuptable[al]
 15925 00002354 FEC1                    		inc	cl		; cl = 4
 15926 00002356 D2E8                    		shr	al,cl		; al >>= 4
 15927 00002358 8846FB                  		mov	[state],al	; save new state	
 15928 0000235B 98                      		cbw			; zero ah (al < 80h)
 15929                                  	
 15930                                  	; ax now has the state # (recall ah = 0) -- now we
 15931                                  	; use this to index into a jump table and go to
 15932                                  	; correct code for the current state
 15933                                  
 15934 0000235C 89C3                    		mov	bx,ax
 15935 0000235E D1E3                    		shl	bx,1		; index words (bx = state #)
 15936                                  		;jmp	jumptable[bx]
 15937                                  		;jmp	far [cs:bx+jumptable]
 15938 00002360 FFA7[FF22]              		jmp	word [bx+jumptable] ; jump to correct state code
 15939                                  
 15940                                  normal_state:
 15941                                  		; normal state - just output the character involved
 15942 00002364 8A56FE                  		mov	dl,[char]
 15943 00002367 B90100                  		mov	cx,1
 15944 0000236A E81104                  		call	outpad
 15945 0000236D EBB3                    		jmp	short loopagain
 15946                                  
 15947                                  percent_state:
 15948                                  		; just read the percent character
 15949 0000236F 31C0                    		xor	ax,ax ; 0
 15950 00002371 8946F0                  		mov	[prfxlen],ax	; prfxlen = 0
 15951 00002374 8946F6                  		mov	[fldwidth],ax	; fldwidth = 0
 15952 00002377 8946EE                  		mov	[capexp],ax	; capexp = 0
 15953                                  ;if sizeD
 15954                                  ;	mov	flags, FL_FAR		; large data -- default far ptrs
 15955                                  ;else
 15956                                  ;	mov	flags, ax		; small data -- default near ptrs
 15957                                  ;endif
 15958 0000237A 8946FC                  		mov	[flags],ax	; flags = 0
 15959 0000237D 48                      		dec	ax
 15960 0000237E 8946F4                  		mov	[precision],ax	; precision = -1 (default)
 15961 00002381 EB9F                    		jmp	short loopagain	; end of state code
 15962                                  
 15963                                  flag_state:
 15964                                  		; just read a flag, so set the flag bits accordingly
 15965 00002383 8A46FE                  		mov	al,[char]
 15966 00002386 3C2D                    		cmp	al,'-'
 15967 00002388 7506                    		jne	short fl1
 15968                                  doprnt_case_minus:
 15969                                  		;or	flags1,FL_LEFT
 15970 0000238A 804EFC04                		or	byte [flags],4	; FL_LEFT
 15971                                  					; char=='-' => left justify
 15972 0000238E EB92                    		jmp	short loopagain
 15973                                  fl1:
 15974 00002390 3C2B                    		cmp	al,'+'
 15975 00002392 7506                    		jne	short fl2	
 15976                                  doprnt_case_plus:
 15977                                  		;or	flags1,FL_SIGN
 15978 00002394 804EFC01                		or	byte [flags],1	; FL_SIGN
 15979                                  					; char=='+' => force sign indicator
 15980 00002398 EB88                    		jmp	short loopagain
 15981                                  fl2:
 15982 0000239A 3C20                    		cmp	al,' '		; FL_SIGNSP 
 15983 0000239C 7507                    		jnz	short fl3
 15984                                  doprnt_case_space:
 15985                                  		;or	flags1,FL_SIGNSP
 15986 0000239E 804EFC02                		or	byte [flags],2	; char==' ' => as above, 
 15987                                  					; but space not +
 15988 000023A2 E97DFF                  		jmp	loopagain	; end of state
 15989                                  fl3:
 15990 000023A5 3C23                    		cmp	al,'#'		 
 15991 000023A7 7507                    		jnz	short fl4
 15992                                  doprnt_case_sharp:
 15993                                  		;or	flags1,FL_ALTERNATE
 15994 000023A9 804EFC80                		or	byte [flags],80h ; FL_ALTERNATE 
 15995                                  					; char=='#' => alternate form
 15996 000023AD E972FF                  		jmp	loopagain
 15997                                  fl4:
 15998                                  		;or	flags1,FL_LEADZERO
 15999 000023B0 804EFC08                		or	byte [flags],8	; FL_LEADZERO
 16000 000023B4 E96BFF                  		jmp	loopagain	; char=='0' => pade with leading zeros
 16001                                  width_state:
 16002                                  		; just read a width specifier -- set width value
 16003 000023B7 8A4EFE                  		mov	cl,[char]
 16004 000023BA 80F92A                  		cmp	cl,'*'		; char == '*'
 16005 000023BD 750F                    		jne	short widthdigit ; no - must be a digit
 16006                                  		; char == '*' means get width from argument list	
 16007 000023BF E85403                  		call	getwordarg	; AX = word argument	
 16008 000023C2 09C0                    		or	ax,ax		; ax < 0
 16009 000023C4 7917                    		jns	short storewidth ; no - do normal
 16010 000023C6 F7D8                    		neg	ax		; ANSI: neg width means - flags
 16011                                  		;or	flags1, FL_LEFT
 16012 000023C8 804EFC04                		or	byte [flags],4	;FL_LEFT ; and positive width
 16013 000023CC EB0F                    		jmp	short storewidth
 16014                                  widthdigit:
 16015                                  		; we just read a digit to add to the stored width value
 16016 000023CE 80E930                  		sub	cl,'0'
 16017 000023D1 30ED                    		xor	ch,ch		; dx = value of digit
 16018 000023D3 8B46F6                  		mov	ax,[fldwidth]
 16019 000023D6 BB0A00                  		mov	bx,10
 16020 000023D9 F7E3                    		mul	bx
 16021 000023DB 01C8                    		add	ax,cx		; fldwidth = 10*fldwidth + (digit-'0')
 16022                                  storewidth:
 16023 000023DD 8946F6                  		mov	[fldwidth],ax
 16024 000023E0 E93FFF                  		jmp	loopagain
 16025                                  
 16026                                  dot_state:
 16027                                  		; We just read the dot -- char must == '.'
 16028                                  		; and all we need to do is zero the precision.
 16029 000023E3 C746F40000              		mov	word [precision],0	; zero precision, no longer default
 16030 000023E8 E937FF                  		jmp	loopagain
 16031                                  
 16032                                  precis_state:
 16033                                  		; just read a precision specifier -- set precision value
 16034 000023EB 8A4EFE                  		mov	cl,[char]
 16035 000023EE 80F92A                  		cmp	cl,'*'		; char == '*'
 16036 000023F1 750C                    		jne	short precisdigit ; no - must be a digit
 16037                                  		; char == '*' means get precision from argument list
 16038 000023F3 E82003                  		call	getwordarg	; AX = word argument
 16039 000023F6 09C0                    		or	ax,ax		; ax < 0
 16040 000023F8 7914                    		jns	short storeprecis ; no - do normal
 16041 000023FA B8FFFF                  		mov	ax,0FFFFh ; -1	; ANSI: neg precis. means default value	
 16042 000023FD EB0F                    		jmp	short storeprecis
 16043                                  
 16044                                  precisdigit:
 16045                                  		; we just read a digit to add to the stored precision value
 16046 000023FF 80E930                  		sub	cl,'0'
 16047 00002402 30ED                    		xor	ch,ch
 16048 00002404 8B46F4                  		mov	ax,[precision]
 16049 00002407 BB0A00                  		mov	bx,10
 16050 0000240A F7E3                    		mul	bx
 16051 0000240C 01C8                    		add	ax,cx	; precision = 10*precision + (digit-'0')
 16052                                  storeprecis:
 16053 0000240E 8946F4                  		mov	[precision],ax	; store precision
 16054 00002411 E90EFF                  		jmp	loopagain
 16055                                  
 16056                                  size_state:
 16057                                  		; just read a size specifier -- set the flags based on it
 16058 00002414 8A46FE                  		mov	al,[char]
 16059 00002417 3C6C                    		cmp	al,'l'
 16060 00002419 7506                    		jne	short sz1
 16061                                  		;or	byte [flags1],FL_LONG
 16062 0000241B 804EFC10                		or	byte [flags],10h ; FL_LONG
 16063                                  				; char=='l' or 'L' => long value given
 16064 0000241F EB22                    		jmp	short szret
 16065                                  sz1:
 16066 00002421 3C46                    		cmp	al,'F'		
 16067 00002423 7506                    		jne	short sz2
 16068                                  		;or 	byte [flags1],FL_FAR
 16069 00002425 804EFC20                		or	byte [flags],20h ; FL_FAR
 16070                                  					; char=='F' => far ptr given
 16071 00002429 EB18                    		jmp	short szret
 16072                                  sz2:
 16073 0000242B 3C4E                    		cmp	al,'N'
 16074 0000242D 7506                    		jnz	short sz3
 16075                                  		;or	byte [flags2],FL_NEAR
 16076 0000242F 804EFD10                		or	byte [flags+1],10h ; FL_NEAR
 16077                                  					; char=='N' => near ptr given	
 16078 00002433 EB0E                    		jmp	short szret
 16079                                  sz3:
 16080 00002435 3C4C                    		cmp	al,'L'
 16081 00002437 7506                    		jnz	short sz4
 16082                                  		;or	byte [flags2],FL_LONGDOUBLE
 16083 00002439 804EFD04                		or	byte [flags+1],4 ; FL_LONGDOUBLE
 16084                                  					; char=='L' => long double given	
 16085 0000243D EB04                    		jmp	short szret
 16086                                  sz4:
 16087                                  		; at this point we must have h given
 16088                                  		;or	byte [flags2], FL_SHORT
 16089 0000243F 804EFD08                		or	byte [flags+1],8 ; FL_SHORT
 16090                                  szret:					; char=='h' => short value given
 16091 00002443 E9DCFE                  		jmp	loopagain
 16092                                  
 16093                                  type_state:
 16094                                  	; OK, we just read the type specifier character, so we now actually
 16095                                  	; have to format and 'print' the output. We do this with the
 16096                                  	; equivalent of a big switch statement to routines that formats the
 16097                                  	; correct input and set ES:DI to point to the text to print
 16098                                  	; and CX to the length of this output. Common code later on
 16099                                  	; then takes care of right/left justifying it. Note that many of
 16100                                  	; the cases share code; in particular all integer formatting is
 16101                                  	; done in one place.
 16102                                  
 16103 00002446 8A46FE                  		mov	al,[char]
 16104 00002449 3C64                    		cmp	al,'d'
 16105 0000244B 7503                    		jne	short t1
 16106                                  		;jmp	doprnt_case_i_d
 16107 0000244D E98D01                  		jmp	type_d
 16108                                  t1:
 16109 00002450 3C69                    		cmp	al,'i'
 16110 00002452 7503                    		jne	short t2
 16111                                  		;jmp	doprnt_case_i_d
 16112 00002454 E98601                  		jmp	type_i
 16113                                  t2:
 16114 00002457 3C75                    		cmp	al,'u'
 16115 00002459 7503                    		jne	short t3
 16116 0000245B E98301                  		jmp	type_u
 16117                                  t3:
 16118 0000245E 3C58                    		cmp	al,'X'
 16119 00002460 7503                    		jne	short t4
 16120 00002462 E98201                  		jmp	type_bigx
 16121                                  t4:
 16122 00002465 3C78                    		cmp	al,'x'
 16123 00002467 7503                    		jne	short t5
 16124 00002469 E98101                  		jmp	type_x
 16125                                  t5:
 16126 0000246C 3C6F                    		cmp	al,'o'
 16127 0000246E 7503                    		jne	short t6
 16128 00002470 E99B01                  		jmp	type_o
 16129                                  t6:
 16130 00002473 3C63                    		cmp	al,'c'
 16131 00002475 741A                    		je	short type_c
 16132 00002477 3C73                    		cmp	al,'s'
 16133 00002479 7427                    		je	short type_s
 16134 0000247B 3C6E                    		cmp	al,'n'
 16135 0000247D 7451                    		je	short type_n
 16136 0000247F 3C70                    		cmp	al,'p'
 16137 00002481 7460                    		je	short type_p
 16138 00002483 3C45                    		cmp	al,'E'
 16139 00002485 7407                    		je	short bigeg
 16140 00002487 3C47                    		cmp	al,'G'
 16141 00002489 7403                    		je	short bigeg
 16142                                  
 16143                                  	; only possible remaining type is 'e', 'f', 'g' -- go to it
 16144 0000248B E9BB00                  		jmp	type_efg	;'e', 'f', 'g' same destination	
 16145                                  bigeg:
 16146 0000248E E9B500                  		jmp	type_bigeg
 16147                                  
 16148                                  	; Now we do case by case output formatting
 16149                                  type_c:
 16150                                  		; character output
 16151 00002491 E88202                  		call	getwordarg	; AX = word argument
 16152                                  		;lea	di,[bp-369] ;  PC-DOS 7.0 FDISK.COM
 16153 00002494 8DBEECFD                		lea	di,[output_buff]
 16154 00002498 16                      		push	ss
 16155 00002499 07                      		pop	es		; es:di points to buffer	
 16156 0000249A AA                      		stosb
 16157 0000249B 4F                      		dec	di		; mov es:[di],al
 16158 0000249C B90100                  		mov	cx,1		; length of 1
 16159 0000249F E9E801                  		jmp	justify		; goto general justify/output
 16160                                  type_s:
 16161                                  	; string output -- must handle both far and near
 16162                                  	; we have to know how much of the string to print -- rule is
 16163                                  	; all of it if precision is default, min(precision, length) if
 16164                                  	; precision given. We do it simply as one computation here
 16165                                  	; because default precision stored as -1, which we treat
 16166                                  	; as 65535, the longest possible string length.
 16167                                  	; a null ptr is printed as '(null)'
 16168                                  
 16169 000024A2 E88502                  		call	getptrarg	; read pointer into es:di
 16170 000024A5 09FF                    		or	di,di		; di == 0?
 16171 000024A7 7512                    		jnz	short s2	; no - a normal string	
 16172 000024A9 8CC0                    		mov	ax,es
 16173 000024AB 09C0                    		or	ax,ax		; es == 0?
 16174 000024AD 750C                    		jnz	short s2	; no - a normal string	
 16175                                  
 16176 000024AF 1E                      		push	ds
 16177 000024B0 07                      		pop	es
 16178 000024B1 BF[63A0]                		mov	di,nullstring ;	"(null)"  ; es:di points to '(null)'
 16179 000024B4 8B0E[69A0]              		mov	cx,[nullstrlen]	; cx has the length
 16180 000024B8 E9CF01                  		jmp	justify		; go to justify routine
 16181                                  s2:
 16182 000024BB 57                      		push	di		; save di
 16183 000024BC 8B4EF4                  		mov	cx,[precision]	; how much of string to scan
 16184 000024BF E307                    		jcxz	s3		; precision == 0; print nothing
 16185 000024C1 30C0                    		xor	al,al		; scan for '\0'
 16186 000024C3 F2AE                    		repne scasb		; scan string - zero flag set if found
 16187 000024C5 7501                    		jnz	short s3	; no - we scanned exactly precision bytes	
 16188 000024C7 4F                      		dec	di		; yes - point to the null byte
 16189                                  s3:
 16190                                  		; di now points just beyond last byte to print
 16191 000024C8 59                      		pop	cx		; cx has old di
 16192 000024C9 29CF                    		sub	di,cx		; di has count of bytes
 16193 000024CB 87CF                    		xchg	cx,di		; di restored, cx has count of bytes
 16194 000024CD E9BA01                  		jmp	justify		; goto justify/output
 16195                                  type_n:
 16196                                  		; store count of characters written so far into int/long
 16197                                  		; pointed to by pointer argument.
 16198                                  		; NOTHING IS OUTPUT
 16199                                  
 16200 000024D0 E85702                  		call	getptrarg	; read ptr into es:di
 16201 000024D3 8B46F8                  		mov	ax,[charsout]	; ax = number of characters written
 16202 000024D6 AB                      		stosw
 16203                                  		;test	byte [flags1],FL_LONG
 16204 000024D7 F646FC10                		test	byte [flags],10h ; FL_LONG ; a long value?
 16205 000024DB 7403                    		jz	short n1	; no - just a short
 16206 000024DD 31C0                    		xor	ax,ax		; clear ax
 16207 000024DF AB                      		stosw			; store high word (0)
 16208                                  n1:
 16209 000024E0 E93FFE                  		jmp	loopagain	; skip output, go straight to loop top
 16210                                  type_p:
 16211                                  		; write a pointer -- this is complicated by the fact that
 16212                                  		; the pointer could be 2 bytes or 4 bytes on the stack,
 16213                                  		; and that we can output in seg:off or off form.
 16214                                  
 16215                                  		;test	byte [flags1],FL_FAR | FL_LONG
 16216 000024E3 F646FC30                		test	byte [flags],30h ; FL_FAR | FL_LONG
 16217 000024E7 7505                    		jnz	short p4byte	; 4 or 2 bytes on stack?	
 16218 000024E9 E82A02                  		call	getwordarg	; get 2 byte ptr in AX
 16219 000024EC EB39                    		jmp	short pshortfmt	; read 2 bytes implies short format
 16220                                  p4byte:
 16221 000024EE E82D02                  		call	getlongarg	; get 4 byte ptr into DX:AX
 16222                                  
 16223                                  		;test	byte [flags2],FL_SHORT| FL_NEAR
 16224 000024F1 F646FD18                		test	byte [flags+1],18h ; specified short format?
 16225 000024F5 7530                    		jnz	short pshortfmt	; yes - goto short format
 16226                                  
 16227                                  		; output xxxx:yyyy
 16228                                  
 16229                                  		;mov byte [heaxadd], 'A' - '9' - 1
 16230 000024F7 C646FF07                		mov	byte [hexadd],7 ; use uppercase hex	
 16231 000024FB B91000                  		mov	cx,16		; radix 16
 16232 000024FE 16                      		push	ss
 16233 000024FF 07                      		pop	es		; es point to segment with buffer
 16234 00002500 52                      		push	dx		; save segment
 16235 00002501 31D2                    		xor	dx,dx		; no high word
 16236                                  		;lea	di,[bp-361]	; IBM PC-DOS 7.0 FDISK.COM
 16237                                  		;lea	di,buffer[8]	; point to end of offset spot in buffer
 16238 00002503 8DBEF4FD                		lea	di,[output_buff+8]
 16239 00002507 BE0400                  		mov	si,4		; 4 digit output
 16240 0000250A E88602                  		call	convert		; convert and place in buffer
 16241                                  
 16242 0000250D B91000                  		mov	cx,16		; radix 16 again
 16243                                  		;lea	di,[bp-366]	; IBM PC-DOS 7.0 FDISK.COM
 16244                                  		;lea	di,buffer[3]	; point to end of segment spot in buffer
 16245 00002510 8DBEEFFD                		lea	di,[output_buff+3]
 16246 00002514 58                      		pop	ax		; ax has segment
 16247 00002515 31D2                    		xor	dx,dx		; no high word
 16248 00002517 BE0400                  		mov	si,4		; 4 digit output again
 16249 0000251A E87602                  		call	convert		; convert again
 16250                                  
 16251                                  		;mov	byte [bp-365],':'
 16252                                  		;mov	buffer[4], ':'	; put colon in middle
 16253 0000251D C686F0FD3A              		mov	byte [output_buff+4],':'
 16254 00002522 B90900                  		mov	cx,9		; 9 character output
 16255 00002525 EB18                    		jmp	short p1	; skip near ptr code	
 16256                                  pshortfmt:
 16257                                  		;  output xxxx:yyyy
 16258                                  
 16259                                  		;mov	byte [hexadd],'A' - '9' - 1 ; use uppercase hex
 16260 00002527 C646FF07                		mov	byte [hexadd],7
 16261 0000252B B91000                  		mov	cx,16		; radix 16
 16262 0000252E 16                      		push	ss
 16263 0000252F 07                      		pop	es		; es point to segment with buffer
 16264 00002530 31D2                    		xor	dx,dx		; no high word
 16265                                  		;lea	di,[bp-366]
 16266                                  		;lea	di,buffer[3]	
 16267 00002532 8DBEEFFD                		lea	di,[output_buff+3] ; point to end of 4 byte buffer
 16268 00002536 BE0400                  		mov	si,4		; 4 character output format
 16269 00002539 E85702                  		call	convert		; convert it into buffer
 16270 0000253C B90400                  		mov	cx,4		; 4 character text length
 16271                                  p1:
 16272                                  		;lea	di,[bp+369]
 16273                                  		;lea	di, buffer	; di points to buffer, cx has length
 16274 0000253F 8DBEECFD                		lea	di,[output_buff]
 16275 00002543 E94401                  		jmp	justify		; justify and output
 16276                                  type_bigeg:
 16277                                  		;inc	word [capexp]	; capitalize exponent
 16278 00002546 FE46EE                  		inc	byte [capexp]
 16279                                  type_efg:
 16280                                  		; floating point conversion -- this is relatively easy
 16281                                  		; because cfltcvt does the work for us
 16282                                  
 16283                                  		;or	flags1, FL_SIGNED ; this is a signed conversion
 16284 00002549 804EFC40                		or	byte [flags],40h
 16285 0000254D 8A46FE                  		mov	al,[char]
 16286 00002550 0C20                    		or	al,20h		; convert to lower case
 16287 00002552 98                      		cbw			; ax has format char is lower case
 16288 00002553 89C6                    		mov	si,ax
 16289 00002555 837EF400                		cmp	word [precision],0
 16290 00002559 7F12                    		jg	short f2	; precision > 0, no adjustment	
 16291 0000255B 7407                    		je	short f1	; precision = 0
 16292 0000255D C746F40600              		mov	word [precision],6 ; precision < 0, make it 6 (default)
 16293 00002562 EB09                    		jmp	short f2
 16294                                  f1:
 16295                                  		;cmp	ax,'g'
 16296 00002564 3C67                    		cmp	al,'g'
 16297 00002566 7505                    		jne	short f2
 16298 00002568 C746F40100              		mov	word [precision],1
 16299                                  f2:
 16300                                  		;lea	di,[bp+369]	; PC--DOS 7.0 FDISK.COM
 16301                                  		;lea	di,buffer	; ss:di points to buffer
 16302 0000256D 8DBEECFD                		lea	di,[output_buff]
 16303                                  
 16304 00002571 FF76EE                  		push	word [capexp]
 16305 00002574 FF76F4                  		push	word [precision]
 16306                                  
 16307 00002577 56                      		push	si		; si has format character
 16308                                  ;if sizeD
 16309                                  ;	push	ss
 16310                                  ;else
 16311                                  ;ifdef _WINDOWS			; buffer in ss
 16312                                  ;	push	ss
 16313                                  ;endif
 16314                                  ;endif
 16315 00002578 57                      		push	di		; push pointer to buffer
 16316                                  ;
 16317                                  ;if sizeD
 16318                                  ;	push	word ptr (arglist[2])
 16319                                  ;else
 16320                                  ;ifdef _WINDOWS			; args in ss
 16321                                  ;	push	ss
 16322                                  ;endif
 16323                                  ;endif
 16324 00002579 FF7606                  		push	word [arglist]	; push arglist
 16325                                  
 16326                                  		;test	flags2,FL_LONGDOUBLE
 16327 0000257C F646FD04                		test	byte [flags+1],4 ; FL_LONGDOUBLE
 16328 00002580 740A                    		jz	short f3
 16329                                  		;call	_cldcvt
 16330                                  		; 14/12/2018
 16331 00002582 FF16[76A0]              		call	word [_cldcvt]	; do long double conversion
 16332 00002586 8346060A                		add	word [arglist],10  ; go to next argument 
 16333                                  					   ; (long double is 10 bytes)
 16334 0000258A EB08                    		jmp	short f4
 16335                                  f3:
 16336                                  		;call	_cfltcvt
 16337                                  		; 14/12/2018
 16338 0000258C FF16[70A0]              		call	word [_cfltcvt]	; do float conversion	
 16339 00002590 83460608                		add	word [arglist],8 ; go to next argument 
 16340                                  					; (double is 8 bytes)
 16341                                  f4:
 16342                                  ;if sizeD
 16343                                  ;	add	sp, 14
 16344                                  ;else
 16345                                  ;ifdef _WINDOWS
 16346                                  ;	add	sp, 14
 16347                                  ;else
 16348 00002594 83C40A                  		add	sp,10		; pop arguments
 16349                                  ;endif
 16350                                  		;test	flags1,FL_ALTERNATE	; alternate form?
 16351 00002597 F646FC80                		test	byte [flags],80h ; FL_ALTERNATE
 16352 0000259B 740E                    		jz	short f5
 16353 0000259D 837EF400                		cmp	word [precision],0 ; precision == 0?
 16354 000025A1 7508                    		jne	short f5	; no - skip decimal forcing
 16355                                  	
 16356                                  	; '#' flag and precision == 0 => need to stick in a decimal point
 16357                                  ;if sizeD
 16358                                  ;	push	ss
 16359                                  ;else
 16360                                  ;	ifdef _WINDOWS
 16361                                  ;		push	ss
 16362                                  ;	endif
 16363                                  ;endif
 16364 000025A3 57                      		push	di		; push pointer to buffer
 16365                                  		;call	_forcdecpt	; force decimal point
 16366                                  		; 14/12/2018
 16367 000025A4 FF16[74A0]              		call	word [_forcdecpt]
 16368                                  ;if sizeD
 16369                                  ;	add	sp, 4
 16370                                  ;else
 16371                                  ;	ifdef _WINDOWS
 16372                                  ;		add	sp, 4
 16373                                  ;	else
 16374 000025A8 83C402                  		add	sp,2		; restore stack
 16375                                  ;	endif				
 16376                                  ;endif
 16377                                  
 16378                                  f5:
 16379 000025AB 83FE67                  		cmp	si,'g'		; g format?
 16380 000025AE 750F                    		jne	short f6	; no - skip zero cropping
 16381                                  		
 16382                                  		;test	flags,FL_ALTERNATE ; '#' given
 16383 000025B0 F746FC8000              		test	word [flags],80h
 16384 000025B5 7508                    		jnz	short f6	; yes - skip zero cropping
 16385                                  
 16386                                  		; 'g' format and no '#' flag => crop trailing zeros
 16387                                  ;if sizeD
 16388                                  ;	push	ss
 16389                                  ;else
 16390                                  ;	ifdef _WINDOWS
 16391                                  ;		push	ss
 16392                                  ;	endif
 16393                                  ;endif
 16394 000025B7 57                      		push	di		; push pointer to buffer
 16395                                  		;call	_cropzeros ; crop zeros if g fmt and not alternate form
 16396                                  		; 14/12/2018
 16397 000025B8 FF16[72A0]              		call	word [_cropzeros]
 16398                                  ;if sizeD
 16399                                  ;	add	sp, 4
 16400                                  ;else
 16401                                  ;	ifdef _WINDOWS
 16402                                  ;		add	sp, 4
 16403                                  ;	else
 16404 000025BC 83C402                  		add	sp,2
 16405                                  ;	endif
 16406                                  ;endif					; restore stack
 16407                                  
 16408                                  f6:
 16409 000025BF 16                      		push	ss
 16410 000025C0 07                      		pop	es		; es:di points to text to output
 16411 000025C1 26803D2D                		cmp	byte [es:di], '-' ; are we negative?
 16412 000025C5 7505                    		jne	short f7	; no -- skip it
 16413 000025C7 47                      		inc	di		; go beyond negative sign
 16414                                  		;or	flags2,FL_NEGATIVE ; record negative number
 16415 000025C8 804EFD01                		or	byte [flags+1],1
 16416                                  f7:
 16417                                  		; now we must find length of buffer to output
 16418 000025CC B9FFFF                  		mov	cx,0FFFFh
 16419 000025CF 57                      		push	di
 16420 000025D0 B000                    		mov	al,0		; scan for null byte
 16421 000025D2 F2AE                    		repne scasb	; do the scan -- now di point just after null byte
 16422 000025D4 4F                      		dec	di		; di points to null byte
 16423 000025D5 59                      		pop	cx		; cx has old di
 16424 000025D6 29CF                    		sub	di,cx		; di has length of string
 16425 000025D8 87CF                    		xchg	cx,di		; cx has length, di restored
 16426 000025DA E9AD00                  		jmp	justify		; done -- justify/output it
 16427                                  type_d:		
 16428                                  		;'d' and 'i' and synonymns
 16429                                  doprnt_case_i_d:
 16430                                  type_i:		; signed decimal output
 16431                                  		;or	flags1, FL_SIGNED
 16432 000025DD 804EFC40                		or	byte [flags],40h
 16433                                  type_u:	
 16434                                  		; unsigned decimal output
 16435 000025E1 C646FA0A                		mov	byte [radix],10
 16436 000025E5 EB35                    		jmp	short int_out	; go to common int formatting
 16437                                  type_bigx:
 16438                                  		; unsigned hex output, with ABCDEF
 16439                                  		;mov	hexadd,'A' - '9' - 1	; hex conversion constant, uppercase
 16440 000025E7 C646FF07                		mov	byte [hexadd],7
 16441 000025EB EB04                    		jmp	short dohex
 16442                                  type_x:
 16443                                  		; unsigned hex output, with abcdef
 16444                                  		;mov	hexadd,'a' - '9' - 1	; hex conversion constant, lowercase
 16445 000025ED C646FF27                		mov	byte [hexadd],27h
 16446                                  
 16447                                  dohex:		
 16448                                  		;test	flags1,FL_ALTERNATE ; alternate form?
 16449 000025F1 F646FC80                		test	byte [flags],80h
 16450 000025F5 7411                    		jz	short hex1		; no -- skip alternate formatting
 16451 000025F7 C746F00200              		mov	word [prfxlen],2	; yes, store 2-byte hex prefix
 16452 000025FC C646F230                		mov	byte [prefix],'0'
 16453                                  		;mov	dl,'x'-'a'+'9'+1
 16454 00002600 B251                    		mov	dl,51h
 16455 00002602 0256FF                  		add	dl,[hexadd]
 16456 00002605 8856F3                  		mov	byte [prefix+1],dl	; byte 2: 'x' or 'X' as appropriate
 16457                                  hex1:
 16458 00002608 C646FA10                		mov	byte [radix],16
 16459 0000260C EB0E                    		jmp	short int_out
 16460                                  type_o:
 16461                                  		; unsigned octal output
 16462                                  		;test	flags1,FL_ALTERNATE	; alternate form?
 16463 0000260E F646FC80                		test	byte [flags],80h
 16464 00002612 7404                    		jz	short oct1		; no - skip alternate formatting
 16465                                  		;or	flags2,FL_FORCEOCTAL	; force leading zero
 16466 00002614 804EFD02                		or	byte [flags+1],2
 16467                                  oct1:
 16468 00002618 C646FA08                		mov	byte [radix],8
 16469                                  
 16470                                  int_out:
 16471                                  	; Here is the common integer formatting routine.
 16472                                  	; Note that shorts and ints are the same, so we ignore FL_SHORT
 16473                                  
 16474                                  ; 1.  Read argument from arglist; if a word, extend into long as appropriate
 16475                                  		;test	flags1,FL_LONG		; read long word?
 16476 0000261C F646FC10                		test	byte [flags],10h
 16477 00002620 7405                    		jz	short int1		; no - read short word
 16478 00002622 E8F900                  		call	getlongarg		; read long word into dx:ax
 16479 00002625 EB0E                    		jmp	short int3
 16480                                  int1:
 16481 00002627 E8EC00                  		call	getwordarg		; read short word into ax
 16482                                  		;test	flags1,FL_SIGNED	; signed argument?
 16483 0000262A F646FC40                		test	byte [flags],40h
 16484 0000262E 7403                    		jz	short int2		; no - goto zeroextend
 16485 00002630 99                      		cwd				; sign extend ax -> dx:ax
 16486 00002631 EB02                    		jmp	short int3
 16487                                  int2:
 16488 00002633 31D2                    		xor	dx, dx
 16489                                  
 16490                                  ; 2.  If signed and negative, make it positive and remember the negative sign
 16491                                  int3:
 16492                                  		;test	flags1,FL_SIGNED	; signed argument?
 16493 00002635 F646FC40                		test	byte [flags],40h
 16494 00002639 740F                    		jz	short int4		; no - skip this
 16495 0000263B 09D2                    		or	dx,dx			; dx:ax < 0?
 16496 0000263D 7D0B                    		jge	short int4		; no - skip this
 16497                                  		;or	flags2,FL_NEGATIVE	; remember negative sign
 16498 0000263F 804EFD01                		or	byte [flags+1],1
 16499 00002643 F7D8                    		neg	ax
 16500 00002645 83D200                  		adc	dx, 0
 16501 00002648 F7DA                    		neg	dx			; dx:ax = -dx:ax
 16502                                  
 16503                                  ; 3.  Check the precision value for default; non-default turns off 0 flag (ANSI)
 16504                                  int4:
 16505 0000264A 837EF400                		cmp	word [precision],0	; precision < 0 (default)
 16506 0000264E 7D07                    		jge	short int5		; no - go turn off zero flag
 16507 00002650 C746F40100              		mov	word [precision],1	; default precision = 1
 16508 00002655 EB04                    		jmp	short int6		; don't turn off zero flag
 16509                                  int5:
 16510                                  		;and	flags1, (NOT FL_LEADZERO) AND 0FFh ; (~FL_LEADZERO) & 0FFh
 16511 00002657 8066FCF7                		and	byte [flags],0F7h ; turn off zero flags when explicit precision
 16512                                  
 16513                                  ; 4.  Check if data is zero, if so, turn off hex prefix
 16514                                  int6:
 16515 0000265B 89C3                    		mov	bx,ax
 16516 0000265D 09D3                    		or	bx,dx			; dx:ax == 0?
 16517 0000265F 7505                    		jnz	short int7		; no - skip this
 16518 00002661 C746F00000              		mov	word [prfxlen],0	; kill hex prefix for zero data
 16519                                  
 16520                                  ; 5.  Convert data into ASCII characters
 16521                                  int7:
 16522                                  		;lea	di,[bp-21]	 ; IBM PC-DOS 7.0 FDISK.COM
 16523                                  		;lea	di,buffer[BUFSIZE-1]
 16524 00002666 8D7EEB                  		lea	di,[output_buff+BUFSIZE-1] ; [output_buf+511] = [bp-(532-511)]
 16525 00002669 16                      		push	ss
 16526 0000266A 07                      		pop	es			; es:di points at end of buffer
 16527 0000266B 8A4EFA                  		mov	cl,[radix]
 16528 0000266E 30ED                    		xor	ch,ch			; cx = radix
 16529 00002670 8B76F4                  		mov	si,[precision]		; si = precision
 16530 00002673 E81D01                  		call	convert			; Convert that sucker:
 16531                                  						; cx has length, es:di points to digits
 16532                                  ; 6.  Force a leading 0 if FL_FORCEOCTAL set
 16533                                  		;test	flags2,FL_FORCEOCTAL	; FORCEOCTAL flags set?
 16534 00002676 F646FD02                		test	byte  [flags+1],2
 16535 0000267A 740E                    		jz	short int8		; nope - don't do it
 16536 0000267C E306                    		jcxz	addzero			; if printing no digits, add a zero
 16537 0000267E 26803D30                		cmp	byte [es:di],'0'	; first digit already a 0?
 16538 00002682 7406                    		je	short int8		; yep - don't do it
 16539                                  addzero:
 16540 00002684 4F                      		dec	di			; move back a digit
 16541 00002685 26C60530                		mov	byte [es:di],'0'	; add in a zero
 16542 00002689 41                      		inc	cx			; increase number of bytes displayed
 16543                                  ; 7.  Jump to general justify/output procedure
 16544                                  int8:
 16545                                  		;;jmp	short $+2
 16546                                  		;jmp	short justify
 16547                                  
 16548                                  justify:
 16549                                  ; here we justify and output the results
 16550                                  
 16551                                  ; Find any prefix that we need to stick on -- note that hex prefixes
 16552                                  ; have already been done.
 16553                                  
 16554 0000268A B80100                  		mov	ax,1 ; 07/12/2018
 16555                                  
 16556                                  		;test	flags1,FL_SIGNED	; is this a signed conversion?	
 16557 0000268D F646FC40                		test	byte [flags],40h
 16558 00002691 7429                    		jz	short just3		; if not, no sign prefix
 16559                                  		;test	flags2,FL_NEGATIVE	; a negative number?
 16560                                  		;test	byte [flags+1],1
 16561 00002693 8446FD                  		test	[flags+1],al ; 1
 16562 00002696 7409                    		jz	short just1		; no - skip
 16563 00002698 C646F22D                		mov	byte [prefix], '-'	; prefix is '-'
 16564                                  		;mov	word [prfxlen],1	; prefix length = 1
 16565 0000269C 8946F0                  		mov	[prfxlen],ax
 16566 0000269F EB1B                    		jmp	short just3
 16567                                  just1:
 16568                                  		;test	flags1,FL_SIGN		; forcing sign?
 16569                                  		;test	byte [flags],1
 16570 000026A1 8446FC                  		test	[flags],al ; 1
 16571 000026A4 7409                    		jz	short just2
 16572                                  		;mov	prefix[0],'+'		; prefix is '+' (can't be negative)
 16573 000026A6 C646F22B                		mov	byte [prefix],'+'
 16574                                  		;mov	word [prfxlen],1	; prefix length = 1
 16575 000026AA 8946F0                  		mov	[prfxlen],ax
 16576 000026AD EB0D                    		jmp	short just3		; skip next test ('+' overrides ' ')
 16577                                  just2:
 16578                                  		;test	flags1,FL_SIGNSP	; forcing sign with blank?
 16579 000026AF F646FC02                		test	byte [flags],2
 16580 000026B3 7407                    		jz	short just3
 16581                                  		;mov	prefix[0],' '		; prefix is ' ' (can't be negative)
 16582 000026B5 C646F220                		mov	byte [prefix],' '
 16583                                  		;mov	word [prfxlen],1	; prefix length = 1
 16584 000026B9 8946F0                  		mov	[prfxlen],ax
 16585                                  just3:
 16586 000026BC 8B46F6                  		mov	ax,[fldwidth]		; subtract length of text
 16587 000026BF 29C8                    		sub	ax,cx			; ax = width - textlen - prfxlen
 16588 000026C1 2B46F0                  		sub	ax,[prfxlen]
 16589 000026C4 7D02                    		jge	short just4		; ax < 0? skip next
 16590 000026C6 31C0                    		xor	ax,ax			; yes - ax = 0
 16591                                  
 16592                                  ; ax now has amount of padding, it's just a question of where to put it
 16593                                  ; es:di points to output string, cx is length
 16594                                  
 16595                                  just4:
 16596 000026C8 06                      		push	es
 16597 000026C9 57                      		push	di
 16598 000026CA 51                      		push	cx			; save these for now...
 16599                                  
 16600                                  		;test	flags1,FL_LEFT OR FL_LEADZERO ; left justify or lead zero?
 16601 000026CB F646FC0C                		test	byte [flags],0Ch ; FL_LEFT | FL_LEADZERO
 16602 000026CF 7507                    		jnz	short just5
 16603 000026D1 89C1                    		mov	cx,ax
 16604 000026D3 B220                    		mov	dl,' '
 16605 000026D5 E8A600                  		call	outpad
 16606                                  just5:
 16607 000026D8 50                      		push	ax			; save pad count
 16608 000026D9 16                      		push	ss
 16609 000026DA 07                      		pop	es
 16610 000026DB 8D7EF2                  		lea	di,[prefix]		; es:di points to prefix
 16611 000026DE 8B4EF0                  		mov	cx,[prfxlen]		; length of prefix
 16612 000026E1 E88100                  		call	outch			; write prefix
 16613 000026E4 58                      		pop	ax			; recover pad count
 16614                                  
 16615                                  		;test	flags1,FL_LEADZERO	; use leading zeros?
 16616 000026E5 F646FC08                		test	byte [flags],8
 16617 000026E9 740D                    		jz	short just6		; no - don't put padding now
 16618                                  		;test	flags1,FL_LEFT		; left justifying?
 16619 000026EB F646FC04                		test	byte [flags],4
 16620 000026EF 7507                    		jnz	short just6		; yes - skip ('-' overrides '0')
 16621                                  
 16622 000026F1 89C1                    		mov	cx,ax			; amount of padding
 16623 000026F3 B230                    		mov	dl,'0'			; pad with zeros
 16624 000026F5 E88600                  		call	outpad			; write the zero padding
 16625                                  just6:
 16626 000026F8 59                      		pop	cx	
 16627 000026F9 5F                      		pop	di
 16628 000026FA 07                      		pop	es			; recover pointer to text
 16629                                  
 16630 000026FB 50                      		push	ax			; save pad count
 16631 000026FC E86600                  		call	outch			; output the text
 16632 000026FF 58                      		pop	ax			; recover pad count
 16633                                  
 16634                                  		;test	flags1,FL_LEFT		; left justify?
 16635 00002700 F646FC04                		test	byte [flags],4
 16636 00002704 7407                    		jz	short just7		; no - don't put padding now
 16637                                  		
 16638 00002706 89C1                    		mov	cx,ax			; amount of padding
 16639 00002708 B220                    		mov	dl,' '			; pad with spaces
 16640 0000270A E87100                  		call	outpad
 16641                                  
 16642                                  ; Now, everything has been output, just go back to start of loop.
 16643                                  
 16644                                  just7:
 16645 0000270D E912FC                  		jmp	loopagain
 16646                                  
 16647                                  ; 07/12/2018
 16648                                  ; PC-DOS 7.0 FDISK.COM segment 0, offset 7C13h
 16649                                  
 16650                                  output_return:
 16651 00002710 5F                      		pop	di
 16652 00002711 5E                      		pop	si
 16653 00002712 89EC                    		mov	sp,bp
 16654 00002714 5D                      		pop	bp
 16655 00002715 C3                      		retn
 16656                                  
 16657                                  ; ------------------------------------------------------ ;
 16658                                  ; END OF MAIN PROCEDURE -- NOW WE HAVE LOCAL SUBROUTINES ;
 16659                                  ; USED BY THE MAIN PROCEDURE.				 ;
 16660                                  ; ------------------------------------------------------ ;
 16661                                  
 16662                                  ; 07/12/2018
 16663                                  ; PC-DOS 7.0 FDISK.COM segment 0, offset 7B4Eh
 16664                                  
 16665                                  ; ----------------------------------------------------------------------------
 16666                                  
 16667                                  ; Read a word argument from the argument list
 16668                                  ; Bumps arglist by 2 bytes
 16669                                  ;   PARAMETERS: none
 16670                                  ;   RETURNS:	word read in AX
 16671                                  ;   TRASHES:	ES, SI
 16672                                  
 16673                                  ;getwordarg:
 16674                                  ;if sizeD
 16675                                  ;	les	si, arglist
 16676                                  ;	lods	word ptr es:[si]	; ax = *arglist++
 16677                                  ;else
 16678                                  ;	mov	si, arglist
 16679                                  ;	lodsw				; ax = *arglist++
 16680                                  ;endif
 16681                                  ;	mov	word ptr (arglist), si	; store arglist back
 16682                                  ;	retn				; return near
 16683                                  
 16684                                  getwordarg:
 16685                                  		;mov	si,[bp+8]
 16686 00002716 8B7606                  		mov	si,[arglist]	; (%define arglist bp+8)
 16687 00002719 AD                      		lodsw			; ax = *arglist++
 16688                                  		;mov	[bp+8],si
 16689 0000271A 897606                  		mov	[arglist],si	; store arglist back
 16690 0000271D C3                      		retn			; return near
 16691                                  
 16692                                  ; ----------------------------------------------------------------------------
 16693                                  
 16694                                  ; Read a long argument from the argument list
 16695                                  ; Bumps arglist by 4 bytes
 16696                                  ;   PARAMETERS: none
 16697                                  ;   RETURNS:	long read in DX:AX
 16698                                  ;   TRASHES:	ES, SI
 16699                                  
 16700                                  ;getlongarg:
 16701                                  ;if sizeD
 16702                                  ;	les	si, arglist
 16703                                  ;	lods	word ptr es:[si]	; ax = *arglist++  (LSW)
 16704                                  ;	mov	dx, ax			; dx = LSW
 16705                                  ;	lods	word ptr es:[si]	; ax = *arglist++  (MSW)
 16706                                  ;	xchg	dx, ax			; ax = LSW, dx = MSW
 16707                                  ;else
 16708                                  ;	mov	si, arglist
 16709                                  ;	lodsw				; ax = *arglist++  (LSW)
 16710                                  ;	mov	dx, ax			; dx = LSW
 16711                                  ;	lodsw				; ax = *arglist++  (MSW)
 16712                                  ;	xchg	dx, ax			; ax = LSW, dx = MSW
 16713                                  ;endif
 16714                                  ;	mov	word ptr (arglist), si	; store arglist back
 16715                                  ;	retn				; return near
 16716                                  
 16717                                  getlongarg:
 16718                                  		;mov	si,[bp+8]
 16719 0000271E 8B7606                  		mov	si,[arglist]	; (%define arglist bp+8)
 16720 00002721 AD                      		lodsw			; ax = *arglist++  (LSW)
 16721 00002722 89C2                    		mov	dx,ax		; dx = LSW
 16722 00002724 AD                      		lodsw			; ax = *arglist++  (MSW)
 16723 00002725 92                      		xchg	ax,dx		; ax = LSW, dx = MSW
 16724                                  		;mov	[bp+8],si
 16725 00002726 897606                  		mov	[arglist],si	; store arglist back
 16726 00002729 C3                      		retn			; return near
 16727                                  
 16728                                  ; ----------------------------------------------------------------------------
 16729                                  
 16730                                  ; Read a pointer from the argument list into es:di
 16731                                  ; Size of pointer read depends on FL_FAR flag, if near, then
 16732                                  ; ds is used as segment.
 16733                                  ; Note that we don't need to check FL_NEAR, because in C/L models,
 16734                                  ; near ptrs are passed as far, and in S/M models near is default
 16735                                  ; anyway.
 16736                                  ;
 16737                                  ;   PARAMETERS: none
 16738                                  ;   RETURNS:	ES:DI holds pointer read
 16739                                  ;   TRASHES:	AX, DX
 16740                                  
 16741                                  getptrarg:
 16742                                  		;test	flags1, FL_FAR	; a far pointer
 16743 0000272A F646FC20                		test	byte [bp-4],20h
 16744 0000272E 7408                    		jz	short rp1	; no - goto near pointer code
 16745 00002730 E8EBFF                  		call	getlongarg	; read far pointer into dx:ax
 16746 00002733 8EC2                    		mov	es,dx
 16747 00002735 89C7                    		mov	di,ax		; put far pointer into es:di
 16748 00002737 C3                      		retn
 16749                                  rp1:
 16750 00002738 E8DBFF                  		call	getwordarg	; read near pointer into ax
 16751 0000273B 89C7                    		mov	di,ax
 16752 0000273D 09C0                    		or	ax,ax		; read NULL ptr?
 16753 0000273F 7503                    		jnz	short rp2	; no - store ds
 16754 00002741 8EC0                    		mov	es,ax		; make long NULL ptr (ax = 0)
 16755 00002743 C3                      		retn
 16756                                  rp2:
 16757 00002744 1E                      		push	ds
 16758 00002745 07                      		pop	es		; put near pointer into es:di
 16759 00002746 C3                      		retn
 16760                                  
 16761                                  ; ----------------------------------------------------------------------------
 16762                                  
 16763                                  ;  Put a character on the output string -- this is the
 16764                                  ;  equivalent of putc_lk(c, f)
 16765                                  ;    PARAMETERS: AL = character to write
 16766                                  ;    RETURNS:	 AX == -1: error, AX == 0: no error
 16767                                  ;    TRASHED:	 BX
 16768                                  
 16769                                  ;putc: ; 13/12/2018
 16770                                  
 16771                                  ;ifdef CPRFLAG		; put on console instead of to stream
 16772                                  ;
 16773                                  ;	cbw				; sign-extend char to AX
 16774                                  ;	push	es			; save es
 16775                                  ;	push	cx
 16776                                  ;	push	dx			; save cx and dx
 16777                                  ;	push	ax			; parameter: char to write
 16778                                  ;	callcrt _putch			; normal put console character
 16779                                  ;	add	sp, 2			; restore stack
 16780                                  ;	pop	dx
 16781                                  ;	pop	cx			; restore cx, dx
 16782                                  ;	pop	es			; restore es
 16783                                  ;	cmp	ax, -1			; error
 16784                                  ;	je	putchret		; yes - return -1 already in ax
 16785                                  ;	xor	ax, ax			; no - return 0
 16786                                  ;
 16787                                  ;putchret:
 16788                                  ;	retn
 16789                                  ;
 16790                                  ;else ; not CPRFLAG  -  now do normal stream output
 16791                                  
 16792                                  		;13/12/2018
 16793                                  		;cbw
 16794                                  
 16795                                  ;if sizeD
 16796                                  ;	push	es			; save es
 16797                                  ;	push	di			; save di
 16798                                  ;	les	bx, stream		; es:bx is file *
 16799                                  ;	dec	es:[bx]._cnt		; --f->_cnt
 16800                                  ;	js	flush			; out of buffer, must flush
 16801                                  ;	mov	di, word ptr es:[bx]._ptr
 16802                                  ;	inc	word ptr es:[bx]._ptr
 16803                                  ;	mov	es, word ptr es:[bx+2]._ptr ; es:di = *f->_ptr++
 16804                                  ;	stosb				; mov es:[di],al - store byte
 16805                                  ;noerrret:
 16806                                  ;	xor	ax, ax			; no error
 16807                                  ;putcret:
 16808                                  ;	pop	di
 16809                                  ;	pop	es			; restore di, es
 16810                                  ;	retn				; return
 16811                                  ;
 16812                                  ;flush:
 16813                                  ;	push	cx
 16814                                  ;	push	dx			; save cx and dx
 16815                                  ;	push	es
 16816                                  ;	push	bx			; push FILE *
 16817                                  ;	push	ax			; character to write
 16818                                  ;	callcrt _flsbuf 		; call _flsbuf(f, c)
 16819                                  ;	add	sp, 6
 16820                                  ;	pop	dx
 16821                                  ;	pop	cx			; restore cx and dx
 16822                                  ;	cmp	ax,-1			; check for an error
 16823                                  ;	jne	noerrret		; no error, go clear ax and return
 16824                                  ;	jmp	short putcret		; return with ax = -1
 16825                                  ;
 16826                                  ;else ; not DataSize
 16827                                  
 16828                                  		; 13/12/2018
 16829                                  		;push	di
 16830                                  		;;mov	bx,[bp+4]
 16831                                  		;mov	bx,[stream]	; (%define stream bp+4)
 16832                                  		;			; bx is FILE *
 16833                                  		;;dec	[bx]._cnt	; dec f->_cnt
 16834                                  		;;dec	word [bx+_strbuf._cnt]
 16835                                  		;dec	word [bx+2]
 16836                                  		;js	short flush
 16837                                  		;;mov	di,[bx]._ptr
 16838                                  		;;inc	[bx]._ptr	; di = f->_ptr++
 16839                                  		;mov	di,[bx]
 16840                                  		;inc	word [bx]	; [bx+_strbuf.ptr] = _strbuf_ptr 	
 16841                                  		;mov	[di],al		; store byte to write
 16842                                  ;noerrret:
 16843                                  		;xor	ax, ax		; no error
 16844                                  ;putcret:
 16845                                  		;pop	di		; restore di
 16846                                  		;retn			; return
 16847                                  ;flush:
 16848                                  		;push	es
 16849                                  		;push	cx
 16850                                  		;push	dx		; save es, cx and dx
 16851                                  		;push	bx		; push file *
 16852                                  		;push	ax		; character to write
 16853                                  		;call	_flsbuf		; call _flsbuf(f, c)
 16854                                  		;add	sp,4		
 16855                                  		;pop	dx
 16856                                  		;pop	cx
 16857                                  		;pop	es		; restore es, cx and dx
 16858                                  		;cmp	ax,-1		; check for an error
 16859                                  		;jnz	short noerrret	; no error, go clear ax and return
 16860                                  		;jmp	short putcret	; return with ax = -1
 16861                                  
 16862                                  putc:
 16863                                  		; 13/12/2018
 16864                                  		; AL = character to be written
 16865 00002747 FF0E[F2CC]              		dec	word [outbuf_cnt]
 16866 0000274B 7908                    		jns	short putc_1 
 16867                                  		; Write count was ZERO (end of buffer)
 16868                                  putc_0:		
 16869 0000274D FF06[F2CC]              		inc	word [outbuf_cnt]
 16870 00002751 30C0                    		xor	al,al ; 0 (end)
 16871 00002753 F9                      		stc
 16872                                  		; zf = 1 and cf = 1
 16873 00002754 C3                      		retn
 16874                                  putc_1:	
 16875 00002755 06                      		push	es
 16876                                  		;push	di
 16877 00002756 1E                      		push	ds
 16878 00002757 07                      		pop	es
 16879 00002758 8B3E[F0CC]              		mov	di,[outbuf_ptr]
 16880 0000275C AA                      		stosb
 16881 0000275D 893E[F0CC]              		mov	[outbuf_ptr],di
 16882                                  		;pop	di
 16883 00002761 07                      		pop	es
 16884 00002762 08C0                    		or	al,al ; cf = 0, zf = 1 if al = 0
 16885 00002764 C3                      		retn
 16886                                  
 16887                                  ; ----------------------------------------------------------------------------
 16888                                  
 16889                                  ;  Output a character string:
 16890                                  ;  Put a (NOT zero-terminated) string of character on the output
 16891                                  ;  stream, and increment the charsout variable
 16892                                  ;    PARAMETERS:  ES:DI points to string to output
 16893                                  ;		  CX specifies count of characters to output
 16894                                  ;    RETURNS:	  none
 16895                                  ;    TRASHES:	  AX, BX, CX, SI, ES
 16896                                  ;    NOTES:	  The DI is used to accumulate possible error returns from
 16897                                  ;		  the calls to putc. However, it is also saved and restored.
 16898                                  
 16899                                  outch:
 16900 00002765 E316                    		jcxz	outchret	; no characters to write - return
 16901 00002767 89FE                    		mov	si,di		; DS:SI points to string
 16902                                  		;add	[bp-8],	cx
 16903                                  		;add	charsout,cx	; increase count of characters out
 16904 00002769 014EF8                  		add	[charsout],cx	; (%define charsout bp-8)
 16905                                  		; 13/12/2018
 16906                                  		;push	di
 16907                                  		;xor	di,di
 16908                                  out1:
 16909                                  		;;lods	byte ptr es:[si] ; al = next char to write, inc si
 16910 0000276C 26                      		es
 16911 0000276D AC                      		lodsb
 16912 0000276E E8D6FF                  		call	putc		; write that character
 16913                                  		;or	di,ax		; or the return value into di
 16914 00002771 7205                    		jc	short out2 ; 13/12/2018
 16915 00002773 7408                    		jz	short outchret ; 13/12/2018	
 16916 00002775 E2F5                    		loop	out1		; write another character if more
 16917                                  		;or	di,di		; did an error occur?
 16918                                  		;pop	di		; restore di
 16919                                  		;jz	short outchret	; no, return
 16920 00002777 C3                      		retn	; 13/12/2018
 16921                                  out2:
 16922                                  		;mov	word [bp-8],0FFFFh
 16923                                  		;mov	charsout,-1	; yes - signal error, then return
 16924 00002778 C746F8FFFF              		mov	word [charsout],-1
 16925                                  outchret:
 16926 0000277D C3                      		retn
 16927                                  
 16928                                  ; ----------------------------------------------------------------------------
 16929                                  
 16930                                  ; Output a string of identical characters for padding
 16931                                  ;   PARAMETERS:   DL = character to write, CX = count of character to write
 16932                                  ;   RETURNS:	  none
 16933                                  ;   TRASHES:	  AX, BX, CX
 16934                                  ;   NOTES:	  The DI is used to accumulate possible error returns from
 16935                                  ;		  the calls to putc. However, it is also saved and restored.
 16936                                  
 16937                                  outpad:
 16938 0000277E E312                    		jcxz	outpadret	; no character to write -- return
 16939                                  		; 13/12/2018
 16940                                  		;add	[bp-8],cx
 16941                                  		;add	charsout,cx	; increase count of chars written
 16942 00002780 014EF8                  		add	[charsout],cx	; (%define charsout bp-8)
 16943                                  		; 13/12/2018
 16944                                  		;push	di
 16945                                  		;xor	di,di		; clear di
 16946 00002783 88D0                    		mov	al,dl ; 13/12/2018
 16947                                  outpad1:
 16948                                  		;mov	al,dl		; al = char to write
 16949 00002785 E8BFFF                  		call	putc		; write that character
 16950                                  		;or	di,ax		; or the return value into di
 16951 00002788 7203                    		jc	short outpad2 ; 13/12/2018 
 16952 0000278A E2F9                    		loop	outpad1		; write another character if more
 16953                                  		
 16954                                  		;or	di,di		; did an error occur?
 16955                                  		;pop	di		; restore di
 16956                                  		;jz	short outpadret	; no - return
 16957                                  
 16958 0000278C C3                      		retn	; 13/12/2018
 16959                                  outpad2:
 16960                                  		;mov	word [bp-8],0FFFFh
 16961                                  		;mov	charsout,-1	; yes - signal error
 16962 0000278D C746F8FFFF              		mov	word [charsout],-1
 16963                                  outpadret:
 16964 00002792 C3                      		retn
 16965                                  
 16966                                  ; ----------------------------------------------------------------------------
 16967                                  
 16968                                  ; Convert a unsigned long to a character string.
 16969                                  ;   PARAMETERS: DX:AX is number to convert
 16970                                  ;		CX is radix to convert with
 16971                                  ;		ES:DI points to where to store LAST digit
 16972                                  ;		SI is min digits to store (pad with zero until this length)
 16973                                  ;   (N.B. Converting 0 with SI==0 gives blank result: this is correct
 16974                                  ;    and ANSI mandated)
 16975                                  ;
 16976                                  ;   RETURNS:	ES:DI points to first digit
 16977                                  ;		CX is length of digit string
 16978                                  ;
 16979                                  ;   TRASHES:	AX, BX, DX, DI, SI
 16980                                  ;
 16981                                  ;
 16982                                  ;   This algorithm does a 32 bit divided by 16 bit division to
 16983                                  ;   get 32 bit quotient and 16 bit remainder like this (lifted from xtoa.asm):
 16984                                  ;
 16985                                  ;	   h/r	:  (h%r:l)/r
 16986                                  ;      --------------
 16987                                  ;   r  )   h	:   l
 16988                                  ;	 r(h/r)
 16989                                  ;	 ------------
 16990                                  ;	  h%r	:   l
 16991                                  ;	 r((h%r:l)/r)
 16992                                  ;	 ------------
 16993                                  ;		((h%r):l)%r  (REMAINDER)
 16994                                  
 16995                                  convert:
 16996 00002793 FD                      		std			; store string in reverse
 16997 00002794 57                      		push	di		; save di
 16998 00002795 93                      		xchg	ax,bx		; dx = h, bx = l
 16999                                  conv1:
 17000 00002796 09F6                    		or	si,si		; si == 0?
 17001 00002798 7F08                    		jg	short conv2	; count > 0 => keep converting
 17002 0000279A 09DB                    		or	bx,bx		; l == 0?
 17003 0000279C 7504                    		jnz	short conv2	; l != 0 => keep converting
 17004 0000279E 09D2                    		or	dx,dx		; h == 0?
 17005                                  		;jnz	short conv2	; h != 0 => keep converting	
 17006                                  		;jmp	short conv4	; stop converting (h:l==0, count<=0);
 17007 000027A0 741A                    		jz	short conv4	
 17008                                  conv2:
 17009 000027A2 92                      		xchg	ax,dx		; ax = h, bx = l
 17010 000027A3 31D2                    		xor	dx,dx		; ax = h, bx = l, dx = 0
 17011 000027A5 F7F1                    		div	cx		; ax = h/r, dx = h%r, bx = l
 17012 000027A7 93                      		xchg	ax,bx		; dx = h%r, ax = l, bx = h/r
 17013 000027A8 F7F1                    		div	cx		; ax = (h%r:l)/r, dx = (h%r:l)%r, bx = h/r
 17014                                  					; bx:ax = (h:l)/r, dx = (h:l)%r
 17015 000027AA 92                      		xchg	ax,dx		; bx:dx = (h:l)/r, ax = (h:l)%r
 17016 000027AB 87D3                    		xchg	dx,bx		; dx:bx = (h:l)/r, ax = (h:l)%r
 17017                                  
 17018                                  ; now al has x%r, which is the numeric value of the digit -- now convert to ASCII
 17019                                  
 17020 000027AD 0430                    		add	al,'0'
 17021 000027AF 3C39                    		cmp	al,'9'		; a normal digit?
 17022 000027B1 7603                    		jbe	short conv3	; yes, store it
 17023                                  		;add	al,[bp-1]
 17024                                  		;add	al,hexadd	; no, convert to hex
 17025 000027B3 0246FF                  		add	al,[hexadd]	; (%define hexadd bp-1)
 17026                                  conv3:
 17027 000027B6 AA                      		stosb			; *(es:di) = al, --di
 17028 000027B7 89D0                    		mov	ax,dx		; ax:bx = (h:l)/r
 17029 000027B9 4E                      		dec	si		; stored a digit, subtract from count
 17030 000027BA EBDA                    		jmp	short conv1
 17031                                  	
 17032                                  	; OK, we're done -- set up the return values
 17033                                  conv4:
 17034 000027BC 59                      		pop	cx		; cx has orginal di
 17035 000027BD 29F9                    		sub	cx,di		; subtract di now, get string length
 17036 000027BF 47                      		inc	di		; point to first digit
 17037 000027C0 FC                      		cld			; must keep direction flag cleared
 17038 000027C1 C3                      		retn
 17039                                  
 17040                                  ;return to user
 17041                                  ;
 17042                                  ;output_return:
 17043                                  ;	pop	di
 17044                                  ;	pop	si			; pop register variables
 17045                                  ;	mov	sp,bp
 17046                                  ;	pop	bp
 17047                                  ;	retn
 17048                                  
 17049                                  ; ----------------------------------------------------------------------------
 17050                                  
 17051                                  ; 07/12/2018 
 17052                                  
 17053                                  ;***
 17054                                  ;chkstk.asm - C stack checking routine
 17055                                  ;
 17056                                  ;	Copyright (c) 1985-1992 Microsoft Corporation, All Rights Reserved
 17057                                  ;
 17058                                  ;Purpose:
 17059                                  ;	Provides support for automatic stack checking in C procedures
 17060                                  ;	when stack checking is enabled.
 17061                                  ;
 17062                                  ;*******************************************************************************
 17063                                  
 17064                                  ;***
 17065                                  ;_chkstk - check stack upon procedure entry
 17066                                  ;
 17067                                  ;Purpose:
 17068                                  ;	Provide stack checking on procedure entry.
 17069                                  ;
 17070                                  ;	[LLIBCDLL.LIB NOTE: Unlike other LLIBCDLL routines, DS != DGROUP
 17071                                  ;	when chkstk() is called.]
 17072                                  ;
 17073                                  ;Entry:
 17074                                  ;	AX = size of local frame
 17075                                  ;
 17076                                  ;Exit:
 17077                                  ;	SP = new stackframe if successful
 17078                                  ;
 17079                                  ;Uses:
 17080                                  ;	AX, BX, CX, DX
 17081                                  ;
 17082                                  ;Exceptions:
 17083                                  ;	Gives out of memory error and aborts if there is not enough
 17084                                  ;	stack space for the routine.
 17085                                  ;
 17086                                  ;*******************************************************************************
 17087                                  
 17088                                  _chkstk:
 17089 000027C2 59                      		pop	cx		; get return offset
 17090 000027C3 89E3                    		mov	bx,sp		; bx = current SP
 17091 000027C5 29C3                    		sub	bx,ax		; bx = new position
 17092 000027C7 720A                    		jc	short OMerr
 17093                                  		;cmp	bx,[_STKHQQ]	; SP - AX : _STKHQQ (for heap/stack)
 17094 000027C9 3B1E[6EA0]              		cmp	bx,[end_of_bss]
 17095 000027CD 7204                    		jb	short OMerr	; error - out of memory
 17096 000027CF 89DC                    		mov	sp,bx
 17097 000027D1 FFE1                    		jmp	cx		; return to cx
 17098                                  OMerr:
 17099                                  		;push	cx
 17100                                  		;xor	ax,ax
 17101                                  		;jmp	_amsg_exit	; give stack overflow and die
 17102                                  		; 14/12/2018
 17103 000027D3 1E                      		push	ds
 17104 000027D4 FF36[D29E]              		push	word [stackerror_msg_off]
 17105 000027D8 E849EE                  		call	display
 17106                                  		;pop	bx
 17107                                  		;pop	bx
 17108 000027DB B0FF                    		mov	al,255
 17109 000027DD E988D8                  		jmp	_exit
 17110                                  
 17111                                  ; ----------------------------------------------------------------------------
 17112                                  ; tdisplay.c (FDISK, MSDOS 6.0, 1991)	
 17113                                  ; ----------------------------------------------------------------------------
 17114                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 07/12/2018)
 17115                                  
 17116                                  ;void get_letters()                                                   /*C32*/
 17117                                  ;BEGIN                                                                /*C32*/
 17118                                  ;                                                                     /*C32*/
 17119                                  ;unsigned char i,j;                                                   /*C32*/
 17120                                  ;unsigned char active_primary_count;                                  /*C32*/
 17121                                  ;unsigned char pri_part;                                              /*C32*/
 17122                                  ;                                                                     /*C32*/
 17123                                  ;    /* initialize next letter */                                     /*C32*/
 17124                                  ;    next_letter = c(SEA);                                            /*C32*/
 17125                                  ;                                                                     /*C32*/
 17126                                  ;    /* get primary DOS partition letters on all drives */            /*C32*/
 17127                                  ;    for (j = uc(0); j < number_of_drives; j++)                       /*C32*/
 17128                                  ;       BEGIN                                                         /*C32*/
 17129                                  ;        /* initialize variables */                                   /*C32*/
 17130                                  ;        primary_partition_count = 0;                                 /*C32*/
 17131                                  ;        active_primary_count = 0;                                    /*C32*/
 17132                                  ;        pri_part = 0xFF;                                             /*C32*/
 17133                                  ;                                                                     /*C32*/
 17134                                  ;        /* Look at all partitions */                                 /*C32*/
 17135                                  ;        for (i=u(0); i < u(4); i++)                                  /*C32*/
 17136                                  ;           BEGIN                                                     /*C32*/
 17137                                  ;            /* Compute e letter */                                   /*C32*/
 17138                                  ;            if ( (part_table[j][i].sys_id == DOS12) ||               /*C32*/
 17139                                  ;                 (part_table[j][i].sys_id == DOS16) ||               /*C32*/
 17140                                  ;                 (part_table[j][i].sys_id == DOSNEW)   )             /*C32*/
 17141                                  ;               BEGIN                                                 /*C32*/
 17142                                  ;                part_table[j][i].drive_letter = c(' ');              /*C32*/
 17143                                  ;                if ((primary_partition_count == 0) ||                /*C32*/
 17144                                  ;                    ((part_table[j][i].boot_ind == 0x80) &&          /*C32*/
 17145                                  ;                     (active_primary_count == 0)))                   /*C32*/
 17146                                  ;                    pri_part = c(i);                                 /*C32*/
 17147                                  ;                if (part_table[j][i].boot_ind == 0x80)               /*C32*/
 17148                                  ;                    active_primary_count++;                          /*C32*/
 17149                                  ;                primary_partition_count++;                           /*C32*/
 17150                                  ;               END                                                   /*C32*/
 17151                                  ;           END                                                       /*C32*/
 17152                                  ;        if ((pri_part != 0xFF) && (next_letter <= c('Z')))           /*C32*/
 17153                                  ;            part_table[j][pri_part].drive_letter = next_letter++;    /*C32*/
 17154                                  ;       END                                                           /*C32*/
 17155                                  ;                                                                     /*C32*/
 17156                                  ;    /* get logical DOS drive letters on all drives */                /*C32*/
 17157                                  ;    for (j = uc(0); j < number_of_drives; j++)                       /*C32*/
 17158                                  ;       BEGIN                                                         /*C32*/
 17159                                  ;       /* Look at all partitions */                                  /*C32*/
 17160                                  ;        for (i=u(0); i < u(23); i++)                                 /*C32*/
 17161                                  ;           BEGIN                                                     /*C32*/
 17162                                  ;            /* Set drive letter */                                   /*C32*/
 17163                                  ;            if ( (ext_table[j][i].sys_id == DOS12) ||                /*C32*/
 17164                                  ;                 (ext_table[j][i].sys_id == DOS16) ||                /*C32*/
 17165                                  ;                 (ext_table[j][i].sys_id == DOSNEW)   )              /*C32*/
 17166                                  ;                if (next_letter <= c('Z'))                           /*C32*/
 17167                                  ;                    ext_table[j][i].drive_letter = next_letter++;    /*C32*/
 17168                                  ;                else                                                 /*C32*/
 17169                                  ;                    ext_table[j][i].drive_letter = c(' ');           /*C32*/
 17170                                  ;           END                                                       /*C32*/
 17171                                  ;       END                                                           /*C32*/
 17172                                  ;                                                                     /*C32*/
 17173                                  ;    /* get enhdisk partition letters on all drives */                /*C32*/
 17174                                  ;    for (j = uc(0); j < number_of_drives; j++)                       /*C32*/
 17175                                  ;       BEGIN                                                         /*C32*/
 17176                                  ;        /* Look at all active primary partitions */                  /*C32*/
 17177                                  ;        for (i=u(0); i < u(4); i++)                                  /*C32*/
 17178                                  ;           BEGIN                                                     /*C32*/
 17179                                  ;            /* Set drive letter */                                   /*C32*/
 17180                                  ;            if (((part_table[j][i].sys_id == DOS12) ||               /*C32*/
 17181                                  ;                 (part_table[j][i].sys_id == DOS16) ||               /*C32*/
 17182                                  ;                 (part_table[j][i].sys_id == DOSNEW)) &&             /*C32*/
 17183                                  ;                (part_table[j][i].boot_ind == 0x80))                 /*C32*/
 17184                                  ;                if ((part_table[j][i].drive_letter == c(' ')) &&     /*C32*/
 17185                                  ;                    (next_letter <= c('Z')))                         /*C32*/
 17186                                  ;                    part_table[j][i].drive_letter = next_letter++;   /*C32*/
 17187                                  ;           END                                                       /*C32*/
 17188                                  ;        /* Look at all non-active primary partitions */              /*C32*/
 17189                                  ;        for (i=u(0); i < u(4); i++)                                  /*C32*/
 17190                                  ;           BEGIN                                                     /*C32*/
 17191                                  ;            /* Set drive letter */                                   /*C32*/
 17192                                  ;            if (((part_table[j][i].sys_id == DOS12) ||               /*C32*/
 17193                                  ;                 (part_table[j][i].sys_id == DOS16) ||               /*C32*/
 17194                                  ;                 (part_table[j][i].sys_id == DOSNEW)) &&             /*C32*/
 17195                                  ;                (part_table[j][i].boot_ind != 0x80))                 /*C32*/
 17196                                  ;                if ((part_table[j][i].drive_letter == c(' ')) &&     /*C32*/
 17197                                  ;                    (next_letter <= c('Z')))                         /*C32*/
 17198                                  ;                    part_table[j][i].drive_letter = next_letter++;   /*C32*/
 17199                                  ;           END                                                       /*C32*/
 17200                                  ;       END                                                           /*C32*/
 17201                                  ;                                                                     /*C32*/
 17202                                  ;    return;                                                          /*C32*/
 17203                                  ;                                                                     /*C32*/
 17204                                  ;END  
 17205                                  
 17206                                  get_letters:
 17207                                  
 17208                                  	%define gdl_j		bp-8
 17209                                  	%define gdl_i		bp-6
 17210                                  	%define a_primary_count	bp-4
 17211                                  	%define p_part		bp-2
 17212                                  
 17213 000027E0 55                      		push	bp
 17214 000027E1 89E5                    		mov	bp,sp
 17215 000027E3 83EC08                  		sub	sp,8
 17216                                  
 17217                                  		;/* initialize next letter */ 
 17218 000027E6 C606[2DA1]43            		mov	byte [next_letter],'C'
 17219                                  
 17220                                  		;/* get primary DOS partition letters on all drives */
 17221                                  		;mov	word [gdl_j],0
 17222 000027EB C646F800                		mov	byte [gdl_j],0
 17223 000027EF B12E                    		mov	cl,46  ; *CL* ; 07/12/2018
 17224 000027F1 E98200                  		jmp	gdl_10
 17225                                  gdl_1:
 17226                                  		;/* Compute a letter */  
 17227 000027F4 8A46F8                  		mov	al,[gdl_j]
 17228                                  		;sub	ah,ah
 17229                                  		;shl	ax,1
 17230                                  		;shl	ax,1
 17231 000027F7 D0E0                    		shl	al,1
 17232 000027F9 D0E0                    		shl	al,1
 17233                                  		;mov	cl,[gdl_i]
 17234                                  		;sub	ch,ch
 17235                                  		;;add	ax,cx
 17236                                  		;add	al,cl
 17237                                  		;mov	cx,46
 17238                                  		;imul	cx
 17239 000027FB 0246FA                  		add	al,[gdl_i]
 17240                                  		;mov	cl,46  ; *CL*
 17241 000027FE F6E1                    		mul	cl
 17242 00002800 89C3                    		mov	bx,ax
 17243                                  
 17244 00002802 80BF[25C4]01            		cmp	byte [part_table_sys_id+bx],1 ; DOS12  ; FAT12	
 17245 00002807 740E                    		je	short gdl_2
 17246 00002809 80BF[25C4]04            		cmp	byte [part_table_sys_id+bx],4 ; DOS16  ; FAT16
 17247 0000280E 7407                    		je	short gdl_2
 17248 00002810 80BF[25C4]06            		cmp	byte [part_table_sys_id+bx],6 ; DOSNEW ; FAT16 big
 17249 00002815 752D                    		jne	short gdl_6
 17250                                  gdl_2:
 17251                                  		;mov	al,[gdl_j]
 17252                                  		;sub	ah,ah
 17253                                  		;shl	ax,1
 17254                                  		;shl	ax,1
 17255                                  		;mov	cl,[gdl_i]
 17256                                  		;sub	ch,ch
 17257                                  		;add	ax,cx
 17258                                  		;mov	cx,46
 17259                                  		;imul	cx
 17260                                  		;mov	bx,ax
 17261                                  
 17262                                  		;part_table[j][i].drive_letter = c(' '); 
 17263 00002817 C687[4DC4]20            		mov	byte [part_table_drive_letter+bx],' '
 17264                                  
 17265                                  		; Only one primary dos partition per disk !
 17266                                  
 17267                                  		;if ((primary_partition_count == 0) ||
 17268                                                  ;   ((part_table[j][i].boot_ind == 0x80) &&
 17269                                                  ;   (active_primary_count == 0)))
 17270                                                  ;   pri_part = c(i);                 
 17271                                  
 17272 0000281C 803E[DCC3]00            		cmp	byte [primary_partition_count],0
 17273 00002821 760D                    		jna	short gdl_3
 17274 00002823 80BF[20C4]80            		cmp	byte [part_table_boot_ind+bx],80h
 17275 00002828 750C                    		jne	short gdl_4
 17276 0000282A 807EFC00                		cmp	byte [a_primary_count],0 ;active_primary_count
 17277 0000282E 7706                    		ja	short gdl_4
 17278                                  gdl_3:
 17279                                  		; Only one primary dos partition per disk !
 17280 00002830 8A46FA                  		mov	al,[gdl_i]
 17281 00002833 8846FE                  		mov	[p_part],al	; primary_part
 17282                                  gdl_4:
 17283                                  		;mov	al,[gdl_j]
 17284                                  		;sub	ah,ah
 17285                                  		;shl	ax,1
 17286                                  		;shl	ax,1
 17287                                  		;mov	cl,[gdl_i]
 17288                                  		;sub	ch,ch
 17289                                  		;add	ax,cx
 17290                                  		;mov	cx,46
 17291                                  		;imul	cx
 17292                                  		;mov	bx,ax
 17293                                  
 17294                                  		;if (part_table[j][i].boot_ind == 0x80)
 17295                                                  ;    active_primary_count++;
 17296                                                  ;primary_partition_count++;            
 17297                                  
 17298 00002836 80BF[20C4]80            		cmp	byte [part_table_boot_ind+bx],80h
 17299 0000283B 7503                    		jne	short gdl_5
 17300 0000283D FE46FC                  		inc	byte [a_primary_count]
 17301                                  gdl_5:
 17302 00002840 FE06[DCC3]              		inc	byte [primary_partition_count]
 17303                                  gdl_6:
 17304 00002844 FE46FA                  		inc	byte [gdl_i]
 17305                                  gdl_7:
 17306                                  		;/* Look at all partitions */
 17307                                  		;for (i=u(0); i < u(4); i++)
 17308                                  
 17309                                  		; if i < 4 -- NEXT -- 
 17310 00002847 807EFA04                		cmp	byte [gdl_i],4
 17311                                  		;jnb	short gdl_8
 17312                                  		;jmp	gdl_1
 17313 0000284B 72A7                    		jb	short gdl_1 ; next
 17314                                  gdl_8:
 17315                                  		;if ((pri_part != 0xFF) && (next_letter <= c('Z')))
 17316                                  		;   part_table[j][pri_part].drive_letter = next_letter++;
 17317                                  
 17318 0000284D 807EFEFF                		cmp	byte [p_part],0FFh
 17319 00002851 7420                    		je	short gdl_9
 17320 00002853 803E[2DA1]5A            		cmp	byte [next_letter],'Z'
 17321 00002858 7F19                    		jg	short gdl_9
 17322                                  
 17323 0000285A 8A46F8                  		mov	al,[gdl_j]
 17324                                  		;sub	ah,ah
 17325                                  		;shl	ax,1
 17326                                  		;shl	ax,1
 17327 0000285D D0E0                    		shl	al,1
 17328 0000285F D0E0                    		shl	al,1
 17329                                  		;mov	cl,[p_part]
 17330                                  		;sub	ch,ch
 17331                                  		;add	ax,cx
 17332                                  		;add	al,cl
 17333                                  		;;mov	cx,46
 17334                                  		;mov	cl,46
 17335                                  		;imul	cx
 17336                                  		;mul	cl
 17337 00002861 0246FE                  		add	al,[p_part]
 17338 00002864 F6E1                    		mul	cl ; CL = 46 ; *CL*
 17339 00002866 89C3                    		mov	bx,ax
 17340 00002868 A0[2DA1]                		mov	al,[next_letter]
 17341 0000286B 8887[4DC4]              		mov	[part_table_drive_letter+bx],al
 17342 0000286F FE06[2DA1]              		inc	byte [next_letter]
 17343                                  gdl_9:
 17344 00002873 FE46F8                  		inc	byte [gdl_j]
 17345                                  gdl_10:
 17346                                  		;/* get primary DOS partition letters on all drives */
 17347                                  		;for (j = uc(0); j < number_of_drives; j++) 
 17348 00002876 A0[E3C3]                		mov	al,[number_of_drives]
 17349 00002879 3846F8                  		cmp	[gdl_j],al
 17350 0000287C 7313                    		jnb	short gdl_11
 17351                                  
 17352                                  		;/* initialize variables */
 17353                                  		;primary_partition_count = 0;
 17354                                  		;active_primary_count = 0;
 17355                                  		;pri_part = 0xFF;     
 17356 0000287E C606[DCC3]00            		mov	byte [primary_partition_count],0
 17357 00002883 C646FEFF                		mov	byte [p_part],0FFh
 17358 00002887 28C0                    		sub	al,al ; 0
 17359 00002889 8846FC                  		mov	[a_primary_count],al
 17360                                  
 17361                                  		;/* Look at all partitions */  ; For next disk/drive
 17362 0000288C 8846FA                  		mov	[gdl_i],al ; 0
 17363 0000288F EBB6                    		jmp	short gdl_7
 17364                                  gdl_11:		
 17365                                  		;/* get logical DOS drive letters on all drives */
 17366 00002891 C646F800                		mov	byte [gdl_j],0
 17367 00002895 EB46                    		jmp	short gdl_17
 17368                                  gdl_12:
 17369                                  		;mov	al,24
 17370                                  		;mul	byte [gdl_j]
 17371                                  		;mov	cl,[gdl_i]
 17372                                  		;sub	ch,ch
 17373                                  		;add	ax,cx
 17374                                  		;mov	cx,46
 17375                                  		;imul	cx
 17376                                  		;mul	cl
 17377                                  		;mov	bx,ax
 17378                                  
 17379                                  		;ext_table[j][i].drive_letter = c(' ');  
 17380 00002897 C687[85A1]20            		mov	byte [ext_table_drive_letter+bx],' '
 17381                                  gdl_13:	
 17382 0000289C FE46FA                  		inc	byte [gdl_i]
 17383                                  gdl_14:
 17384                                  		;/* Look at all partitions */
 17385                                          	;for (i=u(0); i < u(23); i++) 
 17386                                  
 17387                                  		; if i < 23 ;  -- NEXT --
 17388 0000289F 807EFA17                		cmp	byte [gdl_i],23
 17389 000028A3 7335                    		jnb	short gdl_16
 17390                                  
 17391 000028A5 B018                    		mov	al,24
 17392 000028A7 F666F8                  		mul	byte [gdl_j]
 17393                                  			; ax < 192
 17394                                  		;mov	cl,[gdl_i]
 17395                                  		;sub	ch,ch
 17396                                  		;add	ax,cx
 17397 000028AA 0246FA                  		add	al,[gdl_i]
 17398                                  		;mov	cx,46
 17399                                  		;imul	cx
 17400 000028AD F6E1                    		mul	cl ; CL = 46 ; *CL*
 17401 000028AF 89C3                    		mov	bx,ax
 17402                                  
 17403                                  		;/* Set drive letter */ 
 17404                                  
 17405 000028B1 80BF[5DA1]01            		cmp	byte [ext_table_sys_id+bx],1 ; DOS12
 17406 000028B6 740E                    		je	short gdl_15
 17407 000028B8 80BF[5DA1]04            		cmp	byte [ext_table_sys_id+bx],4 ; DOS16
 17408 000028BD 7407                    		je	short gdl_15
 17409 000028BF 80BF[5DA1]06            		cmp	byte [ext_table_sys_id+bx],6 ; DOSNEW ; FAT16 big
 17410 000028C4 75D6                    		jne	short gdl_13
 17411                                  gdl_15:
 17412                                  		;if (next_letter <= c('Z'))
 17413                                                  ;   ext_table[j][i].drive_letter = next_letter++;
 17414                                                  ;else
 17415                                                  ;   ext_table[j][i].drive_letter = c(' ');    
 17416                                  
 17417 000028C6 803E[2DA1]5A            		cmp	byte [next_letter],'Z'
 17418 000028CB 7FCA                    		jg	short gdl_12
 17419                                  
 17420                                  		;mov	al,24
 17421                                  		;mul	[gdl_j]
 17422                                  		;mov	cl,[gdl_i]
 17423                                  		;sub	ch,ch
 17424                                  		;add	ax,cx
 17425                                  		;mov	cx,46
 17426                                  		;imul	cx
 17427                                  		;mov	bx,ax
 17428                                  
 17429 000028CD A0[2DA1]                		mov	al,[next_letter]
 17430 000028D0 8887[85A1]              		mov	[ext_table_drive_letter+bx],al
 17431 000028D4 FE06[2DA1]              		inc	byte [next_letter]
 17432 000028D8 EBC2                    		jmp	short gdl_13
 17433                                  gdl_16:
 17434 000028DA FE46F8                  		inc	byte [gdl_j]
 17435                                  gdl_17:
 17436                                  		;/* get logical DOS drive letters on all drives */
 17437                                      		;for (j = uc(0); j < number_of_drives; j++)    
 17438                                  		
 17439 000028DD A0[E3C3]                		mov	al,[number_of_drives]
 17440 000028E0 3846F8                  		cmp	[gdl_j],al
 17441 000028E3 7306                    		jnb	short gdl_18
 17442                                  		
 17443                                  		;/* Look at all partitions */
 17444 000028E5 C646FA00                		mov	byte [gdl_i],0
 17445 000028E9 EBB4                    		jmp	short gdl_14
 17446                                  gdl_18:
 17447                                  		;/* get enhdisk partition letters on all drives */   	
 17448 000028EB C646F800                		mov	byte [gdl_j],0
 17449 000028EF EB51                    		jmp	short gdl_23
 17450                                  gdl_19:
 17451 000028F1 FE46FA                  		inc	byte [gdl_i]  ; next partition
 17452                                  gdl_20:
 17453                                  		;/* Look at all non-active primary partitions */
 17454                                          	;for (i=u(0); i < u(4); i++)    
 17455                                  
 17456 000028F4 807EFA04                		cmp	byte [gdl_i],4
 17457 000028F8 7345                    		jnb	short gdl_22
 17458                                  
 17459 000028FA 8A46F8                  		mov	al,[gdl_j]
 17460                                  		;sub	ah,ah
 17461                                  		;shl	ax,1
 17462                                  		;shl	ax,1
 17463 000028FD D0E0                    		shl	al,1
 17464 000028FF D0E0                    		shl	al,1
 17465                                  		;mov	cl,[gdl_i]
 17466                                  		;sub	ch,ch
 17467                                  		;add	ax,cx
 17468 00002901 0246FA                  		add	al,[gdl_i]
 17469                                  		;mov	cx,46
 17470                                  		;imul	cx
 17471                                  		;mov	bx,ax
 17472 00002904 F6E1                    		mul	cl ; CL = 46 ; *CL*
 17473 00002906 89C3                    		mov	bx,ax
 17474                                  
 17475                                  		;/* Set drive letter */
 17476                                  		;if (((part_table[j][i].sys_id == DOS12) ||
 17477                                                  ;   (part_table[j][i].sys_id == DOS16) ||
 17478                                                  ;   (part_table[j][i].sys_id == DOSNEW)) &&
 17479                                                  ;   (part_table[j][i].boot_ind != 0x80))       
 17480                                  
 17481 00002908 80BF[25C4]01            		cmp	byte [part_table_sys_id+bx],1 ; DOS12	
 17482 0000290D 740E                    		je	short gdl_21
 17483 0000290F 80BF[25C4]04            		cmp	byte [part_table_sys_id+bx],4 ; DOS16
 17484 00002914 7407                    		je	short gdl_21
 17485 00002916 80BF[25C4]06            		cmp	byte [part_table_sys_id+bx],6 ; DOSNEW ; FAT16 big
 17486 0000291B 75D4                    		jne	short gdl_19
 17487                                  gdl_21:
 17488                                  		;mov	al,[gdl_j]
 17489                                  		;sub	ah,ah
 17490                                  		;shl	ax,1
 17491                                  		;shl	ax,1
 17492                                  		;mov	cl,[gdl_i]
 17493                                  		;sub	ch,ch
 17494                                  		;add	ax,cx
 17495                                  		;mov	cx,46
 17496                                  		;imul	cx
 17497                                  		;mov	bx,ax
 17498                                  
 17499                                  		;if ((part_table[j][i].drive_letter == c(' ')) &&
 17500                                                  ;   (next_letter <= c('Z')))
 17501                                                  ;   part_table[j][i].drive_letter = next_letter++;
 17502                                  
 17503 0000291D 80BF[20C4]80            		cmp	byte [part_table_boot_ind+bx],80h
 17504 00002922 74CD                    		je	short gdl_19
 17505                                  
 17506 00002924 80BF[4DC4]20            		cmp	byte [part_table_drive_letter+bx],' '
 17507 00002929 75C6                    		jne	short gdl_19
 17508 0000292B 803E[2DA1]5A            		cmp	byte [next_letter],'Z'
 17509 00002930 7FBF                    		jg	short gdl_19
 17510                                  
 17511 00002932 A0[2DA1]                		mov	al,[next_letter]
 17512 00002935 8887[4DC4]              		mov	[part_table_drive_letter+bx],al
 17513 00002939 FE06[2DA1]              		inc	byte [next_letter]
 17514 0000293D EBB2                    		jmp	short gdl_19
 17515                                  gdl_22:
 17516 0000293F FE46F8                  		inc	byte [gdl_j]
 17517                                  gdl_23:
 17518                                  		;/* get enhdisk partition letters on all drives */   
 17519                                  		;for (j = uc(0); j < number_of_drives; j++)
 17520                                  
 17521 00002942 A0[E3C3]                		mov	al,[number_of_drives]
 17522 00002945 3846F8                  		cmp	[gdl_j],al
 17523 00002948 7357                    		jnb	short gdl_27
 17524                                  
 17525                                  		;/* Look at all active primary partitions */
 17526                                        		;for (i=u(0); i < u(4); i++)     
 17527 0000294A C646FA00                		mov	byte [gdl_i],0
 17528                                  gdl_24:
 17529 0000294E 8A46F8                  		mov	al,[gdl_j]
 17530                                  		;sub	ah,ah
 17531                                  		;shl	ax,1
 17532                                  		;shl	ax,1
 17533 00002951 D0E0                    		shl	al,1
 17534 00002953 D0E0                    		shl	al,1
 17535                                  		;mov	cl,[gdl_i]
 17536                                  		;sub	ch,ch
 17537                                  		;add	ax,cx
 17538 00002955 0246FA                  		add	al,[gdl_i]
 17539                                  		;mov	cx,46
 17540                                  		;imul	cx
 17541 00002958 F6E1                    		mul	cl ; CL = 46 ; *CL*
 17542 0000295A 89C3                    		mov	bx,ax
 17543                                  
 17544                                  		;/* Set drive letter */
 17545                                              
 17546                                  		;if (((part_table[j][i].sys_id == DOS12) ||
 17547                                                  ;   (part_table[j][i].sys_id == DOS16) ||
 17548                                                  ;   (part_table[j][i].sys_id == DOSNEW)) && 
 17549                                                  ; (part_table[j][i].boot_ind == 0x80))    
 17550                                  
 17551 0000295C 80BF[25C4]01            		cmp	byte [part_table_sys_id+bx],1 ; DOS12  ; FAT12	
 17552 00002961 740E                    		je	short gdl_25
 17553 00002963 80BF[25C4]04            		cmp	byte [part_table_sys_id+bx],4 ; DOS16  ; FAT16
 17554 00002968 7407                    		je	short gdl_25
 17555 0000296A 80BF[25C4]06            		cmp	byte [part_table_sys_id+bx],6 ; DOSNEW ; FAT16 big
 17556 0000296F 7520                    		jne	short gdl_26
 17557                                  gdl_25:
 17558                                  		;mov	al,[gdl_j]
 17559                                  		;sub	ah,ah
 17560                                  		;shl	ax,1
 17561                                  		;shl	ax,1
 17562                                  		;mov	cl,[gdl_i]
 17563                                  		;sub	ch,ch
 17564                                  		;add	ax,cx
 17565                                  		;mov	cx,46
 17566                                  		;imul	cx
 17567                                  		;mov	bx,ax
 17568                                  
 17569 00002971 80BF[20C4]80            		cmp	byte [part_table_boot_ind+bx],80h
 17570 00002976 7519                    		jne	short gdl_26
 17571                                  
 17572                                  		;if ((part_table[j][i].drive_letter == c(' ')) &&
 17573                                                  ;    (next_letter <= c('Z')))
 17574                                                  ;    part_table[j][i].drive_letter = next_letter++; 
 17575                                  
 17576 00002978 80BF[4DC4]20            		cmp	byte [part_table_drive_letter+bx],' '
 17577 0000297D 7512                    		jne	short gdl_26
 17578 0000297F 803E[2DA1]5A            		cmp	byte [next_letter],'Z'
 17579 00002984 7F0B                    		jg	short gdl_26
 17580 00002986 A0[2DA1]                		mov	al,[next_letter]
 17581 00002989 8887[4DC4]              		mov	[part_table_drive_letter+bx],al
 17582 0000298D FE06[2DA1]              		inc	byte [next_letter]
 17583                                  gdl_26:
 17584 00002991 FE46FA                  		inc	byte [gdl_i]
 17585 00002994 807EFA04                		cmp	byte [gdl_i],4
 17586 00002998 72B4                    		jb	short gdl_24 ; next disk/drive
 17587                                  
 17588                                  		;/* Look at all non-active primary partitions */ 
 17589 0000299A C646FA00                		mov	byte [gdl_i],0
 17590 0000299E E953FF                  		jmp	gdl_20
 17591                                  gdl_27:
 17592 000029A1 89EC                    		mov	sp,bp
 17593 000029A3 5D                      		pop	bp
 17594 000029A4 C3                      		retn
 17595                                  
 17596                                  ; ----------------------------------------------------------------------------
 17597                                  ; space.c (FDISK, MSDOS 6.0, 1991)	
 17598                                  ; ----------------------------------------------------------------------------
 17599                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 07/12/2018)
 17600                                  
 17601                                  ;void sort_part_table(size)
 17602                                  ;
 17603                                  ;char size;
 17604                                  ;
 17605                                  ;BEGIN
 17606                                  ;
 17607                                  ;char  changed;
 17608                                  ;char  temp;
 17609                                  ;char   i;
 17610                                  ;
 17611                                  ;       /* Init the sorting parameters */
 17612                                  ;       for (i=c(0); i < size; i++)                               /* AC000 */
 17613                                  ;          BEGIN
 17614                                  ;           sort[i] = i;
 17615                                  ;          END
 17616                                  ;
 17617                                  ;       /* Do a bubble sort */
 17618                                  ;       changed = TRUE;
 17619                                  ;
 17620                                  ;       /* Sort until we don't do a swap */
 17621                                  ;       while (changed)
 17622                                  ;
 17623                                  ;          BEGIN
 17624                                  ;           changed = FALSE;
 17625                                  ;           for (i=c(1); i < size; i++)                           /* AC000 */
 17626                                  ;              BEGIN
 17627                                  ;
 17628                                  ;               /* Does the partition entry start before the previous one, or */
 17629                                  ;               /* is it empty (0 ENTRY). If empty, it automatically gets shoved */
 17630                                  ;               /* to the front, if the previous entry isn't also empty */
 17631                                  ;
 17632                                  ;               if ((part_table[cur_disk][sort[i]].end_cyl < part_table[cur_disk][sort[i-1]].end_cyl)
 17633                                  ;                  || ((part_table[cur_disk][sort[i]].num_sec == ul(0))
 17634                                  ;                  &&  (part_table[cur_disk][sort[i-1]].num_sec != ul(0))))  /* AC000 */
 17635                                  ;
 17636                                  ;                  BEGIN
 17637                                  ;                   /* Swap the order indicators */
 17638                                  ;                   temp = sort[i-1];
 17639                                  ;                   sort[i-1] = sort[i];
 17640                                  ;                   sort[i] = temp;
 17641                                  ;
 17642                                  ;                /* printf("\nI-1 =%d\n",part_table[cur_disk][sort[i-1]].start_cyl);*/
 17643                                  ;                /* printf("I =%d\n",part_table[cur_disk][sort[i]].start_cyl);*/
 17644                                  ;                /* printf("Sort[i-1] = %d\n",sort[i-1]);*/
 17645                                  ;                /* printf("Sort[i] = %d\n",sort[i]); */
 17646                                  ;                /* wait_for_ESC(); */
 17647                                  ;
 17648                                  ;                   /* indicate we did a swap */
 17649                                  ;                   changed = TRUE;
 17650                                  ;                  END
 17651                                  ;              END
 17652                                  ;          END
 17653                                  ;       return;
 17654                                  ;END
 17655                                  
 17656                                  sort_part_table:
 17657                                  				     ; 12/12/2018	
 17658                                  	;%define sort_changed	bp-6    ; ch
 17659                                  	;%define sort_i		bp-4    ; bx
 17660                                  	;%define sort_temp	bp-2    ; ah
 17661                                  	;%define sort_count	bp+4    ; cl
 17662                                  
 17663                                  		; 12/12/2018
 17664                                  		;push	bp
 17665                                  		;mov	bp,sp
 17666                                  		;sub	sp,6
 17667                                  		
 17668                                  		;push	di
 17669                                  		;push	si
 17670                                  
 17671                                  		; CL = sort count ; 12/12/2018
 17672                                  
 17673                                  		;/* Init the sorting parameters */
 17674                                  		;for (i=c(0); i < size; i++)     
 17675                                  		
 17676                                  		;mov	word [sort_i],0
 17677 000029A5 31DB                    		xor	bx,bx ; 0 ; 12/12/2018
 17678 000029A7 EB06                    		jmp	short sortpt_2
 17679                                  sortpt_1:
 17680                                  		;mov	al,[sort_i]
 17681                                  		;cbw
 17682                                  		
 17683                                  		;mov	ax,[sort_i] ; 12/12/2018
 17684                                  		;mov	bx,ax
 17685                                  		
 17686                                  		;mov	[bx+sort],al
 17687 000029A9 889F[F0C3]              		mov	[bx+sort],bl ; 12/12/2018		
 17688                                  
 17689                                  		;inc	byte [sort_i]
 17690 000029AD FEC3                    		inc	bl ; 12/12/2018
 17691                                  sortpt_2:
 17692                                  		;mov	al,[sort_count] ; size
 17693                                  		;cmp	[sort_i],al	; i < size
 17694                                  		;jl	short sortpt_1
 17695                                  		
 17696                                  		; 12/12/2018
 17697                                  		; CL = sort count
 17698 000029AF 38CB                    		cmp	bl,cl
 17699 000029B1 7CF6                    		jl	short sortpt_1
 17700                                  
 17701                                  		;/* Do a bubble sort */
 17702                                  		;changed = TRUE;
 17703                                  
 17704                                  		;mov	byte [sort_changed],1
 17705 000029B3 EB04                    		jmp	short sortpt_4 ; 07/12/2018
 17706                                  sortpt_3:
 17707                                  		;/* Sort until we don't do a swap */
 17708                                          	;while (changed)
 17709                                  
 17710                                  		;cmp	byte [sort_changed],0
 17711                                  		;;jne	short sortpt_4
 17712                                  		;;jmp	sortpt_8
 17713                                  		;jna	short sortpt_8 ; 07/12/2018
 17714                                  		; 12/12/2018
 17715 000029B5 08ED                    		or	ch,ch ; sort changed ?
 17716 000029B7 7455                    		jz	short sortpt_8 ; no.
 17717                                  sortpt_4:
 17718                                  		;changed = FALSE;
 17719                                              	;for (i=c(1); i < size; i++) 
 17720                                  
 17721                                  		;mov	byte [sort_changed],0
 17722 000029B9 30ED                    		xor	ch,ch	; 12/12/2018
 17723                                  		
 17724                                  		;mov	byte [sort_i],1
 17725 000029BB B301                    		mov	bl,1 ; 12/12/2018
 17726                                  
 17727 000029BD B22E                    		mov	dl,46 ; *DL*  ; 07/12/2018
 17728 000029BF EB02                    		jmp	short sortpt_6
 17729                                  sortpt_5:
 17730                                  		;inc	byte [sort_i]
 17731 000029C1 FEC3                    		inc	bl ; 12/12/2018
 17732                                  sortpt_6:
 17733                                  		;mov	al,[sort_count] ; size
 17734                                  		;cmp	[sort_i],al	; i < size
 17735                                  		;jge	short sortpt_3
 17736                                  
 17737                                  		; 12/12/2018
 17738                                  		; CL = sort count
 17739 000029C3 38CB                    		cmp	bl,cl
 17740 000029C5 7DEE                    		jge	short sortpt_3
 17741                                  
 17742                                  		;mov	al,[cur_disk]
 17743                                  		;cbw
 17744                                  		;shl	ax,1
 17745                                  		;shl	ax,1
 17746                                  		;mov	cx,ax
 17747                                  
 17748                                  		;mov	cl,[cur_disk] ; 07/12/2018
 17749                                  		;shl	cl,1
 17750                                  		;shl	cl,1	; 4 partitions per disk
 17751                                  
 17752                                  		; 12/12/2018
 17753 000029C7 8A36[E2CB]              		mov	dh,[cur_disk]
 17754 000029CB D0E6                    		shl	dh,1
 17755 000029CD D0E6                    		shl	dh,1
 17756                                  		
 17757                                  		;mov	al,[sort_i]
 17758                                  		;cbw
 17759                                  		;mov	bx,ax
 17760                                  
 17761                                  		;mov	bx,[sort_i] ; 12/12/2018
 17762                                  
 17763                                  		;mov	al,[bx+sort]
 17764                                  		;cbw
 17765                                  		;add	ax,cx
 17766                                  
 17767 000029CF 8A87[F0C3]              		mov	al,[bx+sort] ; 07/12/2018
 17768                                  		;add	al,cl ; skip partitions of previous drive (other drives)
 17769 000029D3 00F0                    		add	al,dh ; 12/12/2018
 17770                                  
 17771                                  		;mov	si,46
 17772                                  		;imul	si
 17773                                  		;mov	dl,46 ; *DL*
 17774 000029D5 F6E2                    		mul	dl
 17775                                  
 17776                                  		;mov	di,ax
 17777                                  		;mov	ax,[part_table_end_cyl+di]
 17778                                  		;mov	dx,ax
 17779 000029D7 89C6                    		mov	si,ax
 17780                                  
 17781                                  		;mov	ax,[part_table_end_cyl+si]
 17782                                  		;mov	di,ax
 17783 000029D9 8BBC[28C4]              		mov	di,[part_table_end_cyl+si] ; **DI** ; 07/12/2018
 17784                                  
 17785 000029DD 8A87[EFC3]              		mov	al,[bx+sort-1]
 17786                                  
 17787                                  		;cbw
 17788                                  		;add	ax,cx
 17789                                  		;add	al,cl
 17790                                  		;mov	cx,dx
 17791                                  		;imul	si
 17792                                  
 17793                                  		; DH = [cur_disk]
 17794 000029E1 00F0                    		add	al,dh ; 12/12/2018
 17795 000029E3 F6E2                    		mul	dl ; *DL* ; = 46
 17796                                  		;mov	bx,ax
 17797                                  
 17798 000029E5 97                      		xchg	di,ax ; **DI** 12/12/2018
 17799                                  
 17800                                  	;/* Does the partition entry start before the previous one, or */
 17801                                  	;/* is it empty (0 ENTRY). If empty, it automatically gets shoved */
 17802                                  	;/* to the front, if the previous entry isn't also empty */
 17803                                  	;
 17804                                  	;if ((part_table[cur_disk][sort[i]].end_cyl < part_table[cur_disk][sort[i-1]].end_cyl)
 17805                                  	;   || ((part_table[cur_disk][sort[i]].num_sec == ul(0))
 17806                                  	;   &&  (part_table[cur_disk][sort[i-1]].num_sec != ul(0))))
 17807                                  
 17808                                  		;cmp	[part_table_end_cyl+bx],cx
 17809                                  		;cmp	[part_table_end_cyl+bx],di ; **XCHG**
 17810 000029E6 3985[28C4]              		cmp	[part_table_end_cyl+di],ax ; **XCHG** ; 12/12/2018
 17811 000029EA 7714                    		ja	short sortpt_7 ; pt[cur_disk][sort[i]].end_cyl < pt[cur_disk][sort[i-1]].end_cyl
 17812                                  
 17813                                  		;mov	ax,[part_table_num_sec_hw+di]
 17814 000029EC 8B84[30C4]              		mov	ax,[part_table_num_sec_hw+si] ; part_table[cur_disk][sort[i]].num_sec
 17815                                  		;or	ax,[part_table_num_sec_lw+di]
 17816 000029F0 0B84[2EC4]              		or	ax,[part_table_num_sec_lw+si]
 17817 000029F4 75CB                    		jnz	short sortpt_5
 17818                                  		;mov	ax,[part_table_num_sec_hw+bx] ; part_table[cur_disk][sort[i-1]].num_sec
 17819 000029F6 8B85[30C4]              		mov	ax,[part_table_num_sec_hw+di] ; **XCHG** ; 12/12/2018
 17820                                  		;or	ax,[part_table_num_sec_lw+bx]
 17821 000029FA 0B85[2EC4]              		or	ax,[part_table_num_sec_lw+di] ; **XCHG** ; 12/12/2018
 17822 000029FE 74C1                    		jz	short sortpt_5
 17823                                  sortpt_7:
 17824                                  		;/* Swap the order indicators */
 17825                                                  ;temp = sort[i-1];
 17826                                                  ;sort[i-1] = sort[i];
 17827                                                  ;sort[i] = temp;
 17828                                  
 17829                                  		;mov	al,[sort_i]
 17830                                  		;cbw
 17831                                  		;mov	bx,ax
 17832                                  		
 17833                                  		; 12/12/2018
 17834                                  		;mov	bx,[sort_i] ; 07/12/2018
 17835                                  
 17836                                  		;mov	al,[bx+sort-1]
 17837                                  		;mov	[sort_temp],al
 17838                                  		;mov	al,[bx+sort]
 17839                                  		;mov	[bx+sort-1],al
 17840                                  		;mov	al,[sort_temp]
 17841                                  		;mov	[bx+sort],al
 17842                                  
 17843                                  		; 12/12/2018
 17844 00002A00 8B87[EFC3]              		mov	ax,[bx+sort-1] ; 12/12/2018
 17845 00002A04 86E0                    		xchg	ah,al
 17846 00002A06 8987[EFC3]              		mov	[bx+sort-1],ax
 17847                                  
 17848                                  		;mov	byte [sort_changed],1
 17849 00002A0A B501                    		mov	ch,1 ; 12/12/2018
 17850 00002A0C EBB3                    		jmp	short sortpt_5
 17851                                  sortpt_8:
 17852                                  		;pop	si
 17853                                  		;pop	di
 17854                                  		
 17855                                  		;mov	sp,bp ; 12/12/2018
 17856                                  		;pop	bp
 17857                                  		
 17858 00002A0E C3                      		retn
 17859                                  
 17860                                  
 17861                                  ; 08/12/2018
 17862                                  
 17863                                  ;void sort_ext_table(size)
 17864                                  ;
 17865                                  ;char size;
 17866                                  ;
 17867                                  ;BEGIN
 17868                                  ;
 17869                                  ;char  changed;
 17870                                  ;char  temp;
 17871                                  ;char i;
 17872                                  ;
 17873                                  ;       /* Init the sorting parameters */
 17874                                  ;
 17875                                  ;       for (i=c(0); i < size; i++)			/* AC000 */
 17876                                  ;          BEGIN
 17877                                  ;           sort[i] = i;
 17878                                  ;          END
 17879                                  ;
 17880                                  ;       /* Do a bubble sort */
 17881                                  ;       changed = TRUE;
 17882                                  ;
 17883                                  ;       /* Sort until we don't do a swap */
 17884                                  ;       while (changed)
 17885                                  ;
 17886                                  ;          BEGIN
 17887                                  ;           changed = FALSE;
 17888                                  ;           for (i=c(1); i < size; i++)			/* AC000 */
 17889                                  ;              BEGIN
 17890                                  ;
 17891                                  ;               if (ext_table[cur_disk][sort[i]].start_cyl < ext_table[cur_disk][sort[i-1]].start_cyl)
 17892                                  ;                  BEGIN
 17893                                  ;
 17894                                  ;                   temp = sort[i-1];
 17895                                  ;                   sort[i-1] = sort[i];
 17896                                  ;                   sort[i] = temp;
 17897                                  ;                   /* indicate we did a swap */
 17898                                  ;                   changed = TRUE;
 17899                                  ;                  END
 17900                                  ;              END
 17901                                  ;          END
 17902                                  ;       return;
 17903                                  ;END
 17904                                  
 17905                                  sort_ext_table:	
 17906                                  
 17907                                  	;;%define swptemp2      bp-10
 17908                                  	;;%define swptemp1      bp-8
 17909                                  
 17910                                  	;%define sortex_changed bp-6  ; ch
 17911                                  	;%define sortex_i       bp-4  ; bx
 17912                                  	;%define sortex_temp    bp-2  ; ah
 17913                                  
 17914                                  	;%define sortex_count   bp+4  ; cl
 17915                                  
 17916                                  		; 12/12/2018
 17917                                  		;push	bp
 17918                                  		;mov	bp,sp
 17919                                  		;;sub	sp,10
 17920                                  		;sub	sp,6 ; 08/12/2018
 17921                                  		
 17922                                  		;push	di
 17923                                  		;push	si
 17924                                  
 17925                                  		; CL = sort count ; 12/12/2018
 17926                                  
 17927                                  		;/* Init the sorting parameters */
 17928                                  		;for (i=c(0); i < size; i++)
 17929                                  	
 17930                                  		;mov	word [sortex_i],0
 17931 00002A0F 31DB                    		xor	bx,bx ; 0 ; 12/12/2018
 17932 00002A11 EB06                    		jmp	short sortept_2
 17933                                  sortept_1:
 17934                                  		;;mov	al,[sortex_i]
 17935                                  		;;cbw
 17936                                  		; 12/12/2018
 17937                                  		;mov	ax,[sortex_i]
 17938                                  		;mov	bx,ax
 17939                                  		;mov	[bx+sort],al
 17940                                  		
 17941                                  		;mov	bx,[sortex_i]
 17942 00002A13 889F[F0C3]              		mov	[bx+sort],bl ; 12/12/2018
 17943                                  
 17944                                  		;inc	byte [sortex_i]
 17945 00002A17 FEC3                    		inc	bl ; 12/12/2018
 17946                                  sortept_2:
 17947                                  		;mov	al,[sortex_count] ; size
 17948                                  		;cmp	[sortex_i],al ; if i < size
 17949                                  		;jl	short sortept_1 ; then ..
 17950                                  
 17951                                  		; 12/12/2018
 17952                                  		; CL = sort count
 17953 00002A19 38CB                    		cmp	bl,cl
 17954 00002A1B 72F6                    		jb	short sortept_1 ; 04/01/2019 
 17955                                  
 17956                                  		;/* Do a bubble sort */
 17957                                  		;changed = TRUE;
 17958                                  
 17959                                  		;mov	byte [sortex_changed],1
 17960 00002A1D EB04                    		jmp	short sortept_4
 17961                                  sortept_3:
 17962                                  		;/* Sort until we don't do a swap */
 17963                                  		;while (changed)
 17964                                  
 17965                                  		;cmp	byte [sortex_changed],0
 17966                                  		;je	short sortept_7
 17967                                  		
 17968                                  		; 12/12/2018
 17969 00002A1F 08ED                    		or	ch,ch ; sort changed ?
 17970 00002A21 7442                    		jz	short sortept_7 ; no.
 17971                                  sortept_4:
 17972                                  		;changed = FALSE;
 17973                                  		;for (i=c(1); i < size; i++)	
 17974                                  
 17975                                  		;mov	byte [sortex_changed],0
 17976 00002A23 30ED                    		xor	ch,ch	; 12/12/2018
 17977                                  		
 17978                                  		;mov	byte [sortex_i],1
 17979 00002A25 B301                    		mov	bl,1 ; 12/12/2018
 17980                                  
 17981 00002A27 B22E                    		mov	dl,46 ; ***DI*** ; 08/12/2018
 17982 00002A29 EB02                    		jmp	short sortept_6
 17983                                  sortept_5:
 17984                                  		;inc	byte [sortex_i]
 17985 00002A2B FEC3                    		inc	bl ; 12/12/2018
 17986                                  sortept_6:
 17987                                  		;mov	al,[sortex_count] ; size
 17988                                  		;cmp	[sortex_i],al
 17989                                  		;jge	short sortept_3
 17990                                  
 17991                                  		; 12/12/2018
 17992                                  		; CL = sort count
 17993 00002A2D 38CB                    		cmp	bl,cl
 17994 00002A2F 7DEE                    		jge	short sortept_3
 17995                                  
 17996 00002A31 B018                    		mov	al,24
 17997                                  		;imul	byte [cur_disk]
 17998 00002A33 F626[E2CB]              		mul	byte [cur_disk]
 17999                                  
 18000                                  		;mov	cx,ax  ; skip logical drives on previous disk(s)
 18001                                  		; cl = [current_disk]*24, ch = 0
 18002                                  
 18003                                  		; 12/12/2018
 18004 00002A37 88C6                    		mov	dh,al
 18005                                  		; dh = [current_disk]*24	
 18006                                  
 18007                                  		;mov	al,[sortex_i]
 18008                                  		;cbw
 18009                                  		;mov	bx,ax
 18010                                  		
 18011                                  		;mov	bx,[sortex_i]		
 18012                                  
 18013                                  		;mov	al,[bx+sort]
 18014                                  		;mov	dx,ax
 18015                                  		;cbw
 18016                                  		;add	ax,cx
 18017                                  
 18018 00002A39 8A87[F0C3]              		mov	al,[bx+sort]
 18019                                  		;add	al,cl  ; ([current_disk]*24) + [sort[i]] 		
 18020 00002A3D 00F0                    		add	al,dh  ; 12/12/2018 
 18021                                  
 18022                                  		;mov	si,ax
 18023                                  
 18024                                  		;mov	al,[bx+sort-1]
 18025                                  		;mov	di,46
 18026                                  		;mov	[swptemp1],ax
 18027                                  		;mov	ax,si
 18028                                  		;mov	[swptemp2],dx
 18029                                  		;imul	di
 18030                                  		;mov	si,ax
 18031                                  
 18032                                  		;mov	dl,46 ; ***DI***
 18033 00002A3F F6E2                    		mul	dl
 18034 00002A41 89C6                    		mov	si,ax
 18035                                  
 18036                                  		;mov	ax,[ext_table_start_cyl+si] ; ept[cur_disk][sort[i]].start_cyl
 18037                                  		;mov	dx,ax
 18038                                  		;mov	al,[swptemp1]
 18039                                  		;cbw
 18040                                  		;add	ax,cx
 18041                                  	
 18042 00002A43 8BBC[5BA1]              		mov	di,[ext_table_start_cyl+si] ; ept[cur_disk][sort[i]].start_cyl
 18043                                  		
 18044 00002A47 8A87[EFC3]              		mov	al,[bx+sort-1]
 18045                                  		
 18046                                  		; ah = 0
 18047                                  		;add	al,cl ; ; ([current_disk]*24) + [sort[i-i]] 
 18048                                  		;mov	cx,dx
 18049                                  		;imul	di
 18050                                  		
 18051 00002A4B 00F0                    		add	al,dh ; 12/12/2018
 18052 00002A4D F6E2                    		mul	dl ; 46
 18053 00002A4F 89C6                    		mov	si,ax
 18054                                  		
 18055                                  ;if (ext_table[cur_disk][sort[i]].start_cyl < ext_table[cur_disk][sort[i-1]].start_cyl)
 18056                                  
 18057                                  		;cmp	[ext_table_start_cyl+si],cx
 18058 00002A51 39BC[5BA1]              		cmp	[ext_table_start_cyl+si],di ; ept[cur_disk][sort[i-1]].start_cyl
 18059 00002A55 76D4                    		jna	short sortept_5
 18060                                  
 18061                                  		;ept[cur_disk][sort[i]].start_cyl < ept[cur_disk][sort[i-1]].start_cyl
 18062                                  
 18063                                  		;/* Swap the order indicators */
 18064                                  		;;mov	al,[swptemp1]
 18065                                  		;mov	al,[bx+sort-1]
 18066                                  		;mov	[sortex_temp],al
 18067                                  		;;mov	al,[swptemp2]
 18068                                  		;mov	al,[bx+sort]	
 18069                                  		;mov	[bx+sort-1],al
 18070                                  		;mov	al,[sortex_temp]
 18071                                  		;mov	[bx+sort],al
 18072                                  		
 18073                                  		; 12/12/2018
 18074 00002A57 8B87[EFC3]              		mov	ax,[bx+sort-1] ; 12/12/2018
 18075 00002A5B 86E0                    		xchg	ah,al
 18076 00002A5D 8987[EFC3]              		mov	[bx+sort-1],ax
 18077                                  
 18078                                  		;mov	byte [sortex_changed],1
 18079 00002A61 B501                    		mov	ch,1 ; 12/12/2018
 18080 00002A63 EBC6                    		jmp	short sortept_5
 18081                                  sortept_7:
 18082                                  		;pop	si
 18083                                  		;pop	di
 18084                                  		
 18085                                  		;mov	sp,bp ; 12/12/2018
 18086                                  		;pop	bp
 18087                                  		
 18088 00002A65 C3                      		retn
 18089                                  
 18090                                  ; ----------------------------------------------------------------------------
 18091                                  ; IBM PC-DOS 7.0 FDISK.COM, Segment 0, Offset 0014h
 18092                                  
 18093                                  ; 07/12/2018
 18094                                  ;_fptrap:
 18095                                  ;		retn
 18096                                  
 18097                                  ; CRT0FP.ASM - Microsoft Visual C++ Version 1.0
 18098                                  
 18099                                  ;***
 18100                                  ;_fptrap - trap for missing floating-point software
 18101                                  ;
 18102                                  ;Purpose:
 18103                                  ;	Catches these cases of incomplete f.p. software linked into a program.
 18104                                  ;
 18105                                  ;	(1) 87.LIB chosen, but no coprocessor present;
 18106                                  ;	    (i.e., emulator not linked)
 18107                                  ;
 18108                                  ;	(2) "%e", "%f", and "%g" i/o conversion formats specified, but
 18109                                  ;	    not all conversion software has been linked in, because the
 18110                                  ;	    program did not use any floating-point variables or expressions.
 18111                                  ;
 18112                                  ;Entry:
 18113                                  ;	None.
 18114                                  ;
 18115                                  ;Exit:
 18116                                  ;	None.
 18117                                  ;
 18118                                  ;Uses:
 18119                                  ;	AX.
 18120                                  ;
 18121                                  ;Exceptions:
 18122                                  ;	Transfers control to _amsg_exit which ...
 18123                                  ;	- Writes error message to standard error:  "floating point not loaded";
 18124                                  ;	- Terminates the program by calling _exit().
 18125                                  ;*******************************************************************************
 18126                                  
 18127                                  ;labelNP <PUBLIC,_fptrap>
 18128                                  ;
 18129                                  ;ifdef	_LOAD_DGROUP
 18130                                  ;;	 push	 ds		; no need to save ds since program will dying
 18131                                  ;	mov	ax, DGROUP
 18132                                  ;	mov	ds, ax
 18133                                  ;endif	;_LOAD_DGROUP
 18134                                  ;
 18135                                  ;	mov	ax,_RT_FLOAT	; issue floating point not loaded
 18136                                  ;	jmp	_amsg_exit	;   and die
 18137                                  
 18138                                  ; 14/12/2018
 18139                                  _fptrap:
 18140                                  	; 14/12/2018
 18141 00002A66 59                      	pop	cx  ; return address
 18142 00002A67 1E                      	push	ds
 18143 00002A68 FF36[D49E]              	push	word [fperror_msg_off]
 18144 00002A6C E8B5EB                  	call	display
 18145                                  	;pop	bx
 18146                                  	;pop	bx
 18147 00002A6F B0FF                    	mov	al,255
 18148 00002A71 E9F4D5                  	jmp	_exit
 18149                                  
 18150                                  ; CRT0.ASM (VCCRT2.ZIP) - Microsoft Visual C++ 1.0 Run-Time Library Sources
 18151                                  ; ----------------------------------------------------------------------------
 18152                                  ; Microsoft(R) Visual C++ Version 1.0 Run-Time Library Sources (1993)
 18153                                  ; ----------------------------------------------------------------------------
 18154                                  ; Modified and simplified for NASM syntax and com (single segment) file
 18155                                  ;						 (by Erdogan Tan, 07/12/2018)
 18156                                  
 18157                                  ;***
 18158                                  ;_amsg_exit, _cintDIV - Fast exit fatal errors
 18159                                  ;
 18160                                  ;Purpose:
 18161                                  ;	Exit the program with error code of 255 and appropriate error
 18162                                  ;	message.  cintDIV is used for integer divide by zero, amsg_exit
 18163                                  ;	is for other run time errors.
 18164                                  ;
 18165                                  ;ifdef _FATALHOOK
 18166                                  ;	Weak extern call through _fatalexit was added so programs
 18167                                  ;	may be notified of imminent termination (e.g., PWB).
 18168                                  ;endif
 18169                                  ;
 18170                                  ;Entry:
 18171                                  ;	AX	= error message number (amsg_exit only).
 18172                                  ;
 18173                                  ;Exit:
 18174                                  ;	calls exit() [cintDIV] or indirect through _aexit_rtn [amg_exit].
 18175                                  ;
 18176                                  ;Uses:
 18177                                  ;
 18178                                  ;Exceptions:
 18179                                  ;
 18180                                  ;*******************************************************************************
 18181                                  
 18182                                  ; 14/12/2018 (no need to _cintDIV and _agsm_exit for FDISK2.COM)
 18183                                  
 18184                                  ;; IBM PC-DOS 7.0 FDISK.COM, Segment 0, Offset 66D2h
 18185                                  ;
 18186                                  ;		_aDBdoswp equ 0D6D6h
 18187                                  ;_cintDIV:
 18188                                  ;
 18189                                  ;		;mov	ax,[cs:_dataseg] ; DGROUP
 18190                                  ;		;mov	ds,ax	
 18191                                  ;	
 18192                                  ;		push	cs	; 07/12/2018
 18193                                  ;		pop	ds
 18194                                  ;	
 18195                                  ;		mov	ax,3 ; _RT_INTDIV ; Integer divide by zero interrupt
 18196                                  ;		mov	word [_aexit_rtn],_exit ; call high-level exit()
 18197                                  ;				; to cause file buffer flushing
 18198                                  ;_amsg_exit:
 18199                                  ;		push	ax		; message number for _NMSG_WRITE
 18200                                  ;
 18201                                  ;		call	_FF_MSGBANNER	; run-time error message banner
 18202                                  ;		call	_NMSG_WRITE	; write error message to stdout
 18203                                  ;
 18204                                  ;		cmp	word [_aDBswpflg],_aDBdoswp  ; Aware debugger as parent?
 18205                                  ;		jne	short _@FF		     ; No -- skip
 18206                                  ;		pop	ax
 18207                                  ;		push	ax
 18208                                  ;		call	_aDBrterr	; Yes -- report a runtime error
 18209                                  ;_@FF:
 18210                                  ;		mov	ax,255
 18211                                  ;		push	ax
 18212                                  ;
 18213                                  ;		call	word [_aexit_rtn] ; _exit(255) ordinarily
 18214                                  ;					; (or exit(255) for div by 0)
 18215                                  ;					; NEAR routine pointer
 18216                                  
 18217                                  ;;_dataseg: dw	seg DGROUP ; for EXE file
 18218                                  ;_dataseg:  dw  0   ; for COM file
 18219                                  
 18220                                  ; ----------------------------------------------------------------------------
 18221                                  ; IBM PC-DOS 7.0 FDISK.COM, Segment 0, Offset 0016h
 18222                                  ;_FF_MSGBANNER:
 18223                                  ;		retn
 18224                                  
 18225                                  ; ----------------------------------------------------------------------------
 18226                                  ; IBM PC-DOS 7.0 FDISK.COM, Segment 0, Offset 0017h
 18227                                  ;_NMSG_WRITE:
 18228                                  ;		retn
 18229                                  
 18230                                  ; ----------------------------------------------------------------------------
 18231                                  ; IBM PC-DOS 7.0 FDISK.COM, Segment 0, Offset 6D61h
 18232                                  ;_aDBretaddr:
 18233                                  ;		retn
 18234                                  
 18235                                  ; LSEEK.ASM (VCCRT1.ZIP) - Microsoft Visual C++ 1.0 Run-Time Library Sources
 18236                                  ; ----------------------------------------------------------------------------
 18237                                  ; Downloaded From : The Programmer's Corner (www.pcorner.com) - 01/12/2018 -
 18238                                  
 18239                                  ; Modified and simplified for NASM syntax by Erdogan Tan (07/12/2018)
 18240                                  
 18241                                  ;***
 18242                                  ;long _lseek(fh,pos,mthd) - move the file pointer
 18243                                  ;
 18244                                  ;Purpose:
 18245                                  ;	Moves the file pointer associated with fh to a new position.
 18246                                  ;	The new position is pos bytes (pos may be negative) away
 18247                                  ;	from the origin specified by mthd.
 18248                                  ;
 18249                                  ;	If mthd == SEEK_SET, the origin in the beginning of file
 18250                                  ;	If mthd == SEEK_CUR, the origin is the current file pointer position
 18251                                  ;	If mthd == SEEK_END, the origin is the end of the file
 18252                                  ;
 18253                                  ;ifdef _QWIN
 18254                                  ;	Note:  Can't seek on QWIN file handles!
 18255                                  ;endif
 18256                                  ;
 18257                                  ;Entry:
 18258                                  ;	int fh - file handle to move file pointer on
 18259                                  ;	long pos - position to move to, relative to origin
 18260                                  ;	int mthd - specifies the origin pos is relative to (see above)
 18261                                  ;
 18262                                  ;Exit:
 18263                                  ;	returns the offset, in bytes, of the new position from the beginning
 18264                                  ;	of the file.
 18265                                  ;	returns -1L (and sets errno) if fails.
 18266                                  ;	Note that seeking beyond the end of the file is not an error.
 18267                                  ;	(although seeking before the beginning is.)
 18268                                  ;
 18269                                  ;Uses:
 18270                                  ;
 18271                                  ;Exceptions:
 18272                                  ;
 18273                                  ;*******************************************************************************
 18274                                  
 18275                                  ; 14/12/2018 (no need to _lseek for FDISK2.COM)
 18276                                  
 18277                                  ;; IBM PC-DOS 7.0 FDISK.COM, Segment 0, Offset 7C74h
 18278                                  ;
 18279                                  ;_lseek:
 18280                                  ;
 18281                                  ;	%define loword	bp-4
 18282                                  ;	%define hiword	bp-2
 18283                                  ;
 18284                                  ;	%define fh	bp+4
 18285                                  ;	%define	pos	bp+6
 18286                                  ;	%define pos2	bp+8
 18287                                  ;	%define mthd	bp+10
 18288                                  ;
 18289                                  ;		push	bp
 18290                                  ;		mov	bp,sp
 18291                                  ;		sub	sp,4
 18292                                  ;		
 18293                                  ;		mov	bx,[fh]		; file handle
 18294                                  ;		; make sure handle is in OS file handle range
 18295                                  ;		cmp	bx,_nfile
 18296                                  ;		jb	short handle_ok
 18297                                  ;
 18298                                  ;	; _dosret must set DX:AX to -1L
 18299                                  ;		;mov	ax,EBADF shl 8 + 0 ; file handle is out of range
 18300                                  ;		mov	ax,900h
 18301                                  ;		jmp	short seterr
 18302                                  ;handle_ok:
 18303                                  ;
 18304                                  ;; negative offset - due to a DOS idiosyncracy, we have to check here to see
 18305                                  ;; if the seek would move us to a location prior to the beginning of the
 18306                                  ;; file, and, if so, return an error.
 18307                                  ;
 18308                                  ;		test	word [pos+2],8000h ; negative offset ?
 18309                                  ;		jz	short doit	; not negative; just do lseek
 18310                                  ;
 18311                                  ;		cmp	byte [mthd],0	; byte 0 relative?
 18312                                  ;		je	short negative	; yes, error
 18313                                  ;
 18314                                  ;		xor	cx,cx		; no, find current position
 18315                                  ;		mov	dx,cx		; 0L
 18316                                  ;		mov	ax,4201h ; mov ax,DOS_lseek shl 8 + 1
 18317                                  ;		int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 18318                                  ;				; AL = method: offset from present location
 18319                                  ;		jc	short errexit	; if error
 18320                                  ;		test	byte [mthd],2
 18321                                  ;		jnz	short findeof	; mthd is 2
 18322                                  ;					; mthd is 1
 18323                                  ;		add	ax,[pos]	; low word
 18324                                  ;		adc	dx,[pos+2]	; hi word
 18325                                  ;		jns	short doit	; net position is not negative; do lseek
 18326                                  ;negative:				; net position is negative, return
 18327                                  ;		;mov	ax,EINVAL shl 8 + 0 ; invalid value error
 18328                                  ;		mov	ax,1600h
 18329                                  ;seterr:
 18330                                  ;		stc
 18331                                  ;		jmp	short errexit
 18332                                  ;findeof:				; mthd is relative to end of file
 18333                                  ;		mov	[hiword],dx	; save present position (dx:ax)
 18334                                  ;		mov	[loword],ax
 18335                                  ;		mov	dx,cx		; 0L - cx is still zero from previous call
 18336                                  ;		mov	ax,4202h ; mov	ax,DOS_lseek shl 8 + 2 ; find eof position
 18337                                  ;		int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 18338                                  ;				; AL = method: offset from end of file
 18339                                  ;		add	ax,[pos]	; low word
 18340                                  ;		adc	dx,[pos+2]	; hi word
 18341                                  ;		jns	short doit	; if non-negative, just do lseek
 18342                                  ;
 18343                                  ;	; net position would be negative, seek back to original location, then fail
 18344                                  ;
 18345                                  ;		mov	cx,[hiword]	; original offset
 18346                                  ;		mov	dx,[loword]
 18347                                  ;		;mov	ax,DOS_lseek shl 8 + 0 ; from beginning of file
 18348                                  ;		mov	ax,4200h	; go back
 18349                                  ;		int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 18350                                  ;				; AL = method: offset from beginning of	file
 18351                                  ;		jmp	short negative
 18352                                  ;
 18353                                  ;	; seek to the specified location
 18354                                  ;	; bx = file handle
 18355                                  ;doit:
 18356                                  ;		mov	dx,[pos]	; low(pos)
 18357                                  ;		mov	cx,[pos+2]	; high(pos)
 18358                                  ;		mov	al,[mthd]	; method
 18359                                  ;		mov	ah,42h	; move file ptr
 18360                                  ;		int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 18361                                  ;				; AL = method:
 18362                                  ;				; 0-from beginnig,1-from current,2-from	end
 18363                                  ;		jb	short errexit
 18364                                  ;		;and	__osfile[bx],NOT FEOFLAG ; clear ^z flag if lseek succeeds
 18365                                  ;		and	byte [_osfile+bx],~2 ; not 2
 18366                                  ;errexit:
 18367                                  ;		;jmp	__dosretax
 18368                                  ;		;jmp	short _dosretax
 18369                                  ;		;jmp	short DOSerror ; **errexit**
 18370                                  
 18371                                  ; ----------------------------------------------------------------------------
 18372                                  
 18373                                  ;***
 18374                                  ;dosret.asm - map DOS error number to standard C (XENIX) error numbers; returns
 18375                                  ;
 18376                                  ;	Copyright (c) 1987-1992, Microsoft Corporation. All rights reserved.
 18377                                  ;
 18378                                  ;Purpose:
 18379                                  ;	Maps the standard DOS error number to C (XENIX) error number and
 18380                                  ;	returns.  Used at the end of many runtime routines.
 18381                                  ;
 18382                                  ;*******************************************************************************
 18383                                  
 18384                                  ; 14/12/2018 (no need to _dosreto,_dosretax,Doseror,DOSnoerror for FDISK2.COM)
 18385                                  
 18386                                  ;;_dosret0:
 18387                                  ;;		jc	short DOSerror	; set errors
 18388                                  ;;
 18389                                  ;;ret_0:
 18390                                  ;;		xor	ax,ax		; clear errors
 18391                                  ;;		mov	sp,bp
 18392                                  ;;		pop	bp
 18393                                  ;;		retn
 18394                                  ;;_dosreturn:
 18395                                  ;;		jnc	short ret_0
 18396                                  ;;		push	ax
 18397                                  ;;		call	maperror
 18398                                  ;;		pop	ax	; set errno and return original DOS error	
 18399                                  ;;		xor	ah,ah	; make sure ah is 0
 18400                                  ;;		mov	sp,bp
 18401                                  ;;		pop	bp
 18402                                  ;;		retn
 18403                                  ;
 18404                                  ;_dosretax:
 18405                                  ;		jnc	short DOSnoerror ; no errors	
 18406                                  ;
 18407                                  ;DOSerror:				; **errexit**
 18408                                  ;		call	maperror 	; map error to standard C error	
 18409                                  ;		mov	ax,-1		; return DX:AX = -1L
 18410                                  ;		cwd
 18411                                  ;DOSnoerror:
 18412                                  ;		mov	sp,bp
 18413                                  ;		pop	bp
 18414                                  ;		retn
 18415                                  
 18416                                  ; ----------------------------------------------------------------------------
 18417                                  ;_maperror - map DOS errors to standard XENIX errors
 18418                                  
 18419                                  ; 14/12/2018 (no need to _maperror for FDISK2.COM)
 18420                                  
 18421                                  ;_maperror:
 18422                                  ;		xor	ah,ah	 ; clear ah
 18423                                  ;		;call	maperror ; map the error	
 18424                                  ;		;retn
 18425                                  ;
 18426                                  ;; XENIX error translation can be overridden - AH = new XENIX error code
 18427                                  ;
 18428                                  ;maperror:
 18429                                  ;		mov	byte [_doserrno],al ; save dos error
 18430                                  ;		or	ah,ah	; xenix error code override?	
 18431                                  ;		jnz	short mapover ; yes, map the override values
 18432                                  ;
 18433                                  ;		cmp	byte [_dosvermajor],3 ; is this version 3.0 ?
 18434                                  ;		jb	short chk2	; no, compare to 2.0 max error
 18435                                  ;
 18436                                  ;		;cmp	al,E_maxerr3	; yes, compare to 3.0 max error
 18437                                  ;		cmp	al,22h
 18438                                  ;		jnb	short maxerr2	; set bad error value
 18439                                  ;		;cmp	al,E_sharerr	; is this a legit 3.0 error ?
 18440                                  ;		cmp	al,20h
 18441                                  ;		jb	short chk2	; no, see if 2.0 error
 18442                                  ;
 18443                                  ;; we get here only if we have an error value larger than is legit for
 18444                                  ;; 2.0 (19), and is inrange for 3.0. Currently we only support the sharing
 18445                                  ;; and locking violation errors for 3.0, but this will probably change in
 18446                                  ;; the future. We will always map sharing and locking violations to EACCES
 18447                                  ;; Xenix errors.
 18448                                  ;		;mov	al,E_access	; yes, set for access error
 18449                                  ;		mov	al,5
 18450                                  ;		jmp	short inrange	; map it
 18451                                  ;chk2:
 18452                                  ;		;cmp	al,E_maxerr2	; no, compare to 2.0 max error
 18453                                  ;		cmp	al,13h
 18454                                  ;		jbe	short inrange	; error value ok
 18455                                  ;maxerr2:
 18456                                  ;		;mov	al,E_maxerr2	; error value bad, default to max error
 18457                                  ;		mov	al,13h
 18458                                  ;inrange:
 18459                                  ;		;mov	bx,errtab
 18460                                  ;		mov	bx,err_conv_tbl
 18461                                  ;		xlat
 18462                                  ;mapsave:
 18463                                  ;		cbw
 18464                                  ;		mov	[errno],ax
 18465                                  ;		retn
 18466                                  ;mapover:
 18467                                  ;		mov	al,ah
 18468                                  ;		jmp	short mapsave
 18469                                  
 18470                                  ; _GETBUF.ASM (VCCRT2.ZIP) - Microsoft Visual C++ 1.0 Run-Time Library Sources
 18471                                  ; ----------------------------------------------------------------------------
 18472                                  ; Modified and simplified for NASM syntax by Erdogan Tan (09/12/2018)
 18473                                  
 18474                                  ;***
 18475                                  ;_getbuf() - Allocate a buffer and init stream data bases
 18476                                  ;
 18477                                  ;Purpose:
 18478                                  ;	Allocates a buffer for a stream and inits the stream data bases.
 18479                                  ;
 18480                                  ;	[NOTE  1: This routine assumes the caller has already checked to make
 18481                                  ;	sure the stream needs a buffer.
 18482                                  ;
 18483                                  ;	[NOTE 2: Multi-thread - Assumes caller has acquired stream lock, if
 18484                                  ;	needed.]
 18485                                  ;
 18486                                  ;	[NOTE 3: The code now assumes that _iob[] and _iob2[] are near arrays
 18487                                  ;	of the same element size.]
 18488                                  ;
 18489                                  ;Entry:
 18490                                  ;	FILE *stream = stream to allocate a buffer for
 18491                                  ;
 18492                                  ;Exit:
 18493                                  ;	void
 18494                                  ;
 18495                                  ;Exceptions:
 18496                                  ;
 18497                                  ;*******************************************************************************
 18498                                  
 18499                                  ; 14/12/2018 (no need to _getbuf for FDISK2.COM)
 18500                                  
 18501                                  ;_getbuf:
 18502                                  ;	;%define gb_stream bp+4
 18503                                  ;
 18504                                  ;	; INPUT-> si = offset stream data address [ _getbuf(stream) ]
 18505                                  ;
 18506                                  ;		;push	bp
 18507                                  ;		;mov	bp,sp
 18508                                  ;		;push	si	
 18509                                  ;
 18510                                  ;		;mov	si,[gb_stream]
 18511                                  ;
 18512                                  ;		;mov	ax,BUFSIZ
 18513                                  ;		mov	ax,512
 18514                                  ;		push	ax
 18515                                  ;		call	malloc		; malloc(BUFSIZ)
 18516                                  ;		pop	cx		; clean off arg
 18517                                  ;;**
 18518                                  ;; Set:
 18519                                  ;;	bx = _iob2 entry (aka stream2)
 18520                                  ;; Note that by doing it here/now, we don't have to save/restore bx or di.
 18521                                  ;
 18522                                  ;		mov	bx,si
 18523                                  ;		sub	bx,_iob
 18524                                  ;		add	bx,_iob2
 18525                                  ;;**
 18526                                  ;; Now, check the return from malloc(). If it worked, installed the newly
 18527                                  ;; malloc-ed buffer. Otherwise, install single character buffering.
 18528                                  ;
 18529                                  ;;if sizeD
 18530                                  ;;		or	dx,dx		; NULL return?
 18531                                  ;;else
 18532                                  ;		or	ax,ax		; NULL return?
 18533                                  ;;endif
 18534                                  ;		jz	short _singlechar ;   yes, install single char buffer
 18535                                  ;;**
 18536                                  ;; Set stream->_flag and stream2->_bufsiz fields. Then, branch to code
 18537                                  ;; to set other stream fields.
 18538                                  ;
 18539                                  ;		;or	[si]._flag,_IOMYBUF
 18540                                  ;		or	byte [si+6],8
 18541                                  ;		;mov	[bx]._bufsiz,BUFSIZ
 18542                                  ;		mov	word [bx+2],512
 18543                                  ;		jmp	short setfields
 18544                                  ;_singlechar:
 18545                                  ;		;or	[si]._flag,_IONBF
 18546                                  ;		or	byte [si+6],4
 18547                                  ;		;mov	[bx]._bufsiz,1
 18548                                  ;		mov	word [bx+2],1
 18549                                  ;;if sizeD
 18550                                  ;;		mov	dx,ds
 18551                                  ;;endif
 18552                                  ;		;lea	ax,[bx]._charbuf
 18553                                  ;		lea	ax,[bx+1]
 18554                                  ;;**
 18555                                  ;; Set the _ptr, _base and _cnt fields of stream. Note that, on entry, ax
 18556                                  ;; (dx:ax in large data models) is a pointer to new stream buffer.
 18557                                  ;
 18558                                  ;setfields:
 18559                                  ;
 18560                                  ;;if sizeD
 18561                                  ;;		mov	word ptr [si]._ptr + 2,dx
 18562                                  ;;		mov	word ptr [si]._ptr,ax
 18563                                  ;;		mov	word ptr [si]._base + 2,dx
 18564                                  ;;		mov	word ptr [si]._base,ax
 18565                                  ;;else
 18566                                  ;		;mov	word ptr [si]._ptr,ax
 18567                                  ;		mov	[si],ax
 18568                                  ;		;mov	word ptr [si]._base,ax
 18569                                  ;		mov	[si+4],ax
 18570                                  ;;endif
 18571                                  ;		;mov	word ptr [si]._cnt,0
 18572                                  ;		mov     word [si+2],0
 18573                                  ;done:
 18574                                  ;		;pop	si
 18575                                  ;		;pop	bp
 18576                                  ;		retn
 18577                                  
 18578                                  ; NMALLOC.ASM (VCCRT1.ZIP) - Microsoft Visual C++ 1.0 Run-Time Library Sources
 18579                                  ; ----------------------------------------------------------------------------
 18580                                  ; Modified and simplified for NASM syntax by Erdogan Tan (09/12/2018)
 18581                                  
 18582                                  ; 14/12/2018 (no need to malloc,_nmalloc for FDISK2.COM)
 18583                                  
 18584                                  ;malloc:
 18585                                  ;		;jmp	_nmalloc
 18586                                  
 18587                                  ;***
 18588                                  ;void near *_nmalloc(size) - allocate a memory block in the near heap
 18589                                  ;
 18590                                  ;Purpose:
 18591                                  ;	Allocates a memory block of at least size bytes in the near heap.
 18592                                  ;	The block will be aligned for the storage of any type of object.
 18593                                  ;
 18594                                  ;	[NOTE: This routine assumes that the near heap is already
 18595                                  ;	initialized (at startup).]
 18596                                  ;
 18597                                  ;	[MTHREAD NOTE: Multi-thread libraries do NOT support the
 18598                                  ;	?varstck.obj functionality.  Thus, _STKHQQ can be referenced
 18599                                  ;	directly (i.e., without using the tid data table).
 18600                                  ;
 18601                                  ;Entry:
 18602                                  ;	unsigned size - size of memory block desired
 18603                                  ;
 18604                                  ;	CRTDLL:  ds:bx = near heap descriptor
 18605                                  ;
 18606                                  ;Exit:
 18607                                  ;	returns pointer to allocated space or NULL if fails
 18608                                  ;
 18609                                  ;Uses:
 18610                                  ;
 18611                                  ;Exceptions:
 18612                                  ;
 18613                                  ;*******************************************************************************
 18614                                  
 18615                                  ;_nmalloc:
 18616                                  ;
 18617                                  ;	%define incr	bp+4
 18618                                  ;
 18619                                  ;		push	bp
 18620                                  ;		mov	bp,sp
 18621                                  ;		push	si
 18622                                  ;		push	di
 18623                                  ;		mov	cx,[incr]	; cx = request block size
 18624                                  ;		cmp	cx,0FFE8h ; _HEAP_MAXREQ ; cx > max. legal request size ?
 18625                                  ;		ja	short error_rtn	; nope, try to get the memory
 18626                                  ;
 18627                                  ;; Try to get the requested block from the heap
 18628                                  ;; cx = size
 18629                                  ;getmem:
 18630                                  ;		mov	bx,_nheap_desc	; ds:bx = heap descriptor
 18631                                  ;		call	_searchseg	; get block
 18632                                  ;		jnc	short ndone	; if success, we're all done
 18633                                  ;
 18634                                  ;; Did not find a suitable block in the heap.
 18635                                  ;; Try to grow the heap.
 18636                                  ;; cx = size, ds:bx = heap descriptor
 18637                                  ;
 18638                                  ;		call	_growseg	; try to grow the segment
 18639                                  ;		jc	short error_rtn ; if error, return NULL
 18640                                  ;
 18641                                  ;; We successfully grew the heap. Try the search again.
 18642                                  ;; (Rover pointer should be in a place that makes this search efficient.)
 18643                                  ;; cx = size, ds:bx = heap descriptor
 18644                                  ;
 18645                                  ;		call	_searchseg	; search the heap segment
 18646                                  ;		jnc	short ndone	; if success, take good return
 18647                                  ;; Error return
 18648                                  ;error_rtn:
 18649                                  ;		xor	ax, ax
 18650                                  ;		cwd
 18651                                  ;		;jmp	short $+2
 18652                                  ;; Common exit
 18653                                  ;; (dx:ax = return value)
 18654                                  ;ndone:
 18655                                  ;		pop	di
 18656                                  ;		pop	si
 18657                                  ;		pop	bp
 18658                                  ;		retn
 18659                                  
 18660                                  ; HEAP.INC
 18661                                  ;
 18662                                  ; --- Heap segment descriptor ---
 18663                                  ;
 18664                                  ; [***NOTE*** Some heap routines make assumptions about the layout of the
 18665                                  ; heap descriptor. If this descriptor changes, some routines may break.]
 18666                                  ;
 18667                                  
 18668                                  ; 09/12/2018
 18669                                  
 18670                                  ;struc _heap_seg_desc
 18671                                  ; .checksum:	resw 1	; checksum area
 18672                                  ; .flags:	resw 1	; flags word
 18673                                  ; .segsize:	resw 1	; size of segment
 18674                                  ; .start:	resw 1	; offset of first heap entry
 18675                                  ; .rover:	resw 1	; rover offset
 18676                                  ; .last:	resw 1	; offset to end-of-heap marker
 18677                                  ; .nextseg:	resd 1	; far pointer to next _heap_seg_desc
 18678                                  ; .prevseg:	resd 1	; far pointer to previous _heap_seg_desc
 18679                                  ; .size:
 18680                                  ;endstruc
 18681                                  
 18682                                  ; SEARCHSG.ASM - Microsoft Visual C++ 1.0 Run-Time Library Sources
 18683                                  ; ----------------------------------------------------------------------------
 18684                                  
 18685                                  ;***
 18686                                  ; _searchseg - Search a heap segment
 18687                                  ;
 18688                                  ;Purpose:
 18689                                  ;
 18690                                  ; This routine scans through the supplied heap segment looking for a
 18691                                  ; block big enough to satisfy the size request. Contiguous free blocks
 18692                                  ; are coalesced as necessary.
 18693                                  ;
 18694                                  ; The search is done in two parts:
 18695                                  ;
 18696                                  ;	(1) First, we search from the current rover pointer to the end
 18697                                  ;	of the heap segment.
 18698                                  ;
 18699                                  ;	(2) Second, we search from the start of the heap segment to the
 18700                                  ;	rover pointer (being careful to overlap so that all free blocks
 18701                                  ;	are coalesced as much as possible).
 18702                                  ;
 18703                                  ;Entry:
 18704                                  ;	cx = requested size
 18705                                  ;	     [If requested size = _HEAP_COALESCE, then we simply coalesce
 18706                                  ;	     the heap segment and return with carry set]
 18707                                  ;	ds:bx = address of heap descriptor
 18708                                  ;
 18709                                  ;Exit:
 18710                                  ;	Success:
 18711                                  ;		carry = clear
 18712                                  ;		dx:ax = address of block
 18713                                  ;	Failure:
 18714                                  ;		carry = set
 18715                                  ;
 18716                                  ;Uses:
 18717                                  ;	ax, dx, si, di
 18718                                  ;
 18719                                  ;Preserved:
 18720                                  ;	ds:bx, cx
 18721                                  ;
 18722                                  ;Exceptions:
 18723                                  ;	If we detect an inconsistent heap, we return NULL and set errno
 18724                                  ;	to ***???***.
 18725                                  ;
 18726                                  ;*******************************************************************************
 18727                                  
 18728                                  ; 14/12/2018 (no need to _searchseg for FDISK2.COM)
 18729                                  ;
 18730                                  ;_searchseg:
 18731                                  ;		inc	cx
 18732                                  ;		and	cl,0FEh ; ~1 ; not 1 ; round size up to even number
 18733                                  
 18734                                  ; first_pass -
 18735                                  ; On the first pass through the heap, we will search from the current
 18736                                  ; rover pointer to the end of the heap. Set the 'end-of-search' pointer
 18737                                  ; such that the search will not end until we encounter the _HEAP_END flag.
 18738                                  ;
 18739                                  ; Entry:
 18740                                  ;			BX = heap descriptor
 18741                                  ;			CX = requested size
 18742                                  ;
 18743                                  ; Exit Paths:
 18744                                  ;		check_block
 18745                                  ;			SI = pointer where the heap search should start
 18746                                  ;			DI = 0 (pointer to last free block examinted)
 18747                                  ;			BX = pointer to _HEAP_END (where search should end)
 18748                                  ;			CX = requested size
 18749                                  ;			TOS = heap descriptor
 18750                                  
 18751                                  ;first_pass:
 18752                                  ;		push	bx		; save heap descriptor
 18753                                  ;		cld			; go forward when loading
 18754                                  ;		;mov	si,[bx].rover	; si = pointer to start of search
 18755                                  ;		mov	si,[bx+8]
 18756                                  ;		;mov	bx,[bx].last	; bx = pointer to end-of-heap marker
 18757                                  ;		mov	bx,[bx+10]
 18758                                  ;		xor	di,di		; zero out di
 18759                                  ;		jmp	short check_block ; jump into loop
 18760                                  
 18761                                  ; next_pass -
 18762                                  ; We have completed a pass through the heap.
 18763                                  ;	(1) Update .last pointer if necessary.	The only way this could happen
 18764                                  ;	is if we coalesced the last block with one before it.  Thus, we only
 18765                                  ;	need a pointer to the last free block we examined to determine if
 18766                                  ;	.last must be updated.
 18767                                  ;	(3) Determine which pass has been completed by checking the lower
 18768                                  ;	order bit of the end-of-search pointer.
 18769                                  ;	(3) If we just finished the second pass, return an error.
 18770                                  ;	(4) Else, start up a heap search from the start of the heap to the
 18771                                  ;	rover pointer. Use rover - 1 as the value of the end-of-search pointer
 18772                                  ;	since it works are well as rover does and it makes it easy to
 18773                                  ;	determine which pass we have completed.
 18774                                  ;
 18775                                  ; Entry:
 18776                                  ;			BX = end-of-search pointer = pointer to end-of-heap
 18777                                  ;			     marker (after first pass) or rover - 1 (after
 18778                                  ;			     second pass)
 18779                                  ;			CX = requested size
 18780                                  ;			DI = 0 or pointer to last free block examined + 2
 18781                                  ;			TOS = heap descriptor
 18782                                  ;
 18783                                  ; Exit Paths:
 18784                                  ;		failure1 (end of search, block not found)
 18785                                  ;			TOS = heap descriptor
 18786                                  ;		failure2 (end of search, block not found)
 18787                                  ;			BX = heap descriptor
 18788                                  ;		check_block (start up the second heap search)
 18789                                  ;			SI = pointer where the heap search should start
 18790                                  ;			DI = 0 (pointer to last free block examinted)
 18791                                  ;			BX = end-of-search pointer = rover - 1
 18792                                  ;			CX = requested size
 18793                                  ;			TOS = heap descriptor
 18794                                  
 18795                                  ;next_pass:
 18796                                  ;		mov	ax,bx		; ax = end-of-search pointer
 18797                                  ;		pop	bx		; bx = heap descriptor
 18798                                  
 18799                                  ; see if we need another pass through the heap
 18800                                  
 18801                                  ;check_pass:
 18802                                  ;		test	al,1		; test low order bit on eos pointer
 18803                                  ;		jnz	short failure2	; bit was set, we're done
 18804                                  
 18805                                  ; set up for second pass through the heap
 18806                                  
 18807                                  ;		push	bx			; save heap descriptor
 18808                                  ;		;mov	si,[bx].start		; si = start search ptr = start
 18809                                  ;		mov	si,[bx+6]
 18810                                  ;		;mov	bx,[bx].rover		; bx = end-of-search ptr = rover
 18811                                  ;		mov	bx,[bx+8]
 18812                                  ;		cmp	bx,si			; start == rover ??
 18813                                  ;		je	short failure1		; if so, no need to try another pass
 18814                                  ;		dec	bx			; end-of-search pointer = rover - 1
 18815                                  ;		xor	di,di			; zero out di
 18816                                  ;
 18817                                  ;		jmp	short check_block	; jump into loop
 18818                                  
 18819                                  ; ---------- Start of segment search loop ----------
 18820                                  ;
 18821                                  ; The following registers are not changed by any code in the segment
 18822                                  ; search loop:
 18823                                  ;			BX = end of search pointer
 18824                                  ;			CX = requested size
 18825                                  ;			TOS = heap descriptor
 18826                                  ;
 18827                                  ; next_block -
 18828                                  ; See if we're at the end of the segment search loop. If not, move
 18829                                  ; on to the next block.
 18830                                  ;
 18831                                  ; Entry:
 18832                                  ;			AX = header of last block examined (not free)
 18833                                  ;			SI = pointer to last block examined (not free) + 2
 18834                                  ;			DI = 0 or pointer to last free block examined + 2
 18835                                  ;
 18836                                  ; Exit Paths:
 18837                                  ;		next_pass (first pass through heap failed)
 18838                                  ;			DI = 0 or pointer to last free block examined + 2
 18839                                  ;
 18840                                  ;		check_block (info for next block is loaded into AX and SI)
 18841                                  ;			AX = header for (new) block to be checked
 18842                                  ;			SI = pointer to (new) block to be checked + 2
 18843                                  ;			DI = 0 or pointer to last free block examined + 2
 18844                                  
 18845                                  ;EVEN
 18846                                  
 18847                                  ;align 2
 18848                                  ;
 18849                                  ;next_block:
 18850                                  ;		lea	dx,[si-2]	; get current ptr
 18851                                  ;		cmp	dx,bx		; current ptr >= end-of-search ptr ?
 18852                                  ;		jae	short next_pass	; yes, done with this pass
 18853                                  ;
 18854                                  ;		add	si,ax		; bump pointer to next block
 18855                                  ;		jc	short heap_toast ; *** inconsistent heap ***
 18856                                  ;		;fall thru
 18857                                  
 18858                                  ; check_block -
 18859                                  ; Check to see if the current block is free.
 18860                                  ;
 18861                                  ; Entry:
 18862                                  ;			SI = pointer to current block
 18863                                  ;			DI = 0 or pointer to last free block examined + 2
 18864                                  ;
 18865                                  ; Exit Paths:
 18866                                  ;		next_block (if current block is not free)
 18867                                  ;			AX = current block (not free) header
 18868                                  ;			SI = pointer to current block + 2
 18869                                  ;			DI = 0 or pointer to last free block examined + 2
 18870                                  ;		coal_loop (if current block is free)
 18871                                  ;			AX = current block (free) header
 18872                                  ;			SI, DI = pointers to current block + 2
 18873                                  ;
 18874                                  
 18875                                  ;check_block:
 18876                                  ;		lodsw			; ax = get the first block header
 18877                                  ;		test	al,1		; is it free?
 18878                                  ;		jz	short next_block ; no, go try the next block
 18879                                  ;		mov	di,si
 18880                                  ;	;fall thru
 18881                                  
 18882                                  ; coal_loop -
 18883                                  ; Check to see if current block is big enough. If not, try to
 18884                                  ; coalesce proceeding free block with the current block. Loop until we get
 18885                                  ; get a big enough block or cannot coalesce anymore.
 18886                                  ;
 18887                                  ; Entry:
 18888                                  ;			AX = current block header
 18889                                  ;			SI, DI = pointers to current block + 2
 18890                                  ;
 18891                                  ; Exit Paths:
 18892                                  ;		blockfound (current block is big enough)
 18893                                  ;			AX = size of current block
 18894                                  ;			SI, DI = pointers to current block + 2
 18895                                  ;		next_block (failure)
 18896                                  ;			DX = size of current block
 18897                                  ;			DI = pointer to current block + 2
 18898                                  ;			AX = header of next block (not free)
 18899                                  ;			SI = pointer to next block (not free) + 2
 18900                                  
 18901                                  ;;EVEN
 18902                                  ;
 18903                                  ;coal_loop:
 18904                                  ;		dec	ax		; subtract free flag
 18905                                  ;		cmp	ax,cx		; is it big enough?
 18906                                  ;		jae	short blockfound ;   yep, go finish up
 18907                                  ;		add	si,ax		; point to header of next block
 18908                                  ;		jc	short heap_toast ; *** inconsistent heap ***
 18909                                  ;		mov	dx,ax		; save size of original block in DX
 18910                                  ;		lodsw			; get header of next block into AX
 18911                                  ;		test	al,1		; is it free?
 18912                                  ;		jz	short next_block ;   no, go try the next block
 18913                                  ;		add	ax,dx		; coalesce
 18914                                  ;		add	ax,2		; add in header space
 18915                                  ;		mov	si,di		; reset SI to block + 2
 18916                                  ;		mov	[si-2],ax	; update block size
 18917                                  ;		jmp	short coal_loop
 18918                                  
 18919                                  ; ---------- End of segment search loop ----------
 18920                                  
 18921                                  ; heap_toast -
 18922                                  ; We detected an internal consistency error in the heap.
 18923                                  ; Set errno and return an error to the user.
 18924                                  
 18925                                  ;heap_toast:
 18926                                  ;		mov	ax,ax  ; place where we can place a breakpoint for now...
 18927                                  ;		; fall thru for now
 18928                                  
 18929                                  ; failure1, failure2 -
 18930                                  ; We could not find a big enough block in the heap.
 18931                                  ;
 18932                                  ;    (1) Set the rover pointer to the beginning of the heap since
 18933                                  ;	 the rover block may have been coalesced (i.e., the rover
 18934                                  ;	 pointer may no longer point to valid memory).
 18935                                  ;
 18936                                  ;	*** I THINK THIS IS WHAT THE OLD HEAP IS DOING.
 18937                                  ;	*** DO WE WANT TO DO THIS OR CAN WE SOMEHOW MOVE THE
 18938                                  ;	*** ROVER BACK TO THE MERGED BLOCK, IF NECESSARY.
 18939                                  ;
 18940                                  ;    (2) Return carry set to caller.
 18941                                  ;
 18942                                  ; Entry:
 18943                                  ;		failure1
 18944                                  ;			TOS = heap descriptor
 18945                                  ;
 18946                                  ;		failure2
 18947                                  ;			BX = heap descriptor
 18948                                  ;			CX = requested size
 18949                                  ;
 18950                                  ; Exit Paths:
 18951                                  ;		Return to caller (via done)
 18952                                  ;			Carry = set
 18953                                  ;			DS:BX = heap descriptor
 18954                                  ;			CX = requested size
 18955                                  
 18956                                  ;failure1:
 18957                                  ;		pop	bx		; bx = heap descriptor
 18958                                  ;failure2:
 18959                                  ;		;mov	ax,[bx].start	; set rover = start
 18960                                  ;		mov	ax,[bx+6]
 18961                                  ;		;mov	[bx].rover,ax
 18962                                  ;		mov	[bx+8],ax
 18963                                  ;		stc			; carry set = error
 18964                                  ;		jmp	short _done
 18965                                  
 18966                                  ; blockfound -
 18967                                  ; Found a block that fullfills the caller's request.
 18968                                  ;	(1) Transform the block found into an allocated block that
 18969                                  ;	exactly satisfies the allocation request (in CX) and a leftover,
 18970                                  ;	free block.
 18971                                  ;	(2) Update the rover and end pointers, as needed.
 18972                                  ;	(3) Return pointer to the allocated block to the caller.
 18973                                  ;
 18974                                  ; Entry:
 18975                                  ;			AX = size of (free) block (AX >= CX)
 18976                                  ;			SI, DI = pointers to block + 2
 18977                                  ;			CX = requested size
 18978                                  ;			ZF = 1 iff the block is an exact fit (i.e., AX == CX)
 18979                                  ;			     0 otherwise
 18980                                  ;			TOS = heap descriptor
 18981                                  ;
 18982                                  ; Exit Paths:
 18983                                  ;		Return to caller
 18984                                  ;			Carry = clear
 18985                                  ;			DX:AX = pointer to allocated block
 18986                                  ;			DS:BX = heap descriptor
 18987                                  ;			CX = requested size
 18988                                  
 18989                                  ;blockfound:
 18990                                  ;		pop	bx		; get heap descriptor
 18991                                  ;
 18992                                  ;		mov	[si-2],cx	; update header
 18993                                  ;		je	short set_rover	; jump if block size = request size
 18994                                  ;
 18995                                  ;		add	di,cx		; point to leftover piece
 18996                                  ;		sub	ax,cx		; compute header for leftover piece
 18997                                  ;		dec	ax		; as a free block
 18998                                  ;		mov	[di],ax 	; make it a free block
 18999                                  ;		sub	di,cx		; update rover
 19000                                  ;set_rover:
 19001                                  ;		add	di,cx		; point to leftover piece
 19002                                  ;set_rover1:
 19003                                  ;		;mov	[bx].rover,di	; update rover
 19004                                  ;		mov	[bx+8],di
 19005                                  ;		mov	ax,si		; return pointer to allocated block
 19006                                  ;		mov	dx,ds
 19007                                  ;		clc			; carry clear = success
 19008                                  ;; Common exit
 19009                                  ;_done:
 19010                                  ;		retn			; explicit return
 19011                                  
 19012                                  ; HEAP.INC
 19013                                  
 19014                                  ; _heap_seg_desc.flags bit offsets
 19015                                  
 19016                                  ;_HEAP_MODIFY	equ	01h		; heap segment size can be modified
 19017                                  ;_HEAP_FREE	equ	02h		; heap segment may be freed up to OS
 19018                                  ;_HEAP_NEAR	equ	04h		; heap segment is part of the near heap
 19019                                  ;_HEAP_BASED	equ	08h		; heap segment is part of the based heap
 19020                                  
 19021                                  ; --- General Use Heap Constants ---
 19022                                  
 19023                                  ;_HEAP_END	equ	0FFFEh		; End-of-heap flag
 19024                                  ;_HEAP_COALESCE	equ	0FFFEh		; Coalesce segment value
 19025                                  ;_HEAP_GROWSEG	equ	2000h		; Default heap seg growth increment (8K)
 19026                                  ;;_HEAP_MAXREQ	equ	0FFFCh - (_heap_seg_desc.size)	; Max heap request size
 19027                                  ;_HEAP_MAXREQ	equ	0FFFCh - 14h ; 0FFE8h
 19028                                  ;;_HEAP_MINSEG	equ	((_heap_seg_desc.size) + 4) ; Min size heap segment
 19029                                  ;_HEAP_MINSEG	equ	20+4		; Min size heap segment
 19030                                  
 19031                                  ; GROWSEG.ASM - Microsoft Visual C++ 1.0 Run-Time Library Sources
 19032                                  ; ----------------------------------------------------------------------------
 19033                                  
 19034                                  ;***
 19035                                  ; _growseg - Grow a heap segment
 19036                                  ;
 19037                                  ;Purpose:
 19038                                  ;	Grow a heap segment to increase the amount of space
 19039                                  ;	available for allocations.
 19040                                  ;
 19041                                  ;	Notes:
 19042                                  ;	(1) The caller has already determined that the block size cannot
 19043                                  ;	be allocated in the current heap and heap segment growth is necessary.
 19044                                  ;	(2) The size argument is the block allocation size requested
 19045                                  ;	by the user.  The supplied size is NOT the heap increment.
 19046                                  ;	(that size is determined by this routine).
 19047                                  ;
 19048                                  ;Entry:
 19049                                  ;	ds:bx = heap segment descriptor
 19050                                  ;	cx = size of block requested
 19051                                  ;
 19052                                  ;Exit:
 19053                                  ;	Success:
 19054                                  ;		carry = clear
 19055                                  ;	Failure:
 19056                                  ;		carry = set
 19057                                  ;
 19058                                  ;Uses:
 19059                                  ;	es
 19060                                  ;
 19061                                  ;Preserves:
 19062                                  ;	cx, di
 19063                                  ;
 19064                                  ;*******************************************************************************
 19065                                  
 19066                                  ; 14/12/2018 (no need to _growseg for FDISK2.COM)
 19067                                  
 19068                                  ;_growseg:
 19069                                  ;		push	cx		; save caller's cx
 19070                                  ;		push	di		; save caller's di
 19071                                  
 19072                                  ; First, see if it is legal to grow this segment.
 19073                                  ; ds:bx = heap descriptor
 19074                                  
 19075                                  ;		;test	byte ptr [bx].flags,_HEAP_MODIFY
 19076                                  ;		test	byte [bx+2],1
 19077                                  ;		jz	short grow_error_rtn ; return error if modify bit clear
 19078                                  
 19079                                  ; Calculate how much we need to grow the segment by to satisfy the user's
 19080                                  ; request.
 19081                                  ; cx = size of block requested
 19082                                  
 19083                                  ;		call	_findlast	; si = pointer to last heap entry
 19084                                  ;		mov	di,si		; save pointer in di for later use
 19085                                  ;		mov	ax,[si] 	; length of last entry
 19086                                  ;		test	al,1		; is it free ??
 19087                                  ;		jz	short grow_calc_length ; no
 19088                                  ;		sub	cx,ax		; reduce requested length by free size
 19089                                  ;		dec	cx		; adjust for inc' below (only one dec
 19090                                  ;					; because free bit is set...)
 19091                                  ;grow_calc_length:
 19092                                  ;		inc	cx
 19093                                  ;		inc	cx		; add header field to size
 19094                                  ;
 19095                                  ;		;mov	si,[bx].segsize ; si = current size of segment
 19096                                  ;		mov     si,[bx+4]
 19097                                  ;		or	si,si		; already 64 Kb ??
 19098                                  ;		jz	short grow_error_rtn ; yep, go return an error
 19099                                  ;		add	cx,si		; cx = desired new size of segment
 19100                                  ;					; (not yet rounded by _amblksiz)
 19101                                  ;		jnc	short grow_size_ok ; legal segment size
 19102                                  
 19103                                  ; Special code to handle case of cx = 0 (i.e., requested new segment size is
 19104                                  ; exactly 64 K). This amounts to taking a shortcut to calling _incseg.
 19105                                  
 19106                                  ;		xor	ax,ax		; set newsize request to 64 Kb
 19107                                  ;		mov	dx,0FFF0h	; indicate paragraph increment
 19108                                  ;		jcxz	grow3		; shortcut!
 19109                                  ;		jmp	short grow_error_rtn
 19110                                  
 19111                                  ;	; Determine the optimal heap increment size.
 19112                                  ;grow_size_ok:
 19113                                  ;		push	ss		; es = DGROUP
 19114                                  ;		pop	es
 19115                                  
 19116                                  ;		;mov	ax,[es:_amblksiz] ; get increment size
 19117                                  ;	;;*** OPTIMIZATION: CODE WILL WORK WITHOUT THE FOLLOWING 2 INSTRUCTIONS
 19118                                  ;		;;cmp	ax,_HEAP_GROWSEG ; compare to default increment
 19119                                  ;		;cmp     ax,2000h
 19120                                  ;		;je	short grow1	; if equal, use the default
 19121                                  ;		;;fall thru
 19122                                  ;
 19123                                  ;		mov	ax,2000h ; 09/12/2018
 19124                                  
 19125                                  ; Compute the heap segment increment size.
 19126                                  ; That is, 2**N, where 2**N >= _amblksiz > 2**(N-1).
 19127                                  ; Test the values 2**(N-1), in descending order, until one is found that
 19128                                  ; is less than _amblksiz.  Then, shift the value left to get 2**N.
 19129                                  ; ax = _amblksiz
 19130                                  
 19131                                  ;		mov	dx,8000h	; start by testing 2**15
 19132                                  ;grow_next_size:
 19133                                  ;		cmp	dx,ax		; is current 2**(N-1) smaller?
 19134                                  ;		jb	short grow0	;  yep, dx = 2**(N-1)
 19135                                  ;		shr	dx,1		; di = next lower power of 2
 19136                                  ;		jnz	short grow_next_size ; try again...
 19137                                  ;		jmp	short grow_paragraph ; use increment size = paragraph
 19138                                  
 19139                                  ; --- grow ---
 19140                                  ; Try to grow the segment.
 19141                                  ;  (1) First, try to grow the segment by the optimal size
 19142                                  ;      (rounded up to an _amblksiz boundary).
 19143                                  ;  (2) If that fails, try to grow by just enough to fullfill the request
 19144                                  ;      (rounded up to a paragraph boundary).
 19145                                  ;
 19146                                  ;  [NOTE: We will try to grow the segment twice AT MOST.]
 19147                                  ;
 19148                                  ; cx = grow size necessary to fulfill caller's request
 19149                                  ; si = current size of heap segment
 19150                                  ; dx = 2**(N-1)
 19151                                  
 19152                                  ;;grow0:
 19153                                  ;;		cmp	dx,08h			; will increment be < paragraph ??
 19154                                  ;;		jb	short grow_paragraph	; yes, use paragraph increment
 19155                                  ;;		shl	dx,1			; dx = 2**N (if 0, that's ok)
 19156                                  ;;		mov	ax,dx			; ax = (power of 2)
 19157                                  ;;
 19158                                  
 19159                                  ;		; ax = heap seg increment size
 19160                                  ;grow1:
 19161                                  ;		dec	ax			; ax = (power of 2) - 1
 19162                                  ;		mov	dx,ax			; save for later
 19163                                  ;		add	ax,cx			; round up to next highest multiple
 19164                                  ;						; of (power of 2)
 19165                                  ;		jnc	short grow2		; overflow ??
 19166                                  ;		xor	ax,ax			; yes, grow to max seg size (0 = 64kb)
 19167                                  ;grow2:
 19168                                  ;		not	dx			; make ((power of 2) - 1) a mask
 19169                                  ;		and	ax,dx			; ax is now rounded up
 19170                                  ;grow3:
 19171                                  ;		push	dx			; save increment mask
 19172                                  ;		call	_incseg 		; *** try to grow the segment ***
 19173                                  ;		pop	dx			; restore increment mask
 19174                                  ;		jnc	short grow_good_rtn	; Good return on success
 19175                                  ;
 19176                                  ;		cmp	dx,0FFF0h		; error, was increment == paragraph ??
 19177                                  ;		je	short grow_error_rtn	; yes, no more we can do (return error)
 19178                                  ;
 19179                                  ;grow_paragraph:				; try an increment size of a paragraph
 19180                                  ;		mov	ax,10h			; ax = paragraph size
 19181                                  ;		jmp	short grow1		; try again
 19182                                  
 19183                                  ;  --- Error Return ---
 19184                                  
 19185                                  ;grow_error_rtn:
 19186                                  ;		stc				; carry set = error
 19187                                  ;		jmp	short grow_done		; return the error
 19188                                  
 19189                                  ; --- Good Return ---
 19190                                  ;
 19191                                  ; We successfully grew the heap segment.
 19192                                  ; Link the new free block into the heap and update pointers, _HEAP_END, etc.
 19193                                  ; ax = new segment size
 19194                                  ; ds:bx = heap descriptor
 19195                                  ; di = pointer to previous last heap entry
 19196                                  
 19197                                  ;grow_good_rtn:
 19198                                  ;		mov	dx,ax			; dx = new size
 19199                                  ;		;sub	dx,[bx].segsize 	; dx = segment increment
 19200                                  ;		sub	dx,[bx+4]
 19201                                  ;		;mov	[bx].segsize,ax 	; update segment size field
 19202                                  ;		mov     [bx+4],ax
 19203                                  ;
 19204                                  ;		;mov	[bx].rover,di		; rover = previous last entry (in di)
 19205                                  ;		mov	[bx+8],di
 19206                                  ;
 19207                                  ;		;mov	si,[bx].last		; si = pointer to old _HEAP_END
 19208                                  ;		mov	si,[bx+10]
 19209                                  ;		dec	dx			; dx = length of block marked free
 19210                                  ;		mov	[si],dx 		; put length of new block in heap
 19211                                  ;
 19212                                  ;		inc	dx			; dx = length of new block + header
 19213                                  ;		add	si,dx			; si = points to new end of heap
 19214                                  ;		;mov	[si],_HEAP_END		; mark new end of heap
 19215                                  ;		mov     word [si],0FFFEh
 19216                                  ;		;mov	[bx].last,si		; update .last pointer
 19217                                  ;		mov	[bx+10],si
 19218                                  ;	
 19219                                  ;	;fall thru (not that the carry flag was cleared by the add above!)
 19220                                  
 19221                                  ; Common Return
 19222                                  ; ax = return value
 19223                                  
 19224                                  ;grow_done:
 19225                                  ;		pop	di			; restore caller's di
 19226                                  ;		pop	cx			; restore caller's cx
 19227                                  ;		retn
 19228                                  
 19229                                  ; _incseg - Increment the segment
 19230                                  ;
 19231                                  ;Purpose:
 19232                                  ;	This routine issues the OS call that actually grows/shrinks the
 19233                                  ;	heap segment.
 19234                                  ;
 19235                                  ;	NOTE: This routine is meant for internal use only.
 19236                                  ;
 19237                                  ;	DOS NOTE: The 'segsize' value in the near heap descriptor
 19238                                  ;	indicates the top of the heap, NOT the current size of DGROUP.
 19239                                  ;	Thus, we must check the REAL size of DGROUP to see if we
 19240                                  ;	really need to grow the heap (_asizds).   Also, growing
 19241                                  ;	the near heap must be based on the _psp segment, not DGROUP
 19242                                  ;
 19243                                  ;ifdef	_WINDOWS
 19244                                  ;	WINDOWS NOTE:  Do to a Windows restriction/bug, you should not
 19245                                  ;	grow a segment to exactly 64K in standard mode.
 19246                                  ;endif
 19247                                  ;
 19248                                  ;Entry:
 19249                                  ;	ax = new segment size (0 indicates a segment size of 64 Kb)
 19250                                  ;	     [***NOTE***: This value MUST be rounded up to a paragraph
 19251                                  ;	     boundary by the caller.]
 19252                                  ;	ds:bx = heap descriptor
 19253                                  ;Exit:
 19254                                  ;	Success:
 19255                                  ;		carry = clear
 19256                                  ;		ax = new segment size (0 indicates a segment size of 64 Kb)
 19257                                  ;	Failure:
 19258                                  ;		carry = set
 19259                                  ;
 19260                                  ;Preserves:
 19261                                  ;	ds:bx, cx, di
 19262                                  ;
 19263                                  ;Uses:
 19264                                  ;	ax, dx, si, es
 19265                                  ;
 19266                                  ;Exceptions:
 19267                                  ;
 19268                                  ;*******************************************************************************
 19269                                  
 19270                                  ;_incseg:
 19271                                  ;		mov	dx,ax		; save requested size
 19272                                  ;
 19273                                  ;; --- Special near heap code ---
 19274                                  ;;
 19275                                  ;; Growing:  We don't have to issue a call if there's room between heap and
 19276                                  ;; _asizds.
 19277                                  ;;
 19278                                  ;; Shrinking:  If the new size is less than the current size, issue the call to
 19279                                  ;; shrink the segment.  Also, if the new size is EQUAL to the current size,
 19280                                  ;; issue the call since we want to free up unused DGROUP above the heap but
 19281                                  ;; below _asizds.  [Note: _Minseg() has already determined that an OS call is
 19282                                  ;; necessary in this case.]
 19283                                  ;
 19284                                  ;		;test	byte ptr [bx].flags,_HEAP_NEAR ; near heap descriptor ?
 19285                                  ;		test	byte [bx+2],4
 19286                                  ;		jz	short do_oscall1 ; nope
 19287                                  ;
 19288                                  ;		dec	dx		; dx = new segsize - 1
 19289                                  ;		;mov	si,[bx].segsize ; get current segment size
 19290                                  ;		mov	si, [bx+4]
 19291                                  ;		dec	si		; cx = current segsize - 1
 19292                                  ;		cmp	dx,si		; are we shrinking the segment ??
 19293                                  ;		jbe	short do_oscall	; yes, issue the system call
 19294                                  ;
 19295                                  ;		cmp	[bx-2],dx	; _asizds > current segsize ??
 19296                                  ;		jae	short incseg_ok	; yup, no need to issue system call
 19297                                  ;do_oscall:
 19298                                  ;		inc	dx			; nope, restore dx
 19299                                  ;
 19300                                  ;; Issue the system call
 19301                                  ;; ax = dx = desired size
 19302                                  
 19303                                  ;do_oscall1:
 19304                                  ;		push	bx		; save heap descriptor
 19305                                  ;		push	cx		; save cx value
 19306                                  ;		mov	si,ds		; es = si = heap segment
 19307                                  ;		mov	es,si
 19308                                  ;		mov	cl,4		; cl = shift count
 19309                                  ;		shr	ax,cl		; ax = paragraph count
 19310                                  ;		jnz	short do_oscall2 ; if ax != 0, use it
 19311                                  ;		mov	ax,1000h	; if ax == 0, set it to 1000h
 19312                                  ;					; paragraphs (i.e., 64 KB)
 19313                                  ;do_oscall2:
 19314                                  ;		;test	byte ptr [bx].flags,_HEAP_NEAR ; near heap descriptor ?
 19315                                  ;		test    byte [bx+2],4
 19316                                  ;		jz	short do_oscall3 ; nope, issue the system call
 19317                                  ;
 19318                                  ;		; use _psp segment, not DGROUP
 19319                                  ;		add	ax,si		; yes, add in DGROUP seg
 19320                                  ;		mov	bx,[_psp]	; PSP base
 19321                                  ;		sub	ax,bx		; subtract PSP base
 19322                                  ;		mov	es,bx		; es = PSP base
 19323                                  ;do_oscall3:				; ax = new size (para) / es = heap seg
 19324                                  ;		mov	bx,ax		; bx = new segment size (para)
 19325                                  ;		;callos	setmem		; set the heap segment size
 19326                                  ;
 19327                                  ;		mov	ah,4Ah
 19328                                  ;		int	21h	; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
 19329                                  ;				; ES = segment address of block to change
 19330                                  ;				; BX = new size in paragraphs
 19331                                  ;		pop	cx		; restore cx
 19332                                  ;		pop	bx		; restore heap descriptor
 19333                                  ;		jc	short incseg_done ; error - carry is set
 19334                                  ;		;fall thru
 19335                                  ;
 19336                                  ;; --- Good return ---
 19337                                  ;
 19338                                  ;		mov	ax,dx			; return size
 19339                                  ;		;test	byte ptr [bx].flags,_HEAP_NEAR ; near heap descriptor ?
 19340                                  ;		test	byte [bx+2],4
 19341                                  ;		jz	short incseg_ok	; nope, return
 19342                                  ;
 19343                                  ;		; Near heap so update _asizds.
 19344                                  ;		; Use offset from _nheap_desc so DLL will work
 19345                                  ;		dec	dx			; dx = dgroup - 1
 19346                                  ;		mov	[bx-2],dx		; update _asizds
 19347                                  ;incseg_ok:				; ax = new seg size
 19348                                  ;		clc				; carry clear on success
 19349                                  ;		jmp	short incseg_done	; common return
 19350                                  ;
 19351                                  ;; --- Error return ---
 19352                                  ;
 19353                                  ;incseg_err:
 19354                                  ;		;stc				; carry set on error
 19355                                  ;
 19356                                  ;; --- Common return ---
 19357                                  ;
 19358                                  ;incseg_done:
 19359                                  ;		retn
 19360                                  
 19361                                  ;***
 19362                                  ; _findlast - Find the last entry in a heap descriptor segment
 19363                                  ;
 19364                                  ;Purpose:
 19365                                  ;	Given a heap descriptor, return a pointer to the last
 19366                                  ;	entry in that heap segment.
 19367                                  ;
 19368                                  ;Entry:
 19369                                  ;	ds:bx = heap segment descriptor
 19370                                  ;
 19371                                  ;Exit:
 19372                                  ;	si = pointer to header of last entry in that segment
 19373                                  ;
 19374                                  ;Uses:
 19375                                  ;	ax
 19376                                  ;
 19377                                  ;Preserves:
 19378                                  ;	bx, cx, dx, di, ds, es
 19379                                  ;
 19380                                  ;Exceptions:
 19381                                  ;
 19382                                  ;*******************************************************************************
 19383                                  
 19384                                  ; 14/12/2018 (no need to _findlast for FDISK2.COM)
 19385                                  
 19386                                  ;_findlast:
 19387                                  ;		push	di		; save caller's di
 19388                                  ;
 19389                                  ;		;mov	si,[bx].rover	; si = rover pointer
 19390                                  ;		mov	si,[bx+8]
 19391                                  ;		;cmp	si,[bx].last	; does .rover = .last?
 19392                                  ;		cmp	si,[bx+10]
 19393                                  ;		jne	short lastloop	; no, go begin search
 19394                                  ;		;mov	si,[bx].start	; yes, must begin search at .start
 19395                                  ;		mov	si,[bx+6]
 19396                                  ;lastloop:
 19397                                  ;		lodsw			; ax = size of heap entry
 19398                                  ;		;cmp	ax,_HEAP_END	; end of heap ?
 19399                                  ;		cmp     ax,0FFFEh
 19400                                  ;		je	short lastdone	; yup, finish up
 19401                                  ;		mov	di,si		; save current pointer
 19402                                  ;		;and	al,not 1	; nope, mask off free/use bit
 19403                                  ;		and	al,0FEh
 19404                                  ;		add	si,ax		; si = pointer to next entry
 19405                                  ;		;jc	heaptoast	; *** error, heap is toasty... ***
 19406                                  ;		jmp	short lastloop	; try next one
 19407                                  ;lastdone:				; found the end
 19408                                  ;		dec	di
 19409                                  ;		dec	di		; back up saved pointer to header
 19410                                  ;		mov	si,di		; si = pointer to last heap entry header
 19411                                  ;
 19412                                  ;		pop	di		; restore caller's di
 19413                                  ;		retn
 19414                                  
 19415                                  ; ----------------------------------------------------------------------------
 19416                                  ; input.c (FDISK, MSDOS 6.0, 1991)	
 19417                                  ; ----------------------------------------------------------------------------
 19418                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 09/12/2018)
 19419                                  
 19420                                  ;char get_num_input(input_default,max_num,row,col)
 19421                                  ;
 19422                                  ;char      max_num;
 19423                                  ;unsigned  row;
 19424                                  ;unsigned  col;
 19425                                  ;char	   input_default;
 19426                                  ;
 19427                                  ;BEGIN
 19428                                  ;
 19429                                  ;    char  input;
 19430                                  ;
 19431                                  ;    /* SR;9/25/89; Initialize this on entry */
 19432                                  ;    char  default_used = FALSE;
 19433                                  ;    char  input_value;
 19434                                  ;
 19435                                  ;    char            attribute;
 19436                                  ;    char far        *attribute_ptr = &attribute;
 19437                                  ;    char far *input_ptr = &input;
 19438                                  ;
 19439                                  ;    if (mono_flag == TRUE)
 19440                                  ;       attribute = HIWHITE_ON_BLACK; /*C09*/
 19441                                  ;    else
 19442                                  ;       attribute = HIWHITE_ON_BLUE;  /*C09*/
 19443                                  ;
 19444                                  ;    /* print default entry if there is one */
 19445                                  ;    if (input_default != c(NUL))                                 /* AC000 */
 19446                                  ;
 19447                                  ;       BEGIN
 19448                                  ;        default_used = TRUE;
 19449                                  ;        /* position the cursor */
 19450                                  ;        VIOSETCURPOS(row,col,u(0));                              /* AC000 */
 19451                                  ;
 19452                                  ;        /* Display the default character */
 19453                                  ;
 19454                                  ;        input = c(input_default+'0');
 19455                                  ;        VIOWRTCHARSTRATT(input_ptr,u(1),row,col,attribute_ptr,u(0));
 19456                                  ;       END
 19457                                  ;
 19458                                  ;    /* Assume bad input */
 19459                                  ;    valid_input = FALSE;
 19460                                  ;
 19461                                  ;    /* Loop until we get good stuff */
 19462                                  ;    while (valid_input == FALSE)
 19463                                  ;        BEGIN
 19464                                  ;
 19465                                  ;        /* position the cursor */
 19466                                  ;        VIOSETCURPOS(row,col,u(0));                             /* AC000 */
 19467                                  ;
 19468                                  ;        /* Flush the keyboard buffer and get the next pressed key */
 19469                                  ;        input = get_char_input();
 19470                                  ;
 19471                                  ;        /* Do world trade get country information */
 19472                                  ;        input = dos_upper(input);                          /* AN000 */
 19473                                  ;
 19474                                  ;        /* Go handle different inputs */
 19475                                  ;        switch(input)
 19476                                  ;           BEGIN
 19477                                  ;            case ESC:
 19478                                  ;                BEGIN
 19479                                  ;                 valid_input = TRUE;
 19480                                  ;                 break;
 19481                                  ;                END
 19482                                  ;
 19483                                  ;            case CR:
 19484                                  ;                BEGIN
 19485                                  ;                /* Set the input to the default if there is one there */
 19486                                  ;                if (default_used)
 19487                                  ;                    BEGIN
 19488                                  ;                     if (input_default != c(NUL))
 19489                                  ;                        BEGIN
 19490                                  ;                         input_value = input_default+'0';
 19491                                  ;                        END
 19492                                  ;                     else
 19493                                  ;                        BEGIN
 19494                                  ;                         /* Make the enter look like a blank for error message */
 19495                                  ;                         input_value = c(' ');                 /* AC000 */
 19496                                  ;                        END
 19497                                  ;                    END
 19498                                  ;                /* See if it is digit and less or equal to max */
 19499                                  ;                if ( (isdigit(input_value))         &&
 19500                                  ;                     (input_value <= (max_num+'0')) &&
 19501                                  ;                     (input_value != c('0')) )
 19502                                  ;                    BEGIN
 19503                                  ;                     valid_input = TRUE;
 19504                                  ;                     input = input_value;
 19505                                  ;                    END
 19506                                  ;                else
 19507                                  ;                    BEGIN
 19508                                  ;                    if (isdigit(input_value))
 19509                                  ;                       BEGIN
 19510                                  ;                        /* Setup error message */
 19511                                  ;                        insert[0] = input_value;
 19512                                  ;                        insert[1] = c('1');                    /* AC000 */
 19513                                  ;                        insert[2] = c('-');                    /* AC000 */
 19514                                  ;                        insert[3] = max_num+'0';
 19515                                  ;                        display(error_23);
 19516                                  ;                       END
 19517                                  ;                    else
 19518                                  ;                       BEGIN
 19519                                  ;                        insert[0] = c('1');                    /* AC000 */
 19520                                  ;                        insert[1] = c('-');                    /* AC000 */
 19521                                  ;                        insert[2] = max_num+'0';
 19522                                  ;                        display(error_31);
 19523                                  ;                       END
 19524                                  ;                    END
 19525                                  ;                break;
 19526                                  ;                END
 19527                                  ;
 19528                                  ;            default:
 19529                                  ;               BEGIN
 19530                                  ;                /* SR; 10/2/89; If Ctrl-C, display blank and beep */
 19531                                  ;                if ( (isdigit(input))         &&                        /*C16*/
 19532                                  ;                     (input <= (max_num+'0')) &&                        /*C16*/
 19533                                  ;                     (input != c('0')) )                                /*C16*/
 19534                                  ;                    clear_screen(u(23),u(0),u(23),u(79));               /*C16*/
 19535                                  ;                else                                                    /*C16*/
 19536                                  ;                    {                                                   /*C16*/
 19537                                  ;                    if (isdigit(input))                                 /*C16*/
 19538                                  ;                        {                                               /*C16*/
 19539                                  ;                        /* Setup error message */                       /*C16*/
 19540                                  ;                        insert[0] = input;                              /*C16*/
 19541                                  ;                        insert[1] = c('1');                             /*C16*/
 19542                                  ;                        insert[2] = c('-');                             /*C16*/
 19543                                  ;                        insert[3] = max_num+'0';                        /*C16*/
 19544                                  ;                        display(error_23);                              /*C16*/
 19545                                  ;                        }                                               /*C16*/
 19546                                  ;                    else                                                /*C16*/
 19547                                  ;                        {                                               /*C16*/
 19548                                  ;                        insert[0] = c('1');                             /*C16*/
 19549                                  ;                        insert[1] = c('-');                             /*C16*/
 19550                                  ;                        insert[2] = max_num+'0';                        /*C16*/
 19551                                  ;                        display(error_31);                              /*C16*/
 19552                                  ;                        }                                               /*C16*/
 19553                                  ;                    input = c(' ');                                     /*C16*/
 19554                                  ;                    }                                                   /*C16*/
 19555                                  ;                VIOWRTCHARSTRATT(input_ptr,u(1),row,col,attribute_ptr,u(0)); /*C16*/
 19556                                  ;                default_used = FALSE;
 19557                                  ;                input_value = input;
 19558                                  ;                break;
 19559                                  ;                END
 19560                                  ;            END
 19561                                  ;        END
 19562                                  ;     return(input);
 19563                                  ;END
 19564                                  
 19565                                  get_num_input:
 19566                                  	;char get_num_input(input_default,max_num,row,col)
 19567                                  
 19568                                  	%define input_value	bp-16
 19569                                  	%define gni_attr_ptr	bp-14
 19570                                  	;%define gni_attr_ptr_2 bp-12
 19571                                  	%define default_used	bp-10
 19572                                  	%define gni_input_ptr	bp-8
 19573                                  	;%define gni_input_ptr_2 bp-6
 19574                                  	%define gni_attribute	bp-4
 19575                                  	%define gni_input	bp-2
 19576                                  
 19577                                  	%define input_default	bp+4
 19578                                  	%define gni_max_num	bp+6
 19579                                  	%define gni_row		bp+8
 19580                                  	%define gni_column	bp+10
 19581                                  
 19582 00002A74 55                      		push	bp
 19583 00002A75 89E5                    		mov	bp,sp
 19584 00002A77 83EC10                  		sub	sp,16
 19585                                  
 19586                                  		;/* Initialize this on entry */
 19587 00002A7A C646F600                		mov	byte [default_used],0
 19588                                  		
 19589 00002A7E 8D46FC                  		lea	ax,[gni_attribute]
 19590 00002A81 8946F2                  		mov	[gni_attr_ptr],ax
 19591                                  		;mov	[gni_attr_ptr_2],ss
 19592 00002A84 8C56F4                  		mov	[gni_attr_ptr+2],ss
 19593 00002A87 8D4EFE                  		lea	cx,[gni_input]
 19594 00002A8A 894EF8                  		mov	[gni_input_ptr],cx
 19595                                  		;mov	[gni_input_ptr_2],ss
 19596 00002A8D 8C56FA                  		mov	[gni_input_ptr+2],ss
 19597                                  
 19598                                  		;if (mono_flag == TRUE)
 19599                                  		;       attribute = HIWHITE_ON_BLACK;
 19600                                  		;    else
 19601                                  		;       attribute = HIWHITE_ON_BLUE;
 19602                                  
 19603 00002A90 803E[D8C3]01            		cmp	byte [mono_flag],1
 19604 00002A95 7506                    		jnz	short gni_1
 19605 00002A97 C646FC0F                		mov	byte [gni_attribute],0Fh ; HIWHITE_ON_BLACK
 19606 00002A9B EB04                    		jmp	short gni_2
 19607                                  gni_1:
 19608 00002A9D C646FC1F                		mov	byte [gni_attribute],1Fh ; HIWHITE_ON_BLUE
 19609                                  gni_2:
 19610                                  		;/* print default entry if there is one */
 19611                                  		;if (input_default != c(NUL))  
 19612                                  
 19613 00002AA1 807E0400                		cmp	byte [input_default],0
 19614 00002AA5 742E                    		je	short gni_3
 19615 00002AA7 C646F601                		mov	byte [default_used],1
 19616                                  
 19617                                  		;/* position the cursor */
 19618                                  		;VIOSETCURPOS(row,col,u(0));   
 19619                                  
 19620                                  		;push	word [gni_row]
 19621                                  		;push	word [gni_column]
 19622                                  		;sub	ax,ax ; 0
 19623                                  		;push	ax
 19624                                  		; 09/12/2018
 19625 00002AAB 8A7608                  		mov	dh,[gni_row]
 19626 00002AAE 8A560A                  		mov	dl,[gni_column]
 19627 00002AB1 E86C01                  		call	VIOSETCURPOS
 19628                                  
 19629                                  		;/* Display the default character */
 19630                                  		;input = c(input_default+'0');
 19631                                  		;VIOWRTCHARSTRATT(input_ptr,u(1),row,col,attribute_ptr,u(0));
 19632                                  
 19633 00002AB4 8A4604                  		mov	al,[input_default]
 19634 00002AB7 0430                    		add	al,'0'
 19635 00002AB9 8846FE                  		mov	[gni_input],al
 19636                                  		;push	word [gni_input_ptr_2]
 19637 00002ABC FF76FA                  		push	word [gni_input_ptr+2]
 19638 00002ABF FF76F8                  		push	word [gni_input_ptr]
 19639 00002AC2 B80100                  		mov	ax,1
 19640 00002AC5 50                      		push	ax
 19641 00002AC6 FF7608                  		push	word [gni_row]
 19642 00002AC9 FF760A                  		push	word [gni_column]
 19643                                  		;push	word [gni_attr_ptr_2]
 19644 00002ACC FF76F4                  		push	word [gni_attr_ptr+2]
 19645 00002ACF FF76F2                  		push	word [gni_attr_ptr]
 19646                                  		; 09/12/2018
 19647                                  		;sub	ax,ax ; 0
 19648                                  		;push	ax
 19649 00002AD2 E80EEE                  		call	VIOWRTCHARSTRATT
 19650                                  gni_3:
 19651                                  		;/* Assume bad input */
 19652                                  		; 15/12/2018
 19653 00002AD5 C606[ECCB]00            		mov	byte [valid_input],0
 19654                                  gni_4:
 19655                                  		;/* Loop until we get good stuff */
 19656                                  		;while (valid_input == FALSE)
 19657                                  
 19658                                  		;/* position the cursor */
 19659                                  		;VIOSETCURPOS(row,col,u(0)); 
 19660                                  
 19661                                  		;push	word [gni_row]
 19662                                  		;push	word [gni_column]
 19663                                  		;sub	ax,ax ; 0
 19664                                  		;push	ax
 19665                                  		; 09/12/2018
 19666 00002ADA 8A7608                  		mov	dh,[gni_row]
 19667 00002ADD 8A560A                  		mov	dl,[gni_column]
 19668 00002AE0 E83D01                  		call	VIOSETCURPOS
 19669                                  
 19670                                  		;/* Flush the keyboard buffer and get the next pressed key */
 19671                                  		;input = get_char_input();
 19672                                  	
 19673 00002AE3 E82D01                  		call	get_char_input
 19674                                  		;mov	[gni_input],al
 19675                                  	
 19676                                  		;/* Do world trade get country information */
 19677                                  		;input = dos_upper(input);
 19678                                  		; 15/12/2018                      
 19679                                  		;push	ax
 19680 00002AE6 E84F01                  		call	dos_upper
 19681                                  		;pop	bx
 19682 00002AE9 8846FE                  		mov	[gni_input],al
 19683                                  switch_gni_input:
 19684                                  		;/* Go handle different inputs */	
 19685                                  		;switch(input)
 19686                                  		
 19687                                  		;cbw
 19688                                  		;sub	ax,0Dh  ; CR ?
 19689 00002AEC 2C0D                    		sub	al,0Dh
 19690 00002AEE 743F                    		jz	short case_gni_CR  ; yes
 19691                                  		;sub	ax,0Eh  ; 0Dh+0Eh = 1Bh  ; ESC ? 
 19692 00002AF0 2C0E                    		sub	al,0Eh
 19693 00002AF2 7433                    		jz	short case_gni_ESC ; yes
 19694                                  
 19695                                  		; /* If Ctrl-C, display blank and beep */
 19696                                  		; if ((isdigit(input))  
 19697                                  
 19698                                  		; 02/01/2019
 19699                                  		;mov	al,[gni_input]
 19700                                  		;cbw
 19701                                  		;mov	bx,ax
 19702 00002AF4 30FF                    		xor	bh,bh
 19703 00002AF6 8A5EFE                  		mov	bl,[gni_input]
 19704 00002AF9 F687[0A9F]04            		test	byte [isdigit+bx],4
 19705                                  		;jz	short gni_not_digit
 19706 00002AFE 0F84C400                		jz	gni_12 ; 02/01/2019
 19707 00002B02 8A4606                  		mov	al,[gni_max_num]
 19708 00002B05 98                      		cbw
 19709 00002B06 83C030                  		add	ax,'0'
 19710 00002B09 39D8                    		cmp	ax,bx
 19711 00002B0B 7C05                    		jl	short gni_not_digit
 19712                                  		;cmp	byte [gni_input],'0'
 19713 00002B0D 80FB30                  		cmp	bl,'0' ; 02/01/2019
 19714 00002B10 7503                    		jne	short gni_5
 19715                                  gni_not_digit:
 19716 00002B12 E99400                  		jmp	gni_11
 19717                                  gni_5:
 19718 00002B15 B84F00                  		mov	ax,79
 19719 00002B18 50                      		push	ax
 19720 00002B19 B81700                  		mov	ax,23
 19721 00002B1C 50                      		push	ax
 19722 00002B1D 29C9                    		sub	cx,cx
 19723 00002B1F 51                      		push	cx
 19724 00002B20 50                      		push	ax
 19725 00002B21 E872E9                  		call	clear_screen
 19726                                  		;add	sp,8
 19727 00002B24 E9BD00                  		jmp	gni_14
 19728                                  case_gni_ESC:
 19729 00002B27 C606[ECCB]01            		mov	byte [valid_input],1
 19730                                  		;jmp	case_gni_break
 19731 00002B2C E9DB00                  		jmp	gni_15 ; 15/12/2018
 19732                                  case_gni_CR:
 19733                                  		;/* Set the input to the default if there is one there */
 19734                                                  ;if (default_used)
 19735                                  		
 19736 00002B2F 807EF600                		cmp	byte [default_used],0
 19737 00002B33 7414                    		je	short gni_7
 19738                                  
 19739                                  		;if (input_default != c(NUL))
 19740                                  
 19741 00002B35 807E0400                		cmp	byte [input_default],0
 19742 00002B39 740A                    		je	short gni_6
 19743                                  
 19744                                  		;input_value = input_default+'0';
 19745 00002B3B 8A4604                  		mov	al,[input_default]
 19746 00002B3E 0430                    		add	al,'0'
 19747 00002B40 8846F0                  		mov	[input_value],al
 19748 00002B43 EB04                    		jmp	short gni_7
 19749                                  gni_6:
 19750                                  		;/* Make the enter look like a blank for error message */
 19751                                  		;input_value = c(' '); 
 19752 00002B45 C646F020                		mov	byte [input_value],' '
 19753                                  gni_7:
 19754                                  		;/* See if it is digit and less or equal to max */
 19755                                                  ;if ( (isdigit(input_value))         &&
 19756                                                  ;     (input_value <= (max_num+'0')) &&
 19757                                                  ;     (input_value != c('0')) )
 19758                                  
 19759                                  		; 02/01/2019
 19760                                  		;mov	al,[input_value]
 19761                                  		;cbw
 19762                                  		;mov	bx,ax
 19763 00002B49 28FF                    		sub	bh,bh
 19764 00002B4B 8A5EF0                  		mov	bl,[input_value]
 19765 00002B4E F687[0A9F]04            		test	byte [isdigit+bx],4
 19766                                  		;jz	short gni_8
 19767 00002B53 7437                    		jz	short gni_9
 19768                                  
 19769 00002B55 8A4606                  		mov	al,[gni_max_num]
 19770 00002B58 98                      		cbw
 19771 00002B59 83C030                  		add	ax,'0'
 19772 00002B5C 39D8                    		cmp	ax,bx
 19773 00002B5E 7C0F                    		jl	short gni_8
 19774                                  		;cmp	byte [input_value],'0'
 19775 00002B60 80FB30                  		cmp	bl,'0' ; 02/01/2019
 19776 00002B63 740A                    		je	short gni_8
 19777                                  
 19778                                  		;valid_input = TRUE;
 19779                                  		;input = input_value;
 19780                                  
 19781 00002B65 C606[ECCB]01            		mov	byte [valid_input],1
 19782                                  		;mov	al,[input_value]
 19783 00002B6A 88D8                    		mov	al,bl ; 02/01/2019
 19784                                  		;mov	[gni_input],al
 19785                                  		;jmp	case_gni_break
 19786 00002B6C E99E00                  		jmp	gni_16 ; 15/12/2018
 19787                                  gni_8:
 19788                                  		;if (isdigit(input_value))
 19789                                  
 19790                                  		; 02/01/2019
 19791                                  		;mov	al,[input_value]
 19792                                  		;cbw
 19793                                  		;mov	bx,ax
 19794                                  		;test	byte [isdigit+bx],4
 19795                                  		;jz	short gni_9
 19796                                  
 19797                                  		;/* Setup error message */
 19798                                  		;insert[0] = input;
 19799                                  		;insert[1] = c('1');
 19800                                  		;insert[2] = c('-');
 19801                                  		;insert[3] = max_num+'0';
 19802                                  		;display(error_23);      
 19803                                  		
 19804                                  		;mov	[insert],al
 19805 00002B6F 881E[F4CC]              		mov	[insert],bl ; 02/01/2019
 19806 00002B73 C606[F5CC]31            		mov	byte [insert+1],'1'
 19807 00002B78 C606[F6CC]2D            		mov	byte [insert+2],'-'
 19808 00002B7D 8A4606                  		mov	al,[gni_max_num]
 19809 00002B80 0430                    		add	al,'0'
 19810 00002B82 A2[F7CC]                		mov	[insert+3],al
 19811                                  		;push	word [error_23_seg]
 19812 00002B85 1E                      		push	ds
 19813 00002B86 FF36[AC9E]              		push	word [error_23_off]
 19814 00002B8A EB17                    		jmp	short gni_10
 19815                                  gni_9:
 19816                                  		;else 
 19817                                  		 ;insert[0] = c('1');
 19818                                  		 ;insert[1] = c('-');
 19819                                  		 ;insert[2] = max_num+'0';
 19820                                  		 ;display(error_31);
 19821                                  		
 19822 00002B8C C606[F4CC]31            		mov	byte [insert],'1'
 19823 00002B91 C606[F5CC]2D            		mov	byte [insert+1],'-'
 19824 00002B96 8A4606                  		mov	al,[gni_max_num]
 19825 00002B99 0430                    		add	al,'0'
 19826 00002B9B A2[F6CC]                		mov	byte [insert+2],al
 19827                                  		;push	word [error_31_seg]
 19828 00002B9E 1E                      		push	ds
 19829 00002B9F FF36[BC9E]              		push	word [error_31_off]
 19830                                  gni_10:
 19831 00002BA3 E87EEA                  		call	display
 19832                                  		;pop	bx
 19833                                  		;pop	bx
 19834                                  		;jmp	short case_gni_break
 19835 00002BA6 E931FF                  		jmp	gni_4 ; 15/12/2018
 19836                                  gni_11:
 19837                                  		;else
 19838                                  		; insert[0] = c('1');
 19839                                  		; insert[1] = c('-');
 19840                                  		; insert[2] = max_num+'0';
 19841                                  		; display(error_31);
 19842                                  
 19843                                  		; 02/01/2019
 19844                                  		;mov	al,[gni_input]
 19845                                  		;cbw
 19846                                  		;mov	bx,ax
 19847                                  		;test	byte [isdigit+bx],4
 19848                                  		;jz	short gni_12
 19849                                  
 19850                                  		;mov	[insert],al
 19851 00002BA9 881E[F4CC]              		mov	[insert],bl ; 02/01/2019
 19852 00002BAD C606[F5CC]31            		mov	byte [insert+1],'1'
 19853 00002BB2 C606[F6CC]2D            		mov	byte [insert+2],'-'
 19854 00002BB7 8A4606                  		mov	al,[gni_max_num]
 19855 00002BBA 0430                    		add	al,'0'
 19856 00002BBC A2[F7CC]                		mov	[insert+3],al
 19857                                  		;push	word [error_23_seg]
 19858 00002BBF 1E                      		push	ds
 19859 00002BC0 FF36[AC9E]              		push	word [error_23_off]
 19860 00002BC4 EB17                    		jmp	short gni_13
 19861                                  gni_12:
 19862 00002BC6 C606[F4CC]31            		mov	byte [insert],'1'
 19863 00002BCB C606[F5CC]2D            		mov	byte [insert+1],'-'
 19864 00002BD0 8A4606                  		mov	al,[gni_max_num]
 19865 00002BD3 0430                    		add	al,'0'
 19866 00002BD5 A2[F6CC]                		mov	[insert+2],al
 19867                                  		;push	word [error_31_seg]
 19868 00002BD8 1E                      		push	ds
 19869 00002BD9 FF36[BC9E]              		push	word [error_31_off]
 19870                                  gni_13:
 19871 00002BDD E844EA                  		call	display
 19872                                  		;pop	bx
 19873                                  		;pop	bx
 19874                                  
 19875                                  		;input = c(' ');  
 19876 00002BE0 C646FE20                		mov	byte [gni_input],' '
 19877                                  gni_14:
 19878                                  		;push	word [gni_input_ptr_2]
 19879 00002BE4 FF76FA                  		push	word [gni_input_ptr+2]
 19880 00002BE7 FF76F8                  		push	word [gni_input_ptr]
 19881 00002BEA B80100                  		mov	ax,1
 19882 00002BED 50                      		push	ax
 19883 00002BEE FF7608                  		push	word [gni_row]
 19884 00002BF1 FF760A                  		push	word [gni_column]
 19885                                  		;push	word [gni_attr_ptr_2]
 19886 00002BF4 FF76F4                  		push	word [gni_attr_ptr+2]
 19887 00002BF7 FF76F2                  		push	word [gni_attr_ptr]
 19888                                  		; 09/12/2018
 19889                                  		;sub	ax,ax ; 0
 19890                                  		;push	ax
 19891 00002BFA E8E6EC                  		call	VIOWRTCHARSTRATT
 19892 00002BFD C646F600                		mov	byte [default_used],0
 19893 00002C01 8A46FE                  		mov	al,[gni_input]
 19894 00002C04 8846F0                  		mov	[input_value],al
 19895                                  		; 15/12/2018
 19896                                  ;case_gni_break:
 19897                                  ;		cmp	byte [valid_input],0
 19898                                  ;		jne	short gni_15
 19899 00002C07 E9D0FE                  		jmp	gni_4
 19900                                  gni_15:
 19901 00002C0A 8A46FE                  		mov	al,[gni_input]
 19902                                  gni_16:			; 15/12/2018
 19903 00002C0D 89EC                    		mov	sp,bp
 19904 00002C0F 5D                      		pop	bp
 19905                                  		;retn
 19906 00002C10 C20800                  		retn	8 ; 15/12/2018
 19907                                  
 19908                                  ; input.c - get_char_input
 19909                                  ; ----------------------------------------------------------------------------
 19910                                  
 19911                                  ;/*  */
 19912                                  ;char    get_char_input()
 19913                                  ;
 19914                                  ;BEGIN
 19915                                  ;    regs.h.ah = uc(0x0C);                                           /* AC000 */
 19916                                  ;    regs.h.al = uc(0x07);                                           /* AC000 */
 19917                                  ;    intdos(&regs,&regs);
 19918                                  ;    if (regs.h.al == uc(0))                                         /* AC000 */
 19919                                  ;        BEGIN
 19920                                  ;        DOSBEEP(u(900),u(400));                                     /* AC000 */
 19921                                  ;        END
 19922                                  ;    return(((char)(regs.h.al)));
 19923                                  ;
 19924                                  ;END
 19925                                  
 19926                                  ; 09/12/2018
 19927                                  
 19928                                  get_char_input:
 19929                                  		; Flush STDIN (keyboard) buffer 
 19930                                  		; and then, read character from STDIN (without ECHO)
 19931                                  
 19932                                  		;mov	byte [regs_x_ax+1],0Ch  ;ah = 0Ch
 19933                                  		;mov	byte [regs_x_ax],7 ; al = 7
 19934                                  
 19935                                  		;mov	ax,regs_x_ax
 19936                                  		;push	ax
 19937                                  		;push	ax
 19938                                  		;call	intdos
 19939                                  		;pop	bx
 19940                                  		;pop	bx
 19941                                  
 19942                                  		;cmp	byte [regs_x_ax],0
 19943                                  		;jne	short gci_1
 19944                                  
 19945 00002C13 B8070C                  		mov	ax,0C07h    ; **2018**	
 19946 00002C16 CD21                    		int	21h	    ; **2018**	
 19947                                  
 19948 00002C18 08C0                    		or	al,al	    ; **2018**
 19949 00002C1A 7503                    		jnz	short gci_1 ; **2018**	
 19950                                  
 19951                                  		; 01/01/2019
 19952                                  		;mov	ax,900
 19953                                  		;push	ax
 19954                                  		;mov	ax,400
 19955                                  		;push	ax
 19956 00002C1C E828ED                  		call	DOSBEEP
 19957                                  		; 01/01/2019
 19958                                  		;xor	ax,ax ; 15/12/2018
 19959                                  gci_1:
 19960                                  		;mov	al,[regs_x_ax]
 19961 00002C1F C3                      		retn
 19962                                  
 19963                                  ; video.asm (MSDOS 6.0, 1991)
 19964                                  ; ----------------------------------------------------------------------------
 19965                                  ; 09/12/2018 - Modified for NASM syntax & FDISK subroutines (by Erdogan Tan)
 19966                                  
 19967                                  ;========================================================
 19968                                  ; Modify current cursor position.
 19969                                  ;========================================================
 19970                                  
 19971                                  VideoSetRowCol:
 19972                                  VIOSETCURPOS:
 19973                                  
 19974                                  ; IBM PC-DOS FDISK.COM Segment 3, Offset 0009h
 19975                                  
 19976                                  	;;%define cpos_column bp+8   ; Far Call
 19977                                  	;;%define cpos_row    bp+10
 19978                                  
 19979                                  	;%define cpos_column bp+6   ; Near Call
 19980                                  	;%define cpos_row    bp+8
 19981                                  
 19982                                  		; 09/12/2018
 19983                                  		; DH = Row
 19984                                  		; DL = Column
 19985                                  
 19986                                  		;push	bp
 19987                                  		;mov	bp,sp
 19988                                  		;push	bx
 19989                                  		;push	cx
 19990                                  		;push	dx
 19991                                  		;push	si
 19992                                  		;push	di
 19993                                  		;push	ds
 19994                                  		;push	es
 19995                                  		;push	ss
 19996                                  		;push	bp
 19997                                  		
 19998 00002C20 B700                    		mov	bh,0 ; ScreenPage ; Video Page 0
 19999                                  
 20000                                  		;mov	ax,[cpos_row]
 20001                                  		;cmp	al,25
 20002                                  		;jg	short viosetcpos_0
 20003                                  		;mov	dh,al
 20004                                  		;mov	ax,[cpos_column]
 20005                                  		;cmp	al,80
 20006                                  		;jg	short viosetcpos_0
 20007                                  		;mov	dl,al
 20008                                  
 20009 00002C22 80FE19                  		cmp	dh,25
 20010 00002C25 7F0D                    		jg	short viosetcpos_0
 20011 00002C27 80FA50                  		cmp	dl,80
 20012 00002C2A 7F08                    		jg	short viosetcpos_0
 20013                                  		
 20014 00002C2C B402                    		mov	ah,2 ; SET_CURS_POS
 20015                                  
 20016                                  		;push	bx
 20017                                  		;push	cx
 20018                                  		;push	dx
 20019                                  		;push	si
 20020                                  		;push	di
 20021                                  		;push	ds
 20022                                  		;push	es
 20023                                  		;push	ss
 20024                                  		;push	bp
 20025                                  		
 20026 00002C2E CD10                    		int	10h	; - VIDEO - SET	CURSOR POSITION
 20027                                  				; DH,DL	= row, column (0,0 = upper left)
 20028                                  				; BH = page number
 20029                                  		;pop	bp
 20030                                  		;pop	ss
 20031                                  		;pop	es
 20032                                  		;pop	ds
 20033                                  		;pop	di
 20034                                  		;pop	si
 20035                                  		;pop	dx
 20036                                  		;pop	cx
 20037                                  		;pop	bx
 20038                                  
 20039 00002C30 29C0                    		sub	ax,ax
 20040 00002C32 EB03                    		jmp	short viosetcpos_1
 20041                                  
 20042                                  		;nop
 20043                                  viosetcpos_0:
 20044 00002C34 B80200                  		mov	ax,2
 20045                                  viosetcpos_1:
 20046                                  		;pop	bp
 20047                                  		;pop	ss
 20048                                  		;pop	es
 20049                                  		;pop	ds
 20050                                  		;pop	di
 20051                                  		;pop	si
 20052                                  		;pop	dx
 20053                                  		;pop	cx
 20054                                  		;pop	bx
 20055                                  		;mov	sp,bp
 20056                                  		;pop	bp
 20057                                  		;retf	6 ; return from far call
 20058                                  		;retn 	6 ; return from near call
 20059 00002C37 C3                      		retn ; 10/12/2018
 20060                                  
 20061                                  ; ----------------------------------------------------------------------------
 20062                                  ; convert.c (FDISK, MSDOS 6.0, 1991)	
 20063                                  ; ----------------------------------------------------------------------------
 20064                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 09/12/2018)
 20065                                  
 20066                                  ;/*  */
 20067                                  ;/***************************************************************************/
 20068                                  ;/*Routine name:  DOS_UPPER                                                 */
 20069                                  ;/***************************************************************************/
 20070                                  ;/*                                                                         */
 20071                                  ;/*Description:   This routine will uppcase a character using get country   */
 20072                                  ;/*               information (65H) with the capitalize single character    */
 20073                                  ;/*               call (20H).                                               */
 20074                                  ;/*                                                                         */
 20075                                  ;/*Called Procedures:                                                       */
 20076                                  ;/*                                                                         */
 20077                                  ;/*                                                                         */
 20078                                  ;/*                                                                         */
 20079                                  ;/*Change History: Updated        5/31/87         DRM                       */
 20080                                  ;/*                                                                         */
 20081                                  ;/*Input: drive_value                                                       */
 20082                                  ;/*                                                                         */
 20083                                  ;/*Output: input_value                                                      */
 20084                                  ;/*                                                                         */
 20085                                  ;/***************************************************************************/
 20086                                  
 20087                                  ;char dos_upper(drive_value)
 20088                                  ;
 20089                                  ;char drive_value;
 20090                                  ;
 20091                                  ;BEGIN
 20092                                  ;
 20093                                  ;   char output;
 20094                                  ;
 20095                                  ;   regs.x.ax = (unsigned)CAPCHAR;   /* Get extended country information */
 20096                                  ;   regs.h.dl = (unsigned char)drive_value; /* Move input_value to register DL */
 20097                                  ;   int86((int)INT21,&regs,&regs);
 20098                                  ;   output  = (char)regs.h.dl;
 20099                                  ;
 20100                                  ;#ifdef DEBUG
 20101                                  ;           output = toupper(drive_value);
 20102                                  ;#endif
 20103                                  ;           return(output);
 20104                                  ;END
 20105                                  
 20106                                  ;dos_upper:
 20107                                  	%define upcase_input bp+4
 20108                                  
 20109                                  		;push	bp
 20110                                  		;mov	bp,sp
 20111                                  		;;sub	sp,2
 20112                                  		
 20113                                  		;country dependant character capitalization
 20114                                  		
 20115                                  		;mov	[regs_x_ax],6520h
 20116                                  		;mov	al,[upcase_input]
 20117                                  		;mov	[regs_x_dx],al
 20118                                  		;mov	ax,[regs_x_ax]
 20119                                  		;push	ax
 20120                                  		;push	ax
 20121                                  		;mov	ax,21h
 20122                                  		;push	ax
 20123                                  		;call	int86
 20124                                  		;mov	al,[regs_x_dx] ; capitalize character
 20125                                  		;mov	sp,bp
 20126                                  		;pop	bp
 20127                                  		;retn
 20128                                  dos_upper:
 20129                                  		; 09/12/2018
 20130                                  		;country dependant character capitalization
 20131                                  		
 20132                                  		;push	dx
 20133 00002C38 88C2                    		mov	dl,al
 20134 00002C3A B82065                  		mov	ax,6520h
 20135 00002C3D CD21                    		int	21h
 20136 00002C3F 88D0                    		mov	al,dl
 20137                                  		;pop	dx
 20138                                  		
 20139 00002C41 C3                      		retn
 20140                                  
 20141                                  
 20142                                  ; WRITE.ASM (VCCRT1.ZIP) - Microsoft Visual C++ 1.0 Run-Time Library Sources
 20143                                  ; ----------------------------------------------------------------------------
 20144                                  ; Modified and simplified for NASM syntax by Erdogan Tan (10/12/2018)
 20145                                  
 20146                                  ;***
 20147                                  ;int _write(fh, buf, cnt) - write bytes to a file handle
 20148                                  ;
 20149                                  ;Purpose:
 20150                                  ;	Writes count bytes from the buffer to the handle specified.
 20151                                  ;	If the file was opened in text mode, each LF is translated to
 20152                                  ;	CR-LF.	This does not affect the return value.	In text
 20153                                  ;	mode ^Z indicates end of file.
 20154                                  ;
 20155                                  ;	Multi-thread notes:
 20156                                  ;	(1) write() - Locks/unlocks file handle
 20157                                  ;	    _write_lk() - Does NOT lock/unlock file handle
 20158                                  ;	(2) It is assumed in this source that MTHREAD can only be
 20159                                  ;	true under OS/2.  Thus, conditional code is contained within
 20160                                  ;	MTHREAD conditionals without additional OS2 conditionals.
 20161                                  ;
 20162                                  ;Entry:
 20163                                  ;	int fh - file handle to write to
 20164                                  ;	char *buf - buffer to write from
 20165                                  ;	unsigned int cnt - number of bytes to write
 20166                                  ;
 20167                                  ;Exit:
 20168                                  ;	returns number of bytes actually written.
 20169                                  ;	This may be less than cnt, for example, if out of disk space.
 20170                                  ;	returns -1 (and set errno) if fails.
 20171                                  ;
 20172                                  ;Uses:
 20173                                  ;
 20174                                  ;Exceptions:
 20175                                  ;
 20176                                  ;*******************************************************************************
 20177                                  
 20178                                  
 20179                                  ; 14/12/2018 (no need to _write for FDISK2.COM)
 20180                                  
 20181                                  ;;--- Non-multithread version of write
 20182                                  ;
 20183                                  ;_write:
 20184                                  ;
 20185                                  ;	;%define oldsp	bp-8
 20186                                  ;	%define oldsp	bp-6
 20187                                  ;	%define lfcnt	bp-4
 20188                                  ;	%define outcnt	bp-2
 20189                                  ;
 20190                                  ;	%define fhndl	bp+4  ; fh
 20191                                  ;	%define buf	bp+6
 20192                                  ;	%define cnt	bp+8
 20193                                  ;
 20194                                  ;		push	bp
 20195                                  ;		mov	bp,sp
 20196                                  ;		;sub	sp,8
 20197                                  ;		sub	sp,6		
 20198                                  ;
 20199                                  ;		; make sure handle is in range
 20200                                  ;
 20201                                  ;		mov	bx,[fhndl]	; get file handle
 20202                                  ;
 20203                                  ;		cmp	bx,[_nfile]	; handle in range ?
 20204                                  ;		jb	short handle_okay ; yes, continue
 20205                                  ;
 20206                                  ;		;mov	ax,EBADF shl 8 + 0 ; file handle is out of range
 20207                                  ;		mov	ax,900h
 20208                                  ;		stc
 20209                                  ;to_dosretax:
 20210                                  ;		jmp	_dosretax	; error on lseek (invalid file handle)
 20211                                  ;		;jmp	DOSerror
 20212                                  ;handle_okay:
 20213                                  ;		;cmp	_aDBswpflg,_aDBdoswp	; See if we should screen swap
 20214                                  ;		cmp	word [_aDBswpflg],0D6D6h
 20215                                  ;		jne	short chk_append ; No -- skip over call
 20216                                  ;		call	_aDBswpchk	; Yes -- try to do the check
 20217                                  ;chk_append:
 20218                                  ;		;test	__osfile[bx],FAPPEND ; check for append
 20219                                  ;		test    byte [_osfile+bx],20h
 20220                                  ;		jz	short noseek1	; not appending, continue
 20221                                  ;
 20222                                  ;;Append mode - seek to end of file
 20223                                  ;
 20224                                  ;		;mov	ax,DOS_lseek shl 8 + 2 ; appending, lseek to end
 20225                                  ;		mov	ax,4202h
 20226                                  ;		xor	cx,cx
 20227                                  ;		mov	dx,cx		; 0L
 20228                                  ;		;callos
 20229                                  ;		int	21h	; DOS - 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)                                       ; AL = method: offset from end of file
 20230                                  ;				; AL = method: offset from end of file
 20231                                  ;		jc	short to_dosretax ; if no error, continue
 20232                                  ;noseek1:
 20233                                  ;		;test	__osfile[bx],FTEXT ; check for text (DOS finds err)
 20234                                  ;		test	byte [_osfile+bx],80h
 20235                                  ;		jz	short writebin0	; do it without translation
 20236                                  ;		;fall thru		; do the cr/lf translation
 20237                                  ;
 20238                                  ;; --- Translate LF => CR/LF ---
 20239                                  ;; We get here if we have to translate LF's to CR/LF's on output
 20240                                  ;
 20241                                  ;translate:
 20242                                  ;
 20243                                  ;;put input buffer address in es:si
 20244                                  ;
 20245                                  ;		mov	dx,[buf]	; get buffer address
 20246                                  ;		push	ds
 20247                                  ;		pop	es		; es = ds
 20248                                  ;
 20249                                  ;		xor	ax,ax
 20250                                  ;		mov	[outcnt],ax	;zero out char counter
 20251                                  ;		mov	[lfcnt],ax	;zero out lf counter, too
 20252                                  ;
 20253                                  ;		cld
 20254                                  ;		push	di		; save di
 20255                                  ;		push	si		; save si
 20256                                  ;		mov	di,dx		; es:di = start of search
 20257                                  ;		mov	si,dx		; ds:si = start of search, too
 20258                                  ;
 20259                                  ;;Scan for LFs in the user's buffer.
 20260                                  ;;(1) If none, write the buffer out in one shot.
 20261                                  ;;(2) If there is an LF, buffer the output doing translation.
 20262                                  ;
 20263                                  ;lfscan:
 20264                                  ;		mov	[oldsp],sp	;save sp
 20265                                  ;		mov	cx,[cnt]	;get char move count
 20266                                  ;		jcxz	j_writedone	;done if count = 0
 20267                                  ;
 20268                                  ;		;mov	al,C_LF		;set up for scan
 20269                                  ;		mov	al,0Ah
 20270                                  ;		repnz	scasb		;scan for LF
 20271                                  ;		jnz	short writebin1	;no LFs - write out in binary mode
 20272                                  ;		;fall thru		;LFs - use the internal buffer
 20273                                  ;
 20274                                  ;;Move chars from input buffer to LF buffer doing translation as needed.
 20275                                  ;;ds:si = start of input buffer
 20276                                  ;
 20277                                  ;		call	_stackavail	;ax = # bytes on stack
 20278                                  ;		;cmp	ax,LFBUFFMIN+STACKSAVE ;is there enough room on stack?
 20279                                  ;		cmp	ax,168
 20280                                  ;		jbe	short stackerr	;nope - return an error
 20281                                  ;	
 20282                                  ;		sub	sp,2		;move sp to first free word
 20283                                  ;		mov	bx,sp		;bx = end of LF buffer
 20284                                  ;		;mov	dx,LFBUFFMAX	;assume max LF buff size
 20285                                  ;		mov	dx,512	
 20286                                  ;		;cmp	ax,LFBUFFMAX+STACKSAVE ;stack space > max LF buff size ??
 20287                                  ;		cmp     ax,552
 20288                                  ;		jae	short lfbuff	;yes, use the max LF buff size
 20289                                  ;		;mov	dx,LFBUFFMIN	;no, use the min LF buff size
 20290                                  ;		mov	dx,128
 20291                                  ;lfbuff:
 20292                                  ;		sub	sp,dx		;move sp past LF buffer
 20293                                  ;		mov	dx,sp		;dx = start of LF buffer
 20294                                  ;		mov	di,dx		;di = start of LF buffer also
 20295                                  ;
 20296                                  ;		push	ss		;es gets LF buffer segment
 20297                                  ;		pop	es
 20298                                  ;
 20299                                  ;		mov	cx,[cnt]	;cx = # of chars to move
 20300                                  ;
 20301                                  ;;Main body of loop
 20302                                  ;;	al = reserved for current character
 20303                                  ;;	bx = end of LF buffer
 20304                                  ;;	cx = count of chars left to write
 20305                                  ;;	dx = beginning of LF buffer
 20306                                  ;;	ds:si = curr position in input buffer
 20307                                  ;;	es:di = curr position in LFBUFF
 20308                                  ;
 20309                                  ;lfloop:
 20310                                  ;		lodsb			;al = next byte from input
 20311                                  ;		;cmp	al,C_LF		;curr char == LF ?
 20312                                  ;		cmp	al,0Ah
 20313                                  ;		je	short foundlf 	;yes - do the translation
 20314                                  ;lfloop1:
 20315                                  ;		cmp	di,bx		;is LF buffer full ?
 20316                                  ;		je	short wrlfbuff1	;if so, write it out
 20317                                  ;storechr:
 20318                                  ;		stosb			;al ->	LFBUFF and bump di
 20319                                  ;		loop	lfloop		;do next char
 20320                                  ;		;fall thru		;no more input (cx = 0)
 20321                                  ;
 20322                                  ;;No more input - write out anything that's in the LF buffer
 20323                                  ;
 20324                                  ;		call	wrlfbuff	;write out the buffer
 20325                                  ;j_writedone:
 20326                                  ;		jmp	short writedone ;all done!
 20327                                  ;
 20328                                  ;;Found an LF - do the translation
 20329                                  ;
 20330                                  ;foundlf:
 20331                                  ;		;mov	al,C_CR		;put a CR in the buffer
 20332                                  ;		mov	al,0Dh
 20333                                  ;		cmp	di,bx		;LF buffer full ?
 20334                                  ;		jne	short foundlf1	;nope - store the CR
 20335                                  ;		call	wrlfbuff	;write out the LF buffer
 20336                                  ;foundlf1:
 20337                                  ;		stosb			;CR -> LFBUFF and bump di
 20338                                  ;		;mov	al,C_LF		;get LF back
 20339                                  ;		mov	al,0Ah
 20340                                  ;		inc	word [lfcnt] 	;bump LF count
 20341                                  ;		jmp	short lfloop1	;store the LF
 20342                                  ;
 20343                                  ;;Call to wrlfbuff used by the lfloop
 20344                                  ;
 20345                                  ;wrlfbuff1:
 20346                                  ;		call	wrlfbuff	;write out the buffer
 20347                                  ;		jmp	short storechr	;back into loop
 20348                                  ;;Bridges
 20349                                  ;
 20350                                  ;writebin1:
 20351                                  ;		pop	si		;restore si/di
 20352                                  ;		pop	di
 20353                                  ;writebin0:
 20354                                  ;		jmp	short writebin	;binary write code
 20355                                  ;
 20356                                  ;;Error - could not get enough stack space
 20357                                  ;
 20358                                  ;stackerr:
 20359                                  ;	; call _chkstk with a value guaranteed to give an error
 20360                                  ;
 20361                                  ;		mov	ax,0FFFCh ; -4
 20362                                  ;		call	_chkstk 	;give stack overflow and die
 20363                                  ;		;never returns
 20364                                  
 20365                                  ; ----------------------------------------------------------------------------
 20366                                  
 20367                                  ;***
 20368                                  ;wrlfbuff - Write out the lfbuffer
 20369                                  ;
 20370                                  ;Purpose:
 20371                                  ;	This routine writes out the lf buffer and resets appropriate
 20372                                  ;	registers.
 20373                                  ;Entry:
 20374                                  ;	Registers still setup from LF/CR translation loop.
 20375                                  ;	Pertinent values for wrlfbuff() are:
 20376                                  ;		dx = beginning of LF buffer
 20377                                  ;		di = current position in LF buffer
 20378                                  ;Exit:
 20379                                  ;	Resets di to the beginning of the LF buffer.
 20380                                  ;
 20381                                  ;Uses:
 20382                                  ;
 20383                                  ;Exceptions:
 20384                                  ;
 20385                                  ;*******************************************************************************
 20386                                  
 20387                                  ; 14/12/2018 (no need to _wrlfbuff for FDISK2.COM)
 20388                                  
 20389                                  ;wrlfbuff:
 20390                                  ;		push	ax		;save current char
 20391                                  ;		push	bx		;save end of buffer pointer
 20392                                  ;		push	cx		;save cx
 20393                                  ;	
 20394                                  ;		;calculate the # of chars to write out
 20395                                  ;
 20396                                  ;		mov	cx,di		;cx = calc # of bytes to write
 20397                                  ;		sub	cx,dx
 20398                                  ;		jcxz	wrlfdone	;if cx == 0, we're done
 20399                                  ;
 20400                                  ;		push	cx		;save char count
 20401                                  ;
 20402                                  ;		;do the write
 20403                                  ;
 20404                                  ;		mov	bx,[fhndl]		;bx = file handle
 20405                                  ;		;mov	ah,DOS_write	;write call
 20406                                  ;		;callos			;do the write
 20407                                  ;		mov	ah,40h
 20408                                  ;		int	21h	; DOS - 2+ - WRITE TO FILE WITH HANDLE
 20409                                  ;				; BX = file handle, CX = number of bytes to write,
 20410                                  ;				; DS:DX -> buffer
 20411                                  ;		pop	cx		;restore chars written
 20412                                  ;		jc	short wrlferror	;error
 20413                                  ;
 20414                                  ;		add	[outcnt],ax	;add chars written to total
 20415                                  ;		cmp	cx,ax		;did we write less than we wanted
 20416                                  ;		ja	short wrlferror	;yes - return error, if we jump, CF=0
 20417                                  ;
 20418                                  ;	;--- no error on the write ---
 20419                                  ;	;Restore/re-initialize registers and return.
 20420                                  ;
 20421                                  ;wrlfdone:
 20422                                  ;		pop	cx		;restore register
 20423                                  ;		pop	bx
 20424                                  ;		pop	ax
 20425                                  ;		mov	di,dx		;make di = beginning of LF buffer
 20426                                  ;		retn			;return to caller
 20427                                  ;
 20428                                  ;;--- error on the write ---
 20429                                  ;;Either the write returned an explicit error or we wrote less than requested.
 20430                                  ;;Either way, we are not returning to the caller.
 20431                                  ;
 20432                                  ;wrlferror:
 20433                                  ;		lahf			;save carry for a sec...
 20434                                  ;		;add	sp,8		;clean off stack (don't change ax)
 20435                                  ;		add	sp,6		;cleans off return address, too
 20436                                  ;		
 20437                                  ;		cmp	word [outcnt],0	;have we written something?
 20438                                  ;		jne	short writedone	;yes, return how much
 20439                                  ;
 20440                                  ;		sahf			;restore carry
 20441                                  ;
 20442                                  ;		jnc	short wrote0	;carry set ?
 20443                                  ;		;mov	ah,EBADF	;yes - error on write
 20444                                  ;		mov	ah,9
 20445                                  ;		jmp	short writeerror ;error return
 20446                                  ;
 20447                                  ;; The write did not return an error but we didn't write anything.
 20448                                  ;; if dev and first byte ^z, just return 0. else return end of media error.
 20449                                  ;; (AX=0)
 20450                                  ;
 20451                                  ;wrote0:
 20452                                  ;		;test	__osfile[bx],FDEV ; device ?
 20453                                  ;		test	byte [_osfile+bx],40h
 20454                                  ;		jz	short wrlferr1	; no, error
 20455                                  ;	
 20456                                  ;		mov	bx,[buf]
 20457                                  ;		;cmp	byte ptr [bx],C_SUB ; ^z ?
 20458                                  ;		cmp	byte [bx],1Ah
 20459                                  ;		jne	short wrlferr1	; no
 20460                                  ;
 20461                                  ;		clc			; no error
 20462                                  ;		jmp	short writeerror ; don't overwrite ax (ax=0)
 20463                                  ;
 20464                                  ;wrlferr1:				; return an error
 20465                                  ;		stc			; carry set for error
 20466                                  ;		;mov	ax,ENOSPC shl 8 + 0 ; return no more disk space error
 20467                                  ;		mov	ax,1C00h
 20468                                  ;		jmp	short writeerror ; return the error
 20469                                  ;
 20470                                  ;writedone:				; good return
 20471                                  ;		mov	ax,[outcnt]	; total # chars written
 20472                                  ;		sub	ax,[lfcnt]	; subtract the # of LFs translated
 20473                                  ;					; clears carry, too
 20474                                  ;writeerror:				; error return
 20475                                  ;		mov	sp,[oldsp]	; restore sp
 20476                                  ;		pop	si		; restore si
 20477                                  ;		pop	di		; restore di
 20478                                  ;justret:
 20479                                  ;		jmp	_dosretax	; return AX if successful
 20480                                  ;
 20481                                  ;;--- Untranslated Writes ---
 20482                                  ;; Just shove the entire buffer out there as fast as possible
 20483                                  ;; ds = dgroup
 20484                                  ;
 20485                                  ;writebin:
 20486                                  ;		mov	cx,[cnt]	; number of bytes to write
 20487                                  ;		or	cx,cx		; are we supposed to write 0 bytes?
 20488                                  ;		jnz	short writegoon	; nope, continue
 20489                                  ;		mov	ax,cx		; yes, ax = byte count = 0
 20490                                  ;		;jmp	__dosretax	; good return
 20491                                  ;		jmp	DOSnoerror ; 10/12/2018
 20492                                  ;writegoon:
 20493                                  ;		mov	dx,[buf]	; buffer address
 20494                                  ;		;callos	write
 20495                                  ;		mov	ah,40h
 20496                                  ;		int	21h	; DOS - 2+ - WRITE TO FILE WITH HANDLE
 20497                                  ;				; BX = file handle, CX = number of bytes to write,
 20498                                  ;				; DS:DX -> buffer
 20499                                  ;		jnc	short writeok4
 20500                                  ;
 20501                                  ;		;mov	ah,EBADF
 20502                                  ;		mov	ah,9
 20503                                  ;		jmp	short justret
 20504                                  ;
 20505                                  ;writeok4:				;no write error  (ax = # bytes written)
 20506                                  ;		or	ax,ax		;did we write 0 bytes ?
 20507                                  ;		jnz	short justret 	;no, just return
 20508                                  ;
 20509                                  ;; Requested non-zero number of bytes to be written and 0 were written.
 20510                                  ;; If device and 1st byte was ^z, just return 0. else end of media
 20511                                  ;
 20512                                  ;		;test	__osfile[bx],FDEV ; device?
 20513                                  ;		test	byte [_osfile+bx],40h
 20514                                  ;		jz	short notdev	; no
 20515                                  ;
 20516                                  ;		mov	bx,dx
 20517                                  ;		;cmp	byte ptr [bx],C_SUB ; ^z ?
 20518                                  ;		cmp	byte [bx],1Ah
 20519                                  ;		jne	short notdev
 20520                                  ;
 20521                                  ;		clc
 20522                                  ;		jmp	short justret	; good return
 20523                                  ;notdev:
 20524                                  ;		stc			; set carry flag to mark error
 20525                                  ;		;mov	ax,ENOSPC shl 8 + 0 ; return no more disk space error
 20526                                  ;		mov     ax,1C00h
 20527                                  ;		jmp	short justret	; return AX
 20528                                  
 20529                                  ; STACKAVA.ASM (VCCRT1.ZIP) - Visual C++ 1.0 Run-Time Library Sources
 20530                                  ; ----------------------------------------------------------------------------
 20531                                  ; 10/12/2018
 20532                                  
 20533                                  ; 14/12/2018 (no need to _stackavail for FDISK2.COM)
 20534                                  
 20535                                  ;_stackavail:
 20536                                  ;		pop	cx		; return offset
 20537                                  ;		;mov	ax,[_STKHQQ]	; bottom of stack
 20538                                  ;		mov	ax,[end_of_bss]
 20539                                  ;
 20540                                  ;		cmp	ax,sp
 20541                                  ;		jae	short stkavl_1
 20542                                  ;
 20543                                  ;		sub	ax,sp
 20544                                  ;		neg	ax
 20545                                  ;stkavl_0:
 20546                                  ;		jmp	cx		;; return to cx
 20547                                  ;stkavl_1:
 20548                                  ;		xor	ax,ax
 20549                                  ;		jmp	short stkavl_0
 20550                                  
 20551                                  ; ----------------------------------------------------------------------------
 20552                                  ; int13.c (FDISK, MSDOS 6.0, 1991)	
 20553                                  ; ----------------------------------------------------------------------------
 20554                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 15/12/2018)
 20555                                  
 20556                                  ;/*  */
 20557                                  ;char write_boot_record(cylinder,which_disk)
 20558                                  ;
 20559                                  ;unsigned    cylinder;
 20560                                  ;unsigned char   which_disk;
 20561                                  ;
 20562                                  ;BEGIN
 20563                                  ;
 20564                                  ;/*C00    char i;  */
 20565                                  ;/*C00    char j;  */
 20566                                  ;    char far *buffer_pointer = boot_record;
 20567                                  ;
 20568                                  ;    /* Setup read, always on a cylinder boundary */
 20569                                  ;    regs.h.ah = uc(WRITE_DISK);                           /* AC000 */
 20570                                  ;    regs.h.al = uc(1);                                    /* AC000 */
 20571                                  ;    regs.h.dh = uc(0);                                    /* AC000 */
 20572                                  ;    regs.h.cl = uc(0x01);                                 /* AC000 */
 20573                                  ;
 20574                                  ;    /* Specify the disk */
 20575                                  ;    regs.h.dl = which_disk + 0x80;
 20576                                  ;
 20577                                  ;    /* Need to scramble CX so that sectors and cyl's are in INT 13 format */
 20578                                  ;
 20579                                  ;    if (cylinder > u(255))                                /* AC000 */
 20580                                  ;       BEGIN
 20581                                  ;        regs.h.cl = regs.h.cl | ((unsigned char)((cylinder /256) << 6));
 20582                                  ;       END
 20583                                  ;    regs.h.ch = (unsigned char)(cylinder & 0xFF);
 20584                                  ;
 20585                                  ;    /* Point at the place to read the boot record */
 20586                                  ;    regs.x.bx = FP_OFF(buffer_pointer);
 20587                                  ;    segregs.es = FP_SEG(buffer_pointer);
 20588                                  ;
 20589                                  ;    /* write the boot record */
 20590                                  ;    DiskIo(&regs,&regs,&segregs);                         /* AC000 */
 20591                                  ;
 20592                                  ;    /* Check for error reading it */
 20593                                  ;    if ((regs.x.cflag & 1) != u(1))                       /* AC000 */
 20594                                  ;       BEGIN
 20595                                  ;        return(TRUE);
 20596                                  ;       END
 20597                                  ;    else
 20598                                  ;       BEGIN
 20599                                  ;        /* Tell user there was an error */
 20600                                  ;        clear_screen(u(0),u(0),u(24),u(79));              /* AC000 */
 20601                                  ;        display(error_2);
 20602                                  ;        no_fatal_error = FALSE;
 20603                                  ;        return(FALSE);
 20604                                  ;       END
 20605                                  ;END
 20606                                  
 20607                                  write_boot_record:
 20608                                  
 20609                                  	;%define w_buf_pointer	bp-4  ; far ptr, dword
 20610                                  
 20611                                  	%define w_cylinder	bp+4  ; unsigned int, word
 20612                                  	%define w_which_disk	bp+6  ; unsigned char, byte	
 20613                                  
 20614 00002C42 55                      		push	bp
 20615 00002C43 89E5                    		mov	bp,sp
 20616                                  		;sub	sp,4 ; 04/01/2019
 20617                                  		
 20618                                  		;mov	word [w_buf_pointer],boot_record
 20619                                  		;mov	[w_buf_pointer2],ds
 20620                                  
 20621 00002C45 BB[E0C9]                		mov	bx,boot_record
 20622                                  		;push	ds
 20623                                  		;pop	es
 20624                                  		
 20625                                  		;mov	byte [regs_x_ax+1],3 ; write
 20626                                  		;mov	byte [regs_x_ax],1   ; 1 sector	
 20627                                  
 20628                                  		;mov	byte [regs_x_dx+1],0
 20629                                  		;mov	byte [regs_x_cx],1
 20630                                  
 20631 00002C48 28F6                    		sub	dh,dh	; Head 0
 20632 00002C4A B101                    		mov	cl,1	; Sector 1
 20633                                  
 20634                                  		;mov	al,[w_which_disk]
 20635                                  		;add	al,80h
 20636                                  		;mov	byte [regs_x_dx],al
 20637                                  
 20638 00002C4C 8A5606                  		mov	dl,[w_which_disk]
 20639 00002C4F 80C280                  		add	dl,80h
 20640                                  
 20641 00002C52 8B4604                  		mov	ax,[w_cylinder]
 20642 00002C55 88C5                    		mov	ch,al
 20643                                  
 20644                                  		;cmp	word [w_cylinder],255
 20645                                  		;cmp	ax,255
 20646                                  		;jbe	short write_bs_1
 20647 00002C57 08E4                    		or	ah,ah
 20648 00002C59 7408                    		jz	short write_bs_1
 20649                                  
 20650                                  		;mov	ax,[w_cylinder]
 20651 00002C5B D1E8                    		shr	ax,1
 20652 00002C5D D1E8                    		shr	ax,1
 20653 00002C5F 24C0                    		and	al,0C0h
 20654                                  		;or	byte [regs_x_cx],al
 20655 00002C61 08C1                    		or	cl,al
 20656                                  write_bs_1:
 20657                                  		;mov	al,[w_cylinder]
 20658                                  		;mov	byte [regs_x_cx+1],al
 20659                                  
 20660                                  		;mov	ax,[w_buf_pointer]
 20661                                  		;mov	[regs_x_bx],ax
 20662                                  		;mov	ax,[w_buf_pointer2]
 20663                                  		;mov	[segregs_es],ax
 20664                                  		;mov	ax,segregs_es
 20665                                  
 20666                                  		;push	ax
 20667                                  		;mov	ax,regs_x_ax
 20668                                  		;push	ax
 20669                                  		;push	ax
 20670                                  		;call	DiskIo
 20671                                  		;add	sp,6
 20672                                  		;mov	al,[regs_x_cflag]
 20673                                  		;and	al,1
 20674                                  		;cmp	al,1
 20675                                  		;je	short write_bs_2
 20676                                  		;mov	al,1
 20677                                  		;jmp	short write_bs_3
 20678                                  
 20679 00002C63 B80103                  		mov	ax,0301h ; write 1 sector (CHS write)
 20680 00002C66 CD13                    		int	13h
 20681 00002C68 7204                    		jc	short write_bs_2
 20682                                  
 20683 00002C6A B001                    		mov	al,1 ; TRUE
 20684 00002C6C EB14                    		jmp	short write_bs_3
 20685                                  write_bs_2:
 20686                                  		;mov	ax,79
 20687                                  		;push	ax	 ; Bottom Rigth Column (79)  
 20688                                  		;mov	ax,24
 20689                                  		;push	ax	 ; Bottom Row (24)
 20690                                  		;sub	ax,ax ; 0
 20691                                  		;push	ax	 ; Top Left Column (0)	
 20692                                  		;push	ax	 ; Top Row (0)
 20693                                  		;
 20694                                  		;call	clear_screen
 20695                                  		;add	sp,8
 20696                                  
 20697                                  		; Clear screen (clear whole video page)
 20698 00002C6E E8EDE7                  		call	CLS
 20699                                  
 20700 00002C71 28C0                    		sub	al,al ; FALSE
 20701 00002C73 F9                      		stc	; cf = 1  (error!)
 20702                                  
 20703                                  		;;push	word [error_2_seg] ; read error
 20704                                  		;push	word [error_3_seg] ; write error
 20705 00002C74 1E                      		push	ds
 20706                                  		;push	word [error_2_off]
 20707 00002C75 FF36[889E]              		push	word [error_3_off]
 20708 00002C79 E8A8E9                  		call	display
 20709                                  		;pop	bx
 20710                                  		;pop	bx
 20711                                  
 20712 00002C7C 28C0                    		sub	al,al ; FALSE
 20713 00002C7E A2[13C4]                		mov	[no_fatal_error],al ; 0
 20714 00002C81 F9                      		stc	; cf = 1  (error!)
 20715                                  write_bs_3:
 20716                                  		;mov	sp,bp ; 04/01/2019
 20717 00002C82 5D                      		pop	bp
 20718                                  		;retn
 20719 00002C83 C20400                  		retn	4 ; 22/12/2018
 20720                                  
 20721                                  ; ============================================================================
 20722                                  ;  MAIN MENU
 20723                                  ; ============================================================================
 20724                                  ; 15/12/2018
 20725                                  
 20726                                  ; fdisk.msg (MSDOS 6.0)
 20727                                  ;/*************************************************************************************************/
 20728                                  ;/* Screen for DO_MAIN_MENU                                                                       */
 20729                                  ;/*                                                                                               */
 20730                                  ;/*      |00000000001111111111222222222233333333334444444444555555555566666666667777777777|       */
 20731                                  ;/*      |01234567890123456789012345678901234567890123456789012345678901234567890123456789|       */
 20732                                  ;/*    --|--------------------------------------------------------------------------------|       */
 20733                                  ;/*    00|                               MS-DOS Version 6                                 |menu_1 */
 20734                                  ;/*    01|                            Fixed Disk Setup Program                            |menu_1 */
 20735                                  ;/*    02|                    (C)Copyright Microsoft Corp. 1983 - 1993                    |menu_1 */
 20736                                  ;/*    03|                                                                                |       */
 20737                                  ;/*    04|                                 FDISK Options                                  |menu_2 */
 20738                                  ;/*    05|                                                                                |       */
 20739                                  ;/*    06|    Current fixed disk drive: #                                                 |menu_5 */
 20740                                  ;/*    07|                                                                                |       */
 20741                                  ;/*    08|    Choose one of the following:                                                |menu_3 */
 20742                                  ;/*    09|                                                                                |       */
 20743                                  ;/*    10|    1.  Create DOS Partition or Logical DOS Drive                               |menu_2 */
 20744                                  ;/*    11|    2.  Set active partition                                                    |menu_2 */
 20745                                  ;/*    12|    3.  Delete DOS Partition or Logical DOS Drive                               |menu_2 */
 20746                                  ;/*    13|    4.  Display partition information                                           |menu_2 */
 20747                                  ;/*    14|    5.  Change current fixed disk drive                                         |menu_4 */
 20748                                  ;/*    15|                                                                                |       */
 20749                                  ;/*    16|                                                                                |       */
 20750                                  ;/*    17|    Enter choice: [#]                                                           |menu_7 */
 20751                                  ;/*    18|                                                                                |       */
 20752                                  ;/*    19|                                                                                |       */
 20753                                  ;/*    20|    Warning! No partitions are set active - disk 1 is not startable unless      |menu_6 */
 20754                                  ;/*    21|    a partition is set active.                                                  |       */
 20755                                  ;/*    22|                                                                                |       */
 20756                                  ;/*    23|                                                                                |       */
 20757                                  ;/*    24|    Press ESC to exit FDISK                                                     |menu_2 */
 20758                                  ;/*    ------------------------------------------------------------------------------------       */
 20759                                  ;/*                                                                                               */
 20760                                  ;/*************************************************************************************************/
 20761                                  
 20762                                  ; ----------------------------------------------------------------------------
 20763                                  ; mainmenu.c (FDISK, MSDOS 6.0, 1991)	
 20764                                  ; ----------------------------------------------------------------------------
 20765                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 15/12/2018)
 20766                                  
 20767                                  ;/*  */
 20768                                  ;/******************* START OF SPECIFICATIONS *******************/
 20769                                  ;/*                                                             */
 20770                                  ;/* SUBROUTINE NAME: DO_MAIN_MENU                               */
 20771                                  ;/*                                                             */
 20772                                  ;/* DESCRIPTIVE NAME: Main menu display and input routine       */
 20773                                  ;/*                                                             */
 20774                                  ;/* FUNCTION:                                                   */
 20775                                  ;/*    Displays the main FDISK menu, accepts and validates      */
 20776                                  ;/*    input from menu and passes control to requested function */
 20777                                  ;/*                                                             */
 20778                                  ;/* NOTES: The following screen is managed by this routine:     */
 20779                                  ;/*                                                             */
 20780                                  ;/*       |0000000000111111111122222222223333333333|            */
 20781                                  ;/*       |0123456789012345678901234567890123456789|            */
 20782                                  ;/*     --|----------------------------------------|            */
 20783                                  ;/*     00|                                        |            */
 20784                                  ;/*     01|                                        |            */
 20785                                  ;/*     02|                                        |            */
 20786                                  ;/*     03|                                        |            */
 20787                                  ;/*     04|FDISK Options                           |            */
 20788                                  ;/*     05|                                        |            */
 20789                                  ;/*     06|Current Fixed Disk Drive: #             |            */
 20790                                  ;/*     07|                                        |            */
 20791                                  ;/*     08|Choose one of the following:            |            */
 20792                                  ;/*     09|                                        |            */
 20793                                  ;/*     10|    1.  Create DOS partition            |            */
 20794                                  ;/*     11|    2.  Change Active Partition         |            */
 20795                                  ;/*     12|    3.  Delete DOS Partition            |            */
 20796                                  ;/*     13|    4.  Display Partition Data          |            */
 20797                                  ;/*     14|    5.  Select Next Fixed Disk Drive    |            */
 20798                                  ;/*     15|                                        |            */
 20799                                  ;/*     16|                                        |            */
 20800                                  ;/*     17|                                        |            */
 20801                                  ;/*     18|Enter choice: [#]                       |            */
 20802                                  ;/*     19|                                        |            */
 20803                                  ;/*     20|                                        |            */
 20804                                  ;/*     21|WARNING! No partitions marked active    |            */
 20805                                  ;/*     22|                                        |            */
 20806                                  ;/*     23|Press ESC to return to DOS              |            */
 20807                                  ;/*     --------------------------------------------            */
 20808                                  ;/*                                                             */
 20809                                  ;/* ENTRY POINTS: do_main_menu                                  */
 20810                                  ;/*      LINKAGE: do_main_menu();                               */
 20811                                  ;/*               NEAR CALL                                     */
 20812                                  ;/*                                                             */
 20813                                  ;/* INPUT: None                                                 */
 20814                                  ;/*                                                             */
 20815                                  ;/* EXIT-NORMAL: ERROR=FALSE                                    */
 20816                                  ;/*                                                             */
 20817                                  ;/* EXIT-ERROR: ERROR=TRUE                                      */
 20818                                  ;/*             GOTO internal_program_error if case statement   */
 20819                                  ;/*             failure when branching to requested function    */
 20820                                  ;/*                                                             */
 20821                                  ;/* EFFECTS: No data directly modified by this routine, but     */
 20822                                  ;/*          child routines will modify data.                   */
 20823                                  ;/*                                                             */
 20824                                  ;/* INTERNAL REFERENCES:                                        */
 20825                                  ;/*   ROUTINES:                                                 */
 20826                                  ;/*      clear_screen                                           */
 20827                                  ;/*      display                                                */
 20828                                  ;/*      get_num_input                                          */
 20829                                  ;/*      create_partition                                       */
 20830                                  ;/*      change_active_partition                                */
 20831                                  ;/*      delete_partition                                       */
 20832                                  ;/*      display_partition_information                          */
 20833                                  ;/*      find_active_partition                                  */
 20834                                  ;/*      change_drive                                           */
 20835                                  ;/*      internal_program_error                                 */
 20836                                  ;/*                                                             */
 20837                                  ;/* EXTERNAL REFERENCES:                                        */
 20838                                  ;/*   ROUTINES:                                                 */
 20839                                  ;/*                                                             */
 20840                                  ;/******************** END OF SPECIFICATIONS ********************/
 20841                                  
 20842                                  ;/*  */
 20843                                  ;void do_main_menu()
 20844                                  ;
 20845                                  ;BEGIN
 20846                                  ;
 20847                                  ;char   input;
 20848                                  ;char   max_input;
 20849                                  ;
 20850                                  ;FLAG	error_switch;
 20851                                  ;
 20852                                  ;unsigned    temp;
 20853                                  ;unsigned    i;
 20854                                  ;
 20855                                  ;   input = c(NUL);
 20856                                  ;   PercentFlag = (FLAG)FALSE;
 20857                                  ;   /* Initialize cur_disk indicator. It is 0 based for array usage */
 20858                                  ;   /* See if first disk readable */
 20859                                  ;   cur_disk = c(0);
 20860                                  ;   if (!good_disk[0])
 20861                                  ;      BEGIN
 20862                                  ;       cur_disk++;
 20863                                  ;      END
 20864                                  ;
 20865                                  ;   temp = u(0);
 20866                                  ;   for (i=u(0);i<u(number_of_drives);i++)
 20867                                  ;       if (good_disk[i])
 20868                                  ;           temp = u(1);
 20869                                  ;   if (temp == u(1))
 20870                                  ;
 20871                                  ;      BEGIN
 20872                                  ;       clear_screen(u(0),u(0),u(24),u(79));
 20873                                  ;       /* Display the copyright */
 20874                                  ;       display(menu_1);
 20875                                  ;
 20876                                  ;       /* See if we couldn't access drive 1 */
 20877                                  ;		for (i = 0; i < number_of_drives; i++)
 20878                                  ;			BEGIN
 20879                                  ;			 if (!good_disk[i] && (error_switch == FALSE))
 20880                                  ;				{
 20881                                  ;          	insert[0] = c(i+'1');
 20882                                  ;           	display(error_30);
 20883                                  ;			 	error_switch = TRUE;
 20884                                  ;			   }
 20885                                  ;      END
 20886                                  ;
 20887                                  ;      /* Display the menu every time this routine is returned to until ESC */
 20888                                  ;      input = c(NUL);
 20889                                  ;      while (input !=c(ESC))
 20890                                  ;         BEGIN
 20891                                  ;            /* Put up most of the menu */
 20892                                  ;            display(menu_2);
 20893                                  ;            display(menu_3);
 20894                                  ;            display(menu_7);
 20895                                  ;
 20896                                  ;            /* Put correct disk in current disk message */
 20897                                  ;            insert[0]=cur_disk+1+'0';
 20898                                  ;            display(menu_5);
 20899                                  ;
 20900                                  ;            /* Display warning prompt if no active partitions */
 20901                                  ;            /* check to see if there is an avail partition */
 20902                                  ;            temp = u(0);
 20903                                  ;            for (i = u(0); i < u(4);i++)
 20904                                  ;               BEGIN
 20905                                  ;
 20906                                  ;               /* See if any non - zero system id bytes */
 20907                                  ;               temp = temp | part_table[cur_disk][i].sys_id ;
 20908                                  ;              END
 20909                                  ;           /* Any entry that isn't zero means */
 20910                                  ;           if (temp != u(0))
 20911                                  ;              BEGIN
 20912                                  ;               /* If there isn't an active partition and this is disk 1, then yell) */
 20913                                  ;               if ((!find_active_partition()) && (cur_disk == c(0)))
 20914                                  ;                  display(menu_6);
 20915                                  ;              END
 20916                                  ;
 20917                                  ;           /* Get the menu input */
 20918                                  ;
 20919                                  ;           /* See if more than one fixed disk */
 20920                                  ;           if (number_of_drives > uc(1))
 20921                                  ;             BEGIN
 20922                                  ;              display(menu_4);
 20923                                  ;              max_input = c(5);
 20924                                  ;             END
 20925                                  ;           else     /* only 4 options */
 20926                                  ;               max_input = c(4);
 20927                                  ;           /* Setup default and go get input */
 20928                                  ;           input = get_num_input(c(1),max_input,input_row,input_col);
 20929                                  ;           switch(input)
 20930                                  ;              BEGIN
 20931                                  ;               case  '1': create_partition();
 20932                                  ;                          break;
 20933                                  ;
 20934                                  ;               case  '2': change_active_partition();
 20935                                  ;                          break;
 20936                                  ;
 20937                                  ;               case  '3': delete_partition();
 20938                                  ;                          break;
 20939                                  ;
 20940                                  ;               case  '4': display_partition_information();
 20941                                  ;                          break;
 20942                                  ; 
 20943                                  ;               case  '5': change_current_drive();
 20944                                  ;                          break;
 20945                                  ;
 20946                                  ;               case  ESC: break;  /* ESC case */
 20947                                  ;
 20948                                  ;               default:   internal_program_error();
 20949                                  ;              END
 20950                                  ;           END
 20951                                  ;       END
 20952                                  ;   else
 20953                                  ;       BEGIN
 20954                                  ;        /* Can't read any drive, so quit */
 20955                                  ;        no_fatal_error = c(FALSE);
 20956                                  ;        display(error_2);
 20957                                  ;       END
 20958                                  ;   return;
 20959                                  ;END
 20960                                  
 20961                                  do_main_menu:
 20962                                  
 20963                                  	%define mm_err_switch bp-8 ; bp-10
 20964                                  	%define mm_i	      bp-6 ; bp-8
 20965                                  	;%define mm_temp      bp-6
 20966                                  	%define mm_max_input  bp-4
 20967                                  	%define mm_input      bp-2
 20968                                  
 20969 00002C86 55                      		push	bp
 20970 00002C87 89E5                    		mov	bp,sp
 20971                                  		;sub	sp,10
 20972 00002C89 83EC08                  		sub	sp,8
 20973                                  		;sub	al,al ; 0
 20974 00002C8C 29C0                    		sub	ax,ax
 20975 00002C8E 8846FE                  		mov	[mm_input],al
 20976 00002C91 A2[E0C3]                		mov	[PercentFlag],al
 20977 00002C94 A2[E2CB]                		mov	[cur_disk],al
 20978 00002C97 8846F8                  		mov	[mm_err_switch],al ; 0
 20979                                  		;cmp	byte [gooddisk+0],0
 20980 00002C9A 3806[50A1]              		cmp	[good_disk],al ; 0
 20981 00002C9E 7505                    		jne	short mainmenu_01
 20982 00002CA0 C606[E2CB]01            		mov	byte [cur_disk],1
 20983                                  mainmenu_01:
 20984 00002CA5 29C0                    		sub	ax,ax ; 0
 20985                                  		;mov	[mm_temp],ax ; FALSE
 20986 00002CA7 8946FA                  		mov	[mm_i],ax
 20987 00002CAA EB0F                    		jmp	short mainmenu_04
 20988                                  mainmenu_02:
 20989 00002CAC 8B5EFA                  		mov	bx,[mm_i]
 20990 00002CAF 80BF[50A1]00            		cmp	byte [good_disk+bx],0
 20991 00002CB4 7402                    		je	short mainmenu_03
 20992                                  		;mov	byte [mm_temp],1 ; TRUE
 20993 00002CB6 FEC4                    		inc	ah ; [mm_temp] = 1
 20994                                  mainmenu_03:
 20995 00002CB8 FE46FA                  		inc	byte [mm_i]
 20996                                  mainmenu_04:
 20997 00002CBB A0[E3C3]                		mov	al,[number_of_drives]
 20998                                  		;sub	ah,ah
 20999                                  		;cmp	ax,[mm_i]
 21000 00002CBE 3A46FA                  		cmp	al,[mm_i]
 21001 00002CC1 77E9                    		ja	short mainmenu_02
 21002                                  		;cmp	byte [mm_temp],1
 21003                                  		;je	short mainmenu_05
 21004 00002CC3 08E4                    		or	ah,ah ; [mm_temp]
 21005 00002CC5 7503                    		jnz	short mainmenu_05
 21006 00002CC7 E90F01                  		jmp	mainmenu_27
 21007                                  mainmenu_05:
 21008                                  		;mov	ax,79
 21009                                  		;push	ax
 21010                                  		;mov	ax,24
 21011                                  		;push	ax
 21012                                  		;sub	ax,ax
 21013                                  		;push	ax
 21014                                  		;push	ax
 21015                                  		;call	clear_screen
 21016                                  		;add	sp,8
 21017                                  
 21018 00002CCA E891E7                  		call	CLS
 21019                                  
 21020                                  		;push	word [menu_1_segment]
 21021 00002CCD 1E                      		push	ds
 21022 00002CCE FF36[F59D]              		push	word [menu_1_offset]
 21023 00002CD2 E84FE9                  		call	display
 21024                                  		;pop	bx
 21025                                  		;pop	bx
 21026 00002CD5 C646FA00                		mov	byte [mm_i],0
 21027 00002CD9 EB25                    		jmp	short mainmenu_08
 21028                                  mainmenu_06:
 21029 00002CDB 8B5EFA                  		mov	bx,[mm_i]
 21030 00002CDE 80BF[50A1]00            		cmp	byte [good_disk+bx],0
 21031 00002CE3 7718                    		ja	short mainmenu_07
 21032 00002CE5 807EF800                		cmp	byte [mm_err_switch],0
 21033 00002CE9 7712                    		ja	short mainmenu_07
 21034 00002CEB 8D4731                  		lea	ax,[bx+'1']
 21035 00002CEE A2[F4CC]                		mov	[insert],al
 21036                                  		;push	word [error_30_seg]
 21037 00002CF1 1E                      		push	ds
 21038 00002CF2 FF36[BA9E]              		push	word [error_30_off]
 21039 00002CF6 E82BE9                  		call	display
 21040                                  		;pop	bx
 21041                                  		;pop	bx
 21042 00002CF9 C646F801                		mov	byte [mm_err_switch],1
 21043                                  mainmenu_07:
 21044 00002CFD FE46FA                  		inc	byte [mm_i]
 21045                                  mainmenu_08:
 21046 00002D00 A0[E3C3]                		mov	al,[number_of_drives]
 21047 00002D03 28E4                    		sub	ah,ah
 21048                                  		;cmp	ax,[mm_i]
 21049 00002D05 3A46FA                  		cmp	al,[mm_i]
 21050 00002D08 77D1                    		ja	short mainmenu_06
 21051 00002D0A 8866FE                  		mov	byte [mm_input],ah ; 0
 21052                                  mainmenu_10:
 21053 00002D0D 807EFE1B                		cmp	byte [mm_input],1Bh ; ESC key
 21054 00002D11 7503                    		jne	short mainmenu_11
 21055 00002D13 E9D000                  		jmp	mainmenu_28
 21056                                  mainmenu_11:
 21057                                  		;push	word [menu_2_segment]
 21058 00002D16 1E                      		push	ds
 21059 00002D17 FF36[F79D]              		push	word [menu_2_offset]
 21060 00002D1B E806E9                  		call	display
 21061                                  		;pop	bx
 21062                                  		;pop	bx
 21063                                  		;push	word [menu_3_segment]
 21064 00002D1E 1E                      		push	ds
 21065 00002D1F FF36[F99D]              		push	word [menu_3_offset]
 21066 00002D23 E8FEE8                  		call	display
 21067                                  		;pop	bx
 21068                                  		;pop	bx
 21069                                  		;push	word [menu_7_segment]
 21070 00002D26 1E                      		push	ds
 21071 00002D27 FF36[019E]              		push	word [menu_7_offset]
 21072 00002D2B E8F6E8                  		call	display
 21073                                  		;pop	bx
 21074                                  		;pop	bx
 21075                                  mainmenu_12:
 21076                                  		;mov	al,[cur_disk]
 21077                                  		;add	al,'1'
 21078                                  		;mov	[insert],al
 21079                                  		;;push	word [menu_5_segment]
 21080                                  		;push	ds
 21081                                  		;push	word [menu_5_offset]
 21082                                  		;call	display
 21083                                  		;;pop	bx
 21084                                  		;;pop	bx
 21085                                  
 21086 00002D2E E82C01                  		call	display_menu_5 ; 31/12/2018
 21087                                  		
 21088                                  		;sub	ax,ax ; 0
 21089 00002D31 28C0                    		sub	al,al
 21090                                  		;mov	[mm_temp],ax
 21091                                  		;mov	[mm_temp],al ; 0
 21092                                  		;xor	ch,ch ; [mm_temp]
 21093 00002D33 B92E00                  		mov	cx,46 ; *
 21094                                  		;mov	[mm_i],ax
 21095 00002D36 8846FA                  		mov	[mm_i],al ; 0
 21096                                  		;jmp	short mainmenu_14
 21097                                  mainmenu_13:
 21098 00002D39 A0[E2CB]                		mov	al,[cur_disk]
 21099                                  		;cbw
 21100                                  		;shl	ax,1
 21101                                  		;shl	ax,1
 21102 00002D3C D0E0                    		shl	al,1
 21103 00002D3E D0E0                    		shl	al,1
 21104                                  		;add	ax,[mm_i]
 21105 00002D40 0246FA                  		add	al,[mm_i]
 21106                                  		;mov	cx,46
 21107                                  		;mul	cx
 21108                                  		;mov	cl,46 ; *
 21109 00002D43 F6E1                    		mul	cl
 21110 00002D45 89C3                    		mov	bx,ax
 21111 00002D47 8A87[25C4]              		mov	al,[part_table_sys_id+bx]
 21112                                  		;sub	ah,ah
 21113                                  		;or	[mm_temp],ax
 21114                                  		;or	[mm_temp],al
 21115 00002D4B 08C5                    		or	ch,al
 21116 00002D4D FE46FA                  		inc	byte [mm_i]
 21117                                  mainmenu_14:
 21118 00002D50 807EFA04                		cmp	byte [mm_i],4
 21119 00002D54 72E3                    		jb	short mainmenu_13
 21120                                  		;cmp	byte [mm_temp],0
 21121                                  		;jna	short mainmenu_15
 21122 00002D56 08ED                    		or	ch,ch ; [mm_temp]
 21123 00002D58 7413                    		jz	short mainmenu_15
 21124                                  
 21125 00002D5A E8EE05                  		call	find_active_partition
 21126                                  		;or	al,al
 21127                                  		;jnz	short mainmenu_15
 21128 00002D5D 750E                    		jnz	short mainmenu_15
 21129                                  		; al = 0
 21130                                  
 21131 00002D5F 3806[E2CB]              		cmp	[cur_disk],al ; 0
 21132 00002D63 7508                    		jne	short mainmenu_15
 21133                                  		;push	word [menu_6_segment]
 21134 00002D65 1E                      		push	ds
 21135 00002D66 FF36[FF9D]              		push	word [menu_6_offset]
 21136 00002D6A E8B7E8                  		call	display
 21137                                  		;pop	bx
 21138                                  		;pop	bx
 21139                                  mainmenu_15:
 21140 00002D6D 803E[E3C3]01            		cmp	byte [number_of_drives],1
 21141 00002D72 760E                    		jbe	short mainmenu_16
 21142                                  		;push	word [menu_4_segment]
 21143 00002D74 1E                      		push	ds
 21144 00002D75 FF36[FB9D]              		push	word [menu_4_offset]
 21145 00002D79 E8A8E8                  		call	display
 21146                                  		;pop	bx
 21147                                  		;pop	bx
 21148 00002D7C C646FC05                		mov	byte [mm_max_input],5
 21149 00002D80 EB04                    		jmp	short mainmenu_17
 21150                                  mainmenu_16:
 21151 00002D82 C646FC04                		mov	byte [mm_max_input],4
 21152                                  mainmenu_17:
 21153 00002D86 FF36[AAA0]              		push	word [input_col]
 21154 00002D8A FF36[4CA1]              		push	word [input_row]
 21155 00002D8E 8A46FC                  		mov	al,[mm_max_input]
 21156 00002D91 50                      		push	ax
 21157 00002D92 B001                    		mov	al,1
 21158 00002D94 50                      		push	ax
 21159 00002D95 E8DCFC                  		call	get_num_input
 21160                                  		;add	sp,8 ; 15/12/2018
 21161                                  switch_input1:
 21162 00002D98 8846FE                  		mov	[mm_input],al
 21163                                  		;cbw
 21164                                  		;cmp	ax,'5'
 21165 00002D9B 3C35                    		cmp	al,'5'
 21166 00002D9D 7434                    		je	short case_5
 21167 00002D9F 7714                    		ja	short case_DEF
 21168 00002DA1 2C1B                    		sub	al,1Bh  ; ESC key
 21169                                  		;jnz	short mainmenu_19
 21170                                  		;jmp	mainmenu_10
 21171 00002DA3 7441                    		jz	short mainmenu_28
 21172                                  mainmenu_19:
 21173 00002DA5 2C16                    		sub	al,16h ; 1Bh+16h = 31h = '1'
 21174 00002DA7 7412                    		jz	short case_1 ; '1'
 21175 00002DA9 FEC8                    		dec	al
 21176 00002DAB 7414                    		jz	short case_2 ; '2'
 21177 00002DAD FEC8                    		dec	al
 21178 00002DAF 7416                    		jz	short case_3 ; '3'
 21179 00002DB1 FEC8                    		dec	al
 21180 00002DB3 7418                    		jz	short case_4 ; '4'
 21181                                  case_DEF:
 21182 00002DB5 E86305                  		call	internal_program_error
 21183                                  mainmenu_21:
 21184 00002DB8 E952FF                  		jmp	mainmenu_10
 21185                                  case_1:
 21186 00002DBB E8861A                  		call	create_partition
 21187 00002DBE E94CFF                  		jmp	mainmenu_10
 21188                                  case_2:
 21189 00002DC1 E8AE05                  		call	change_active_partition
 21190 00002DC4 E946FF                  		jmp	mainmenu_10
 21191                                  case_3:
 21192 00002DC7 E8B60C                  		call	delete_partition
 21193 00002DCA E940FF                  		jmp	mainmenu_10
 21194                                  case_4:
 21195 00002DCD E81A00                  		call	display_partition_information
 21196 00002DD0 E93AFF                  		jmp	mainmenu_10
 21197                                  case_5:
 21198 00002DD3 E868F2                  		call	change_current_drive
 21199 00002DD6 E934FF                  		jmp	mainmenu_10
 21200                                  mainmenu_27:
 21201 00002DD9 C606[13C4]00            		mov	byte [no_fatal_error],0
 21202                                  		;push	word [error_2_seg]
 21203 00002DDE 1E                      		push	ds
 21204 00002DDF FF36[869E]              		push	word [error_2_off]
 21205 00002DE3 E83EE8                  		call	display
 21206                                  		;pop	bx
 21207                                  		;pop	bx
 21208                                  mainmenu_28:
 21209 00002DE6 89EC                    		mov	sp,bp
 21210 00002DE8 5D                      		pop	bp
 21211 00002DE9 C3                      		retn
 21212                                  
 21213                                  ; ============================================================================
 21214                                  ;  DISPLAY PARTITION INFORMATION
 21215                                  ; ============================================================================
 21216                                  ; 16/12/2018
 21217                                  
 21218                                  ; fdisk.msg (MSDOS 6.0)
 21219                                  ;/***************************************************************************************************/
 21220                                  ;/*  Screen for DISPLAY_PARTITION_INFORMATION                                                       */
 21221                                  ;/*                                                                                                 */
 21222                                  ;/*     |00000000001111111111222222222233333333334444444444555555555566666666667777777777|          */
 21223                                  ;/*     |01234567890123456789012345678901234567890123456789012345678901234567890123456789|          */
 21224                                  ;/*   --|--------------------------------------------------------------------------------|          */
 21225                                  ;/*   00|                                                                                |          */
 21226                                  ;/*   01|                                                                                |          */
 21227                                  ;/*   02|                                                                                |          */
 21228                                  ;/*   03|                                                                                |          */
 21229                                  ;/*   04|                           Display Partition Information                        |menu_35   */
 21230                                  ;/*   05|                                                                                |          */
 21231                                  ;/*   06|    Current fixed disk drive: #                                                 |menu_5 #  */
 21232                                  ;/*   07|                                                                                |          */
 21233                                  ;/*   08|    Partition Status   Type    Size in Mbytes   Percentage of Disk Used         |menu_14 # */
 21234                                  ;/*   09|     ## #        #   #######       ####         ###%                            |menu_14 # */
 21235                                  ;/*   10|     ## #        #   #######       ####         ###%                            |          */
 21236                                  ;/*   11|     ## #        #   #######       ####         ###%                            |          */
 21237                                  ;/*   12|     ## #        #   #######       ####         ###%                            |          */
 21238                                  ;/*   13|                                                                                |          */
 21239                                  ;/*   14|    Total disk space is #### Mbytes (1 Mbyte = 1048576 bytes)                   |menu_15 # */
 21240                                  ;/*   15|                                                                                |          */
 21241                                  ;/*   16|                                                                                |          */
 21242                                  ;/*   17|    The Extended DOS partition contains Logical DOS Drives.                     |menu_36   */
 21243                                  ;/*   18|    Do you want to display the logical drive information (Y/N)......? [Y]       |menu_36   */
 21244                                  ;/*   19|                                                                                |          */
 21245                                  ;/*   20|                                                                                |          */
 21246                                  ;/*   21|                                                                                |          */
 21247                                  ;/*   22|                                                                                |          */
 21248                                  ;/*   23|                                                                                |          */
 21249                                  ;/*   24|    Press ESC to return to FDISK Options                                        |menu_11   */
 21250                                  ;/*   ------------------------------------------------------------------------------------          */
 21251                                  ;/*                                                                                                 */
 21252                                  ;/***************************************************************************************************/
 21253                                  
 21254                                  ; ----------------------------------------------------------------------------
 21255                                  ; fdisk.c (FDISK, MSDOS 6.0, 1991)	
 21256                                  ; ----------------------------------------------------------------------------
 21257                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 16/12/2018)
 21258                                  
 21259                                  ;/*  */
 21260                                  ;/******************* START OF SPECIFICATIONS *******************/
 21261                                  ;/*                                                             */
 21262                                  ;/* SUBROUTINE NAME: DISPLAY_PARTITION_INFORMATION              */
 21263                                  ;/*                                                             */
 21264                                  ;/* DESCRIPTIVE NAME: Display partition information             */
 21265                                  ;/*                                                             */
 21266                                  ;/* FUNCTION: Displays defined partition information and prompt */
 21267                                  ;/*           user to display disk volumes if they exist        */
 21268                                  ;/*                                                             */
 21269                                  ;/* NOTES:                                                      */
 21270                                  ;/*                                                             */
 21271                                  ;/*        The following screen is managed                      */
 21272                                  ;/*                                                             */
 21273                                  ;/*     |0000000000111111111122222222223333333333|              */
 21274                                  ;/*     |0123456789012345678901234567890123456789|              */
 21275                                  ;/*   --|----------------------------------------|              */
 21276                                  ;/*   00|                                        |              */
 21277                                  ;/*   01|                                        |              */
 21278                                  ;/*   02|                                        |              */
 21279                                  ;/*   03|                                        |              */
 21280                                  ;/*   04|Display Partition Information           |              */
 21281                                  ;/*   05|                                        |              */
 21282                                  ;/*   06|Current Fixed Disk Drive: #             |              */
 21283                                  ;/*   07|                                        |              */
 21284                                  ;/*   08|Partition Status   Type  Start  End Size|              */
 21285                                  ;/*   09|    #        #   #######  #### #### ####|              */
 21286                                  ;/*   10|                                        |              */
 21287                                  ;/*   11|                                        |              */
 21288                                  ;/*   12|                                        |              */
 21289                                  ;/*   13|                                        |              */
 21290                                  ;/*   14|Total disk space is #### cylinders.     |              */
 21291                                  ;/*   15|                                        |              */
 21292                                  ;/*   16|                                        |              */
 21293                                  ;/*   17|                                        |              */
 21294                                  ;/*   18|The EXTENDED DOS partition contains DOS |              */
 21295                                  ;/*   19|disk volumes. Do you want to display    |              */
 21296                                  ;/*   20|the volume information............? [Y] |              */
 21297                                  ;/*   21|                                        |              */
 21298                                  ;/*   22|                                        |              */
 21299                                  ;/*   23|Press ESC to return to FDISK Options    |              */
 21300                                  ;/*   --------------------------------------------              */
 21301                                  ;/*                                                             */
 21302                                  ;/* ENTRY POINTS: Display_Partition_Information                 */
 21303                                  ;/*      LINKAGE: display_partition_information ()              */
 21304                                  ;/*          NEAR CALL                                          */
 21305                                  ;/*                                                             */
 21306                                  ;/* INPUT: None                                                 */
 21307                                  ;/*                                                             */
 21308                                  ;/* EXIT-NORMAL: ERROR=FALSE                                    */
 21309                                  ;/*                                                             */
 21310                                  ;/* EXIT-ERROR: ERROR=TRUE                                      */
 21311                                  ;/*             GOTO internal_program_error if invalid input    */
 21312                                  ;/*             returned to this routine                        */
 21313                                  ;/*                                                             */
 21314                                  ;/* EFFECTS: No data directly modified by this routine, but     */
 21315                                  ;/*          child routines will modify data.                   */
 21316                                  ;/*                                                             */
 21317                                  ;/* INTERNAL REFERENCES:                                        */
 21318                                  ;/*   ROUTINES:                                                 */
 21319                                  ;/*      clear_screen                                           */
 21320                                  ;/*      wait_for_ESC                                           */
 21321                                  ;/*      display                                                */
 21322                                  ;/*      table_display                                          */
 21323                                  ;/*      get_yn_input                                           */
 21324                                  ;/*      find_partition_type                                    */
 21325                                  ;/*      display_volume_information                             */
 21326                                  ;/*      internal_program_error                                 */
 21327                                  ;/*                                                             */
 21328                                  ;/* EXTERNAL REFERENCES:                                        */
 21329                                  ;/*   ROUTINES:                                                 */
 21330                                  ;/*                                                             */
 21331                                  ;/******************** END OF SPECIFICATIONS ********************/
 21332                                  
 21333                                  ;/*  */
 21334                                  ;void display_partition_information()
 21335                                  ;
 21336                                  ;BEGIN
 21337                                  ;
 21338                                  ; char   input;
 21339                                  ;
 21340                                  ;    input = c(NUL);
 21341                                  ;    /* Clear_screen */
 21342                                  ;    clear_screen(u(0),u(0),u(24),u(79));
 21343                                  ;
 21344                                  ;    /* Display Header */
 21345                                  ;    display(menu_35);
 21346                                  ;
 21347                                  ;    /* Setup and print current disk */
 21348                                  ;    insert[0] = cur_disk+1+'0';
 21349                                  ;    display(menu_5);
 21350                                  ;
 21351                                  ;    /* Display information */
 21352                                  ;    if (table_display())
 21353                                  ;       BEGIN
 21354                                  ;
 21355                                  ;	/* Setup and print disk space msg */
 21356                                  ;	number_in_msg((XFLOAT)total_mbytes[cur_disk],u(0));
 21357                                  ;	display(menu_15);
 21358                                  ;
 21359                                  ;	/* See if any logical drive stuff to display */
 21360                                  ;	if (find_partition_type(uc(EXTENDED)))
 21361                                  ;	   BEGIN
 21362                                  ;	    /* See if any logical drives exist */
 21363                                  ;	    if (find_logical_drive())
 21364                                  ;	       BEGIN
 21365                                  ;
 21366                                  ;		/* print ESC prompt */
 21367                                  ;		display(menu_11);
 21368                                  ;
 21369                                  ;		/* Prompt to see if they want to see EXTENDED info */
 21370                                  ;		display(menu_36);
 21371                                  ;
 21372                                  ;		/* Get Y/N input, default is YES */
 21373                                  ;		input = get_yn_input(c(Yes),input_row,input_col);
 21374                                  ;		switch(input)
 21375                                  ;		   BEGIN
 21376                                  ;
 21377                                  ;		    case 1:    display_volume_information();
 21378                                  ;			       break;
 21379                                  ;
 21380                                  ;		    case 0:    break;
 21381                                  ;
 21382                                  ;		    case ESC:  break;
 21383                                  ;
 21384                                  ;		    default:   internal_program_error();
 21385                                  ;			       break;
 21386                                  ;		   END
 21387                                  ;	       END
 21388                                  ;	    else
 21389                                  ;		input = wait_for_ESC();
 21390                                  ;	   END
 21391                                  ;	else
 21392                                  ;	    input = wait_for_ESC();
 21393                                  ;       END
 21394                                  ;    else
 21395                                  ;	input = wait_for_ESC();
 21396                                  ;    /* clear the screen before going back to main menu */
 21397                                  ;    clear_screen(u(0),u(0),u(24),u(79));
 21398                                  ;    return;
 21399                                  ;END
 21400                                  
 21401                                  ; IBM PC-DOS 7.0, FDISK.COM (unpacked) Segment 0, Offset 202Ch
 21402                                  
 21403                                  display_partition_information:
 21404 00002DEA 55                      		push	bp
 21405                                  		;mov	bp,sp
 21406                                  		;sub	sp,2
 21407                                  		
 21408                                  		;mov	ax,79
 21409                                  		;push	ax
 21410                                  		;mov	ax,24
 21411                                  		;push	ax
 21412                                  		;sub	ax,ax
 21413                                  		;push	ax
 21414                                  		;push	ax
 21415                                  		;call	clear_screen
 21416                                  		;add	sp,8
 21417                                  
 21418 00002DEB E870E6                  		call	CLS
 21419                                  
 21420                                  		;push	word [menu_35_segment]
 21421 00002DEE 1E                      		push	ds
 21422 00002DEF FF36[519E]              		push	word [menu_35_offset]
 21423 00002DF3 E82EE8                  		call	display
 21424                                  		;pop	bx
 21425                                  		;pop	bx
 21426                                  
 21427                                  		;mov	al,[cur_disk]
 21428                                  		;add	al,'1'
 21429                                  		;mov	[insert],al
 21430                                  		;;push	word [menu_5_segment]
 21431                                  		;push	ds
 21432                                  		;push	word [menu_5_offset]
 21433                                  		;call	display
 21434                                  		;;pop	bx
 21435                                  		;;pop	bx
 21436                                  
 21437 00002DF6 E86400                  		call	display_menu_5 ; 31/12/2018
 21438                                  
 21439 00002DF9 E87B00                  		call	table_display
 21440                                  		;or	al,al
 21441                                  		;jz	short disp_wait_for_esc
 21442 00002DFC 7257                    		jc	short disp_wait_for_esc
 21443                                  		
 21444 00002DFE 29C0                    		sub	ax,ax ; 0
 21445 00002E00 50                      		push	ax
 21446 00002E01 A0[E2CB]                		mov	al,[cur_disk]
 21447                                  		;cbw
 21448                                  		;mov	bx,ax
 21449                                  		;shl	bx,1
 21450 00002E04 D0E0                    		shl	al,1
 21451 00002E06 89C3                    		mov	bx,ax
 21452 00002E08 FFB7[D6A0]              		push	word [total_mbytes+bx]
 21453 00002E0C E8EC01                  		call	number_in_msg
 21454                                  		;pop	bx
 21455                                  		;pop	bx
 21456                                  
 21457                                  		;push	word [menu_15_segment]
 21458 00002E0F 1E                      		push	ds
 21459 00002E10 FF36[139E]              		push	word [menu_15_offset]
 21460 00002E14 E80DE8                  		call	display
 21461                                  		;pop	bx
 21462                                  		;pop	bx
 21463                                  		
 21464 00002E17 B005                    		mov	al,EXTENDED ; 5
 21465                                  		;push	ax
 21466 00002E19 E8A8EF                  		call	find_partition_type
 21467                                  		;pop	bx
 21468                                  		;or	al,al
 21469                                  		;jz	short disp_wait_for_esc
 21470 00002E1C 7237                    		jc	short disp_wait_for_esc
 21471                                  
 21472 00002E1E E80502                  		call	find_logical_drive
 21473                                  		;or	al,al
 21474                                  		;jz	short disp_wait_for_esc
 21475 00002E21 7232                    		jc	short disp_wait_for_esc
 21476                                  
 21477                                  		;;push	word [menu_11_segment]
 21478                                  		;push	ds
 21479                                  		;push	word [menu_11_offset]
 21480                                  		;call	display
 21481                                  		;;pop	bx
 21482                                  		;;pop	bx
 21483                                  
 21484 00002E23 E84800                  		call	display_menu_11 ; 31/12/2018
 21485                                  		
 21486                                  		;push	word [menu_36_segment]
 21487 00002E26 1E                      		push	ds
 21488 00002E27 FF36[539E]              		push	word [menu_36_offset]
 21489 00002E2B E8F6E7                  		call	display
 21490                                  		;pop	bx
 21491                                  		;pop	bx
 21492                                  		
 21493 00002E2E FF36[AAA0]              		push	word [input_col] ; Column for input
 21494 00002E32 FF36[4CA1]              		push	word [input_row] ; Row for input
 21495 00002E36 A0[D9C3]                		mov	al,[Yes] ; 'Y'	; Default input value/char
 21496 00002E39 50                      		push	ax
 21497 00002E3A E81102                  		call	get_yn_input  ; Get YES ('Y'), NO ('N') input
 21498                                  		;add	sp,6
 21499                                  switch_input9:
 21500                                  		;cbw
 21501                                  		;cmp	ax,1Bh
 21502 00002E3D 3C1B                    		cmp	al,1Bh ; ESC key
 21503 00002E3F 7417                    		je	short case_disp_pinf_break
 21504 00002E41 7708                    		ja	short case_disp_pinf_DEF
 21505 00002E43 08C0                    		or	al,al
 21506 00002E45 7411                    		jz	short case_disp_pinf_break ; NO, 'N'
 21507 00002E47 FEC8                    		dec	al
 21508 00002E49 7405                    		jz	short case_disp_pinf_1 ; YES, 'Y'
 21509                                  case_disp_pinf_DEF:
 21510 00002E4B E8CD04                  		call	internal_program_error
 21511 00002E4E EB08                    		jmp	short case_disp_pinf_break
 21512                                  case_disp_pinf_1:
 21513 00002E50 E85C03                  		call	display_volume_information
 21514 00002E53 EB03                    		jmp	short case_disp_pinf_break
 21515                                  disp_wait_for_esc:
 21516 00002E55 E81C03                  		call	wait_for_ESC
 21517                                  case_disp_pinf_break:
 21518                                  		;mov	ax,79
 21519                                  		;push	ax
 21520                                  		;mov	ax,24
 21521                                  		;push	ax
 21522                                  		;sub	ax,ax
 21523                                  		;push	ax
 21524                                  		;push	ax
 21525                                  		;call	clear_screen
 21526                                  		
 21527 00002E58 E803E6                  		call	CLS
 21528                                  
 21529                                  		;mov	sp,bp
 21530 00002E5B 5D                      		pop	bp
 21531 00002E5C C3                      		retn
 21532                                  
 21533                                  display_menu_5:
 21534                                  		; 31/12/2018
 21535 00002E5D A0[E2CB]                		mov	al,[cur_disk]
 21536 00002E60 0431                    		add	al,'1'
 21537 00002E62 A2[F4CC]                		mov	[insert],al
 21538                                  		;push	word [menu_5_segment]
 21539 00002E65 1E                      		push	ds
 21540 00002E66 FF36[FD9D]              		push	word [menu_5_offset]
 21541 00002E6A E8B7E7                  		call	display
 21542                                  		;pop	bx
 21543                                  		;pop	bx
 21544 00002E6D C3                      		retn
 21545                                  
 21546                                  display_menu_11:
 21547                                  		; 31/12/2018
 21548                                  		;push	word [menu_11_segment]
 21549 00002E6E 1E                      		push	ds
 21550 00002E6F FF36[099E]              		push	word [menu_11_offset]
 21551 00002E73 E8AEE7                  		call	display
 21552                                  		;pop	bx
 21553                                  		;pop	bx
 21554 00002E76 C3                      		retn
 21555                                  
 21556                                  ; ----------------------------------------------------------------------------
 21557                                  ; tdisplay.c (FDISK, MSDOS 6.0, 1991)	
 21558                                  ; ----------------------------------------------------------------------------
 21559                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 16/12/2018)
 21560                                  
 21561                                  ;/*  */
 21562                                  ;char table_display()
 21563                                  ;
 21564                                  ;BEGIN
 21565                                  ;
 21566                                  ;    unsigned    i;
 21567                                  ;    unsigned    io;
 21568                                  ;    char       *ThisPartitionType;
 21569                                  ;    char        ThisPartitionLetter[3];
 21570                                  ;    FLAG        partition_found;
 21571                                  ;    char        partition_num;
 21572                                  ;
 21573                                  ;    memset(insert,c(' '),4*38);
 21574                                  ;    io = u(0);
 21575                                  ;
 21576                                  ;    /* Get current drive letters */
 21577                                  ;    get_letters();
 21578                                  ;
 21579                                  ;    /* Sort the partitions */
 21580                                  ;    sort_part_table(c(4));
 21581                                  ;
 21582                                  ;    /* loop thru the partitions, only print stuff if it is there */
 21583                                  ;    partition_found = FALSE;
 21584                                  ;    partition_num = c(0);
 21585                                  ;
 21586                                  ;    for (i=u(0); i < u(4); i++)
 21587                                  ;        BEGIN
 21588                                  ;
 21589                                  ;        if (part_table[cur_disk][sort[i]].sys_id != uc(0))
 21590                                  ;            BEGIN
 21591                                  ;
 21592                                  ;            partition_found = TRUE;
 21593                                  ;
 21594                                  ;            strcpy(ThisPartitionLetter,"  ");
 21595                                  ;            switch(part_table[cur_disk][sort[i]].sys_id)
 21596                                  ;                BEGIN
 21597                                  ;                case DOSNEW:
 21598                                  ;                case DOS16:
 21599                                  ;                case DOS12:
 21600                                  ;                    ThisPartitionType = DOS_part;
 21601                                  ;                    sprintf(ThisPartitionLetter,"%c%c",
 21602                                  ;                            part_table[cur_disk][sort[i]].drive_letter,
 21603                                  ;                            ( part_table[cur_disk][sort[i]].drive_letter == c(' ') ) ? ' ' : ':');
 21604                                  ;                    break;
 21605                                  ;                case EXTENDED:
 21606                                  ;                    ThisPartitionType = EXTENDED_part;
 21607                                  ;                    break;
 21608                                  ;                case BAD_BLOCK:
 21609                                  ;                    ThisPartitionType = BAD_BLOCK_part;
 21610                                  ;                    break;
 21611                                  ;                case XENIX1:
 21612                                  ;                    ThisPartitionType = XENIX_part;
 21613                                  ;                    break;
 21614                                  ;                case XENIX2:
 21615                                  ;                    ThisPartitionType = XENIX_part;
 21616                                  ;                    break;
 21617                                  ;                case PCIX:
 21618                                  ;                    ThisPartitionType = PCIX_part;
 21619                                  ;                    break;
 21620                                  ;                case HPFS:
 21621                                  ;                    ThisPartitionType = HPFS_part;
 21622                                  ;                    break;
 21623                                  ;                case NOVELL:
 21624                                  ;                    ThisPartitionType = NOVELL_part
 21625                                  ;                    break;
 21626                                  ;                case CPM:
 21627                                  ;                    ThisPartitionType = CPM_part;
 21628                                  ;                    break;
 21629                                  ;                default:
 21630                                  ;                    ThisPartitionType = NON_DOS_part;
 21631                                  ;                    break;
 21632                                  ;                END
 21633                                  ;
 21634                                  ;            io += sprintf(&insert[io],"%-2.2s%c%c%-7.7s%-11.11s%4.0d%-8.8s%3.0d%%",
 21635                                  ;                       ThisPartitionLetter,
 21636                                  ;                       partition_num+'1',
 21637                                  ;                       (part_table[cur_disk][sort[i]].boot_ind == uc(0x80)) ? 'A' : ' ',
 21638                                  ;                       ThisPartitionType,
 21639                                  ;                       part_table[cur_disk][sort[i]].vol_label,
 21640                                  ;                       part_table[cur_disk][sort[i]].mbytes_used,
 21641                                  ;                       part_table[cur_disk][sort[i]].system,
 21642                                  ;                       part_table[cur_disk][sort[i]].percent_used);
 21643                                  ;
 21644                                  ;            partition_num++;
 21645                                  ;
 21646                                  ;            END
 21647                                  ;
 21648                                  ;        END
 21649                                  ;
 21650                                  ;    /* Do a clearscreen to erase previous data */
 21651                                  ;    clear_screen(u(8),u(0),u(12),u(79));
 21652                                  ;
 21653                                  ;    if (partition_found) display(menu_14);
 21654                                  ;        else display(status_8);
 21655                                  ;
 21656                                  ;    /* Return true if partitions exist, false otherwise */
 21657                                  ;    if (partition_found) return(TRUE);
 21658                                  ;
 21659                                  ;    return(FALSE);
 21660                                  ;
 21661                                  ;END
 21662                                  
 21663                                  ; IBM PC-DOS 7.0, FDISK.COM (unpacked) Segment 0, Offset 3D20h
 21664                                  
 21665                                  table_display:
 21666                                  
 21667                                  %define td_i                bp-14 ; unsigned int, word
 21668                                  %define partition_num       bp-12 ; char, byte
 21669                                  %define td_io               bp-10 ; unsigned int, word		
 21670                                  %define partition_found	    bp-8  ; flag, byte
 21671                                  %define ThisPartitionType   bp-6  ; word, near pointer
 21672                                  %define ThisPartitionLetter bp-4  ; 4 chars (array), dword
 21673                                  
 21674 00002E77 55                      		push	bp
 21675 00002E78 89E5                    		mov	bp,sp
 21676 00002E7A 83EC0E                  		sub	sp,14
 21677                                  		;push	si
 21678                                  
 21679                                  		;mov	ax,152 ; 4*38
 21680                                  		;push	ax
 21681                                  		;mov	ax,' '
 21682                                  		;push	ax
 21683                                  		;mov	ax,insert
 21684                                  		;push	ax
 21685                                  		;call	memset
 21686                                  		;add	sp,6
 21687                                  
 21688                                  		;push	di
 21689 00002E7D B99800                  		mov	cx,152 ; 4*38
 21690 00002E80 BF[F4CC]                		mov	di,insert
 21691 00002E83 B020                    		mov	al,' '
 21692 00002E85 F3AA                    		rep 	stosb
 21693                                  		;pop	di
 21694                                  				
 21695 00002E87 E856F9                  		call	get_letters
 21696                                  
 21697                                  		;mov	al,4
 21698                                  		;push	ax
 21699                                  
 21700 00002E8A B104                    		mov	cl,4
 21701 00002E8C E816FB                  		call	sort_part_table
 21702                                  		;pop	bx
 21703                                  
 21704                                  		;sub	al,al ; 0
 21705 00002E8F 29C0                    		sub	ax,ax
 21706 00002E91 8846F8                  		mov	[partition_found],al
 21707 00002E94 8846F4                  		mov	[partition_num],al
 21708                                  		;sub	ax,ax
 21709 00002E97 8946F6                  		mov	[td_io],ax ; 0
 21710 00002E9A 8946F2                  		mov	[td_i],ax ; 0
 21711                                  		;jmp	td_16
 21712 00002E9D E9A800                  		jmp	td_17
 21713                                  td_ptype_PRIDOS:
 21714 00002EA0 A1[D89E]                		mov	ax,[PRIDOS]
 21715 00002EA3 8946FA                  		mov	[ThisPartitionType],ax
 21716                                  
 21717                                  		;;mov	al,[cur_disk]
 21718                                  		;;;cbw
 21719                                  		;;;shl	ax,1
 21720                                  		;;;shl	ax,1
 21721                                  		;;shl	al,1
 21722                                  		;;shl	al,1
 21723                                  		;mov	cl,[cur_disk]
 21724                                  		;shl	cl,1
 21725                                  		;shl	cl,1
 21726                                  		;mov	bx,[td_i]
 21727                                  		;;;mov	cx,ax
 21728                                  		;;mov	cl,al
 21729                                  		;mov	al,[sort+bx]
 21730                                  		;;cbw
 21731                                  		;;add	ax,cx
 21732                                  		;add	al,cl
 21733                                  		;;mov	cx,46
 21734                                  		;;imul	cx
 21735                                  		;mov	cl,46
 21736                                  		;mul	cl
 21737                                  		;;mov	bx,ax
 21738                                  		;
 21739                                  		;mov	si,ax ; *=*
 21740                                  
 21741 00002EA6 89DE                    		mov	si,bx ; *=*
 21742                                  
 21743                                  		;cmp	byte [part_table_drive_letter+bx],' '
 21744 00002EA8 80BC[4DC4]20            		cmp	byte [part_table_drive_letter+si],' '
 21745 00002EAD 7505                    		jne	short td_02
 21746 00002EAF B82000                  		mov	ax,' '
 21747 00002EB2 EB03                    		jmp	short td_03
 21748                                  td_02:
 21749 00002EB4 B83A00                  		mov	ax,':'
 21750                                  td_03:
 21751 00002EB7 50                      		push	ax
 21752 00002EB8 8A87[4DC4]              		mov	al,[part_table_drive_letter+bx]
 21753                                  		;cbw
 21754 00002EBC 50                      		push	ax
 21755 00002EBD B8[C06F]                		mov	ax,twochars ; "%c%c"
 21756 00002EC0 50                      		push	ax
 21757 00002EC1 8D46FC                  		lea	ax,[ThisPartitionLetter]
 21758 00002EC4 50                      		push	ax
 21759 00002EC5 E8FDF3                  		call	sprintf
 21760 00002EC8 83C408                  		add	sp,8
 21761                                  td_04:
 21762                                  		;mov	al,[cur_disk]
 21763                                  		;;cbw
 21764                                  		;;shl	ax,1
 21765                                  		;;shl	ax,1
 21766                                  		;shl	al,1
 21767                                  		;shl	al,1
 21768                                  		;mov	bx,[td_i]
 21769                                  		;;mov	cx,ax
 21770                                  		;mov	cl,al
 21771                                  		;mov	al,[sort+bx]
 21772                                  		;;cbw
 21773                                  		;;add	ax,cx
 21774                                  		;add	al,cl
 21775                                  		;mov	cx,46
 21776                                  		;;imul	cx
 21777                                  		;mul	cl
 21778                                  		;;mov	bx,ax
 21779                                  		;mov	si,ax
 21780                                  
 21781 00002ECB 89F3                    		mov	bx,si ; *=*
 21782                                  td_05:
 21783 00002ECD FFB7[36C4]              		push	word [part_table_percent_used+bx]
 21784 00002ED1 81C3[44C4]              		add	bx,part_table_system
 21785 00002ED5 53                      		push	bx
 21786                                  		;mov	bx,ax
 21787                                  		;push	word [part_table_mbytes_used+bx]
 21788 00002ED6 FFB4[34C4]              		push	word [part_table_mbytes_used+si]
 21789                                  		;add	ax,part_table_vol_label
 21790                                  		;push	ax
 21791 00002EDA 89F0                    		mov	ax,si
 21792 00002EDC 05[38C4]                		add	ax,part_table_vol_label
 21793 00002EDF 50                      		push	ax
 21794 00002EE0 FF76FA                  		push	word [ThisPartitionType]
 21795                                  		;cmp	byte [part_table_boot_ind+bx],80h
 21796 00002EE3 80BC[20C4]80            		cmp	byte [part_table_boot_ind+si],80h
 21797 00002EE8 752D                    		jne	short td_13
 21798 00002EEA B84100                  		mov	ax,'A'
 21799 00002EED EB2B                    		jmp	short td_14
 21800                                  td_ptype_EXTENDED:
 21801 00002EEF A1[DC9E]                		mov	ax,[EXTDOS]
 21802                                  td_06:
 21803 00002EF2 8946FA                  		mov	[ThisPartitionType],ax
 21804 00002EF5 89DE                    		mov	si,bx ; *=* ; 16/12/2018
 21805                                  		;jmp	short td_04
 21806 00002EF7 EBD4                    		jmp	short td_05 ; 17/12/2018
 21807                                  td_ptype_TABLE:
 21808 00002EF9 A1[DE9E]                		mov	ax,[TABLE]
 21809 00002EFC EBF4                    		jmp	short td_06
 21810                                  td_ptype_XENIX:
 21811 00002EFE A1[DA9E]                		mov	ax,[XENIX]
 21812 00002F01 EBEF                    		jmp	short td_06
 21813                                  td_ptype_PCIX:
 21814 00002F03 A1[E09E]                		mov	ax,[PCIX]
 21815 00002F06 EBEA                    		jmp	short td_06
 21816                                  ;td_ptype_HPFS:
 21817                                  td_ptype_NTFS:
 21818                                  		;mov	ax,[HPFS]
 21819 00002F08 A1[E29E]                		mov	ax,[NTFS] ; 16/12/2018
 21820 00002F0B EBE5                    		jmp	short td_06
 21821                                  td_ptype_NOVELL:
 21822 00002F0D A1[E49E]                		mov	ax,[NOVELL]
 21823 00002F10 EBE0                    		jmp	short td_06
 21824                                  td_ptype_CPM:
 21825 00002F12 A1[E69E]                		mov	ax,[CPM]
 21826 00002F15 EBDB                    		jmp	short td_06
 21827                                  td_13:
 21828 00002F17 B82000                  		mov	ax,' '
 21829                                  td_14:
 21830 00002F1A 50                      		push	ax
 21831 00002F1B 8A46F4                  		mov	al,[partition_num]
 21832                                  		;cbw
 21833                                  		;add	ax,'1'
 21834 00002F1E 0431                    		add	al,'1'
 21835 00002F20 50                      		push	ax
 21836 00002F21 8D46FC                  		lea	ax,[ThisPartitionLetter]
 21837 00002F24 50                      		push	ax
 21838 00002F25 B8[C56F]                		mov	ax,ptbl_row_format ; "%-2.2s%c%c%-7.7s%-11.11s%4.1d%-8.8s%3.1"...
 21839 00002F28 50                      		push	ax
 21840 00002F29 8B46F6                  		mov	ax,[td_io]
 21841 00002F2C 05[F4CC]                		add	ax,insert
 21842 00002F2F 50                      		push	ax
 21843 00002F30 E892F3                  		call	sprintf
 21844 00002F33 83C414                  		add	sp,20
 21845 00002F36 0146F6                  		add	[td_io],ax
 21846                                  
 21847 00002F39 FE46F4                  		inc	byte [partition_num]
 21848                                  td_15:
 21849 00002F3C FE46F2                  		inc	byte [td_i]
 21850                                  td_16:
 21851 00002F3F 807EF204                		cmp	byte [td_i],4
 21852 00002F43 7203                    		jb	short td_17
 21853 00002F45 E98300                  		jmp	td_29
 21854                                  td_17:
 21855                                  		;mov	al,[cur_disk]
 21856                                  		;;cbw
 21857                                  		;;shl	ax,1
 21858                                  		;;shl	ax,1
 21859                                  		;shl	al,1
 21860                                  		;shl	al,1
 21861                                  		;mov	bx,[td_i]
 21862                                  		;;mov	cx,ax
 21863                                  		;mov	cl,al
 21864 00002F48 8A0E[E2CB]              		mov	cl,[cur_disk]
 21865 00002F4C D0E1                    		shl	cl,1
 21866 00002F4E D0E1                    		shl	cl,1
 21867 00002F50 8B5EF2                  		mov	bx,[td_i]
 21868 00002F53 8A87[F0C3]              		mov	al,[sort+bx]
 21869                                  		;cbw
 21870                                  		;add	ax,cx
 21871 00002F57 00C8                    		add	al,cl
 21872 00002F59 B92E00                  		mov	cx,46
 21873                                  		;imul	cx
 21874 00002F5C F6E1                    		mul	cl
 21875                                  		;mov	si,ax ; *=*
 21876                                  		;mov	bx,si ; *=*
 21877 00002F5E 89C3                    		mov	bx,ax ; *=*
 21878                                  
 21879                                  		;cmp	byte [part_table_sys_id+si],0
 21880 00002F60 80BF[25C4]00            		cmp	byte [part_table_sys_id+bx],0
 21881 00002F65 74D5                    		je	short td_15
 21882                                  
 21883 00002F67 C646F801                		mov	byte [partition_found],1
 21884                                  		
 21885                                  		;;mov	ax,twospace ; "	 "
 21886                                  		;;push	ax
 21887                                  		;;lea	ax,[ThisPartitionLetter]
 21888                                  		;;push	ax
 21889                                  		;;call	strcpy
 21890                                  		;;pop	bx
 21891                                  		;;pop	bx
 21892                                  
 21893 00002F6B BE[BD6F]                		mov	si,twospace
 21894 00002F6E 8D7EFC                  		lea	di,[ThisPartitionLetter]
 21895 00002F71 E8B9ED                  		call	strcpy
 21896                                  
 21897                                  		;mov	al,[cur_disk]
 21898                                  		;;cbw
 21899                                  		;;shl	ax,1
 21900                                  		;;shl	ax,1
 21901                                  		;shl	al,1
 21902                                  		;shl	al,1
 21903                                  		;mov	bx,[td_i]
 21904                                  		;;mov	cx,ax
 21905                                  		;mov	cl,al
 21906                                  		;mov	al,[sort+bx]
 21907                                  		;;cbw
 21908                                  		;;add	ax,cx
 21909                                  		;add	al,cl
 21910                                  		;mov	cx,46
 21911                                  		;;imul	cx
 21912                                  		;mul	cl
 21913                                  		;mov	bx,ax
 21914                                  
 21915 00002F74 8A87[25C4]              		mov	al,[part_table_sys_id+bx]
 21916                                  		;sub	ah,ah
 21917                                  		;dec	ax
 21918 00002F78 FEC8                    		dec	al
 21919 00002F7A 7503                    		jnz	short td_18	; > 01h
 21920 00002F7C E921FF                  		jmp	td_ptype_PRIDOS
 21921                                  td_18:
 21922                                  		;dec	ax
 21923 00002F7F FEC8                    		dec	al
 21924 00002F81 7503                    		jnz	short td_19	; > 02h
 21925 00002F83 E978FF                  		jmp	td_ptype_XENIX
 21926                                  td_19:
 21927                                  		;dec	ax
 21928 00002F86 FEC8                    		dec	al
 21929 00002F88 7503                    		jnz	short td_20	; > 03h
 21930 00002F8A E971FF                  		jmp	td_ptype_XENIX
 21931                                  td_20:
 21932                                  		;dec	ax
 21933 00002F8D FEC8                    		dec	al
 21934 00002F8F 7503                    		jnz	short td_21	; > 04h
 21935 00002F91 E90CFF                  		jmp	td_ptype_PRIDOS
 21936                                  td_21:
 21937                                  		;dec	ax
 21938 00002F94 FEC8                    		dec	al
 21939 00002F96 7503                    		jnz	short td_22	; > 05h
 21940 00002F98 E954FF                  		jmp	td_ptype_EXTENDED
 21941                                  td_22:
 21942                                  		;dec	ax
 21943 00002F9B FEC8                    		dec	al
 21944 00002F9D 7503                    		jnz	short td_23	; > 06h
 21945 00002F9F E9FEFE                  		jmp	td_ptype_PRIDOS
 21946                                  td_23:
 21947                                  		;dec	ax
 21948 00002FA2 FEC8                    		dec	al
 21949 00002FA4 7503                    		jnz	short td_24	; > 07h
 21950                                  		;jmp	td_ptype_HPFS
 21951 00002FA6 E95FFF                  		jmp	td_ptype_NTFS ; 16/12/2018
 21952                                  td_24:
 21953                                  		;sub	ax,5Dh
 21954 00002FA9 2C5D                    		sub	al,5Dh
 21955 00002FAB 7503                    		jnz	short td_25	; > 64h
 21956                                  		;jb	short td_28
 21957                                  		;ja	short td_25
 21958 00002FAD E95DFF                  		jmp	td_ptype_NOVELL
 21959                                  td_25:
 21960                                  		;sub	ax,11h
 21961 00002FB0 2C11                    		sub	al,11h
 21962 00002FB2 7503                    		jnz	short td_26	; > 75h
 21963                                  		;jb	short td_28
 21964                                  		;ja	short td_26
 21965 00002FB4 E94CFF                  		jmp	td_ptype_PCIX
 21966                                  td_26:
 21967                                  		;sub	ax,66h
 21968 00002FB7 2C66                    		sub	al,66h
 21969 00002FB9 7503                    		jnz	short td_27	; > DBh
 21970                                  		;jb	short td_28
 21971                                  		;ja	short td_27
 21972 00002FBB E954FF                  		jmp	td_ptype_CPM
 21973                                  td_27:
 21974                                  		;sub	ax,24h
 21975 00002FBE 2C24                    		sub	al,24h
 21976 00002FC0 7503                    		jnz	short td_28	; <> FFh
 21977 00002FC2 E934FF                  		jmp	td_ptype_TABLE
 21978                                  td_28:
 21979 00002FC5 A1[E89E]                		mov	ax,[NONDOS]
 21980 00002FC8 E927FF                  		jmp	td_06
 21981                                  td_29:
 21982 00002FCB B84F00                  		mov	ax,79
 21983 00002FCE 50                      		push	ax
 21984 00002FCF B80C00                  		mov	ax,12
 21985 00002FD2 50                      		push	ax
 21986 00002FD3 29C0                    		sub	ax,ax
 21987 00002FD5 50                      		push	ax
 21988 00002FD6 B80800                  		mov	ax,8
 21989 00002FD9 50                      		push	ax
 21990 00002FDA E8B9E4                  		call	clear_screen
 21991                                  		;add	sp,8
 21992                                  
 21993 00002FDD 807EF800                		cmp	byte [partition_found],0
 21994 00002FE1 7407                    		je	short td_30
 21995                                  		
 21996                                  		;push	word [menu_14_segment]
 21997 00002FE3 1E                      		push	ds
 21998 00002FE4 FF36[119E]              		push	word [menu_14_offset]
 21999 00002FE8 EB05                    		jmp	short td_31
 22000                                  td_30:
 22001                                  		;push	word [status_8_seg]
 22002 00002FEA 1E                      		push	ds
 22003 00002FEB FF36[799E]              		push	word [status_8_off]
 22004                                  td_31:
 22005 00002FEF E832E6                  		call	display
 22006                                  		;pop	bx
 22007                                  		;pop	bx
 22008                                  
 22009                                  		;cmp	byte [partition_found],0
 22010                                  		;je	short td_32
 22011                                  		;mov	al,1
 22012                                  		;jmp	short td_33
 22013                                  ;td_32:
 22014                                  		;sub	al,al ; 0
 22015                                  
 22016 00002FF2 8A46F8                  		mov	al,[partition_found]
 22017 00002FF5 3C01                    		cmp	al,1	
 22018                                  ;td_33:
 22019                                  		;pop	si
 22020 00002FF7 89EC                    		mov	sp,bp
 22021 00002FF9 5D                      		pop	bp
 22022 00002FFA C3                      		retn
 22023                                  
 22024                                  ; ----------------------------------------------------------------------------
 22025                                  ; display.c (FDISK, MSDOS 6.0, 1991)	
 22026                                  ; ----------------------------------------------------------------------------
 22027                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 16/12/2018)
 22028                                  
 22029                                  ;void number_in_msg(number,start)
 22030                                  ;
 22031                                  ;XFLOAT      number;
 22032                                  ;unsigned    start;
 22033                                  ;
 22034                                  ;BEGIN
 22035                                  ;
 22036                                  ;char    mbytes[32];
 22037                                  ;
 22038                                  ;        /* Divide the space down and get it into decimal */
 22039                                  ;        sprintf(mbytes,"%4.0d",number);
 22040                                  ;        insert[start+0] = mbytes[0];
 22041                                  ;        insert[start+1] = mbytes[1];
 22042                                  ;        insert[start+2] = mbytes[2];
 22043                                  ;        insert[start+3] = mbytes[3];
 22044                                  ;
 22045                                  ;        return;
 22046                                  ;
 22047                                  ;END
 22048                                  
 22049                                  number_in_msg:
 22050                                  		; 16/12/2018
 22051                                  
 22052                                  	;%define numinmsg_mb	bp-32
 22053                                  	%define numinmsg_mb	bp-4	
 22054                                  
 22055                                  	%define numinmsg_num	bp+4
 22056                                  	%define numinmsg_start	bp+6
 22057                                  
 22058 00002FFB 55                      		push	bp
 22059 00002FFC 89E5                    		mov	bp,sp
 22060                                  		;sub	sp,32
 22061 00002FFE 83EC04                  		sub	sp,4
 22062                                  
 22063 00003001 FF7604                  		push	word [numinmsg_num]
 22064 00003004 B8[926F]                		mov	ax,numinmsg_format ; "%4.1d"
 22065 00003007 50                      		push	ax
 22066 00003008 8D46FC                  		lea	ax,[numinmsg_mb]
 22067 0000300B 50                      		push	ax
 22068 0000300C E8B6F2                  		call	sprintf
 22069                                  		;add	sp,6
 22070                                  
 22071 0000300F 8B5E06                  		mov	bx,[numinmsg_start]
 22072                                  
 22073                                  		;mov	al,[numinmsg_mb]
 22074                                  		;mov	[insert+bx],al
 22075                                  		;mov	al,[numinmsg_mb+1]
 22076                                  		;mov	[insert+1+bx],al
 22077                                  		;mov	al,[numinmsg_mb+2]
 22078                                  		;mov	[insert+2+bx],al
 22079                                  		;mov	al,[numinmsg_mb+3]
 22080                                  		;mov	[insert+3+bx],al
 22081                                  
 22082 00003012 8B46FC                  		mov	ax,[numinmsg_mb]
 22083 00003015 8987[F4CC]              		mov	[bx+insert],ax
 22084 00003019 8B46FE                  		mov	ax,[numinmsg_mb+2]
 22085 0000301C 8987[F6CC]              		mov	[bx+insert+2],ax
 22086                                  
 22087 00003020 89EC                    		mov	sp,bp
 22088 00003022 5D                      		pop	bp
 22089                                  		;retn
 22090 00003023 C20400                  		retn	4 ; 17/12/2018
 22091                                  
 22092                                  ; ----------------------------------------------------------------------------
 22093                                  ; partinfo.c (FDISK, MSDOS 6.0, 1991)	
 22094                                  ; ----------------------------------------------------------------------------
 22095                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 16/12/2018)
 22096                                  
 22097                                  ;char find_logical_drive()
 22098                                  ;
 22099                                  ;BEGIN
 22100                                  ;
 22101                                  ;unsigned  char  i;
 22102                                  ;
 22103                                  ;       /* See if there is a logical drive defined in Extended Partition */
 22104                                  ;       for (i = uc(0); i < uc(23);i++)
 22105                                  ;          BEGIN
 22106                                  ;
 22107                                  ;           /* See if we find a sys id that is not 0 */
 22108                                  ;           if (ext_table[cur_disk][i].sys_id != uc(0))
 22109                                  ;              BEGIN
 22110                                  ;               return(TRUE);
 22111                                  ;               break;
 22112                                  ;              END
 22113                                  ;          END
 22114                                  ;        return(FALSE);
 22115                                  ;END
 22116                                  
 22117                                  find_logical_drive:
 22118                                  		; 16/12/2018
 22119                                  
 22120                                  	;%define findlogdrv_i bp-2
 22121                                  	
 22122                                  		;push	bp
 22123                                  		;mov	bp,sp
 22124                                  		;sub	sp,2
 22125                                  		
 22126                                  		;mov	word [findlogdrv_i],0
 22127                                  		;jmp	short findlogdrv_2
 22128                                  		
 22129 00003026 31D2                    		xor	dx,dx
 22130 00003028 EB07                    		jmp	short findlogdrv_3		
 22131                                  findlogdrv_1:
 22132                                  		;inc	byte [findlogdrv_i]
 22133 0000302A FEC2                    		inc	dl
 22134                                  findlogdrv_2:
 22135                                  		;cmp	byte [findlogdrv_i],23
 22136 0000302C 80FA17                  		cmp	dl,23
 22137 0000302F 7319                    		jnb	short findlogdrv_4
 22138                                  findlogdrv_3:
 22139 00003031 B018                    		mov	al,24
 22140                                  		;imul	byte [cur_disk]
 22141 00003033 F626[E2CB]              		mul	byte [cur_disk]
 22142                                  		;mov	cl,[findlogdrv_i]
 22143                                  		;;sub	ch,ch
 22144                                  		;;add	ax,cx
 22145                                  		;add	al,cl
 22146                                  		
 22147 00003037 00D0                    		add	al,dl
 22148                                  		
 22149                                  		;mov	cx,46
 22150                                  		;imul	cx
 22151                                  		
 22152 00003039 B12E                    		mov	cl,46
 22153 0000303B F6E1                    		mul	cl
 22154 0000303D 89C3                    		mov	bx,ax
 22155 0000303F 80BF[5DA1]00            		cmp	byte [ext_table_sys_id+bx],0
 22156 00003044 74E4                    		je	short findlogdrv_1
 22157 00003046 B001                    		mov	al,1
 22158 00003048 EB03                    		jmp	short findlogdrv_5 ; cf = 0
 22159                                  findlogdrv_4:
 22160 0000304A 28C0                    		sub	al,al
 22161 0000304C F9                      		stc
 22162                                  findlogdrv_5:
 22163                                  		;mov	sp,bp
 22164                                  		;pop	bp
 22165 0000304D C3                      		retn
 22166                                  
 22167                                  ; ----------------------------------------------------------------------------
 22168                                  ; input.c (FDISK, MSDOS 6.0, 1991)	
 22169                                  ; ----------------------------------------------------------------------------
 22170                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 16/12/2018)
 22171                                  
 22172                                  ;/*  */
 22173                                  ;
 22174                                  ;char get_yn_input(input_default,row,col)
 22175                                  ;
 22176                                  ;unsigned        row;
 22177                                  ;unsigned        col;
 22178                                  ;char            input_default;
 22179                                  ;
 22180                                  ;BEGIN
 22181                                  ;
 22182                                  ;    char   input;
 22183                                  ;    char   default_used;
 22184                                  ;    char   input_value;
 22185                                  ;
 22186                                  ;    char   attribute;
 22187                                  ;    char far *attribute_ptr = &attribute;
 22188                                  ;    char far *input_ptr = &input;
 22189                                  
 22190                                  ;    if (mono_flag == TRUE)
 22191                                  ;/*C09   attribute = GRAY_ON_BLACK;  */
 22192                                  ;        attribute = HIWHITE_ON_BLACK; /*C09*/
 22193                                  ;    else
 22194                                  ;/*C09   attribute = WHITE_ON_BLUE;  */
 22195                                  ;        attribute = HIWHITE_ON_BLUE;  /*C09*/
 22196                                  ;
 22197                                  ;    /* print default entry if there is one */
 22198                                  ;    if (input_default != c(NUL))
 22199                                  ;
 22200                                  ;        BEGIN
 22201                                  ;        default_used = TRUE;
 22202                                  ;        /* position the cursor */
 22203                                  ;        VIOSETCURPOS(row,col,u(0));
 22204                                  ;
 22205                                  ;        /* Display the default character */
 22206                                  ;		 input = input_default;
 22207                                  ;		 VIOWRTCHARSTRATT(input_ptr,u(1),row,col,attribute_ptr,u(0));
 22208                                  ;        END
 22209                                  ;
 22210                                  ;    /* Assume bad input */
 22211                                  ;    valid_input = FALSE;
 22212                                  ;
 22213                                  ;    /* Loop until we get good stuff */
 22214                                  ;    while (valid_input == FALSE)
 22215                                  ;        BEGIN
 22216                                  ;
 22217                                  ;        /* position the cursor */
 22218                                  ;        VIOSETCURPOS(row,col,u(0));
 22219                                  ;
 22220                                  ;        /* Flush the keyboard buffer and get the next pressed key */
 22221                                  ;        input = get_char_input();
 22222                                  ;        input = dos_upper(input);
 22223                                  ;
 22224                                  ;        /* Go handle different inputs */
 22225                                  ;        switch(input)
 22226                                  ;            BEGIN
 22227                                  ;            case ESC:
 22228                                  ;                BEGIN
 22229                                  ;                valid_input = TRUE;
 22230                                  ;                break;
 22231                                  ;                END
 22232                                  ;
 22233                                  ;            case  CR:
 22234                                  ;                BEGIN
 22235                                  ;                /* Set the input to the default if there is one there */
 22236                                  ;                if (default_used)
 22237                                  ;                    BEGIN
 22238                                  ;                    if (input_default != c(NUL))
 22239                                  ;                        BEGIN
 22240                                  ;                        input_value = input_default;
 22241                                  ;                        END
 22242                                  ;                    else
 22243                                  ;                        BEGIN
 22244                                  ;                        internal_program_error();
 22245                                  ;                        END
 22246                                  ;                    END
 22247                                  ;
 22248                                  ;                /* See if YES or NO */
 22249                                  ;
 22250                                  ;                /* Do world trade get country information */
 22251                                  ;                input = check_yn_input(input_value);
 22252                                  ;
 22253                                  ;                if ((input == c(1)) || (input == c(0)))
 22254                                  ;                    BEGIN
 22255                                  ;                    valid_input = TRUE;
 22256                                  ;                    END
 22257                                  ;                else
 22258                                  ;                    BEGIN
 22259                                  ;                    /* Setup error message */
 22260                                  ;                    insert[0] = c(Yes);
 22261                                  ;                    insert[1] = c('-');
 22262                                  ;                    insert[2] = c(No);
 22263                                  ;                    display(error_31);
 22264                                  ;                    END
 22265                                  ;                break;
 22266                                  ;                END
 22267                                  ;
 22268                                  ;            default:
 22269                                  ;                BEGIN
 22270                                  ;                if ((check_yn_input(input) == c(1)) ||             /*C16*/
 22271                                  ;                    (check_yn_input(input) == c(0)))               /*C16*/
 22272                                  ;                    clear_screen(u(23),u(0),u(23),u(79));          /*C16*/
 22273                                  ;                else                                               /*C16*/
 22274                                  ;                    {                                              /*C16*/
 22275                                  ;                    /* Setup error message */                      /*C16*/
 22276                                  ;                    insert[0] = c(Yes);                            /*C16*/
 22277                                  ;                    insert[1] = c('-');                            /*C16*/
 22278                                  ;                    insert[2] = c(No);                             /*C16*/
 22279                                  ;                    display(error_31);                             /*C16*/
 22280                                  ;                    input = c(' ');                                /*C16*/
 22281                                  ;                    }                                              /*C16*/
 22282                                  ;                VIOWRTCHARSTRATT(input_ptr,u(1),row,col,attribute_ptr,u(0)); /*C16*/
 22283                                  ;                default_used = FALSE;
 22284                                  ;                input_value = input;
 22285                                  ;                break;
 22286                                  ;                END
 22287                                  ;            END
 22288                                  ;         END
 22289                                  ;     return(input);
 22290                                  ;END
 22291                                  
 22292                                  get_yn_input:
 22293                                  		; 16/12/2018
 22294                                  
 22295                                  	%define gyn_input_val	bp-16 ; byte, char 
 22296                                  	%define gyn_attr_ptr	bp-14 ; dword, far ptr
 22297                                  	%define gyn_def_used	bp-10 ; byte, char
 22298                                  	%define gyn_input_ptr	bp-8  ; dword, far ptr
 22299                                  	%define gyn_attribute	bp-4  ; byte, char
 22300                                  	%define gyn_input	bp-2  ; byte, char
 22301                                  	%define gyn_input_def	bp+4  ; byte, char 
 22302                                  	%define gyn_row		bp+6  ; word, unsigned int
 22303                                  	%define gyn_column	bp+8  ; word, unsigned int
 22304                                  
 22305 0000304E 55                      		push	bp
 22306 0000304F 89E5                    		mov	bp,sp
 22307 00003051 83EC10                  		sub	sp,16
 22308                                  
 22309 00003054 8D46FC                  		lea	ax,[gyn_attribute]
 22310 00003057 8946F2                  		mov	[gyn_attr_ptr],ax
 22311 0000305A 8C56F4                  		mov	[gyn_attr_ptr+2],ss
 22312 0000305D 8D4EFE                  		lea	cx,[gyn_input]
 22313 00003060 894EF8                  		mov	[gyn_input_ptr],cx
 22314 00003063 8C56FA                  		mov	[gyn_input_ptr+2],ss
 22315                                  
 22316 00003066 803E[D8C3]01            		cmp	byte [mono_flag],1 ; TRUE
 22317 0000306B 7506                    		jne	short gyni_1
 22318 0000306D C646FC0F                		mov	byte[gyn_attribute],0Fh  ; HIWHITE_ON_BLACK
 22319 00003071 EB04                    		jmp	short gyni_2
 22320                                  gyni_1:
 22321 00003073 C646FC1F                		mov	byte [gyn_attribute],1Fh ; HIWHITE_ON_BLUE
 22322                                  gyni_2:
 22323 00003077 807E0400                		cmp	byte [gyn_input_def],0
 22324 0000307B 7428                    		je	short gyni_3
 22325                                  
 22326                                  		;mov	[gyn_def_used],1
 22327                                  
 22328                                  		;push	word [gyn_row]
 22329                                  		;push	word [gyn_column]
 22330                                  		;sub	ax,ax
 22331                                  		;push	ax
 22332 0000307D 8A7606                  		mov	dh,[gyn_row]
 22333 00003080 8A5608                  		mov	dl,[gyn_column]
 22334 00003083 E89AFB                  		call	VIOSETCURPOS
 22335                                  
 22336 00003086 8A4604                  		mov	al,[gyn_input_def]
 22337 00003089 8846FE                  		mov	[gyn_input],al
 22338 0000308C FF76FA                  		push	word [gyn_input_ptr+2]
 22339 0000308F FF76F8                  		push	word [gyn_input_ptr]
 22340 00003092 B80100                  		mov	ax,1
 22341 00003095 50                      		push	ax
 22342 00003096 FF7606                  		push	word [gyn_row]
 22343 00003099 FF7608                  		push	word [gyn_column]
 22344 0000309C FF76F4                  		push	word [gyn_attr_ptr+2]
 22345 0000309F FF76F2                  		push	word [gyn_attr_ptr]
 22346                                  		;sub	ax,ax
 22347                                  		;push	ax
 22348 000030A2 E83EE8                  		call	VIOWRTCHARSTRATT
 22349                                  gyni_3:
 22350 000030A5 C606[ECCB]00            		mov	byte [valid_input],0
 22351                                  gyni_4:
 22352                                  		;push	word [gyn_row]
 22353                                  		;push	word [gyn_column]
 22354                                  		;sub	ax,ax
 22355                                  		;push	ax
 22356 000030AA 8A7606                  		mov	dh,[gyn_row]
 22357 000030AD 8A5608                  		mov	dl,[gyn_column]
 22358 000030B0 E86DFB                  		call	VIOSETCURPOS
 22359                                  
 22360 000030B3 E85DFB                  		call	get_char_input
 22361                                  		;mov	[gyn_input], al
 22362                                  		
 22363                                  		;push	ax
 22364 000030B6 E87FFB                  		call	dos_upper
 22365                                  		;pop	bx
 22366 000030B9 8846FE                  		mov	[gyn_input],al
 22367                                  switch_input11:
 22368                                  		;cbw
 22369                                  		;sub	ax,0Dh
 22370 000030BC 2C0D                    		sub	al,0Dh
 22371 000030BE 741D                    		jz	short case_gyni_CR
 22372                                  		;sub	ax,0Eh
 22373 000030C0 2C0E                    		sub	al,0Eh
 22374 000030C2 743B                    		jz	short case_gyni_ESC
 22375                                  case_gyni_DEF:
 22376                                  		; Check if character represents country relative
 22377                                  		; Yes or No response 
 22378                                  
 22379                                  		;mov	al,[gyn_input]
 22380                                  		;push	ax
 22381                                  		;call	check_yn_input
 22382                                  		;pop	bx
 22383                                  		;dec	al
 22384                                  		;jz	short gyni_7  ; al = 1 = YES
 22385                                  
 22386                                  		;cmp	al,1
 22387                                  		;ja	short gyni_13 ; al = 2 = not a valid YES or NO character
 22388                                  
 22389                                  		;mov	al,[gyn_input]
 22390                                  		;;push	ax
 22391                                  		;call	check_yn_input
 22392                                  		;;pop	bx
 22393                                  		;or	al,al
 22394                                  		;jnz	short gyni_13
 22395                                  
 22396 000030C4 8A56FE                  		mov	dl,[gyn_input]
 22397 000030C7 E8D600                  		call	check_yn_input
 22398 000030CA 7255                    		jc	short gyni_13
 22399                                  gyni_7:
 22400 000030CC B84F00                  		mov	ax,79
 22401 000030CF 50                      		push	ax
 22402 000030D0 B81700                  		mov	ax,23
 22403 000030D3 50                      		push	ax
 22404 000030D4 29C9                    		sub	cx,cx
 22405 000030D6 51                      		push	cx
 22406 000030D7 50                      		push	ax
 22407 000030D8 E8BBE3                  		call	clear_screen
 22408                                  		;add	sp,8
 22409 000030DB EB61                    		jmp	short gyni_14
 22410                                  case_gyni_CR:
 22411 000030DD 807EF600                		cmp	byte [gyn_def_used],0
 22412 000030E1 7411                    		je	short gyni_10
 22413 000030E3 807E0400                		cmp	byte [gyn_input_def],0
 22414 000030E7 7408                    		je	short gyni_9
 22415 000030E9 8A4604                  		mov	al,[gyn_input_def]
 22416 000030EC 8846F0                  		mov	[gyn_input_val],al
 22417 000030EF EB03                    		jmp	short gyni_10
 22418                                  gyni_9:
 22419 000030F1 E82702                  		call	internal_program_error
 22420                                  gyni_10:
 22421                                  		;mov	al,[gyn_input_val]
 22422                                  		;push	ax
 22423                                  		;call	check_yn_input
 22424                                  		;pop	bx
 22425                                  		;mov	[gyn_input],al
 22426                                  		;cmp	al,1
 22427                                  		;je	short case_gyni_ESC
 22428                                  		;or	al,al
 22429                                  		;jnz	short gyni_12
 22430                                  		
 22431 000030F4 8A56F0                  		mov	dl,[gyn_input_val]
 22432 000030F7 E8A600                  		call	check_yn_input
 22433 000030FA 720A                    		jc	short gyni_12
 22434 000030FC 8846FE                  		mov	[gyn_input],al
 22435                                  case_gyni_ESC:
 22436 000030FF C606[ECCB]01            		mov	byte [valid_input],1
 22437                                  		;jmp	short gyni_15
 22438 00003104 EB65                    		jmp	short gyni_16
 22439                                  gyni_12:
 22440 00003106 A0[D9C3]                		mov	al,[Yes]
 22441 00003109 A2[F4CC]                		mov	[insert],al
 22442 0000310C C606[F5CC]2D            		mov	byte [insert+1],'-'
 22443 00003111 A0[ACA0]                		mov	al,[No]
 22444 00003114 A2[F6CC]                		mov	[insert+2],al
 22445                                  		;push	word [error_31_seg]
 22446 00003117 1E                      		push	ds
 22447 00003118 FF36[BC9E]              		push	word [error_31_off]
 22448 0000311C E805E5                  		call	display
 22449                                  		;pop	bx
 22450                                  		;pop	bx
 22451                                  		
 22452                                  		;jmp	short gyni_15
 22453 0000311F EB89                    		jmp	short gyni_4
 22454                                  gyni_13:
 22455 00003121 A0[D9C3]                		mov	al,[Yes]
 22456 00003124 A2[F4CC]                		mov	[insert],al
 22457 00003127 C606[F5CC]2D            		mov	byte [insert+1],'-'
 22458 0000312C A0[ACA0]                		mov	al,[No]
 22459 0000312F A2[F6CC]                		mov	[insert+2],al
 22460                                  		;push	word [error_31_seg]
 22461 00003132 1E                      		push	ds
 22462 00003133 FF36[BC9E]              		push	word [error_31_off]
 22463 00003137 E8EAE4                  		call	display
 22464                                  		;pop	bx
 22465                                  		;pop	bx
 22466 0000313A C646FE20                		mov	byte [gyn_input],' ' ; 20h
 22467                                  gyni_14:
 22468 0000313E FF76FA                  		push	word [gyn_input_ptr+2]
 22469 00003141 FF76F8                  		push	word [gyn_input_ptr]
 22470 00003144 B80100                  		mov	ax,1
 22471 00003147 50                      		push	ax
 22472 00003148 FF7606                  		push	word [gyn_row]
 22473 0000314B FF7608                  		push	word [gyn_column]
 22474 0000314E FF76F4                  		push	word [gyn_attr_ptr+2]
 22475 00003151 FF76F2                  		push	word [gyn_attr_ptr]
 22476                                  		;sub	ax,ax
 22477                                  		;push	ax
 22478 00003154 E88CE7                  		call	VIOWRTCHARSTRATT
 22479                                  		
 22480 00003157 C646F600                		mov	byte [gyn_def_used],0
 22481 0000315B 8A46FE                  		mov	al,[gyn_input]
 22482 0000315E 8846F0                  		mov	[gyn_input_val],al
 22483                                  gyni_15:
 22484 00003161 803E[ECCB]00            		cmp	byte [valid_input],0
 22485 00003166 7503                    		jne	short gyni_16
 22486 00003168 E93FFF                  		jmp	gyni_4
 22487                                  gyni_16:
 22488 0000316B 8A46FE                  		mov	al,[gyn_input]
 22489 0000316E 89EC                    		mov	sp,bp
 22490 00003170 5D                      		pop	bp
 22491                                  		;retn
 22492 00003171 C20600                  		retn	6 ; 17/12/2018
 22493                                  
 22494                                  ; input.c - wait_for_ESC
 22495                                  ; ----------------------------------------------------------------------------
 22496                                  
 22497                                  ;char wait_for_ESC()
 22498                                  ;
 22499                                  ;BEGIN
 22500                                  ;    char  input;
 22501                                  ;
 22502                                  ;    clear_screen(u(24),u(0),u(24),u(79));
 22503                                  ;    display(menu_46);
 22504                                  ;    while (input != c(ESC))
 22505                                  ;        BEGIN
 22506                                  ;        /* position the cursor at the end of the ESC prompt */
 22507                                  ;        VIOSETCURPOS(input_row,input_col,u(0));
 22508                                  ;
 22509                                  ;        /* Get input */
 22510                                  ;        input = get_char_input();
 22511                                  ;        END
 22512                                  ;    return(c(ESC));
 22513                                  ;END
 22514                                  
 22515                                  wait_for_ESC:
 22516                                  		; 16/12/2018
 22517                                  
 22518                                  		;%define wfesc_input bp-2
 22519                                  
 22520                                  		;push	bp
 22521                                  		;mov	bp,sp
 22522                                  		;sub	sp,2
 22523                                  
 22524                                  		; 17/12/2018
 22525 00003174 B84F00                  		mov	ax,79
 22526 00003177 50                      		push	ax	; Bottom Rigth Column (79)  
 22527 00003178 B81800                  		mov	ax,24
 22528 0000317B 50                      		push	ax	; Bottom Row (24)
 22529 0000317C 29C9                    		sub	cx,cx
 22530 0000317E 51                      		push	cx	; Top Left Column (0)	
 22531 0000317F 50                      		push	ax	; Top Row (24)
 22532 00003180 E813E3                  		call	clear_screen  ;	clear row
 22533                                  		;add	sp,8
 22534                                  
 22535                                  		;push	word [menu_46_segment]
 22536 00003183 1E                      		push	ds
 22537 00003184 FF36[1D9E]              		push	word [menu_46_offset]
 22538 00003188 E899E4                  		call	display
 22539                                  		;pop	bx
 22540                                  		;pop	bx
 22541 0000318B EB0E                    		jmp	short wfesc_2
 22542                                  wfesc_1:
 22543                                  		;push	word [input_row]
 22544                                  		;push	word [input_col]
 22545                                  		;sub	ax,ax
 22546                                  		;push	ax
 22547 0000318D 8A36[4CA1]              		mov	dh,[input_row]
 22548 00003191 8A16[AAA0]              		mov	dl,[input_col]
 22549 00003195 E888FA                  		call	VIOSETCURPOS
 22550                                  		
 22551 00003198 E878FA                  		call	get_char_input
 22552                                  		;mov	[wfesc_input],al
 22553                                  wfesc_2:
 22554                                  		;cmp	[wfesc_input],1Bh ; ESC key
 22555                                  		;jne	short wfesc_1
 22556                                  		;mov	al,1Bh
 22557                                  
 22558 0000319B 3C1B                    		cmp	al,1Bh ; ESC key
 22559 0000319D 75EE                    		jne	short wfesc_1
 22560                                  
 22561                                  		;mov	sp,bp
 22562                                  		;pop	bp
 22563                                  		
 22564 0000319F C3                      		retn
 22565                                  
 22566                                  ; ----------------------------------------------------------------------------
 22567                                  ; convert.c (FDISK, MSDOS 6.0, 1991)	
 22568                                  ; ----------------------------------------------------------------------------
 22569                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 16/12/2018)
 22570                                  
 22571                                  ;/***************************************************************************/
 22572                                  ;/*Routine name:  CHECK_YN_INPUT                                            */
 22573                                  ;/***************************************************************************/
 22574                                  ;/*                                                                         */
 22575                                  ;/*Description:   Get single character input, which must be a country       */
 22576                                  ;/*               dependent (Y/N). Will be verified using new uppercase     */
 22577                                  ;/*               table function calls. Will accept default value.          */
 22578                                  ;/*                                                                         */
 22579                                  ;/*Called Procedures:                                                       */
 22580                                  ;/*                                                                         */
 22581                                  ;/*                                                                         */
 22582                                  ;/*Change History: Updated        5/31/87         DRM                       */
 22583                                  ;/*                                                                         */
 22584                                  ;/*Input: input_value                                                       */
 22585                                  ;/*                                                                         */
 22586                                  ;/*Output: input                                                            */
 22587                                  ;/*        valid_input                                                      */
 22588                                  ;/*                                                                         */
 22589                                  ;/***************************************************************************/
 22590                                  
 22591                                  ;char check_yn_input(input_value)
 22592                                  ;
 22593                                  ;        char   input_value;
 22594                                  ;
 22595                                  ;BEGIN
 22596                                  ;        char   input;
 22597                                  ;
 22598                                  ;        /* Get extended country information */
 22599                                  ;        regs.x.ax = (unsigned)CAP_YN;
 22600                                  ;        /* Move input_value to register DL  */
 22601                                  ;        regs.h.dl = (unsigned char)input_value;
 22602                                  ;        int86((int)INT21,&regs,&regs);
 22603                                  ;
 22604                                  ;        /* check carry flag for error */
 22605                                  ;        if ((regs.x.cflag & CARRY_FLAG) == CARRY_FLAG)
 22606                                  ;        /* input will be 0 for NO and 1 for YES in AX */
 22607                                  ;           input = c(NO_GOOD);    /* input will equal not 0 or 1 */
 22608                                  ;        else
 22609                                  ;           input = c(regs.x.ax);
 22610                                  ;
 22611                                  ;        return(input);
 22612                                  ;END
 22613                                  
 22614                                  check_yn_input:
 22615                                  		; 16/12/2018
 22616                                  
 22617                                  	%define	yn_input bp-2
 22618                                  	%define yn_input_value bp+4
 22619                                  
 22620                                  		;push	bp
 22621                                  		;mov	bp,sp
 22622                                  		;sub	sp,2
 22623                                  
 22624                                  		;mov	[regs_x_ax],6523h
 22625                                  		;mov	al,[yn_input_value]
 22626                                  		;mov	[regs_x_dx],al
 22627                                  		;mov	ax,regs
 22628                                  		;push	ax
 22629                                  		;push	ax
 22630                                  		;mov	ax,21h
 22631                                  		;push	ax
 22632                                  		;call	int86
 22633                                  		;add	sp,6
 22634                                  		;mov	al,[regs_x_cflag]
 22635                                  		;and	al,1
 22636                                  		;cmp	al,1
 22637                                  		;jnz	short cyni_1
 22638                                  		;mov	byte [yn_input],2
 22639                                  		;jmp	short cyni_2
 22640                                  ;cyni_1:
 22641                                  		;mov	al,[regs_x_ax]
 22642                                  		;mov	[yn_input],al
 22643                                  ;cyni_2:	
 22644                                  		;mov	al,[yn_input]
 22645                                  		;mov	sp,bp
 22646                                  		;pop	bp
 22647                                  		;retn
 22648                                  
 22649                                  		; INT 21h
 22650                                  		;   INPUT:
 22651                                  		;      AH = 65h 
 22652                                  		;	    Get Extended Country Information (DOS 3.3+)
 22653                                  		;      AL = 23h
 22654                                  		;	    Determine if character represents 
 22655                                  		;	    country relative Yes or No response (DOS 4+)
 22656                                  		;
 22657                                  		;      DL = Character to be tested
 22658                                  		;			
 22659                                  		;   OUTPUT:
 22660                                  		;      AX = error code if CF is set
 22661                                  	  	;	  = 00h : NO response
 22662                                  	   	;	  = 01h : YES response
 22663                                  	  	;	  = 02h : not a yes or no response
 22664                                  
 22665                                  		;mov	dl,al
 22666                                  
 22667 000031A0 B82365                  		mov	ax,6523h
 22668 000031A3 CD21                    		int	21h
 22669 000031A5 7207                    		jc	short cyni_1
 22670 000031A7 08C0                    		or	al,al
 22671 000031A9 7403                    		jz	short cyni_1
 22672 000031AB 3C02                    		cmp	al,2
 22673 000031AD F5                      		cmc	
 22674                                  cyni_1:
 22675 000031AE C3                      		retn
 22676                                  
 22677                                  ; ============================================================================
 22678                                  ;  DISPLAY VOLUME INFORMATION
 22679                                  ; ============================================================================
 22680                                  ; 16/12/2018
 22681                                  
 22682                                  ; fdisk.msg (MSDOS 6.0)
 22683                                  ;/***************************************************************************************************/
 22684                                  ;/*  Screen for DISPLAY_VOLUME_INFORMATION                                                          */
 22685                                  ;/*                                                                                                 */
 22686                                  ;/*     |00000000001111111111222222222233333333334444444444555555555566666666667777777777|          */
 22687                                  ;/*     |01234567890123456789012345678901234567890123456789012345678901234567890123456789|          */
 22688                                  ;/*   --|--------------------------------------------------------------------------------|          */
 22689                                  ;/*   00|                                                                                |          */
 22690                                  ;/*   01|                     Display Logical DOS Drive Information                      |menu_37   */
 22691                                  ;/*   02|                                                                                |          */
 22692                                  ;/*   03|Drv Volume Label  Mbytes  System  Usage  Drv Volume Label  Mbytes  System  Usage|menu_19/20*/
 22693                                  ;/*   04|##  #############  ####  ########  ###%  ##  #############  ####  ########  ###%|          */
 22694                                  ;/*   05|##  #############  ####  ########  ###%  ##  #############  ####  ########  ###%|          */
 22695                                  ;/*   16|##  #############  ####  ########  ###%  ##  #############  ####  ########  ###%|          */
 22696                                  ;/*   17|##  #############  ####  ########  ###%  ##  #############  ####  ########  ###%|          */
 22697                                  ;/*   18|##  #############  ####  ########  ###%  ##  #############  ####  ########  ###%|          */
 22698                                  ;/*   19|##  #############  ####  ########  ###%  ##  #############  ####  ########  ###%|          */
 22699                                  ;/*   10|##  #############  ####  ########  ###%  ##  #############  ####  ########  ###%|          */
 22700                                  ;/*   11|##  #############  ####  ########  ###%  ##  #############  ####  ########  ###%|          */
 22701                                  ;/*   12|##  #############  ####  ########  ###%  ##  #############  ####  ########  ###%|          */
 22702                                  ;/*   13|##  #############  ####  ########  ###%  ##  #############  ####  ########  ###%|          */
 22703                                  ;/*   14|##  #############  ####  ########  ###%  ##  #############  ####  ########  ###%|          */
 22704                                  ;/*   15|##  #############  ####  ########  ###%                                         |          */
 22705                                  ;/*   16|                                                                                |          */
 22706                                  ;/*   17|    Total Extended DOS partition size is #### Mbytes (1 Mbyte = 1048576 bytes)  |menu_17   */
 22707                                  ;/*   18|                                                                                |          */
 22708                                  ;/*   19|                                                                                |          */
 22709                                  ;/*   20|                                                                                |          */
 22710                                  ;/*   21|                                                                                |          */
 22711                                  ;/*   22|                                                                                |          */
 22712                                  ;/*   23|                                                                                |          */
 22713                                  ;/*   24|    Press ESC to return to FDISK Options                                        |menu_11   */
 22714                                  ;/*   ------------------------------------------------------------------------------------          */
 22715                                  ;/*                                                                                                 */
 22716                                  ;/***************************************************************************************************/
 22717                                  
 22718                                  ; ----------------------------------------------------------------------------
 22719                                  ; fdisk.c (FDISK, MSDOS 6.0, 1991)	
 22720                                  ; ----------------------------------------------------------------------------
 22721                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 17/12/2018)
 22722                                  
 22723                                  ;/*  */
 22724                                  ;/******************* START OF SPECIFICATIONS *******************/
 22725                                  ;/*                                                             */
 22726                                  ;/* SUBROUTINE NAME: DISPLAY_VOLUME_INFORMATION                 */
 22727                                  ;/*                                                             */
 22728                                  ;/* DESCRIPTIVE NAME: Display DOS disk Volume Information       */
 22729                                  ;/*                                                             */
 22730                                  ;/* FUNCTION: Displays disk volume size and existence           */
 22731                                  ;/*                                                             */
 22732                                  ;/* NOTES:                                                      */
 22733                                  ;/*                                                             */
 22734                                  ;/*        The following screen is managed                      */
 22735                                  ;/*                                                             */
 22736                                  ;/*     |0000000000111111111122222222223333333333|              */
 22737                                  ;/*     |0123456789012345678901234567890123456789|              */
 22738                                  ;/*   --|----------------------------------------|              */
 22739                                  ;/*   01|Display DOS Disk Volume Information     |              */
 22740                                  ;/*   02|                                        |              */
 22741                                  ;/*   03|Vol Start End  Size  Vol Start End  Size|              */
 22742                                  ;/*   04| #  ####  #### ####   #  ####  #### ####|              */
 22743                                  ;/*   05|                                        |              */
 22744                                  ;/*   06|                                        |              */
 22745                                  ;/*   07|                                        |              */
 22746                                  ;/*   08|                                        |              */
 22747                                  ;/*   09|                                        |              */
 22748                                  ;/*   10|                                        |              */
 22749                                  ;/*   11|                                        |              */
 22750                                  ;/*   12|                                        |              */
 22751                                  ;/*   13|                                        |              */
 22752                                  ;/*   14|                                        |              */
 22753                                  ;/*   15|                                        |              */
 22754                                  ;/*   16|                                        |              */
 22755                                  ;/*   17|                                        |              */
 22756                                  ;/*   18|                                        |              */
 22757                                  ;/*   19|                                        |              */
 22758                                  ;/*   20|                                        |              */
 22759                                  ;/*   21|                                        |              */
 22760                                  ;/*   22|                                        |              */
 22761                                  ;/*   23|Press ESC to return to FDISK Options    |              */
 22762                                  ;/*   --------------------------------------------              */
 22763                                  ;/*                                                             */
 22764                                  ;/* ENTRY POINTS: Display_Volume_Information                    */
 22765                                  ;/*      LINKAGE: display_volume_information ()                 */
 22766                                  ;/*          NEAR CALL                                          */
 22767                                  ;/*                                                             */
 22768                                  ;/* INPUT: None                                                 */
 22769                                  ;/*                                                             */
 22770                                  ;/* EXIT-NORMAL: ERROR=FALSE                                    */
 22771                                  ;/*                                                             */
 22772                                  ;/* EXIT-ERROR: ERROR=TRUE                                      */
 22773                                  ;/*                                                             */
 22774                                  ;/* EFFECTS: No data directly modified by this routine, but     */
 22775                                  ;/*          child routines will modify data.                   */
 22776                                  ;/*                                                             */
 22777                                  ;/* INTERNAL REFERENCES:                                        */
 22778                                  ;/*   ROUTINES:                                                 */
 22779                                  ;/*      clear_screen                                           */
 22780                                  ;/*      wait_for_ESC                                           */
 22781                                  ;/*      display                                                */
 22782                                  ;/*      volume_display                                         */
 22783                                  ;/*                                                             */
 22784                                  ;/* EXTERNAL REFERENCES:                                        */
 22785                                  ;/*   ROUTINES:                                                 */
 22786                                  ;/*                                                             */
 22787                                  ;/******************** END OF SPECIFICATIONS ********************/
 22788                                  
 22789                                  ;void display_volume_information()
 22790                                  ;
 22791                                  ;BEGIN
 22792                                  ;
 22793                                  ;    char   input;
 22794                                  ;    char    temp;
 22795                                  ;
 22796                                  ;    input = c(NUL);
 22797                                  ;    /* clear the screen */
 22798                                  ;    clear_screen(u(0),u(0),u(24),u(79));
 22799                                  ;
 22800                                  ;    /* Display Header */
 22801                                  ;    display(menu_37);
 22802                                  ;
 22803                                  ;    /* Display information */
 22804                                  ;    temp = volume_display();
 22805                                  ;
 22806                                  ;    /* Set up partition size message */
 22807                                  ;    sprintf(insert,"%4.0d",get_partition_size( uc(EXTENDED) ) );
 22808                                  ;    display(menu_21);
 22809                                  ;
 22810                                  ;    /* print ESC prompt */
 22811                                  ;    display(menu_11);
 22812                                  ;
 22813                                  ;    /* Wait to exit */
 22814                                  ;    input = wait_for_ESC();
 22815                                  ;    return;
 22816                                  ;END
 22817                                  
 22818                                  ; IBM PC-DOS 7.0 FDISK.COM (unpacked) /// Segment 0, Offset 20FCh 
 22819                                  
 22820                                  display_volume_information:
 22821                                  		; 17/12/2018	
 22822                                  		;mov	ax,79
 22823                                  		;push	ax
 22824                                  		;mov	ax,24
 22825                                  		;push	ax
 22826                                  		;sub	ax,ax
 22827                                  		;push	ax
 22828                                  		;push	ax
 22829                                  		;call	clear_screen
 22830                                  		;add	sp,8
 22831                                  
 22832 000031AF E8ACE2                  		call	CLS ; 18/02/2018
 22833                                  
 22834                                  		;push	word [menu_37_segment]
 22835 000031B2 1E                      		push	ds
 22836 000031B3 FF36[559E]              		push    word [menu_37_offset]
 22837 000031B7 E86AE4                  		call    display
 22838                                  		;pop	bx
 22839                                  		;pop	bx
 22840                                  
 22841 000031BA E82500                  		call    volume_display
 22842                                  
 22843                                  		;;mov	al,5
 22844                                  		;;push	ax
 22845                                  		;mov	dh,5
 22846                                  		;call	get_partition_size
 22847                                  		;;pop	bx
 22848                                  		;push 	ax
 22849                                  		;mov	ax,p_size_format ; "%4.1d"
 22850                                  		;push	ax
 22851                                  		;mov     ax,insert
 22852                                  		;push    ax
 22853                                  		;call    sprintf
 22854                                  		;add	sp,6
 22855                                  		;
 22856                                  		;;push	word [menu_21_segment]
 22857                                  		;push	ds
 22858                                  		;push	word [menu_21_offset]
 22859                                  		;call	display
 22860                                  		;;pop	bx
 22861                                  		;;pop	bx
 22862                                  
 22863 000031BD E80500                  		call	display_ext_partition_size ; 31/12/2018
 22864                                  
 22865                                  		;;push	word [menu_11_segment]
 22866                                  		;push	ds
 22867                                  		;push	word [menu_11_offset]
 22868                                  		;call	display
 22869                                  		;;pop	bx
 22870                                  		;;pop	bx
 22871                                  
 22872 000031C0 E8ABFC                  		call	display_menu_11 ; 31/12/2018
 22873                                  
 22874 000031C3 EBAF                    		jmp     wait_for_ESC
 22875                                  
 22876                                  ; 31/12/2018
 22877                                  display_ext_partition_size:
 22878                                  		;mov	al,5
 22879                                  		;push	ax
 22880 000031C5 B605                    		mov	dh,5
 22881 000031C7 E85E01                  		call	get_partition_size
 22882                                  		;pop	bx
 22883 000031CA 50                      		push    ax
 22884 000031CB B8[926F]                		mov	ax,p_size_format ; "%4.1d"
 22885 000031CE 50                      		push	ax
 22886 000031CF B8[F4CC]                		mov     ax,insert
 22887 000031D2 50                      		push    ax
 22888 000031D3 E8EFF0                  		call    sprintf
 22889 000031D6 83C406                  		add	sp,6
 22890                                  
 22891                                  		;push	word [menu_21_segment]
 22892 000031D9 1E                      		push	ds
 22893 000031DA FF36[299E]              		push	word [menu_21_offset]
 22894 000031DE E843E4                  		call	display
 22895                                  		;pop	bx
 22896                                  		;pop	bx
 22897                                  
 22898 000031E1 C3                      		retn
 22899                                  
 22900                                  ; ----------------------------------------------------------------------------
 22901                                  ; vdisplay.c (FDISK, MSDOS 6.0, 1991)	
 22902                                  ; ----------------------------------------------------------------------------
 22903                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 18/12/2018)
 22904                                  
 22905                                  ;/*  */
 22906                                  ;char volume_display()
 22907                                  ;
 22908                                  ;BEGIN
 22909                                  ;
 22910                                  ;    unsigned    i;
 22911                                  ;
 22912                                  ;    char        drive_found;
 22913                                  ;    char        drive_letter;
 22914                                  ;    char        drive_num;
 22915                                  ;
 22916                                  ;    char        first_display;
 22917                                  ;    char        second_display;
 22918                                  ;    char        third_display;
 22919                                  ;    char        fourth_display;
 22920                                  ;    unsigned    insert_offset;
 22921                                  ;
 22922                                  ;    first_display = FALSE;
 22923                                  ;
 22924                                  ;    /* get the current drive letters */
 22925                                  ;    get_letters();
 22926                                  ;
 22927                                  ;    /* loop thru the partitions, only print stuff if it is there */
 22928                                  ;
 22929                                  ;    /* Get the drives in order by location on disk */
 22930                                  ;    sort_ext_table(c(23));
 22931                                  ;
 22932                                  ;    /* initialize all the inserts to blanks */
 22933                                  ;    memset(insert,c(' '),(24*29));
 22934                                  ;
 22935                                  ;    drive_num = c(0);
 22936                                  ;    drive_found = FALSE;
 22937                                  ;    first_display = TRUE;
 22938                                  ;    insert_offset = 0;
 22939                                  ;
 22940                                  ;    for (i=u(0); i < u(23); i++)
 22941                                  ;       BEGIN
 22942                                  ;
 22943                                  ;        /* See if entry exists */
 22944                                  ;        if ( (ext_table[cur_disk][sort[i]].sys_id == uc(DOS12)) ||
 22945                                  ;             (ext_table[cur_disk][sort[i]].sys_id == uc(DOS16)) ||
 22946                                  ;             (ext_table[cur_disk][sort[i]].sys_id == uc(DOSNEW)) )
 22947                                  ;           BEGIN
 22948                                  ;
 22949                                  ;            /* We found one, now get the info */
 22950                                  ;            drive_found = TRUE;
 22951                                  ;
 22952                                  ;            insert_offset += sprintf(&insert[insert_offset],"%c%c%-11.11s%4.0d%-8.8s%3.0d%%",
 22953                                  ;                    ext_table[cur_disk][sort[i]].drive_letter,
 22954                                  ;                    ( ext_table[cur_disk][sort[i]].drive_letter == c(' ') ) ? ' ' : ':',
 22955                                  ;                    ext_table[cur_disk][sort[i]].vol_label,
 22956                                  ;                    ext_table[cur_disk][sort[i]].mbytes_used,
 22957                                  ;                    ext_table[cur_disk][sort[i]].system,
 22958                                  ;                    ext_table[cur_disk][sort[i]].percent_used );
 22959                                  ;
 22960                                  ;            drive_letter = ext_table[cur_disk][sort[i]].drive_letter;
 22961                                  ;            drive_num++;
 22962                                  ;
 22963                                  ;           END
 22964                                  ;       END
 22965                                  ;
 22966                                  ;    /* Display the column of drives */
 22967                                  ;    if (drive_found)
 22968                                  ;       BEGIN
 22969                                  ;
 22970                                  ;        clear_screen(u(2),u(0),u(15),u(79));
 22971                                  ;
 22972                                  ;        if ( drive_num > 0 )
 22973                                  ;            BEGIN
 22974                                  ;            pinsert = &insert[0];
 22975                                  ;            display(menu_19);
 22976                                  ;            END
 22977                                  ;
 22978                                  ;        if ( drive_num > 6 )
 22979                                  ;            BEGIN
 22980                                  ;            pinsert = &insert[6*29];
 22981                                  ;            display(menu_43);
 22982                                  ;            END
 22983                                  ;
 22984                                  ;        if ( drive_num > 12 )
 22985                                  ;            BEGIN
 22986                                  ;            pinsert = &insert[12*29];
 22987                                  ;            display(menu_20);
 22988                                  ;            END
 22989                                  ;
 22990                                  ;        if ( drive_num > 18 )
 22991                                  ;            BEGIN
 22992                                  ;            pinsert = &insert[18*29];
 22993                                  ;            display(menu_44);
 22994                                  ;            END
 22995                                  ;        pinsert = &insert[0];
 22996                                  ;        END
 22997                                  ;    else
 22998                                  ;       BEGIN
 22999                                  ;        /* Didn't find any */
 23000                                  ;        if (first_display)
 23001                                  ;           BEGIN
 23002                                  ;            /* Wipe out display and put up message */
 23003                                  ;            clear_screen(u(2),u(0),u(15),u(79));
 23004                                  ;            display(status_9);
 23005                                  ;           END
 23006                                  ;       END
 23007                                  ;    /* Return the highest drive letter found */
 23008                                  ;    return(drive_letter);
 23009                                  ;END
 23010                                  
 23011                                  volume_display:
 23012                                  		; 18/12/2018
 23013                                  
 23014                                  	;%define vd_first_display bp-18
 23015                                  	;%define vd_insert_offset bp-14
 23016                                  	;%define vd_i		  bp-12
 23017                                  	;%define vd_drive_letter  bp-10
 23018                                  	;%define vd_drive_num	  bp-8
 23019                                  	;%define vd_drive_found	  bp-6
 23020                                  
 23021                                  	%define vd_drive_letter   bp-12 ; 25/12/2018
 23022                                  	%define vd_first_display  bp-10
 23023                                  	%define vd_insert_offset  bp-8
 23024                                  	%define vd_i		  bp-6
 23025                                  	%define vd_drive_num	  bp-4
 23026                                  	%define vd_drive_found	  bp-2
 23027                                  
 23028 000031E2 55                      		push	bp
 23029 000031E3 89E5                    		mov	bp,sp
 23030                                  		;sub	sp,18
 23031 000031E5 83EC0C                  		sub	sp,12 ; 02/01/2019
 23032 000031E8 56                      		push	si ; *
 23033                                  
 23034 000031E9 E8F4F5                  		call	get_letters
 23035                                  
 23036                                  		;mov	al,23
 23037                                  		;push	ax
 23038 000031EC B117                    		mov	cl,23
 23039 000031EE E81EF8                  		call	sort_ext_table
 23040                                  		;pop	bx
 23041                                  
 23042                                  		;mov	ax,696 ; 24*29
 23043                                  		;push	ax
 23044                                  		;mov	ax,' '
 23045                                  		;push	ax
 23046                                  		;mov	ax,insert
 23047                                  		;push	ax
 23048                                  		;call	memset
 23049                                  		;add	sp,6
 23050                                  
 23051 000031F1 B020                    		mov	al,' '
 23052 000031F3 B9B802                  		mov	cx,696 ; 24*29
 23053 000031F6 BF[F4CC]                		mov	di,insert
 23054                                  		;push	ds
 23055                                  		;pop	es
 23056 000031F9 F3AA                    		rep	stosb
 23057                                  
 23058                                  		;sub	al,al
 23059 000031FB 29C0                    		sub	ax,ax
 23060 000031FD 8846FC                  		mov	[vd_drive_num],al ; 0
 23061 00003200 8846FE                  		mov	[vd_drive_found],al ; 0
 23062                                  
 23063                                  		;mov	byte [vd_first_display],1 ; TRUE
 23064                                  
 23065                                  		;sub	ax,ax ; 0
 23066 00003203 8946F8                  		mov	[vd_insert_offset],ax ; 0
 23067 00003206 8946FA                  		mov	[vd_i],ax ; 0
 23068 00003209 EB30                    		jmp	short vd_05
 23069                                  vd_01:
 23070 0000320B B83A00                  		mov	ax,':'
 23071                                  vd_02:
 23072 0000320E 50                      		push	ax
 23073 0000320F 8A84[85A1]              		mov	al,[ext_table_drive_letter+si]
 23074                                  		;cbw
 23075 00003213 50                      		push	ax
 23076 00003214 B8[F06F]                		mov	ax,eptbl_row_format ; "%c%c%-11.11s%4.1d%-8.8s%3.1d%%"
 23077 00003217 50                      		push	ax
 23078 00003218 8B46F8                  		mov	ax,[vd_insert_offset]
 23079 0000321B 05[F4CC]                		add	ax,insert
 23080 0000321E 50                      		push	ax
 23081 0000321F E8A3F0                  		call	sprintf
 23082 00003222 83C410                  		add	sp,16
 23083 00003225 0146F8                  		add	[vd_insert_offset],ax
 23084                                  		
 23085                                  		;mov	al,24
 23086                                  		;;imul	byte [cur_disk]
 23087                                  		;mul	byte [cur_disk]
 23088                                  		;mov	bx,[vd_i]
 23089                                  		;;mov	cx,ax
 23090                                  		;;mov	al,[sort+bx]
 23091                                  		;;cbw
 23092                                  		;mov	cl,[sort+bx]
 23093                                  		;add	al,cl
 23094                                  		;;mov	cx,46
 23095                                  		;;imul	cx
 23096                                  		;mov	cl,46
 23097                                  		;mul	cl
 23098                                  		;mov	bx,ax
 23099                                  		
 23100                                  		;mov	al,[ext_table_drive_letter+bx]
 23101 00003228 8A84[85A1]              		mov	al,[ext_table_drive_letter+si]
 23102                                  vd_03:
 23103 0000322C 8846F4                  		mov	[vd_drive_letter],al ; 25/12/2018
 23104 0000322F FE46FC                  		inc	byte [vd_drive_num]
 23105                                  vd_04:
 23106 00003232 FE46FA                  		inc	byte [vd_i]
 23107                                  ;vd_05:
 23108 00003235 807EFA17                		cmp	byte [vd_i],23
 23109 00003239 734E                    		jnb	short vd_08
 23110                                  vd_05:
 23111 0000323B B018                    		mov	al,24
 23112                                  		;imul	byte [cur_disk]
 23113 0000323D F626[E2CB]              		mul	byte [cur_disk]
 23114 00003241 8B5EFA                  		mov	bx,[vd_i]
 23115                                  		;mov	cx,ax
 23116                                  		;mov	al,[sort+bx]
 23117                                  		;cbw
 23118                                  		;add	ax,cx
 23119                                  		;mov	cl,[sort+bx]
 23120                                  		;add	al,cl
 23121 00003244 0287[F0C3]              		add	al,[sort+bx] ; 06/01/2019
 23122                                  		;mov	cx,46
 23123                                  		;imul	cx
 23124 00003248 B12E                    		mov	cl,46
 23125 0000324A F6E1                    		mul	cl
 23126 0000324C 89C3                    		mov	bx,ax
 23127 0000324E 80BF[5DA1]01            		cmp	byte [ext_table_sys_id+bx],1
 23128 00003253 740E                    		je	short vd_06
 23129 00003255 80BF[5DA1]04            		cmp	byte [ext_table_sys_id+bx],4
 23130 0000325A 7407                    		je	short vd_06
 23131 0000325C 80BF[5DA1]06            		cmp	byte [ext_table_sys_id+bx],6
 23132 00003261 75CF                    		jne	short vd_04
 23133                                  vd_06:
 23134 00003263 C646FE01                		mov	byte [vd_drive_found],1
 23135                                  		
 23136                                  		;mov	al,24
 23137                                  		;imul	byte [cur_disk]
 23138                                  		;mov	bx,[vd_i]
 23139                                  		;;mov	cx,ax
 23140                                  		;;mov	al,[sort+bx]
 23141                                  		;;cbw
 23142                                  		;;add	ax,cx
 23143                                  		;mov	cl,[sort+bx]
 23144                                  		;add	al,cl
 23145                                  		;;mov	cx,46
 23146                                  		;;imul	cx
 23147                                  		;mov	cl,46
 23148                                  		;mul	cl
 23149                                  		;mov	si,ax ; -*-
 23150                                  
 23151 00003267 89DE                    		mov	si,bx ; -*-		
 23152                                  
 23153                                  		;push	word [ext_table_percent_used+si]
 23154                                  		;add	si,ext_table_system
 23155                                  		;push	si
 23156                                  		;mov	si,ax
 23157 00003269 FFB7[6EA1]              		push	word [ext_table_percent_used+bx]
 23158 0000326D 81C3[7CA1]              		add	bx,ext_table_system
 23159 00003271 53                      		push	bx
 23160                                  		;mov	bx,ax ; -*-
 23161 00003272 89F3                    		mov	bx,si ; -*-
 23162                                  		;push	word [ext_table_mbytes_used+si]
 23163 00003274 FFB7[6CA1]              		push	word [ext_table_mbytes_used+bx]
 23164                                  		;add	ax,ext_table_vol_label
 23165                                  		;push	ax
 23166 00003278 81C3[70A1]              		add	bx,ext_table_vol_label
 23167 0000327C 53                      		push	bx
 23168 0000327D 80BC[85A1]20            		cmp	byte [ext_table_drive_letter+si],' '
 23169                                  		;je	short vd_07
 23170                                  		;jmp	vd_01
 23171 00003282 7587                    		jne	short vd_01
 23172                                  vd_07:
 23173 00003284 B82000                  		mov	ax,' '
 23174 00003287 EB85                    		jmp	vd_02
 23175                                  vd_08:
 23176 00003289 807EFE00                		cmp	byte [vd_drive_found],0
 23177                                  		;jne	short vd_09
 23178                                  		;jmp	vd_14
 23179 0000328D 746A                    		je	short vd_14
 23180                                  vd_09:
 23181 0000328F B84F00                  		mov	ax,79
 23182 00003292 50                      		push	ax
 23183 00003293 B80F00                  		mov	ax,15
 23184 00003296 50                      		push	ax
 23185 00003297 29C0                    		sub	ax,ax
 23186 00003299 50                      		push	ax
 23187 0000329A B80200                  		mov	ax,2
 23188 0000329D 50                      		push	ax
 23189 0000329E E8F5E1                  		call	clear_screen
 23190                                  		;add	sp,8
 23191                                  		
 23192 000032A1 807EFC00                		cmp	byte [vd_drive_num],0
 23193                                  		;jle	short vd_10
 23194 000032A5 764A                    		jna	short vd_13
 23195                                  		
 23196 000032A7 C706[9870][F4CC]        		mov	word [pinsert],insert
 23197                                  		;push	word [menu_19_segment]
 23198 000032AD 1E                      		push	ds
 23199 000032AE FF36[219E]              		push	word [menu_19_offset]
 23200 000032B2 E86FE3                  		call	display
 23201                                  		;pop	bx
 23202                                  		;pop	bx
 23203                                  vd_10:
 23204 000032B5 807EFC06                		cmp	byte [vd_drive_num],6
 23205                                  		;jle	short vd_11
 23206 000032B9 7E36                    		jle	short vd_13
 23207                                  
 23208 000032BB C706[9870][A2CD]        		mov	word [pinsert],insert+174 ; 6*29
 23209                                  		;push	word [menu_43_segment]
 23210 000032C1 1E                      		push	ds
 23211 000032C2 FF36[239E]              		push	word [menu_43_offset]
 23212 000032C6 E85BE3                  		call	display
 23213                                  		;pop	bx
 23214                                  		;pop	bx
 23215                                  vd_11:
 23216 000032C9 807EFC0C                		cmp	byte [vd_drive_num],12
 23217                                  		;jle	short vd_12
 23218 000032CD 7E22                    		jle	short vd_13
 23219                                  
 23220 000032CF C706[9870][50CE]        		mov	word [pinsert],insert+348 ; 12*129
 23221                                  		;push	word [menu_20_segment]
 23222 000032D5 1E                      		push	ds
 23223 000032D6 FF36[259E]              		push	word [menu_20_offset]
 23224 000032DA E847E3                  		call	display
 23225                                  		;pop	bx
 23226                                  		;pop	bx
 23227                                  vd_12:
 23228 000032DD 807EFC12                		cmp	byte [vd_drive_num],18
 23229 000032E1 7E0E                    		jle	short vd_13
 23230                                  
 23231 000032E3 C706[9870][FECE]        		mov	word [pinsert],insert+522 ; 18*129
 23232                                  		;push	word [menu_44_segment]
 23233 000032E9 1E                      		push	ds
 23234 000032EA FF36[279E]              		push	word [menu_44_offset]
 23235 000032EE E833E3                  		call	display
 23236                                  		;pop	bx
 23237                                  		;pop	bx
 23238                                  vd_13:
 23239 000032F1 C706[9870][F4CC]        		mov	word [pinsert],insert
 23240 000032F7 EB1A                    		jmp	short vd_15
 23241                                  vd_14:
 23242                                  		;cmp	[vd_first_display],0
 23243                                  		;je	short vd_15
 23244                                  
 23245 000032F9 B84F00                  		mov	ax,79
 23246 000032FC 50                      		push	ax
 23247 000032FD B80F00                  		mov	ax,15
 23248 00003300 50                      		push	ax
 23249 00003301 29C0                    		sub	ax,ax
 23250 00003303 50                      		push	ax
 23251 00003304 B80200                  		mov	ax,2
 23252 00003307 50                      		push	ax
 23253 00003308 E88BE1                  		call	clear_screen
 23254                                  		;add	sp,8
 23255                                  
 23256                                  		;push	word [status_9_seg]
 23257 0000330B 1E                      		push	ds
 23258 0000330C FF36[7B9E]              		push	word [status_9_off]
 23259 00003310 E811E3                  		call	display
 23260                                  		;pop	bx
 23261                                  		;pop	bx
 23262                                  vd_15:
 23263 00003313 8A46F4                  		mov	al,[vd_drive_letter] ; 25/12/2018
 23264                                  		
 23265 00003316 5E                      		pop	si ; *
 23266 00003317 89EC                    		mov	sp,bp
 23267 00003319 5D                      		pop	bp
 23268 0000331A C3                      		retn
 23269                                  
 23270                                  ; ----------------------------------------------------------------------------
 23271                                  ; fdisk.c (FDISK, MSDOS 6.0, 1991)	
 23272                                  ; ----------------------------------------------------------------------------
 23273                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 18/12/2018)
 23274                                  
 23275                                  ;/*  */
 23276                                  ;void internal_program_error()
 23277                                  ;
 23278                                  ;BEGIN
 23279                                  ;   display(internal_error);
 23280                                  ;   DOSEXIT(u(0),u(0));
 23281                                  ;   return;
 23282                                  ;END
 23283                                  
 23284                                  internal_program_error:
 23285                                  
 23286                                  		; 18/12/2018
 23287                                  
 23288                                  		;push	word [inter_err_seg]
 23289 0000331B 1E                      		push	ds
 23290 0000331C FF36[D09E]              		push	word [inter_err_off]
 23291 00003320 E801E3                  		call	display
 23292                                  		;pop	bx
 23293                                  		;pop	bx
 23294                                  		
 23295                                  		;sub	ax,ax
 23296                                  		;push	ax
 23297                                  		;push	ax
 23298                                  		;call	DOSEXIT
 23299                                  		;retn
 23300                                  
 23301 00003323 29C0                    		sub	ax,ax
 23302 00003325 E940CD                  		jmp	DOSEXIT
 23303                                  
 23304                                  ; ----------------------------------------------------------------------------
 23305                                  ; partinfo.c (FDISK, MSDOS 6.0, 1991)	
 23306                                  ; ----------------------------------------------------------------------------
 23307                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 17/12/2018)
 23308                                  
 23309                                  ;XFLOAT get_partition_size(type) 
 23310                                  ;
 23311                                  ;unsigned char type;
 23312                                  ;
 23313                                  ;BEGIN
 23314                                  ; char  i;
 23315                                  ;
 23316                                  ; /*  Look at all four partition entries for system id byte that matches */
 23317                                  ; for (i = c(0); i < c(4);i++)
 23318                                  ;    BEGIN
 23319                                  ;
 23320                                  ;     /* if we find a match, get the size */
 23321                                  ;     if (part_table[cur_disk][i].sys_id == type)
 23322                                  ;        BEGIN
 23323                                  ;         /* Get the size of the partition from the array */
 23324                                  ;         return(part_table[cur_disk][i].mbytes_used);
 23325                                  ;        END
 23326                                  ;    END
 23327                                  ; /* Did not find one, something bad wrong happened */
 23328                                  ; internal_program_error();
 23329                                  ;END
 23330                                  
 23331                                  get_partition_size:
 23332                                  		; 17/12/2018
 23333                                  
 23334                                  	;%define gpz_i	 bp-2
 23335                                  	;%define gpz_type bp+4
 23336                                  
 23337                                  		; DH = [gpz_type]
 23338                                  
 23339                                  		;push	bp
 23340                                  		;mov	bp,sp
 23341                                  		;;sub	sp,2
 23342                                  		;xor	ax,ax
 23343                                  		;mov	word [gpz_i],ax ; 0
 23344                                  		;push	ax
 23345                                  		;xor	dx,dx
 23346                                  		;xor	dl,dl
 23347                                  		;jmp	short gpz_2
 23348 00003328 B2FF                    		mov	dl,0FFh ; 19/12/2018
 23349                                  gpz_1:	
 23350                                  		;inc	byte [gpz_i]
 23351 0000332A FEC2                    		inc	dl
 23352                                  ;gpz_2:
 23353                                  		;cmp	byte [gpz_i],4
 23354 0000332C 80FA04                  		cmp	dl,4
 23355                                  		;jge	short gpz_3
 23356 0000332F 7DEA                    		jge	short internal_program_error ; 19/12/2018
 23357                                  gpz_2:
 23358                                  		;mov	al,[cur_disk]
 23359                                  		;cbw
 23360                                  		;shl	ax,1
 23361                                  		;shl	ax,1
 23362                                  		;mov	cx,ax
 23363                                  
 23364                                  		;mov	cl,[cur_disk]
 23365                                  		;shl	cl,1
 23366                                  		;shl	cl,1
 23367                                  		
 23368                                  		;mov	al,[gpz_i]
 23369                                  		;;cbw
 23370                                  		;;add	ax,cx
 23371                                  		;add	al,cl		
 23372                                  		
 23373 00003331 A0[E2CB]                		mov	al,[cur_disk]
 23374 00003334 D0E0                    		shl	al,1
 23375 00003336 D0E0                    		shl	al,1
 23376 00003338 00D0                    		add	al,dl ; [gpz_i]		
 23377                                  
 23378                                  		;mov	cx,46
 23379                                  		;imul	cx
 23380 0000333A B12E                    		mov	cl,46
 23381 0000333C F6E1                    		mul	cl
 23382 0000333E 89C3                    		mov	bx,ax
 23383                                  
 23384                                  		;mov	al,[gpz_type]
 23385                                  		;cmp	[part_table_sys_id+bx],al
 23386 00003340 38B7[25C4]              		cmp	[part_table_sys_id+bx],dh ; [gpz_type]
 23387 00003344 75E4                    		jne	short gpz_1
 23388 00003346 8B87[34C4]              		mov	ax,[part_table_mbytes_used+bx]
 23389                                  		;jmp	short gpz_4
 23390 0000334A C3                      		retn	; 19/12/2018
 23391                                  ;gpz_3:
 23392                                  		;;call	internal_program_error
 23393                                  		;jmp	internal_program_error ; 19/12/2018
 23394                                  ;gpz_4:
 23395                                  		;mov	sp,bp
 23396                                  		;pop	bp
 23397                                  		;retn
 23398                                  
 23399                                  ; ----------------------------------------------------------------------------
 23400                                  ; 18/12/2018
 23401                                  
 23402                                  ;char find_active_partition()
 23403                                  ;
 23404                                  ;BEGIN
 23405                                  ;
 23406                                  ;unsigned  char   i;
 23407                                  ;
 23408                                  ;       /* See if there is an active partition */
 23409                                  ;       for (i = uc(0); i < uc(4);i++)
 23410                                  ;         BEGIN
 23411                                  ;          /* if we find an active one, TRUE return */
 23412                                  ;          if (part_table[cur_disk][i].boot_ind == uc(ACTIVE))
 23413                                  ;             BEGIN
 23414                                  ;              return(TRUE);
 23415                                  ;              break;
 23416                                  ;             END
 23417                                  ;         END
 23418                                  ;       /* Did not find one, return FALSE */
 23419                                  ;       return(FALSE);
 23420                                  ;END
 23421                                  
 23422                                  find_active_partition:
 23423                                  		; 18/12/2018
 23424                                  
 23425                                  		;%define fap_i bp-2
 23426                                  
 23427                                  		;push	bp
 23428                                  		;mov	bp,sp
 23429                                  
 23430                                  		;sub	sp,2
 23431                                  		;mov	word [fap_i],0
 23432                                  		;xor	dx,dx
 23433                                  		;xor	dl,dl
 23434                                  		;jmp	short fap_2
 23435 0000334B B2FF                    		mov	dl,0FFh ; 19/12/2018
 23436                                  fap_1:
 23437                                  		;inc	byte [fap_i]
 23438 0000334D FEC2                    		inc	dl
 23439                                  fap_2:
 23440                                  		;cmp	byte [fap_i],4
 23441 0000334F 80FA04                  		cmp	dl,4
 23442 00003352 731B                    		jnb	short fap_3
 23443                                  		
 23444 00003354 A0[E2CB]                		mov	al,[cur_disk]
 23445                                  		;cbw
 23446                                  		;shl	ax,1
 23447                                  		;shl	ax,1
 23448 00003357 D0E0                    		shl	al,1
 23449 00003359 D0E0                    		shl	al,1
 23450                                  		;mov	cl,[fap_i]
 23451                                  		;;sub	ch,ch
 23452                                  		;;add	ax,cx
 23453                                  		;add	al,cl
 23454 0000335B 00D0                    		add	al,dl
 23455                                  		;mov	cx,46
 23456                                  		;imul	cx
 23457 0000335D B12E                    		mov	cl,46		
 23458 0000335F F6E1                    		mul	cl
 23459 00003361 89C3                    		mov	bx,ax
 23460                                  
 23461 00003363 80BF[20C4]80            		cmp	byte [part_table_boot_ind+bx],80h
 23462 00003368 75E3                    		jne	short fap_1
 23463                                  		;mov	al,1
 23464                                  		;jmp	short fap_4
 23465                                  
 23466 0000336A 30C0                    		xor	al,al
 23467 0000336C FEC0                    		inc	al
 23468                                  
 23469                                  		; DL = 0  to 3 (active partition number)
 23470                                  		; zf = 0
 23471                                  		; AL = 1
 23472                                  
 23473 0000336E C3                      		retn
 23474                                  fap_3:
 23475 0000336F 28C0                    		sub	al,al
 23476                                  
 23477                                  		; DL = 4
 23478                                  		; zf = 1
 23479                                  		; AL = 0
 23480                                  fap_4:
 23481                                  		;mov	sp,bp
 23482                                  		;pop	bp
 23483                                  
 23484 00003371 C3                      		retn
 23485                                  
 23486                                  ; ============================================================================
 23487                                  ;  CHANGE ACTIVE INFORMATION
 23488                                  ; ============================================================================
 23489                                  ; 19/12/2018
 23490                                  
 23491                                  ; fdisk.msg (MSDOS 6.0)
 23492                                  ;/***************************************************************************************************/
 23493                                  ;/*  Screen for CHANGE_ACTIVE_PARTITION                                                             */
 23494                                  ;/*                                                                                                 */
 23495                                  ;/*     |00000000001111111111222222222233333333334444444444555555555566666666667777777777|          */
 23496                                  ;/*     |01234567890123456789012345678901234567890123456789012345678901234567890123456789|          */
 23497                                  ;/*   --|--------------------------------------------------------------------------------|          */
 23498                                  ;/*   00|                                                                                |          */
 23499                                  ;/*   01|                              Set Active Partition                              |menu_23   */
 23500                                  ;/*   02|                                                                                |          */
 23501                                  ;/*   03|                                                                                |          */
 23502                                  ;/*   04|                                                                                |          */
 23503                                  ;/*   05|                                                                                |          */
 23504                                  ;/*   06|    Current fixed disk drive: #                                                 |menu_5 #  */
 23505                                  ;/*   07|                                                                                |          */
 23506                                  ;/*   08|    Partition Status   Type    Size in Mbytes   Percentage of Disk Used         |menu_14 # */
 23507                                  ;/*   09|     ## #        #   #######       ####         ###%                            |          */
 23508                                  ;/*   10|     ## #        #   #######       ####         ###%                            |          */
 23509                                  ;/*   11|     ## #        #   #######       ####         ###%                            |          */
 23510                                  ;/*   12|     ## #        #   #######       ####         ###%                            |          */
 23511                                  ;/*   13|                                                                                |          */
 23512                                  ;/*   14|    Total disk space is #### Mbytes (1 Mbyte = 1048576 bytes)                   |menu_15 # */
 23513                                  ;/*   15|                                                                                |          */
 23514                                  ;/*   16|    Enter the number of the partition you want to make active............:[#]   |menu_24   */
 23515                                  ;/*   17|                                                                                |          */
 23516                                  ;/*   18|                                                                                |          */
 23517                                  ;/*   19|                                                                                |          */
 23518                                  ;/*   20|                                                                                |          */
 23519                                  ;/*   21|                                                                                |          */
 23520                                  ;/*   22|                                                                                |          */
 23521                                  ;/*   23|                                                                                |          */
 23522                                  ;/*   24|    Press ESC to return to FDISK Options                                        |menu_11   */
 23523                                  ;/*   ------------------------------------------------------------------------------------          */
 23524                                  ;/*                                                                                                 */
 23525                                  ;/***************************************************************************************************/
 23526                                  
 23527                                  ; ----------------------------------------------------------------------------
 23528                                  ; fdisk.c (FDISK, MSDOS 6.0, 1991)	
 23529                                  ; ----------------------------------------------------------------------------
 23530                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 19/12/2018)
 23531                                  
 23532                                  ;/*  */
 23533                                  ;/******************* START OF SPECIFICATIONS *******************/
 23534                                  ;/*                                                             */
 23535                                  ;/* SUBROUTINE NAME: CHANGE_ACTIVE_PARTITION                    */
 23536                                  ;/*                                                             */
 23537                                  ;/* DESCRIPTIVE NAME: Change bootable partition                 */
 23538                                  ;/*                                                             */
 23539                                  ;/* FUNCTION: Will allow user to select the partition that will */
 23540                                  ;/*           recieve control when system is IPL'd. This is     */
 23541                                  ;/*           only for the first hardfile as far as booting is  */
 23542                                  ;/*           concerned, although partitions can be set active  */
 23543                                  ;/*           the second. There are reserved partitions that may*/
 23544                                  ;/*           not be set active and this routine will enforce   */
 23545                                  ;/*           that.                                             */
 23546                                  ;/*                                                             */
 23547                                  ;/* NOTES: If no valid partition is specified, then the active  */
 23548                                  ;/*        partition setting is left unchanged. Screen can be   */
 23549                                  ;/*        exited via the ESC command before active partition   */
 23550                                  ;/*        is changed and no action will take place             */
 23551                                  ;/*                                                             */
 23552                                  ;/*        The following screen is managed                      */
 23553                                  ;/*                                                             */
 23554                                  ;/*     |0000000000111111111122222222223333333333|              */
 23555                                  ;/*     |0123456789012345678901234567890123456789|              */
 23556                                  ;/*   --|----------------------------------------|              */
 23557                                  ;/*   00|                                        |              */
 23558                                  ;/*   01|                                        |              */
 23559                                  ;/*   02|                                        |              */
 23560                                  ;/*   03|                                        |              */
 23561                                  ;/*   04|Change Active Partition                 |              */
 23562                                  ;/*   05|                                        |              */
 23563                                  ;/*   06|Current Fixed Disk Drive: #             |              */
 23564                                  ;/*   07|                                        |              */
 23565                                  ;/*   08|Partition Status   Type  Start  End Size|              */
 23566                                  ;/*   09|    #        #   #######  #### #### ####|              */
 23567                                  ;/*   10|                                        |              */
 23568                                  ;/*   11|                                        |              */
 23569                                  ;/*   12|                                        |              */
 23570                                  ;/*   13|                                        |              */
 23571                                  ;/*   14|Total disk space is #### cylinders.     |              */
 23572                                  ;/*   15|                                        |              */
 23573                                  ;/*   16|                                        |              */
 23574                                  ;/*   17|                                        |              */
 23575                                  ;/*   18|Enter the number of the partition you   |              */
 23576                                  ;/*   19|want to make active...............: [#] |              */
 23577                                  ;/*   20|                                        |              */
 23578                                  ;/*   21|                                        |              */
 23579                                  ;/*   22|                                        |              */
 23580                                  ;/*   23|Press ESC to return to FDISK Options    |              */
 23581                                  ;/*   --------------------------------------------              */
 23582                                  ;/*                                                             */
 23583                                  ;/* ENTRY POINTS: Change_Active_Partition                       */
 23584                                  ;/*      LINKAGE: change_active_partition ()                    */
 23585                                  ;/*           NEAR CALL                                         */
 23586                                  ;/*                                                             */
 23587                                  ;/* INPUT: None                                                 */
 23588                                  ;/*                                                             */
 23589                                  ;/* EXIT-NORMAL: ERROR=FALSE                                    */
 23590                                  ;/*                                                             */
 23591                                  ;/* EXIT-ERROR: ERROR=TRUE                                      */
 23592                                  ;/*             GOTO internal_program_error if invalid num      */
 23593                                  ;/*             input is returned to this level                 */
 23594                                  ;/*                                                             */
 23595                                  ;/* EFFECTS: Display prompts needed to guide user input, and    */
 23596                                  ;/*          gets input from user.                              */
 23597                                  ;/*                                                             */
 23598                                  ;/* INTERNAL REFERENCES:                                        */
 23599                                  ;/*   ROUTINES:                                                 */
 23600                                  ;/*      clear_screen                                           */
 23601                                  ;/*      display                                                */
 23602                                  ;/*      get_num_input                                          */
 23603                                  ;/*      table_display                                          */
 23604                                  ;/*      wait_for_ESC                                           */
 23605                                  ;/*      internal_program_error                                 */
 23606                                  ;/*                                                             */
 23607                                  ;/* EXTERNAL REFERENCES:                                        */
 23608                                  ;/*   ROUTINES:                                                 */
 23609                                  ;/*                                                             */
 23610                                  ;/******************** END OF SPECIFICATIONS ********************/
 23611                                  
 23612                                  ;void change_active_partition()
 23613                                  ;
 23614                                  ;BEGIN
 23615                                  ;
 23616                                  ;    char   input;
 23617                                  ;    unsigned i;
 23618                                  ;    unsigned x;
 23619                                  ;    char   num_partitions;
 23620                                  ;    char   valid_partitions;
 23621                                  ;    char   num_of_bootable_partitions;
 23622                                  ;    char   valid_input;
 23623                                  ;    char   input_default;
 23624                                  ;
 23625                                  ;    input = c(NUL);
 23626                                  ;    /* Clear screen */
 23627                                  ;    clear_screen(u(0),u(0),u(24),u(79));
 23628                                  ;
 23629                                  ;    /* Display header */
 23630                                  ;    display(menu_23);
 23631                                  ;
 23632                                  ;    /* Setup and print current disk */
 23633                                  ;    insert[0] = cur_disk+1+'0';
 23634                                  ;    display(menu_5);
 23635                                  ;
 23636                                  ;    /* Only allow active partitions on the first (and bootable) disk */
 23637                                  ;    if (cur_disk == c(0))
 23638                                  ;
 23639                                  ;       BEGIN
 23640                                  ;	/* Display partition info and see if any partitions exist*/
 23641                                  ;	if (table_display())
 23642                                  ;
 23643                                  ;	   BEGIN
 23644                                  ;	    /* See if active partition is bootable */
 23645                                  ;	    for (i=u(0); i < u(4); i++)
 23646                                  ;	       BEGIN
 23647                                  ;		if (part_table[cur_disk][i].sys_id != uc(0) &&
 23648                                  ;		    part_table[cur_disk][i].boot_ind == uc(0x80))
 23649                                  ;		   BEGIN
 23650                                  ;		    if ((part_table[cur_disk][i].sys_id == uc(BAD_BLOCK)) ||
 23651                                  ;			(part_table[cur_disk][i].sys_id==uc(EXTENDED)))
 23652                                  ;		       BEGIN
 23653                                  ;			/* The active partition is not bootable, so warn user */
 23654                                  ;			display(error_24);
 23655                                  ;		       END
 23656                                  ;		   END
 23657                                  ;	       END
 23658                                  ;
 23659                                  ;	    /* Check to see if only one partition */
 23660                                  ;	    num_partitions = c(0) ;
 23661                                  ;	    num_of_bootable_partitions = c(0);
 23662                                  ;	    for (i=u(0); i < u(4); i++)
 23663                                  ;
 23664                                  ;	       BEGIN
 23665                                  ;		if (part_table[cur_disk][i].sys_id != uc(0))
 23666                                  ;		   BEGIN
 23667                                  ;		    /* Get a count of partitions */
 23668                                  ;		    num_partitions++;
 23669                                  ;
 23670                                  ;		    /* Get a count of the number of defined partitions but don't*/
 23671                                  ;		    /* count those we know aren't bootable */
 23672                                  ;		    if ((part_table[cur_disk][i].sys_id != uc(BAD_BLOCK)) &&
 23673                                  ;			(part_table[cur_disk][i].sys_id != uc(EXTENDED)))
 23674                                  ;		       BEGIN
 23675                                  ;			num_of_bootable_partitions++;
 23676                                  ;		       END
 23677                                  ;		   END
 23678                                  ;	       END
 23679                                  ;	    /* If only one partition found, see if it is active already */
 23680                                  ;	    if (num_of_bootable_partitions == c(1))
 23681                                  ;	       BEGIN
 23682                                  ;
 23683                                  ;		/* Find the partition and see if it is already active */
 23684                                  ;		for (i=u(0); i < u(4); i++)
 23685                                  ;
 23686                                  ;		   BEGIN
 23687                                  ;		    if (part_table[cur_disk][i].sys_id !=uc(0) &&
 23688                                  ;			part_table[cur_disk][i].boot_ind == uc(0x80))
 23689                                  ;
 23690                                  ;		       BEGIN
 23691                                  ;			/* Make sure it is not unbootable partition again*/
 23692                                  ;			if ((part_table[cur_disk][i].sys_id != uc(BAD_BLOCK)) &&
 23693                                  ;			    (part_table[cur_disk][i].sys_id!=uc(EXTENDED)))
 23694                                  ;
 23695                                  ;			   BEGIN
 23696                                  ;			    /* Once it is found, put out the message */
 23697                                  ;			    display(error_15);
 23698                                  ;
 23699                                  ;			    /* Wait for ESC, then get out */
 23700                                  ;			    wait_for_ESC();
 23701                                  ;
 23702                                  ;			    /* clear the screen before going back to main menu*/
 23703                                  ;			    clear_screen(u(0),u(0),u(24),u(79));
 23704                                  ;			    return;
 23705                                  ;			   END
 23706                                  ;		       END
 23707                                  ;		   END
 23708                                  ;	       END
 23709                                  ;	    /* See if any bootable partitions exist */
 23710                                  ;	    if (num_of_bootable_partitions == c(0))
 23711                                  ;	       BEGIN
 23712                                  ;		/* At this point, we know at least one partition does exist due to*/
 23713                                  ;		/* getting past the table_display call, so the only ones around   */
 23714                                  ;		/* must be unbootable  */
 23715                                  ;
 23716                                  ;		/* Display this fact then get out of here */
 23717                                  ;		display(error_25);
 23718                                  ;	       END
 23719                                  ;	    else
 23720                                  ;	       BEGIN
 23721                                  ;		/* All is okay to go and set one, do display prompts */
 23722                                  ;		number_in_msg((XFLOAT)total_mbytes[cur_disk],u(0));
 23723                                  ;		display(menu_15);
 23724                                  ;
 23725                                  ;		/* print ESC prompt */
 23726                                  ;		display(menu_11);
 23727                                  ;
 23728                                  ;		/* Put up input prompt */
 23729                                  ;		display(menu_24);
 23730                                  ;
 23731                                  ;		/* Assume bad input until proven otherwise */
 23732                                  ;		valid_input = FALSE;
 23733                                  ;		valid_partitions = num_partitions;
 23734                                  ;		input_default = c(NUL);
 23735                                  ;
 23736                                  ;		while (!valid_input)
 23737                                  ;		   BEGIN
 23738                                  ;		    /* Go get partition to make active */
 23739                                  ;		    input = get_num_input(input_default,num_partitions,input_row,input_col);
 23740                                  ;
 23741                                  ;		    /* Save the input for next time in case CR pressed */
 23742                                  ;		    input_default = input-'0';
 23743                                  ;
 23744                                  ;		    clear_screen(u(18),u(0),u(23),u(79));
 23745                                  ;
 23746                                  ;		    if (input != c(ESC))
 23747                                  ;		       BEGIN
 23748                                  ;			/* See if known unbootable partition */
 23749                                  ;			/* Set the new one */
 23750                                  ;			valid_partitions = c(0);
 23751                                  ;
 23752                                  ;			/* Make sure the partitions are in physical order */
 23753                                  ;			sort_part_table(c(4));
 23754                                  ;
 23755                                  ;			/* Go find existing partitions */
 23756                                  ;			for (i=u(0);i < u(4); i++)
 23757                                  ;			   BEGIN
 23758                                  ;			    /* First we have to find it */
 23759                                  ;			    if (part_table[cur_disk][sort[i]].sys_id != uc(0))
 23760                                  ;			       BEGIN
 23761                                  ;				/* If this is the 'input'th one, then we got it */
 23762                                  ;				if (valid_partitions == (input-'1'))
 23763                                  ;				   BEGIN
 23764                                  ;				    /* See if it is an unbootable partition */
 23765                                  ;				    if ((part_table[cur_disk][sort[i]].sys_id != uc(BAD_BLOCK)) &&
 23766                                  ;				     (part_table[cur_disk][sort[i]].sys_id !=  uc(EXTENDED)))
 23767                                  ;
 23768                                  ;				       BEGIN
 23769                                  ;					/* Its bootable, so we have good input */
 23770                                  ;					valid_input = c(TRUE);
 23771                                  ;
 23772                                  ;					/* Remove the active indicator from the old partition */
 23773                                  ;					for (x=u(0); x < u(4); x++)
 23774                                  ;					   BEGIN
 23775                                  ;
 23776                                  ;					    if (part_table[cur_disk][x].boot_ind == uc(0x80))
 23777                                  ;					       BEGIN
 23778                                  ;						part_table[cur_disk][x].changed = TRUE;
 23779                                  ;						part_table[cur_disk][x].boot_ind = uc(0);
 23780                                  ;					       END
 23781                                  ;					   END
 23782                                  ;
 23783                                  ;					/* Put in new active indicator */
 23784                                  ;					part_table[cur_disk][sort[i]].boot_ind = uc(0x80);
 23785                                  ;
 23786                                  ;					/* Indicate that it is changed */
 23787                                  ;					part_table[cur_disk][sort[i]].changed = TRUE;
 23788                                  ;
 23789                                  ;					/* Set the reboot flag */
 23790                                  ;					reboot_flag = (FLAG)TRUE;
 23791                                  ;
 23792                                  ;					/* Update the partition info display */
 23793                                  ;					table_display();
 23794                                  ;
 23795                                  ;					/* Clear off the old prompts */
 23796                                  ;					clear_screen(u(16),u(0),u(21),u(79));
 23797                                  ;
 23798                                  ;					/* Say you did it */
 23799                                  ;					insert[0] = input;
 23800                                  ;					display(status_4);
 23801                                  ;					break;
 23802                                  ;				       END
 23803                                  ;				    else
 23804                                  ;				       BEGIN
 23805                                  ;					/* It is, so setup message and tell user */
 23806                                  ;					insert[0] = input;
 23807                                  ;					display(error_17);
 23808                                  ;					break;
 23809                                  ;				       END
 23810                                  ;				   END
 23811                                  ;				else
 23812                                  ;				   BEGIN
 23813                                  ;				    /* Indicate we found one but keep going */
 23814                                  ;				    valid_partitions++;
 23815                                  ;				   END
 23816                                  ;			       END
 23817                                  ;			   END
 23818                                  ;		       END
 23819                                  ;		    else
 23820                                  ;		       BEGIN
 23821                                  ;			/* Mark ESC as ok input so we can get out of here */
 23822                                  ;			valid_input = c(TRUE);
 23823                                  ;		       END
 23824                                  ;		   END /* While loop */
 23825                                  ;	       END
 23826                                  ;	   END /* table display test endif */
 23827                                  ;	else
 23828                                  ;	   BEGIN
 23829                                  ;	    /* No partitions to make active */
 23830                                  ;	    display(error_16);
 23831                                  ;	   END
 23832                                  ;       END
 23833                                  ;    else
 23834                                  ;       BEGIN
 23835                                  ;	display(error_26);
 23836                                  ;       END
 23837                                  ;    /* clear the screen before going back to main menu */
 23838                                  ;    if (input != c(ESC))
 23839                                  ;       BEGIN
 23840                                  ;	wait_for_ESC();
 23841                                  ;       END
 23842                                  ;    clear_screen(u(0),u(0),u(24),u(79));
 23843                                  ;    return;
 23844                                  ;END
 23845                                  
 23846                                  change_active_partition:
 23847                                  		; 19/12/2018
 23848                                  
 23849                                  	%define cap_valid_input		bp-16
 23850                                  	%define cap_num_partitions	bp-14
 23851                                  	%define cap_valid_partitions	bp-12
 23852                                  	%define cap_i			bp-10
 23853                                  	%define cap_x			bp-8
 23854                                  	%define cap_num_boot_partitions bp-6
 23855                                  	%define cap_input_default	bp-4
 23856                                  	%define cap_input		bp-2
 23857                                  
 23858 00003372 55                      		push	bp
 23859 00003373 89E5                    		mov	bp,sp
 23860 00003375 83EC10                  		sub	sp,16
 23861                                  		
 23862 00003378 C646FE00                		mov	byte [cap_input],0
 23863                                  		
 23864                                  		;/* Clear screen */
 23865                                  
 23866                                  		;mov	ax,79
 23867                                  		;push	ax
 23868                                  		;mov	ax,24
 23869                                  		;push	ax
 23870                                  		;sub	ax,ax
 23871                                  		;push	ax
 23872                                  		;push	ax
 23873                                  		;call	clear_screen
 23874                                  		;add	sp,8
 23875                                  
 23876 0000337C E8DFE0                  		call	CLS
 23877                                  
 23878                                  		;/* Display header */
 23879                                  
 23880                                  		;push	word [menu_23_segment]
 23881 0000337F 1E                      		push	ds
 23882 00003380 FF36[2F9E]              		push	word [menu_23_offset]
 23883 00003384 E89DE2                  		call	display
 23884                                  		;pop	bx
 23885                                  		;pop	bx
 23886                                  
 23887                                  		;/* Setup and print current disk */	
 23888                                  		
 23889                                  		;mov	al,[cur_disk]
 23890                                  		;add	al,'1'
 23891                                  		;mov	[insert],al
 23892                                  		;
 23893                                  		;;push	word [menu_5_segment]
 23894                                  		;push	ds
 23895                                  		;push	word [menu_5_offset]
 23896                                  		;call	display
 23897                                  		;;pop	bx
 23898                                  		;;pop	bx
 23899                                  
 23900 00003387 E8D3FA                  		call	display_menu_5 ; 31/12/2018
 23901                                  
 23902                                  	;/* Only allow active partitions on the first (and bootable) disk */
 23903                                  cap_if1:
 23904 0000338A 803E[E2CB]00            		cmp	byte [cur_disk],0
 23905 0000338F 7403                    		je	short cap_01_if2
 23906 00003391 E9DA00                  		jmp	cap_29
 23907                                  
 23908                                  	;/* Display partition info and see if any partitions exist*/
 23909                                  cap_01_if2:
 23910 00003394 E8E0FA                  		call	table_display
 23911                                  		;or	al,al
 23912                                  		;jnz	short cap_02_for1
 23913 00003397 7303                    		jnc	short cap_02_for1
 23914 00003399 E9CB00                  		jmp	cap_28
 23915                                  
 23916                                  		;/* See if active partition is bootable */	
 23917                                  cap_02_for1:
 23918 0000339C C746F60000              		mov	word [cap_i],0
 23919                                  cap_03_for1_next2:
 23920 000033A1 A0[E2CB]                		mov	al,[cur_disk]
 23921                                  		;cbw
 23922                                  		;shl	ax,1
 23923                                  		;shl	ax,1
 23924                                  		;add	ax,[cap_i]
 23925 000033A4 D0E0                    		shl	al,1
 23926 000033A6 D0E0                    		shl	al,1
 23927 000033A8 0246F6                  		add	al,[cap_i]
 23928                                  		;mov	cx,46
 23929                                  		;mul	cx
 23930 000033AB B12E                    		mov	cl,46
 23931 000033AD F6E1                    		mul	cl
 23932 000033AF 89C3                    		mov	bx,ax
 23933                                  cap_if3:
 23934 000033B1 80BF[25C4]00            		cmp	byte [part_table_sys_id+bx],0
 23935 000033B6 741D                    		je	short cap_05_for1_next1
 23936 000033B8 80BF[20C4]80            		cmp	byte [part_table_boot_ind+bx],80h ; Active  partition indicator
 23937 000033BD 7516                    		jne	short cap_05_for1_next1
 23938                                  cap_if4:
 23939 000033BF 80BF[25C4]FF            		cmp	byte [part_table_sys_id+bx],0FFh ; (xenix) Bad Block TABLE
 23940 000033C4 7407                    		je	short cap_04
 23941 000033C6 80BF[25C4]05            		cmp	byte [part_table_sys_id+bx],5 ; EXTENDED DOS partition
 23942 000033CB 7508                    		jne	short cap_05_for1_next1
 23943                                  
 23944                                  	;/* The active partition is not bootable, so warn user */	
 23945                                  cap_04:
 23946                                  		;push	word [error_24_seg]
 23947 000033CD 1E                      		push	ds
 23948 000033CE FF36[AE9E]              		push	word [error_24_off]
 23949 000033D2 E84FE2                  		call	display
 23950                                  		;pop	bx
 23951                                  		;pop	bx
 23952                                  cap_05_for1_next1:
 23953 000033D5 FE46F6                  		inc	byte [cap_i]
 23954 000033D8 807EF604                		cmp	byte [cap_i],4
 23955 000033DC 72C3                    		jb	short cap_03_for1_next2
 23956                                  
 23957                                  		;/* Check to see if only one partition */
 23958 000033DE 28C0                    		sub	al,al ; 0
 23959 000033E0 8846F2                  		mov	[cap_num_partitions],al	; reset
 23960 000033E3 8846FA                  		mov	[cap_num_boot_partitions],al ; reset
 23961                                  cap_for2:
 23962 000033E6 C646F600                		mov	byte [cap_i],0
 23963                                  cap_06_for2_next2:
 23964 000033EA A0[E2CB]                		mov	al,[cur_disk]
 23965                                  		;cbw
 23966                                  		;shl	ax,1
 23967                                  		;shl	ax,1
 23968                                  		;add	ax,[cap_i]
 23969                                  		;mov	cx,46
 23970                                  		;mul	cx
 23971 000033ED D0E0                    		shl	al,1
 23972 000033EF D0E0                    		shl	al,1
 23973 000033F1 0246F6                  		add	al,[cap_i]
 23974 000033F4 B12E                    		mov	cl,46
 23975 000033F6 F6E1                    		mul	cl
 23976 000033F8 89C3                    		mov	bx,ax
 23977                                  cap_if5:
 23978 000033FA 80BF[25C4]00            		cmp	byte [part_table_sys_id+bx],0 ; Partition ID (0 = Empty)	
 23979 000033FF 7414                    		je	short cap_07_for2_next1
 23980                                  
 23981                                  		;/* Get a count of partitions */
 23982 00003401 FE46F2                  		inc	byte [cap_num_partitions]  ; number of partitions (in PT)
 23983                                  cap_if6:
 23984                                  	;/* Get a count of the number of defined partitions but don't*/
 23985                                  	;/* count those we know aren't bootable */
 23986 00003404 80BF[25C4]FF            		cmp	byte [part_table_sys_id+bx],0FFh ; (xenix) Bad Block TABLE
 23987 00003409 740A                    		je	short cap_07_for2_next1
 23988 0000340B 80BF[25C4]05            		cmp	byte [part_table_sys_id+bx],5  ; EXTENDED DOS partition
 23989 00003410 7403                    		je	short cap_07_for2_next1
 23990 00003412 FE46FA                  		inc	byte [cap_num_boot_partitions] ; num of bootable partitions
 23991                                  cap_07_for2_next1:
 23992 00003415 FE46F6                  		inc	byte [cap_i]
 23993 00003418 807EF604                		cmp	byte [cap_i],4
 23994 0000341C 72CC                    		jb	short cap_06_for2_next2
 23995                                  
 23996                                  	;/* If only one partition found, see if it is active already *
 23997                                  cap_if7:
 23998 0000341E 807EFA01                		cmp	byte [cap_num_boot_partitions],1
 23999 00003422 7562                    		jne	short cap_12_if10
 24000                                  
 24001                                  	;/* Find the partition and see if it is already active */
 24002                                  cap_for3:
 24003 00003424 C646F600                		mov	byte [cap_i],0
 24004 00003428 EB09                    		jmp	short cap_09_for3_next1
 24005                                  cap_08_for3_next2:
 24006 0000342A FE46F6                  		inc	byte [cap_i]
 24007                                  ;cap_09_for3_next1:
 24008 0000342D 807EF604                		cmp	byte [cap_i],4
 24009 00003431 7353                    		jnb	short cap_12_if10
 24010                                  cap_09_for3_next1:
 24011 00003433 A0[E2CB]                		mov	al,[cur_disk]
 24012                                  		;cbw
 24013                                  		;shl	ax,1
 24014                                  		;shl	ax,1
 24015                                  		;add	ax,[cap_i]
 24016                                  		;mul	cx
 24017 00003436 D0E0                    		shl	al,1
 24018 00003438 D0E0                    		shl	al,1
 24019 0000343A 0246F6                  		add	al,[cap_i]
 24020 0000343D F6E1                    		mul	cl	
 24021 0000343F 89C3                    		mov	bx,ax
 24022                                  cap_if8:
 24023 00003441 80BF[25C4]00            		cmp	byte [part_table_sys_id+bx],0 ; empty pt entry
 24024 00003446 74E2                    		je	short cap_08_for3_next2
 24025 00003448 80BF[20C4]80            		cmp	byte [part_table_boot_ind+bx],80h ; Active partition
 24026 0000344D 75DB                    		jne	short cap_08_for3_next2
 24027                                  
 24028                                  	;/* Make sure it is not unbootable partition again*/
 24029                                  cap_if9:
 24030 0000344F 80BF[25C4]FF            		cmp	byte [part_table_sys_id+bx],0FFh ; (xenix) Bad Block TABLE
 24031 00003454 74D4                    		je	short cap_08_for3_next2
 24032 00003456 80BF[25C4]05            		cmp	byte [part_table_sys_id+bx],5  ; EXTENDED DOS partition	
 24033 0000345B 74CD                    		je	short cap_08_for3_next2
 24034                                  
 24035                                  		;/* Once it is found, put out the message */	
 24036                                  
 24037                                  		;push	word [error_15_seg]
 24038 0000345D 1E                      		push	ds
 24039 0000345E FF36[9E9E]              		push	word [error_15_off]
 24040 00003462 E8BFE1                  		call	display
 24041                                  		;pop	bx
 24042                                  		;pop	bx
 24043                                  
 24044 00003465 EB15                    		jmp	short cap_10 ; 19/12/2018
 24045                                  
 24046                                  		;/* No partitions to make active */
 24047                                  cap_28:
 24048                                  		;push	word [error_16_seg]
 24049 00003467 1E                      		push	ds
 24050 00003468 FF36[A09E]              		push	word [error_16_off]
 24051 0000346C EB05                    		jmp	short cap_30
 24052                                  cap_29:
 24053                                  		;push	word [error_26_seg]
 24054 0000346E 1E                      		push	ds
 24055 0000346F FF36[B29E]              		push	word [error_26_off]
 24056                                  cap_30:
 24057 00003473 E8AEE1                  		call	display
 24058                                  		;pop	bx
 24059                                  		;pop	bx
 24060                                  
 24061                                  		;jmp	cap_31 ; 19/12/2018
 24062                                  
 24063                                  		;/* clear the screen before going back to main menu */
 24064                                  cap_31:
 24065 00003476 807EFE1B                		cmp	byte [cap_input],1Bh  ; ESC key
 24066                                  		;jne	short cap_32
 24067                                  		;jmp	cap_11
 24068 0000347A 7403                    		je	short cap_11
 24069                                  ;cap_32:
 24070                                  		;jmp	cap_10
 24071                                  
 24072                                  		;/* Wait for ESC, then get out */
 24073                                  cap_10:
 24074 0000347C E8F5FC                  		call	wait_for_ESC
 24075                                  
 24076                                  	 ;/* clear the screen before going back to main menu*/
 24077                                  cap_11:
 24078                                  		;mov	ax,79
 24079                                  		;push	ax
 24080                                  		;mov	ax,24
 24081                                  		;push	ax
 24082                                  		;sub	ax,ax
 24083                                  		;push	ax
 24084                                  		;push	ax
 24085                                  		;call	clear_screen
 24086                                  		;add	sp,8
 24087                                  
 24088 0000347F E8DCDF                  		call	CLS
 24089                                  
 24090                                  		;jmp	cap_33
 24091                                  cap_33:
 24092 00003482 89EC                    		mov	sp,bp
 24093 00003484 5D                      		pop	bp
 24094 00003485 C3                      		retn
 24095                                  
 24096                                  	;/* See if any bootable partitions exist */
 24097                                  cap_12_if10:
 24098 00003486 807EFA00                		cmp	byte [cap_num_boot_partitions],0
 24099 0000348A 7507                    		jne	short cap_13_if10_else
 24100                                  
 24101                                  	;/* At this point, we know at least one partition does exist due to*/
 24102                                  	;/* getting past the table_display call, so the only ones around   */
 24103                                  	;/* must be unbootable  */
 24104                                  cap_12:
 24105                                  		;/* Display this fact then get out of here */
 24106                                  
 24107                                  		;push	word [error_25_seg]
 24108 0000348C 1E                      		push	ds
 24109 0000348D FF36[B09E]              		push	word [error_25_off]
 24110 00003491 EBE0                    		jmp	cap_30
 24111                                  
 24112                                  	;/* All is okay to go and set one, do display prompts */	
 24113                                  cap_13_if10_else:
 24114 00003493 29C0                    		sub	ax,ax
 24115 00003495 50                      		push	ax
 24116 00003496 A0[E2CB]                		mov	al,[cur_disk]
 24117                                  		;cbw
 24118 00003499 89C3                    		mov	bx,ax
 24119                                  		;shl	bx,1
 24120 0000349B D0E3                    		shl	bl,1
 24121 0000349D FFB7[D6A0]              		push	word [total_mbytes+bx]
 24122 000034A1 E857FB                  		call	number_in_msg
 24123                                  		;pop	bx
 24124                                  		;pop	bx
 24125                                  
 24126                                  		;push	word [menu_15_segment]
 24127 000034A4 1E                      		push	ds
 24128 000034A5 FF36[139E]              		push	word [menu_15_offset]
 24129 000034A9 E878E1                  		call	display
 24130                                  		;pop	bx
 24131                                  		;pop	bx
 24132                                  
 24133                                  		;/* print ESC prompt */
 24134                                  
 24135                                  		;;push	word [menu_11_segment]
 24136                                  		;push	ds
 24137                                  		;push	word [menu_11_offset]
 24138                                  		;call	display
 24139                                  		;;pop	bx
 24140                                  		;;pop	bx
 24141                                  
 24142 000034AC E8BFF9                  		call	display_menu_11 ; 31/12/2018
 24143                                  
 24144                                  		;/* Put up input prompt */
 24145                                  
 24146                                  		;push	word [menu_24_segment]
 24147 000034AF 1E                      		push	ds
 24148 000034B0 FF36[319E]              		push	word [menu_24_offset]
 24149 000034B4 E86DE1                  		call	display
 24150                                  		;pop	bx
 24151                                  		;pop	bx
 24152                                  
 24153                                  		;/* Assume bad input until proven otherwise */
 24154                                  
 24155 000034B7 8A46F2                  		mov	al,[cap_num_partitions]
 24156 000034BA 8846F4                  		mov	[cap_valid_partitions],al
 24157 000034BD 28C0                    		sub	al,al ; 0
 24158 000034BF 8846F0                  		mov	[cap_valid_input],al
 24159 000034C2 8846FC                  		mov	[cap_input_default],al
 24160                                  		;jmp	cap_26_while
 24161                                  
 24162                                  cap_26_while:
 24163 000034C5 807EF000                		cmp	byte [cap_valid_input],0 ; FALSE ?
 24164                                  		;;jne	short cap_27
 24165                                  		;jne	short cap_31
 24166                                  		;jmp	cap_14
 24167 000034C9 75AB                    		jne	short cap_31
 24168                                  
 24169                                  		;/* Go get partition to make active */
 24170                                  cap_14:
 24171 000034CB FF36[AAA0]              		push	word [input_col]
 24172 000034CF FF36[4CA1]              		push	word [input_row]
 24173 000034D3 8A46F2                  		mov	al,[cap_num_partitions]
 24174 000034D6 50                      		push	ax
 24175 000034D7 8A46FC                  		mov	al,[cap_input_default]
 24176 000034DA 50                      		push	ax
 24177 000034DB E896F5                  		call	get_num_input
 24178                                  		;add	sp,8
 24179 000034DE 8846FE                  		mov	[cap_input],al
 24180                                  
 24181                                  	;/* Save the input for next time in case CR pressed */
 24182                                  
 24183 000034E1 2C30                    		sub	al,'0'
 24184 000034E3 8846FC                  		mov	[cap_input_default],al
 24185                                  
 24186 000034E6 B84F00                  		mov	ax,79
 24187 000034E9 50                      		push	ax
 24188 000034EA B81700                  		mov	ax,23
 24189 000034ED 50                      		push	ax
 24190 000034EE 29C0                    		sub	ax,ax
 24191 000034F0 50                      		push	ax
 24192 000034F1 B91200                  		mov	cx,18
 24193 000034F4 51                      		push	cx
 24194 000034F5 E89EDF                  		call	clear_screen
 24195                                  		;add	sp,8
 24196                                  cap_if11:
 24197 000034F8 807EFE1B                		cmp	byte [cap_input],1Bh ; ESC key
 24198 000034FC 7503                    		jne	short cap_15
 24199 000034FE E9DD00                  		jmp	cap_25_if11_else
 24200                                  
 24201                                  		;/* See if known unbootable partition */
 24202                                  		;/* Set the new one */
 24203                                  cap_15:
 24204 00003501 C646F400                		mov	byte [cap_valid_partitions],0
 24205                                  
 24206                                  		;/* Make sure the partitions are in physical order */
 24207                                  
 24208                                  		;mov	al,4
 24209                                  		;push	ax
 24210 00003505 B104                    		mov	cl,4
 24211 00003507 E89BF4                  		call	sort_part_table
 24212                                  		;pop	bx
 24213                                  
 24214                                  		;/* Go find existing partitions */
 24215                                  cap_15_for4:
 24216 0000350A C646F600                		mov	byte [cap_i],0
 24217                                  		;jmp	short cap_20_for4_next1
 24218 0000350E EB1E                    		jmp	short cap_21_for4_next2
 24219                                  
 24220                                  		;/* It is, so setup message and tell user */
 24221                                  cap_16_if14_else:
 24222 00003510 8A46FE                  		mov	al,[cap_input]
 24223 00003513 A2[F4CC]                		mov	[insert],al
 24224                                  		;push	word [error_17_seg]
 24225 00003516 1E                      		push	ds
 24226 00003517 FF36[A29E]              		push	word [error_17_off]
 24227                                  cap_17:
 24228 0000351B E806E1                  		call	display
 24229                                  		;pop	bx
 24230                                  		;pop	bx
 24231 0000351E EBA5                    		jmp	short cap_26_while  ; /* While loop */
 24232                                  
 24233                                  		;/* Indicate we found one but keep going */
 24234                                  cap_18:
 24235 00003520 FE46F4                  		inc	byte [cap_valid_partitions]
 24236                                  cap_19:
 24237 00003523 FE46F6                  		inc	byte [cap_i]
 24238                                  cap_20_for4_next1:
 24239 00003526 807EF604                		cmp	byte [cap_i],4
 24240 0000352A 7202                    		jb	short cap_21_for4_next2
 24241 0000352C EB97                    		jmp	short cap_26_while  ; /* While loop */
 24242                                  cap_21_for4_next2:
 24243 0000352E A0[E2CB]                		mov	al,[cur_disk]
 24244                                  		;cbw
 24245                                  		;shl	ax,1
 24246                                  		;shl	ax,1
 24247 00003531 D0E0                    		shl	al,1
 24248 00003533 D0E0                    		shl	al,1
 24249 00003535 8B5EF6                  		mov	bx,[cap_i]
 24250                                  		;mov	cx,ax
 24251                                  		;mov	al,[sort+bx]
 24252                                  		;cbw
 24253                                  		;add	ax,cx
 24254 00003538 8A8F[F0C3]              		mov	cl,[sort+bx]
 24255 0000353C 00C8                    		add	al,cl
 24256                                  		;mov	cx,46
 24257                                  		;imul	cx
 24258 0000353E B12E                    		mov	cl,46
 24259 00003540 F6E1                    		mul	cl
 24260 00003542 89C3                    		mov	bx,ax
 24261                                  
 24262                                  		;/* First we have to find it */	
 24263                                  cap_if12:
 24264 00003544 80BF[25C4]00            		cmp	byte [part_table_sys_id+bx],0  ; Partition ID (0 = empty)
 24265 00003549 74D8                    		je	short cap_19
 24266                                  
 24267                                  		;/* If this is the 'input'th one, then we got it */
 24268                                  cap_if13:
 24269                                  		;mov	al,[cap_valid_partitions]
 24270                                  		;cbw
 24271                                  		;mov	cx,ax
 24272 0000354B 8A4EF4                  		mov	cl,[cap_valid_partitions]
 24273 0000354E 8A46FE                  		mov	al,[cap_input]
 24274                                  		;cbw
 24275                                  		;sub	ax,cx
 24276 00003551 28C8                    		sub	al,cl
 24277                                  		;cmp	ax,'1'
 24278 00003553 3C31                    		cmp	al,'1'
 24279 00003555 75C9                    		jne	short cap_18
 24280                                  
 24281                                  		;/* See if it is an unbootable partition */
 24282                                  cap_if14:
 24283 00003557 80BF[25C4]FF            		cmp	byte [part_table_sys_id+bx],0FFh ; (xenix) Bad Block TABLE
 24284 0000355C 74B2                    		je	short cap_16_if14_else
 24285 0000355E 80BF[25C4]05            		cmp	byte [part_table_sys_id+bx],5  ; EXTENDED DOS partition	
 24286 00003563 74AB                    		je	short cap_16_if14_else
 24287                                  
 24288                                  		;/* Its bootable, so we have good input */
 24289                                  		
 24290 00003565 C646F001                		mov	byte [cap_valid_input],1 ; TRUE
 24291                                  
 24292                                  	;/* Remove the active indicator from the old partition */
 24293                                  cap_for5:
 24294 00003569 C646F800                		mov	byte [cap_x],0
 24295                                  cap_22_for5_next2:
 24296 0000356D A0[E2CB]                		mov	al,[cur_disk]
 24297                                  		;cbw
 24298                                  		;shl	ax,1
 24299                                  		;shl	ax,1
 24300 00003570 D0E0                    		shl	al,1
 24301 00003572 D0E0                    		shl	al,1
 24302                                  		;add	ax,[cap_x]
 24303 00003574 0246F8                  		add	al,[cap_x]
 24304                                  		;mov	cx,46
 24305                                  		;mul	cx
 24306 00003577 B12E                    		mov	cl,46
 24307 00003579 F6E1                    		mul	cl
 24308 0000357B 89C3                    		mov	bx,ax
 24309                                  cap_if15:
 24310 0000357D 80BF[20C4]80            		cmp	byte [part_table_boot_ind+bx],80h ; Active partition indicator
 24311 00003582 750A                    		jne	short cap_24_for5_next1
 24312 00003584 C687[33C4]01            		mov	byte [part_table_changed+bx],1  ; Partion table changed flag
 24313 00003589 C687[20C4]00            		mov	byte [part_table_boot_ind+bx],0 ; non-active partition
 24314                                  cap_24_for5_next1:
 24315 0000358E FE46F8                  		inc	byte [cap_x]
 24316 00003591 807EF804                		cmp	byte [cap_x],4
 24317 00003595 72D6                    		jb	short cap_22_for5_next2
 24318                                  		
 24319                                  		;/* Put in new active indicator */
 24320                                  
 24321 00003597 A0[E2CB]                		mov	al,[cur_disk]
 24322                                  		;cbw
 24323                                  		;shl	ax,1
 24324                                  		;shl	ax,1
 24325 0000359A D0E0                    		shl	al,1
 24326 0000359C D0E0                    		shl	al,1
 24327 0000359E 8B5EF6                  		mov	bx,[cap_i]
 24328                                  		;mov	cx,ax
 24329                                  		;mov	al,[sort+bx]
 24330                                  		;cbw
 24331                                  		;add	ax,cx
 24332 000035A1 8A8F[F0C3]              		mov	cl,[sort+bx]
 24333 000035A5 00C8                    		add	al,cl
 24334                                  		;mov	cx,46
 24335                                  		;imul	cx
 24336 000035A7 B12E                    		mov	cl,46
 24337 000035A9 F6E1                    		mul	cl
 24338 000035AB 89C3                    		mov	bx,ax
 24339 000035AD C687[20C4]80            		mov	byte [part_table_boot_ind+bx],80h  ; Set as Active partition
 24340                                  		
 24341                                  		;/* Indicate that it is changed */
 24342                                  
 24343 000035B2 B001                    		mov	al,1
 24344 000035B4 8887[33C4]              		mov	[part_table_changed+bx],al ;  TRUE
 24345                                  
 24346                                  		;/* Set the reboot flag */
 24347                                  
 24348 000035B8 A2[78A0]                		mov	[reboot_flag],al ; TRUE
 24349                                  
 24350                                  		;/* Update the partition info display */
 24351                                  
 24352 000035BB E8B9F8                  		call	table_display
 24353                                  
 24354                                  		;/* Clear off the old prompts */
 24355                                  
 24356 000035BE B84F00                  		mov	ax,79
 24357 000035C1 50                      		push	ax
 24358 000035C2 B81500                  		mov	ax,21
 24359 000035C5 50                      		push	ax
 24360 000035C6 29C0                    		sub	ax,ax
 24361 000035C8 50                      		push	ax
 24362 000035C9 B81000                  		mov	ax,16
 24363 000035CC 50                      		push	ax
 24364 000035CD E8C6DE                  		call	clear_screen
 24365                                  		;add	sp,8
 24366                                  
 24367                                  		;/* Say you did it */
 24368                                  
 24369 000035D0 8A46FE                  		mov	al,[cap_input]
 24370 000035D3 A2[F4CC]                		mov	[insert],al
 24371                                  		;push	word [status_4_seg]
 24372 000035D6 1E                      		push	ds
 24373 000035D7 FF36[719E]              		push	word [status_4_off]
 24374                                  
 24375 000035DB E93DFF                  		jmp	cap_17
 24376                                  
 24377                                  	;/* Mark ESC as ok input so we can get out of here */
 24378                                  cap_25_if11_else:
 24379 000035DE C646F001                		mov	byte [cap_valid_input],1 ; TRUE
 24380 000035E2 E99AFE                  		jmp	cap_11 ; 19/12/2018
 24381                                  
 24382                                  ;cap_26_while:
 24383                                  ;		cmp	byte [cap_valid_input],0 ; FALSE ?
 24384                                  ;		;jne	short cap_27
 24385                                  ;		jne	short cap_31
 24386                                  ;		jmp	cap_14
 24387                                  ;cap_27:
 24388                                  		;jmp	short cap_31
 24389                                  
 24390                                  ;		;/* No partitions to make active */
 24391                                  ;cap_28:
 24392                                  ;		;push	word [error_16_seg]
 24393                                  ;		push	ds
 24394                                  ;		push	word [error_16_off]
 24395                                  ;		jmp	short cap_30
 24396                                  ;cap_29:
 24397                                  ;		;push	word [error_26_seg]
 24398                                  ;		push	ds
 24399                                  ;		push	word [error_26_off]
 24400                                  ;cap_30:
 24401                                  ;		call	display
 24402                                  ;		;pop	bx
 24403                                  ;		;pop	bx
 24404                                  ;
 24405                                  ;		jmp	cap_31 ; 19/12/2018
 24406                                  
 24407                                  ;		;/* clear the screen before going back to main menu */
 24408                                  ;cap_31:
 24409                                  ;		cmp	byte [cap_input],1Bh  ; ESC key
 24410                                  ;		;jne	short cap_32
 24411                                  ;		;jmp	cap_11
 24412                                  ;		je	cap_11
 24413                                  ;cap_32:
 24414                                  ;		jmp	cap_10
 24415                                  ;cap_33:
 24416                                  ;		mov	sp,bp
 24417                                  ;		pop	bp
 24418                                  ;		retn
 24419                                  
 24420                                  ; ----------------------------------------------------------------------------
 24421                                  ; fdisk.c (FDISK, MSDOS 6.0, 1991)	
 24422                                  ; ----------------------------------------------------------------------------
 24423                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 19/12/2018)
 24424                                  
 24425                                  ;/*  */
 24426                                  ;void reboot_system()
 24427                                  ;BEGIN
 24428                                  ;
 24429                                  ;    char far *boot_drive;
 24430                                  ;    char     boot_letter;
 24431                                  ;    char     i,j;
 24432                                  ;    FLAG     boot_changed;
 24433                                  ;
 24434                                  ;    clear_screen(u(0),u(0),u(24),u(79));
 24435                                  ;    if (quiet_flag == FALSE)
 24436                                  ;	BEGIN
 24437                                  ;	regs.h.ah = 0x52;
 24438                                  ;	intdosx(&regs,&regs,&segregs);
 24439                                  ;	FP_SEG(boot_drive) = segregs.es;
 24440                                  ;	FP_OFF(boot_drive) = regs.x.bx + u(0x43);
 24441                                  ;	boot_letter = *boot_drive + c(0x40);
 24442                                  ;	if (boot_letter != 'A')
 24443                                  ;	    {
 24444                                  ;	    boot_changed = TRUE;
 24445                                  ;	    for (i=0; i<number_of_drives; i++)
 24446                                  ;		for (j=0; j<4; j++)
 24447                                  ;		    if (part_table[i][j].drive_letter == boot_letter)
 24448                                  ;			boot_changed = part_table[i][j].changed;
 24449                                  ;	    if (boot_changed == FALSE)
 24450                                  ;		display(menu_60);
 24451                                  ;	    else
 24452                                  ;		display(menu_38);
 24453                                  ;	    } 
 24454                                  ;	else/
 24455                                  ;	    display(menu_38);
 24456                                  ;	getch();
 24457                                  ;	reboot();
 24458                                  ;	END
 24459                                  ;   else
 24460                                  ;	BEGIN
 24461                                  ;	cur_disk = c(0);
 24462                                  ;	reset_video_information();
 24463                                  ;	if ( (find_partition_type(uc(DOS12))) ||
 24464                                  ;	     (find_partition_type(uc(DOS16))) ||
 24465                                  ;	     (find_partition_type(uc(DOSNEW))) )
 24466                                  ;	    exit(ERR_LEVEL_0);
 24467                                  ;	else
 24468                                  ;	    exit(ERR_LEVEL_1);
 24469                                  ;	END
 24470                                  ;END
 24471                                  
 24472                                  reboot_system:
 24473                                  		; 19/12/2018
 24474                                  
 24475                                  	%define r_boot_drive	bp-12 ; far ptr, dword
 24476                                  	%define r_boot_changed	bp-8  ; flag, byte
 24477                                  	%define r_i		bp-6  ; char, byte	
 24478                                  	%define r_j		bp-4  ; char, byte
 24479                                  	%define r_boot_letter	bp-2  ; char, byte 
 24480                                  
 24481                                  		;push	bp
 24482 000035E5 89E5                    		mov	bp,sp
 24483 000035E7 83EC0C                  		sub	sp,12
 24484                                  
 24485 000035EA B84F00                  		mov	ax,79
 24486 000035ED 50                      		push	ax
 24487 000035EE B81800                  		mov	ax,24
 24488 000035F1 50                      		push	ax
 24489 000035F2 29C0                    		sub	ax,ax
 24490 000035F4 50                      		push	ax
 24491 000035F5 50                      		push	ax
 24492 000035F6 E89DDE                  		call	clear_screen
 24493 000035F9 83C408                  		add	sp,8
 24494 000035FC 803E[4EA1]00            		cmp	byte [quiet_flag],0
 24495 00003601 7402                    		je	short rebootsys_0
 24496 00003603 EB75                    		jmp	rebootsys_8
 24497                                  rebootsys_0:
 24498                                  		;Get Pointer to DOS SYSVARS
 24499 00003605 06                      		push	es
 24500 00003606 B452                    		mov	ah,52h
 24501 00003608 CD21                    		int	21h
 24502                                  			; ES:BX = pointer to DOS "sysvars", 
 24503                                  			;	  a table of pointers used by DOS
 24504 0000360A 268A07                  		mov	al,[es:bx]
 24505 0000360D 07                      		pop	es
 24506 0000360E 0440                    		add	al,40h
 24507 00003610 8846FE                  		mov	[r_boot_letter],al
 24508 00003613 3C41                    		cmp	al,'A'
 24509 00003615 7456                    		je	short rebootsys_6
 24510 00003617 C646F801                		mov	byte [r_boot_changed],1
 24511 0000361B C646FC00                		mov	byte [r_j],0
 24512 0000361F EB2E                    		jmp	short rebootsys_4
 24513                                  rebootsys_1:
 24514 00003621 FE46FA                  		inc	byte [r_i]
 24515                                  rebootsys_2:
 24516 00003624 807EFA04                		cmp	byte [r_i],4
 24517 00003628 7D22                    		jge	short rebootsys_3
 24518 0000362A 8A46FC                  		mov	al,[r_j]
 24519                                  		;cbw
 24520                                  		;shl	ax,1
 24521                                  		;shl	ax,1
 24522 0000362D D0E0                    		shl	al,1
 24523 0000362F D0E0                    		shl	al,1
 24524                                  		;mov	cx,ax
 24525                                  		;mov	al,[r_i]
 24526                                  		;cbw
 24527                                  		;add	ax,cx
 24528 00003631 0246FA                  		add	al,[r_i]
 24529                                  		;mov	cx,46
 24530                                  		;imul	cx
 24531 00003634 B12E                    		mov	cl,46
 24532 00003636 F6E1                    		mul	cl
 24533 00003638 89C3                    		mov	bx,ax
 24534 0000363A 8A46FE                  		mov	al,[r_boot_letter]
 24535 0000363D 3887[4DC4]              		cmp	byte [part_table_drive_letter+bx],al
 24536 00003641 75DE                    		jne	short rebootsys_1
 24537 00003643 8A87[33C4]              		mov	al,[part_table_changed+bx]
 24538 00003647 8846F8                  		mov	[r_boot_changed],al
 24539 0000364A EBD5                    		jmp	short rebootsys_1
 24540                                  rebootsys_3:
 24541 0000364C FE46FC                  		inc	byte [r_j]
 24542                                  rebootsys_4:
 24543 0000364F 8A46FC                  		mov	al,[r_j]
 24544                                  		;cbw
 24545 00003652 8A0E[E3C3]              		mov	cl,[number_of_drives]
 24546                                  		;sub	ch,ch
 24547                                  		;cmp	ax,cx
 24548 00003656 38C8                    		cmp	al,cl
 24549 00003658 7D06                    		jge	short rebootsys_5
 24550                                  		;mov	[r_i],ch
 24551 0000365A C646FA00                		mov	byte [r_i],0
 24552 0000365E EBC4                    		jmp	short rebootsys_2
 24553                                  rebootsys_5:
 24554 00003660 807EF800                		cmp	byte [r_boot_changed],0
 24555 00003664 7507                    		jne	short rebootsys_6
 24556                                  		;push	word [menu_60_segment]
 24557 00003666 1E                      		push	ds
 24558 00003667 FF36[699E]              		push	word [menu_60_offset]
 24559 0000366B EB05                    		jmp	short rebootsys_7
 24560                                  rebootsys_6:
 24561                                  		;push	word [menu_38_segment]
 24562 0000366D 1E                      		push	ds
 24563 0000366E FF36[679E]              		push	word [menu_38_offset]
 24564                                  rebootsys_7:
 24565 00003672 E8AFDF                  		call	display
 24566                                  		;pop	bx
 24567                                  		;pop	bx
 24568 00003675 E82900                  		call	getch
 24569                                  		;call	reboot
 24570                                  		;jmp	short rebootsys_12
 24571                                  		; 19/12/2018
 24572                                  		;mov	sp,bp
 24573                                  		;pop	bp
 24574 00003678 EB2C                    		jmp	short reboot
 24575                                  rebootsys_8:
 24576 0000367A C606[E2CB]00            		mov	byte [cur_disk],0
 24577 0000367F E8BFDD                  		call	reset_video_information
 24578 00003682 B001                    		mov	al,1
 24579                                  		;push	ax
 24580 00003684 E83DE7                  		call	find_partition_type
 24581                                  		;pop	bx
 24582                                  		;or	al,al
 24583                                  		;jnz	short rebootsys_9
 24584 00003687 730E                    		jnc	short rebootsys_9
 24585 00003689 B004                    		mov	al,4
 24586                                  		;push	ax
 24587 0000368B E836E7                  		call	find_partition_type
 24588                                  		;pop	bx
 24589                                  		;or	al,al
 24590                                  		;jnz	short rebootsys_9
 24591 0000368E 7307                    		jnc	short rebootsys_9
 24592 00003690 B006                    		mov	al,6
 24593                                  		;push	ax
 24594 00003692 E82FE7                  		call	find_partition_type
 24595                                  		;pop	bx
 24596                                  		;or	al,al
 24597                                  		;jz	short rebootsys_10
 24598 00003695 7204                    		jc	short rebootsys_10
 24599                                  rebootsys_9:
 24600 00003697 29C0                    		sub	ax,ax
 24601 00003699 EB03                    		jmp	short rebootsys_11
 24602                                  rebootsys_10:
 24603 0000369B B80100                  		mov	ax,1
 24604                                  rebootsys_11:
 24605                                  		;push	ax
 24606                                  		;call	_exit
 24607                                  		;pop	bx
 24608 0000369E E9C7C9                  		jmp	_exit
 24609                                  ;rebootsys_12:
 24610                                  ;		mov	sp,bp
 24611                                  ;		pop	bp
 24612                                  ;		retn
 24613                                  
 24614                                  ; getch
 24615                                  ; ----------------------------------------------------------------------------
 24616                                  ; 19/12/2018
 24617                                  
 24618                                  getch:
 24619 000036A1 30E4                    		xor	ah,ah
 24620 000036A3 CD16                    		int	16h
 24621 000036A5 C3                      		retn
 24622                                  
 24623                                  ; reboot (MSDOS 6.0, reboot.asm)
 24624                                  ; ----------------------------------------------------------------------------
 24625                                  ; IBM PC-DOS FDISK.COM (unpacked) /// Segment 0, Offset 2E0Ah [ 19/12/2018 ]
 24626                                  
 24627                                  reboot:
 24628 000036A6 B84000                  		mov	ax,40h ; BIOS DATA segment
 24629 000036A9 8ED8                    		mov	ds,ax
 24630 000036AB C70672003412            		mov	word [72h],1234h ; mov word [WarmBootFlag],WARM_BOOT_CODE
 24631 000036B1 B81535                  		mov	ax,3515h
 24632 000036B4 CD21                    		int	21h	; DOS -	2+ - GET INTERRUPT VECTOR
 24633                                  				; AL = interrupt number
 24634                                  				; Return: ES:BX	= value	of interrupt vector
 24635 000036B6 8CC0                    		mov	ax,es
 24636 000036B8 09D8                    		or	ax,bx
 24637 000036BA 740A                    		jz	short reboot_0
 24638                                  
 24639                                  		;mov	ax,40h
 24640                                  		;mov	ds,ax
 24641                                  
 24642 000036BC C60617000C              		mov	byte [17h],0Ch ; mov byte [KB_FLAG],ALT_SHIFT|SHIFT
 24643 000036C1 B8534F                  		mov	ax,4F53h ; (KB_INTERCEPT SHL 8) OR DEL_KEY
 24644 000036C4 CD15                    		int	15h	; OS HOOK - KEYBOARD INTERCEPT
 24645                                  				;	 (AT model 3x9,XT2,XT286,CONV,PS)
 24646                                  				; AL = scan code, CF set
 24647                                  				; Return: CF set - AL =	scan code
 24648                                  				; CF clear - scan code should be ignored
 24649                                  
 24650                                  reboot_0:	; Jump to the processor power-on address FFFF:0000h
 24651 000036C6 EA0000FFFF              		jmp	0FFFFh:0
 24652                                  
 24653                                  ; ----------------------------------------------------------------------------
 24654                                  ; diskout.c (FDISK, MSDOS 6.0, 1991)	
 24655                                  ; ----------------------------------------------------------------------------
 24656                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 20/12/2018)
 24657                                  
 24658                                  ;/*  */
 24659                                  ;void write_info_to_disk()
 24660                                  ;
 24661                                  ;BEGIN
 24662                                  ;
 24663                                  ;    char     i;
 24664                                  ;    unsigned char j;
 24665                                  ;    unsigned extended_location;
 24666                                  ;    char     extended_index;
 24667                                  ;    char     temp;
 24668                                  ;    char     changed_flag;
 24669                                  ;    char     temp_disk;
 24670                                  ;
 24671                                  ;    /* Change invalid value for temp to 0xff. NUL is a valid value for
 24672                                  ;       the index and cannot be used */
 24673                                  ;
 24674                                  ;    temp = 0xff;
 24675                                  ;    temp_disk = cur_disk;
 24676                                  ;    /* See if need to update the master boot record */
 24677                                  ;    for (j = uc(0); j < number_of_drives; j++)
 24678                                  ;       BEGIN
 24679                                  ;
 24680                                  ;        /* Save disk number */
 24681                                  ;        cur_disk = ((char)(j));
 24682                                  ;
 24683                                  ;        /* See if there were any errors on that drive */
 24684                                  ;        if (good_disk[j])
 24685                                  ;           BEGIN
 24686                                  ;            for (i=c(0); i < c(4); i++)
 24687                                  ;               BEGIN
 24688                                  ;                if (part_table[j][i].changed)
 24689                                  ;                   BEGIN
 24690                                  ;                    write_master_boot_to_disk(j);
 24691                                  ;                    break;
 24692                                  ;                   END
 24693                                  ;               END
 24694                                  ;            /* See if the extended partition exists - if not, don't fool with the logical */
 24695                                  ;            /* drives - there is nothing to point to their structures. Otherwise you get into */
 24696                                  ;            /* a chicken and the egg situation, where you are trying to write out 'deletes' of */
 24697                                  ;            /* the logical drive based on the start of the extended partition, but there isn't one */
 24698                                  ;            /* because it has already been deleted already. Bad things happen - PTM P941 */
 24699                                  ;
 24700                                  ;            /* SR; 9/26/89; Removed semi-colon at the end of the if
 24701                                  ;               statement that caused the block of code to always execute */
 24702                                  ;
 24703                                  ;            if (find_partition_type(uc(EXTENDED)))
 24704                                  ;               BEGIN
 24705                                  ;                /* See if any extended partitions need to be updated */
 24706                                  ;                changed_flag = FALSE;
 24707                                  ;
 24708                                  ;                for (i=c(0);i < c(23); i++)
 24709                                  ;                   BEGIN
 24710                                  ;                    if (ext_table[j][i].changed)
 24711                                  ;                       BEGIN
 24712                                  ;                        changed_flag = TRUE;
 24713                                  ;                        break;
 24714                                  ;                       END
 24715                                  ;                   END
 24716                                  ;                if (changed_flag)
 24717                                  ;                   BEGIN
 24718                                  ;                    /* First,get them in order - drive letters are assigned in the order */
 24719                                  ;                    /* that they exist on the disk */
 24720                                  ;                    sort_ext_table(c(23));
 24721                                  ;
 24722                                  ;                    for (i=c(0);i < c(23); i++)
 24723                                  ;
 24724                                  ;                       BEGIN
 24725                                  ;                        /* If there is a valid drive existing, write it out */
 24726                                  ;                        if (ext_table[j][sort[i]].sys_id != uc(0))
 24727                                  ;                           BEGIN
 24728                                  ;                            write_ext_boot_to_disk(i,j);
 24729                                  ;                           END
 24730                                  ;                       END
 24731                                  ;
 24732                                  ;                    /* Find start of extended partition */
 24733                                  ;                    extended_index = find_partition_location(uc(EXTENDED));
 24734                                  ;                    extended_location = part_table[j][extended_index].start_cyl;
 24735                                  ;
 24736                                  ;                    /* See if the first entry in EXTENDED DOS partition will be written out */
 24737                                  ;                    /* Need to find the first drive in the sorted list */
 24738                                  ;                    for (i=c(0);i < c(23); i++)
 24739                                  ;                       BEGIN
 24740                                  ;                        if (ext_table[j][sort[i]].sys_id != uc(0))
 24741                                  ;                           BEGIN
 24742                                  ;                            temp = sort[i];
 24743                                  ;                            break;
 24744                                  ;                           END
 24745                                  ;                       END
 24746                                  ;                    /* See if drive written out */
 24747                                  ;                    /* SR; 9/28/89; Check for the special case when the
 24748                                  ;                       volume is deleted and write out only a pointer
 24749                                  ;                       for it */
 24750                                  ;
 24751                                  ;                    if ((temp == c(0xff)) ||
 24752                                  ;                        (extended_location != ext_table[j][temp].start_cyl))
 24753                                  ;                       BEGIN
 24754                                  ;                        /* If not, make a special case and go do it */
 24755                                  ;                        /* Use the 24 entry in the array to set up a dummy entry */
 24756                                  ;                        /* This one isn't used for anything else */
 24757                                  ;                        /* Indicate this is special by passing along a deleted entry - the subroutine will catch it and handle correctly */
 24758                                  ;                        ext_table[j][23].sys_id = uc(0);
 24759                                  ;                        ext_table[j][23].start_cyl = part_table[j][extended_index].start_cyl;
 24760                                  ;                        ext_table[j][23].start_head = uc(0);
 24761                                  ;                        ext_table[j][23].start_sector = uc(1);
 24762                                  ;
 24763                                  ;                        /* Write out our modified first location - only pointer info will be sent to the disk */
 24764                                  ;                        write_ext_boot_to_disk(c(23),j);
 24765                                  ;                       END
 24766                                  ;                   END
 24767                                  ;               END
 24768                                  ;           END
 24769                                  ;       END
 24770                                  ;    cur_disk = temp_disk;
 24771                                  ;    return;
 24772                                  ;END
 24773                                  
 24774                                  write_info_to_disk:
 24775                                  		; 04/01/2019
 24776                                  		; 20/12/2018
 24777                                  	
 24778                                  	%define witd_j		   bp-10 ; bp-14
 24779                                  	%define witd_i		   bp-8  ; bp-12
 24780                                  	%define witd_extd_location bp-6	 ; bp-10
 24781                                  	%define witd_extd_index    bp-4	 ; bp-8
 24782                                  	%define witd_temp	   bp-12 ; bp-6
 24783                                  	;%define witd_changed_flag       ; bp-4
 24784                                  	%define witd_temp_disk	   bp-2  ; bp-2
 24785                                  
 24786                                  		;push	bp
 24787 000036CB 89E5                    		mov	bp,sp
 24788                                  		;;sub	sp,14
 24789                                  		;sub	sp,10
 24790 000036CD 83EC0C                  		sub	sp,12 ; 04/01/2019
 24791                                  
 24792                                  		;push	si
 24793                                  
 24794 000036D0 C646F4FF                		mov	byte [witd_temp],0FFh ; 04/01/2019
 24795                                  
 24796 000036D4 A0[E2CB]                		mov	al,[cur_disk]
 24797 000036D7 8846FE                  		mov	[witd_temp_disk],al
 24798 000036DA C746F60000              		mov	word [witd_j],0
 24799 000036DF E93E01                  		jmp	witd_16
 24800                                  witd_1:
 24801 000036E2 FE46F8                  		inc	byte [witd_i]
 24802                                  ;witd_2:
 24803 000036E5 807EF804                		cmp	byte [witd_i],4
 24804 000036E9 7D20                    		jge	short witd_3
 24805                                  witd_2:
 24806 000036EB 8A46F8                  		mov	al,[witd_i] ; Partition number
 24807                                  		;cbw
 24808 000036EE 8A4EF6                  		mov	cl,[witd_j] ; Disk number
 24809                                  		;sub	ch,ch
 24810                                  		;shl	cx,1
 24811                                  		;shl	cx,1
 24812 000036F1 D0E1                    		shl	cl,1
 24813 000036F3 D0E1                    		shl	cl,1
 24814                                  		;add	ax,cx
 24815 000036F5 00C8                    		add	al,cl
 24816                                  		;mov	cx,46
 24817                                  		;imul	cx
 24818 000036F7 B12E                    		mov	cl,46
 24819 000036F9 F6E1                    		mul	cl
 24820 000036FB 89C3                    		mov	bx,ax
 24821 000036FD 80BF[33C4]00            		cmp	byte [part_table_changed+bx],0
 24822 00003702 74DE                    		je	short witd_1
 24823 00003704 8A46F6                  		mov	al,[witd_j]
 24824 00003707 50                      		push	ax
 24825 00003708 E83101                  		call	write_master_boot_to_disk
 24826                                  		;pop	bx
 24827                                  
 24828                                  		;/* See if the extended partition exists - if not, 
 24829                                  		;   don't fool with the logical drives */
 24830                                  witd_3:
 24831 0000370B B005                    		mov	al,5 ; EXTENDED
 24832                                  		;push	ax
 24833 0000370D E8B4E6                  		call	find_partition_type
 24834                                  			 ; CL = Partition number if CF = 0
 24835                                  		;pop	bx
 24836                                  		;or	al, al
 24837                                  		;jnz	short witd_4
 24838 00003710 7303                    		jnc	short witd_4
 24839 00003712 E90001                  		jmp	witd_15
 24840                                  witd_4:
 24841 00003715 884EFC                  		mov	[witd_extd_index],cl ; *==
 24842                                  
 24843                                   		;/* See if any extended partitions need to be updated */
 24844                                  
 24845                                  		;sub	al,al
 24846                                  		;sub	ax,ax
 24847                                  		;mov	[witd_changed_flag],al ; 0  ; FALSE
 24848                                  		;;mov	[witd_i],al ; reset
 24849                                  		;mov	[witd_i],ax ; 0
 24850 00003718 C746F80000              		mov	word [witd_i],0
 24851 0000371D EB0B                    		jmp	short witd_6
 24852                                  witd_5:
 24853 0000371F FE46F8                  		inc	byte [witd_i]
 24854                                  ;witd_6:
 24855 00003722 807EF817                		cmp	byte [witd_i],23
 24856                                  		;jge	short witd_7
 24857 00003726 0F8DEB00                		jge	witd_15
 24858                                  witd_6:
 24859                                  		;mov	al,[witd_i]
 24860                                  		;cbw
 24861                                  		;mov	cx,ax
 24862 0000372A 8A4EF8                  		mov	cl,[witd_i]
 24863 0000372D B018                    		mov	al,24
 24864 0000372F F666F6                  		mul	byte [witd_j]
 24865                                  		;add	ax,cx
 24866 00003732 00C8                    		add	al,cl
 24867                                  		;mov	cx,46
 24868                                  		;imul	cx
 24869 00003734 B12E                    		mov	cl,46
 24870 00003736 F6E1                    		mul	cl
 24871 00003738 89C3                    		mov	bx,ax
 24872 0000373A 80BF[6BA1]00            		cmp	byte [ext_table_changed+bx],0
 24873 0000373F 74DE                    		je	short witd_5
 24874                                  
 24875                                  		;mov	byte [witd_changed_flag],1 ; TRUE
 24876                                  ;witd_7:
 24877                                  ;		cmp	byte [witd_changed_flag],0
 24878                                  ;		jne	short witd_8
 24879                                  ;		jmp	witd_15
 24880                                  
 24881                                   	;/* First,get them in order - drive letters are assigned in the order */
 24882                                  	;/* that they exist on the disk */
 24883                                  witd_8:
 24884                                  		;mov	al,23
 24885                                  		;push	ax
 24886 00003741 B117                    		mov	cl,23
 24887 00003743 E8C9F2                  		call	sort_ext_table
 24888                                  		;pop	bx
 24889                                  		
 24890 00003746 C646F800                		mov	byte [witd_i],0
 24891                                  witd_9:
 24892 0000374A B018                    		mov	al,24
 24893 0000374C F666F6                  		mul	byte [witd_j] ; Disk (0 to 7)
 24894                                  		;mov	cx,ax
 24895                                  		;mov	al,[witd_i]
 24896                                  		;cbw
 24897                                  		;mov	bx,ax
 24898 0000374F 8B5EF8                  		mov	bx,[witd_i] ; Logical drive (0 to 22)	
 24899                                  		;mov	al,[sort+bx]
 24900                                  		;cbw
 24901                                  		;add	ax,cx
 24902 00003752 0287[F0C3]              		add	al,[sort+bx]	
 24903                                  		;mov	cx,46
 24904                                  		;imul	cx
 24905 00003756 B12E                    		mov	cl,46
 24906 00003758 F6E1                    		mul	cl
 24907 0000375A 89C3                    		mov	bx,ax
 24908                                  
 24909 0000375C 80BF[5DA1]00            		cmp	byte [ext_table_sys_id+bx],0
 24910 00003761 740B                    		je	short witd_10 ; Empty partition
 24911                                  
 24912 00003763 8A46F6                  		mov	al,[witd_j]
 24913 00003766 50                      		push	ax
 24914 00003767 8A46F8                  		mov	al,[witd_i]
 24915 0000376A 50                      		push	ax
 24916 0000376B E86801                  		call	write_ext_boot_to_disk
 24917                                  		;pop	bx
 24918                                  		;pop	bx
 24919                                  witd_10:
 24920 0000376E FE46F8                  		inc	byte [witd_i]
 24921 00003771 807EF817                		cmp	byte [witd_i],23
 24922 00003775 72D3                    		jb	short witd_9 ; 04/01/2019
 24923                                  
 24924                                  		;/* Find start of extended partition */
 24925                                  
 24926                                  		;mov	al,5
 24927                                  		;push	ax
 24928                                  		;call	find_partition_location
 24929                                  		;pop	bx
 24930                                  		;mov	[witd_extd_index],al ; *==
 24931                                  		
 24932                                  		;cbw
 24933                                  		;mov	cl,[witd_j]
 24934                                  		;sub	ch,ch
 24935                                  		;shl	cx,1
 24936                                  		;shl	cx,1
 24937                                  		;add	ax,cx
 24938                                  
 24939 00003777 8A46F6                  		mov	al,[witd_j]
 24940 0000377A D0E0                    		shl	al,1
 24941 0000377C D0E0                    		shl	al,1
 24942 0000377E 0246FC                  		add	al,[witd_extd_index] ; *==		
 24943                                  
 24944                                  		;mov	cx,46
 24945                                  		;imul	cx
 24946 00003781 B12E                    		mov	cl,46
 24947 00003783 F6E1                    		mul	cl		
 24948 00003785 89C3                    		mov	bx,ax
 24949                                  
 24950 00003787 8B87[23C4]              		mov	ax,[part_table_start_cyl+bx]
 24951 0000378B 8946FA                  		mov	[witd_extd_location],ax
 24952                                  
 24953                                  	;/* See if the first entry in EXTENDED DOS partition will be written out */
 24954                                  	;/* Need to find the first drive in the sorted list */
 24955                                  
 24956 0000378E C646F800                		mov	byte [witd_i],0
 24957 00003792 EB09                    		jmp	short witd_12
 24958                                  witd_11:
 24959 00003794 FE46F8                  		inc	byte [witd_i]
 24960                                  ;witd_12:
 24961 00003797 807EF817                		cmp	byte [witd_i],23
 24962 0000379B 7D1E                    		jge	short witd_13 ; 04/01/2019
 24963                                  witd_12:
 24964 0000379D B018                    		mov	al,24
 24965 0000379F F666F6                  		mul	byte [witd_j]
 24966                                  		;mov	cx,ax
 24967                                  		;mov	al,[witd_i]
 24968                                  		;cbw
 24969 000037A2 8B5EF8                  		mov	bx,[witd_i]
 24970                                  		;mov	al,[sort+bx]
 24971 000037A5 8A97[F0C3]              		mov	dl,[sort+bx] ; 04/01/2019
 24972                                  		;mov	dx,ax
 24973                                  		;cbw
 24974                                  		;add	ax,cx
 24975 000037A9 00D0                    		add	al,dl ; 04/01/2019	
 24976                                  
 24977                                  		;mov	cx,46
 24978                                  		;mov	bx,dx
 24979                                  		;imul	cx
 24980                                  		;mov	cl,46
 24981 000037AB F6E1                    		mul	cl
 24982                                  		;mov	si,ax
 24983 000037AD 89C3                    		mov	bx,ax
 24984                                  		;cmp	byte [ext_table_sys_id+si],0
 24985 000037AF 80BF[5DA1]00            		cmp	byte [ext_table_sys_id+bx],0
 24986 000037B4 74DE                    		je	short witd_11
 24987                                  
 24988                                  		; 04/01/2019	
 24989                                  		;mov	[witd_temp],bl
 24990 000037B6 8856F4                  		mov	[witd_temp],dl
 24991                                  
 24992 000037B9 EB12                    		jmp	short witd_18 ; 20/12/2018
 24993                                  
 24994                                  		;/* See if drive written out */
 24995                                  
 24996                                  		;/* Check for the special case when the
 24997                                                  ;   volume is deleted and write out only a pointer for it */
 24998                                  
 24999                                  		; 21/12/2018
 25000                                  witd_13:	; 04/01/2019	
 25001 000037BB 807EF4FF                		cmp	byte [witd_temp],0FFh ; 255
 25002 000037BF 7415                    		je	short witd_14
 25003                                  
 25004                                  		;;mov	al,[witd_temp]
 25005                                  		;;cbw
 25006                                  		;;mov	cx,ax
 25007                                  		;mov	dl,[witd_temp]	
 25008                                  ;witd_18:	
 25009                                  		; 04/01/2019	
 25010 000037C1 B018                    		mov	al,24
 25011 000037C3 F666F6                  		mul	byte [witd_j]
 25012                                  		;;add	ax,cx
 25013                                  		;add	al,dl
 25014 000037C6 0246F4                  		add	al,[witd_temp]
 25015                                  		;;mov	cx,46
 25016                                  		;;imul	cx
 25017                                  		;mov	cl,46
 25018 000037C9 F6E1                    		mul	cl
 25019 000037CB 89C3                    		mov	bx,ax
 25020                                  
 25021                                  witd_18:	; 04/01/2019
 25022 000037CD 8B46FA                  		mov	ax,[witd_extd_location]
 25023 000037D0 3987[5BA1]              		cmp	[ext_table_start_cyl+bx],ax
 25024 000037D4 743F                    		je	short witd_15
 25025                                  witd_14:
 25026 000037D6 8A46F6                  		mov	al,[witd_j]
 25027 000037D9 28E4                    		sub	ah,ah ; 04/01/2019
 25028 000037DB B95004                  		mov	cx,1104 ; 46*24
 25029                                  		;mov	bx,ax
 25030 000037DE 88C3                    		mov	bl,al
 25031                                  		;imul	cx
 25032 000037E0 F7E1                    		mul	cx
 25033 000037E2 89C6                    		mov	si,ax
 25034 000037E4 C684[7FA5]00            		mov	byte [ep0_lp23_sys_id+si],0
 25035 000037E9 8A46FC                  		mov	al,[witd_extd_index]
 25036                                  		;cbw
 25037                                  		;shl	bx,1
 25038                                  		;shl	bx,1
 25039 000037EC D0E3                    		shl	bl,1
 25040 000037EE D0E3                    		shl	bl,1
 25041                                  		;add	ax,bx
 25042 000037F0 00D8                    		add	al,bl
 25043 000037F2 B92E00                  		mov	cx,46
 25044                                  		;imul	cx
 25045 000037F5 F6E1                    		mul	cl
 25046 000037F7 89C3                    		mov	bx,ax
 25047                                  
 25048                                  		;/* If not, make a special case and go do it */
 25049                                  		;/* Use the 24 entry in the array to set up a dummy entry */
 25050                                  		;/* This one isn't used for anything else */
 25051                                  
 25052 000037F9 8B87[23C4]              		mov	ax,[part_table_start_cyl+bx]
 25053 000037FD 8984[7DA5]              		mov	[ep0_lp23_start_cyl+si],ax
 25054 00003801 C684[7BA5]00            		mov	byte [ep0_lp23_start_head+si],0
 25055 00003806 C684[7CA5]01            		mov	byte [ep0_lp23_start_sector+si],1
 25056                                  		
 25057                                   		;/* Write out our modified first location -
 25058                                  		;   only pointer info will be sent to the disk */
 25059                                  
 25060 0000380B 8A46F6                  		mov	al,[witd_j] ; 04/01/2019
 25061 0000380E 50                      		push	ax
 25062 0000380F B017                    		mov	al,23	; Logical drive	(23)
 25063 00003811 50                      		push	ax
 25064 00003812 E8C100                  		call	write_ext_boot_to_disk
 25065                                  		;pop	bx
 25066                                  		;pop	bx
 25067                                  witd_15:
 25068 00003815 FE46F6                  		inc	byte [witd_j]  ; next disk
 25069                                  ;witd_16:
 25070                                  		;/* See if need to update the master boot record */
 25071                                  
 25072 00003818 A0[E3C3]                		mov	al,[number_of_drives]
 25073 0000381B 3846F6                  		cmp	byte [witd_j],al
 25074 0000381E 7313                    		jnb	short witd_17
 25075                                  witd_16:
 25076                                  		;mov	al,[witd_j]
 25077                                  		;mov	[cur_disk],al
 25078                                  		;mov	bl,al
 25079                                  		;sub	bh,bh
 25080 00003820 8B5EF6                  		mov	bx,[witd_j]
 25081 00003823 881E[E2CB]              		mov	[cur_disk],bl		
 25082                                  
 25083                                  		;/* See if there were any errors on that drive */
 25084                                  
 25085 00003827 38BF[50A1]              		cmp	byte [good_disk+bx],bh ; 0
 25086 0000382B 74E8                    		je	short witd_15
 25087 0000382D 887EF8                  		mov	[witd_i],bh ; 0
 25088 00003830 E9B8FE                  		jmp	witd_2
 25089                                  witd_17:
 25090 00003833 8A46FE                  		mov	al,[witd_temp_disk]
 25091 00003836 A2[E2CB]                		mov	[cur_disk],al
 25092                                  
 25093                                  		;pop	si
 25094                                  		
 25095 00003839 89EC                    		mov	sp,bp
 25096                                  		;pop	bp
 25097 0000383B C3                      		retn
 25098                                  
 25099                                  ; ----------------------------------------------------------------------------
 25100                                  
 25101                                  ;/*  */
 25102                                  ;char write_master_boot_to_disk(disk)
 25103                                  ;
 25104                                  ;unsigned char   disk;
 25105                                  ;
 25106                                  ;BEGIN
 25107                                  ;
 25108                                  ;    unsigned char i;
 25109                                  ;    unsigned j;
 25110                                  ;    unsigned long long_temp;
 25111                                  ;    unsigned index;
 25112                                  ;
 25113                                  ;    /* Clean out the boot_record */
 25114                                  ;    for (j=u(0);j < u(BYTES_PER_SECTOR); j++)
 25115                                  ;       BEGIN
 25116                                  ;        boot_record[j] = uc(0);
 25117                                  ;       END
 25118                                  ;
 25119                                  ;    /* Copy the master boot record to boot_record */
 25120                                  ;    for (j=u(0); j < u(BYTES_PER_SECTOR); j++)
 25121                                  ;       BEGIN
 25122                                  ;        boot_record[j] = master_boot_record[disk][j];
 25123                                  ;       END
 25124                                  ;
 25125                                  ;    /* Copy the partition tables over - only bother with the changed ones */
 25126                                  ;    for (i=uc(0); i < uc(4); i++)
 25127                                  ;       BEGIN
 25128                                  ;        index = ((unsigned)i)*16;
 25129                                  ;        if (part_table[disk][i].changed)
 25130                                  ;           BEGIN
 25131                                  ;            /* Get boot ind */
 25132                                  ;            boot_record[0x1BE+(index)] = part_table[disk][i].boot_ind;
 25133                                  ;
 25134                                  ;            /* Start head */
 25135                                  ;            boot_record[0x1BF+(index)] = part_table[disk][i].start_head;
 25136                                  ;
 25137                                  ;            /* Start sector - scramble it to INT 13 format*/
 25138                                  ;            boot_record[0x1C0+(index)] = (part_table[disk][i].start_sector & 0x3F)  |
 25139                                  ;                                           ((unsigned char)((part_table[disk][i].start_cyl/256) << 6));
 25140                                  ;
 25141                                  ;            /* Start cyl - scramble it to INT 13 format */
 25142                                  ;            boot_record[0x1C1+(index)] = ((unsigned char)(part_table[disk][i].start_cyl%256));
 25143                                  ;
 25144                                  ;            /* System id */
 25145                                  ;            boot_record[0x1C2+(index)] = part_table[disk][i].sys_id;
 25146                                  ;
 25147                                  ;            /* End head */
 25148                                  ;            boot_record[0x1C3+(index)] = part_table[disk][i].end_head;
 25149                                  ;
 25150                                  ;            /* End sector - scramble it to INT 13 format*/
 25151                                  ;            boot_record[0x1C4+(index)] = (part_table[disk][i].end_sector & 0x3F)  |
 25152                                  ;                                            ((unsigned char)((part_table[disk][i].end_cyl/256) << 6));
 25153                                  ;
 25154                                  ;            /* End cyl - scramble it to INT 13 format*/
 25155                                  ;            boot_record[0x1C5+(index)] = ((unsigned char)(part_table[disk][i].end_cyl%256));
 25156                                  ;
 25157                                  ;            /* Relative sectors */
 25158                                  ;            long_temp = part_table[disk][i].rel_sec;
 25159                                  ;            boot_record[0x1C9+(index)] = uc((long_temp >> 24));
 25160                                  ;            boot_record[0x1C8+(index)] = uc(((long_temp & 0x00FF0000l) >> 16));
 25161                                  ;            boot_record[0x1C7+(index)] = uc(((long_temp & 0x0000FF00l) >> 8));
 25162                                  ;            boot_record[0x1C6+(index)] = uc((long_temp & 0x000000FFl));
 25163                                  ;
 25164                                  ;
 25165                                  ;            /* Number of sectors */
 25166                                  ;            long_temp = part_table[disk][i].num_sec;
 25167                                  ;            boot_record[0x1CD+(index)] = uc(long_temp >> 24);
 25168                                  ;            boot_record[0x1CC+(index)] = uc((long_temp & 0x00FF0000l) >> 16);
 25169                                  ;            boot_record[0x1CB+(index)] = uc((long_temp & 0x0000FF00l) >> 8);
 25170                                  ;            boot_record[0x1CA+(index)] = uc(long_temp & 0x000000FFl);
 25171                                  ;          END
 25172                                  ;       END
 25173                                  ;    boot_record[510] = uc(0x55);
 25174                                  ;    boot_record[511] = uc(0xAA);
 25175                                  ;
 25176                                  ;    return(write_boot_record(u(0),disk));
 25177                                  ;END
 25178                                  
 25179                                  write_master_boot_to_disk:
 25180                                  		; 21/12/2018
 25181                                  
 25182                                  	;%define wmbr_long_temp	bp-12 ; bp-14
 25183                                  	%define wmbr_j		bp-8  ; bp-10	
 25184                                  	%define wmbr_i		bp-6  ; bp-8
 25185                                  	%define wmbr_index	bp-4  ; bp-6
 25186                                  	
 25187                                  	%define wmbr_disk	bp+4
 25188                                  
 25189 0000383C 55                      		push	bp
 25190 0000383D 89E5                    		mov	bp,sp
 25191                                  		;;sub	sp,14
 25192                                  		;sub	sp,12
 25193 0000383F 83EC08                  		sub	sp,8
 25194                                  
 25195                                  		;push	di
 25196                                  		;push	si
 25197                                  
 25198 00003842 C746F80000              		mov	word [wmbr_j],0
 25199                                  
 25200                                  		;/* Clean out the boot_record */
 25201                                  ;wmbr_0:
 25202                                  		;;mov	bx,[wmbr_j]
 25203                                  		;;mov	byte [boot_record+bx],0
 25204                                  		;;inc	word [wmbr_j]
 25205                                  		;;cmp	word [wmbr_j],512
 25206                                  		;;jb	short wmbr_0
 25207                                  		;;mov	word [wmbr_j],0
 25208                                  		
 25209                                  		;xor	ax,ax
 25210                                  		;mov	di,boot_record
 25211                                  		;mov	cx,256
 25212                                  		;;push	ds
 25213                                  		;;pop	es
 25214                                  		;rep	stosw
 25215                                  
 25216                                  		;/* Copy the master boot record to boot_record */
 25217                                  wmbr_1:
 25218                                  		;mov	cl,9
 25219                                  		;mov	al,[wmbr_disk]
 25220                                  		;sub	ah,ah
 25221                                  		;mov	si,ax
 25222                                  		;shl	si,cl
 25223                                  		;mov	bx,[wmbr_j]
 25224                                  		;mov	al,[master_boot_record+bx+si]
 25225                                  		;mov	[boot_record+bx],al
 25226                                  		;inc	word [wmbr_j]
 25227                                  		;cmp	word [wmbr_j],512
 25228                                  		;jb	short wmbr_1
 25229                                  
 25230 00003847 8A4604                  		mov	al,[wmbr_disk]
 25231 0000384A 30E4                    		xor	ah,ah
 25232 0000384C 89C6                    		mov	si,ax
 25233 0000384E B109                    		mov	cl,9
 25234 00003850 D3E6                    		shl	si,cl ; * 512
 25235 00003852 81C6[925F]              		add	si,master_boot_record
 25236 00003856 BF[E0C9]                		mov	di,boot_record		
 25237 00003859 B90001                  		mov	cx,256
 25238 0000385C F3A5                    		rep	movsw
 25239                                  
 25240                                  	;/* Copy the partition tables over - only bother with the changed ones */
 25241                                  
 25242                                  		;mov	byte [wmbr_i],ah ; 0
 25243 0000385E 894EFA                  		mov	word [wmbr_i],cx ; 0
 25244                                  wmbr_2:
 25245 00003861 B104                    		mov	cl,4
 25246                                  		;mov	al,[wmbr_i]
 25247                                  		;sub	ah,ah
 25248                                  		;mov	dx,ax
 25249                                  		;shl	ax,cl
 25250                                  		
 25251                                  		;mov	ax,[wmbr_i]
 25252                                  		;mov	bx,ax
 25253 00003863 8B5EFA                  		mov	bx,[wmbr_i]
 25254 00003866 88D8                    		mov	al,bl
 25255                                  		;shl	bx,cl ; * 16
 25256 00003868 D2E3                    		shl	bl,cl
 25257                                  		;mov	[wmbr_index],ax
 25258 0000386A 895EFC                  		mov	[wmbr_index],bx ; Partition table entry offset
 25259                                  		;mov	al,[wmbr_disk]
 25260                                  		;sub	ah,ah
 25261                                  		;shl	ax,1
 25262                                  		;shl	ax,1
 25263                                  		;add	ax,dx
 25264 0000386D 8A4E04                  		mov	cl,[wmbr_disk]
 25265 00003870 D0E1                    		shl	cl,1
 25266 00003872 D0E1                    		shl	cl,1
 25267 00003874 00C8                    		add	al,cl	; FDISK Partititon data index	
 25268                                  		;mov	cx,46
 25269                                  		;imul	cx
 25270 00003876 B12E                    		mov	cl,46
 25271 00003878 F6E1                    		mul	cl
 25272 0000387A 89C3                    		mov	bx,ax	; FDISK Partition data offset
 25273 0000387C 80BF[33C4]00            		cmp	byte [part_table_changed+bx],0
 25274                                  		;jne	short wmbr_3
 25275                                  		;jmp	wmbr_4
 25276 00003881 7434                    		je	short wmbr_4
 25277                                  wmbr_3:
 25278                                  		;mov	al,[part_table_boot_ind+bx]
 25279                                  		;mov	si,[wmbr_index]
 25280                                  		;mov	[boot_record+1BEh+si],al
 25281                                  		;mov	al,[part_table_start_head+bx]
 25282                                  		;mov	[boot_record+1BFh+si],al
 25283                                  		;mov	ax,[part_table_start_cyl+bx]
 25284                                  		;;mov	cx,ax
 25285                                  		;mov	ch,al
 25286                                  		;shr	ax,1
 25287                                  		;shr	ax,1
 25288                                  		;;mov	dx,ax
 25289                                  		;and	al,0C0h
 25290                                  		;;xor	al,[part_table_start_sector+bx]
 25291                                  		;;and	al,3Fh
 25292                                  		;;xor	dl,al
 25293                                  		;;mov	[boot_record+1C0h+si],dl
 25294                                  		;;mov	[boot_record+1C1h+si],cl  ; Start cylinder
 25295                                  		;mov	cl,[part_table_start_sector+bx]
 25296                                  		;;and	cl,3Fh
 25297                                  		;or	cl,al
 25298                                  		;mov	[boot_record+1C0h+si],cl  ; Start sector
 25299                                  		;mov	[boot_record+1C1h+si],ch  ; Start cylinder		
 25300                                  		;
 25301                                  		;mov	al,[part_table_sys_id+bx]
 25302                                  		;mov	[boot_record+1C2h+si],al
 25303                                  		;mov	al,[part_table_end_head+bx]
 25304                                  		;mov	[boot_record+1C3h+si],al
 25305                                  		;mov	ax,[part_table_end_cyl+bx]
 25306                                  		;;mov	cx,ax
 25307                                  		;shr	ax,1
 25308                                  		;shr	ax,1
 25309                                  		;;mov	dx,ax
 25310                                  		;and	al,0C0h
 25311                                  		;;xor	al,[part_table_end_sector+bx]
 25312                                  		;;and	al,3Fh
 25313                                  		;;xor	dl,al
 25314                                  		;;mov	[boot_record+1C4h+si],dl
 25315                                  		;;mov	[boot_record+1C5h+si],cl
 25316                                  		;mov	cl,[part_table_end_sector+bx]
 25317                                  		;;and	cl,3Fh
 25318                                  		;or	cl,al		
 25319                                  		;mov	[boot_record+1C4h+si],cl  ; End sector
 25320                                  		;mov	[boot_record+1C5h+si],ch  ; End cylinder
 25321                                  
 25322 00003883 8DB7[20C4]              		lea	si,[part_table_boot_ind+bx]
 25323                                  		;es = ds = cs = ss
 25324 00003887 8B7EFC                  		mov	di,[wmbr_index]
 25325 0000388A 81C7[9ECB]              		add	di,boot_record+1BEh
 25326                                  		
 25327 0000388E A5                      		movsw	; boot indicator & start head
 25328                                  		
 25329 0000388F AC                      		lodsb
 25330 00003890 88C1                    		mov	cl,al ; start sector
 25331 00003892 AD                      		lodsw	; start cylinder
 25332 00003893 88C5                    		mov	ch,al ; 04/01/2019
 25333 00003895 D1E8                    		shr	ax,1
 25334 00003897 D1E8                    		shr	ax,1
 25335 00003899 24C0                    		and	al,0C0h
 25336 0000389B 08C8                    		or	al,cl ; sector bits 0 to 5, cylinder bits 8 & 9 (6 and 7)
 25337 0000389D 88EC                    		mov	ah,ch
 25338 0000389F AB                      		stosw	; start sector & start cylinder
 25339                                  
 25340 000038A0 A5                      		movsw	; system ID & end head
 25341                                  
 25342 000038A1 AC                      		lodsb
 25343 000038A2 88C1                    		mov	cl,al ; end sector
 25344 000038A4 AD                      		lodsw	; end cylinder
 25345 000038A5 88C5                    		mov	ch,al ; 04/01/2019
 25346 000038A7 D1E8                    		shr	ax,1
 25347 000038A9 D1E8                    		shr	ax,1
 25348 000038AB 24C0                    		and	al,0C0h
 25349 000038AD 08C8                    		or	al,cl ; sector bits 0 to 5, cylinder bits 8 & 9 (6 and 7)
 25350 000038AF 88EC                    		mov	ah,ch
 25351 000038B1 AB                      		stosw	; end sector & end cylinder
 25352                                   		
 25353                                  		;; Microsoft C compiler code/output for
 25354                                  		;; /* Relative sectors */
 25355                                  		;;long_temp = part_table[disk][i].rel_sec;
 25356                                  		;;boot_record[0x1C9+(index)] = uc((long_temp >> 24));
 25357                                  		;;boot_record[0x1C8+(index)] = uc(((long_temp & 0x00FF0000l) >> 16));
 25358                                  		;;boot_record[0x1C7+(index)] = uc(((long_temp & 0x0000FF00l) >> 8));
 25359                                  		;;boot_record[0x1C6+(index)] = uc((long_temp & 0x000000FFl));
 25360                                  
 25361                                  		;;mov	ax,[part_table_rec_sec_lw+bx]
 25362                                  		;;mov	dx,[part_table_rel_sec_hw+bx]
 25363                                  		;;mov	cx,ax
 25364                                  		;;mov	di,dx
 25365                                  		;;mov	dl,dh
 25366                                  		;;sub	dh,dh
 25367                                  		;;mov	[boot_record+1C9h+si],dl
 25368                                  		;;mov	si,di
 25369                                  		;;mov	ax,si
 25370                                  		;;mov	di,[wmbr_index]
 25371                                  		;;mov	[boot_record+1C8h+di],al
 25372                                  		;;mov	ax,cx
 25373                                  		;;mov	dx,si
 25374                                  		;;mov	cl,8
 25375                                  		;;mov	si,bx
 25376                                  		;;mov	[wmbr_long_temp],ax
 25377                                  		;;call	shr32
 25378                                  		;;mov	bx,[wmbr_index]
 25379                                  		;;mov	[boot_record+1C7h+bx],al
 25380                                  		;;mov	al,[wmbr_long_temp]
 25381                                  		;;mov	[boot_record+1C6h+bx],al
 25382                                  
 25383                                  		; 21/12/2018
 25384                                  		; Direct assembly language code for
 25385                                  		; /* Relative sectors */
 25386                                  		
 25387                                  		;mov	ax,[part_table_rec_sec_lw+bx]
 25388                                  		;mov	dx,[part_table_rel_sec_hw+bx]
 25389                                  		;mov	[boot_record+1C6h+di],ax		
 25390                                  		;mov	[boot_record+1C8h+di],dx
 25391                                  
 25392                                  		;; Microsoft C compiler code/output for
 25393                                  		;; /* Number of sectors */
 25394                                  		;;long_temp = part_table[disk][i].num_sec;
 25395                                  		;;boot_record[0x1CD+(index)] = uc(long_temp >> 24);
 25396                                  		;;boot_record[0x1CC+(index)] = uc((long_temp & 0x00FF0000l) >> 16);
 25397                                  		;;boot_record[0x1CB+(index)] = uc((long_temp & 0x0000FF00l) >> 8);
 25398                                  		;;boot_record[0x1CA+(index)] = uc(long_temp & 0x000000FFl);
 25399                                  
 25400                                  		;;mov	ax,[part_table_num_sec_lw+si]
 25401                                  		;;mov	dx,[part_table_num_sec_hw+si]
 25402                                  		;;mov	cx,ax
 25403                                  		;;mov	si,dx
 25404                                  		;;mov	dl,dh
 25405                                  		;;sub	dh,dh
 25406                                  		;;mov	[boot_record+1CDh+bx],dl
 25407                                  		;;mov	di,si
 25408                                  		;;mov	ax,di
 25409                                  		;;mov	[boot_record+1CCh+bx],al
 25410                                  		;;mov	ax,cx
 25411                                  		;;mov	dx,si
 25412                                  		;;mov	cl,8
 25413                                  		;;mov	si,ax
 25414                                  		;;call	shr32
 25415                                  		;;mov	bx,[wmbr_index]
 25416                                  		;;mov	[boot_record+1CBh+bx],al
 25417                                  		;;mov	ax,si
 25418                                  		;;mov	[boot_record+1CAh+bx],al
 25419                                  
 25420                                  		; 21/12/2018
 25421                                  		; Direct assembly language code for
 25422                                  		; /* Number of sectors */
 25423                                  		
 25424                                  		;mov	ax,[part_table_num_sec_lw+si]
 25425                                  		;mov	dx,[part_table_num_sec_hw+si]
 25426                                  		;mov	[boot_record+1CAh+bx],ax
 25427                                  		;mov	[boot_record+1CCh+bx],dx
 25428                                  
 25429 000038B2 B90400                  		mov	cx,4
 25430 000038B5 F3A5                    		rep	movsw
 25431                                  wmbr_4:
 25432 000038B7 FE46FA                  		inc	byte [wmbr_i]
 25433 000038BA 807EFA04                		cmp	byte [wmbr_i],4
 25434                                  		;jnb	short wmbr_5
 25435                                  		;jmp	wmbr_2
 25436 000038BE 72A1                    		jb	short wmbr_2
 25437                                  wmbr_5:
 25438                                  		;mov	byte [boot_record+1FEh],55h
 25439                                  		;mov	byte [boot_record+1FFh],0AAh
 25440 000038C0 C706[DECB]55AA          		mov	word [boot_record+1FEh],0AA55h
 25441                                  
 25442 000038C6 8A4604                  		mov	al,[wmbr_disk] ; disk (0 to 7)
 25443 000038C9 50                      		push	ax
 25444 000038CA 29C0                    		sub	ax,ax  ; cylinder = 0
 25445 000038CC 50                      		push	ax
 25446 000038CD E872F3                  		call	write_boot_record
 25447                                  		;pop	bx
 25448                                  		;pop	bx ; 22/12/2018
 25449                                  
 25450                                  		;pop	si
 25451                                  		;pop	di
 25452                                  		
 25453 000038D0 89EC                    		mov	sp,bp
 25454 000038D2 5D                      		pop	bp
 25455                                  		;retn
 25456 000038D3 C20200                  		retn	2 ; 21/12/2018
 25457                                  
 25458                                  ; ----------------------------------------------------------------------------
 25459                                  
 25460                                  ;/*  */
 25461                                  ;char write_ext_boot_to_disk(entry,disk)
 25462                                  ;
 25463                                  ;char entry;
 25464                                  ;unsigned char disk;
 25465                                  ;BEGIN
 25466                                  ;
 25467                                  ;    char            i;
 25468                                  ;    unsigned        j;
 25469                                  ;    unsigned long   long_temp;
 25470                                  ;    char            location;
 25471                                  ;    char            next_drive;
 25472                                  ;    char            pointer;
 25473                                  ;    char            write;
 25474                                  ;
 25475                                  ;    /* Clean out the boot_record */
 25476                                  ;    for (j=u(0);j < u(BYTES_PER_SECTOR); j++)
 25477                                  ;       BEGIN
 25478                                  ;        boot_record[j] = uc(0);
 25479                                  ;       END
 25480                                  ;
 25481                                  ;    /* First - setup the logical devices */
 25482                                  ;    /* See if it has been deleted - if so, leave entries as zero */
 25483                                  ;    /* Otherwise - go unscramble everything out of the arrays */
 25484                                  ;
 25485                                  ;    /* SR; 9/28/89; If entry=23, then sort[entry] is undefined and we
 25486                                  ;       can have unpredictable results. Check for this special case */
 25487                                  ;
 25488                                  ;    if (entry != 23 && ext_table[disk][sort[entry]].sys_id != uc(0))
 25489                                  ;       BEGIN
 25490                                  ;        /* Get boot ind */
 25491                                  ;        boot_record[0x1BE] = ext_table[disk][sort[entry]].boot_ind;
 25492                                  ;
 25493                                  ;        /* Start head */
 25494                                  ;        boot_record[0x1BF] = ext_table[disk][sort[entry]].start_head;
 25495                                  ;
 25496                                  ;        /* Start sector - scramble it to INT 13 format */
 25497                                  ;        boot_record[0x1C0] = (ext_table[disk][sort[entry]].start_sector & 0x3F) |
 25498                                  ;                ((ext_table[disk][sort[entry]].start_cyl/256) << 6);
 25499                                  ;
 25500                                  ;        /* Start cyl - scramble it to INT 13 format*/
 25501                                  ;        boot_record[0x1C1] = ((unsigned char)(ext_table[disk][sort[entry]].start_cyl%256));
 25502                                  ;
 25503                                  ;        /* System id */
 25504                                  ;        boot_record[0x1C2]= ext_table[disk][sort[entry]].sys_id;
 25505                                  ;
 25506                                  ;        /* End head */
 25507                                  ;        boot_record[0x1C3] = ext_table[disk][sort[entry]].end_head;
 25508                                  ;
 25509                                  ;        /* End sector - scramble it to INT 13 format */
 25510                                  ;        boot_record[0x1C4] = (ext_table[disk][sort[entry]].end_sector & 0x3F) |
 25511                                  ;             ((ext_table[disk][sort[entry]].end_cyl/256) << 6);
 25512                                  ;
 25513                                  ;        /* End cyl - scramble it to INT 13 format*/
 25514                                  ;        boot_record[0x1C5] = ((unsigned char)(ext_table[disk][sort[entry]].end_cyl%256));
 25515                                  ;
 25516                                  ;        /* Relative sectors */
 25517                                  ;        long_temp = ext_table[disk][sort[entry]].rel_sec;
 25518                                  ;        boot_record[0x1C9] = uc((long_temp >> 24));
 25519                                  ;        boot_record[0x1C8] = uc(((long_temp & 0x00FF0000l) >> 16));
 25520                                  ;        boot_record[0x1C7] = uc(((long_temp & 0x0000FF00l) >> 8));
 25521                                  ;        boot_record[0x1C6] = uc((long_temp & 0x000000FFl));
 25522                                  ;
 25523                                  ;        /* Number of sectors */
 25524                                  ;        long_temp = ext_table[disk][sort[entry]].num_sec;
 25525                                  ;        boot_record[0x1CD] = uc((long_temp >> 24));
 25526                                  ;        boot_record[0x1CC] = uc(((long_temp & 0x00FF0000l) >> 16));
 25527                                  ;        boot_record[0x1CB] = uc(((long_temp & 0x0000FF00l) >> 8));
 25528                                  ;        boot_record[0x1CA] = uc((long_temp & 0x000000FFl));
 25529                                  ;       END
 25530                                  ;
 25531                                  ;    /* set up pointer to next logical drive unless this is # 23 */
 25532                                  ;    if (entry != c(22))
 25533                                  ;       BEGIN
 25534                                  ;        /* Find the drive to be pointed to */
 25535                                  ;        pointer = entry+1;
 25536                                  ;
 25537                                  ;        /* Handle the special case of a deleted or empty first entry in partition */
 25538                                  ;        if (entry == c(23))
 25539                                  ;           BEGIN
 25540                                  ;            pointer = c(0);
 25541                                  ;           END
 25542                                  ;        for (i = pointer; i <c(23); i++)
 25543                                  ;           BEGIN
 25544                                  ;            next_drive = ((char)(INVALID));
 25545                                  ;
 25546                                  ;            /* Go look for the next valid drive */
 25547                                  ;            if (ext_table[disk][sort[i]].sys_id != uc(0))
 25548                                  ;               BEGIN
 25549                                  ;                next_drive = sort[i];
 25550                                  ;                break;
 25551                                  ;               END
 25552                                  ;           END
 25553                                  ;        if (next_drive != ((char)(INVALID)))
 25554                                  ;           BEGIN
 25555                                  ;            /* Get boot ind */
 25556                                  ;            boot_record[0x1CE] = uc(0);
 25557                                  ;
 25558                                  ;            /* Start head */
 25559                                  ;            boot_record[0x1CF] = uc(0);
 25560                                  ;
 25561                                  ;            /* Start sector - scramble it to INT 13 format*/
 25562                                  ;            boot_record[0x1D0] = uc(0x01) | ((ext_table[disk][next_drive].start_cyl/256) << 6);
 25563                                  ;
 25564                                  ;            /* System id */
 25565                                  ;            boot_record[0x1D2]= uc(EXTENDED);
 25566                                  ;
 25567                                  ;            /* End head */
 25568                                  ;            boot_record[0x1D3] = uc(max_head[disk] -1);
 25569                                  ;
 25570                                  ;            /* End sector - scramble it to INT 13 format*/
 25571                                  ;            boot_record[0x1D4] =(max_sector[disk] & 0x3F) | ((ext_table[disk][next_drive].end_cyl/256) << 6);
 25572                                  ;
 25573                                  ;            /* Start cyl - scramble it to INT 13 format*/
 25574                                  ;            boot_record[0x1D1] = ((unsigned char)(ext_table[disk][next_drive].start_cyl%256));
 25575                                  ;
 25576                                  ;            /* End cyl - scramble it to INT 13 format*/
 25577                                  ;            boot_record[0x1D5] = ((unsigned char)(ext_table[disk][next_drive].end_cyl%256));
 25578                                  ;
 25579                                  ;            /* Relative sectors - this is from the front of the extended volume */
 25580                                  ;            /* Find the extended partition */
 25581                                  ;            location = find_partition_location(uc(EXTENDED));
 25582                                  ;            long_temp = ((unsigned long)(ext_table[disk][next_drive].start_cyl - part_table[disk][location].start_cyl))
 25583                                  ;                          * max_head[disk] *  max_sector[disk];
 25584                                  ;            boot_record[0x1D9] = uc((long_temp >> 24));
 25585                                  ;            boot_record[0x1D8] = uc(((long_temp & 0x00FF0000l) >> 16));
 25586                                  ;            boot_record[0x1D7] = uc(((long_temp & 0x0000FF00l) >> 8));
 25587                                  ;            boot_record[0x1D6] = uc((long_temp & 0x000000FFl));
 25588                                  ;
 25589                                  ;            /* Number of sectors in the next volume*/
 25590                                  ;            long_temp = ((unsigned long)(ext_table[disk][next_drive].end_cyl - ext_table[disk][next_drive].start_cyl+1))
 25591                                  ;                        * max_head[disk] * max_sector[disk];
 25592                                  ;            boot_record[0x1DD] = uc((long_temp >> 24));
 25593                                  ;            boot_record[0x1DC] = uc(((long_temp & 0x00FF0000l) >> 16));
 25594                                  ;            boot_record[0x1DB] = uc(((long_temp & 0x0000FF00l) >> 8));
 25595                                  ;            boot_record[0x1DA] = uc((long_temp & 0x000000FFl));
 25596                                  ;           END
 25597                                  ;       END
 25598                                  ;    boot_record[510] = uc(0x55);
 25599                                  ;    boot_record[511] = uc(0xAA);
 25600                                  ;
 25601                                  ;    /* Write the boot record out */
 25602                                  ;    if (entry != c(23))
 25603                                  ;       BEGIN
 25604                                  ;        write = write_boot_record(ext_table[disk][sort[entry]].start_cyl,disk);
 25605                                  ;       END
 25606                                  ;    else
 25607                                  ;       BEGIN
 25608                                  ;        /* Write the special case of the first entry only having a pointer */
 25609                                  ;        write = write_boot_record(ext_table[disk][23].start_cyl,disk);
 25610                                  ;       END
 25611                                  ;    return(write);
 25612                                  ;END
 25613                                  
 25614                                  write_ext_boot_to_disk:
 25615                                  
 25616                                  %define webr_temp3	bp-22h
 25617                                  %define webr_multiplicand_lw bp-1Eh
 25618                                  %define webr_multiplicand_hw bp-1Ch
 25619                                  %define webr_multiplier_lw bp-1Ah
 25620                                  %define webr_multiplier_hw bp-18h
 25621                                  %define webr_temp2	bp-16h
 25622                                  %define webr_temp1	bp-14h
 25623                                  %define webr_j		bp-0Eh
 25624                                  %define webr_i		bp-0Ch
 25625                                  %define webr_location	bp-0Ah
 25626                                  %define webr_next_drive	bp-8
 25627                                  %define webr_longtemp	bp-6
 25628                                  %define webr_longtemp_2	bp-4
 25629                                  %define webr_pointer	bp-2
 25630                                  %define webr_entry	bp+4
 25631                                  %define webr_disk	bp+6
 25632                                  
 25633 000038D6 55                      		push	bp
 25634 000038D7 89E5                    		mov	bp, sp
 25635 000038D9 83EC22                  		sub	sp, 34
 25636 000038DC 57                      		push	di
 25637 000038DD 56                      		push	si
 25638 000038DE C746F20000              		mov	word [webr_j], 0
 25639                                  webr_1:
 25640                                  		;/* Clean out the boot_record */
 25641                                  
 25642                                  		;mov	bx,[webr_j]
 25643                                  		;mov	byte [boot_record+bx],0
 25644                                  		;inc	word [webr_j]
 25645                                  		;cmp	word [webr_j],512
 25646                                  		;jb	short webr_1
 25647                                  
 25648 000038E3 31C0                    		xor	ax,ax
 25649 000038E5 BF[E0C9]                		mov	di,boot_record
 25650 000038E8 B90001                  		mov	cx,256
 25651                                  		;push	ds
 25652                                  		;pop	es
 25653 000038EB F3AB                    		rep	stosw
 25654                                  
 25655                                  	; /* First - setup the logical devices */
 25656                                  	; /* See if it has been deleted - if so, leave entries as zero */
 25657                                  	; /* Otherwise - go unscramble everything out of the arrays */
 25658                                  	;
 25659                                  	; /* SR; 9/28/89; If entry=23, then sort[entry] is undefined and we
 25660                                  	;    can have unpredictable results. Check for this special case */
 25661                                  
 25662 000038ED 807E0417                		cmp	byte [webr_entry],23
 25663                                  		;jne	short webr_2
 25664                                  		;jmp	webr_4
 25665 000038F1 744B                    		je	short webr_4 ; 22/12/2018
 25666                                  webr_2:
 25667 000038F3 B018                    		mov	al,24
 25668 000038F5 F66606                  		mul	byte [webr_disk]
 25669                                  		;mov	cx,ax
 25670                                  		;mov	al,[webr_entry]
 25671                                  		;cbw
 25672                                  		;mov	bx,ax
 25673 000038F8 8A5E04                  		mov	bl,[webr_entry]
 25674 000038FB 30FF                    		xor	bh,bh
 25675                                  		;mov	al,[sort+bx]
 25676                                  		;cbw
 25677                                  		;add	ax,cx
 25678 000038FD 0287[F0C3]              		add	al,[sort+bx]
 25679                                  		;mov	cx,46
 25680                                  		;imul	cx
 25681 00003901 B12E                    		mov	cl,46
 25682 00003903 F6E1                    		mul	cl ; 06/01/2019
 25683 00003905 89C3                    		mov	bx,ax
 25684 00003907 80BF[5DA1]00            		cmp	byte [ext_table_sys_id+bx],0
 25685                                  		;jne	short webr_3
 25686                                  		;jmp	webr_4
 25687 0000390C 7430                    		je	short webr_4 ; 22/12/2018
 25688                                  webr_3:
 25689                                  		;/* Get boot ind */
 25690                                  		;mov	al,[ext_table_boot_ind+bx]
 25691                                  		;mov	[boot_record+1BEh],al  ; boot indicator
 25692                                  		;/* Start head */
 25693                                  		;mov	al,[ext_table_start_head+bx]
 25694                                  		;mov	[boot_record+1BFh],al  ;start head
 25695                                  		;/* Start sector - scramble it to INT 13 format */
 25696                                  		;/* Start cyl - scramble it to INT 13 format*/
 25697                                  		;mov	ax,[ext_table_start_cyl+bx]
 25698                                  		;mov	cx,ax
 25699                                  		;shr	ax,1
 25700                                  		;shr	ax,1
 25701                                  		;mov	dx,ax
 25702                                  		;xor	al,[ext_table_start_sector+bx]
 25703                                  		;and	al,3Fh
 25704                                  		;xor	dl,al
 25705                                  		;mov	[boot_record+1C0h],dl ; start sector
 25706                                  		;mov	[boot_record+1C1h],cl ; start cylinder
 25707                                  	
 25708 0000390E 8DB7[58A1]              		lea	si,[ext_table_boot_ind+bx]
 25709                                  		;es = ds = cs = ss
 25710 00003912 BF[9ECB]                		mov	di,boot_record+1BEh
 25711 00003915 A5                      		movsw	; boot indicator & start head
 25712                                  		
 25713 00003916 AC                      		lodsb
 25714 00003917 88C1                    		mov	cl,al ; start sector
 25715 00003919 AD                      		lodsw	; start cylinder
 25716 0000391A 88C5                    		mov	ch,al ; 04/01/2019
 25717 0000391C D1E8                    		shr	ax,1
 25718 0000391E D1E8                    		shr	ax,1
 25719 00003920 24C0                    		and	al,0C0h
 25720 00003922 08C8                    		or	al,cl ; sector bits 0 to 5, cylinder bits 8 & 9 (6 and 7)
 25721 00003924 88EC                    		mov	ah,ch
 25722 00003926 AB                      		stosw	; start sector & start cylinder
 25723                                  
 25724 00003927 A5                      		movsw	; system ID & end head
 25725                                  
 25726                                  		;/* System id */
 25727                                  		;mov	al,[ext_table_sys_id+bx]
 25728                                  		;mov	[boot_record+1C2h],al ; system ID
 25729                                  		;/* End head */
 25730                                  		;mov	al,[ext_table_end_head+bx]  ;end head
 25731                                  		;mov	[boot_record+1C3h],al ; end head
 25732                                  		;/* End sector - scramble it to INT 13 format */
 25733                                  		;/* End cyl - scramble it to INT 13 format*/
 25734                                  		;mov	ax,[ext_table_end_cyl+bx]
 25735                                  		;mov	cx,ax
 25736                                  		;shr	ax,1
 25737                                  		;shr	ax,1
 25738                                  		;mov	dx,ax
 25739                                  		;xor	al,[ext_table_end_sector+bx]
 25740                                  		;and	al,3Fh
 25741                                  		;xor	dl,al
 25742                                  		;mov	[boot_record+1C4h],dl ; end sector
 25743                                  		;mov	[boot_record+1C5h],cl ; end cylinder
 25744                                  
 25745 00003928 AC                      		lodsb
 25746 00003929 88C1                    		mov	cl,al ; end sector
 25747 0000392B AD                      		lodsw	; end cylinder
 25748 0000392C 88C5                    		mov	ch,al ; 04/01/2019
 25749 0000392E D1E8                    		shr	ax,1
 25750 00003930 D1E8                    		shr	ax,1
 25751 00003932 24C0                    		and	al,0C0h
 25752 00003934 08C8                    		or	al,cl ; sector bits 0 to 5, cylinder bits 8 & 9 (6 and 7)
 25753 00003936 88EC                    		mov	ah,ch
 25754 00003938 AB                      		stosw	; end sector & end cylinder
 25755                                  
 25756                                   		;;/* Relative sectors */
 25757                                  		;;mov	ax,[ext_table_rel_sec_lw+bx]
 25758                                  		;;mov	dx,[ext_table_rel_sec_hw+bx]
 25759                                  		;;mov	cx,ax
 25760                                  		;;mov	si,dx
 25761                                  		;;mov	dl,dh
 25762                                  		;;sub	dh,dh
 25763                                  		;;mov	[boot_record+1C9h],dl
 25764                                  		;;mov	di,si
 25765                                  		;;mov	ax,si
 25766                                  		;;mov	[boot_record+1C8h],al
 25767                                  		;;mov	ax,cx
 25768                                  		;;mov	dx,di
 25769                                  		;;mov	cl,8
 25770                                  		;;mov	si,bx
 25771                                  		;;mov	[webr_temp],ax
 25772                                  		;;call	shr32
 25773                                  		;;mov	[boot_record+1C7h],al
 25774                                  		;;mov	al,[webr_temp]
 25775                                  		;;mov	[boot_record+1C6h],al
 25776                                  
 25777                                  		;mov	ax,[ext_table_rec_sec_lw+bx]
 25778                                  		;mov	dx,[ext_table_rel_sec_hw+bx]
 25779                                  		;mov	[boot_record+1C6h+di],ax		
 25780                                  		;mov	[boot_record+1C8h+di],dx
 25781                                  
 25782                                  		;;/* Number of sectors */
 25783                                  		;;mov	ax,[ext_table_num_sec_lw+si]
 25784                                  		;;mov	dx,[ext_table_num_sec_hw+si]
 25785                                  		;;mov	[webr_longtemp],ax
 25786                                  		;;mov	[webr_longtemp+2],dx
 25787                                  		;;mov	cx,ax
 25788                                  		;;mov	bx,dx
 25789                                  		;;mov	dl,dh
 25790                                  		;;sub	dh,dh
 25791                                  		;;mov	[boot_record+1CDh],dl
 25792                                  		;;mov	si,bx
 25793                                  		;;mov	[boot_record+1CCh],bl
 25794                                  		;;mov	dx,bx
 25795                                  		;;mov	cl,8
 25796                                  		;;mov	di,ax
 25797                                  		;;call	shr32
 25798                                  		;;mov	[boot_record+1CBh],al
 25799                                  		;;mov	ax,di
 25800                                  		;;mov	[boot_record+1CAh],al
 25801                                  
 25802                                  		;mov	ax,[ext_table_num_sec_lw+si]
 25803                                  		;mov	dx,[ext_table_num_sec_hw+si]
 25804                                  		;mov	[boot_record+1CAh+bx],ax
 25805                                  		;mov	[boot_record+1CCh+bx],dx
 25806                                  
 25807 00003939 B90400                  		mov	cx,4
 25808 0000393C F3A5                    		rep	movsw
 25809                                  
 25810                                  	;/* set up pointer to next logical drive unless this is # 23 */
 25811                                  webr_4:
 25812 0000393E 8A4604                  		mov	al,[webr_entry] ; 21/12/2018
 25813                                  
 25814                                  		;cmp	byte [webr_entry],22
 25815 00003941 3C16                    		cmp	al,22
 25816 00003943 7503                    		jne	short webr_5
 25817 00003945 E9F500                  		jmp	webr_11
 25818                                  
 25819                                  	;/* Find the drive to be pointed to */	
 25820                                  webr_5:
 25821                                  		; 21/12/2018
 25822 00003948 3C17                    		cmp	al,23
 25823 0000394A 7407                    		je	short webr_14
 25824                                  
 25825                                  		;mov	al,[webr_entry]
 25826 0000394C FEC0                    		inc	al
 25827 0000394E 8846FE                  		mov	[webr_pointer],al
 25828 00003951 EB05                    		jmp	short webr_6
 25829                                  
 25830                                  	;/* Handle the special case of a deleted or empty first entry in partition */
 25831                                  
 25832                                  		;cmp	[webr_entry],23
 25833                                  		;jne	short webr_6
 25834                                  webr_14:
 25835 00003953 28C0                    		sub	al,al ; 0 ; 21/12/2018
 25836                                  		;mov	byte [webr_pointer],0
 25837                                  
 25838 00003955 8846FE                  		mov	[webr_pointer],al ; 0
 25839                                  ;webr_6:
 25840                                  		;mov	al,[webr_pointer]
 25841                                  
 25842                                  		;for (i = pointer; i < c(23); i++)
 25843                                  webr_6:
 25844 00003958 8846F4                  		mov	[webr_i],al ; al = [webr_pointer]
 25845                                  		;jmp	short webr_8
 25846 0000395B EB0B                    		jmp	short webr_15
 25847                                  webr_7:
 25848 0000395D FE46F4                  		inc	byte [webr_i] ; i++
 25849                                  
 25850                                  webr_8:
 25851 00003960 807EF417                		cmp	byte [webr_i],23 ; i < c(23)
 25852                                  		;jge	short webr_9
 25853 00003964 0F8DD500                		jge	webr_11
 25854                                  webr_15:
 25855                                  		; next_drive = ((char)(INVALID));
 25856                                  
 25857                                  		;mov	byte [webr_next_drive],0FFh ; 255
 25858                                  
 25859                                  	;/* Go look for the next valid drive */
 25860                                  
 25861 00003968 B018                    		mov	al,24
 25862 0000396A F66606                  		mul	byte [webr_disk]
 25863                                  		;mov	cx,ax
 25864                                  		;mov	al,[webr_i]
 25865                                  		;cbw
 25866                                  		;mov	bx,ax
 25867 0000396D 8A5EF4                  		mov	bl,[webr_i]
 25868 00003970 30FF                    		xor	bh,bh
 25869                                  		;mov	al,[sort+bx]
 25870                                  		;mov	dx,ax
 25871 00003972 8A97[F0C3]              		mov	dl,[sort+bx]
 25872                                  		;cbw
 25873                                  		;add	ax,cx
 25874 00003976 00D0                    		add	al,dl
 25875                                  		;mov	cx,46
 25876                                  		;mov	bx,dx
 25877                                  		;imul	cx
 25878 00003978 B12E                    		mov	cl,46
 25879 0000397A F6E1                    		mul	cl
 25880 0000397C 89C6                    		mov	si,ax
 25881                                  
 25882                                  		;if (ext_table[disk][sort[i]].sys_id != uc(0))
 25883                                  
 25884 0000397E 80BC[5DA1]00            		cmp	byte [ext_table_sys_id+si],0
 25885 00003983 74D8                    		je	short webr_7 ; next for
 25886                                  
 25887                                  		; next_drive = sort[i];
 25888                                  
 25889                                  		;;mov	[webr_next_drive],bl
 25890                                  		;mov	[webr_next_drive],dl
 25891                                  
 25892                                  		; break;   ; exit for
 25893                                  webr_9:
 25894                                  		; condition check inside 'for'
 25895                                  
 25896                                  		; if (next_drive != ((char)(INVALID)))
 25897                                  
 25898                                  ;		cmp	byte [webr_next_drive],0FFh ; 255
 25899                                  ;		jne	short webr_10
 25900                                  ;		jmp	webr_11  ; next_drive = 0FFh ; exit from 'for'
 25901                                  
 25902                                  webr_10:	; next_drive != 0FFh
 25903                                  
 25904                                  		;sub	al,al
 25905                                  		;mov	[boot_record+1CEh],al ; boot (active) indicator
 25906                                  		;mov	[boot_record+1CFh],al ; start head (= 0)
 25907                                  
 25908 00003985 29C0                    		sub	ax,ax
 25909 00003987 A3[AECB]                		mov	[boot_record+1CEh],ax ; 0 
 25910                                  
 25911                                  		;mov	al,[webr_next_drive]
 25912                                  		;cbw
 25913                                  		;mov	cx,24
 25914 0000398A B118                    		mov	cl,24
 25915                                  		;mov	dx,ax
 25916 0000398C 8A4606                  		mov	al,[webr_disk]
 25917                                  		;sub	ah,ah
 25918                                  		;mov	bx,dx
 25919                                  		;mov	si,46
 25920 0000398F 89C7                    		mov	di,ax ; *!*!"
 25921                                  		;imul	cx
 25922 00003991 F6E1                    		mul	cl ; [webr_disk]*24
 25923                                  		;add	ax,bx
 25924                                  		;add	al,[webr_next_drive] ; 06/01/2019
 25925 00003993 00D0                    		add	al,dl  ; add al,[webr_next_drive]
 25926                                  		;imul	si
 25927 00003995 B12E                    		mov	cl,46
 25928 00003997 F6E1                    		mul	cl
 25929 00003999 89C3                    		mov	bx,ax ; **
 25930                                  
 25931 0000399B 8B87[5BA1]              		mov	ax,[ext_table_start_cyl+bx]
 25932 0000399F 88C5                    		mov	ch,al ; 04/01/2019
 25933 000039A1 D1E8                    		shr	ax,1
 25934 000039A3 D1E8                    		shr	ax,1
 25935                                  		;and	al,0C1h
 25936 000039A5 24C0                    		and	al,0C0h
 25937 000039A7 0C01                    		or	al,1
 25938 000039A9 88EC                    		mov	ah,ch
 25939                                  		;mov	[boot_record+1D0h],al ; start sector (= 1) 
 25940                                  					      ;	and cylinders bits 8 and 9
 25941                                  		;mov	[boot_record+1D1h],ch ; start cylinder (bits 0 to 7)
 25942 000039AB A3[B0CB]                		mov	[boot_record+1D0h],ax ; start sector & start cylinder
 25943 000039AE C606[B2CB]05            		mov	byte [boot_record+1D2h],5 ; EXTENDED  ; system ID
 25944                                  		
 25945                                  		;mov	ax,di ;disk (0 to 7)
 25946 000039B3 89FE                    		mov	si,di ; *!*!
 25947 000039B5 D1E7                    		shl	di,1
 25948 000039B7 8A95[B6A0]              		mov	dl,[max_head+di] ;*!*!*
 25949 000039BB FECA                    		dec	dl
 25950 000039BD 8816[B3CB]              		mov	[boot_record+1D3h],dl ; end head
 25951                                  
 25952 000039C1 8B97[60A1]              		mov	dx,[ext_table_end_cyl+bx]
 25953 000039C5 88D5                    		mov	ch,dl ; end cylinder, low 8 bits
 25954 000039C7 D1EA                    		shr	dx,1
 25955 000039C9 D1EA                    		shr	dx,1
 25956 000039CB 80E2C0                  		and	dl,0C0h
 25957 000039CE 895EEC                  		mov	[webr_temp1],bx ; **
 25958                                  		;mov	bx,ax
 25959                                  		;mov	[webr_temp2],dx
 25960                                  		;xor	dl,[max_sector+bx]
 25961                                  		;and	dl,3Fh
 25962                                  		;xor	dl,[webr_temp2]
 25963 000039D1 8A8C[AEA0]              		mov	cl,[max_sector+si] ; *!*!
 25964                                  		;and	cl,3Fh
 25965 000039D5 08D1                    		or	cl,dl ; scramble end sector (bit 0 to bit 5) to 
 25966                                  			      ; end cylinder bits 8 & 9 (end sector bits 6 & 7)
 25967                                  		
 25968                                  		;mov	[boot_record+1D4h],dl ; end sector
 25969                                  		;mov	[boot_record+1D1h],cl
 25970                                  		;mov	cx,si
 25971                                  		;mov	[boot_record+1D5h],cl ; end cylinder
 25972                                  		;mov	cl,5
 25973                                  		;mov	[boot_record+1D2h],cl
 25974                                  
 25975 000039D7 890E[B4CB]              		mov	[boot_record+1D4h],cx ; end sector & end cylinder	
 25976                                  
 25977                                  		;/* Find the extended partition */
 25978                                  
 25979                                  		;push	cx
 25980                                  		
 25981                                  		;mov	si,bx
 25982                                  		;call	find_partition_location
 25983                                  		;pop	bx
 25984                                  		;mov	[webr_location],al
 25985                                  
 25986                                  		;mov	al,5  ; EXTENDED
 25987                                  		;mov	[boot_record+1D2h],al
 25988                                  
 25989 000039DB B005                    		mov	al,5 ; EXTENDED
 25990                                  		;push	ax
 25991 000039DD E8E4E3                  		call	find_partition_type
 25992                                  			 ; CH = 0 ; *
 25993                                  			 ; CL = Partition number if CF = 0
 25994                                  		;pop	bx
 25995                                  
 25996 000039E0 884EF6                  		mov	[webr_location],cl
 25997                                  
 25998                                  	;/* Relative sectors - this is from the front of the extended volume */
 25999                                  
 26000 000039E3 8B85[B6A0]              		mov	ax,[max_head+di] ; *!*!* (di = disk number * 2)
 26001                                  		;sub	dx,dx
 26002                                  		;push	dx ; 0		     ; dx_h	
 26003                                  		;push	ax ; max_head[disk]  ; ax_h	
 26004 000039E7 8A8C[AEA0]              		mov	cl,[max_sector+si] ; *!*! (si = disk number)
 26005                                  		;;sub	ch,ch ; *
 26006                                  		;sub	bx,bx
 26007                                  		;push	bx ; 0
 26008                                  		;push	cx ; max_sector[disk]
 26009 000039EB BF2E00                  		mov	di,46
 26010 000039EE D1E6                    		shl	si,1
 26011 000039F0 D1E6                    		shl	si,1 ; disk number * 4
 26012                                  		
 26013                                  		; 22/12/2018
 26014 000039F2 F7E1                    		mul	cx ; mx_sector[disk]*max_head[disk]
 26015                                  		
 26016 000039F4 8946E6                  		mov	[webr_multiplier_lw],ax
 26017 000039F7 8956E8                  		mov	[webr_multiplier_hw],dx
 26018                                  
 26019                                  		; 22/12/2018
 26020 000039FA 52                      		push	dx ; DX_h*s
 26021 000039FB 50                      		push	ax ; AX_h*s
 26022                                  
 26023 000039FC 8A46F6                  		mov	al,[webr_location]
 26024 000039FF 98                      		cbw
 26025 00003A00 01F0                    		add	ax,si
 26026                                  		;imul	di
 26027 00003A02 F7E7                    		mul	di ; * 46
 26028 00003A04 89C6                    		mov	si,ax ; [disk][location]
 26029                                  
 26030 00003A06 8B7EEC                  		mov	di,[webr_temp1] ; ** ; [disk][next_drive]
 26031                                  
 26032 00003A09 8B85[5BA1]              		mov	ax,[ext_table_start_cyl+di]
 26033                                  
 26034                                  		;mov	dx,ax
 26035 00003A0D 89C7                    		mov	di,ax ; ext_table[disk][next_drive].start_cyl ; ***
 26036                                  
 26037 00003A0F 2B84[23C4]              		sub	ax,[part_table_start_cyl+si]
 26038                                  
 26039                                  	; ax = ext_table[disk][next_drive].start_cyl - part_table[disk][location].start_cyl
 26040                                  
 26041                                  		;mov	si,dx  
 26042                                  		;sub	dx,dx
 26043                                  		
 26044 00003A13 52                      		push	dx ; 0
 26045 00003A14 50                      		push	ax
 26046                                  		
 26047                                  		;mov	di,cx
 26048                                  		;mov	[webr_multiplicand_lw],di
 26049                                  		;mov	[webr_multiplicand_hw],bx
 26050                                  
 26051                                  		;; stack: ; Microsoft C compiler's multiplication code
 26052                                  		;	;sp+5 -> dx_head = 0
 26053                                  		;	;sp+4 -> ax_head = max_head[disk]
 26054                                  		;	;sp+3 -> bx = 0
 26055                                  		;	;sp+2 -> cx = max_sector[disk]
 26056                                  		;	;sp+1 -> dx = 0
 26057                                  		;	;sp -> ax = next_drive's start cyl - extended partition's start cyl
 26058                                  		;call	mul_32 ; [bx:cx]*[dx:ax]
 26059                                  		;	; result:
 26060                                  		;	;   dx:ax = start cylinder difference * max_sector[disk]
 26061                                  		;push	dx
 26062                                  		;push	ax
 26063                                  		;	;sp+3 -> dx_head = 0
 26064                                  		;	;sp+2 -> ax_head = max_head[disk]
 26065                                  		;	;sp+1 -> dx = high word of previous multiplication result
 26066                                  		;	;sp -> ax = low word of previous multiplication result
 26067                                  		;call	mul32
 26068                                  		;	; result:
 26069                                  		;	;   dx:ax = start cyl diff. * max_sector[disk] * max_head[disk]
 26070                                  			;         = relative start sector of next logical drv in ext part.
 26071                                  		
 26072                                  		; stack: ; Erdogan Tan - 22/12/2018
 26073                                  		;	;sp+3 -> DX_h*s = high word of max_sector[disk]*max_head[disk]
 26074                                  		;	;sp+2 -> AX_h*s = low word of max_sector[disk]*max_head[disk]
 26075                                  		;	;sp+1 -> DX = 0
 26076                                  		;	;sp -> AX = next_drive's start cyl - extended partition's start cyl
 26077 00003A15 E8C3DB                  		call	mul32
 26078                                  			; result:
 26079                                  			;   dx:ax = relative start sector of next logical drive in ext part.
 26080                                  
 26081                                  		;mov	cx,ax
 26082                                  		;mov	bx,dx
 26083                                  		;mov	dl,dh
 26084                                  		;sub	dh,dh
 26085                                  		;mov	[boot_record+1D9h],dl
 26086                                  		;mov	di,bx
 26087                                  		;mov	[boot_record+1D8h],bl
 26088                                  		;mov	dx,di
 26089                                  		;mov	cl,8
 26090                                  		;mov	[webr_temp3],ax
 26091                                  		;call	shr32
 26092                                  		;mov	[boot_record+1D7h],al
 26093                                  		;mov	al,[webr_temp3]
 26094                                  		;mov	[boot_record+1D6h],al
 26095                                  
 26096                                  		; 22/12/2018
 26097 00003A18 A3[B6CB]                		mov	[boot_record+1D6h],ax
 26098 00003A1B 8916[B8CB]              		mov	[boot_record+1D8h],dx
 26099                                  
 26100                                  	;/* Number of sectors in the next volume */
 26101                                  
 26102                                  		;push	word [webr_multiplier_hw]   ; 0	
 26103                                  		;push	word [webr_multiplier_lw]   ; max_head[disk] 	
 26104                                  		;push	word [webr_multiplicand_hw] ; 0
 26105                                  		;push	word [webr_multiplicand_lw] ; max_sector[disk]
 26106                                  		;mov	bx,[webr_temp]
 26107                                  		;sub	si,[ext_table_end_cyl+bx]
 26108                                  		;neg	si
 26109                                  		;inc	si
 26110                                  		;sub	cx,cx
 26111                                  		;push	cx ; 0
 26112                                  		;push	si ; cylinder count of the next logical drive
 26113                                  		;call	mul32
 26114                                  		;push	dx ;high word of cylinders * sectors (per track)	
 26115                                  		;push	ax ;low word of cylinders * sectors (per track)
 26116                                  		;call	mul32
 26117                                  		
 26118                                  		; 22/12/2018
 26119 00003A1F FF76E8                  		push	word [webr_multiplier_hw] ; hw of mx_sector[disk]*max_head[disk]
 26120 00003A22 FF76E6                  		push	word [webr_multiplier_lw] ; lw of mx_sector[disk]*max_head[disk]
 26121                                  		
 26122                                  		; di = ext_table[disk][next_drive].start_cyl ; ***
 26123                                  
 26124 00003A25 8B5EEC                  		mov	bx,[webr_temp1]
 26125 00003A28 2BBF[60A1]              		sub	di,[ext_table_end_cyl+bx]
 26126 00003A2C F7DF                    		neg	di
 26127 00003A2E 47                      		inc	di
 26128 00003A2F 31DB                    		xor	bx,bx
 26129 00003A31 53                      		push	bx ; 0
 26130 00003A32 57                      		push	di ; cylinder count of the next logical drive
 26131 00003A33 E8A5DB                  		call	mul32
 26132                                  			; result:
 26133                                  			;   dx:ax = number of sectors in the next logical drive	
 26134                                  
 26135                                  		;mov	[webr_longtemp],ax
 26136                                  		;mov	[webr_longtemp+2],dx
 26137                                  		;mov	dl,dh
 26138                                  		;sub	dh,dh
 26139                                  		;mov	[boot_record+1DDh],dl
 26140                                  		;mov	al,[webr_longtemp_2]
 26141                                  		;mov	[boot_record+1DCh],al
 26142                                  		;mov	ax,[webr_longtemp]
 26143                                  		;mov	dx,[webr_longtemp+2]
 26144                                  		;mov	cl,8
 26145                                  		;call	shr32
 26146                                  		;mov	[boot_record+1DBh],al
 26147                                  		;mov	al,[webr_longtemp]
 26148                                  		;mov	[boot_record+1DAh],al
 26149                                  
 26150                                  		; 22/12/2018
 26151 00003A36 A3[BACB]                		mov	[boot_record+1DAh],ax
 26152 00003A39 8916[BCCB]              		mov	[boot_record+1DCh],dx
 26153                                  webr_11:
 26154                                  		;mov	byte [boot_record+1FEh],55h
 26155                                  		;mov	byte [boot_record+1FFh],0AAh
 26156 00003A3D C706[DECB]55AA          		mov	word [boot_record+1FEh],0AA55h
 26157                                  
 26158 00003A43 807E0417                		cmp	byte [webr_entry],23
 26159 00003A47 741D                    		je	short webr_12
 26160                                  
 26161                                  		;/* Write the boot record out */
 26162                                  
 26163 00003A49 8A4606                  		mov	al,[webr_disk]
 26164 00003A4C 50                      		push	ax
 26165 00003A4D B118                    		mov	cl,24
 26166 00003A4F F6E1                    		mul	cl
 26167                                  		;mov	cx,ax
 26168                                  		;mov	al,[webr_entry]
 26169                                  		;cbw
 26170                                  		;mov	bx,ax
 26171                                  
 26172 00003A51 8A5E04                  		mov	bl,[webr_entry]
 26173 00003A54 30FF                    		xor	bh,bh
 26174                                  		;;mov	al,[sort+bx]
 26175                                  		;mov	cl,[sort+bx]
 26176                                  		;;cbw
 26177                                  		;;add	ax,cx
 26178                                  		;add	al,cl
 26179 00003A56 0287[F0C3]              		add	al,[sort+bx]
 26180                                  		;mov	cx,46
 26181                                  		;imul	cx
 26182 00003A5A B12E                    		mov	cl,46
 26183 00003A5C F6E1                    		mul	cl
 26184 00003A5E 89C3                    		mov	bx,ax
 26185 00003A60 FFB7[5BA1]              		push	word [ext_table_start_cyl+bx]
 26186 00003A64 EB11                    		jmp	short webr_13
 26187                                  
 26188                                  	;/* Write the special case of the first entry only having a pointer */
 26189                                  webr_12:
 26190 00003A66 8A4606                  		mov	al,[webr_disk]
 26191 00003A69 28E4                    		sub	ah,ah
 26192 00003A6B 50                      		push	ax	; Disk (0 to 7)
 26193 00003A6C B95004                  		mov	cx,1104 ; 24*46
 26194                                  		;imul	cx
 26195 00003A6F F7E1                    		mul	cx
 26196 00003A71 89C3                    		mov	bx,ax
 26197 00003A73 FFB7[7DA5]              		push	word [ep0_lp23_start_cyl+bx]  ; Cylinder
 26198                                  webr_13:
 26199 00003A77 E8C8F1                  		call	write_boot_record
 26200                                  		;pop	bx
 26201                                  		;pop	bx ; 22/12/2018
 26202                                  
 26203                                  		;pop	si
 26204                                  		;pop	di
 26205                                  
 26206 00003A7A 89EC                    		mov	sp,bp
 26207 00003A7C 5D                      		pop	bp
 26208                                  		
 26209                                  		;retn
 26210 00003A7D C20400                  		retn	4 ; 05/01/2019
 26211                                  
 26212                                  ; ============================================================================
 26213                                  ;  DELETE PARTITION
 26214                                  ; ============================================================================
 26215                                  ; 23/12/2018
 26216                                  
 26217                                  ; fdisk.msg (MSDOS 6.0)
 26218                                  ;/***************************************************************************************************/
 26219                                  ;/*  Screen for DELETE_PARTITION                                                                    */
 26220                                  ;/*                                                                                                 */
 26221                                  ;/*     |00000000001111111111222222222233333333334444444444555555555566666666667777777777|          */
 26222                                  ;/*     |01234567890123456789012345678901234567890123456789012345678901234567890123456789|          */
 26223                                  ;/*   --|--------------------------------------------------------------------------------|          */
 26224                                  ;/*   00|                                                                                |          */
 26225                                  ;/*   01|                                                                                |          */
 26226                                  ;/*   02|                                                                                |          */
 26227                                  ;/*   03|                                                                                |          */
 26228                                  ;/*   04|                   Delete DOS Partition or Logical DOS Drive                    |menu_25   */
 26229                                  ;/*   05|                                                                                |          */
 26230                                  ;/*   06|    Current fixed disk drive: #                                                 |menu_5 #  */
 26231                                  ;/*   07|                                                                                |          */
 26232                                  ;/*   08|    Choose one of the following:                                                |menu_3 #  */
 26233                                  ;/*   09|                                                                                |          */
 26234                                  ;/*   10|    1.  Delete Primary DOS Partition                                            |menu_26   */
 26235                                  ;/*   11|    2.  Delete Extended DOS Partition                                           |menu_26   */
 26236                                  ;/*   12|    3.  Delete Logical DOS Drive(s) in the Extended DOS Partition               |menu_27   */
 26237                                  ;/*   13|    4.  Delete Non-DOS Partition                                                |menu_57   */
 26238                                  ;/*   14|                                                                                |          */
 26239                                  ;/*   15|                                                                                |          */
 26240                                  ;/*   16|                                                                                |          */
 26241                                  ;/*   17|    Enter choice: [ ]                                                           |menu_7 #  */
 26242                                  ;/*   18|                                                                                |          */
 26243                                  ;/*   19|                                                                                |          */
 26244                                  ;/*   20|                                                                                |          */
 26245                                  ;/*   21|                                                                                |          */
 26246                                  ;/*   22|                                                                                |          */
 26247                                  ;/*   23|                                                                                |          */
 26248                                  ;/*   24|    Press ESC to return to FDISK Options                                        |menu_11   */
 26249                                  ;/*   ------------------------------------------------------------------------------------          */
 26250                                  ;/*                                                                                                 */
 26251                                  ;/***************************************************************************************************/
 26252                                  ; ----------------------------------------------------------------------------
 26253                                  ; d_menus.c (FDISK, MSDOS 6.0, 1991)	
 26254                                  ; ----------------------------------------------------------------------------
 26255                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 23/12/2018)
 26256                                  
 26257                                  ;/*  */
 26258                                  ;/******************* START OF SPECIFICATIONS *******************/
 26259                                  ;/*                                                             */
 26260                                  ;/* SUBROUTINE NAME: DELETE_PARTITION                           */
 26261                                  ;/*                                                             */
 26262                                  ;/* DESCRIPTIVE NAME: Delete partition selection menu           */
 26263                                  ;/*                                                             */
 26264                                  ;/* FUNCTION: User is prompted as to what type of DOS partition */
 26265                                  ;/*           he wishes to delete.                              */
 26266                                  ;/*                                                             */
 26267                                  ;/* NOTES: The delete volume option is only displayed if some   */
 26268                                  ;/*        disk volumes exist                                   */
 26269                                  ;/*                                                             */
 26270                                  ;/*        The following screen is managed                      */
 26271                                  ;/*                                                             */
 26272                                  ;/*     |0000000000111111111122222222223333333333|              */
 26273                                  ;/*     |0123456789012345678901234567890123456789|              */
 26274                                  ;/*   --|----------------------------------------|              */
 26275                                  ;/*   00|                                        |              */
 26276                                  ;/*   01|                                        |              */
 26277                                  ;/*   02|                                        |              */
 26278                                  ;/*   03|                                        |              */
 26279                                  ;/*   04|Delete DOS Partition                    |              */
 26280                                  ;/*   05|                                        |              */
 26281                                  ;/*   06|Current Fixed Disk Drive: #             |              */
 26282                                  ;/*   07|                                        |              */
 26283                                  ;/*   08|Enter the type of DOS partition you     |              */
 26284                                  ;/*   09|wish to delete..............?           |              */
 26285                                  ;/*   10|                                        |              */
 26286                                  ;/*   11|    1.  Normal DOS partition            |              */
 26287                                  ;/*   12|    2.  EXTENDED DOS Partition          |              */
 26288                                  ;/*   13|    3.  Disk volume in the EXTENDED     |              */
 26289                                  ;/*   14|        DOS Partition                   |              */
 26290                                  ;/*   15|                                        |              */
 26291                                  ;/*   16|                                        |              */
 26292                                  ;/*   17|                                        |              */
 26293                                  ;/*   18|Enter choice: [#]                       |              */
 26294                                  ;/*   19|                                        |              */
 26295                                  ;/*   20|                                        |              */
 26296                                  ;/*   21|                                        |              */
 26297                                  ;/*   22|                                        |              */
 26298                                  ;/*   23|Press ESC to return to FDISK Options    |              */
 26299                                  ;/*   --------------------------------------------              */
 26300                                  ;/*                                                             */
 26301                                  ;/* ENTRY POINTS: Delete_Partition                              */
 26302                                  ;/*      LINKAGE: delete_partition()                            */
 26303                                  ;/*           NEAR CALL                                         */
 26304                                  ;/*                                                             */
 26305                                  ;/* INPUT: None                                                 */
 26306                                  ;/*                                                             */
 26307                                  ;/* EXIT-NORMAL: ERROR=FALSE                                    */
 26308                                  ;/*                                                             */
 26309                                  ;/* EXIT-ERROR: ERROR=TRUE                                      */
 26310                                  ;/*             GOTO internal_program_error if case statement   */
 26311                                  ;/*             failure when branching to requested function    */
 26312                                  ;/*                                                             */
 26313                                  ;/* EFFECTS: No data directly modified by this routine, but     */
 26314                                  ;/*          child routines will modify data.                   */
 26315                                  ;/*                                                             */
 26316                                  ;/* INTERNAL REFERENCES:                                        */
 26317                                  ;/*   ROUTINES:                                                 */
 26318                                  ;/*      clear_screen                                           */
 26319                                  ;/*      wait_for_ESC                                           */
 26320                                  ;/*      get_num_input                                          */
 26321                                  ;/*      internal_program_error                                 */
 26322                                  ;/*      dos_delete                                             */
 26323                                  ;/*      ext_delete                                             */
 26324                                  ;/*      vol_delete                                             */
 26325                                  ;/*                                                             */
 26326                                  ;/* EXTERNAL REFERENCES:                                        */
 26327                                  ;/*   ROUTINES:                                                 */
 26328                                  ;/*                                                             */
 26329                                  ;/******************** END OF SPECIFICATIONS ********************/
 26330                                  
 26331                                  ;/*  */
 26332                                  ;void delete_partition()
 26333                                  ;
 26334                                  ;BEGIN
 26335                                  ;
 26336                                  ;    unsigned i;
 26337                                  ;    char input;
 26338                                  ;    char temp;
 26339                                  ;    char max_input;
 26340                                  ;
 26341                                  ;    input = c(NUL);
 26342                                  ;    /* clear_screen */
 26343                                  ;    clear_screen(u(0),u(0),u(24),u(79));
 26344                                  ;
 26345                                  ;    /* Display header */
 26346                                  ;    display(menu_25);
 26347                                  ;
 26348                                  ;    /* Setup and print current disk */
 26349                                  ;    insert[0] = cur_disk+1+'0';
 26350                                  ;    display(menu_5);
 26351                                  ;
 26352                                  ;    /* check to see if there is an avail partition */
 26353                                  ;    temp = c(0);
 26354                                  ;    for (i = u(0); i < u(4);i++)
 26355                                  ;       BEGIN
 26356                                  ;
 26357                                  ;        /* See if any non - zero system id bytes */
 26358                                  ;        temp = temp | part_table[cur_disk][i].sys_id ;
 26359                                  ;       END
 26360                                  ;    /* Any entry that isn't zero means */
 26361                                  ;    if (temp != c(0))
 26362                                  ;       BEGIN
 26363                                  ;
 26364                                  ;        /* Display enter prompts */
 26365                                  ;        /* display dos delete menu without input prompt */
 26366                                  ;        display(menu_3);
 26367                                  ;        display(menu_25);
 26368                                  ;        display(menu_26);
 26369                                  ;        display(menu_7);
 26370                                  ;
 26371                                  ;        /* print ESC prompt */
 26372                                  ;        display(menu_11);
 26373                                  ;
 26374                                  ;        display(menu_27);
 26375                                  ;        display(menu_57);
 26376                                  ;        max_input = c(4);
 26377                                  ;
 26378                                  ;        input = get_num_input(c(NUL),max_input,input_row,input_col);
 26379                                  ;        /* Go branch to the requested function */
 26380                                  ;        switch(input)
 26381                                  ;           BEGIN
 26382                                  ;            case '1':
 26383                                  ;                if (find_partition_type(uc(DOS12)) ||
 26384                                  ;                    find_partition_type(uc(DOS16)) ||
 26385                                  ;                    find_partition_type(uc(DOSNEW)))
 26386                                  ;                    dos_delete();
 26387                                  ;                else
 26388                                  ;                    BEGIN
 26389                                  ;                    /* No Pri partition to delete */
 26390                                  ;                    clear_screen(u(17),u(0),u(17),u(79));
 26391                                  ;                    display(error_6);
 26392                                  ;                    wait_for_ESC();
 26393                                  ;                    END
 26394                                  ;                break;
 26395                                  ;
 26396                                  ;            case '2':
 26397                                  ;                if (find_partition_type(uc(EXTENDED)))
 26398                                  ;                    ext_delete();
 26399                                  ;                else
 26400                                  ;                    BEGIN
 26401                                  ;                    /* No Ext partition to delete */
 26402                                  ;                    clear_screen(u(17),u(0),u(17),u(79));
 26403                                  ;                    display(error_7);
 26404                                  ;                    wait_for_ESC();
 26405                                  ;                    END
 26406                                  ;                break;
 26407                                  ;
 26408                                  ;            case '3':
 26409                                  ;                if ((find_partition_type(uc(EXTENDED))) && (find_logical_drive()))
 26410                                  ;                    volume_delete();
 26411                                  ;                else
 26412                                  ;                    BEGIN
 26413                                  ;                    clear_screen(u(17),u(0),u(17),u(79));
 26414                                  ;                    display(error_36);
 26415                                  ;                    wait_for_ESC();
 26416                                  ;                    END
 26417                                  ;                break;
 26418                                  ;
 26419                                  ;            case '4':
 26420                                  ;                if (find_non_dos_partition())
 26421                                  ;                    non_dos_delete();
 26422                                  ;                else
 26423                                  ;                    BEGIN
 26424                                  ;                    clear_screen(u(17),u(0),u(17),u(79));
 26425                                  ;                    display(error_38);
 26426                                  ;                    wait_for_ESC();
 26427                                  ;                    END
 26428                                  ;                break;
 26429                                  ;
 26430                                  ;            case ESC:
 26431                                  ;                break;
 26432                                  ;
 26433                                  ;            default :
 26434                                  ;                internal_program_error();
 26435                                  ;                 break;
 26436                                  ;           END
 26437                                  ;       END
 26438                                  ;    else
 26439                                  ;       BEGIN
 26440                                  ;        display(error_14);
 26441                                  ;        wait_for_ESC();
 26442                                  ;       END
 26443                                  ;    /* clear the screen before going back to main menu */
 26444                                  ;    clear_screen(u(0),u(0),u(24),u(79));
 26445                                  ;    return;
 26446                                  ;END
 26447                                  
 26448                                  delete_partition:
 26449                                  		; 23/12/2018
 26450                                  
 26451                                  	%define dp_i	bp-4
 26452                                  	%define dp_temp	bp-2
 26453                                  
 26454 00003A80 55                      		push	bp
 26455 00003A81 89E5                    		mov	bp,sp
 26456 00003A83 83EC04                  		sub	sp,4
 26457                                  
 26458                                  		;/* clear_screen */
 26459                                  
 26460                                  		;mov	ax,79
 26461                                  		;push	ax
 26462                                  		;mov	ax,24
 26463                                  		;push	ax
 26464                                  		;sub	ax,ax
 26465                                  		;push	ax
 26466                                  		;push	ax
 26467                                  		;call	clear_screen
 26468                                  		;add	sp,8
 26469                                  
 26470 00003A86 E8D5D9                  		call	CLS
 26471                                  
 26472                                  		;/* Display header */
 26473                                  
 26474                                  		;push	word [menu_25_segment]
 26475 00003A89 1E                      		push	ds
 26476 00003A8A FF36[339E]              		push	word [menu_25_offset]
 26477 00003A8E E893DB                  		call	display
 26478                                  		;pop	bx
 26479                                  		;pop	bx
 26480                                  
 26481                                  		;/* Setup and print current disk */
 26482                                  
 26483                                  		;mov	al,[cur_disk]
 26484                                  		;add	al,'1'
 26485                                  		;mov	[insert],al
 26486                                  		;;push	word [menu_5_segment]
 26487                                  		;push	ds
 26488                                  		;push	word [menu_5_offset]
 26489                                  		;call	display
 26490                                  		;;pop	bx
 26491                                  		;;pop	bx
 26492                                  
 26493 00003A91 E8C9F3                  		call	display_menu_5 ; 31/12/2018
 26494                                  
 26495                                  		;/* check to see if there is an avail partition */
 26496                                  		
 26497 00003A94 28C0                    		sub	al,al ; 0
 26498 00003A96 8846FE                  		mov	[dp_temp],al
 26499 00003A99 8846FC                  		mov	[dp_i],al ; 0
 26500                                  dp_1:
 26501 00003A9C A0[E2CB]                		mov	al,[cur_disk]
 26502                                  		;cbw
 26503                                  		;shl	ax,1
 26504                                  		;shl	ax,1
 26505 00003A9F D0E0                    		shl	al,1
 26506 00003AA1 D0E0                    		shl	al,1
 26507                                  		;add	ax,[dp_i]
 26508 00003AA3 0246FC                  		add	al,[dp_i]
 26509                                  		;mov	cx,46
 26510                                  		;mul	cx
 26511 00003AA6 B12E                    		mov	cl,46
 26512 00003AA8 F6E1                    		mul	cl
 26513 00003AAA 89C3                    		mov	bx,ax
 26514                                  
 26515                                  		;/* See if any non-zero system id bytes */
 26516                                  		
 26517 00003AAC 8A87[25C4]              		mov	al,[part_table_sys_id+bx]
 26518 00003AB0 0846FE                  		or	[dp_temp],al
 26519 00003AB3 FE46FC                  		inc	byte [dp_i]
 26520 00003AB6 807EFC04                		cmp	byte [dp_i],4
 26521 00003ABA 72E0                    		jb	short dp_1
 26522                                  
 26523                                  		;/* Any entry that isn't zero means */
 26524                                  
 26525 00003ABC 807EFE00                		cmp	byte [dp_temp],0
 26526 00003AC0 7503                    		jne	short dp_2
 26527 00003AC2 E9C500                  		jmp	dp_16
 26528                                  dp_2:
 26529                                  		;/* Display enter prompts */
 26530                                  		;/* display dos delete menu without input prompt */
 26531                                  
 26532                                  		;push	word [menu_3_segment]
 26533 00003AC5 1E                      		push	ds
 26534 00003AC6 FF36[F99D]              		push	word [menu_3_offset]
 26535 00003ACA E857DB                  		call	display
 26536                                  		;pop	bx
 26537                                  		;pop	bx
 26538                                  		
 26539                                  		;;push	word [menu_25_segment]
 26540                                  		;push	ds
 26541                                  		;push	word [menu_25_offset]
 26542                                  		;call	display
 26543                                  		;;pop	bx
 26544                                  		;;pop	bx
 26545                                  		
 26546                                  		;push	word [menu_26_segment]
 26547 00003ACD 1E                      		push	ds
 26548 00003ACE FF36[359E]              		push	word [menu_26_offset]
 26549 00003AD2 E84FDB                  		call	display
 26550                                  		;pop	bx
 26551                                  		;pop	bx
 26552                                  		
 26553                                  		;push	word [menu_7_segment]
 26554 00003AD5 1E                      		push	ds
 26555 00003AD6 FF36[019E]              		push	word [menu_7_offset]
 26556 00003ADA E847DB                  		call	display
 26557                                  		;pop	bx
 26558                                  		;pop	bx
 26559                                  		
 26560                                  		;/* print ESC prompt */
 26561                                  
 26562                                  		;;push	word [menu_11_segment]
 26563                                  		;push	ds
 26564                                  		;push	word [menu_11_offset]
 26565                                  		;call	display
 26566                                  		;;pop	bx
 26567                                  		;;pop	bx
 26568                                  
 26569 00003ADD E88EF3                  		call	display_menu_11 ; 31/12/2018
 26570                                  		
 26571                                  		;push	word [menu_27_segment]
 26572 00003AE0 1E                      		push	ds
 26573 00003AE1 FF36[379E]              		push	word [menu_27_offset]
 26574 00003AE5 E83CDB                  		call	display
 26575                                  		;pop	bx
 26576                                  		;pop	bx
 26577                                  
 26578                                  		;push	word [menu_57_segment]
 26579 00003AE8 1E                      		push	ds
 26580 00003AE9 FF36[399E]              		push	word [menu_57_offset]
 26581 00003AED E834DB                  		call	display
 26582                                  		;pop	bx
 26583                                  		;pop	bx
 26584                                  
 26585 00003AF0 FF36[AAA0]              		push	word [input_col]
 26586 00003AF4 FF36[4CA1]              		push	word [input_row]
 26587 00003AF8 B004                    		mov	al,4  ; Maximum input = 4	
 26588 00003AFA 50                      		push	ax
 26589 00003AFB 28C0                    		sub	al,al ; Default input = 0
 26590 00003AFD 50                      		push	ax
 26591 00003AFE E873EF                  		call	get_num_input
 26592                                  		;add	sp,8
 26593                                  
 26594                                  		;/* Go branch to the requested function */
 26595                                  switch_input2:
 26596                                  		;cbw
 26597                                  		;cmp	ax,'4'
 26598 00003B01 3C34                    		cmp	al,'4'
 26599 00003B03 7502                    		jne	short dp_4
 26600 00003B05 EB6F                    		jmp	case_delete_4
 26601                                  dp_4:
 26602 00003B07 7713                    		ja	short dp_6
 26603 00003B09 2C1B                    		sub	al,1Bh  ; ESC key
 26604 00003B0B 7503                    		jnz	short dp_5
 26605 00003B0D E98500                  		jmp	case_delete_ESC
 26606                                  dp_5:
 26607 00003B10 2C16                    		sub	al,16h  ; 1Bh+16h = 31h = '1'
 26608 00003B12 740D                    		jz	short case_delete_1
 26609 00003B14 FEC8                    		dec	al		  ; 32h = '2'
 26610 00003B16 742D                    		jz	short case_delete_2
 26611 00003B18 FEC8                    		dec	al		  ; 33h = '3'	
 26612 00003B1A 743F                    		jz	short case_delete_3
 26613                                  dp_6:
 26614 00003B1C E8FCF7                  		call	internal_program_error
 26615 00003B1F EB74                    		jmp	case_delete_ESC
 26616                                  case_delete_1:
 26617 00003B21 B001                    		mov	al,1  ; DOS12 (FAT12)
 26618                                  		;push	ax
 26619 00003B23 E89EE2                  		call	find_partition_type
 26620                                  		;pop	bx
 26621                                  		;or	al,al
 26622                                  		;jnz	short dp_8
 26623 00003B26 730E                    		jnc	short dp_8
 26624                                  
 26625 00003B28 B004                    		mov	al,4  ; DOS16 (FAT16)
 26626                                  		;push	ax
 26627 00003B2A E897E2                  		call	find_partition_type
 26628                                  		;pop	bx
 26629                                  		;or	al,al
 26630                                  		;jnz	short dp_8
 26631 00003B2D 7307                    		jnc	short dp_8
 26632                                  		
 26633 00003B2F B006                    		mov	al,6  ; DOSNEW (FAT16 big)
 26634                                  		;push	ax
 26635 00003B31 E890E2                  		call	find_partition_type
 26636                                  		;pop	bx
 26637                                  		;or	al,al
 26638                                  		;jz	short dp_9
 26639 00003B34 7205                    		jc	short dp_9
 26640                                  dp_8:
 26641 00003B36 E87300                  		call	dos_delete
 26642 00003B39 EB5A                    		jmp	case_delete_ESC
 26643                                  dp_9:
 26644                                  		;mov	ax,79
 26645                                  		;push	ax
 26646                                  		;mov	ax,17
 26647                                  		;push	ax
 26648                                  		;sub	cx,cx
 26649                                  		;push	cx
 26650                                  		;push	ax
 26651                                  		;call	clear_screen
 26652                                  		;;add	sp,8
 26653                                  
 26654 00003B3B E85E00                  		call	CLS_R17 ; 23/12/2018
 26655                                  
 26656                                  		;push	word [error_6_seg]
 26657 00003B3E 1E                      		push	ds
 26658 00003B3F FF36[8E9E]              		push	word [error_6_off]
 26659 00003B43 EB4A                    		jmp	dp_17
 26660                                  case_delete_2:
 26661 00003B45 B005                    		mov	al,5 ; EXTENDED partition
 26662                                  		;push	ax
 26663 00003B47 E87AE2                  		call	find_partition_type
 26664                                  		;pop	bx
 26665                                  		;or	al,al
 26666                                  		;jz	short dp_11
 26667 00003B4A 7205                    		jc	short dp_11
 26668                                  
 26669 00003B4C E83702                  		call	ext_delete
 26670 00003B4F EB44                    		jmp	case_delete_ESC
 26671                                  dp_11:
 26672                                  		;mov	ax,79
 26673                                  		;push	ax
 26674                                  		;mov	ax,17
 26675                                  		;push	ax
 26676                                  		;sub	cx,cx
 26677                                  		;push	cx
 26678                                  		;push	ax
 26679                                  		;call	clear_screen
 26680                                  		;;add	sp,8
 26681                                  
 26682 00003B51 E84800                  		call	CLS_R17 ; 23/12/2018
 26683                                  
 26684                                  		;push	word [error_7_seg]
 26685 00003B54 1E                      		push	ds
 26686 00003B55 FF36[909E]              		push	word [error_7_off]
 26687 00003B59 EB34                    		jmp	short dp_17
 26688                                  case_delete_3:
 26689 00003B5B B005                    		mov	al,5
 26690                                  		;push	ax
 26691 00003B5D E864E2                  		call	find_partition_type
 26692                                  		;pop	bx
 26693                                  		;or	al, al
 26694                                  		;jz	short dp_13
 26695 00003B60 720A                    		jc	short dp_13
 26696 00003B62 E8C1F4                  		call	find_logical_drive
 26697                                  		;or	al,al
 26698                                  		;jz	short dp_13
 26699 00003B65 7205                    		jc	short dp_13
 26700 00003B67 E8C802                  		call	volume_delete
 26701 00003B6A EB29                    		jmp	short case_delete_ESC
 26702                                  dp_13:
 26703                                  		;mov	ax,79
 26704                                  		;push	ax
 26705                                  		;mov	ax,17
 26706                                  		;push	ax
 26707                                  		;sub	cx,cx
 26708                                  		;push	cx
 26709                                  		;push	ax
 26710                                  		;call	clear_screen
 26711                                  		;;add	sp,8
 26712                                  
 26713 00003B6C E82D00                  		call	CLS_R17 ; 23/12/2018
 26714                                  
 26715                                  		;push	word [error_36_seg]
 26716 00003B6F 1E                      		push	ds
 26717 00003B70 FF36[C69E]              		push	word [error_36_off]
 26718 00003B74 EB19                    		jmp	short dp_17
 26719                                  case_delete_4:
 26720 00003B76 E8A007                  		call	find_non_dos_partition
 26721                                  		;or	al,al
 26722                                  		;jz	short dp_15
 26723 00003B79 7205                    		jc	short dp_15
 26724 00003B7B E85306                  		call	non_dos_delete
 26725 00003B7E EB15                    		jmp	short case_delete_ESC
 26726                                  dp_15:
 26727                                  		;mov	ax,79
 26728                                  		;push	ax
 26729                                  		;mov	ax,17
 26730                                  		;push	ax
 26731                                  		;sub	cx,cx
 26732                                  		;push	cx
 26733                                  		;push	ax
 26734                                  		;call	clear_screen
 26735                                  		;;add	sp,8
 26736                                  
 26737 00003B80 E81900                  		call	CLS_R17 ; 23/12/2018
 26738                                  
 26739                                  		;push	word [error_38_seg]
 26740 00003B83 1E                      		push	ds
 26741 00003B84 FF36[CA9E]              		push	word [error_38_off]
 26742 00003B88 EB05                    		jmp	short dp_17
 26743                                  dp_16:
 26744                                  		;push	word [error_14_seg]
 26745 00003B8A 1E                      		push	ds
 26746 00003B8B FF36[9C9E]              		push	word [error_14_off]
 26747                                  dp_17:
 26748 00003B8F E892DA                  		call	display
 26749                                  		;pop	bx
 26750                                  		;pop	bx
 26751                                  
 26752 00003B92 E8DFF5                  		call	wait_for_ESC
 26753                                  case_delete_ESC:
 26754                                  		;/* clear the screen before going back to main menu */
 26755                                  
 26756                                  		;mov	ax,79
 26757                                  		;push	ax
 26758                                  		;mov	ax,24
 26759                                  		;push	ax
 26760                                  		;sub	ax,ax
 26761                                  		;push	ax
 26762                                  		;push	ax
 26763                                  		;call	clear_screen
 26764                                  
 26765 00003B95 E8C6D8                  		call	CLS
 26766                                  		
 26767 00003B98 89EC                    		mov	sp,bp
 26768 00003B9A 5D                      		pop	bp
 26769 00003B9B C3                      		retn
 26770                                  
 26771                                  CLS_R17:
 26772                                  		; 23/12/2018 (Clear row 17)
 26773 00003B9C B84F00                  		mov	ax,79
 26774 00003B9F 50                      		push	ax
 26775 00003BA0 B81100                  		mov	ax,17
 26776 00003BA3 50                      		push	ax
 26777 00003BA4 29C9                    		sub	cx,cx
 26778 00003BA6 51                      		push	cx
 26779 00003BA7 50                      		push	ax
 26780 00003BA8 E8EBD8                  		call	clear_screen
 26781                                  		;add	sp,8
 26782 00003BAB C3                      		retn
 26783                                  
 26784                                  ; fdisk.msg (MSDOS 6.0)
 26785                                  ;/***************************************************************************************************/
 26786                                  ;/*  Screen for DOS_DELETE                                                                          */
 26787                                  ;/*                                                                                                 */
 26788                                  ;/*     |00000000001111111111222222222233333333334444444444555555555566666666667777777777|          */
 26789                                  ;/*     |01234567890123456789012345678901234567890123456789012345678901234567890123456789|          */
 26790                                  ;/*   --|--------------------------------------------------------------------------------|          */
 26791                                  ;/*   00|                                                                                |          */
 26792                                  ;/*   01|                                                                                |          */
 26793                                  ;/*   02|                                                                                |          */
 26794                                  ;/*   03|                                                                                |          */
 26795                                  ;/*   04|                           Delete Primary DOS Partition                         |menu_28   */
 26796                                  ;/*   05|                                                                                |          */
 26797                                  ;/*   06|    Current fixed disk drive: #                                                 |menu_5 #  */
 26798                                  ;/*   07|                                                                                |          */
 26799                                  ;/*   08|    Partition Status   Type    Size in Mbytes   Percentage of Disk Used         |menu_14 # */
 26800                                  ;/*   09|     ## #        #   #######       ####         ###%                            |menu_14 # */
 26801                                  ;/*   10|     ## #        #   #######       ####         ###%                            |          */
 26802                                  ;/*   11|     ## #        #   #######       ####         ###%                            |          */
 26803                                  ;/*   12|     ## #        #   #######       ####         ###%                            |          */
 26804                                  ;/*   13|                                                                                |          */
 26805                                  ;/*   14|    Total disk space is #### Mbytes (1 Mbyte = 1048576 bytes)                   |menu_15 # */
 26806                                  ;/*   15|                                                                                |          */
 26807                                  ;/*   16|    Warning! Data in the deleted Primary DOS Partition will be lost.            |menu_29   */
 26808                                  ;/*   17|    What Primary DOS Partition do you want to delete? [ ]                       |          */
 26809                                  ;/*   18|                                                                                |          */
 26810                                  ;/*   19|    Do you wish to continue (Y/N).................? [N]                         |menu_56   */
 26811                                  ;/*   20|                                                                                |          */
 26812                                  ;/*   21|                                                                                |          */
 26813                                  ;/*   22|                                                                                |          */
 26814                                  ;/*   23|                                                                                |          */
 26815                                  ;/*   24|    Press ESC to return to FDISK Options                                        |menu_11   */
 26816                                  ;/*   ------------------------------------------------------------------------------------          */ 
 26817                                  ;/*                                                                                                 */
 26818                                  ;/***************************************************************************************************/
 26819                                  
 26820                                  ; d_menus.c (MSDOS 6.0)
 26821                                  ;/*  */
 26822                                  ;/******************* START OF SPECIFICATIONS *******************/
 26823                                  ;/*                                                             */
 26824                                  ;/* SUBROUTINE NAME: DOS_DELETE                                 */
 26825                                  ;/*                                                             */
 26826                                  ;/* DESCRIPTIVE NAME: Delete DOS partition                      */
 26827                                  ;/*                                                             */
 26828                                  ;/* FUNCTION: Delete the DOS partition. Prompt user with dire   */
 26829                                  ;/*           warning first. Default entry on prompt is (N)     */
 26830                                  ;/*                                                             */
 26831                                  ;/* NOTES: Screen can be exited via the ESC command before      */
 26832                                  ;/*        partition is deleted and nothing will change         */
 26833                                  ;/*                                                             */
 26834                                  ;/*        The following screen is managed                      */
 26835                                  ;/*                                                             */
 26836                                  ;/*     |0000000000111111111122222222223333333333|              */
 26837                                  ;/*     |0123456789012345678901234567890123456789|              */
 26838                                  ;/*   --|----------------------------------------|              */
 26839                                  ;/*   00|                                        |              */
 26840                                  ;/*   01|                                        |              */
 26841                                  ;/*   02|                                        |              */
 26842                                  ;/*   03|                                        |              */
 26843                                  ;/*   04|Delete DOS Partition                    |              */
 26844                                  ;/*   05|                                        |              */
 26845                                  ;/*   06|Current Fixed Disk Drive: #             |              */
 26846                                  ;/*   07|                                        |              */
 26847                                  ;/*   08|Partition Status   Type  Start  End Size|              */
 26848                                  ;/*   09|    #        #   #######  #### #### ####|              */
 26849                                  ;/*   10|                                        |              */
 26850                                  ;/*   11|                                        |              */
 26851                                  ;/*   12|                                        |              */
 26852                                  ;/*   13|                                        |              */
 26853                                  ;/*   14|Total disk space is #### cylinders.     |              */
 26854                                  ;/*   15|                                        |              */
 26855                                  ;/*   16|                                        |              */
 26856                                  ;/*   17|                                        |              */
 26857                                  ;/*   18|Warning! Data in the DOS partition      |              */
 26858                                  ;/*   19|will be lost. Do you wish to            |              */
 26859                                  ;/*   20|continue..........................? [N] |              */
 26860                                  ;/*   21|                                        |              */
 26861                                  ;/*   22|                                        |              */
 26862                                  ;/*   23|Press ESC to return to FDISK Options    |              */
 26863                                  ;/*   --------------------------------------------              */
 26864                                  ;/*                                                             */
 26865                                  ;/* ENTRY POINTS: DOS_Delete                                    */
 26866                                  ;/*      LINKAGE: dos_delete                                    */
 26867                                  ;/*          NEAR CALL                                          */
 26868                                  ;/*                                                             */
 26869                                  ;/* INPUT: None                                                 */
 26870                                  ;/*                                                             */
 26871                                  ;/* EXIT-NORMAL: ERROR=FALSE                                    */
 26872                                  ;/*                                                             */
 26873                                  ;/* EXIT-ERROR: ERROR=TRUE                                      */
 26874                                  ;/*             GOTO internal_program_error if invalid input    */
 26875                                  ;/*             returned to this level                          */
 26876                                  ;/*                                                             */
 26877                                  ;/* EFFECTS: No data directly modified by this routine, but     */
 26878                                  ;/*          child routines will modify data.                   */
 26879                                  ;/*                                                             */
 26880                                  ;/* INTERNAL REFERENCES:                                        */
 26881                                  ;/*   ROUTINES                                                  */
 26882                                  ;/*      table_display                                          */
 26883                                  ;/*      clear_screen                                           */
 26884                                  ;/*      wait_for_ESC                                           */
 26885                                  ;/*      get_yn_input                                           */
 26886                                  ;/*      display                                                */
 26887                                  ;/*      Write_Boot_Record                                      */
 26888                                  ;/*      find_part_free_space                                   */
 26889                                  ;/*                                                             */
 26890                                  ;/* EXTERNAL REFERENCES:                                        */
 26891                                  ;/*   ROUTINES:                                                 */
 26892                                  ;/*                                                             */
 26893                                  ;/******************** END OF SPECIFICATIONS ********************/
 26894                                  
 26895                                  ;/*  */
 26896                                  ;void dos_delete()
 26897                                  ;
 26898                                  ;BEGIN
 26899                                  ;
 26900                                  ;    char input;
 26901                                  ;    unsigned i;
 26902                                  ;    unsigned char string_input[12];
 26903                                  ;
 26904                                  ;    int     j;
 26905                                  ;    int     pri;
 26906                                  ;    int     ext;
 26907                                  ;    int     cnt;
 26908                                  ;    int     pnum;
 26909                                  ;
 26910                                  ;    input = c(NUL);
 26911                                  ;    /* clear screen */
 26912                                  ;    clear_screen(u(0),u(0),u(24),u(79));
 26913                                  ;
 26914                                  ;    /* Display header */
 26915                                  ;    display(menu_28);
 26916                                  ;
 26917                                  ;    /* Setup and print current disk */
 26918                                  ;    insert[0] = cur_disk+1+'0';
 26919                                  ;    display(menu_5);
 26920                                  ;
 26921                                  ;    /* print ESC prompt */
 26922                                  ;    display(menu_11);
 26923                                  ;
 26924                                  ;    /* Display partition data and double check if partition exists*/
 26925                                  ;    if (table_display())
 26926                                  ;       BEGIN
 26927                                  ;
 26928                                  ;        sprintf(insert,"%4.0d",total_mbytes[cur_disk]);
 26929                                  ;        display(menu_15);
 26930                                  ;
 26931                                  ;        /* See if drive 1 and extended partition exists */
 26932                                  ;
 26933                                  ;        cnt = 0;
 26934                                  ;        pri = 0;
 26935                                  ;        ext = 0;
 26936                                  ;
 26937                                  ;        /* Find the total number of partitions, the number of normal
 26938                                  ;        /* partitions, and whether there is an extended partition on the
 26939                                  ;        /* current hard disk
 26940                                  ;
 26941                                  ;        for (i = u(0); i < u(4); i++)
 26942                                  ;            if (part_table[cur_disk][i].sys_id != uc(0))
 26943                                  ;               {
 26944                                  ;                cnt++;
 26945                                  ;                if ((part_table[cur_disk][i].sys_id == uc(DOS12)) ||
 26946                                  ;                    (part_table[cur_disk][i].sys_id == uc(DOS16)) ||
 26947                                  ;                    (part_table[cur_disk][i].sys_id == uc(DOSNEW))  )
 26948                                  ;                   {
 26949                                  ;                    pri++;
 26950                                  ;                   }
 26951                                  ;                else if (part_table[cur_disk][i].sys_id == uc(LOGICAL))
 26952                                  ;                   {
 26953                                  ;                    ext = 1;
 26954                                  ;                   }
 26955                                  ;               }
 26956                                  ;
 26957                                  ;        /* The partition can be deleted if the the number of normal          */
 26958                                  ;        /* partitions is greater than one or if there is only one but it is  */
 26959                                  ;        /* not the first hard disk or if there is only one normal partition  */
 26960                                  ;        /* on the first hard disk but no extended partition.                 */
 26961                                  ;
 26962                                  ;        if ((pri > 1) ||
 26963                                  ;            (pri == 1 && cur_disk != c(0)) ||
 26964                                  ;            (pri == 1 && cur_disk == c(0) && !ext))
 26965                                  ;           BEGIN
 26966                                  ;            /* Display partition number prompt */
 26967                                  ;            display(menu_55);
 26968                                  ;
 26969                                  ;            /* Get the partition number from the user */
 26970                                  ;            input = get_num_input(c(1),c(cnt),input_row,input_col);
 26971                                  ;
 26972                                  ;            if (input != ESC)
 26973                                  ;               {
 26974                                  ;                pnum = (int)input - '0';
 26975                                  ;
 26976                                  ;                /* The number that the user has entered is the sorted numbering  */
 26977                                  ;                /* of the partition table. We have to retrieve the actual        */
 26978                                  ;                /* position of this partition in the partition table             */
 26979                                  ;
 26980                                  ;                j = 0;
 26981                                  ;                for (i = 0; i < 4; i++)
 26982                                  ;                   {
 26983                                  ;                    if (part_table[cur_disk][sort[i]].sys_id != 0)
 26984                                  ;                       {
 26985                                  ;                        j++;
 26986                                  ;                        if (j == pnum)
 26987                                  ;                            break;
 26988                                  ;                       }
 26989                                  ;                   };
 26990                                  ;                i = sort[i];
 26991                                  ;
 26992                                  ;                /* Verify selected partition is a primary partition */
 26993                                  ;
 26994                                  ;                if ((part_table[cur_disk][i].sys_id==uc(DOS12)) ||
 26995                                  ;                    (part_table[cur_disk][i].sys_id==uc(DOS16)) ||
 26996                                  ;                    (part_table[cur_disk][i].sys_id==uc(DOSNEW)) )
 26997                                  ;                   {
 26998                                  ;                    /* delete previous volume mismatch message */
 26999                                  ;                    string_input[0] = uc(NUL);
 27000                                  ;
 27001                                  ;                    /* Get input volume label */
 27002                                  ;                    display(menu_41);
 27003                                  ;                    get_string_input(input_row,input_col,string_input);
 27004                                  ;                    if (string_input[0] != uc(ESC))
 27005                                  ;                       {
 27006                                  ;                        /* See if the volume id matches the drive */
 27007                                  ;                        if (strcmp(part_table[cur_disk][i].vol_label,
 27008                                  ;                            string_input) == (int)ZERO)
 27009                                  ;                           {
 27010                                  ;                            /* Display Y/N prompt */
 27011                                  ;                            display(menu_34);
 27012                                  ;
 27013                                  ;                            /* Get yes/no prompt */
 27014                                  ;                            input = get_yn_input(c(No),input_row,input_col);
 27015                                  ;                            switch(input)
 27016                                  ;                               BEGIN
 27017                                  ;                                case 1:
 27018                                  ;                                   BEGIN
 27019                                  ;                                    /* Set Partition entry to zero */
 27020                                  ;                                    remove_partition(cur_disk,i);
 27021                                  ;
 27022                                  ;                                    /* Redisplay the partition info */
 27023                                  ;                                    table_display();
 27024                                  ;
 27025                                  ;                                    /* clear the prompt off */
 27026                                  ;                                    clear_screen(u(16),u(0),u(23),u(79));
 27027                                  ;
 27028                                  ;                                    /* Set the reboot flag */
 27029                                  ;                                    reboot_flag = (FLAG)TRUE;
 27030                                  ;
 27031                                  ;                                    /* Say that you deleted it */
 27032                                  ;                                    display(status_1);
 27033                                  ;
 27034                                  ;                                    wait_for_ESC();
 27035                                  ;                                    break;
 27036                                  ;                                   END
 27037                                  ;
 27038                                  ;                                case 0:
 27039                                  ;                                    break;
 27040                                  ;
 27041                                  ;                                case ESC:
 27042                                  ;                                    break;
 27043                                  ;
 27044                                  ;                                default:
 27045                                  ;                                   BEGIN
 27046                                  ;                                    internal_program_error();
 27047                                  ;                                    break;
 27048                                  ;                                   END
 27049                                  ;                               END
 27050                                  ;                           }
 27051                                  ;                        else
 27052                                  ;                           {
 27053                                  ;                            /* Tell user volume name was incorrect */
 27054                                  ;                            display(error_34);
 27055                                  ;                            wait_for_ESC();
 27056                                  ;                           }
 27057                                  ;                       }
 27058                                  ;                   }
 27059                                  ;                else
 27060                                  ;                   {
 27061                                  ;                    /* Tell user he can only delete primary partition */
 27062                                  ;                    display(error_37);
 27063                                  ;                    wait_for_ESC();
 27064                                  ;                   }
 27065                                  ;               }
 27066                                  ;           END
 27067                                  ;        else
 27068                                  ;           BEGIN
 27069                                  ;            /* Tell user he can't do it while extended exists on drive 1 */
 27070                                  ;            display(error_32);
 27071                                  ;            wait_for_ESC();
 27072                                  ;           END
 27073                                  ;       END
 27074                                  ;
 27075                                  ;    else
 27076                                  ;       BEGIN
 27077                                  ;        internal_program_error();
 27078                                  ;       END
 27079                                  ;    clear_screen(u(0),u(0),u(24),u(79));
 27080                                  ;    return;
 27081                                  ;END
 27082                                  
 27083                                  dos_delete:
 27084                                  		; 23/12/2018
 27085                                  
 27086                                  	%define ddp_pri	      bp-24 ;bp-26
 27087                                  	%define ddp_j	      bp-22 ;bp-24
 27088                                  	%define ddp_i	      bp-20 ;bp-22
 27089                                  	%define ddp_str_input bp-18 ;bp-20
 27090                                  	%define ddp_cnt	      bp-6  ;bp-8
 27091                                  	%define ddp_ext	      bp-4  ;bp-6
 27092                                  	%define ddp_input     	    ;bp-4
 27093                                  	%define ddp_pnum      bp-2  ;bp-2
 27094                                  
 27095 00003BAC 55                      		push	bp
 27096 00003BAD 89E5                    		mov	bp,sp
 27097                                  		;sub	sp,26
 27098 00003BAF 83EC18                  		sub	sp,24 ; 24/12/2018
 27099                                  
 27100                                  		;mov	word [ddp_input],0
 27101                                  		
 27102                                  		;/* clear screen */
 27103                                  
 27104                                  		;mov	ax,79
 27105                                  		;push	ax
 27106                                  		;mov	ax,24
 27107                                  		;push	ax
 27108                                  		;sub	ax,ax
 27109                                  		;push	ax
 27110                                  		;push	ax
 27111                                  		;call	clear_screen
 27112                                  		;add	sp,8
 27113                                  
 27114 00003BB2 E8A9D8                  		call	CLS
 27115                                  
 27116                                  		;/* Display header */
 27117                                  
 27118                                  		;push	word [menu_28_segment]
 27119 00003BB5 1E                      		push	ds
 27120 00003BB6 FF36[3B9E]              		push	word [menu_28_offset]
 27121 00003BBA E867DA                  		call	display
 27122                                  		;pop	bx
 27123                                  		;pop	bx
 27124                                  
 27125                                  		;/* Setup and print current disk */
 27126                                  
 27127                                  		;mov	al,[cur_disk]
 27128                                  		;add	al,'1'
 27129                                  		;mov	[insert],al
 27130                                  		;;push	word [menu_5_segment]
 27131                                  		;push	ds
 27132                                  		;push	word [menu_5_offset]
 27133                                  		;call	display
 27134                                  		;;pop	bx
 27135                                  		;;pop	bx
 27136                                  
 27137 00003BBD E89DF2                  		call	display_menu_5 ; 31/12/2018
 27138                                  		
 27139                                  		;/* print ESC prompt */
 27140                                  
 27141                                  		;;push	word [menu_11_segment]
 27142                                  		;push	ds
 27143                                  		;push	word [menu_11_offset]
 27144                                  		;call	display
 27145                                  		;;pop	bx
 27146                                  		;;pop	bx
 27147                                  
 27148 00003BC0 E8ABF2                  		call	display_menu_11 ; 31/12/2018
 27149                                  
 27150                                  	;/* Display partition data and double check if partition exists */
 27151                                  
 27152 00003BC3 E8B1F2                  		call	table_display
 27153                                  		;or	al,al
 27154                                  		;jnz	short ddp_1
 27155 00003BC6 7303                    		jnc	short ddp_1
 27156 00003BC8 E99601                  		jmp	case_dos_del_DEF
 27157                                  ddp_1:
 27158                                  		;;mov	al,[cur_disk]
 27159                                  		;;cbw
 27160                                  		;;mov	bx,ax
 27161                                  		;mov	bl,[cur_disk]
 27162                                  		;xor	bh,bh
 27163                                  		;shl	bx,1
 27164                                  		;push	word [total_mbytes+bx]
 27165                                  		;mov	ax,disk_size_format ; "%4.1d"
 27166                                  		;push	ax
 27167                                  		;mov	ax,insert
 27168                                  		;push	ax
 27169                                  		;call	sprintf
 27170                                  		;add	sp,6
 27171                                  
 27172 00003BCB E89D01                  		call	sprintf_total_mbytes ; 24/12/2018
 27173                                  
 27174                                  		;push	word [menu_15_segment]
 27175 00003BCE 1E                      		push	ds
 27176 00003BCF FF36[139E]              		push	word [menu_15_offset]
 27177 00003BD3 E84EDA                  		call	display
 27178                                  		;pop	bx
 27179                                  		;pop	bx
 27180                                  
 27181                                  		;/* See if drive 1 and extended partition exists */
 27182                                  
 27183 00003BD6 29C0                    		sub	ax,ax
 27184 00003BD8 8846FA                  		mov	[ddp_cnt],al ; 0
 27185 00003BDB 8846E8                  		mov	[ddp_pri],al ; 0
 27186 00003BDE 8846FC                  		mov	[ddp_ext],al ; 0
 27187                                  
 27188                                  	;/* Find the total number of partitions, the number of normal */
 27189                                  	;/* partitions, and whether there is an extended partition on the */
 27190                                  	;/* current hard disk */
 27191                                  
 27192 00003BE1 8946EC                  		mov	[ddp_i],ax ; 0
 27193 00003BE4 EB11                    		jmp	short ddp_4
 27194                                  ddp_2:
 27195                                  		;mov	al,[cur_disk]
 27196                                  		;;cbw
 27197                                  		;;shl	ax,1
 27198                                  		;;shl	ax,1
 27199                                  		;;add	ax,[ddp_i]
 27200                                  		;shl	al,1
 27201                                  		;shl	al,1
 27202                                  		;add	al,[ddp_i]
 27203                                  		;;mul	cx
 27204                                  		;mul	cl
 27205                                  		;;mov	bx,ax
 27206                                  		
 27207                                  		;mov	al,[part_table_sys_id+bx]
 27208                                  		;cmp	byte [part_table_sys_id+bx],5 ; EXTENTED
 27209 00003BE6 3C05                    		cmp	al,5
 27210 00003BE8 7504                    		jne	short ddp_3 
 27211 00003BEA C646FC01                		mov	byte [ddp_ext],1 ;  TRUE
 27212                                  ddp_3:
 27213 00003BEE FE46EC                  		inc	byte [ddp_i]
 27214                                  ;ddp_4:
 27215 00003BF1 807EEC04                		cmp	byte [ddp_i],4
 27216 00003BF5 732C                    		jnb	short ddp_6
 27217                                  ddp_4:
 27218 00003BF7 A0[E2CB]                		mov	al,[cur_disk]
 27219                                  		;cbw
 27220                                  		;shl	ax,1
 27221                                  		;shl	ax,1
 27222 00003BFA D0E0                    		shl	al,1
 27223 00003BFC D0E0                    		shl	al,1
 27224                                  		;add	ax,[ddp_i]
 27225 00003BFE 0246EC                  		add	al,[ddp_i]
 27226                                  		;mov	cx,46
 27227                                  		;mul	cx
 27228 00003C01 B12E                    		mov	cl,46
 27229 00003C03 F6E1                    		mul	cl
 27230 00003C05 89C3                    		mov	bx,ax
 27231                                  		
 27232 00003C07 8A87[25C4]              		mov	al,[part_table_sys_id+bx]
 27233                                  		;cmp	byte [part_table_sys_id+bx],0
 27234                                  		;je	short ddp_3
 27235 00003C0B 20C0                    		and	al,al
 27236 00003C0D 74DF                    		jz	short ddp_3
 27237 00003C0F FE46FA                  		inc	byte [ddp_cnt]
 27238                                  		;cmp	byte [part_table_sys_id+bx],1
 27239 00003C12 3C01                    		cmp	al,1
 27240 00003C14 7408                    		je	short ddp_5
 27241                                  		;cmp	byte [part_table_sys_id+bx],4
 27242 00003C16 3C04                    		cmp	al,4
 27243 00003C18 7404                    		je	short ddp_5
 27244                                  		;cmp	byte [part_table_sys_id+bx],6
 27245 00003C1A 3C06                    		cmp	al,6
 27246 00003C1C 75C8                    		jne	short ddp_2
 27247                                  ddp_5:
 27248 00003C1E FE46E8                  		inc	byte [ddp_pri]
 27249 00003C21 EBCB                    		jmp	short ddp_3
 27250                                  ddp_6:
 27251                                  	;/* The partition can be deleted if the the number of normal */
 27252                                  	;/* partitions is greater than one or if there is only one but it is */
 27253                                  	;/* not the first hard disk or if there is only one normal partition */
 27254                                  	;/* on the first hard disk but no extended partition. */
 27255                                  
 27256 00003C23 807EE801                		cmp	byte [ddp_pri],1
 27257 00003C27 7F11                    		jg	short ddp_10
 27258                                  		;jne	short ddp_7
 27259 00003C29 0F858600                		jne	ddp_21
 27260 00003C2D 803E[E2CB]00            		cmp	byte [cur_disk],0
 27261 00003C32 7506                    		jne	short ddp_10
 27262                                  ;ddp_7:
 27263                                  		;cmp	byte [ddp_pri],1
 27264                                  		;;je	short ddp_8
 27265                                  		;;jmp	short ddp_21
 27266                                  		;jne	short ddp_21
 27267                                  ;ddp_8:
 27268                                  		;cmp	byte [cur_disk],0
 27269                                  		;;jne	short ddp_9
 27270                                  		;jne	short ddp_21
 27271 00003C34 807EFC00                		cmp	byte [ddp_ext],0
 27272                                  		;je	short ddp_10
 27273 00003C38 7579                    		jne	short ddp_21
 27274                                  ;ddp_9:
 27275                                  		;jmp	short ddp_21
 27276                                  ddp_10:
 27277                                  		;/* Display partition number prompt */
 27278                                  
 27279                                  		;push	word [menu_55_segment]
 27280 00003C3A 1E                      		push	ds
 27281 00003C3B FF36[3D9E]              		push	word [menu_55_offset]
 27282 00003C3F E8E2D9                  		call	display
 27283                                  		;pop	bx
 27284                                  		;pop	bx
 27285                                  
 27286                                  		;/* Get the partition number from the user */
 27287                                  
 27288 00003C42 FF36[AAA0]              		push	word [input_col]
 27289 00003C46 FF36[4CA1]              		push	word [input_row]
 27290 00003C4A 8A46FA                  		mov	al,[ddp_cnt] ; Maximum input number
 27291 00003C4D 50                      		push	ax
 27292 00003C4E B001                    		mov	al,1	; Default input number	
 27293 00003C50 50                      		push	ax
 27294 00003C51 E820EE                  		call	get_num_input
 27295                                  		;add	sp,8
 27296                                  		;mov	[ddp_input],al
 27297                                  
 27298 00003C54 3C1B                    		cmp	al,1Bh	; ESCape key
 27299 00003C56 7503                    		jne	short ddp_11
 27300 00003C58 E90901                  		jmp	dos_del_break
 27301                                  ddp_11:
 27302                                  		;cbw
 27303                                  		;sub	ax,'0'
 27304 00003C5B 2C30                    		sub	al,'0'
 27305                                  		;mov	[ddp_pnum],ax
 27306 00003C5D 8846FE                  		mov	[ddp_pnum],al
 27307                                  
 27308                                  	;/* The number that the user has entered is the sorted numbering */
 27309                                  	;/* of the partition table. We have to retrieve the actual */
 27310                                  	;/* position of this partition in the partition table */
 27311                                  
 27312 00003C60 C646EA00                		mov	byte [ddp_j],0
 27313 00003C64 C646EC00                		mov	byte [ddp_i],0
 27314 00003C68 B12E                    		mov	cl,46 ; 24/12/2018
 27315 00003C6A EB0B                    		jmp	short ddp_13
 27316                                  ddp_12:
 27317 00003C6C FE46EC                  		inc	byte [ddp_i]
 27318                                  ;ddp_13:
 27319 00003C6F 807EEC04                		cmp	byte [ddp_i],4
 27320                                  		;jnb	short ddp_14
 27321 00003C73 0F83E300                		jnb	ddp_20 ; 24/12/2018 
 27322                                  ddp_13:
 27323 00003C77 A0[E2CB]                		mov	al,[cur_disk]
 27324                                  		;cbw
 27325                                  		;shl	ax,1
 27326                                  		;shl	ax,1
 27327 00003C7A D0E0                    		shl	al,1
 27328 00003C7C D0E0                    		shl	al,1
 27329 00003C7E 8B5EEC                  		mov	bx,[ddp_i]
 27330                                  		;mov	cx,ax
 27331                                  		;mov	al,[sort+bx]
 27332                                  		;cbw
 27333 00003C81 8A97[F0C3]              		mov	dl,[sort+bx]  ; *--*
 27334                                  		;add	ax,cx
 27335 00003C85 00D0                    		add	al,dl
 27336                                  		;mov	cx,46
 27337                                  		;mul	cx
 27338                                  		;mov	cl,46
 27339 00003C87 F6E1                    		mul	cl
 27340 00003C89 89C3                    		mov	bx,ax
 27341                                  
 27342 00003C8B 80BF[25C4]00            		cmp	byte [part_table_sys_id+bx],0
 27343 00003C90 74DA                    		je	short ddp_12
 27344                                  		;mov	ax,[ddp_pnum]
 27345 00003C92 8A46FE                  		mov	al,[ddp_pnum]
 27346 00003C95 FE46EA                  		inc	byte [ddp_j]
 27347                                  		;cmp	[ddp_j],ax
 27348 00003C98 3846EA                  		cmp	[ddp_j],al
 27349 00003C9B 75CF                    		jne	short ddp_12
 27350                                  ;ddp_14:
 27351                                  		;mov	al,[cur_disk]
 27352                                  		;;cbw
 27353                                  		;;shl	ax,1
 27354                                  		;;shl	ax,1
 27355                                  		;shl	al,1
 27356                                  		;shl	al,1
 27357                                  		;mov	bx,[ddp_i]
 27358                                  		;;mov	cx,ax
 27359                                  		;;mov	al,[sort+bx]
 27360                                  		;;cbw
 27361                                  		;;mov	[ddp_i],ax
 27362                                  		;;add	ax,cx
 27363                                  		;mov	dl,[sort+bx]
 27364                                  		;add	al,dl
 27365                                  		;;mov	cx,46
 27366                                  		;;mul	cx
 27367                                  		;mov	cl,46
 27368                                  		;mul	cl
 27369                                  		;mov	bx,ax
 27370                                  		
 27371                                  		; i = sort[i]
 27372 00003C9D 8856EC                  		mov	[ddp_i],dl ; *--*
 27373                                  
 27374                                  		;/* Verify selected partition is a primary partition */
 27375                                  
 27376 00003CA0 8A87[25C4]              		mov	al,[part_table_sys_id+bx]
 27377                                  		;cmp	byte [part_table_sys_id+bx],1
 27378 00003CA4 3C01                    		cmp	al,1 ; DOS12
 27379 00003CA6 7413                    		je	short ddp_15
 27380                                  		;cmp	byte [part_table_sys_id+bx],4
 27381 00003CA8 3C04                    		cmp	al,4 ; DOS16
 27382 00003CAA 740F                    		je	short ddp_15
 27383                                  		;cmp	byte [part_table_sys_id+bx],6
 27384 00003CAC 3C06                    		cmp	al,6 ; DOSNEW
 27385 00003CAE 740B                    		je	short ddp_15
 27386 00003CB0 E9A700                  		jmp	ddp_20
 27387                                  ddp_21:
 27388                                  		;/* Tell user he can't do it while extended exists on drive 1 */
 27389                                  
 27390                                  		;push	word [error_32_seg]
 27391 00003CB3 1E                      		push	ds
 27392 00003CB4 FF36[BE9E]              		push	word [error_32_off]
 27393 00003CB8 E99000                  		jmp	ddp_18
 27394                                  ddp_15:
 27395                                  		;/* delete privious volume mismatch message */
 27396                                  
 27397 00003CBB C646EE00                		mov	byte [ddp_str_input],0
 27398                                  
 27399                                  		;/* Get input volume label */
 27400                                  
 27401                                  		;push	word [menu_41_segment]
 27402 00003CBF 1E                      		push	ds
 27403 00003CC0 FF36[4B9E]              		push	word [menu_41_offset]
 27404 00003CC4 E85DD9                  		call	display
 27405                                  		;pop	bx
 27406                                  		;pop	bx
 27407                                  		
 27408 00003CC7 8D46EE                  		lea	ax,[ddp_str_input]
 27409 00003CCA 16                      		push	ss
 27410 00003CCB 50                      		push	ax
 27411 00003CCC FF36[AAA0]              		push	word [input_col]
 27412 00003CD0 FF36[4CA1]              		push	word [input_row]
 27413 00003CD4 E8CC06                  		call	get_string_input
 27414                                  		;add	sp,8
 27415 00003CD7 807EEE1B                		cmp	byte [ddp_str_input],1Bh ; ESC key
 27416 00003CDB 7503                    		jne	short ddp_16
 27417 00003CDD E98400                  		jmp	dos_del_break
 27418                                  ddp_16:
 27419                                  		;/* See if the volume id matches the drive */
 27420                                  
 27421                                  		;lea	ax,[ddp_str_input]
 27422                                  		;push	ax
 27423                                  	
 27424 00003CE0 8D7EEE                  		lea	di,[ddp_str_input] ; dst
 27425                                  
 27426 00003CE3 A0[E2CB]                		mov	al,[cur_disk]
 27427                                  		;cbw
 27428                                  		;shl	ax,1
 27429                                  		;shl	ax,1
 27430 00003CE6 D0E0                    		shl	al,1
 27431 00003CE8 D0E0                    		shl	al,1
 27432                                  		;add	ax,[ddp_i]
 27433 00003CEA 0246EC                  		add	al,[ddp_i]
 27434                                  		;mov	cx,46
 27435                                  		;mul	cx
 27436 00003CED B12E                    		mov	cl,46
 27437 00003CEF F6E1                    		mul	cl
 27438 00003CF1 89C6                    		mov	si,ax
 27439                                  
 27440                                  		;add	ax,part_table_vol_label
 27441                                  		;push	ax
 27442 00003CF3 81C6[38C4]              		add	si,part_table_vol_label ; src
 27443                                  
 27444 00003CF7 E89406                  		call	strcmp
 27445                                  		;pop	bx
 27446                                  		;pop	bx
 27447 00003CFA 09C0                    		or	ax,ax
 27448 00003CFC 7555                    		jnz	short ddp_19
 27449                                  		
 27450                                  		;/* Display Y/N prompt */
 27451                                  
 27452                                  		;push	word [menu_34_segment]
 27453 00003CFE 1E                      		push	ds
 27454 00003CFF FF36[499E]              		push	word [menu_34_offset]
 27455 00003D03 E81ED9                  		call	display
 27456                                  		;pop	bx
 27457                                  		;pop	bx
 27458                                  
 27459                                  		;/* Get yes/no prompt */
 27460                                  
 27461 00003D06 FF36[AAA0]              		push	word [input_col]
 27462 00003D0A FF36[4CA1]              		push	word [input_row]
 27463 00003D0E A0[ACA0]                		mov	al,[No] ; 'N'	; Default input value/char
 27464 00003D11 50                      		push	ax
 27465 00003D12 E839F3                  		call	get_yn_input	; Get YES ('Y'), NO ('N') input
 27466                                  		;add	sp,6
 27467                                  ddp_17:
 27468                                  		;mov	[ddp_input],al  ; 1 = Yes, 0 = No
 27469                                  		;cbw
 27470                                  		;cmp	ax,1Bh  ; ESC key
 27471 00003D15 3C1B                    		cmp	al,1Bh
 27472 00003D17 744B                    		je	short dos_del_break
 27473 00003D19 7746                    		ja	short case_dos_del_DEF
 27474 00003D1B 08C0                    		or	al,al
 27475 00003D1D 7445                    		jz	short dos_del_break ; 'N'
 27476 00003D1F FEC8                    		dec	al
 27477 00003D21 753E                    		jnz	short case_dos_del_DEF ; neither 'Y' or 'N'
 27478                                  		; 'Y'
 27479                                  case_dos_del_1:
 27480                                  		;/* Set Partition entry to zero */
 27481                                  
 27482                                  		;push	word [ddp_i]
 27483                                  		; 02/01/2019
 27484 00003D23 8A66EC                  		mov	ah,[ddp_i] ; Partition entry number
 27485 00003D26 A0[E2CB]                		mov	al,[cur_disk]
 27486                                  		;push	ax
 27487 00003D29 E83C0A                  		call	remove_partition
 27488                                  		;pop	bx
 27489                                  		;pop	bx
 27490                                  
 27491                                  		;/* Redisplay the partition info */
 27492                                  
 27493 00003D2C E848F1                  		call	table_display
 27494                                  		
 27495                                  		;/* clear the prompt off */
 27496                                  
 27497 00003D2F B84F00                  		mov	ax,79
 27498 00003D32 50                      		push	ax
 27499 00003D33 B81700                  		mov	ax,23
 27500 00003D36 50                      		push	ax
 27501 00003D37 29C0                    		sub	ax,ax
 27502 00003D39 50                      		push	ax
 27503 00003D3A B81000                  		mov	ax,16
 27504 00003D3D 50                      		push	ax
 27505 00003D3E E855D7                  		call	clear_screen
 27506                                  		;add	sp,8
 27507                                  
 27508                                  		;/* Set the reboot flag */
 27509                                  
 27510 00003D41 C606[78A0]01            		mov	byte [reboot_flag],1  ; TRUE
 27511                                  
 27512                                  		;/* Say that you deleted it */
 27513                                  
 27514                                  		;push	word [status_1_seg]
 27515 00003D46 1E                      		push	ds
 27516 00003D47 FF36[6B9E]              		push	word [status_1_off]
 27517                                  ddp_18:
 27518 00003D4B E8D6D8                  		call	display
 27519                                  		;pop	bx
 27520                                  		;pop	bx
 27521 00003D4E E823F4                  		call	wait_for_ESC
 27522 00003D51 EB11                    		jmp	short dos_del_break
 27523                                  ddp_19:
 27524                                  		;/* Tell user volume name was incorrect */
 27525                                  
 27526                                  		;push	word [error_34_seg]
 27527 00003D53 1E                      		push	ds
 27528 00003D54 FF36[C29E]              		push	word [error_34_off]
 27529 00003D58 EBF1                    		jmp	short ddp_18
 27530                                  ddp_20:
 27531                                  		;/* Tell user he can only delete primary partition */
 27532                                  	
 27533                                  		;push	word [error_37_seg]
 27534 00003D5A 1E                      		push	ds
 27535 00003D5B FF36[C89E]              		push	word [error_37_off]
 27536 00003D5F EBEA                    		jmp	short ddp_18
 27537                                  ;ddp_21:
 27538                                  ;		;push	word [error_32_seg]
 27539                                  ;		push	ds
 27540                                  ;		push	word [error_32_off]
 27541                                  ;		jmp	short ddp_18
 27542                                  case_dos_del_DEF:
 27543 00003D61 E8B7F5                  		call	internal_program_error
 27544                                  dos_del_break:
 27545                                  		;mov	ax,79
 27546                                  		;push	ax
 27547                                  		;mov	ax,24
 27548                                  		;push	ax
 27549                                  		;sub	ax,ax
 27550                                  		;push	ax
 27551                                  		;push	ax
 27552                                  		;call	clear_screen
 27553                                  
 27554 00003D64 E8F7D6                  		call	CLS
 27555                                  
 27556 00003D67 89EC                    		mov	sp,bp
 27557 00003D69 5D                      		pop	bp
 27558 00003D6A C3                      		retn
 27559                                  
 27560                                  sprintf_total_mbytes:
 27561                                  		; 24/12/2018
 27562                                  
 27563                                  		;mov	al,[cur_disk]
 27564                                  		;cbw
 27565                                  		;mov	bx,ax
 27566 00003D6B 8A1E[E2CB]              		mov	bl,[cur_disk]
 27567 00003D6F 30FF                    		xor	bh,bh
 27568 00003D71 D1E3                    		shl	bx,1
 27569 00003D73 FFB7[D6A0]              		push	word [total_mbytes+bx]
 27570 00003D77 B8[926F]                		mov	ax,disk_size_format ; "%4.1d"
 27571 00003D7A 50                      		push	ax
 27572 00003D7B B8[F4CC]                		mov	ax,insert
 27573 00003D7E 50                      		push	ax
 27574 00003D7F E843E5                  		call	sprintf
 27575 00003D82 83C406                  		add	sp,6
 27576 00003D85 C3                      		retn
 27577                                  
 27578                                  ; fdisk.msg (MSDOS 6.0)
 27579                                  ;/***************************************************************************************************/
 27580                                  ;/*  Screen for EXT_DELETE                                                                          */
 27581                                  ;/*                                                                                                 */
 27582                                  ;/*     |00000000001111111111222222222233333333334444444444555555555566666666667777777777|          */
 27583                                  ;/*     |01234567890123456789012345678901234567890123456789012345678901234567890123456789|          */
 27584                                  ;/*   --|--------------------------------------------------------------------------------|          */
 27585                                  ;/*   00|                                                                                |          */
 27586                                  ;/*   01|                                                                                |          */
 27587                                  ;/*   02|                                                                                |          */
 27588                                  ;/*   03|                                                                                |          */
 27589                                  ;/*   04|                           Delete Extended DOS Partition                        |menu_30   */
 27590                                  ;/*   05|                                                                                |          */
 27591                                  ;/*   06|    Current fixed disk drive: #                                                 |menu_5 #  */
 27592                                  ;/*   07|                                                                                |          */
 27593                                  ;/*   08|    Partition Status   Type    Size in Mbytes   Percentage of Disk Used         |menu_14 # */
 27594                                  ;/*   09|     ## #        #   #######       ####         ###%                            |menu_14 # */
 27595                                  ;/*   10|     ## #        #   #######       ####         ###%                            |          */
 27596                                  ;/*   11|     ## #        #   #######       ####         ###%                            |          */
 27597                                  ;/*   12|     ## #        #   #######       ####         ###%                            |          */
 27598                                  ;/*   13|                                                                                |          */
 27599                                  ;/*   14|    Total disk space is #### Mbytes (1 Mbyte = 1048576 bytes)                   |menu_15 # */
 27600                                  ;/*   15|                                                                                |          */
 27601                                  ;/*   16|    Warning! Data in the deleted Extended DOS partition will be lost.           |menu_31   */
 27602                                  ;/*   17|    Do you wish to continue (Y/N).................? [N]                         |menu_31   */
 27603                                  ;/*   18|                                                                                |          */
 27604                                  ;/*   19|                                                                                |          */
 27605                                  ;/*   20|                                                                                |          */
 27606                                  ;/*   21|                                                                                |          */
 27607                                  ;/*   22|                                                                                |          */
 27608                                  ;/*   23|                                                                                |          */
 27609                                  ;/*   24|    Press ESC to return to FDISK Options                                        |menu_11   */
 27610                                  ;/*   ------------------------------------------------------------------------------------          */ 
 27611                                  ;/*                                                                                                 */
 27612                                  ;/***************************************************************************************************/
 27613                                  
 27614                                  ; d_menus.c (MSDOS 6.0)
 27615                                  ;/*  */
 27616                                  ;/******************* START OF SPECIFICATIONS *******************/
 27617                                  ;/*                                                             */
 27618                                  ;/* SUBROUTINE NAME: EXT_DELETE                                 */
 27619                                  ;/*                                                             */
 27620                                  ;/* DESCRIPTIVE NAME: Delete EXTENDED DOS partition             */
 27621                                  ;/*                                                             */
 27622                                  ;/* FUNCTION: Delete the EXTENDED DOS partition. Prompt with    */
 27623                                  ;/*           warning first. Default entry on prompt is (N)     */
 27624                                  ;/*                                                             */
 27625                                  ;/* NOTES: Screen can be exited via the ESC command before      */
 27626                                  ;/*        partition is deleted and nothing will change         */
 27627                                  ;/*                                                             */
 27628                                  ;/*        The following screen is managed                      */
 27629                                  ;/*                                                             */
 27630                                  ;/*     |0000000000111111111122222222223333333333|              */
 27631                                  ;/*     |0123456789012345678901234567890123456789|              */
 27632                                  ;/*   --|----------------------------------------|              */
 27633                                  ;/*   00|                                        |              */
 27634                                  ;/*   01|                                        |              */
 27635                                  ;/*   02|                                        |              */
 27636                                  ;/*   03|                                        |              */
 27637                                  ;/*   04|Delete EXTENDED DOS Partition           |              */
 27638                                  ;/*   05|                                        |              */
 27639                                  ;/*   06|Current Fixed Disk Drive: #             |              */
 27640                                  ;/*   07|                                        |              */
 27641                                  ;/*   08|Partition Status   Type  Start  End Size|              */
 27642                                  ;/*   09|    #        #   #######  #### #### ####|              */
 27643                                  ;/*   10|                                        |              */
 27644                                  ;/*   11|                                        |              */
 27645                                  ;/*   12|                                        |              */
 27646                                  ;/*   13|                                        |              */
 27647                                  ;/*   14|Total disk space is #### cylinders.     |              */
 27648                                  ;/*   15|                                        |              */
 27649                                  ;/*   16|                                        |              */
 27650                                  ;/*   17|                                        |              */
 27651                                  ;/*   18|Warning! Data in the EXTENDED DOS       |              */
 27652                                  ;/*   19|partition will be lost. Do you wish     |              */
 27653                                  ;/*   20|to continue.......................? [N] |              */
 27654                                  ;/*   21|                                        |              */
 27655                                  ;/*   22|                                        |              */
 27656                                  ;/*   23|Press ESC to return to FDISK Options    |              */
 27657                                  ;/*   --------------------------------------------              */
 27658                                  ;/*                                                             */
 27659                                  ;/* ENTRY POINTS: Ext_Delete                                    */
 27660                                  ;/*      LINKAGE: ext_delete ()                                 */
 27661                                  ;/*          NEAR CALL                                          */
 27662                                  ;/*                                                             */
 27663                                  ;/* INPUT: None                                                 */
 27664                                  ;/*                                                             */
 27665                                  ;/* EXIT-NORMAL: ERROR=FALSE                                    */
 27666                                  ;/*                                                             */
 27667                                  ;/* EXIT-ERROR: ERROR=TRUE                                      */
 27668                                  ;/*             GOTO internal_program_error if invalid input    */
 27669                                  ;/*             returned to this routine                        */
 27670                                  ;/*                                                             */
 27671                                  ;/* EFFECTS: No data directly modified by this routine, but     */
 27672                                  ;/*          child routines will modify data.                   */
 27673                                  ;/*                                                             */
 27674                                  ;/* INTERNAL REFERENCES:                                        */
 27675                                  ;/*   ROUTINES:                                                 */
 27676                                  ;/*      table_display                                          */
 27677                                  ;/*      clear_screen                                           */
 27678                                  ;/*      wait_for_ESC                                           */
 27679                                  ;/*      get_yn_input                                           */
 27680                                  ;/*      display                                                */
 27681                                  ;/*      Write_Boot_Record                                      */
 27682                                  ;/*      Internal_Program_Error                                 */
 27683                                  ;/*      Find_Free_Space                                        */
 27684                                  ;/*                                                             */
 27685                                  ;/* EXTERNAL REFERENCES:                                        */
 27686                                  ;/*   ROUTINES:                                                 */
 27687                                  ;/*                                                             */
 27688                                  ;/******************** END OF SPECIFICATIONS ********************/
 27689                                  
 27690                                  ;/*  */
 27691                                  ;void ext_delete()
 27692                                  ;
 27693                                  ;BEGIN
 27694                                  ;
 27695                                  ;    char   input;
 27696                                  ;    unsigned i;
 27697                                  ;
 27698                                  ;    input = c(NUL);
 27699                                  ;    /* Clear the screen */
 27700                                  ;    clear_screen(u(0),u(0),u(24),u(79));
 27701                                  ;
 27702                                  ;    /* Display header */
 27703                                  ;    display(menu_30);
 27704                                  ;
 27705                                  ;    /* Setup and print current disk */
 27706                                  ;    insert[0] = cur_disk+1+'0';
 27707                                  ;    display(menu_5);
 27708                                  ;
 27709                                  ;    /* print ESC prompt */
 27710                                  ;    display(menu_11);
 27711                                  ;
 27712                                  ;    /* Display partition data and double check if partition exists*/
 27713                                  ;    table_display();
 27714                                  ;    sprintf(insert,"%4.0d",total_mbytes[cur_disk]);
 27715                                  ;    display(menu_15);
 27716                                  ;
 27717                                  ;       BEGIN
 27718                                  ;        /* See if there are still volumes */
 27719                                  ;        if (!find_logical_drive())
 27720                                  ;           BEGIN
 27721                                  ;            /* Display Y/N prompt */
 27722                                  ;            display(menu_31);
 27723                                  ;
 27724                                  ;            /* Get yes/no prompt */
 27725                                  ;            input = get_yn_input(c(No),input_row,input_col);
 27726                                  ;            switch(input)
 27727                                  ;               BEGIN
 27728                                  ;                case 1:
 27729                                  ;                   BEGIN
 27730                                  ;                    for (i=u(0); i < u(4); i++)
 27731                                  ;                    /* Note: This will delete all occurances of EXTENDED DOS partitions found */
 27732                                  ;                       BEGIN
 27733                                  ;                        if (part_table[cur_disk][i].sys_id == uc(EXTENDED))
 27734                                  ;                           BEGIN
 27735                                  ;                            /* Set Partition entry to zero */
 27736                                  ;                            remove_partition(cur_disk,i);
 27737                                  ;
 27738                                  ;                            /* Redisplay the partition info */
 27739                                  ;                            table_display();
 27740                                  ;
 27741                                  ;                            /* clear the prompt off */
 27742                                  ;                            clear_screen(u(17),u(0),u(23),u(79));
 27743                                  ;
 27744                                  ;                            /* Say that you deleted it */
 27745                                  ;                            display(status_2);
 27746                                  ;
 27747                                  ;                            /* Set the reboot flag */
 27748                                  ;                            reboot_flag = (FLAG)TRUE;
 27749                                  ;                           END
 27750                                  ;                       END
 27751                                  ;                    wait_for_ESC();
 27752                                  ;                    break;
 27753                                  ;                   END
 27754                                  ;
 27755                                  ;                case 0:
 27756                                  ;                    break;
 27757                                  ;
 27758                                  ;                case ESC:
 27759                                  ;
 27760                                  ;                     break;
 27761                                  ;
 27762                                  ;                default:
 27763                                  ;                     internal_program_error();
 27764                                  ;                     break;
 27765                                  ;               END
 27766                                  ;           END
 27767                                  ;        else
 27768                                  ;           BEGIN
 27769                                  ;            /* Logical drives still exist, can't delete partition */
 27770                                  ;            display(error_21);
 27771                                  ;            wait_for_ESC();
 27772                                  ;           END
 27773                                  ;       END
 27774                                  ;    clear_screen(u(0),u(0),u(24),u(79));
 27775                                  ;    return;
 27776                                  ;END
 27777                                  
 27778                                  ext_delete:
 27779                                  		; 24/12/2018
 27780                                  
 27781                                  	;%define ed_i	bp-2 ;bp-4
 27782                                  
 27783 00003D86 55                      		push	bp
 27784                                  		;mov	bp,sp
 27785                                  		;;sub	sp,4
 27786                                  		;sub	sp,2
 27787                                  
 27788                                  		;/* Clear the screen */
 27789                                  
 27790                                  		;mov	ax,79
 27791                                  		;push	ax
 27792                                  		;mov	ax,24
 27793                                  		;push	ax
 27794                                  		;sub	ax,ax
 27795                                  		;push	ax
 27796                                  		;push	ax
 27797                                  		;call	clear_screen
 27798                                  		;add	sp,8
 27799                                  
 27800 00003D87 E8D4D6                  		call	CLS
 27801                                  
 27802                                  		;/* Display header */
 27803                                  
 27804                                  		;push	word [menu_30_segment]
 27805 00003D8A 1E                      		push	ds
 27806 00003D8B FF36[419E]              		push	word [menu_30_offset]
 27807 00003D8F E892D8                  		call	display
 27808                                  		;pop	bx
 27809                                  		;pop	bx
 27810                                  
 27811                                  		;/* Setup and print current disk */
 27812                                  
 27813                                  		;mov	al,[cur_disk]
 27814                                  		;add	al,'1'
 27815                                  		;mov	[insert],al
 27816                                  		;;push	word [menu_5_segment]
 27817                                  		;push	ds
 27818                                  		;push	word [menu_5_offset]
 27819                                  		;call	display
 27820                                  		;;pop	bx
 27821                                  		;;pop	bx
 27822                                  
 27823 00003D92 E8C8F0                  		call	display_menu_5 ; 31/12/2018
 27824                                  
 27825                                  		;/* print ESC prompt */
 27826                                  
 27827                                  		;;push	word [menu_11_segment]
 27828                                  		;push	ds
 27829                                  		;push	word [menu_11_offset]
 27830                                  		;call	display
 27831                                  		;;pop	bx
 27832                                  		;;pop	bx
 27833                                  
 27834 00003D95 E8D6F0                  		call	display_menu_11 ; 31/12/2018
 27835                                  
 27836                                  	;/* Display partition data and double check if partition exists*/
 27837                                  		
 27838 00003D98 E8DCF0                  		call	table_display
 27839                                  		
 27840                                  		;;mov	al,[cur_disk]
 27841                                  		;;cbw
 27842                                  		;;mov	bx,ax
 27843                                  		;mov	bl,[cur_disk]
 27844                                  		;xor	bh,bh
 27845                                  		;shl	bx,1
 27846                                  		;push	word [total_mbytes+bx]
 27847                                  		;mov	ax,disk_size_format ; "%4.1d"
 27848                                  		;push	ax
 27849                                  		;mov	ax,insert
 27850                                  		;push	ax
 27851                                  		;call	sprintf
 27852                                  		;add	sp,6
 27853                                  
 27854 00003D9B E8CDFF                  		call	sprintf_total_mbytes ; 24/12/2018
 27855                                  		
 27856                                  		;push	word [menu_15_segment]
 27857 00003D9E 1E                      		push	ds
 27858 00003D9F FF36[139E]              		push	word [menu_15_offset]
 27859 00003DA3 E87ED8                  		call	display
 27860                                  		;pop	bx
 27861                                  		;pop	bx
 27862                                  
 27863                                  		;/* See if there are still volumes */
 27864                                  
 27865 00003DA6 E87DF2                  		call	find_logical_drive
 27866                                  		;or	al,al
 27867                                  		;jz	short ed_1
 27868 00003DA9 720A                    		jc	short ed_1
 27869                                  		;jmp	ed_7
 27870                                  ;ed_7:
 27871                                  	;/* Logical drives still exist, can't delete partition */
 27872                                  
 27873                                  		;push	word [error_21_seg]
 27874 00003DAB 1E                      		push	ds
 27875 00003DAC FF36[A89E]              		push	word [error_21_off]
 27876 00003DB0 E871D8                  		call	display
 27877                                  		;pop	bx
 27878                                  		;pop	bx
 27879 00003DB3 EB75                    		jmp	short ed_8
 27880                                  ed_1:
 27881                                  		;/* Display Y/N prompt */
 27882                                  
 27883                                  		;push	word [menu_31_segment]
 27884 00003DB5 1E                      		push	ds
 27885 00003DB6 FF36[439E]              		push	word [menu_31_offset]
 27886 00003DBA E867D8                  		call	display
 27887                                  		;pop	bx
 27888                                  		;pop	bx
 27889                                  		
 27890                                  		;/* Get yes/no prompt */
 27891                                  
 27892 00003DBD FF36[AAA0]              		push	word [input_col]
 27893 00003DC1 FF36[4CA1]              		push	word [input_row]
 27894 00003DC5 A0[ACA0]                		mov	al,[No] ; 'N' ; Default input
 27895 00003DC8 50                      		push	ax
 27896 00003DC9 E882F2                  		call	get_yn_input
 27897                                  		;add	sp,6
 27898                                  switch_input4:
 27899                                  		;cbw
 27900                                  		;cmp	ax,1Bh
 27901 00003DCC 3C1B                    		cmp	al,1Bh ; ESCape key
 27902 00003DCE 745D                    		je	short case_ext_del_break
 27903 00003DD0 7708                    		ja	short ed_3
 27904 00003DD2 08C0                    		or	al,al
 27905 00003DD4 7457                    		jz	short case_ext_del_break  ; 'N'
 27906 00003DD6 FEC8                    		dec	al
 27907 00003DD8 7405                    		jz	short case_ext_del_1 ; 'Y'
 27908                                  ed_3:
 27909 00003DDA E83EF5                  		call	internal_program_error
 27910 00003DDD EB4E                    		jmp	short case_ext_del_break
 27911                                  case_ext_del_1:
 27912                                  		;mov	byte [ed_i],0
 27913 00003DDF 31ED                    		xor	bp,bp ; 01/01/2019
 27914                                  ed_5:
 27915                                  
 27916                                  	;/* Note: This will delete all occurances of EXTENDED DOS partitions found */
 27917                                  
 27918 00003DE1 A0[E2CB]                		mov	al,[cur_disk]
 27919                                  		;cbw
 27920                                  		;shl	ax,1
 27921                                  		;shl	ax,1
 27922 00003DE4 D0E0                    		shl	al,1
 27923 00003DE6 D0E0                    		shl	al,1
 27924                                  		;;add	ax,[ed_i]
 27925                                  		;add	al,[ed_i]
 27926 00003DE8 01E8                    		add	ax,bp ; 01/01/2019
 27927                                  		;mov	cx,46
 27928                                  		;mul	cx
 27929 00003DEA B12E                    		mov	cl,46
 27930 00003DEC F6E1                    		mul	cl
 27931 00003DEE 89C3                    		mov	bx,ax
 27932                                  
 27933 00003DF0 80BF[25C4]05            		cmp	byte [part_table_sys_id+bx],5  ; EXTENDED partition
 27934 00003DF5 752D                    		jne	short ed_6
 27935                                  
 27936                                  		;/* Set Partition entry to zero */
 27937                                  
 27938                                  		;push	word [ed_i]
 27939                                  		;push	bp ; 01/01/2019
 27940 00003DF7 89E8                    		mov	ax,bp ; 02/01/2019
 27941                                  		;mov	al,[cur_disk]
 27942                                  		;push	ax
 27943 00003DF9 8A26[E2CB]              		mov	ah,[cur_disk]
 27944 00003DFD 86C4                    		xchg	al,ah
 27945 00003DFF E86609                  		call	remove_partition
 27946                                  		;pop	bx
 27947                                  		;pop	bx
 27948                                  
 27949                                  		;/* Redisplay the partition info */
 27950                                  
 27951 00003E02 E872F0                  		call	table_display
 27952                                  
 27953                                  		;/* clear the prompt off */
 27954                                  		
 27955 00003E05 B84F00                  		mov	ax,79
 27956 00003E08 50                      		push	ax
 27957 00003E09 B81700                  		mov	ax,23
 27958 00003E0C 50                      		push	ax
 27959 00003E0D 29C0                    		sub	ax,ax
 27960 00003E0F 50                      		push	ax
 27961 00003E10 B81100                  		mov	ax,17
 27962 00003E13 50                      		push	ax
 27963 00003E14 E87FD6                  		call	clear_screen
 27964                                  		;add	sp,8
 27965                                  
 27966                                  		;/* Say that you deleted it */
 27967                                  
 27968                                  		;push	word [status_2_seg]
 27969 00003E17 1E                      		push	ds
 27970 00003E18 FF36[6D9E]              		push	word [status_2_off]
 27971 00003E1C E805D8                  		call	display
 27972                                  		;pop	bx
 27973                                  		;pop	bx
 27974                                  
 27975                                  		;/* Set the reboot flag */
 27976                                  
 27977 00003E1F C606[78A0]01            		mov	byte [reboot_flag],1 ; TRUE
 27978                                  ed_6:
 27979                                  		;inc	byte [ed_i]
 27980 00003E24 45                      		inc	bp ; 01/01/2019
 27981                                  		;cmp	byte [ed_i],4
 27982 00003E25 83FD04                  		cmp	bp,4
 27983 00003E28 72B7                    		jb	short ed_5
 27984                                  		;jmp	short ed_8
 27985                                  ;ed_7:
 27986                                  ;		;push	word [error_21_seg]
 27987                                  ;		push	ds
 27988                                  ;		push	word [error_21_off]
 27989                                  ;		call	display
 27990                                  ;		;pop	bx
 27991                                  ;		;pop	bx
 27992                                  ed_8:
 27993 00003E2A E847F3                  		call	wait_for_ESC
 27994                                  
 27995                                  case_ext_del_break:
 27996                                  		;mov	ax,79
 27997                                  		;push	ax
 27998                                  		;mov	ax,24
 27999                                  		;push	ax
 28000                                  		;sub	ax,ax
 28001                                  		;push	ax
 28002                                  		;push	ax
 28003                                  		;call	clear_screen
 28004                                  
 28005 00003E2D E82ED6                  		call	CLS		
 28006                                  
 28007                                  		;mov	sp,bp
 28008 00003E30 5D                      		pop	bp
 28009 00003E31 C3                      		retn
 28010                                  
 28011                                  ; fdisk.msg (MSDOS 6.0)
 28012                                  ;/******************************************************************************************************/
 28013                                  ;/*  Screen for VOL_DELETE                                                                             */
 28014                                  ;/*                                                                                                    */
 28015                                  ;/*     |00000000001111111111222222222233333333334444444444555555555566666666667777777777|             */
 28016                                  ;/*     |01234567890123456789012345678901234567890123456789012345678901234567890123456789|             */
 28017                                  ;/*   --|--------------------------------------------------------------------------------|             */
 28018                                  ;/*   00|                                                                                |             */
 28019                                  ;/*   01|            Delete Logical DOS Drive(s) in the Extended DOS Partition           |menu_32      */
 28020                                  ;/*   02|                                                                                |             */
 28021                                  ;/*   03|Drv Volume Label  MBytes  System  Usage  Drv Volume Label  MBytes  System  Usage|menu_19/20 # */
 28022                                  ;/*   04|##  #############  ####  ########  ###%  ##  #############  ####  ########  ###%|             */
 28023                                  ;/*   05|##  #############  ####  ########  ###%  ##  #############  ####  ########  ###%|             */
 28024                                  ;/*   06|##  #############  ####  ########  ###%  ##  #############  ####  ########  ###%|             */
 28025                                  ;/*   07|##  #############  ####  ########  ###%  ##  #############  ####  ########  ###%|             */
 28026                                  ;/*   08|##  #############  ####  ########  ###%  ##  #############  ####  ########  ###%|             */
 28027                                  ;/*   09|##  #############  ####  ########  ###%  ##  #############  ####  ########  ###%|             */
 28028                                  ;/*   10|##  #############  ####  ########  ###%  ##  #############  ####  ########  ###%|             */
 28029                                  ;/*   11|##  #############  ####  ########  ###%  ##  #############  ####  ########  ###%|             */
 28030                                  ;/*   12|##  #############  ####  ########  ###%  ##  #############  ####  ########  ###%|             */
 28031                                  ;/*   13|##  #############  ####  ########  ###%  ##  #############  ####  ########  ###%|             */
 28032                                  ;/*   14|##  #############  ####  ########  ###%  ##  #############  ####  ########  ###%|             */
 28033                                  ;/*   15|##  #############  ####  ########  ###%                                         |             */
 28034                                  ;/*   16|                                                                                |             */
 28035                                  ;/*   17|    Total Extended DOS Partition size is #### Mbytes (1 Mbyte = 1048576 bytes)  |menu_21      */
 28036                                  ;/*   18|                                                                                |             */
 28037                                  ;/*   19|    Warning! Data in a deleted Logical DOS Drive will be lost.                  |menu_33      */
 28038                                  ;/*   20|    What drive do you want to delete...........................? [ ]            |menu_33      */
 28039                                  ;/*   21|    Enter Volume Label.............................? [             ]            |menu_41      */
 28040                                  ;/*   22|    Are you sure (Y/N).............................? [N]                        |menu_34      */
 28041                                  ;/*   23|                                                                                |             */
 28042                                  ;/*   24|    Press ESC to return to FDISK Options                                        |menu_11      */
 28043                                  ;/*   ------------------------------------------------------------------------------------             */
 28044                                  ;/*                                                                                                    */
 28045                                  ;/******************************************************************************************************/
 28046                                  
 28047                                  ; d_menus.c (MSDOS 6.0)
 28048                                  ;/*  */
 28049                                  ;/******************* START OF SPECIFICATIONS *******************/
 28050                                  ;/*                                                             */
 28051                                  ;/* SUBROUTINE NAME: VOL_DELETE                                 */
 28052                                  ;/*                                                             */
 28053                                  ;/* DESCRIPTIVE NAME: Delete DOS disk Volume                    */
 28054                                  ;/*                                                             */
 28055                                  ;/* FUNCTION: Prompts user to delete a DOS disk volume          */
 28056                                  ;/*                                                             */
 28057                                  ;/* NOTES: Screen can be exited via the ESC command before      */
 28058                                  ;/*        partition is deleted and nothing will change         */
 28059                                  ;/*                                                             */
 28060                                  ;/*        The following screen is managed                      */
 28061                                  ;/*                                                             */
 28062                                  ;/*     |0000000000111111111122222222223333333333|              */
 28063                                  ;/*     |0123456789012345678901234567890123456789|              */
 28064                                  ;/*   --|----------------------------------------|              */
 28065                                  ;/*   00|Delete DOS Disk Volume                  |              */
 28066                                  ;/*   01|                                        |              */
 28067                                  ;/*   02|Vol Start End  Size                     |              */
 28068                                  ;/*   03| #  ####  #### ####                     |              */
 28069                                  ;/*   04|                                        |              */
 28070                                  ;/*   05|                                        |              */
 28071                                  ;/*   06|                                        |              */
 28072                                  ;/*   07|                                        |              */
 28073                                  ;/*   08|                                        |              */
 28074                                  ;/*   09|                                        |              */
 28075                                  ;/*   10|                                        |              */
 28076                                  ;/*   11|                                        |              */
 28077                                  ;/*   12|                                        |              */
 28078                                  ;/*   13|                                        |              */
 28079                                  ;/*   14|                                        |              */
 28080                                  ;/*   15|                                        |              */
 28081                                  ;/*   16|Total partition size is #### cylinders. |              */
 28082                                  ;/*   17|                                        |              */
 28083                                  ;/*   18|Warning! Data in the DOS disk volume    |              */
 28084                                  ;/*   19|will be lost. What volume do you wish   |              */
 28085                                  ;/*   20|to delete.........................? [#] |              */
 28086                                  ;/*   21|                                        |              */
 28087                                  ;/*   22|Are you sure......................? [N] |              */
 28088                                  ;/*   23|Press ESC to return to FDISK Options    |              */
 28089                                  ;/*   --------------------------------------------              */
 28090                                  ;/*                                                             */
 28091                                  ;/* ENTRY POINTS: Vol_Delete                                    */
 28092                                  ;/*      LINKAGE: vol_delete ()                                 */
 28093                                  ;/*          NEAR CALL                                          */
 28094                                  ;/*                                                             */
 28095                                  ;/* INPUT: None                                                 */
 28096                                  ;/*                                                             */
 28097                                  ;/* EXIT-NORMAL: ERROR=FALSE                                    */
 28098                                  ;/*                                                             */
 28099                                  ;/* EXIT-ERROR: ERROR=TRUE                                      */
 28100                                  ;/*             GOTO internal_program_error if invalid input    */
 28101                                  ;/*             returned to this routine                        */
 28102                                  ;/*                                                             */
 28103                                  ;/* EFFECTS: No data directly modified by this routine, but     */
 28104                                  ;/*          child routines will modify data.                   */
 28105                                  ;/*                                                             */
 28106                                  ;/* INTERNAL REFERENCES:                                        */
 28107                                  ;/*   ROUTINES:                                                 */
 28108                                  ;/*      clear_screen                                           */
 28109                                  ;/*      display                                                */
 28110                                  ;/*      volume_display                                         */
 28111                                  ;/*      get_num_input                                          */
 28112                                  ;/*      wait_for_ESC                                           */
 28113                                  ;/*      get_yn_input                                           */
 28114                                  ;/*      Write_Boot_Record                                      */
 28115                                  ;/*      Find_Free_Space                                        */
 28116                                  ;/*      Internal_Program_Error                                 */
 28117                                  ;/*                                                             */
 28118                                  ;/* EXTERNAL REFERENCES:                                        */
 28119                                  ;/*   ROUTINES:                                                 */
 28120                                  ;/*                                                             */
 28121                                  ;/******************** END OF SPECIFICATIONS ********************/
 28122                                  
 28123                                  ;/*  */
 28124                                  ;void volume_delete()
 28125                                  ;
 28126                                  ;BEGIN
 28127                                  ;
 28128                                  ;    char   input;
 28129                                  ;    char   drive_input;
 28130                                  ;    char   high_drive;
 28131                                  ;    char   low_drive;
 28132                                  ;    char   error_low_drive;
 28133                                  ;    char   error_high_drive;
 28134                                  ;    char   drives_reassigned;
 28135                                  ;    int    list_index;
 28136                                  ;    int    i;
 28137                                  ;    int    j;
 28138                                  ;    int    point;
 28139                                  ;    FLAG   delete_drive;
 28140                                  ;    unsigned char   drive_list[23][2];
 28141                                  ;    int    column;
 28142                                  ;    int    row;
 28143                                  ;    FLAG   drives_exist;
 28144                                  ;    FLAG   vol_matches;
 28145                                  ;    char   temp;
 28146                                  ;    unsigned char drive_temp;
 28147                                  ;    char far *s;
 28148                                  ;    unsigned char   string_input[12];
 28149                                  ;
 28150                                  ;    input = c(NUL);
 28151                                  ;    string_input[0] = uc(NUL);
 28152                                  ;
 28153                                  ;    /* Clear screen */
 28154                                  ;    clear_screen(u(0),u(0),u(24),u(79));
 28155                                  ;
 28156                                  ;    /* Display header */
 28157                                  ;    display(menu_32);
 28158                                  ;
 28159                                  ;    /* print ESC prompt */
 28160                                  ;    display(menu_11);
 28161                                  ;
 28162                                  ;    /* Display logical drives and get the highest drive letter assigned*/
 28163                                  ;    high_drive = volume_display();
 28164                                  ;
 28165                                  ;    /* Get the first avail drive letter to be deleted */
 28166                                  ;    low_drive = (high_drive - get_num_logical_dos_drives()+1);
 28167                                  ;
 28168                                  ;    if (low_drive <= c('Z'))
 28169                                  ;    {
 28170                                  ;    if (high_drive > c('Z'))
 28171                                  ;        high_drive = c('Z');
 28172                                  ;
 28173                                  ;    temp = low_drive;
 28174                                  ;
 28175                                  ;    /* Initialize array of drive letters that exist at this point */
 28176                                  ;    for (i=(int)0; i < (int)23; i++)
 28177                                  ;        BEGIN
 28178                                  ;        /* See if we've exceeded the drive letter range */
 28179                                  ;        if (temp <= high_drive)
 28180                                  ;            BEGIN
 28181                                  ;            /* Put in drive letter */
 28182                                  ;            drive_list[i][0] = ((unsigned char)(temp));
 28183                                  ;            /* Initialize the offsets into the array to something harmless */
 28184                                  ;            drive_list[i][1] = uc(INVALID);
 28185                                  ;            END
 28186                                  ;        else
 28187                                  ;            BEGIN
 28188                                  ;            /* No drive there, put in NUL */
 28189                                  ;            drive_list[i][0] = uc(NUL);
 28190                                  ;            drive_list[i][1] = uc(INVALID);
 28191                                  ;            END
 28192                                  ;
 28193                                  ;        /* Check for next drive */
 28194                                  ;        temp++;
 28195                                  ;        END
 28196                                  ;
 28197                                  ;    /* Set up partition size message */
 28198                                  ;    sprintf(insert,"%4.0d",get_partition_size( uc(EXTENDED) ) );
 28199                                  ;    display(menu_21);
 28200                                  ;
 28201                                  ;    /* Assume no drives deleted */
 28202                                  ;    drives_reassigned = (FLAG)FALSE;
 28203                                  ;
 28204                                  ;    /* Loop until ESC or all deleted */
 28205                                  ;    while (input != c(ESC))
 28206                                  ;        BEGIN
 28207                                  ;
 28208                                  ;        /* Are there any drives left?*/
 28209                                  ;        drives_exist = (FLAG)FALSE;
 28210                                  ;        error_low_drive = ((char)(NUL));
 28211                                  ;        error_high_drive = ((char)(NUL));
 28212                                  ;
 28213                                  ;        for (i=(int)0;i < (int)23; i++)
 28214                                  ;            BEGIN
 28215                                  ;            drive_temp = drive_list[i][0];
 28216                                  ;            if ((drive_temp != uc(NUL)) && (drive_list[i][1] != uc(DELETED)))
 28217                                  ;                BEGIN
 28218                                  ;                drives_exist = (FLAG)TRUE;
 28219                                  ;
 28220                                  ;                /* Find last existing drive letter */
 28221                                  ;                error_high_drive = ((char)(drive_temp));
 28222                                  ;
 28223                                  ;                /* See if we've found the first drive yet */
 28224                                  ;                if (error_low_drive == ((char)(NUL)))
 28225                                  ;                    error_low_drive = ((char)(drive_temp));
 28226                                  ;                END
 28227                                  ;            END
 28228                                  ;
 28229                                  ;        /* If there are drives, go let user try to delete them */
 28230                                  ;        if (drives_exist)
 28231                                  ;            BEGIN
 28232                                  ;
 28233                                  ;            /* Get input until given a correct drive */
 28234                                  ;            valid_input = (FLAG)FALSE;
 28235                                  ;            while ( (!valid_input) && (input != c(ESC)) )
 28236                                  ;                BEGIN
 28237                                  ;
 28238                                  ;                /* Prompt for input */
 28239                                  ;                display(menu_33);
 28240                                  ;
 28241                                  ;                /* Get input between first and highest drive letters */
 28242                                  ;                clear_screen( u(21), u(0), u(21), u(79) );
 28243                                  ;                input = get_alpha_input(low_drive,high_drive,input_row,input_col,error_low_drive,error_high_drive);
 28244                                  ;                drive_input = input;
 28245                                  ;
 28246                                  ;                /* See if it has been deleted already or ESC pressed */
 28247                                  ;                drives_exist = FALSE;
 28248                                  ;                for (i=(int)0;i < (int)23; i++) 
 28249                                  ;                    BEGIN
 28250                                  ;                    if (drive_list[i][0] == ((unsigned char)(drive_input)) &&
 28251                                  ;                       (drive_list[i][1] != ((unsigned char) DELETED)))
 28252                                  ;                        BEGIN
 28253                                  ;                        drives_exist = TRUE;
 28254                                  ;                        list_index = i;
 28255                                  ;                        END
 28256                                  ;                    if (ext_table[cur_disk][i].drive_letter == c(drive_input) )
 28257                                  ;                        point = i;
 28258                                  ;                    END
 28259                                  ;                END
 28260                                  ;
 28261                                  ;            /* Input volume string to confirm delete */
 28262                                  ;            vol_matches = FALSE;
 28263                                  ;            if (input != c(ESC))
 28264                                  ;                BEGIN
 28265                                  ;                if (drives_exist)
 28266                                  ;                    BEGIN
 28267                                  ;                    /* delete privious volume mismatch message */
 28268                                  ;                    string_input[0] = uc(NUL);
 28269                                  ;                    clear_screen( u(22), u(0), u(23), u(79) );
 28270                                  ;                    /* Get input volume label */
 28271                                  ;                    display(menu_41);
 28272                                  ;                    get_string_input(input_row,input_col,string_input);
 28273                                  ;                    if (string_input[0] == uc(ESC)) input = c(ESC);
 28274                                  ;
 28275                                  ;                    /* See if the volume id matches the selected drive */
 28276                                  ;                    if (strcmp(ext_table[cur_disk][point].vol_label,string_input) == (int)ZERO)
 28277                                  ;                           vol_matches = TRUE;
 28278                                  ;                    else if (input != c(ESC)) display(error_34);
 28279                                  ;                    END
 28280                                  ;                 else
 28281                                  ;                    BEGIN
 28282                                  ;                    /* Tell user the drive has already been deleted */
 28283                                  ;                    insert[0] = dos_upper(drive_input);
 28284                                  ;                    insert[1] = c(DRIVE_INDICATOR);
 28285                                  ;                    clear_screen( u(21), u(0), u(22), u(79) );
 28286                                  ;                    display(error_29);
 28287                                  ;                    END
 28288                                  ;                END
 28289                                  ;
 28290                                  ;                /* If it is a valid drive indicate that the input was ok */
 28291                                  ;                if ( (input != c(ESC)) && (drives_exist) && (vol_matches) )
 28292                                  ;                    BEGIN
 28293                                  ;                    valid_input = TRUE;
 28294                                  ;
 28295                                  ;                    /* At this point we have a valid drive letter to delete */
 28296                                  ;
 28297                                  ;                    /* Get the offset into the array for the drive to be deleted */
 28298                                  ;                    delete_drive = find_ext_drive(drive_input - low_drive);
 28299                                  ;
 28300                                  ;                    /* Got a drive letter - prompt are you sure */
 28301                                  ;                    display(menu_34);
 28302                                  ;
 28303                                  ;                    /* Get Y/N input, default is NO */
 28304                                  ;                    input = get_yn_input(c(No),input_row,input_col);
 28305                                  ;
 28306                                  ;                    /* Clear everything out on screen in prompt area */
 28307                                  ;                    clear_screen(u(23),u(0),u(23),u(79));
 28308                                  ;
 28309                                  ;                    /* Go handle the delete */
 28310                                  ;                    switch(input)
 28311                                  ;                        BEGIN
 28312                                  ;                        case 1:
 28313                                  ;                            BEGIN
 28314                                  ;                            /* Go ahead and mark it deleted in list array */
 28315                                  ;
 28316                                  ;                            /* Throw up a flag to indicate we need to delete this one for real later */
 28317                                  ;                            /* This is because if we change the ext_table array now, we lose the ability */
 28318                                  ;                            /* to match up drive letters with locations, or at least it become more */
 28319                                  ;                            /* complicated than I felt like figuring out, so mark it now and do it later */
 28320                                  ;                            drive_list[list_index][1] = (unsigned char)DELETED;
 28321                                  ;
 28322                                  ;                            drives_reassigned = TRUE;
 28323                                  ;
 28324                                  ;                            /* Put prompt up on screen */
 28325                                  ;                            for (i=(int)0; i < (int)23; i++)
 28326                                  ;                                BEGIN
 28327                                  ;                                /* See if drive deleted */
 28328                                  ;                                if (drive_list[i][1] == uc(DELETED))
 28329                                  ;                                    BEGIN
 28330                                  ;                                    /* Wipe out the drive info and print deleted message */
 28331                                  ;                                    /* See what column it is in */
 28332                                  ;                                    if (i < (int)12)
 28333                                  ;                                        BEGIN
 28334                                  ;                                        column = (int)4;
 28335                                  ;                                        row = (int)(4 + i - (int)0);
 28336                                  ;                                        clear_screen( (unsigned)row, (unsigned)column,
 28337                                  ;                                                      (unsigned)row, (unsigned)39 );
 28338                                  ;                                        END
 28339                                  ;                                    else
 28340                                  ;                                        BEGIN
 28341                                  ;                                        column = (int)45;
 28342                                  ;                                        row = (int)(4 + i - (int)12);
 28343                                  ;                                        clear_screen( (unsigned)row, (unsigned)column,
 28344                                  ;                                                      (unsigned)row, (unsigned)79 );
 28345                                  ;                                        END
 28346                                  ;
 28347                                  ;                                    /* Put the start row,col of message in the message string */
 28348                                  ;                                    s=status_3;
 28349                                  ;                                    s++;
 28350                                  ;                                    *s++ = ((char)(row/10))+'0';
 28351                                  ;                                    *s++ = ((char)(row%10))+'0';
 28352                                  ;                                    *s++ = ((char)(column/10))+'0';
 28353                                  ;                                    *s = ((char)(column%10))+'0';
 28354                                  ;                                    display(status_3);
 28355                                  ;                                    END
 28356                                  ;                                END
 28357                                  ;                            /* Set the reboot flag */
 28358                                  ;                            reboot_flag = TRUE;
 28359                                  ;                            clear_screen( u(21), u(0), u(23), u(79) );
 28360                                  ;                            break;
 28361                                  ;                            END
 28362                                  ;
 28363                                  ;                        case ESC:
 28364                                  ;                        case 0:
 28365                                  ;                            clear_screen( u(21), u(0), u(23), u(79) );
 28366                                  ;                            break;
 28367                                  ;
 28368                                  ;                        default:
 28369                                  ;                            internal_program_error();
 28370                                  ;                            break;
 28371                                  ;                        END
 28372                                  ;                    END
 28373                                  ;            END
 28374                                  ;         else     /* drives do not exist! */
 28375                                  ;            BEGIN
 28376                                  ;            /* No more logical drives to delete */
 28377                                  ;            clear_screen(u(16),u(0),u(21),u(79));
 28378                                  ;            display(error_22);
 28379                                  ;            input = wait_for_ESC();
 28380                                  ;            END
 28381                                  ;        END /* while input != esc */
 28382                                  ;
 28383                                  ;    if (drives_reassigned)
 28384                                  ;        BEGIN
 28385                                  ;        /* If anything got deleted, lets go do it for real */
 28386                                  ;        for (i=(int)0; i < (int)23;i++)
 28387                                  ;            BEGIN
 28388                                  ;            if (drive_list[i][1] == uc(DELETED))
 28389                                  ;                BEGIN
 28390                                  ;                for (j=(int)0; j < (int)23;j++)
 28391                                  ;                    BEGIN
 28392                                  ;                    if (drive_list[i][0] == ext_table[cur_disk][j].drive_letter)
 28393                                  ;                        BEGIN
 28394                                  ;                        /* Zero sys id and show it changed */
 28395                                  ;                        remove_volume(cur_disk,i);
 28396                                  ;                        END
 28397                                  ;                    END
 28398                                  ;                END
 28399                                  ;            END
 28400                                  ;
 28401                                  ;        /* Show new drive letters */
 28402                                  ;        volume_display();
 28403                                  ;
 28404                                  ;        /* Say that drive letters changed */
 28405                                  ;        clear_screen(u(16),u(0),u(23),u(79));
 28406                                  ;        display(status_10);
 28407                                  ;        wait_for_ESC();
 28408                                  ;        END
 28409                                  ;    }
 28410                                  ;    else     /* drives do not exist! */
 28411                                  ;    {
 28412                                  ;        /* No more logical drives to delete */
 28413                                  ;        clear_screen(u(16),u(0),u(21),u(79));
 28414                                  ;        display(error_36);
 28415                                  ;        wait_for_ESC();
 28416                                  ;    }
 28417                                  ;    clear_screen(u(0),u(0),u(24),u(79));
 28418                                  ;
 28419                                  ;    return;
 28420                                  ;
 28421                                  ;END
 28422                                  
 28423                                  volume_delete:
 28424                                  		; 04/01/2018
 28425                                  		; 03/01/2019
 28426                                  		; 24/12/2018
 28427                                  
 28428                                  	%define vdel_drv_temp	  bp-92 ;bp-94	;bp-98
 28429                                  	;%define vdel_column	  bp-92	;bp-96
 28430                                  	%define vdel_del_drive	  bp-90	;bp-94
 28431                                  	%define vdel_low_drive	  bp-88	;bp-92
 28432                                  	%define vdel_j		  bp-86	;bp-90
 28433                                  	%define vdel_point	  bp-84	;bp-88
 28434                                  	%define vdel_drive_input  bp-82	;bp-86
 28435                                  	%define vdel_high_drive	  bp-80	;bp-84
 28436                                  	%define vdel_i		  bp-78	;bp-82
 28437                                  	%define vdel_drives_exist bp-76	;bp-80
 28438                                  	%define vdel_row	  bp-74	;bp-78
 28439                                  	;%define vdel_temp	  bp-72	;bp-76
 28440                                  	%define vdel_column	  bp-72	;bp-96
 28441                                  	%define vdel_string_input bp-70	;bp-74
 28442                                  	%define vdel_drive_list	  bp-58	;bp-62
 28443                                  	;%define vdel_drive_list1 bp-57	;bp-61
 28444                                  	%define vdel_vol_matches  bp-12	;bp-16
 28445                                  	%define error_low_drive	  bp-10	;bp-14
 28446                                  	%define vdel_list_index	  bp-8	;bp-12
 28447                                  	;%define vdel_s		        ;bp-10
 28448                                  	%define error_high_drive  bp-6	;bp-6
 28449                                  	%define drives_reassigned bp-4	;bp-4
 28450                                  	%define vdel_input	  bp-2	;bp-2
 28451                                  
 28452 00003E32 55                      		push	bp
 28453 00003E33 89E5                    		mov	bp,sp
 28454                                  		;sub	sp,98
 28455                                  		;sub	sp,94 ; 31/12/2018
 28456 00003E35 83EC5C                  		sub	sp,92 ; 04/01/2019
 28457                                  
 28458                                  		;push	si ;*
 28459                                  
 28460 00003E38 C646FE00                		mov	byte [vdel_input],0
 28461 00003E3C C646BA00                		mov	byte [vdel_string_input],0
 28462                                  
 28463                                  		;/* Clear screen */
 28464                                  		
 28465                                  		;mov	ax,79
 28466                                  		;push	ax
 28467                                  		;mov	ax,24
 28468                                  		;push	ax
 28469                                  		;sub	ax,ax
 28470                                  		;push	ax
 28471                                  		;push	ax
 28472                                  		;call	clear_screen
 28473                                  		;add	sp,8
 28474                                  
 28475 00003E40 E81BD6                  		call	CLS ; 03/01/2019
 28476                                  
 28477                                  		;/* Display header */
 28478                                  
 28479                                  		;push	word [menu_32_segment]
 28480 00003E43 1E                      		push	ds ; 02/01/2019
 28481 00003E44 FF36[459E]              		push	word [menu_32_offset]
 28482 00003E48 E8D9D7                  		call	display
 28483                                  		;pop	bx
 28484                                  		;pop	bx
 28485                                  
 28486                                  		;/* print ESC prompt */
 28487                                  
 28488                                  		;;push	word [menu_11_segment]
 28489                                  		;push	ds
 28490                                  		;push	word [menu_11_offset]
 28491                                  		;call	display
 28492                                  		;;pop	bx
 28493                                  		;;pop	bx
 28494                                  
 28495 00003E4B E820F0                  		call	display_menu_11 ; 31/12/2018
 28496                                  
 28497                                  	;/* Display logical drives and get the highest drive letter assigned */
 28498                                  
 28499 00003E4E E891F3                  		call	volume_display
 28500 00003E51 8846B0                  		mov	[vdel_high_drive],al
 28501                                  
 28502                                  		;/* Get the first avail drive letter to be deleted */
 28503                                  
 28504 00003E54 E8C109                  		call	get_num_logical_dos_drives
 28505 00003E57 2A46B0                  		sub	al,[vdel_high_drive]
 28506 00003E5A F6D8                    		neg	al
 28507 00003E5C FEC0                    		inc	al
 28508 00003E5E 8846A8                  		mov	[vdel_low_drive],al
 28509                                  
 28510 00003E61 3C5A                    		cmp	al,'Z'
 28511 00003E63 7E03                    		jle	short vdel_1
 28512 00003E65 E94503                  		jmp	vdel_47
 28513                                  vdel_1:
 28514 00003E68 807EB05A                		cmp	byte [vdel_high_drive],'Z'
 28515 00003E6C 7E04                    		jle	short vdel_2
 28516 00003E6E C646B05A                		mov	byte [vdel_high_drive],'Z'
 28517                                  vdel_2:
 28518                                  		;mov	al,[vdel_low_drive] ; 31/12/2018
 28519                                  		;mov	[vdel_temp],al ; 03/01/2019
 28520                                  
 28521                                  	;/* Initialize array of drive letters that exist at this point */
 28522                                  
 28523                                  		;mov	word [vdel_i],0
 28524                                  		; 03/01/2019
 28525 00003E72 31F6                    		xor	si,si ; 0
 28526 00003E74 8976B2                  		mov	[vdel_i],si ; 0
 28527 00003E77 EB18                    		jmp	short vdel_5
 28528                                  vdel_3:
 28529                                  		;/* No drive there, put in NUL */
 28530                                  
 28531                                  		;mov	si,[vdel_i] ; 31/12/2018
 28532                                  		;shl	si,1
 28533 00003E79 C642C600                		mov	byte [si+vdel_drive_list],0
 28534                                  vdel_4:
 28535                                  	;/* Initialize the offsets into the array to something harmless */
 28536                                  
 28537 00003E7D C642C7FF                		mov	byte [si+vdel_drive_list+1],0FFh ; INVALID
 28538                                  
 28539                                  		;/* Check for next drive */
 28540                                  
 28541                                  		;inc	byte [vdel_temp] ; 03/01/2019
 28542 00003E81 FEC0                    		inc	al ; 03/01/2019
 28543                                  		
 28544 00003E83 FE46B2                  		inc	byte [vdel_i]
 28545                                  ;vdel_5:
 28546 00003E86 807EB217                		cmp	byte [vdel_i],23
 28547 00003E8A 730F                    		jnb	short vdel_6
 28548                                  
 28549                                  		;/* See if we've exceeded the drive letter range */
 28550                                  
 28551                                  		;mov	al,[vdel_temp] ; 03/01/2019
 28552                                  
 28553                                  		; 31/12/2018
 28554 00003E8C 8B76B2                  		mov	si,[vdel_i]
 28555 00003E8F D1E6                    		shl	si,1
 28556                                  
 28557                                  vdel_5: 	; 03/01/2019
 28558 00003E91 3846B0                  		cmp	[vdel_high_drive],al ; [vdel_temp]
 28559 00003E94 72E3                    		jb	short vdel_3
 28560                                  		
 28561                                  		;/* Put in drive letter */
 28562                                  
 28563                                  		;mov	si,[vdel_i]
 28564                                  		;shl	si,1
 28565                                  
 28566 00003E96 8842C6                  		mov	[si+vdel_drive_list],al
 28567 00003E99 EBE2                    		jmp	short vdel_4
 28568                                  vdel_6:
 28569                                  		;/* Set up partition size message */
 28570                                  
 28571                                  		;mov	al,5
 28572                                  		;;push	ax
 28573                                  		;mov	dh,5
 28574                                  		;call	get_partition_size
 28575                                  		;;pop	bx
 28576                                  		;push	ax
 28577                                  		;mov	ax,ld_p_size_format ; "%4.1d"
 28578                                  		;push	ax
 28579                                  		;mov	ax,insert
 28580                                  		;push	ax
 28581                                  		;call	sprintf
 28582                                  		;add	sp,6
 28583                                  		;	
 28584                                  		;;push	word [menu_21_segment]
 28585                                  		;push	ds
 28586                                  		;push	word [menu_21_offset]
 28587                                  		;call	display
 28588                                  		;;pop	bx
 28589                                  		;;pop	bx
 28590                                  
 28591 00003E9B E827F3                  		call	display_ext_partition_size ; 31/12/2018
 28592                                  
 28593                                  		;/* Assume no drives deleted */
 28594                                  
 28595 00003E9E C646FC00                		mov	byte [drives_reassigned],0 ; FALSE
 28596                                  		;jmp	vdel_39 ; 03/01/2019
 28597                                  
 28598                                  		;/* while input != esc */
 28599                                  vdel_7:		
 28600                                  		;/* Are there any drives left?*/
 28601                                  	
 28602 00003EA2 28C0                    		sub	al,al ; 0
 28603 00003EA4 8846B4                  		mov	[vdel_drives_exist],al ; 0
 28604 00003EA7 8846F6                  		mov	[error_low_drive],al ; 0
 28605 00003EAA 8846FA                  		mov	[error_high_drive],al ; 0
 28606 00003EAD 8846B2                  		mov	[vdel_i],al ; 0
 28607                                  vdel_8:
 28608 00003EB0 8B76B2                  		mov	si,[vdel_i]
 28609 00003EB3 D1E6                    		shl	si,1
 28610 00003EB5 8A42C6                  		mov	al,[si+vdel_drive_list]
 28611 00003EB8 8846A4                  		mov	[vdel_drv_temp],al
 28612                                  
 28613 00003EBB 08C0                    		or	al,al
 28614 00003EBD 7416                    		jz	short vdel_9
 28615 00003EBF 807AC7FE                		cmp	byte [si+vdel_drive_list+1],0FEh ; DELETED
 28616 00003EC3 7410                    		je	short vdel_9
 28617 00003EC5 C646B401                		mov	byte [vdel_drives_exist],1 ; TRUE
 28618                                  
 28619                                  		;/* Find last existing drive letter */
 28620                                  
 28621 00003EC9 8846FA                  		mov	[error_high_drive],al
 28622                                  
 28623                                  		;/* See if we've found the first drive yet */
 28624                                  
 28625 00003ECC 807EF600                		cmp	byte [error_low_drive],0
 28626 00003ED0 7503                    		jne	short vdel_9
 28627 00003ED2 8846F6                  		mov	[error_low_drive],al
 28628                                  vdel_9:
 28629 00003ED5 FE46B2                  		inc	byte [vdel_i]
 28630 00003ED8 807EB217                		cmp	byte [vdel_i],23
 28631 00003EDC 72D2                    		jb	short vdel_8
 28632                                  
 28633                                  		;/* If there are drives, go let user try to delete them */
 28634                                  
 28635 00003EDE 807EB400                		cmp	byte [vdel_drives_exist],0
 28636 00003EE2 7503                    		jne	short vdel_10
 28637 00003EE4 E92B02                  		jmp	vdel_38
 28638                                  
 28639                                  		;/* Get input until given a correct drive */
 28640                                  vdel_10:
 28641 00003EE7 C606[ECCB]00            		mov	byte [valid_input],0
 28642                                  vdel_11:
 28643 00003EEC 807EFE1B                		cmp	byte [vdel_input],1Bh ; ESCape
 28644 00003EF0 7503                    		jne	short vdel_12
 28645 00003EF2 E98900                  		jmp	vdel_16
 28646                                  	
 28647                                  		;/* Prompt for input */
 28648                                  vdel_12:
 28649                                  		;push	word [menu_33_segment]
 28650 00003EF5 1E                      		push	ds
 28651 00003EF6 FF36[479E]              		push	word [menu_33_offset]
 28652 00003EFA E827D7                  		call	display
 28653                                  		;pop	bx
 28654                                  		;pop	bx
 28655                                  
 28656                                  		;/* Get input between first and highest drive letters */
 28657                                  
 28658 00003EFD B84F00                  		mov	ax,79
 28659 00003F00 50                      		push	ax
 28660 00003F01 B81500                  		mov	ax,21
 28661 00003F04 50                      		push	ax
 28662 00003F05 29C9                    		sub	cx,cx
 28663 00003F07 51                      		push	cx
 28664 00003F08 50                      		push	ax
 28665 00003F09 E88AD5                  		call	clear_screen
 28666                                  		;add	sp,8
 28667                                  
 28668 00003F0C 8A46FA                  		mov	al,[error_high_drive]
 28669 00003F0F 50                      		push	ax
 28670 00003F10 8A46F6                  		mov	al,[error_low_drive]
 28671 00003F13 50                      		push	ax
 28672 00003F14 FF36[AAA0]              		push	word [input_col]
 28673 00003F18 FF36[4CA1]              		push	word [input_row]
 28674 00003F1C 8A46B0                  		mov	al,[vdel_high_drive]
 28675 00003F1F 50                      		push	ax
 28676 00003F20 8A46A8                  		mov	al,[vdel_low_drive]
 28677 00003F23 50                      		push	ax
 28678 00003F24 E80607                  		call	get_alpha_input
 28679                                  		;add	sp,12
 28680                                  
 28681 00003F27 8846FE                  		mov	[vdel_input],al
 28682 00003F2A 8846AE                  		mov	[vdel_drive_input],al
 28683                                  		
 28684                                  		;/* See if it has been deleted already or ESC pressed */
 28685                                  
 28686                                  		;mov	byte [vdel_drives_exist],0
 28687                                  		;mov	byte [vdel_i],0
 28688                                  
 28689 00003F2D 30C0                    		xor	al,al ; 0
 28690 00003F2F 8846B4                  		mov	[vdel_drives_exist],al
 28691 00003F32 8846B2                  		mov	[vdel_i],al
 28692                                  vdel_13:
 28693 00003F35 8A46AE                  		mov	al,[vdel_drive_input]
 28694 00003F38 8B76B2                  		mov	si,[vdel_i]
 28695 00003F3B 89F2                    		mov	dx,si ; 03/01/2019
 28696 00003F3D D1E6                    		shl	si,1
 28697 00003F3F 3842C6                  		cmp	[si+vdel_drive_list],al
 28698 00003F42 750D                    		jne	short vdel_14
 28699 00003F44 807AC7FE                		cmp	byte [si+vdel_drive_list+1],0FEh ; DELETED
 28700 00003F48 7407                    		je	short vdel_14
 28701 00003F4A C646B401                		mov	byte [vdel_drives_exist],1 ; TRUE
 28702                                  		;mov	ax,[vdel_i]
 28703                                  		;mov	[vdel_list_index],ax
 28704                                  		;mov	dx,[vdel_i]
 28705 00003F4E 8956F8                  		mov	[vdel_list_index],dx
 28706                                  vdel_14:
 28707 00003F51 B018                    		mov	al,24
 28708                                  		;imul	byte [cur_disk]
 28709 00003F53 F626[E2CB]              		mul	byte [cur_disk]
 28710                                  		;add	ax,[vdel_i]
 28711                                  		;add	al,[vdel_i]
 28712 00003F57 00D0                    		add	al,dl ; 03/01/2019
 28713                                  		;mov	cx,46
 28714                                  		;imul	cx
 28715 00003F59 B12E                    		mov	cl,46
 28716 00003F5B F6E1                    		mul	cl
 28717 00003F5D 89C3                    		mov	bx,ax
 28718 00003F5F 8A46AE                  		mov	al,[vdel_drive_input]
 28719 00003F62 3887[85A1]              		cmp	byte [ext_table_drive_letter+bx],al
 28720 00003F66 7503                    		jne	short vdel_15
 28721                                  		;mov	ax,[vdel_i]
 28722                                  		;mov	[vdel_point],ax
 28723 00003F68 8956AC                  		mov	[vdel_point],dx ; [vdel_i]
 28724                                  vdel_15:
 28725 00003F6B FE46B2                  		inc	byte [vdel_i]
 28726 00003F6E 807EB217                		cmp	byte [vdel_i],23
 28727 00003F72 7CC1                    		jl	short vdel_13
 28728 00003F74 803E[ECCB]00            		cmp	byte [valid_input],0
 28729 00003F79 7503                    		jne	short vdel_16
 28730 00003F7B E96EFF                  		jmp	vdel_11
 28731                                  
 28732                                  		;/* Input volume string to confirm delete */
 28733                                  vdel_16:
 28734 00003F7E C646F400                		mov	byte [vdel_vol_matches],0 ; FALSE
 28735 00003F82 807EFE1B                		cmp	byte [vdel_input],1Bh ; ESC
 28736 00003F86 7503                    		jne	short vdel_17
 28737                                  		;jmp	vdel_22
 28738 00003F88 E9B001                  		jmp	vdel_40 ; 31/12/2018
 28739                                  vdel_17:
 28740 00003F8B 807EB400                		cmp	byte [vdel_drives_exist],0
 28741 00003F8F 7464                    		je	short vdel_20
 28742                                  
 28743                                  		;/* delete previous volume mismatch message */
 28744                                  
 28745 00003F91 C646BA00                		mov	byte [vdel_string_input],0
 28746 00003F95 B84F00                  		mov	ax,79
 28747 00003F98 50                      		push	ax
 28748 00003F99 B81700                  		mov	ax,23
 28749 00003F9C 50                      		push	ax
 28750 00003F9D 29C0                    		sub	ax,ax
 28751 00003F9F 50                      		push	ax
 28752 00003FA0 B81600                  		mov	ax,22
 28753 00003FA3 50                      		push	ax
 28754 00003FA4 E8EFD4                  		call	clear_screen
 28755                                  		;add	sp,8
 28756                                  
 28757                                  		;/* Get input volume label */
 28758                                  
 28759                                  		;push	word [menu_41_segment]
 28760 00003FA7 1E                      		push	ds
 28761 00003FA8 FF36[4B9E]              		push	word [menu_41_offset]
 28762 00003FAC E875D6                  		call	display
 28763                                  		;pop	bx
 28764                                  		;pop	bx
 28765                                  		
 28766 00003FAF 8D46BA                  		lea	ax,[vdel_string_input]
 28767 00003FB2 16                      		push	ss
 28768 00003FB3 50                      		push	ax
 28769 00003FB4 FF36[AAA0]              		push	word [input_col]
 28770 00003FB8 FF36[4CA1]              		push	word [input_row]
 28771 00003FBC E8E403                  		call	get_string_input
 28772                                  		;add	sp,8
 28773 00003FBF 807EBA1B                		cmp	byte [vdel_string_input],1Bh ; ESC
 28774 00003FC3 7503                    		jne	short vdel_18  ; [vdel_drives_exist] > 0
 28775                                  
 28776                                  		;mov	byte [vdel_input],1Bh
 28777                                  		; 31/12/2018 (modification)
 28778 00003FC5 E97301                  		jmp	vdel_40
 28779                                  
 28780                                  		;/* See if the volume id matches the selected drive */
 28781                                  vdel_18:
 28782                                  		;lea	ax,[vdel_string_input]
 28783                                  		;push	ax
 28784                                  
 28785 00003FC8 8D7EBA                  		lea	di,[vdel_string_input] ; dst
 28786                                  
 28787 00003FCB B018                    		mov	al,24
 28788                                  		;imul	byte [cur_disk]
 28789 00003FCD F626[E2CB]              		mul	byte [cur_disk]
 28790                                  		;add	ax,[vdel_point]
 28791 00003FD1 0246AC                  		add	al,[vdel_point]
 28792                                  		;mov	cx,46
 28793                                  		;imul	cx
 28794 00003FD4 B12E                    		mov	cl,46
 28795 00003FD6 F6E1                    		mul	cl
 28796 00003FD8 05[70A1]                		add	ax,ext_table_vol_label
 28797                                  		;push	ax
 28798                                  
 28799 00003FDB 89C6                    		mov	si,ax  ;src
 28800                                  
 28801 00003FDD E8AE03                  		call	strcmp
 28802                                  		;pop	bx
 28803                                  		;pop	bx
 28804 00003FE0 09C0                    		or	ax,ax
 28805 00003FE2 7506                    		jnz	short vdel_19
 28806                                  
 28807 00003FE4 C646F401                		mov	byte [vdel_vol_matches],1
 28808                                  		;jmp	short vdel_22
 28809                                  
 28810                                  		; [vdel_drives_exist] > 0
 28811                                  		;jmp	short vdel_23 ; 31/12/2018
 28812 00003FE8 EB36                    		jmp	short vdel_25
 28813                                  vdel_19:
 28814                                  		;cmp	byte [vdel_input],1Bh
 28815                                  		;je	short vdel_22
 28816                                  
 28817                                  		;push	word [error_34_seg]
 28818 00003FEA 1E                      		push	ds
 28819 00003FEB FF36[C29E]              		push	word [error_34_off]
 28820                                  		;jmp	short vdel_21
 28821                                  
 28822                                  		; 31/12/2018
 28823 00003FEF E832D6                  		call	display
 28824                                  		;pop	bx
 28825                                  		;pop	bx
 28826 00003FF2 E9ADFE                  		jmp	vdel_7
 28827                                  
 28828                                  vdel_20:
 28829                                  		;/* Tell user the drive has already been deleted */
 28830                                  
 28831 00003FF5 8A46AE                  		mov	al,[vdel_drive_input]
 28832                                  		;push	ax
 28833 00003FF8 E83DEC                  		call	dos_upper
 28834                                  		;pop	bx
 28835 00003FFB A2[F4CC]                		mov	[insert],al
 28836 00003FFE C606[F5CC]3A            		mov	byte [insert+1],':' ; 3Ah
 28837                                  		
 28838 00004003 B84F00                  		mov	ax,79
 28839 00004006 50                      		push	ax
 28840 00004007 B81600                  		mov	ax,22
 28841 0000400A 50                      		push	ax
 28842 0000400B 29C0                    		sub	ax,ax
 28843 0000400D 50                      		push	ax
 28844 0000400E B81500                  		mov	ax,21
 28845 00004011 50                      		push	ax
 28846 00004012 E881D4                  		call	clear_screen
 28847                                  		;add	sp,8
 28848                                  
 28849                                  		;push	word [error_29_seg]
 28850 00004015 1E                      		push	ds
 28851 00004016 FF36[B89E]              		push	word [error_29_off]
 28852                                  vdel_21:
 28853 0000401A E807D6                  		call	display
 28854                                  		;pop	bx
 28855                                  		;pop	bx
 28856                                  vdel_22:
 28857                                  		;cmp	[vdel_input],1Bh ; ESC
 28858                                  		;jne	short vdel_23
 28859                                  		
 28860                                  		;;jmp	vdel_39
 28861                                  		;jmp	vdel_40
 28862                                  vdel_23:
 28863                                  		;cmp	[vdel_drives_exist], 0
 28864                                  		;je	short vdel_24
 28865                                  		;cmp	[vdel_vol_matches], 0
 28866                                  		;jne	short vdel_25
 28867                                  vdel_24:
 28868                                  		;jmp	vdel_39
 28869 0000401D E982FE                  		jmp	vdel_7
 28870                                  
 28871                                  	;/* At this point we have a valid drive letter to delete */
 28872                                  
 28873                                  	;/* Get the offset into the array for the drive to be deleted */
 28874                                  vdel_25:
 28875 00004020 C606[ECCB]01            		mov	byte [valid_input],1 ; TRUE
 28876                                  		;mov	al,[vdel_drive_input]
 28877                                  		;sub	al,[vdel_low_drive]
 28878 00004025 8A56AE                  		mov	dl,[vdel_drive_input]
 28879 00004028 2A56A8                  		sub	dl,[vdel_low_drive]
 28880                                  		;push	ax
 28881 0000402B E82A03                  		call	find_ext_drive
 28882                                  		;pop	bx
 28883                                  		;mov	[vdel_del_drive],al
 28884 0000402E 884EA6                  		mov	[vdel_del_drive],cl
 28885                                  
 28886                                  		;/* Got a drive letter - prompt are you sure */
 28887                                  
 28888                                  		;push	word [menu_34_segment]
 28889 00004031 1E                      		push	ds
 28890 00004032 FF36[499E]              		push	word [menu_34_offset]
 28891 00004036 E8EBD5                  		call	display
 28892                                  		;pop	bx
 28893                                  		;pop	bx
 28894                                  
 28895                                  		;/* Get Y/N input, default is NO */
 28896                                  
 28897 00004039 FF36[AAA0]              		push	word [input_col]
 28898 0000403D FF36[4CA1]              		push	word [input_row]
 28899 00004041 A0[ACA0]                		mov	al,[No]
 28900 00004044 50                      		push	ax
 28901 00004045 E806F0                  		call	get_yn_input
 28902                                  		;add	sp,6
 28903 00004048 8846FE                  		mov	[vdel_input],al
 28904                                  	
 28905                                  		;/* Clear everything out on screen in prompt area */
 28906                                  
 28907 0000404B B84F00                  		mov	ax,79
 28908 0000404E 50                      		push	ax
 28909 0000404F B81700                  		mov	ax,23
 28910 00004052 50                      		push	ax
 28911 00004053 29C9                    		sub	cx,cx
 28912 00004055 51                      		push	cx
 28913 00004056 50                      		push	ax
 28914 00004057 E83CD4                  		call	clear_screen
 28915                                  		;add	sp,8
 28916                                  switch_input5:
 28917                                  		;/* Go handle the delete */
 28918                                  
 28919 0000405A 8A46FE                  		mov	al,[vdel_input]
 28920                                  		;cbw
 28921                                  		;cmp	ax,1Bh
 28922 0000405D 3C1B                    		cmp	al,1Bh ; ESC key
 28923 0000405F 7503                    		jne	short vdel_27
 28924 00004061 E99A00                  		jmp	case_vol_del_break ; case ESC
 28925                                  vdel_27:
 28926 00004064 770B                    		ja	short case_vol_del_DEF
 28927 00004066 08C0                    		or	al,al
 28928 00004068 7503                    		jnz	short vdel_28
 28929 0000406A E99100                  		jmp	case_vol_del_break ; Case 0
 28930                                  vdel_28:
 28931 0000406D FEC8                    		dec	al
 28932 0000406F 7406                    		jz	short case_vol_del_1 ; 'Y'
 28933                                  case_vol_del_DEF:
 28934 00004071 E8A7F2                  		call	internal_program_error
 28935                                  		;jmp	vdel_39
 28936 00004074 E92BFE                  		jmp	vdel_7 ; 02/01/2019
 28937                                  
 28938                                  		;/* Go ahead and mark it deleted in list array */
 28939                                  
 28940                                  	;/* Throw up a flag to indicate we need to delete this one for real later */
 28941                                  	;/* This is because if we change the ext_table array now, we lose the ability */
 28942                                  	;/* to match up drive letters with locations, or at least it become more */
 28943                                  	;/* complicated than I felt like figuring out, so mark it now and do it later */
 28944                                  
 28945                                  case_vol_del_1:
 28946 00004077 8B76F8                  		mov	si,[vdel_list_index]
 28947 0000407A D1E6                    		shl	si,1
 28948 0000407C C642C7FE                		mov	byte [si+vdel_drive_list+1],0FEh ; DELETED
 28949 00004080 C646FC01                		mov	byte [drives_reassigned],1 ; TRUE
 28950 00004084 C646B200                		mov	byte [vdel_i],0
 28951 00004088 EB48                    		jmp	short vdel_34
 28952                                  vdel_31:
 28953 0000408A C746B82D00              		mov	word [vdel_column],45
 28954 0000408F 8B46B2                  		mov	ax,[vdel_i]
 28955                                  		;sub	ax,8
 28956 00004092 2C08                    		sub	al,8 ; 12-4 ; 04/01/2019
 28957 00004094 8946B6                  		mov	[vdel_row],ax
 28958 00004097 B94F00                  		mov	cx,79
 28959 0000409A 51                      		push	cx
 28960 0000409B 50                      		push	ax
 28961 0000409C B92D00                  		mov	cx,45
 28962                                  vdel_32:
 28963 0000409F 51                      		push	cx
 28964 000040A0 50                      		push	ax
 28965 000040A1 E8F2D3                  		call	clear_screen
 28966                                  		;add	sp,8
 28967                                  
 28968                                  		;/* Put the start row,col of message in the message string */
 28969                                  
 28970                                  		;mov	ax,[vdel_row]
 28971                                  		;mov	cx,10
 28972                                  		;cwd
 28973                                  		;idiv	cx
 28974                                  		;add	al,'0'
 28975                                  		;les	bx,[status_3_off]
 28976                                  		;inc	bx
 28977                                  		;mov	[vdel_s],bx
 28978                                  		;mov	[vdel_s+2],es
 28979                                  		;mov	[es:bx],al
 28980                                  
 28981                                  		; 26/12/2018
 28982 000040A4 8B1E[6F9E]              		mov	bx,[status_3_off]
 28983 000040A8 43                      		inc	bx
 28984 000040A9 8B46B6                  		mov	ax,[vdel_row]
 28985 000040AC B10A                    		mov	cl,10
 28986 000040AE F6F1                    		div	cl
 28987 000040B0 053030                  		add	ax,'00'
 28988 000040B3 8907                    		mov	[bx],ax
 28989 000040B5 43                      		inc	bx		
 28990                                  
 28991                                  		;mov	ax,[vdel_row]
 28992                                  		;cwd
 28993                                  		;;idiv	cx
 28994                                  		;div	cx
 28995                                  		;add	dl,'0'
 28996                                  		;inc	word [vdel_s]
 28997                                  		;;les	bx,[vdel_s]
 28998                                  		;mov	bx,[vdel_s]
 28999                                  		;;mov	es:[bx],dl
 29000                                  		;mov	[bx],dl
 29001                                  
 29002                                  		;mov	ax,[vdel_column]
 29003                                  		;cwd
 29004                                  		;idiv	cx
 29005                                  		;add	al,'0'
 29006                                  		;inc	bx
 29007                                  		;mov	[vdel_s],bx
 29008                                  		;mov	[vdel_s+2],es
 29009                                  		;mov	[es:bx],al
 29010                                  		
 29011                                  		; 26/12/2018
 29012 000040B6 8B46B8                  		mov	ax,[vdel_column]
 29013 000040B9 F6F1                    		div	cl ; 10
 29014 000040BB 053030                  		add	ax,'00'
 29015 000040BE 43                      		inc	bx
 29016 000040BF 8907                    		mov	[bx],ax
 29017                                  
 29018                                  		;mov	ax,[vdel_column]
 29019                                  		;cwd
 29020                                  		;idiv	cx
 29021                                  		;add	dl,'0'
 29022                                  		;inc	bx
 29023                                  		;mov	[vdel_s],bx
 29024                                  		;mov	[vdel_s+2],es
 29025                                  		;mov	[es:bx],dl
 29026                                  		
 29027                                  		;push	word [status_3_seg]
 29028 000040C1 1E                      		push	ds
 29029 000040C2 FF36[6F9E]              		push	word [status_3_off]
 29030 000040C6 E85BD5                  		call	display
 29031                                  		;pop	bx
 29032                                  		;pop	bx
 29033                                  vdel_33:
 29034 000040C9 FE46B2                  		inc	byte [vdel_i]
 29035                                  
 29036                                  		;/* Put prompt up on screen */
 29037                                  ;vdel_34:
 29038 000040CC 807EB217                		cmp	byte [vdel_i],23
 29039 000040D0 7D27                    		jge	short vdel_36
 29040                                  vdel_34:
 29041 000040D2 8B76B2                  		mov	si,[vdel_i]
 29042 000040D5 D1E6                    		shl	si,1
 29043 000040D7 807AC7FE                		cmp	byte [si+vdel_drive_list+1],0FEh ; DELETED
 29044 000040DB 75EC                    		jne	short vdel_33
 29045                                  
 29046                                  		;/* Wipe out the drive info and print deleted message */
 29047                                  		;/* See what column it is in */
 29048                                  
 29049 000040DD 807EB20C                		cmp	byte [vdel_i],12
 29050                                  		;jl	short vdel_35
 29051                                  		;jmp	short vdel_31
 29052 000040E1 73A7                    		jnb	short vdel_31	
 29053                                  vdel_35:
 29054 000040E3 C746B80400              		mov	word [vdel_column],4
 29055 000040E8 8B46B2                  		mov	ax,[vdel_i]
 29056                                  		;add	ax,4
 29057 000040EB 0404                    		add	al,4
 29058 000040ED 8946B6                  		mov	[vdel_row],ax
 29059 000040F0 B92700                  		mov	cx,39
 29060 000040F3 51                      		push	cx
 29061 000040F4 50                      		push	ax
 29062                                  		;mov	cx,4
 29063 000040F5 B104                    		mov	cl,4
 29064 000040F7 EBA6                    		jmp	short vdel_32
 29065                                  
 29066                                  		;/* Set the reboot flag */
 29067                                  vdel_36:
 29068 000040F9 C606[78A0]01            		mov	byte [reboot_flag],1
 29069                                  
 29070                                  case_vol_del_break:
 29071 000040FE B84F00                  		mov	ax,79
 29072 00004101 50                      		push	ax
 29073 00004102 B81700                  		mov	ax,23
 29074 00004105 50                      		push	ax
 29075 00004106 29C0                    		sub	ax,ax
 29076 00004108 50                      		push	ax
 29077 00004109 B81500                  		mov	ax,21
 29078 0000410C 50                      		push	ax
 29079 0000410D E886D3                  		call	clear_screen
 29080                                  		;add	sp,8
 29081 00004110 EB20                    		jmp	short vdel_39
 29082                                  
 29083                                  		;/* No more logical drives to delete */
 29084                                  vdel_38:
 29085 00004112 B84F00                  		mov	ax,79
 29086 00004115 50                      		push	ax
 29087 00004116 B81500                  		mov	ax,21
 29088 00004119 50                      		push	ax
 29089 0000411A 29C0                    		sub	ax,ax
 29090 0000411C 50                      		push	ax
 29091 0000411D B81000                  		mov	ax,16
 29092 00004120 50                      		push	ax
 29093 00004121 E872D3                  		call	clear_screen
 29094                                  		;add	sp,8
 29095                                  		
 29096                                  		;push	word [error_22_seg]
 29097 00004124 1E                      		push	ds
 29098 00004125 FF36[AA9E]              		push	word [error_22_off]
 29099 00004129 E8F8D4                  		call	display
 29100                                  		;pop	bx
 29101                                  		;pop	bx
 29102                                  
 29103 0000412C E845F0                  		call	wait_for_ESC
 29104 0000412F 8846FE                  		mov	[vdel_input],al
 29105                                  
 29106                                  		;/* Loop until ESC or all deleted */
 29107                                  vdel_39:
 29108 00004132 807EFE1B                		cmp	byte [vdel_input],1Bh  ; ESC
 29109 00004136 7403                    		je	short vdel_40
 29110 00004138 E967FD                  		jmp	vdel_7
 29111                                  vdel_40:
 29112 0000413B 807EFC00                		cmp	byte [drives_reassigned],0
 29113 0000413F 7503                    		jne	short vol_del_for_1
 29114                                  		
 29115                                  		;/* drives do not exist! */		
 29116                                  		
 29117 00004141 E98600                  		jmp	vdel_49
 29118                                  vol_del_for_1:
 29119                                  		;/* If anything got deleted, lets go do it for real */
 29120                                  		
 29121 00004144 C646B200                		mov	byte [vdel_i],0
 29122                                  
 29123                                  vol_del_for_1_next:
 29124 00004148 8B76B2                  		mov	si,[vdel_i]
 29125 0000414B D1E6                    		shl	si,1
 29126 0000414D 807AC7FE                		cmp	byte [si+vdel_drive_list+1],0FEh ; DELETED
 29127 00004151 7535                    		jne	short vol_del_for_1_condition
 29128                                  
 29129                                  vol_del_for_2:
 29130 00004153 C646AA00                		mov	byte [vdel_j],0
 29131                                  vol_del_for_2_next:
 29132 00004157 B018                    		mov	al,24
 29133                                  		;imul	byte [cur_disk]
 29134 00004159 F626[E2CB]              		mul	byte [cur_disk]
 29135                                  		;add	ax,[vdel_j]
 29136 0000415D 0246AA                  		add	al,[vdel_j] ; 04/01/2019
 29137                                  		;mov	cx,46
 29138 00004160 B12E                    		mov	cl,46
 29139                                  		;imul	cx
 29140 00004162 F6E1                    		mul	cl
 29141 00004164 89C3                    		mov	bx,ax
 29142 00004166 8A87[85A1]              		mov	al,[ext_table_drive_letter+bx]
 29143                                  		;cbw
 29144 0000416A 8B76B2                  		mov	si,[vdel_i]
 29145 0000416D D1E6                    		shl	si,1
 29146 0000416F 8A4AC6                  		mov	cl,[si+vdel_drive_list]
 29147                                  		;sub	ch,ch
 29148                                  		;cmp	ax,cx
 29149 00004172 38C8                    		cmp	al,cl
 29150 00004174 7509                    		jne	short vol_del_for_2_condition
 29151                                  		
 29152                                  		;/* Zero sys id and show it changed */
 29153                                  
 29154                                  		;push	word [vdel_i]
 29155 00004176 8A4EB2                  		mov	cl,[vdel_i] ; Partition entry number
 29156 00004179 A0[E2CB]                		mov	al,[cur_disk]
 29157                                  		;push	ax
 29158 0000417C E83F06                  		call	remove_volume
 29159                                  		;pop	bx
 29160                                  		;pop	bx
 29161                                  
 29162                                  vol_del_for_2_condition:
 29163 0000417F FE46AA                  		inc	byte [vdel_j]
 29164                                  
 29165 00004182 807EAA17                		cmp	byte [vdel_j],23
 29166 00004186 7CCF                    		jl	short vol_del_for_2_next
 29167                                  vol_del_for_1_condition:
 29168 00004188 FE46B2                  		inc	byte [vdel_i]
 29169 0000418B 807EB217                		cmp	byte [vdel_i],23
 29170 0000418F 7CB7                    		jl	short vol_del_for_1_next
 29171                                  
 29172                                  		;/* Show new drive letters */
 29173                                  
 29174 00004191 E84EF0                  		call	volume_display
 29175                                  
 29176 00004194 B84F00                  		mov	ax,79
 29177 00004197 50                      		push	ax
 29178 00004198 B81700                  		mov	ax,23
 29179 0000419B 50                      		push	ax
 29180 0000419C 29C0                    		sub	ax,ax
 29181 0000419E 50                      		push	ax
 29182 0000419F B81000                  		mov	ax,16
 29183 000041A2 50                      		push	ax
 29184 000041A3 E8F0D2                  		call	clear_screen
 29185                                  		;add	sp,8
 29186                                  
 29187                                  		;/* Say that drive letters changed */
 29188                                  
 29189                                  		; 04/01/2019
 29190                                  
 29191                                  		;push	word [status_10_seg]
 29192 000041A6 1E                      		push	ds
 29193 000041A7 FF36[7D9E]              		push	word [status_10_off]
 29194 000041AB EB17                    		jmp	short vdel_48
 29195                                  vdel_47:
 29196 000041AD B84F00                  		mov	ax,79
 29197 000041B0 50                      		push	ax
 29198 000041B1 B81500                  		mov	ax,21
 29199 000041B4 50                      		push	ax
 29200 000041B5 29C0                    		sub	ax,ax
 29201 000041B7 50                      		push	ax
 29202 000041B8 B81000                  		mov	ax,16
 29203 000041BB 50                      		push	ax
 29204 000041BC E8D7D2                  		call	clear_screen
 29205                                  		;add	sp,8
 29206                                  
 29207                                  		;push	word [error_36_seg]
 29208 000041BF 1E                      		push	ds
 29209 000041C0 FF36[C69E]              		push	word [error_36_off]
 29210                                  vdel_48:
 29211 000041C4 E85DD4                  		call	display
 29212                                  		;pop	bx
 29213                                  		;pop	bx
 29214                                  		
 29215 000041C7 E8AAEF                  		call	wait_for_ESC
 29216                                  vdel_49:
 29217                                  		;mov	ax,79
 29218                                  		;push	ax
 29219                                  		;mov	ax,24
 29220                                  		;push	ax
 29221                                  		;sub	ax,ax
 29222                                  		;push	ax
 29223                                  		;push	ax
 29224                                  		;call	clear_screen
 29225                                  		;add	sp,8
 29226                                  
 29227 000041CA E891D2                  		call	CLS
 29228                                  
 29229                                  		;pop	si *
 29230                                  
 29231 000041CD 89EC                    		mov	sp,bp
 29232 000041CF 5D                      		pop	bp
 29233 000041D0 C3                      		retn
 29234                                  
 29235                                  ; fdisk.msg (MSDOS 6.0)
 29236                                  ;/***************************************************************************************************/
 29237                                  ;/*  Screen for NON_DOS_DELETE                                                                      */
 29238                                  ;/*                                                                                                 */
 29239                                  ;/*     |00000000001111111111222222222233333333334444444444555555555566666666667777777777|          */
 29240                                  ;/*     |01234567890123456789012345678901234567890123456789012345678901234567890123456789|          */
 29241                                  ;/*   --|--------------------------------------------------------------------------------|          */
 29242                                  ;/*   00|                                                                                |          */
 29243                                  ;/*   01|                                                                                |          */
 29244                                  ;/*   02|                                                                                |          */
 29245                                  ;/*   03|                                                                                |          */
 29246                                  ;/*   04|                            Delete Non-DOS Partition                            |menu_58   */
 29247                                  ;/*   05|                                                                                |          */
 29248                                  ;/*   06|    Current fixed disk drive: #                                                 |menu_5 #  */
 29249                                  ;/*   07|                                                                                |          */
 29250                                  ;/*   08|    Partition Status   Type    Size in Mbytes   Percentage of Disk Used         |menu_14 # */
 29251                                  ;/*   09|     ## #        #   #######       ####         ###%                            |menu_14 # */
 29252                                  ;/*   10|     ## #        #   #######       ####         ###%                            |          */
 29253                                  ;/*   11|     ## #        #   #######       ####         ###%                            |          */
 29254                                  ;/*   12|     ## #        #   #######       ####         ###%                            |          */
 29255                                  ;/*   13|                                                                                |          */
 29256                                  ;/*   14|    Total disk space is #### Mbytes (1 Mbyte = 1048576 bytes)                   |menu_15 # */
 29257                                  ;/*   15|                                                                                |          */
 29258                                  ;/*   16|    Warning! Data in the deleted Non-DOS Partition will be lost.                |menu_59   */
 29259                                  ;/*   17|    What Non-DOS partition do you want to delete..? [ ]                         |          */
 29260                                  ;/*   18|                                                                                |          */
 29261                                  ;/*   19|    Do you wish to continue (Y/N).................? [N]                         |menu_56   */
 29262                                  ;/*   20|                                                                                |          */
 29263                                  ;/*   21|                                                                                |          */
 29264                                  ;/*   22|                                                                                |          */
 29265                                  ;/*   23|                                                                                |          */
 29266                                  ;/*   24|    Press ESC to return to FDISK Options                                        |menu_11   */
 29267                                  ;/*   ------------------------------------------------------------------------------------          */
 29268                                  ;/*                                                                                                 */
 29269                                  ;/***************************************************************************************************/
 29270                                  
 29271                                  ; d_menus.c (MSDOS 6.0)
 29272                                  ;/*  */
 29273                                  ;/******************* START OF SPECIFICATIONS *******************/
 29274                                  ;/*                                                             */
 29275                                  ;/* SUBROUTINE NAME: NON_DOS_DELETE                             */
 29276                                  ;/*                                                             */
 29277                                  ;/* DESCRIPTIVE NAME: Delete Non-DOS partition                  */
 29278                                  ;/*                                                             */
 29279                                  ;/* FUNCTION: Delete the Non-DOS partition. Prompt user with    */
 29280                                  ;/*           warning first. Default entry on prompt is (N)     */
 29281                                  ;/*                                                             */
 29282                                  ;/* NOTES: Screen can be exited via the ESC command before      */
 29283                                  ;/*        partition is deleted and nothing will change         */
 29284                                  ;/*                                                             */
 29285                                  ;/*        The following screen is managed                      */
 29286                                  ;/*                                                             */
 29287                                  ;/*     |0000000000111111111122222222223333333333|              */
 29288                                  ;/*     |0123456789012345678901234567890123456789|              */
 29289                                  ;/*   --|----------------------------------------|              */
 29290                                  ;/*   00|                                        |              */
 29291                                  ;/*   01|                                        |              */
 29292                                  ;/*   02|                                        |              */
 29293                                  ;/*   03|                                        |              */
 29294                                  ;/*   04|Delete Non-DOS Partition                |              */
 29295                                  ;/*   05|                                        |              */
 29296                                  ;/*   06|Current Fixed Disk Drive: #             |              */
 29297                                  ;/*   07|                                        |              */
 29298                                  ;/*   08|Partition Status   Type  Start  End Size|              */
 29299                                  ;/*   09|    #        #   #######  #### #### ####|              */
 29300                                  ;/*   10|                                        |              */
 29301                                  ;/*   11|                                        |              */
 29302                                  ;/*   12|                                        |              */
 29303                                  ;/*   13|                                        |              */
 29304                                  ;/*   14|Total disk space is #### cylinders.     |              */
 29305                                  ;/*   15|                                        |              */
 29306                                  ;/*   16|                                        |              */
 29307                                  ;/*   17|                                        |              */
 29308                                  ;/*   18|Warning! Data in the Non-DOS partition  |              */
 29309                                  ;/*   19|will be lost. Do you wish to            |              */
 29310                                  ;/*   20|continue..........................? [N] |              */
 29311                                  ;/*   21|                                        |              */
 29312                                  ;/*   22|                                        |              */
 29313                                  ;/*   23|Press ESC to return to FDISK Options    |              */
 29314                                  ;/*   --------------------------------------------              */
 29315                                  ;/*                                                             */
 29316                                  ;/* ENTRY POINTS: Non_DOS_Delete                                */
 29317                                  ;/*      LINKAGE: non_dos_delete                                */
 29318                                  ;/*          NEAR CALL                                          */
 29319                                  ;/*                                                             */
 29320                                  ;/* INPUT: None                                                 */
 29321                                  ;/*                                                             */
 29322                                  ;/* EXIT-NORMAL: ERROR=FALSE                                    */
 29323                                  ;/*                                                             */
 29324                                  ;/* EXIT-ERROR: ERROR=TRUE                                      */
 29325                                  ;/*             GOTO internal_program_error if invalid input    */
 29326                                  ;/*             returned to this level                          */
 29327                                  ;/*                                                             */
 29328                                  ;/* EFFECTS: No data directly modified by this routine, but     */
 29329                                  ;/*          child routines will modify data.                   */
 29330                                  ;/*                                                             */
 29331                                  ;/* INTERNAL REFERENCES:                                        */
 29332                                  ;/*   ROUTINES                                                  */
 29333                                  ;/*      table_display                                          */
 29334                                  ;/*      clear_screen                                           */
 29335                                  ;/*      wait_for_ESC                                           */
 29336                                  ;/*      get_yn_input                                           */
 29337                                  ;/*      display                                                */
 29338                                  ;/*      Write_Boot_Record                                      */
 29339                                  ;/*      find_part_free_space                                   */
 29340                                  ;/*                                                             */
 29341                                  ;/* EXTERNAL REFERENCES:                                        */
 29342                                  ;/*   ROUTINES:                                                 */
 29343                                  ;/*                                                             */
 29344                                  ;/******************** END OF SPECIFICATIONS ********************/
 29345                                                                                                     
 29346                                  ;/*  */                                                              
 29347                                  ;void non_dos_delete()                                                
 29348                                  ;                                                                     
 29349                                  ;BEGIN                                                                
 29350                                  ;                                                                     
 29351                                  ;    char input;                                                      
 29352                                  ;    unsigned i;                                                      
 29353                                  ;    int     j;                                                       
 29354                                  ;    int     cnt;                                                     
 29355                                  ;    int     pnum;                                                    
 29356                                  ;                                                                     
 29357                                  ;    input = c(NUL);                                                  
 29358                                  ;    /* clear screen */                                               
 29359                                  ;    clear_screen(u(0),u(0),u(24),u(79));                             
 29360                                  ;                                                                     
 29361                                  ;    /* Display header */                                             
 29362                                  ;    display(menu_58);                                                
 29363                                  ;                                                                     
 29364                                  ;    /* Setup and print current disk */                               
 29365                                  ;    insert[0] = cur_disk+1+'0';                                      
 29366                                  ;    display(menu_5);                                                 
 29367                                  ;                                                                     
 29368                                  ;    /* print ESC prompt */                                           
 29369                                  ;    display(menu_11);                                                
 29370                                  ;                                                                     
 29371                                  ;    /* Display partition data and double check if partition exists*/ 
 29372                                  ;    if (table_display())                                             
 29373                                  ;       BEGIN                                                         
 29374                                  ;                                                                     
 29375                                  ;        sprintf(insert,"%4.0d",total_mbytes[cur_disk]);              
 29376                                  ;        display(menu_15);                                            
 29377                                  ;                                                                     
 29378                                  ;        /* count the number of partitions */                         
 29379                                  ;        cnt = 0;                                                     
 29380                                  ;        for (i = u(0); i < u(4); i++)                                
 29381                                  ;            if (part_table[cur_disk][i].sys_id != uc(0))             
 29382                                  ;                cnt++;                                               
 29383                                  ;                                                                     
 29384                                  ;        /* Display partition number prompt */                        
 29385                                  ;        display(menu_59);                                            
 29386                                  ;                                                                     
 29387                                  ;        /* Get the partition number from the user */                 
 29388                                  ;        input = get_num_input(c(1),c(cnt),input_row,input_col);      
 29389                                  ;                                                                     
 29390                                  ;        if (input != ESC)                                            
 29391                                  ;           BEGIN                                                     
 29392                                  ;            pnum = (int)input - '0';                                 
 29393                                  ;                                                                     
 29394                                  ;            /* The number that the user has entered is the sorted */ 
 29395                                  ;            /* numbering of the partition table.  We have to      */ 
 29396                                  ;            /* retrieve the actual position of this partition in  */ 
 29397                                  ;            /* the partition table.                               */ 
 29398                                  ;                                                                     
 29399                                  ;            j = 0;                                                   
 29400                                  ;            for (i = 0; i < 4; i++)                                  
 29401                                  ;               BEGIN                                                 
 29402                                  ;                if (part_table[cur_disk][sort[i]].sys_id != 0)       
 29403                                  ;                   BEGIN                                             
 29404                                  ;                    j++;                                             
 29405                                  ;                    if (j == pnum)                                   
 29406                                  ;                        break;                                       
 29407                                  ;                   END                                               
 29408                                  ;               END                                                   
 29409                                  ;            i = sort[i];                                             
 29410                                  ;                                                                     
 29411                                  ;            /* Verify selected partition is a non-DOS partition */   
 29412                                  ;                                                                     
 29413                                  ;            if ((part_table[cur_disk][i].sys_id!=uc(DOS12))  &&      
 29414                                  ;                (part_table[cur_disk][i].sys_id!=uc(DOS16))  &&      
 29415                                  ;                (part_table[cur_disk][i].sys_id!=uc(DOSNEW)) &&      
 29416                                  ;                (part_table[cur_disk][i].sys_id!=uc(EXTENDED)) )     
 29417                                  ;               BEGIN                                                 
 29418                                  ;                /* Display Y/N prompt */                             
 29419                                  ;                display(menu_56);                                    
 29420                                  ;                                                                     
 29421                                  ;                /* Get yes/no prompt */                              
 29422                                  ;                input = get_yn_input(c(No),input_row,input_col);     
 29423                                  ;                switch(input)                                        
 29424                                  ;                   BEGIN                                             
 29425                                  ;                    case 1:                                          
 29426                                  ;                       BEGIN                                         
 29427                                  ;                        /* Set Partition entry to zero */            
 29428                                  ;                        remove_partition(cur_disk,i);
 29429                                  ;                                                                  
 29430                                  ;                        /* Redisplay the partition info */           
 29431                                  ;                        table_display();                             
 29432                                  ;                                                                     
 29433                                  ;                        /* clear the prompt off */                   
 29434                                  ;                        clear_screen(u(16),u(0),u(23),u(79));        
 29435                                  ;                                                                     
 29436                                  ;                        /* Set the reboot flag */                    
 29437                                  ;                        reboot_flag = (FLAG)TRUE;                    
 29438                                  ;                                                                     
 29439                                  ;                        /* Say that you deleted it */                
 29440                                  ;                        display(status_13);                          
 29441                                  ;                                                                     
 29442                                  ;                        wait_for_ESC();                              
 29443                                  ;                        break;                                       
 29444                                  ;                       END                                           
 29445                                  ;                                                                     
 29446                                  ;                    case 0:                                          
 29447                                  ;                        break;                                       
 29448                                  ;                                                                     
 29449                                  ;                    case ESC:                                        
 29450                                  ;                        break;                                       
 29451                                  ;                                                                     
 29452                                  ;                    default:                                         
 29453                                  ;                       BEGIN                                         
 29454                                  ;                        internal_program_error();                    
 29455                                  ;                        break;                                       
 29456                                  ;                       END                                           
 29457                                  ;                   END                                               
 29458                                  ;               END                                                   
 29459                                  ;            else                                                     
 29460                                  ;               BEGIN                                                 
 29461                                  ;                /* Tell user he can only delete non-DOS partition */ 
 29462                                  ;                display(error_39);                                   
 29463                                  ;                wait_for_ESC();                                      
 29464                                  ;               END                                                   
 29465                                  ;           END                                                       
 29466                                  ;       END                                                           
 29467                                  ;    else                                                             
 29468                                  ;       BEGIN                                                         
 29469                                  ;        internal_program_error();                                    
 29470                                  ;       END                                                           
 29471                                  ;    clear_screen(u(0),u(0),u(24),u(79));                             
 29472                                  ;    return;                                                          
 29473                                  ;END 
 29474                                  
 29475                                  non_dos_delete:
 29476                                  		; 31/12/2018
 29477                                  
 29478                                  	%define ndd_j	 bp-10
 29479                                  	%define ndd_i	 bp-8
 29480                                  	%define ndd_cnt	 bp-6
 29481                                  	%define ndd_pnum bp-2
 29482                                  
 29483 000041D1 55                      		push	bp
 29484 000041D2 89E5                    		mov	bp,sp
 29485 000041D4 83EC0A                  		sub	sp,10
 29486                                  
 29487                                  		;/* clear screen */
 29488                                  
 29489                                  		;mov	ax,79
 29490                                  		;push	ax
 29491                                  		;mov	ax,24
 29492                                  		;push	ax
 29493                                  		;sub	ax,ax
 29494                                  		;push	ax
 29495                                  		;push	ax
 29496                                  		;call	clear_screen
 29497                                  		;add	sp,8
 29498                                  
 29499 000041D7 E884D2                  		call	CLS
 29500                                  
 29501                                  		;/* Display header */
 29502                                  
 29503                                  		;push	word [menu_58_segment]
 29504 000041DA 1E                      		push	ds
 29505 000041DB FF36[4D9E]              		push	word [menu_58_offset]
 29506 000041DF E842D4                  		call	display
 29507                                  		;pop	bx
 29508                                  		;pop	bx
 29509                                  
 29510                                  		;/* Setup and print current disk */
 29511                                  		
 29512                                  		;mov	al,[cur_disk]
 29513                                  		;add	al,'1'
 29514                                  		;mov	[insert],al
 29515                                  		;;push	word [menu_5_segment]
 29516                                  		;push	ds
 29517                                  		;push	word [menu_5_offset]
 29518                                  		;call	display
 29519                                  		;;pop	bx
 29520                                  		;;pop	bx
 29521                                  
 29522 000041E2 E878EC                  		call	display_menu_5 ; 31/12/2018
 29523                                  
 29524                                  		;/* print ESC prompt */   
 29525                                  
 29526                                  		;;push	word [menu_11_segment]
 29527                                  		;push	ds
 29528                                  		;push	word [menu_11_offset]
 29529                                  		;call	display
 29530                                  		;;pop	bx
 29531                                  		;;pop	bx
 29532                                  
 29533 000041E5 E886EC                  		call	display_menu_11 ; 31/12/2018
 29534                                  
 29535                                  		;/* Display partition data and double check if partition exists*/ 
 29536                                  
 29537 000041E8 E88CEC                  		call	table_display
 29538                                  		;or	al, al
 29539                                  		;jnz	short ndd_1
 29540 000041EB 7303                    		jnc	short ndd_1
 29541 000041ED E91F01                  		jmp	case_nondos_del_DEF
 29542                                  ndd_1:
 29543 000041F0 A0[E2CB]                		mov	al,[cur_disk]
 29544 000041F3 98                      		cbw
 29545 000041F4 89C3                    		mov	bx,ax
 29546 000041F6 D1E3                    		shl	bx,1
 29547 000041F8 FFB7[D6A0]              		push	word [total_mbytes+bx]
 29548 000041FC B8[926F]                		mov	ax,nd_p_size_format ; "%4.1d"
 29549 000041FF 50                      		push	ax
 29550 00004200 B8[F4CC]                		mov	ax,insert
 29551 00004203 50                      		push	ax
 29552 00004204 E8BEE0                  		call	sprintf
 29553 00004207 83C406                  		add	sp,6
 29554                                  
 29555                                  		;push	word [menu_15_segment]
 29556 0000420A 1E                      		push	ds
 29557 0000420B FF36[139E]              		push	word [menu_15_offset]
 29558 0000420F E812D4                  		call	display
 29559                                  		;pop	bx
 29560                                  		;pop	bx
 29561                                  
 29562                                  		;/* count the number of partitions */   
 29563                                  
 29564 00004212 31D2                    		xor	dx,dx
 29565 00004214 8956FA                  		mov	[ndd_cnt],dx ; 0
 29566 00004217 8956F8                  		mov	[ndd_i],dx ;0
 29567                                  ndd_2:
 29568 0000421A A0[E2CB]                		mov	al,[cur_disk]
 29569                                  		;cbw
 29570                                  		;shl	ax,1
 29571                                  		;shl	ax,1
 29572                                  		;add	ax,[ndd_i]
 29573 0000421D D0E0                    		shl	al,1
 29574 0000421F D0E0                    		shl	al,1
 29575 00004221 0246F8                  		add	al,[ndd_i]		
 29576                                  		;mov	cx,46
 29577                                  		;mul	cx
 29578 00004224 89C3                    		mov	bx,ax
 29579 00004226 80BF[25C4]00            		cmp	byte [part_table_sys_id+bx],0
 29580 0000422B 7403                    		je	short ndd_3
 29581 0000422D FE46FA                  		inc	byte [ndd_cnt]
 29582                                  ndd_3:
 29583 00004230 FE46F8                  		inc	byte [ndd_i]
 29584 00004233 807EF804                		cmp	byte [ndd_i],4
 29585 00004237 72E1                    		jb	short ndd_2
 29586                                  
 29587                                  		;/* Display partition number prompt */  
 29588                                  
 29589                                  		;push	word [menu_59_segment]
 29590 00004239 1E                      		push	ds
 29591 0000423A FF36[4F9E]              		push	word [menu_59_offset]
 29592 0000423E E8E3D3                  		call	display
 29593                                  		;pop	bx
 29594                                  		;pop	bx
 29595 00004241 FF36[AAA0]              		push	word [input_col]
 29596 00004245 FF36[4CA1]              		push	word [input_row]
 29597 00004249 8A46FA                  		mov	al,[ndd_cnt]  ; maximum
 29598 0000424C 50                      		push	ax
 29599 0000424D B001                    		mov	al,1  ; default
 29600 0000424F 50                      		push	ax
 29601 00004250 E821E8                  		call	get_num_input
 29602                                  		;add	sp,8
 29603                                  
 29604 00004253 3C1B                    		cmp	al,1Bh
 29605 00004255 7503                    		jne	short ndd_4
 29606 00004257 E9B800                  		jmp	case_nondos_del_break
 29607                                  ndd_4:
 29608 0000425A 98                      		cbw
 29609                                  		;sub	ax,'0'
 29610 0000425B 2C30                    		sub	al,'0'
 29611 0000425D 8946FE                  		mov	[ndd_pnum],ax
 29612                                  
 29613                                  	;/* The number that the user has entered is the sorted */ 
 29614                                          ;/* numbering of the partition table.  We have to      */ 
 29615                                          ;/* retrieve the actual position of this partition in  */ 
 29616                                          ;/* the partition table.                               */ 
 29617                                  
 29618 00004260 C646F600                		mov	byte [ndd_j],0
 29619 00004264 C646F800                		mov	byte [ndd_i],0
 29620 00004268 EB03                    		jmp	short ndd_6
 29621                                  ndd_5:
 29622 0000426A FE46F8                  		inc	byte [ndd_i]
 29623                                  ndd_6:
 29624 0000426D A0[E2CB]                		mov	al,[cur_disk]
 29625                                  		;cbw
 29626                                  		;shl	ax,1
 29627                                  		;shl	ax,1
 29628 00004270 D0E0                    		shl	al,1
 29629 00004272 D0E0                    		shl	al,1
 29630 00004274 8B5EF8                  		mov	bx,[ndd_i]
 29631                                  		;mov	cx,ax
 29632                                  		;mov	al,[sort+bx]
 29633 00004277 8A97[F0C3]              		mov	dl,[sort+bx] ; *=*
 29634                                  		;cbw
 29635                                  		;add	ax,cx
 29636 0000427B 00D0                    		add	al,dl
 29637                                  		;mov	cx,46
 29638                                  		;imul	cx
 29639 0000427D B12E                    		mov	cl,46
 29640 0000427F F6E1                    		mul	cl
 29641 00004281 89C3                    		mov	bx,ax
 29642                                  
 29643 00004283 807EF804                		cmp	byte [ndd_i],4
 29644 00004287 7313                    		jnb	short ndd_7
 29645                                  
 29646                                  		;mov	al,[cur_disk]
 29647                                  		;;cbw
 29648                                  		;;shl	ax,1
 29649                                  		;;shl	ax,1
 29650                                  		;shl	al,1
 29651                                  		;shl	al,1
 29652                                  		;mov	bx,[ndd_i]
 29653                                  		;;mov	cx,ax
 29654                                  		;;mov	al,[sort+bx]
 29655                                  		;mov	cl,[sort+bx]
 29656                                  		;;cbw
 29657                                  		;;add	ax,cx
 29658                                  		;add	al,cl
 29659                                  		;;mov	cx,46
 29660                                  		;;imul	cx
 29661                                  		;mov	cl,46
 29662                                  		;mul	cl
 29663                                  		;mov	bx,ax
 29664                                  
 29665 00004289 8AB7[25C4]              		mov	dh,[part_table_sys_id+bx]  ; *==*
 29666                                  
 29667                                  		;cmp	byte [part_table_sys_id+bx],0
 29668                                  		;je	short ndd_5
 29669                                  
 29670 0000428D 08F6                    		or	dh,dh
 29671 0000428F 74D9                    		jz	short ndd_5
 29672                                  
 29673                                  		;mov	ax,[ndd_pnum]
 29674 00004291 8A46FE                  		mov	al,[ndd_pnum]
 29675 00004294 FE46F6                  		inc	byte [ndd_j]
 29676                                  		;cmp	[ndd_j],ax
 29677 00004297 3846F6                  		cmp	[ndd_j],al
 29678 0000429A 75CE                    		jne	short ndd_5
 29679                                  ndd_7:
 29680                                  		;mov	al,[cur_disk]
 29681                                  		;cbw
 29682                                  		;shl	ax,1
 29683                                  		;shl	ax,1
 29684                                  		;mov	bx,[ndd_i]
 29685                                  		;mov	cx,ax
 29686                                  		;mov	al,[sort+bx]
 29687                                  		;cbw
 29688                                  		;mov	[ndd_i],ax
 29689                                  
 29690 0000429C 8856F8                  		mov	[ndd_i],dl ; *=*
 29691                                  
 29692                                  		;add	ax,cx
 29693                                  		;mov	cx,46
 29694                                  		;mul	cx
 29695                                  		;mov	bx,ax
 29696                                  
 29697                                  		;/* Verify selected partition is a non-DOS partition */  
 29698                                  		
 29699                                  		; dh = [part_table_sys_id+bx] ; *==*
 29700                                  
 29701                                  		;cmp	byte [part_table_sys_id+bx],1
 29702 0000429F 80FE01                  		cmp	dh,1
 29703 000042A2 7464                    		je	short ndd_11
 29704                                  		;cmp	byte [part_table_sys_id+bx],4
 29705 000042A4 80FE04                  		cmp	dh,4
 29706 000042A7 745F                    		je	short ndd_11
 29707                                  		;cmp	byte [part_table_sys_id+bx],6
 29708 000042A9 80FE06                  		cmp	dh,6
 29709 000042AC 745A                    		je	short ndd_11
 29710                                  		;cmp	byte [part_table_sys_id+bx],5
 29711 000042AE 80FE05                  		cmp	dh,5
 29712 000042B1 7455                    		je	short ndd_11
 29713                                  
 29714                                  		;/* Display Y/N prompt */
 29715                                  
 29716                                  		;push	word [menu_56_segment]
 29717 000042B3 1E                      		push	ds
 29718 000042B4 FF36[3F9E]              		push	word [menu_56_offset]
 29719 000042B8 E869D3                  		call	display
 29720                                  		;pop	bx
 29721                                  		;pop	bx
 29722                                  
 29723                                  		;/* Get yes/no prompt */ 
 29724                                  		
 29725 000042BB FF36[AAA0]              		push	word [input_col]
 29726 000042BF FF36[4CA1]              		push	word [input_row]
 29727 000042C3 A0[ACA0]                		mov	al,[No] ; default input, 'N'
 29728 000042C6 50                      		push	ax
 29729 000042C7 E884ED                  		call	get_yn_input
 29730                                  		;add	sp,6
 29731                                  switch_input6:
 29732                                  		;cbw
 29733                                  		;cmp	ax,1Bh
 29734 000042CA 3C1B                    		cmp	al,1Bh
 29735 000042CC 7444                    		je	short case_nondos_del_break
 29736 000042CE 773F                    		ja	short case_nondos_del_DEF
 29737 000042D0 08C0                    		or	al,al
 29738 000042D2 743E                    		jz	short case_nondos_del_break
 29739 000042D4 FEC8                    		dec	al
 29740 000042D6 7537                    		jnz	short case_nondos_del_DEF
 29741                                  
 29742                                  case_nondos_del_1:
 29743                                  		;/* Set Partition entry to zero */
 29744                                  
 29745                                  		;push	word [ndd_i]
 29746 000042D8 8A66F8                  		mov	ah,[ndd_i] ; 02/01/2019
 29747 000042DB A0[E2CB]                		mov	al,[cur_disk]
 29748                                  		;push	ax
 29749 000042DE E88704                  		call	remove_partition
 29750                                  		;pop	bx
 29751                                  		;pop	bx
 29752                                  
 29753                                  		;/* Redisplay the partition info */ 
 29754                                  		
 29755 000042E1 E893EB                  		call	table_display
 29756                                  
 29757                                  		;/* clear the prompt off */    
 29758                                  		
 29759 000042E4 B84F00                  		mov	ax,79
 29760 000042E7 50                      		push	ax
 29761 000042E8 B81700                  		mov	ax,23
 29762 000042EB 50                      		push	ax
 29763 000042EC 29C0                    		sub	ax,ax
 29764 000042EE 50                      		push	ax
 29765 000042EF B81000                  		mov	ax,16
 29766 000042F2 50                      		push	ax
 29767 000042F3 E8A0D1                  		call	clear_screen
 29768                                  		;add	sp,8
 29769                                  
 29770                                  		;/* Set the reboot flag */ 
 29771                                  
 29772 000042F6 C606[78A0]01            		mov	byte [reboot_flag],1
 29773                                  
 29774                                  		;/* Say that you deleted it */
 29775                                  
 29776                                  		;push	word [status_13_seg]
 29777 000042FB 1E                      		push	ds
 29778 000042FC FF36[819E]              		push	word [status_13_off]
 29779                                  ndd_10:
 29780 00004300 E821D3                  		call	display
 29781                                  		;pop	bx
 29782                                  		;pop	bx
 29783 00004303 E86EEE                  		call	wait_for_ESC
 29784 00004306 EB0A                    		jmp	short case_nondos_del_break
 29785                                  ndd_11:
 29786                                  		;/* Tell user he can only delete non-DOS partition */ 
 29787                                  
 29788                                  		;push	word [error_39_seg]
 29789 00004308 1E                      		push	ds
 29790 00004309 FF36[CC9E]              		push	word [error_39_off]
 29791 0000430D EBF1                    		jmp	short ndd_10
 29792                                  case_nondos_del_DEF:
 29793 0000430F E809F0                  		call	internal_program_error
 29794                                  case_nondos_del_break:
 29795                                  		;mov	ax,79
 29796                                  		;push	ax
 29797                                  		;mov	ax,24
 29798                                  		;push	ax
 29799                                  		;sub	ax,ax
 29800                                  		;push	ax
 29801                                  		;push	ax
 29802                                  		;call	clear_screen
 29803                                  		
 29804 00004312 E849D1                  		call	CLS
 29805                                  
 29806 00004315 89EC                    		mov	sp,bp
 29807 00004317 5D                      		pop	bp
 29808 00004318 C3                      		retn
 29809                                  
 29810                                  ; ----------------------------------------------------------------------------
 29811                                  ; partinfo.c (FDISK, MSDOS 6.0, 1991)	
 29812                                  ; ----------------------------------------------------------------------------
 29813                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 23/12/2018)
 29814                                  
 29815                                  ;char find_non_dos_partition()
 29816                                  ;
 29817                                  ;BEGIN
 29818                                  ; char  i;
 29819                                  ;
 29820                                  ; /* Look at all four partition entries for system id byte that is */
 29821                                  ; /* not NUL, DOS12, DOS16, DOSNEW, or EXTENDED. */
 29822                                  ; for (i = c(0); i < c(4);i++)
 29823                                  ;    BEGIN
 29824                                  ;
 29825                                  ;     /* if we find a match, do a TRUE return */
 29826                                  ;     if ((part_table[cur_disk][i].sys_id != NUL)    &&
 29827                                  ;         (part_table[cur_disk][i].sys_id != DOS12)  &&
 29828                                  ;         (part_table[cur_disk][i].sys_id != DOS16)  &&
 29829                                  ;         (part_table[cur_disk][i].sys_id != DOSNEW) &&
 29830                                  ;         (part_table[cur_disk][i].sys_id != EXTENDED))
 29831                                  ;        BEGIN
 29832                                  ;         return(TRUE);
 29833                                  ;         break;
 29834                                  ;        END
 29835                                  ;    END
 29836                                  ; /* Did not find one, return FALSE */
 29837                                  ; return(FALSE);
 29838                                  ;END
 29839                                  
 29840                                  find_non_dos_partition:
 29841                                  		; 23/12/2018
 29842                                  
 29843                                  	;%define fndp_i	bp-2
 29844                                  
 29845                                  		;push	bp
 29846                                  		;mov	bp,sp
 29847                                  		;sub	sp,2
 29848                                  		
 29849                                  		;mov	byte [fndp_i],0
 29850 00004319 30D2                    		xor	dl,dl
 29851 0000431B EB07                    		jmp	short fndp_2
 29852                                  fndp_1:
 29853                                  		;inc	byte [fndp_i]
 29854 0000431D FEC2                    		inc	dl
 29855                                  ;fndp_2:
 29856                                  		;cmp	byte [fndp_i],4
 29857 0000431F 80FA04                  		cmp	dl,4
 29858 00004322 7D2F                    		jge	short fndp_3
 29859                                  fndp_2:
 29860 00004324 A0[E2CB]                		mov	al,[cur_disk]
 29861                                  		;cbw
 29862                                  		;shl	ax,1
 29863                                  		;shl	ax,1
 29864 00004327 D0E0                    		shl	al,1
 29865 00004329 D0E0                    		shl	al,1
 29866                                  		;mov	cx,ax
 29867                                  		;mov	al,[fndp_i]
 29868                                  		;cbw
 29869                                  		;add	ax,cx
 29870 0000432B 00D0                    		add	al,dl
 29871                                  		;mov	cx,46
 29872                                  		;imul	cx
 29873 0000432D B12E                    		mov	cl,46
 29874 0000432F F6E1                    		mul	cl
 29875 00004331 89C3                    		mov	bx,ax
 29876                                  		
 29877 00004333 8A8F[25C4]              		mov	cl,[part_table_sys_id+bx]
 29878                                  		
 29879                                  		;cmp	byte [part_table_sys_id+bx],0
 29880                                  		;je	short fndp_1
 29881 00004337 08C9                    		or	cl,cl
 29882 00004339 74E2                    		jz	short fndp_1
 29883                                  
 29884                                  		;cmp	byte [part_table_sys_id+bx],1
 29885                                  		;je	short fndp_1
 29886 0000433B 80F901                  		cmp	cl,1
 29887 0000433E 74DD                    		je	short fndp_1
 29888                                  
 29889                                  		;cmp	byte [part_table_sys_id+bx],4
 29890                                  		;je	short fndp_1
 29891 00004340 80F904                  		cmp	cl,4
 29892 00004343 74D8                    		je	short fndp_1
 29893                                  		
 29894                                  		;cmp	byte [part_table_sys_id+bx],6
 29895                                  		;je	short fndp_1
 29896 00004345 80F906                  		cmp	cl,6
 29897 00004348 74D3                    		je	short fndp_1		
 29898                                  
 29899                                  		;cmp	byte [part_table_sys_id+bx],5
 29900                                  		;je	short fndp_1
 29901 0000434A 80F905                  		cmp	cl,5
 29902 0000434D 74CE                    		je	short fndp_1
 29903                                  
 29904 0000434F B001                    		mov	al,1
 29905 00004351 EB02                    		jmp	short fndp_4
 29906                                  fndp_3:
 29907 00004353 28C0                    		sub	al,al
 29908                                  fndp_4:
 29909 00004355 3C01                    		cmp	al,1
 29910                                  
 29911                                  		;mov	sp,bp
 29912                                  		;pop	bp
 29913                                  
 29914 00004357 C3                      		retn
 29915                                  
 29916                                  ; ----------------------------------------------------------------------------
 29917                                  
 29918                                  ;char find_ext_drive(offset)
 29919                                  ;
 29920                                  ;char offset;
 29921                                  ;
 29922                                  ;BEGIN
 29923                                  ;
 29924                                  ;char number_found;
 29925                                  ;char i;
 29926                                  ;
 29927                                  ;    number_found = c(0);
 29928                                  ;
 29929                                  ;    /* Go look for the nth extended drive */
 29930                                  ;    for (i=c(0); i < c(23); i++)
 29931                                  ;      BEGIN
 29932                                  ;       /* See if there is a drive we know about */
 29933                                  ;       if ((ext_table[cur_disk][i].sys_id == uc(DOS12)) || (ext_table[cur_disk][i].sys_id == uc(DOS16)) ||
 29934                                  ;          (ext_table[cur_disk][i].sys_id == uc(DOSNEW)))
 29935                                  ;          BEGIN
 29936                                  ;           /* Is this the one we were looking for ? */
 29937                                  ;           if (number_found == offset)
 29938                                  ;              BEGIN
 29939                                  ;               /* Yes it is, return where we found it */
 29940                                  ;               return(i);
 29941                                  ;               break;
 29942                                  ;              END
 29943                                  ;              /* Show we found one and go look for the next */
 29944                                  ;              number_found++;
 29945                                  ;          END
 29946                                  ;      END
 29947                                  ;      /* We should never get here */
 29948                                  ;      internal_program_error();
 29949                                  ;      return(c(INVALID));
 29950                                  ;END
 29951                                  
 29952                                  find_ext_drive:
 29953                                  		; 26/12/2018
 29954                                  	;%define fed_number_found bp-4
 29955                                  	;%define fed_i		 bp-2
 29956                                  	;%define fed_offset	 bp+4
 29957                                  
 29958                                  		;push	bp
 29959                                  		;mov	bp,sp
 29960                                  		;sub	sp,4
 29961                                  
 29962                                  		; INPUT: DL = Logical dos drive offset/index
 29963                                  		; 06/01/2019
 29964                                  		; OUTPUT: CL = Extended drive index of (that) logical DOS drive 
 29965                                  		;	      (including count of non-dos drives before it) 
 29966                                  		;	  CL = 0FFh -> invalid (not found)		
 29967                                  
 29968                                  		;/* Go look for the nth extended drive */
 29969                                  
 29970                                  		;sub	al,al ; 0
 29971                                  		;mov	[fed_i],al ; 0
 29972                                  		;mov	[fed_number_found],al ; 0
 29973 00004358 31C9                    		xor	cx,cx
 29974                                  		;mov	[fed_i],cl
 29975                                  		;mov	[fed_number_found],cl
 29976 0000435A EB09                    		jmp	short fed_3
 29977                                  fed_1:
 29978                                  		;inc	byte [fed_i]
 29979 0000435C FEC5                    		inc	ch
 29980                                  fed_2:
 29981                                  		;/* Show we found one and go look for the next */
 29982                                  
 29983                                  		;inc	byte [fed_number_found]
 29984 0000435E FEC1                    		inc	cl
 29985                                  ;fed_3:
 29986                                  		;cmp	byte [fed_number_found],23
 29987 00004360 80F917                  		cmp	cl,23	
 29988 00004363 7D23                    		jge	short fed_5
 29989                                  		;mov	al,[fed_number_found]
 29990                                  		;mov	cl,[fed_number_found]
 29991                                  fed_3:
 29992                                  		;/* See if there is a drive we know about */
 29993                                  
 29994                                  		;cbw
 29995                                  		;mov	cx,ax
 29996 00004365 B018                    		mov	al,24
 29997                                  		;imul	byte [cur_disk]
 29998 00004367 F626[E2CB]              		mul	byte [cur_disk]
 29999                                  		;add	ax,cx
 30000 0000436B 00C8                    		add	al,cl
 30001                                  		;mov	cx,46
 30002                                  		;imul	cx
 30003 0000436D B32E                    		mov	bl,46
 30004 0000436F F6E3                    		mul	bl
 30005 00004371 89C3                    		mov	bx,ax
 30006                                  
 30007 00004373 8A87[5DA1]              		mov	al,[ext_table_sys_id+bx]
 30008                                  		;cmp	byte [ext_table_sys_id+bx],1
 30009 00004377 3C01                    		cmp	al,1
 30010 00004379 7408                    		je	short fed_4
 30011                                  		;cmp	byte [ext_table_sys_id+bx],4
 30012 0000437B 3C04                    		cmp	al,4
 30013 0000437D 7404                    		je	short fed_4
 30014                                  		;cmp	byte [ext_table_sys_id+bx],6
 30015 0000437F 3C06                    		cmp	al,6
 30016 00004381 75DB                    		jne	short fed_2
 30017                                  fed_4:		
 30018                                  		;/* Is this the one we were looking for ? */
 30019                                  
 30020                                  		;mov	al,[fed_offset]
 30021                                  		;cmp	[fed_i],al
 30022 00004383 38D5                    		cmp	ch,dl
 30023 00004385 75D5                    		jne	short fed_1
 30024                                  
 30025                                  		;/* Yes it is, return where we found it */
 30026                                  
 30027                                  		;mov	al,[fed_number_found]
 30028                                  		;jmp	short fed_6
 30029                                  		;mov	al,cl
 30030                                  		;xor	ch,ch
 30031                                  		; cl = Extended drive index number
 30032 00004387 C3                      		retn
 30033                                  fed_5:
 30034                                  		;/* We should never get here */
 30035                                  
 30036 00004388 E890EF                  		call	internal_program_error
 30037                                  		;mov	al,0FFh
 30038                                  		;mov	cx,0FFh
 30039                                  		;stc
 30040 0000438B B1FF                    		mov	cl,0FFh
 30041                                  fed_6:
 30042                                  		;mov	sp,bp
 30043                                  		;pop	bp
 30044 0000438D C3                      		retn
 30045                                  
 30046                                  
 30047                                  ; fdisk.msg (MSDOS 6.0)
 30048                                  ;/***************************************************************************************************/
 30049                                  ;/*  Screen for SYSTEM_REBOOT                                                                       */
 30050                                  ;/*                                                                                                 */
 30051                                  ;/*     |00000000001111111111222222222233333333334444444444555555555566666666667777777777|          */
 30052                                  ;/*     |01234567890123456789012345678901234567890123456789012345678901234567890123456789|          */
 30053                                  ;/*   --|--------------------------------------------------------------------------------|          */
 30054                                  ;/*   00|                                                                                |          */
 30055                                  ;/*   01|                                                                                |          */
 30056                                  ;/*   02|                                                                                |          */
 30057                                  ;/*   03|                                                                                |          */
 30058                                  ;/*   04|                                                                                |          */
 30059                                  ;/*   05|                                                                                |          */
 30060                                  ;/*   06|                                                                                |          */
 30061                                  ;/*   07|                                                                                |          */
 30062                                  ;/*   08|                                                                                |          */
 30063                                  ;/*   09|                                                                                |          */
 30064                                  ;/*   10|                                                                                |          */
 30065                                  ;/*   11|                                                                                |          */
 30066                                  ;/*   12|                                                                                |          */
 30067                                  ;/*   13|    System will now restart                                                     |menu_38   */
 30068                                  ;/*   14|                                                                                |          */
 30069                                  ;/*   15|    Insert DOS diskette in drive A:                                             |menu_38   */
 30070                                  ;/*   16|    Press any key when ready . . .                                              |menu_38   */
 30071                                  ;/*   17|                                                                                |          */
 30072                                  ;/*   18|                                                                                |          */
 30073                                  ;/*   19|                                                                                |          */
 30074                                  ;/*   20|                                                                                |          */
 30075                                  ;/*   21|                                                                                |          */
 30076                                  ;/*   22|                                                                                |          */
 30077                                  ;/*   23|                                                                                |          */
 30078                                  ;/*   24|                                                                                |          */
 30079                                  ;/*   ------------------------------------------------------------------------------------          */
 30080                                  ;/*                                                                                                 */
 30081                                  ;/***************************************************************************************************/
 30082                                  
 30083                                  ; strcmp (Microsoft C 6.0 runtime library, MSDOS 6.0, 1991)	
 30084                                  ; ============================================================================
 30085                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 23/12/2018)
 30086                                  
 30087                                  ; STRCMP.ASM
 30088                                  ;*************
 30089                                  ;strcmp - compare two strings, returning less than, equal to, or greater than
 30090                                  ;
 30091                                  ;Purpose:
 30092                                  ;	Compares two string, determining their lexical order.  Unsigned
 30093                                  ;	comparison is used.
 30094                                  ;
 30095                                  ;	Algorithm:
 30096                                  ;	   int strcmp ( src , dst )
 30097                                  ;		   unsigned char *src;
 30098                                  ;		   unsigned char *dst;
 30099                                  ;	   {
 30100                                  ;		   int ret = 0 ;
 30101                                  ;
 30102                                  ;		   while( ! (ret = *src - *dst) && *dst)
 30103                                  ;			   ++src, ++dst;
 30104                                  ;
 30105                                  ;		   if ( ret < 0 )
 30106                                  ;			   ret = -1 ;
 30107                                  ;		   else if ( ret > 0 )
 30108                                  ;			   ret = 1 ;
 30109                                  ;
 30110                                  ;		   return( ret );
 30111                                  ;	   }
 30112                                  ;
 30113                                  ;Entry:
 30114                                  ;	const char * src - string for left-hand side of comparison
 30115                                  ;	const char * dst - string for right-hand side of comparison
 30116                                  ;
 30117                                  ;Exit:
 30118                                  ;	AX < 0, 0, or >0, indicating whether the first string is
 30119                                  ;	Less than, Equal to, or Greater than the second string.
 30120                                  ;
 30121                                  ;Uses:
 30122                                  ;	BX, CX, DX
 30123                                  ;
 30124                                  ;Exceptions:
 30125                                  ;
 30126                                  ;*******************************************************************************
 30127                                  
 30128                                  ; IBM PC-DOS FDISK.COM (upacked) - Segment 0, Offset 6FA4h
 30129                                  
 30130                                  strcmp:
 30131                                  		; 23/12/2018
 30132                                  
 30133                                  	%define strcmp_src bp+4
 30134                                  	%define strcmp_dst bp+6
 30135                                  
 30136                                  		;push	bp
 30137                                  		;mov	bp,sp
 30138                                  	
 30139                                  		;mov	dx,di	; preserve SI and DI
 30140                                  		;mov	bx,si
 30141                                  	
 30142                                  		;mov	ax,ds
 30143                                  		;mov	es,ax	; ES = DS = DGROUP
 30144                                  		;mov	si,[strcmp_src]	; DS:SI = src
 30145                                  		;mov	di,[strcmp_dst]	; ES:DI = dst
 30146                                  
 30147 0000438E 31C0                    		xor	ax,ax
 30148 00004390 B9FFFF                  		mov	cx,-1
 30149 00004393 F2AE                    		repne	scasb	; compute length of "dst"
 30150 00004395 F7D1                    		not	cx	; CX = strlen(dst)+1
 30151 00004397 29CF                    		sub	di,cx	; restore ES:DI = dst
 30152 00004399 F3A6                    		repe	cmpsb	; compare while equal, at most length of "dst"
 30153 0000439B 7405                    		je	short toend ; dst == src?  (AX = 0)
 30154                                  				; dst < src	dst > src
 30155 0000439D 19C0                    		sbb	ax,ax	; AX=-1, CY=1	AX=0, CY=0
 30156 0000439F 83D8FF                  		sbb	ax,-1	; AX=-1		AX=1
 30157                                  toend:
 30158                                  		;mov	si,bx		; restore SI and DI
 30159                                  		;mov	di,dx
 30160                                  
 30161                                  		;pop	bp
 30162 000043A2 C3                      		retn
 30163                                  
 30164                                  ; ----------------------------------------------------------------------------
 30165                                  ; input.c (FDISK, MSDOS 6.0, 1991)	
 30166                                  ; ----------------------------------------------------------------------------
 30167                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 01/01/2019)
 30168                                  
 30169                                  ;/*  */ 
 30170                                  ;
 30171                                  ;void get_string_input(StartRow,StartCol,string_ptr)
 30172                                  ;                                  
 30173                                  ;unsigned        StartRow;                                         /* AN000 */
 30174                                  ;unsigned        StartCol;                                         /* AN000 */
 30175                                  ;char far        *string_ptr;                                      /* AN000 */
 30176                                  ;                                                                  /* AN000 */
 30177                                  ;BEGIN                                                             /* AN000 */
 30178                                  ;
 30179                                  ;    #define MAX_STRING_INPUT_LENGTH 11
 30180                                  ;                                                                  /* AN000 */
 30181                                  ;    unsigned char   input;                                        /* AN000 */
 30182                                  ;    char   far *WorkingPtr;                                       /* AN000 */
 30183                                  ;    char   far *DeletePtr;                                        /* AN000 */
 30184                                  ;    char   Done;                                                  /* AN000 */
 30185                                  ;    unsigned        Row;                                          /* AN000 */
 30186                                  ;    unsigned        Col;                                          /* AN000 */
 30187                                  ;
 30188                                  ;    char            attribute;
 30189                                  ;    char far        *attribute_ptr = &attribute;
 30190                                  ;    char far *input_ptr = &input;
 30191                                  ;
 30192                                  ;    if (mono_flag == TRUE)
 30193                                  ;        attribute = HIWHITE_ON_BLACK; /*C09*/
 30194                                  ;    else
 30195                                  ;        attribute = HIWHITE_ON_BLUE;  /*C09*/
 30196                                  ;
 30197                                  ;    WorkingPtr = string_ptr;                                      /* AN000 */
 30198                                  ;
 30199                                  ;    Row = StartRow;                                               /* AN000 */
 30200                                  ;    Col = StartCol;                                               /* AN000 */
 30201                                  ;    VIOSETCURPOS(Row,Col,u(0));                                   /* AN000 */
 30202                                  ;
 30203                                  ;    while(*WorkingPtr != c(NUL))                                  /* AN000 */
 30204                                  ;        BEGIN                                                     /* AN000 */
 30205                                  ;        VIOWRTCHARSTRATT(WorkingPtr,u(1),Row,Col,attribute_ptr,u(0));
 30206                                  ;        WorkingPtr++;
 30207                                  ;        Col++;                                                    /* AN000 */
 30208                                  ;        VIOSETCURPOS(Row,Col,u(0));                               /* AN000 */
 30209                                  ;        END                                                       /* AN000 */
 30210                                  ;
 30211                                  ;    regs.h.ah = uc(12);                                           /* AN000 */
 30212                                  ;    regs.h.al = uc(7); /*C03*/
 30213                                  ;    intdos(&regs,&regs);                                          /* AN000 */
 30214                                  ;    input = regs.h.al;                                            /* AN000 */
 30215                                  ;
 30216                                  ;    /* Loop until we get good stuff */                            /* AN000 */
 30217                                  ;    Done = FALSE;                                                 /* AN000 */
 30218                                  ;    while (!Done)                                                 /* AN000 */
 30219                                  ;        BEGIN                                                     /* AN000 */
 30220                                  ;
 30221                                  ;        /* Go handle different inputs */
 30222                                  ;
 30223                                  ;        if (input < 32)                                           /* AN000 */
 30224                                  ;            BEGIN                                                 /* AN000 */
 30225                                  ;            switch(input)                                         /* AN000 */
 30226                                  ;                BEGIN                                             /* AN000 */
 30227                                  ;                case ESC:                                         /* AN000 */
 30228                                  ;                    Done=TRUE;                                    /* AN000 */
 30229                                  ;                    *string_ptr++ = c(ESC);                       /* AN000 */
 30230                                  ;                    *string_ptr++ = c('\0');                      /* AN000 */
 30231                                  ;                   break;                                         /* AN000 */
 30232                                  ;
 30233                                  ;                case  CR:                                         /* AN000 */
 30234                                  ;                    Done=TRUE;                                    /* AN000 */
 30235                                  ;                    break;                                        /* AN000 */
 30236                                  ;
 30237                                  ;                case 8: /* backspace */                           /* AN000 */
 30238                                  ;                    if (Col > StartCol)                           /* AN000 */
 30239                                  ;                        BEGIN                                     /* AN000 */
 30240                                  ;                        WorkingPtr--;                             /* AN000 */
 30241                                  ;                        Col--;                                    /* AN000 */
 30242                                  ;                        VIOSETCURPOS(Row,Col,u(0));               /* AN000 */
 30243                                  ;			  input = c(' ');
 30244                                  ;                        VIOWRTCHARSTRATT(input_ptr,u(1),Row,Col,attribute_ptr,u(0));
 30245                                  ;                        VIOSETCURPOS(Row,Col,u(0));               /* AN000 */
 30246                                  ;                        DeletePtr = WorkingPtr;                   /* AN000 */
 30247                                  ;                        while ( *(DeletePtr+1) != c('\0')  )      /* AN000 */
 30248                                  ;                            BEGIN                                 /* AN000 */
 30249                                  ;                            *DeletePtr = *(DeletePtr+1);          /* AN000 */
 30250                                  ;                            VIOWRTCHARSTRATT(DeletePtr,u(1),Row,Col,attribute_ptr,u(0));
 30251                                  ;                            DeletePtr++;                          /* AN000 */
 30252                                  ;                            END                                   /* AN000 */
 30253                                  ;                        *DeletePtr = c('\0');                     /* AN000 */
 30254                                  ;			  input = c(' ');
 30255                                  ;                        VIOWRTCHARSTRATT(input_ptr,u(1),Row,Col+1,attribute_ptr,u(0));
 30256                                  ;                        VIOSETCURPOS(Row,Col,u(0));               /* AN000 */
 30257                                  ;                        END                                       /* AN000 */
 30258                                  ;                    else DOSBEEP(u(900),u(400));                  /* AN000 */
 30259                                  ;                break;                                            /* AN000 */
 30260                                  ;
 30261                                  ;                case  0:                                          /* AN000 */
 30262                                  ;                    regs.h.ah = uc(0x07); /*C03*/
 30263                                  ;                    intdos(&regs,&regs);                          /* AN000 */
 30264                                  ;                    input = regs.h.al;                            /* AN000 */
 30265                                  ;                    switch(input)                                 /* AN000 */
 30266                                  ;                        BEGIN                                     /* AN000 */
 30267                                  ;                        case 71: /* HOME */                       /* AN000 */
 30268                                  ;                            WorkingPtr = string_ptr;              /* AN000 */
 30269                                  ;                            Row = StartRow;                       /* AN000 */
 30270                                  ;                            Col = StartCol;                       /* AN000 */
 30271                                  ;                            VIOSETCURPOS(Row,Col,u(0));           /* AN000 */
 30272                                  ;                            break;                                /* AN000 */
 30273                                  ;
 30274                                  ;                        case 79: /* END  */                       /* AN000 */
 30275                                  ;                            while (*WorkingPtr != c('\0') )       /* AN000 */
 30276                                  ;                                BEGIN                             /* AN000 */
 30277                                  ;                                WorkingPtr++;                     /* AN000 */
 30278                                  ;                                Col++;                            /* AN000 */
 30279                                  ;                                VIOSETCURPOS(Row,Col,u(0));       /* AN000 */
 30280                                  ;                                END                               /* AN000 */
 30281                                  ;                            break;                                /* AN000 */
 30282                                  ;
 30283                                  ;                        case 75: /* Cursor Left */                /* AN000 */
 30284                                  ;                            if (Col > StartCol)                   /* AN000 */
 30285                                  ;                                BEGIN                             /* AN000 */
 30286                                  ;                                WorkingPtr--;                     /* AN000 */
 30287                                  ;                                Col--;                            /* AN000 */
 30288                                  ;                                VIOSETCURPOS(Row,Col,u(0));       /* AN000 */
 30289                                  ;                                END                               /* AN000 */
 30290                                  ;                            else DOSBEEP(u(900),u(400));          /* AN000 */
 30291                                  ;                            break;                                /* AN000 */
 30292                                  ;
 30293                                  ;                        case 77: /* Cursor Right */               /* AN000 */
 30294                                  ;                            if ( *WorkingPtr != c('\0') )         /* AN000 */
 30295                                  ;                                BEGIN                             /* AN000 */
 30296                                  ;                                WorkingPtr++;                     /* AN000 */
 30297                                  ;                                Col++;                            /* AN000 */
 30298                                  ;                                VIOSETCURPOS(Row,Col,u(0));       /* AN000 */
 30299                                  ;                                END                               /* AN000 */
 30300                                  ;                            else DOSBEEP(u(900),u(400));          /* AN000 */
 30301                                  ;                            break;                                /* AN000 */
 30302                                  ;
 30303                                  ;                        default:                                  /* AN000 */
 30304                                  ;                            DOSBEEP(u(900),u(400));               /* AN000 */
 30305                                  ;                            break;                                /* AN000 */
 30306                                  ;
 30307                                  ;                        END                                       /* AN000 */
 30308                                  ;                    break;                                        /* AN000 */
 30309                                  ;
 30310                                  ;                default:                                          /* AN000 */
 30311                                  ;                        DOSBEEP(u(900),u(400));                   /* AN000 */
 30312                                  ;                        break;                                    /* AN000 */
 30313                                  ;                END                                               /* AN000 */
 30314                                  ;
 30315                                  ;            END                                                   /* AN000 */
 30316                                  ;         else     /* input is >= 32 */                            /* AN000 */
 30317                                  ;            BEGIN                                                 /* AN000 */
 30318                                  ;            input = dos_upper(input);                             /* AN000 */
 30319                                  ;            if ( (strchr(".\"/\\[]:|<>+=;,",input) == NULL) &&
 30320                                  ;                 (Col < StartCol + MAX_STRING_INPUT_LENGTH)    )  /* AN000 */
 30321                                  ;                BEGIN                                             /* AN000 */
 30322                                  ;                /* SR; 10/2/89; If Ctrl-C, display blank and beep */
 30323                                  ;                if ( input != 0x03 )
 30324                                  ;                    VIOWRTCHARSTRATT(input_ptr,u(1),Row,Col,attribute_ptr,u(0));
 30325                                  ;                else
 30326                                  ;                    {
 30327                                  ;                    DOSBEEP( 900, 400 );
 30328                                  ;                    input = c(' ');
 30329                                  ;                    VIOWRTCHARSTRATT(input_ptr,u(1),Row,Col,attribute_ptr,u(0));
 30330                                  ;                    }
 30331                                  ;                *WorkingPtr = input;                              /* AN000 */
 30332                                  ;                *(WorkingPtr+1) = c('\0');                        /* AN000 */
 30333                                  ;                if (Col < (StartCol + MAX_STRING_INPUT_LENGTH - 1)) /* AN000 */
 30334                                  ;                    BEGIN                                         /* AN000 */
 30335                                  ;                    Col++;                                        /* AN000 */
 30336                                  ;                    WorkingPtr++;                                 /* AN000 */
 30337                                  ;                    END                                           /* AN000 */
 30338                                  ;                VIOSETCURPOS(Row,Col,u(0));                       /* AN000 */
 30339                                  ;                END                                               /* AN000 */
 30340                                  ;            else DOSBEEP(u(900),u(400));                          /* AN000 */
 30341                                  ;            END                                                   /* AN000 */
 30342                                  ;
 30343                                  ;        if (!Done)                                                /* AN000 */
 30344                                  ;            BEGIN                                                 /* AN000 */
 30345                                  ;            /* Get a character */                                 /* AN000 */
 30346                                  ;            regs.h.ah = uc(0x07); /*C03*/
 30347                                  ;            intdos(&regs,&regs);                                  /* AN000 */
 30348                                  ;            input = regs.h.al;                                    /* AN000 */
 30349                                  ;            END                                                   /* AN000 */
 30350                                  ;        END                                                       /* AN000 */
 30351                                  ;
 30352                                  ;    return;                                                       /* AN000 */
 30353                                  ;END                                                                 
 30354                                  
 30355                                  get_string_input:
 30356                                  
 30357                                  		; 01/01/2019
 30358                                  
 30359                                  	%define gsi_endcol	bp-28 ; modification 
 30360                                  
 30361                                  	%define gsi_col		bp-26
 30362                                  	%define gsi_deleteptr	bp-24
 30363                                  	%define gsi_attribute_ptr bp-20
 30364                                  	;%define gsi_attribute_ptr2 bp-18
 30365                                  	%define gsi_row		bp-16
 30366                                  	%define gsi_workingptr	bp-14
 30367                                  	%define gsi_done	bp-10
 30368                                  	%define gsi_input_ptr	bp-8
 30369                                  	;%define gsi_input_ptr2	bp-6
 30370                                  	%define gsi_attribute	bp-4
 30371                                  	%define gsi_input	bp-2
 30372                                  
 30373                                  	%define gs_i_startrow	bp+4
 30374                                  	%define gs_i_startcol	bp+6
 30375                                  	%define gs_i_stringptr	bp+8
 30376                                  
 30377 000043A3 55                      		push	bp
 30378 000043A4 89E5                    		mov	bp,sp
 30379                                  		;sub	sp,26
 30380 000043A6 83EC1C                  		sub	sp,28
 30381                                  
 30382 000043A9 8D46FC                  		lea	ax,[gsi_attribute]
 30383 000043AC 8946EC                  		mov	[gsi_attribute_ptr],ax
 30384 000043AF 8C56EE                  		mov	[gsi_attribute_ptr+2],ss
 30385 000043B2 8D4EFE                  		lea	cx,[gsi_input]
 30386 000043B5 894EF8                  		mov	[gsi_input_ptr],cx
 30387 000043B8 8C56FA                  		mov	[gsi_input_ptr+2],ss
 30388                                  		
 30389 000043BB 803E[D8C3]01            		cmp	byte [mono_flag],1
 30390 000043C0 7506                    		jne	short gsi_1
 30391 000043C2 C646FC0F                		mov	byte [gsi_attribute],0Fh ;HIWHITE_ON_BLACK
 30392 000043C6 EB04                    		jmp	short gsi_2
 30393                                  gsi_1:
 30394 000043C8 C646FC1F                		mov	byte [gsi_attribute],1Fh ;HIWHITE_ON_BLUE
 30395                                  gsi_2:
 30396 000043CC 8B4608                  		mov	ax,[gs_i_stringptr]
 30397 000043CF 8B560A                  		mov	dx,[gs_i_stringptr+2]
 30398 000043D2 8946F2                  		mov	[gsi_workingptr],ax
 30399 000043D5 8956F4                  		mov	[gsi_workingptr+2],dx
 30400 000043D8 8B4604                  		mov	ax,[gs_i_startrow]
 30401 000043DB 8946F0                  		mov	[gsi_row],ax
 30402 000043DE 8B4E06                  		mov	cx,[gs_i_startcol]
 30403 000043E1 894EE6                  		mov	[gsi_col],cx
 30404                                  
 30405                                  		; modification
 30406 000043E4 83C10B                  		add	cx,11 ; MAX_STRING_INPUT_LENGTH = 11
 30407 000043E7 894EE4                  		mov	[gsi_endcol],cx
 30408                                  		
 30409                                  		;push	ax
 30410                                  		;push	cx
 30411 000043EA EB1B                    		jmp	short gsi_4
 30412                                  gsi_3:
 30413                                  		;VIOWRTCHARSTRATT(WorkingPtr,u(1),Row,Col,attribute_ptr,u(0));
 30414                                  
 30415 000043EC 06                      		push	es
 30416 000043ED 53                      		push	bx
 30417 000043EE B80100                  		mov	ax,1
 30418 000043F1 50                      		push	ax
 30419 000043F2 FF76F0                  		push	word [gsi_row]
 30420 000043F5 FF76E6                  		push	word [gsi_col]
 30421 000043F8 FF76EE                  		push	word [gsi_attribute_ptr+2]
 30422 000043FB FF76EC                  		push	word [gsi_attribute_ptr]
 30423                                  		;sub	cx,cx
 30424                                  		;push	cx
 30425 000043FE E8E2D4                  		call	VIOWRTCHARSTRATT
 30426                                  		
 30427                                  		;WorkingPtr++;
 30428                                  		;Col++;
 30429                                  		
 30430                                  		;VIOSETCURPOS(Row,Col,u(0));         
 30431                                  
 30432 00004401 FF46F2                  		inc	word [gsi_workingptr]
 30433                                  		;push	word [gsi_row]
 30434 00004404 FE46E6                  		inc	byte [gsi_col]
 30435                                  		;push	word [gsi_col]
 30436                                  gsi_4:
 30437                                  		;sub	ax,ax
 30438                                  		;push	ax
 30439                                  
 30440 00004407 8A76F0                  		mov	dh,[gsi_row]
 30441 0000440A 8A56E6                  		mov	dl,[gsi_col]
 30442                                  
 30443 0000440D E810E8                  		call	VIOSETCURPOS
 30444                                  		
 30445                                  		;while(*WorkingPtr != c(NUL))     	
 30446                                  
 30447 00004410 C45EF2                  		les	bx,[gsi_workingptr]
 30448 00004413 26803F00                		cmp	byte [es:bx],0
 30449 00004417 75D3                    		jne	short gsi_3
 30450                                  
 30451                                  		;mov	byte [regs_x_ax+1],0Ch
 30452                                  		;mov	byte [regs_x_ax],7
 30453                                  		;mov	ax,regs_x_ax
 30454                                  		;push	ax
 30455                                  		;push	ax
 30456                                  		;call	intdos
 30457                                  		;pop	bx
 30458                                  		;pop	bx
 30459                                  		;mov	al,[regs_x_ax]
 30460                                  
 30461                                  		;DOS function
 30462                                  		;FLUSH BUFFER AND READ STANDARD INPUT		
 30463                                  		;mov	ah,0Ch
 30464                                  		;mov	al,7  ; DIRECT CHARACTER INPUT, WITHOUT ECHO
 30465 00004419 B8070C                  		mov	ax,0C07h
 30466 0000441C CD21                    		int	21h
 30467                                  
 30468 0000441E 8846FE                  		mov	byte [gsi_input],al
 30469                                  
 30470                                  		;/* Loop until we get good stuff */ 
 30471                                  
 30472 00004421 C646F600                		mov	byte [gsi_done],0  ; Done = FALSE;
 30473                                  gsi_5:
 30474                                  		;/* Go handle different inputs */
 30475                                  
 30476                                  		;if (input < 32)
 30477 00004425 807EFE20                		cmp	byte [gsi_input],20h ; 32 ; SPACE character
 30478 00004429 7203                    		jb	short gsi_6 ; one of control characters
 30479 0000442B E96D01                  		jmp	gsi_26	; TEXT character
 30480                                  gsi_6:
 30481                                  		;switch(input)  
 30482                                  
 30483 0000442E 8A46FE                  		mov	al,[gsi_input]
 30484                                  		;sub	ah,ah
 30485                                  		;cmp	ax,1Bh
 30486 00004431 3C1B                    		cmp	al,1Bh ; ESCape key
 30487 00004433 7417                    		je	short gsi_9
 30488 00004435 7203                    		jb	short gsi_7
 30489 00004437 E9C801                  		jmp	gsi_29
 30490                                  gsi_7:
 30491 0000443A 08C0                    		or	al,al
 30492 0000443C 7503                    		jnz	short gsi_8
 30493 0000443E E9CD00                  		jmp	gsi_15
 30494                                  gsi_8:
 30495 00004441 2C08                    		sub	al,8
 30496 00004443 7426                    		jz	short gsi_11  ; 8, /* backspace */
 30497 00004445 2C05                    		sub	al,5
 30498 00004447 741B                    		jz	short gsi_10  ; 13, CR
 30499 00004449 E9B601                  		jmp	gsi_29 ; one of other (control) keys, invalid
 30500                                  gsi_9:
 30501                                  		;case ESC:
 30502 0000444C C646F601                		mov	byte [gsi_done],1 ; Done = TRUE
 30503 00004450 C45E08                  		les	bx,[gs_i_stringptr]
 30504 00004453 FF4608                  		inc	word [gs_i_stringptr]
 30505                                  		;mov	byte [es:bx],1Bh
 30506 00004456 268807                  		mov	[es:bx],al ; 1Bh
 30507                                  		;les	bx,[gs_i_stringptr]
 30508 00004459 43                      		inc	bx
 30509 0000445A FF4608                  		inc	word [gs_i_stringptr]
 30510 0000445D 26C60700                		mov	byte [es:bx],0
 30511 00004461 E9A101                  		jmp	gsi_30
 30512                                  gsi_10:	
 30513                                  		;case CR: ; 0Dh ; ENTER (Carriage Return) key
 30514 00004464 C646F601                		mov	byte [gsi_done],1 ; TRUE
 30515 00004468 E99A01                  		jmp	gsi_30 ; break;
 30516                                  gsi_11:
 30517                                  		; case 8: ; /* backspace */ 
 30518 0000446B 8B4606                  		mov	ax,[gs_i_startcol]
 30519 0000446E 3946E6                  		cmp	[gsi_col],ax
 30520 00004471 7703                    		ja	short gsi_12 ; if (Col > StartCol) 
 30521 00004473 E98C01                  		jmp	gsi_29 ; beep!
 30522                                  gsi_12:
 30523                                  		;push	word [gsi_row]
 30524 00004476 FE4EE6                  		dec	byte [gsi_col]
 30525                                  		;mov	ax,[gsi_col]
 30526                                  		;push	ax
 30527                                  		;sub	cx,cx
 30528                                  		;push	cx
 30529 00004479 8A76F0                  		mov	dh,[gsi_row]
 30530 0000447C 8A56E6                  		mov	dl,[gsi_col]
 30531 0000447F E89EE7                  		call	VIOSETCURPOS
 30532 00004482 C646FE20                		mov	byte [gsi_input],' '
 30533 00004486 FF76FA                  		push	word [gsi_input_ptr+2]
 30534 00004489 FF76F8                  		push	word [gsi_input_ptr]
 30535 0000448C B80100                  		mov	ax,1
 30536 0000448F 50                      		push	ax
 30537 00004490 FF76F0                  		push	word [gsi_row]
 30538 00004493 FF76E6                  		push	word [gsi_col]
 30539 00004496 FF76EE                  		push	word [gsi_attribute_ptr+2]
 30540 00004499 FF76EC                  		push	word [gsi_attribute_ptr]
 30541                                  		;sub	ax,ax
 30542                                  		;push	ax
 30543 0000449C E844D4                  		call	VIOWRTCHARSTRATT
 30544                                  		;push	[gsi_row]
 30545                                  		;push	[gsi_col]
 30546                                  		;sub	ax,ax
 30547                                  		;push	ax
 30548 0000449F 8A76F0                  		mov	dh,[gsi_row]
 30549 000044A2 8A56E6                  		mov	dl,[gsi_col]
 30550 000044A5 E878E7                  		call	VIOSETCURPOS
 30551 000044A8 FF4EF2                  		dec	word [gsi_workingptr]
 30552 000044AB 8B46F2                  		mov	ax,[gsi_workingptr]
 30553 000044AE 8B56F4                  		mov	dx,[gsi_workingptr+2]
 30554 000044B1 8946E8                  		mov	[gsi_deleteptr],ax
 30555 000044B4 8956EA                  		mov	[gsi_deleteptr+2],dx
 30556 000044B7 EB26                    		jmp	short gsi_14
 30557                                  gsi_13:	
 30558 000044B9 268A4701                		mov	al,[es:bx+1]
 30559 000044BD 268807                  		mov	[es:bx],al
 30560 000044C0 06                      		push	es
 30561 000044C1 53                      		push	bx
 30562 000044C2 B80100                  		mov	ax,1
 30563 000044C5 50                      		push	ax
 30564 000044C6 FF76F0                  		push	word [gsi_row]
 30565 000044C9 FF76E6                  		push	word [gsi_col]
 30566 000044CC FF76EE                  		push	word [gsi_attribute_ptr+2]
 30567 000044CF FF76EC                  		push	word [gsi_attribute_ptr]
 30568                                  		;sub	ax,ax
 30569                                  		;push	ax
 30570 000044D2 E80ED4                  		call	VIOWRTCHARSTRATT
 30571 000044D5 8B46E8                  		mov	ax,[gsi_deleteptr]
 30572 000044D8 8B56EA                  		mov	dx,[gsi_deleteptr+2]
 30573 000044DB 40                      		inc	ax
 30574 000044DC 8946E8                  		mov	[gsi_deleteptr],ax
 30575                                  
 30576                                  gsi_14:
 30577                                  		;while ( *(DeletePtr+1) != c('\0')  ) 
 30578                                  
 30579 000044DF C45EE8                  		les	bx,[gsi_deleteptr]
 30580 000044E2 26807F0100              		cmp	byte [es:bx+1],0
 30581 000044E7 75D0                    		jne	short gsi_13
 30582                                  	
 30583 000044E9 26C60700                		mov	byte [es:bx],0
 30584 000044ED C646FE20                		mov	byte [gsi_input],' '
 30585 000044F1 FF76FA                  		push	word [gsi_input_ptr+2]
 30586 000044F4 FF76F8                  		push	word [gsi_input_ptr]
 30587 000044F7 B80100                  		mov	ax,1
 30588 000044FA 50                      		push	ax
 30589 000044FB FF76F0                  		push	word [gsi_row]
 30590 000044FE 0346E6                  		add	ax,[gsi_col]
 30591 00004501 50                      		push	ax
 30592 00004502 FF76EE                  		push	word [gsi_attribute_ptr+2]
 30593 00004505 FF76EC                  		push	word [gsi_attribute_ptr]
 30594                                  		;sub	ax,ax
 30595                                  		;push	ax
 30596 00004508 E8D8D3                  		call	VIOWRTCHARSTRATT
 30597 0000450B E9F100                  		jmp	gsi_28
 30598                                  gsi_15:		
 30599                                  		;case  0: 
 30600                                   
 30601                                  		;mov	byte [regs_x_ax+1],7
 30602                                  		;mov	ax,regs_x_ax
 30603                                  		;push	ax
 30604                                  		;push	ax
 30605                                  		;call	intdos
 30606                                  		;pop	bx
 30607                                  		;pop	bx
 30608                                  		;mov	al,[regs_x_ax]
 30609                                  
 30610                                  		;DOS function
 30611                                  		;DIRECT CHARACTER INPUT, WITHOUT ECHO
 30612 0000450E B407                    		mov	ah,07h
 30613 00004510 CD21                    		int	21h
 30614 00004512 8846FE                  		mov	byte [gsi_input],al
 30615                                  
 30616                                  		;switch(input)
 30617                                  
 30618                                  		;sub	ah,ah
 30619 00004515 83F84F                  		cmp	ax,79  
 30620 00004518 7438                    		je	short gsi_19  ; /* END */
 30621 0000451A 7203                    		jb	short gsi_16
 30622 0000451C E9E300                  		jmp	gsi_29
 30623                                  gsi_16:
 30624 0000451F 2C47                    		sub	al,71
 30625 00004521 740B                    		je	short gsi_17 ; /* HOME */    
 30626 00004523 2C04                    		sub	al,4
 30627 00004525 7448                    		je	short gsi_21 ; 75, /* Cursor Left */	
 30628 00004527 2C02                    		sub	al,2
 30629 00004529 745A                    		je	short gsi_23 ; 77, /* Cursor Right */ 
 30630 0000452B E9D400                  		jmp	gsi_29	; one of other (control) keys, invalid
 30631                                  gsi_17:
 30632                                  		;case 71: /* HOME */    
 30633                                  
 30634 0000452E 8B4608                  		mov	ax,[gs_i_stringptr]
 30635 00004531 8B560A                  		mov	dx,[gs_i_stringptr+2]
 30636 00004534 8946F2                  		mov	[gsi_workingptr],ax
 30637 00004537 8956F4                  		mov	[gsi_workingptr+2],dx
 30638                                  		
 30639 0000453A 8B4604                  		mov	ax,[gs_i_startrow]
 30640 0000453D 8946F0                  		mov	[gsi_row],ax
 30641 00004540 8B4E06                  		mov	cx,[gs_i_startcol]
 30642 00004543 894EE6                  		mov	[gsi_col],cx
 30643                                  		;push	ax
 30644                                  		;push	cx
 30645                                  gsi_18:
 30646                                  		;sub	ax,ax
 30647                                  		;push	ax
 30648 00004546 8A76F0                  		mov	dh,[gsi_row]
 30649 00004549 8A56E6                  		mov	dl,[gsi_col]
 30650 0000454C E8D1E6                  		call	VIOSETCURPOS
 30651 0000454F E9B300                  		jmp	gsi_30
 30652                                  gsi_19:
 30653                                  		;case 79: ; /* END */   
 30654                                  		
 30655                                  		;while (*WorkingPtr != c('\0') ) 
 30656 00004552 C45EF2                  		les	bx,[gsi_workingptr]
 30657 00004555 26803F00                		cmp	byte [es:bx],0
 30658 00004559 7503                    		jne	short gsi_20
 30659 0000455B E9A700                  		jmp	gsi_30
 30660                                  gsi_20:	
 30661 0000455E FF46F2                  		inc	word [gsi_workingptr]
 30662                                  		;push	word [gsi_row]
 30663 00004561 FE46E6                  		inc	byte [gsi_col]
 30664                                  		;push	word [gsi_col]
 30665                                  		;sub	ax,ax
 30666                                  		;push	ax
 30667 00004564 8A76F0                  		mov	dh,[gsi_row]
 30668 00004567 8A56E6                  		mov	dl,[gsi_col]
 30669 0000456A E8B3E6                  		call	VIOSETCURPOS
 30670 0000456D EBE3                    		jmp	short gsi_19
 30671                                  gsi_21:
 30672                                  		;case 75: ; /* Cursor Left */
 30673                                  
 30674 0000456F 8B4606                  		mov	ax,[gs_i_startcol]
 30675 00004572 3946E6                  		cmp	[gsi_col],ax
 30676 00004575 7703                    		ja	short gsi_22  ; if (Col > StartCol)
 30677 00004577 E98800                  		jmp	gsi_29
 30678                                  gsi_22:	
 30679 0000457A FF4EF2                  		dec	word [gsi_workingptr]
 30680 0000457D FF76F0                  		push	word [gsi_row]
 30681 00004580 FE4EE6                  		dec	byte [gsi_col]
 30682                                  		;jmp	short gsi_25
 30683 00004583 EBC1                    		jmp	short gsi_18 ; 02/01/2019
 30684                                  gsi_23:
 30685                                  		;case 77: ; /* Cursor Right */ 
 30686                                  
 30687 00004585 C45EF2                  		les	bx,[gsi_workingptr]
 30688 00004588 26803F00                		cmp	byte [es:bx],0
 30689 0000458C 7502                    		jne	short gsi_24 ; if ( *WorkingPtr != c('\0') )
 30690 0000458E EB72                    		jmp	gsi_29
 30691                                  gsi_24:
 30692 00004590 FF46F2                  		inc	word [gsi_workingptr]
 30693 00004593 FF76F0                  		push	word [gsi_row]
 30694 00004596 FE46E6                  		inc	byte [gsi_col]
 30695                                  ;gsi_25:
 30696                                  		;push	word [gsi_col]
 30697 00004599 EBAB                    		jmp	short gsi_18
 30698                                  gsi_26:
 30699                                  		;else	/* input is >= 32 */
 30700                                  
 30701                                  		;input = dos_upper(input);
 30702 0000459B 8A46FE                  		mov	al,[gsi_input]
 30703                                  		;push	ax
 30704 0000459E E897E6                  		call	dos_upper
 30705                                  		;pop	bx
 30706 000045A1 8846FE                  		mov	[gsi_input],al
 30707                                  	
 30708                                  		;if ( (strchr(".\"/\\[]:|<>+=;,",input) == NULL) &&
 30709                                  		;   (Col < StartCol + MAX_STRING_INPUT_LENGTH))
 30710                                  
 30711                                  		;sub	ah,ah
 30712                                  		;push	ax
 30713                                  		;mov	ax,invstrchars ; ".\"/\\[]:|<>+=;,"
 30714                                  		;push	ax
 30715                                  		;call	strchr
 30716                                  		;pop	bx
 30717                                  		;pop	bx
 30718                                  
 30719                                  		; 01/01/2019
 30720 000045A4 BE[AD6F]                		mov	si,invstrchars ; ".\"/\\[]:|<>+=;,"
 30721                                  		;al = character to be searched in invstrchars		
 30722 000045A7 E87100                  		call	strchr
 30723                                  
 30724 000045AA 09C0                    		or	ax,ax
 30725 000045AC 7554                    		jnz	short gsi_29
 30726                                  
 30727                                  		;mov	ax,[gs_i_startcol]
 30728                                  		;add	ax,11	; MAX_STRING_INPUT_LENGTH = 11
 30729 000045AE 8B46E4                  		mov	ax,[gsi_endcol]
 30730 000045B1 3B46E6                  		cmp	ax,[gsi_col]		
 30731 000045B4 764C                    		jbe	short gsi_29
 30732                                  
 30733 000045B6 807EFE03                		cmp	byte [gsi_input],3
 30734 000045BA 7507                    		jne	short gsi_27
 30735                                  		
 30736                                  		;mov	ax,900
 30737                                  		;push	ax
 30738                                  		;mov	ax,400
 30739                                  		;push	ax
 30740 000045BC E888D3                  		call	DOSBEEP  ; 01/01/2019
 30741                                  
 30742 000045BF C646FE20                		mov	byte [gsi_input],' '
 30743                                  gsi_27:
 30744                                  		;VIOWRTCHARSTRATT(input_ptr,u(1),Row,Col,attribute_ptr,u(0));
 30745                                  
 30746 000045C3 FF76FA                  		push	word [gsi_input_ptr+2]
 30747 000045C6 FF76F8                  		push	word [gsi_input_ptr]
 30748 000045C9 B80100                  		mov	ax,1
 30749 000045CC 50                      		push	ax
 30750 000045CD FF76F0                  		push	word [gsi_row]
 30751 000045D0 FF76E6                  		push	word [gsi_col]
 30752 000045D3 FF76EE                  		push	word [gsi_attribute_ptr+2]
 30753 000045D6 FF76EC                  		push	word [gsi_attribute_ptr]
 30754                                  		;sub	ax,ax
 30755                                  		;push	ax
 30756 000045D9 E807D3                  		call	VIOWRTCHARSTRATT
 30757                                  
 30758 000045DC 8A46FE                  		mov	al,[gsi_input]
 30759 000045DF C45EF2                  		les	bx,[gsi_workingptr]
 30760 000045E2 268807                  		mov	[es:bx],al
 30761 000045E5 26C6470100              		mov	byte [es:bx+1],0
 30762                                  		;mov	ax,[gs_i_startcol]
 30763                                  		;add	ax,10
 30764 000045EA 8B46E4                  		mov	ax,[gsi_endcol]  ; modification
 30765 000045ED 48                      		dec	ax
 30766 000045EE 3B46E6                  		cmp	ax,[gsi_col]
 30767 000045F1 760C                    		jbe	short gsi_28
 30768 000045F3 FE46E6                  		inc	byte [gsi_col]
 30769 000045F6 8D4701                  		lea	ax,[bx+1]
 30770 000045F9 8946F2                  		mov	[gsi_workingptr],ax
 30771 000045FC 8C46F4                  		mov	[gsi_workingptr+2],es
 30772                                  gsi_28:
 30773                                  		;push	word [gsi_row]
 30774                                  		;jmp	gsi_25
 30775 000045FF E944FF                  		jmp	gsi_18
 30776                                  gsi_29:
 30777                                  		;mov	ax,900
 30778                                  		;push	ax
 30779                                  		;mov	ax,400
 30780                                  		;push	ax
 30781 00004602 E842D3                  		call	DOSBEEP  ; 01/01/2019
 30782                                  gsi_30:
 30783                                  		;if (!Done) 
 30784 00004605 807EF600                		cmp	byte [gsi_done],0
 30785                                  		;jne	short gsi_31
 30786 00004609 750A                    		jne	short gsi_32
 30787                                  
 30788                                  		;/* Get a character */
 30789                                  		;regs.h.ah = uc(0x07);
 30790                                  		;intdos(&regs,&regs);
 30791                                  		;input = regs.h.al;       
 30792                                  
 30793                                  		;mov	byte [regs_x_ax+1],7
 30794                                  		;mov	ax,regs_x_ax
 30795                                  		;push	ax
 30796                                  		;push	ax
 30797                                  		;call	intdos
 30798                                  		;pop	bx
 30799                                  		;pop	bx
 30800                                  		;mov	al,[regs_x_ax]
 30801                                  
 30802                                  		;DOS function
 30803                                  		;DIRECT CHARACTER INPUT, WITHOUT ECHO
 30804 0000460B B407                    		mov	ah,07h
 30805 0000460D CD21                    		int	21h		
 30806                                  
 30807 0000460F 8846FE                  		mov	[gsi_input],al
 30808                                  ;gsi_31:
 30809                                  		;while (!Done)
 30810                                  		;cmp	[gsi_done],0
 30811                                  		;jne	short gsi_32
 30812                                  	
 30813                                  		;/* Go handle different inputs */
 30814 00004612 E910FE                  		jmp	gsi_5
 30815                                  gsi_32:
 30816 00004615 89EC                    		mov	sp,bp
 30817 00004617 5D                      		pop	bp
 30818                                  		;retn
 30819 00004618 C20800                  		retn	8
 30820                                  
 30821                                  ; STRCHR.ASM (VCCRT2.ZIP) - Microsoft Visual C++ 1.0 Run-Time Library Sources
 30822                                  ; ----------------------------------------------------------------------------
 30823                                  ; Modified and simplified for NASM syntax by Erdogan Tan (01/01/2019)
 30824                                  
 30825                                  ;********
 30826                                  ;char *strchr(string, c) - search a string for a character
 30827                                  ;
 30828                                  ;Purpose:
 30829                                  ;	Searches a string for a given character, which may be the
 30830                                  ;	null character '\0'.
 30831                                  ;
 30832                                  ;	Algorithm:
 30833                                  ;	char *
 30834                                  ;	strchr (string, ch)
 30835                                  ;	      char *string, ch;
 30836                                  ;	      {
 30837                                  ;	      while (*string && *string != ch)
 30838                                  ;		      string++;
 30839                                  ;	      if (*string == ch)
 30840                                  ;		      return(string);
 30841                                  ;	      return((char *)0);
 30842                                  ;	      }
 30843                                  ;
 30844                                  ;Entry:
 30845                                  ;	char *string - string to search in
 30846                                  ;	char c - character to search for
 30847                                  ;
 30848                                  ;Exit:
 30849                                  ;	returns pointer to the first occurence of c in string
 30850                                  ;	returns NULL if c does not occur in string
 30851                                  ;
 30852                                  ;Uses:
 30853                                  ;
 30854                                  ;Exceptions:
 30855                                  ;
 30856                                  ;*******************************************************************************
 30857                                  
 30858                                  ; IBM PC-DOS 7.0 FDISDK.COM (unpacked) - Segfment 0, Offset 7264h
 30859                                  
 30860                                  strchr:
 30861                                  ;	%define strchr_string bp+4
 30862                                  ;	%define strchr_chr    bp+6	
 30863                                  ;
 30864                                  ;		push	bp
 30865                                  ;		mov	bp,sp
 30866                                  ;		;push	di 
 30867                                  ;
 30868                                  ;		mov	di,[strchr_string] ; di=pointer to string
 30869                                  ;		push	ds	; fix es for small/middle model
 30870                                  ;		pop	es
 30871                                  ;	
 30872                                  ;		mov	bx,di	; bx saves string pointer
 30873                                  ;		xor	ax,ax	; null byte to search for
 30874                                  ;		mov	cx,-1	; count bytes negatively in cx
 30875                                  ;		repne	scasb	; find string length by scanning for null
 30876                                  ;		not	cx	; cx=strlen+1
 30877                                  ;		mov	al,[str_chr] ; al=byte to search for
 30878                                  ;		mov	di,bx	; restore from saved string pointer
 30879                                  ;		repne	scasb	; find that byte (if it exists)!
 30880                                  ;
 30881                                  ;; if the repne scasb above terminates with the zero flag set, a match has
 30882                                  ;; been found and di points to the byte FOLLOWING the matching byte. if
 30883                                  ;; the zero flag is NOT set and the character being scanned for was NOT
 30884                                  ;; a null ('\0'), then the scan has failed. in the remaining case, which
 30885                                  ;; can only occur in large data models, the string must be exactly 0x10000
 30886                                  ;; bytes long (counting the terminal null character) and the very last byte
 30887                                  ;; is the match.
 30888                                  ;
 30889                                  ;		je	short retsuccess ; have a match, go do the return
 30890                                  ;
 30891                                  ;		xor	ax,ax	; no match, return NULL
 30892                                  ;		jmp	short toend
 30893                                  ;retsuccess:
 30894                                  ;		lea	ax,[di-1] ; ret value: pointer to matching byte
 30895                                  ;toend:
 30896                                  ;		;pop	di
 30897                                  ;		pop	bp
 30898                                  ;		retn
 30899                                  
 30900                                  		; INPUT:
 30901                                  		;   ds:si = address of string to search in 
 30902                                  		;   al = character to search for
 30903                                  		; OUTPUT:
 30904                                  		;   ax = pointer to the first occurence of chr in string
 30905                                  		;      = 0 if character does not occur in string	 	
 30906                                  
 30907                                  		;push	si
 30908                                  
 30909 0000461B 88C4                    		mov	ah,al
 30910                                  strchr_0:
 30911 0000461D AC                      		lodsb
 30912 0000461E 38E0                    		cmp	al,ah
 30913 00004620 7407                    		je	short strchr_2
 30914 00004622 20C0                    		and	al,al
 30915 00004624 75F7                    		jnz	short strchr_0
 30916 00004626 30E4                    		xor	ah,ah
 30917                                  strchr_1:
 30918                                  		;pop	si
 30919 00004628 C3                      		retn
 30920                                  strchr_2:
 30921 00004629 8D44FF                  		lea	ax,[si-1]
 30922                                  		;jmp	shott shrchr_1
 30923 0000462C C3                      		retn
 30924                                  
 30925                                  ; ----------------------------------------------------------------------------
 30926                                  ; input.c (FDISK, MSDOS 6.0, 1991)	
 30927                                  ; ----------------------------------------------------------------------------
 30928                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 02/01/2019)
 30929                                  
 30930                                  ;/*  */
 30931                                  ;char get_alpha_input(low_letter,high_letter,row,col,error_low_letter,error_high_letter)
 30932                                  ;
 30933                                  ;unsigned     row;
 30934                                  ;unsigned     col;
 30935                                  ;char         low_letter;
 30936                                  ;char         high_letter;
 30937                                  ;char         error_low_letter;
 30938                                  ;char         error_high_letter;
 30939                                  ;
 30940                                  ;BEGIN
 30941                                  ;
 30942                                  ;    char   input;
 30943                                  ;    char   default_used;
 30944                                  ;    char   input_value;
 30945                                  ;
 30946                                  ;    char            attribute;
 30947                                  ;    char far        *attribute_ptr = &attribute;
 30948                                  ;    char far *input_ptr = &input;
 30949                                  ;
 30950                                  ;    if (mono_flag == TRUE)
 30951                                  ;        attribute = HIWHITE_ON_BLACK; /*C09*/
 30952                                  ;    else
 30953                                  ;        attribute = HIWHITE_ON_BLUE;  /*C09*/
 30954                                  ;
 30955                                  ;    /* Assume bad input */
 30956                                  ;    valid_input = FALSE;
 30957                                  ;
 30958                                  ;    /* Init input_value to something non-alpha */
 30959                                  ;    input_value = c(0);                                              /* AC000 */
 30960                                  ;
 30961                                  ;    /* Loop until we get good stuff */
 30962                                  ;    while (valid_input == FALSE)
 30963                                  ;        BEGIN
 30964                                  ;
 30965                                  ;        /* position the cursor */
 30966                                  ;        VIOSETCURPOS(row,col,u(0));                                  /* AC000 */
 30967                                  ;
 30968                                  ;        /* Flush the keyboard buffer and get the next pressed key */
 30969                                  ;        input = get_char_input();
 30970                                  ;        input = dos_upper(input);
 30971                                  ;
 30972                                  ;        /* Go handle different inputs */
 30973                                  ;        switch(input)
 30974                                  ;            BEGIN
 30975                                  ;            case ESC:
 30976                                  ;                BEGIN
 30977                                  ;                valid_input = TRUE;
 30978                                  ;                break;
 30979                                  ;                END
 30980                                  ;
 30981                                  ;            case  CR:
 30982                                  ;                BEGIN
 30983                                  ;                /* See if it is digit and between given letters*/
 30984                                  ;                /* Do world trade get country information */
 30985                                  ;                input = dos_upper(input_value);                      /* AN000 */
 30986                                  ;                if ((isalpha(input))       &&
 30987                                  ;                    (input >= low_letter)  &&
 30988                                  ;                    (input <= high_letter) &&
 30989                                  ;                    (isalpha(input_value)))
 30990                                  ;                    BEGIN
 30991                                  ;                    valid_input = TRUE;
 30992                                  ;                    END
 30993                                  ;                else
 30994                                  ;                    BEGIN
 30995                                  ;                    if (isalpha(input_value))
 30996                                  ;                        BEGIN
 30997                                  ;                        /* Setup error message */
 30998                                  ;                        insert[0] = input;
 30999                                  ;                        insert[1] = error_low_letter;
 31000                                  ;                        insert[2] = c('-');                          /* AC000 */
 31001                                  ;                        insert[3] = error_high_letter;
 31002                                  ;                        display(error_23);
 31003                                  ;                        END
 31004                                  ;                    else
 31005                                  ;                        BEGIN
 31006                                  ;                        insert[0] = error_low_letter;
 31007                                  ;                        insert[1] = c('-');                          /* AC000 */
 31008                                  ;                        insert[2] = error_high_letter;
 31009                                  ;                        display(error_31);
 31010                                  ;                        END
 31011                                  ;                    END
 31012                                  ;                break;
 31013                                  ;                END
 31014                                  ;
 31015                                  ;            default:
 31016                                  ;                BEGIN
 31017                                  ;
 31018                                  ;                if ((isalpha(input))       &&                           /*C16*/
 31019                                  ;                    (dos_upper(input) >= low_letter)  &&                /*C16*/
 31020                                  ;                    (dos_upper(input) <= high_letter))                  /*C16*/
 31021                                  ;                    clear_screen(u(23),u(0),u(23),u(79));               /*C16*/
 31022                                  ;                else                                                    /*C16*/
 31023                                  ;                    {                                                   /*C16*/
 31024                                  ;                    if (isalpha(input))                                 /*C16*/
 31025                                  ;                        {                                               /*C16*/
 31026                                  ;                        /* Setup error message */                       /*C16*/
 31027                                  ;                        insert[0] = input;                              /*C16*/
 31028                                  ;                        insert[1] = error_low_letter;                   /*C16*/
 31029                                  ;                        insert[2] = c('-');                             /*C16*/
 31030                                  ;                        insert[3] = error_high_letter;                  /*C16*/
 31031                                  ;                        display(error_23);                              /*C16*/
 31032                                  ;                        }                                               /*C16*/
 31033                                  ;                    else                                                /*C16*/
 31034                                  ;                        {                                               /*C16*/
 31035                                  ;                        insert[0] = error_low_letter;                   /*C16*/
 31036                                  ;                        insert[1] = c('-');                             /*C16*/
 31037                                  ;                        insert[2] = error_high_letter;                  /*C16*/
 31038                                  ;                        display(error_31);                              /*C16*/
 31039                                  ;                        }                                               /*C16*/
 31040                                  ;                    input = c(' ');                                     /*C16*/
 31041                                  ;                    }                                                   /*C16*/
 31042                                  ;                VIOWRTCHARSTRATT(input_ptr,u(1),row,col,attribute_ptr,u(0)); /*C16*/
 31043                                  ;                default_used = FALSE;
 31044                                  ;                input_value = input;
 31045                                  ;                break;
 31046                                  ;                END
 31047                                  ;            END
 31048                                  ;        END
 31049                                  ;    return(input);
 31050                                  ;END
 31051                                  		
 31052                                  get_alpha_input:
 31053                                  		; 02/01/2019
 31054                                  
 31055                                  	;%define gai_input_value   bp-16
 31056                                  	%define gai_attributeptr   bp-14
 31057                                  	;%define gai_attributeptr2 bp-12
 31058                                  	%define gai_input_value    bp-10
 31059                                  	;%define gai_default_used  bp-10
 31060                                  	%define gai_input_ptr	   bp-8
 31061                                  	;%define gai_input_ptr2	   bp-6
 31062                                  	%define gai_attribute	   bp-4
 31063                                  	%define gai_input	   bp-2
 31064                                  
 31065                                  	%define ga_i_low_letter	   bp+4
 31066                                  	%define ga_i_high_letter   bp+6
 31067                                  	%define ga_i_row	   bp+8
 31068                                  	%define ga_i_col	   bp+10
 31069                                  	%define ga_i_err_low_lett  bp+12
 31070                                  	%define ga_i_err_high_lett bp+14
 31071                                  
 31072 0000462D 55                      		push	bp
 31073 0000462E 89E5                    		mov	bp,sp
 31074                                  		;sub	sp,16
 31075 00004630 83EC0E                  		sub	sp,14
 31076                                  
 31077 00004633 8D46FC                  		lea	ax,[gai_attribute]
 31078 00004636 8946F2                  		mov	[gai_attributeptr],ax
 31079 00004639 8C56F4                  		mov	[gai_attributeptr+2],ss
 31080 0000463C 8D4EFE                  		lea	cx,[gai_input]
 31081 0000463F 894EF8                  		mov	[gai_input_ptr],cx
 31082 00004642 8C56FA                  		mov	[gai_input_ptr+2],ss
 31083                                  		
 31084 00004645 803E[D8C3]01            		cmp	byte [mono_flag],1 ; TRUE
 31085 0000464A 7506                    		jne	short gai_1
 31086 0000464C C646FC0F                		mov	byte [gai_attribute],0Fh ;HIWHITE_ON_BLACK
 31087 00004650 EB04                    		jmp	short gai_2
 31088                                  gai_1:
 31089 00004652 C646FC1F                		mov	byte [gai_attribute],1Fh ;HIWHITE_ON_BLUE
 31090                                  gai_2:
 31091 00004656 28C0                    		sub	al,al  ;0
 31092                                  
 31093                                  		;/* Assume bad input */
 31094                                  
 31095 00004658 A2[ECCB]                		mov	[valid_input],al ; 0
 31096                                  gai_3:
 31097                                  		;/* Init input_value to something non-alpha */
 31098                                  
 31099 0000465B 8846F6                  		mov	[gai_input_value],al ; 0
 31100                                  gai_4:
 31101                                  		;/* Loop until we get good stuff */
 31102                                  
 31103 0000465E 803E[ECCB]00            		cmp	byte [valid_input],0 ; FALSE
 31104                                  		;je	short gai_5
 31105                                  		;jmp	gai_17 
 31106 00004663 7544                    		jne	short gai_17 ; 03/01/2019
 31107                                  gai_5:
 31108                                  		;/* position the cursor */
 31109                                  
 31110                                  		;push	word [ga_i_row]
 31111                                  		;push	word [ga_i_col]
 31112                                  		;sub	ax,ax
 31113                                  		;push	ax
 31114                                  
 31115 00004665 8A7608                  		mov	dh,[ga_i_row]
 31116 00004668 8A560A                  		mov	dl,[ga_i_col]
 31117                                  
 31118 0000466B E8B2E5                  		call	VIOSETCURPOS
 31119                                  
 31120                                  	;/* Flush the keyboard buffer and get the next pressed key */
 31121                                  
 31122 0000466E E8A2E5                  		call	get_char_input
 31123                                  		;mov	[gai_input],al
 31124                                  		;push	ax
 31125 00004671 E8C4E5                  		call	dos_upper ; ***
 31126                                  		;pop	bx
 31127 00004674 8846FE                  		mov	[gai_input],al
 31128                                  		
 31129                                  		;/* Go handle different inputs */
 31130                                  
 31131 00004677 98                      		cbw
 31132 00004678 89C3                    		mov	bx,ax ; bl = [gai_input]
 31133                                  
 31134                                  		;switch(input)
 31135                                  
 31136                                  		;cbw
 31137                                  		;sub	ax,0Dh
 31138 0000467A 2C0D                    		sub	al,0Dh ; sub al,13
 31139 0000467C 7431                    		jz	short gai_9 ; 13, CR
 31140                                  		;sub	ax,0Eh
 31141 0000467E 2C0E                    		sub	al,0Eh ; sub al,14
 31142 00004680 744B                    		jz	short gai_8 ; 27, ESC 
 31143                                  
 31144                                  		;mov	al,[gai_input]
 31145                                  		;cbw
 31146                                  		;mov	bx,ax
 31147                                  
 31148 00004682 F687[0A9F]03            		test	byte [isdigit+bx],3
 31149                                  		;jz	short gai_6
 31150 00004687 0F84A100                		jz	gai_14
 31151                                  
 31152                                  		;;push	ax
 31153                                  		;call	dos_upper
 31154                                  		;;pop	bx
 31155                                  		
 31156                                  		;cmp	al,[ga_i_low_letter]
 31157 0000468B 3A5E04                  		cmp	bl,[ga_i_low_letter]
 31158 0000468E 7C05                    		jl	short gai_6
 31159                                  		;;mov	al,[gai_input]
 31160                                  		;;push	ax
 31161                                  		;call	dos_upper
 31162                                  		;;pop	bx
 31163                                  		;cmp	al,[ga_i_high_letter]
 31164 00004690 3A5E06                  		cmp	bl,[ga_i_high_letter]
 31165 00004693 7E02                    		jle	short gai_7
 31166                                  gai_6:
 31167 00004695 EB79                    		jmp	gai_13
 31168                                  gai_7:
 31169 00004697 B84F00                  		mov	ax,79
 31170 0000469A 50                      		push	ax
 31171 0000469B B81700                  		mov	ax,23
 31172 0000469E 50                      		push	ax
 31173 0000469F 29C9                    		sub	cx,cx
 31174 000046A1 51                      		push	cx
 31175 000046A2 50                      		push	ax
 31176 000046A3 E8F0CD                  		call	clear_screen
 31177                                  		;add	sp,8
 31178                                  		
 31179 000046A6 E9A000                  		jmp	gai_16
 31180                                  		
 31181                                  		; 03/01/2019
 31182                                  gai_17:
 31183                                  		;mov	al,[gai_input]
 31184 000046A9 89EC                    		mov	sp,bp
 31185 000046AB 5D                      		pop	bp
 31186                                  		;retn
 31187 000046AC C20C00                  		retn	12
 31188                                  
 31189                                  ;gai_8:
 31190                                  ;		mov	byte [valid_input],1
 31191                                  ;		;jmp	short gai_4
 31192                                  ;		mov	al,bl ; mov al,[gai_input]
 31193                                  ;		jmp	short gai_17
 31194                                  gai_9:
 31195                                  		;/* See if it is digit and between given letters*/
 31196                                  		;/* Do world trade get country information */
 31197                                  
 31198 000046AF 8A46F6                  		mov	al,[gai_input_value]
 31199                                  
 31200                                  		; (AL has already uppercase character) ; ***
 31201                                  		; (gai_5 -> gai_7 -> gai_16 -> gai_3 -> gai_5 -> gai_9)
 31202                                  		;;push	ax
 31203                                  		;call	dos_upper
 31204                                  		;;pop	bx
 31205                                  
 31206                                  		;if (isalpha(input))
 31207                                  
 31208 000046B2 8846FE                  		mov	[gai_input],al ; the char just prior to CR
 31209 000046B5 98                      		cbw
 31210 000046B6 89C3                    		mov	bx,ax
 31211 000046B8 F687[0A9F]03            		test	byte [isdigit+bx],3
 31212                                  		;jz	short gai_10
 31213 000046BD 7435                    		jz	short gai_11
 31214                                  
 31215 000046BF 8A4604                  		mov	al,[ga_i_low_letter]
 31216                                  		;cmp	[gai_input],al
 31217 000046C2 38C3                    		cmp	bl,al
 31218 000046C4 7C10                    		jl	short gai_10
 31219 000046C6 8A4606                  		mov	al,[ga_i_high_letter]
 31220                                  		;cmp	[gai_input],al	
 31221 000046C9 38C3                    		cmp	bl,al
 31222 000046CB 7F09                    		jg	short gai_10
 31223                                  		
 31224                                  		;mov	al,[gai_input_value]
 31225                                  		;cbw
 31226                                  		;mov	bx,ax
 31227                                  		;test	[isdigit+bx],3
 31228                                  		;jnz	short gai_8
 31229                                  
 31230                                  		;jmp	short gai_8
 31231                                  gai_8:
 31232 000046CD C606[ECCB]01            		mov	byte [valid_input],1 ; TRUE
 31233                                  		;jmp	short gai_4
 31234 000046D2 88D8                    		mov	al,bl ; mov al,[gai_input]
 31235 000046D4 EBD3                    		jmp	short gai_17 ; 03/01/2019
 31236                                  gai_10:
 31237                                  		;/* Setup error message */    
 31238                                  
 31239                                  		;mov	al,[gai_input_value]
 31240                                  		;cbw
 31241                                  		;mov	bx,ax
 31242                                  		;test	[isdigit+bx],3
 31243                                  		;jz	short gai_11
 31244                                  		
 31245 000046D6 8A46FE                  		mov	al,[gai_input]
 31246 000046D9 A2[F4CC]                		mov	[insert],al
 31247 000046DC 8A460C                  		mov	al,[ga_i_err_low_lett]
 31248 000046DF A2[F5CC]                		mov	[insert+1],al
 31249 000046E2 C606[F6CC]2D            		mov	byte [insert+2],'-'
 31250 000046E7 8A460E                  		mov	al, [ga_i_err_high_lett]
 31251 000046EA A2[F7CC]                		mov	[insert+3],al
 31252                                  		;push	word [error_23_seg]
 31253 000046ED 1E                      		push	ds
 31254 000046EE FF36[AC9E]              		push	word [error_23_off]
 31255 000046F2 EB16                    		jmp	short gai_12
 31256                                  gai_11:
 31257 000046F4 8A460C                  		mov	al,[ga_i_err_low_lett]
 31258 000046F7 A2[F4CC]                		mov	[insert],al
 31259 000046FA C606[F5CC]2D            		mov	byte [insert+1],'-'
 31260 000046FF 8A460E                  		mov	al,[ga_i_err_high_lett]
 31261 00004702 A2[F6CC]                		mov	[insert+2],al
 31262                                  		;push	word [error_31_seg]
 31263 00004705 1E                      		push	ds
 31264 00004706 FF36[BC9E]              		push	word [error_31_off]
 31265                                  gai_12:
 31266 0000470A E817CF                  		call	display
 31267                                  		;pop	bx
 31268                                  		;pop	bx
 31269                                  		; 03/01/2019
 31270                                  		;jmp	gai_4
 31271 0000470D E955FF                  		jmp	gai_5 ; [valid_input] = 0
 31272                                  gai_13:
 31273                                  		;;mov	al,[gai_input]
 31274                                  		;;cbw
 31275                                  		;;mov	bx,ax
 31276                                  		;mov	bl,[gai_input]
 31277                                  		;xor	bh,bh
 31278                                  		;test	byte [isdigit+bx],3
 31279                                  		;jz	short gai_14
 31280                                  
 31281                                  		;/* Setup error message */        
 31282                                  
 31283                                  		;mov	[insert],al
 31284 00004710 881E[F4CC]              		mov	[insert],bl
 31285 00004714 8A460C                  		mov	al,[ga_i_err_low_lett]
 31286 00004717 A2[F5CC]                		mov	[insert+1],al
 31287 0000471A C606[F6CC]2D            		mov	byte [insert+2],'-'
 31288 0000471F 8A460E                  		mov	al,[ga_i_err_high_lett]
 31289 00004722 A2[F7CC]                		mov	[insert+3],al
 31290                                  		;push	word [error_23_seg]
 31291 00004725 1E                      		push	ds
 31292 00004726 FF36[AC9E]              		push	word [error_23_off]
 31293 0000472A EB16                    		jmp	short gai_15
 31294                                  gai_14:
 31295 0000472C 8A460C                  		mov	al,[ga_i_err_low_lett]
 31296 0000472F A2[F4CC]                		mov	[insert],al
 31297 00004732 C606[F5CC]2D            		mov	byte [insert+1],'-'
 31298 00004737 8A460E                  		mov	al,[ga_i_err_high_lett]
 31299 0000473A A2[F6CC]                		mov	[insert+2],al
 31300                                  		;push	word [error_31_seg]
 31301 0000473D 1E                      		push	ds
 31302 0000473E FF36[BC9E]              		push	word [error_31_off]
 31303                                  gai_15:
 31304 00004742 E8DFCE                  		call	display
 31305                                  		;pop	bx
 31306                                  		;pop	bx
 31307 00004745 C646FE20                		mov	byte [gai_input],' '
 31308                                  gai_16:
 31309                                  	;VIOWRTCHARSTRATT(input_ptr,u(1),row,col,attribute_ptr,u(0));
 31310                                  
 31311 00004749 FF76FA                  		push	word [gai_input_ptr+2]
 31312 0000474C FF76F8                  		push	word [gai_input_ptr]
 31313 0000474F B80100                  		mov	ax,1
 31314 00004752 50                      		push	ax
 31315 00004753 FF7608                  		push	word [ga_i_row]
 31316 00004756 FF760A                  		push	word [ga_i_col]
 31317 00004759 FF76F4                  		push	word [gai_attributeptr+2]
 31318 0000475C FF76F2                  		push	word [gai_attributeptr]
 31319                                  		;sub	ax,ax
 31320                                  		;push	ax
 31321 0000475F E881D1                  		call	VIOWRTCHARSTRATT
 31322                                  		;mov	byte [gai_default_used],0  ;FALSE
 31323 00004762 8A46FE                  		mov	al,[gai_input]
 31324 00004765 E9F3FE                  		jmp	gai_3
 31325                                  ;gai_17:
 31326                                  ;		;mov	al,[gai_input]
 31327                                  ;		mov	sp,bp
 31328                                  ;		pop	bp
 31329                                  ;		;retn
 31330                                  ;		retn	12
 31331                                  
 31332                                  ; ----------------------------------------------------------------------------
 31333                                  ; rempart.c (FDISK, MSDOS 6.0, 1991)	
 31334                                  ; ----------------------------------------------------------------------------
 31335                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 02/01/2019)
 31336                                  
 31337                                  ;void remove_partition(drive,entry)
 31338                                  ;
 31339                                  ;char        drive;
 31340                                  ;unsigned    entry;
 31341                                  ;
 31342                                  ;BEGIN
 31343                                  ;
 31344                                  ;    /* Set Partition entry to zero */
 31345                                  ;    part_table[drive][entry].boot_ind = uc(0);
 31346                                  ;    part_table[drive][entry].start_head = uc(0);
 31347                                  ;    part_table[drive][entry].start_sector = uc(0);
 31348                                  ;    part_table[drive][entry].start_cyl = u(0);
 31349                                  ;    part_table[drive][entry].sys_id = uc(0);
 31350                                  ;    part_table[drive][entry].end_head = uc(0);
 31351                                  ;    part_table[drive][entry].end_sector = uc(0);
 31352                                  ;    part_table[drive][entry].end_cyl = u(0);
 31353                                  ;    part_table[drive][entry].rel_sec = ul(0);
 31354                                  ;    part_table[drive][entry].num_sec = ul(0);
 31355                                  ;    part_table[drive][entry].changed = (FLAG)TRUE;
 31356                                  ;    part_table[drive][entry].mbytes_used = f(0);
 31357                                  ;    part_table[drive][entry].percent_used = u(0);
 31358                                  ;
 31359                                  ;    strcpy(part_table[drive][entry].system,c(NUL));
 31360                                  ;    strcpy(part_table[drive][entry].vol_label,c(NUL));
 31361                                  ;
 31362                                  ;    return;
 31363                                  ;END
 31364                                  
 31365                                  remove_partition:
 31366                                  		; 02/01/2019
 31367                                  
 31368                                  	;%define rmp_drive bp+4
 31369                                  	;%define rmp_entry bp+6
 31370                                  
 31371                                  		;push	bp
 31372                                  		;mov	bp,sp
 31373                                  		;push	si
 31374                                  
 31375                                  		; INPUT:
 31376                                  		;   AL = Disk number (0 to 7)
 31377                                  		;   AH = Partition entry number (0 to 3)
 31378                                  
 31379                                  		;mov	al,[rmp_drive]
 31380                                  		;cbw
 31381                                  		;shl	ax,1
 31382                                  		;shl	ax,1
 31383                                  		;add	ax,[rmp_entry]
 31384                                  
 31385 00004768 D0E0                    		shl	al,1
 31386 0000476A D0E0                    		shl	al,1
 31387 0000476C 00E0                    		add	al,ah
 31388                                  
 31389                                  		;mov	cx,46
 31390                                  		;mul	cx
 31391                                  
 31392 0000476E B12E                    		mov	cl,46
 31393 00004770 F6E1                    		mul	cl		
 31394 00004772 89C3                    		mov	bx,ax
 31395                                  		;sub	al,al
 31396 00004774 29C0                    		sub	ax,ax
 31397 00004776 8887[20C4]              		mov	[part_table_boot_ind+bx],al
 31398 0000477A 8887[21C4]              		mov	[part_table_start_head+bx],al
 31399 0000477E 8887[22C4]              		mov	[part_table_start_sector+bx],al
 31400 00004782 8987[23C4]              		mov	[part_table_start_cyl+bx],ax ; 0
 31401 00004786 8887[25C4]              		mov	[part_table_sys_id+bx],al
 31402 0000478A 8887[26C4]              		mov	[part_table_end_head+bx],al
 31403 0000478E 8887[27C4]              		mov	[part_table_end_sector+bx],al
 31404 00004792 8987[28C4]              		mov	[part_table_end_cyl+bx],ax ; 0
 31405                                  		;sub	ax,ax
 31406 00004796 8987[2CC4]              		mov	[part_table_rel_sec_hw+bx],ax
 31407 0000479A 8987[2AC4]              		mov	[part_table_rel_sec_lw+bx],ax
 31408 0000479E 8987[30C4]              		mov	[part_table_num_sec_hw+bx],ax
 31409 000047A2 8987[2EC4]              		mov	[part_table_num_sec_lw+bx],ax
 31410 000047A6 C687[33C4]01            		mov	byte [part_table_changed+bx],1
 31411 000047AB 8987[34C4]              		mov	[part_table_mbytes_used+bx],ax
 31412 000047AF 8987[36C4]              		mov	[part_table_percent_used+bx],ax
 31413                                  
 31414                                  		;push	ax
 31415                                  		;mov	cx,bx
 31416                                  		;add	bx,part_table_system
 31417                                  		;push	bx
 31418                                  		;mov	si,cx
 31419                                  		;call	strcpy
 31420                                  		;pop	bx
 31421                                  		;pop	bx
 31422                                  
 31423                                  		;sub	ax,ax
 31424                                  		;push	ax
 31425                                  		;add	si,part_table_vol_label
 31426                                  		;push	si
 31427                                  		;call	strcpy
 31428                                  		;pop	bx
 31429                                  		;pop	bx
 31430                                  
 31431                                  		; 02/01/2019
 31432                                  		;xor	al,al
 31433                                  		;push	ds
 31434                                  		;pop	es
 31435 000047B3 BF[38C4]                		mov	di,part_table_vol_label
 31436 000047B6 01DF                    		add	di,bx
 31437 000047B8 B91500                  		mov	cx,12+9 ; 21
 31438 000047BB F3AA                    		rep	stosb
 31439 000047BD C3                      		retn		
 31440                                  
 31441                                  		;pop	si
 31442                                  		;mov	sp,bp
 31443                                  		;pop	bp
 31444                                  		;retn
 31445                                  		;retn	4
 31446                                  
 31447                                  ; ----------------------------------------------------------------------------
 31448                                  		
 31449                                  ;void remove_volume(drive,entry)
 31450                                  ;
 31451                                  ;char        drive;
 31452                                  ;unsigned    entry;
 31453                                  ;
 31454                                  ;BEGIN
 31455                                  ;
 31456                                  ;    /* Set volume entry to zero */
 31457                                  ;    ext_table[drive][entry].boot_ind = uc(0);
 31458                                  ;    ext_table[drive][entry].start_head = uc(0);
 31459                                  ;    ext_table[drive][entry].start_sector = uc(0);
 31460                                  ;    ext_table[drive][entry].start_cyl = u(0);
 31461                                  ;    ext_table[drive][entry].sys_id = uc(0);
 31462                                  ;    ext_table[drive][entry].end_head = uc(0);
 31463                                  ;    ext_table[drive][entry].end_sector = uc(0);
 31464                                  ;    ext_table[drive][entry].end_cyl = u(0);
 31465                                  ;    ext_table[drive][entry].rel_sec = ul(0);
 31466                                  ;    ext_table[drive][entry].num_sec = ul(0);
 31467                                  ;    ext_table[drive][entry].mbytes_used = f(0);
 31468                                  ;    ext_table[drive][entry].percent_used = u(0);
 31469                                  ;    ext_table[drive][entry].changed = TRUE;
 31470                                  ;    ext_table[drive][entry].drive_letter = NUL;
 31471                                  ;
 31472                                  ;    strcpy(ext_table[drive][entry].system,c(NUL));
 31473                                  ;    strcpy(ext_table[drive][entry].vol_label,c(NUL));
 31474                                  ;
 31475                                  ;    return;
 31476                                  ;END
 31477                                  
 31478                                  remove_volume:
 31479                                  		; 02/01/2019
 31480                                  
 31481                                  	;%define rmv_drive bp+4
 31482                                  	;%define rmv_entry bp+6
 31483                                  
 31484                                  		;push	bp
 31485                                  		;mov	bp,sp
 31486                                  		;push	si
 31487                                  
 31488                                  		; INPUT:
 31489                                  		;   AL = Disk number (0 to 7)
 31490                                  		;   CL = Partition entry number (0 to 3)
 31491                                  
 31492                                  		;mov	al,24
 31493                                  		;imul	byte [rmv_drive]
 31494                                  
 31495 000047BE B418                    		mov	ah,24
 31496 000047C0 F6E4                    		mul	ah
 31497 000047C2 00C8                    		add	al,cl
 31498                                  		
 31499                                  		;mov	cx,46
 31500                                  		;mul	cx
 31501 000047C4 B12E                    		mov	cl,46
 31502 000047C6 F6E1                    		mul	cl
 31503 000047C8 89C3                    		mov	bx,ax
 31504                                  		;sub	al,al
 31505 000047CA 29C0                    		sub	ax,ax
 31506 000047CC 8887[58A1]              		mov	[ext_table_boot_ind+bx],al
 31507 000047D0 8887[59A1]              		mov	[ext_table_start_head+bx],al
 31508 000047D4 8887[5AA1]              		mov	[ext_table_start_sector+bx],al
 31509 000047D8 8987[5BA1]              		mov	[ext_table_start_cyl+bx],ax ; 0
 31510 000047DC 8887[5DA1]              		mov	[ext_table_sys_id+bx],al
 31511 000047E0 8887[5EA1]              		mov	[ext_table_end_head+bx],al
 31512 000047E4 8887[5FA1]              		mov	[ext_table_end_sector+bx],al
 31513 000047E8 8987[60A1]              		mov	[ext_table_end_cyl+bx],ax ; 0
 31514                                  		;sub	ax,ax
 31515 000047EC 8987[64A1]              		mov	[ext_table_rel_sec_hw+bx],ax
 31516 000047F0 8987[62A1]              		mov	[ext_table_rel_sec_lw+bx],ax
 31517 000047F4 8987[68A1]              		mov	[ext_table_num_sec_hw+bx],ax
 31518 000047F8 8987[66A1]              		mov	[ext_table_num_sec_lw+bx],ax
 31519 000047FC 8987[6CA1]              		mov	[ext_table_mbytes_used+bx],ax
 31520 00004800 8987[6EA1]              		mov	[ext_table_percent_used+bx],ax
 31521 00004804 C687[6BA1]01            		mov	byte [ext_table_changed+bx],1
 31522 00004809 8987[85A1]              		mov	[ext_table_drive_letter+bx],ax ; 0
 31523                                  		
 31524                                  		;push	ax
 31525                                  		;mov	cx,bx
 31526                                  		;add	bx,ext_table_system
 31527                                  		;push	bx
 31528                                  		;mov	si,cx
 31529                                  		;call	strcpy
 31530                                  		;pop	bx
 31531                                  		;pop	bx
 31532                                  
 31533                                  		;sub	ax,ax
 31534                                  		;push	ax
 31535                                  		;add	si,ext_table_vol_label
 31536                                  		;push	si
 31537                                  		;call	strcpy
 31538                                  		;pop	bx
 31539                                  		;pop	bx
 31540                                  
 31541                                  		; 02/01/2019
 31542                                  		;xor	al,al
 31543                                  		;push	ds
 31544                                  		;pop	es
 31545 0000480D BF[70A1]                		mov	di,ext_table_vol_label
 31546 00004810 01DF                    		add	di,bx
 31547 00004812 B91500                  		mov	cx,12+9 ; 21
 31548 00004815 F3AA                    		rep	stosb
 31549 00004817 C3                      		retn		
 31550                                  
 31551                                  		;pop	si
 31552                                  		;mov	sp,bp
 31553                                  		;pop	bp
 31554                                  		;retn
 31555                                  		;retn	4
 31556                                  
 31557                                  ; ----------------------------------------------------------------------------
 31558                                  ; partinfo.c (FDISK, MSDOS 6.0, 1991)	
 31559                                  ; ----------------------------------------------------------------------------
 31560                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 02/01/2019)
 31561                                  
 31562                                  ;char get_num_logical_dos_drives()
 31563                                  ;BEGIN
 31564                                  ;
 31565                                  ;char   i;
 31566                                  ;char number;
 31567                                  ;
 31568                                  ;   number = c(0);
 31569                                  ;   /* See if there is a logical drive defined in Extended Partition */
 31570                                  ;   for (i = c(0); i < c(23);i++)
 31571                                  ;      BEGIN
 31572                                  ;        /* See if we find a sys id that is DOS */
 31573                                  ;       if ((ext_table[cur_disk][i].sys_id == uc(DOS12)) || (ext_table[cur_disk][i].sys_id == uc(DOS16)) ||
 31574                                  ;          (ext_table[cur_disk][i].sys_id == uc(DOSNEW))) 
 31575                                  ;          BEGIN
 31576                                  ;           number++;
 31577                                  ;          END
 31578                                  ;      END
 31579                                  ;    return(number);
 31580                                  ;END
 31581                                  
 31582                                  get_num_logical_dos_drives:
 31583                                  		
 31584                                  		; 02/01/2019
 31585                                  
 31586                                  	;%define gnldd_i      bp-4
 31587                                  	;%define gnldd_number bp-2
 31588                                  
 31589                                  		;push	bp
 31590                                  		;mov	bp,sp
 31591                                  		;sub	sp,4
 31592                                  
 31593                                  		;sub	al,al
 31594                                  		;mov	[gnldd_number],al
 31595                                  		;mov	[gnldd_i], al
 31596                                  		
 31597 00004818 31D2                    		xor	dx,dx  ; 0
 31598                                  		;jmp	short gnldd_4
 31599                                  gnldd_1:
 31600                                  		;mov	al,[gnldd_i]
 31601                                  ;gnldd_4:
 31602                                  		;cbw
 31603                                  		;mov	cx,ax
 31604 0000481A B018                    		mov	al,24
 31605                                  		;imul	byte [cur_disk]
 31606 0000481C F626[E2CB]              		mul	byte [cur_disk]
 31607                                  		;add	ax,cx
 31608 00004820 00D0                    		add	al,dl ; [gnldd_i]
 31609                                  		;mov	cx,46
 31610                                  		;imul	cx
 31611 00004822 B12E                    		mov	cl,46
 31612 00004824 F6E1                    		mul	cl
 31613 00004826 89C3                    		mov	bx,ax
 31614 00004828 8A87[5DA1]              		mov	al,[ext_table_sys_id+bx]
 31615                                  		;cmp	byte [ext_table_sys_id+bx],1 ; DOS12
 31616 0000482C 3C01                    		cmp	al,1
 31617 0000482E 7408                    		je	short gnldd_2
 31618                                  		;cmp	byte [ext_table_sys_id+bx],4 ; DOS16
 31619 00004830 3C04                    		cmp	al,4
 31620 00004832 7404                    		je	short gnldd_2
 31621                                  		;cmp	byte [ext_table_sys_id+bx],6 ; DOSNEW (FAT16 big)
 31622 00004834 3C06                    		cmp	al,6
 31623 00004836 7502                    		jne	short gnldd_3
 31624                                  gnldd_2:
 31625                                  		;inc	byte [gnldd_number]
 31626 00004838 FEC6                    		inc	dh
 31627                                  gnldd_3:
 31628                                  		;inc	byte [gnldd_i]
 31629 0000483A FEC2                    		inc	dl
 31630                                  ;gnldd_4:
 31631                                  		;cmp	byte [gnldd_i],23
 31632 0000483C 80FA17                  		cmp	dl,23
 31633 0000483F 7CD9                    		jl	short gnldd_1
 31634                                  
 31635                                  		;mov	al,[gnldd_number]
 31636                                  
 31637 00004841 88F0                    		mov	al,dh ; [gnldd_number]
 31638                                  
 31639                                  		;xor	dx,dx
 31640                                  
 31641                                  		;mov	sp,bp
 31642                                  		;pop	bp
 31643                                  
 31644 00004843 C3                      		retn
 31645                                  
 31646                                  ; ============================================================================
 31647                                  ;  CREATE PARTITION
 31648                                  ; ============================================================================
 31649                                  ; 13/01/2019
 31650                                  
 31651                                  ; fdisk.msg (MSDOS 6.0)
 31652                                  ;/***************************************************************************************************/
 31653                                  ;/* Screen for CREATE_PARTITION                                                                     */
 31654                                  ;/*                                                                                                 */
 31655                                  ;/*     |00000000001111111111222222222233333333334444444444555555555566666666667777777777|          */
 31656                                  ;/*     |01234567890123456789012345678901234567890123456789012345678901234567890123456789|          */
 31657                                  ;/*   --|--------------------------------------------------------------------------------|          */
 31658                                  ;/*   00|                                                                                |          */
 31659                                  ;/*   01|                                                                                |          */
 31660                                  ;/*   02|                                                                                |          */
 31661                                  ;/*   03|                                                                                |          */
 31662                                  ;/*   04|                  Create DOS Partition or Logical DOS Drive                     |menu_8    */
 31663                                  ;/*   05|                                                                                |          */
 31664                                  ;/*   06|    Current fixed disk drive: #                                                 |menu_5 #  */
 31665                                  ;/*   07|                                                                                |          */
 31666                                  ;/*   08|    Choose one of the following:                                                |menu_3 #  */
 31667                                  ;/*   09|                                                                                |          */
 31668                                  ;/*   10|    1.  Create Primary DOS Partition                                            |menu_9    */
 31669                                  ;/*   11|    2.  Create Extended DOS Partition                                           |menu_9    */
 31670                                  ;/*   12|    3.  Create logical DOS Drive(s) in the Extended DOS Partition               |menu_10   */
 31671                                  ;/*   13|                                                                                |          */
 31672                                  ;/*   14|                                                                                |          */
 31673                                  ;/*   15|                                                                                |          */
 31674                                  ;/*   16|                                                                                |          */
 31675                                  ;/*   17|    Enter choice: [ ]                                                           |menu_7 #  */
 31676                                  ;/*   18|                                                                                |          */
 31677                                  ;/*   19|                                                                                |          */
 31678                                  ;/*   20|                                                                                |          */
 31679                                  ;/*   21|                                                                                |          */
 31680                                  ;/*   22|                                                                                |          */
 31681                                  ;/*   23|                                                                                |          */
 31682                                  ;/*   24|    Press ESC to return to FDISK Options                                        |menu_11   */
 31683                                  ;/*   ------------------------------------------------------------------------------------          */
 31684                                  ;/*                                                                                                 */
 31685                                  ;/***************************************************************************************************/
 31686                                  
 31687                                  ; ----------------------------------------------------------------------------
 31688                                  ; c_menus.c (FDISK, MSDOS 6.0, 1991)	
 31689                                  ; ----------------------------------------------------------------------------
 31690                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 13/01/2019)
 31691                                  
 31692                                  ;/*  */
 31693                                  ;/******************* START OF SPECIFICATIONS *******************/
 31694                                  ;/*                                                             */
 31695                                  ;/* SUBROUTINE NAME: CREATE_PARTITION                           */
 31696                                  ;/*                                                             */
 31697                                  ;/* DESCRIPTIVE NAME: Create DOS related partition(s)           */
 31698                                  ;/*                                                             */
 31699                                  ;/* FUNCTION:                                                   */
 31700                                  ;/*      This routine verifies if there are free partitions,    */
 31701                                  ;/*      posts an status message if there is not, otherwise     */
 31702                                  ;/*      prints a screen asking what type of partition to       */
 31703                                  ;/*      be created, and passes control to the requested        */
 31704                                  ;/*      function.                                              */
 31705                                  ;/*                                                             */
 31706                                  ;/* NOTES: This is a screen control module only, no data is     */
 31707                                  ;/*        modified. Routine also will only allow 1 DOS and     */
 31708                                  ;/*        1 Ext DOS partitions per disk, if one already exists,*/
 31709                                  ;/*        then status message is displayed when the create     */
 31710                                  ;/*        option for that type partition is selected           */
 31711                                  ;/*                                                             */
 31712                                  ;/*        The following screen in managed                      */
 31713                                  ;/*                                                             */
 31714                                  ;/*       |0000000000111111111122222222223333333333|            */
 31715                                  ;/*       |0123456789012345678901234567890123456789|            */
 31716                                  ;/*     --|----------------------------------------|            */
 31717                                  ;/*     00|                                        |            */
 31718                                  ;/*     01|                                        |            */
 31719                                  ;/*     02|                                        |            */
 31720                                  ;/*     03|                                        |            */
 31721                                  ;/*     04|Create DOS Partition                    |            */
 31722                                  ;/*     05|                                        |            */
 31723                                  ;/*     06|Current Fixed Disk Drive: #             |            */
 31724                                  ;/*     07|                                        |            */
 31725                                  ;/*     08|Choose one of the following:            |            */
 31726                                  ;/*     09|                                        |            */
 31727                                  ;/*     10|    1.  Create Primary DOS partition    |            */
 31728                                  ;/*     11|    2.  Create EXTENDED DOS partition   |            */
 31729                                  ;/*     12|    3.  Create logical DOS drive(s) in  |            */
 31730                                  ;/*     13|        the EXTENDED DOS partition      |            */
 31731                                  ;/*     14|                                        |            */
 31732                                  ;/*     15|                                        |            */
 31733                                  ;/*     16|                                        |            */
 31734                                  ;/*     17|                                        |            */
 31735                                  ;/*     18|Enter choice: [ ]                       |            */
 31736                                  ;/*     19|                                        |            */
 31737                                  ;/*     20|                                        |            */
 31738                                  ;/*     21|                                        |            */
 31739                                  ;/*     22|                                        |            */
 31740                                  ;/*     23|Press ESC to return to FDISK Options    |            */
 31741                                  ;/*     --------------------------------------------            */
 31742                                  ;/*                                                             */
 31743                                  ;/* ENTRY POINTS: create_partition                              */
 31744                                  ;/*      LINKAGE: create_partition();                           */
 31745                                  ;/*                                                             */
 31746                                  ;/* INPUT: None                                                 */
 31747                                  ;/*                                                             */
 31748                                  ;/* EXIT-NORMAL: ERROR=FALSE                                    */
 31749                                  ;/*                                                             */
 31750                                  ;/* EXIT-ERROR: ERROR=TRUE                                      */
 31751                                  ;/*             GOTO internal_program_error if case statement   */
 31752                                  ;/*             failure when branching to requested function    */
 31753                                  ;/*                                                             */
 31754                                  ;/* EFFECTS: No data directly modified by this routine, but     */
 31755                                  ;/*          child routines will modify data.                   */
 31756                                  ;/*                                                             */
 31757                                  ;/* INTERNAL REFERENCES:                                        */
 31758                                  ;/*   ROUTINES:                                                 */
 31759                                  ;/*      find_free_partition                                    */
 31760                                  ;/*      dos_create_partition                                   */
 31761                                  ;/*      ext_create_partition                                   */
 31762                                  ;/*      volume_create                                          */
 31763                                  ;/*      internal_program_error                                 */
 31764                                  ;/*      find_partition_type                                    */
 31765                                  ;/*      get_num_input                                          */
 31766                                  ;/*      display                                                */
 31767                                  ;/*      wait_for_ESC                                           */
 31768                                  ;/*      clear_screen                                           */
 31769                                  ;/*                                                             */
 31770                                  ;/* EXTERNAL REFERENCES:                                        */
 31771                                  ;/*   ROUTINES:                                                 */
 31772                                  ;/*                                                             */
 31773                                  ;/******************** END OF SPECIFICATIONS ********************/
 31774                                  
 31775                                  ;/*  */
 31776                                  ;void create_partition()
 31777                                  ;
 31778                                  ;BEGIN
 31779                                  ;
 31780                                  ;char   input;
 31781                                  ;char   default_value;
 31782                                  ;char   max_input;
 31783                                  ;
 31784                                  ;    input = c(NUL);                                                    /* AC000 */
 31785                                  ;    clear_screen(u(0),u(0),u(24),u(79));                               /* AC000 */
 31786                                  ;    /* put up heading and ESC */
 31787                                  ;    display(menu_8);
 31788                                  ;    display(menu_11);
 31789                                  ;
 31790                                  ;    /* Setup current drive msg */
 31791                                  ;    insert[0]=cur_disk+1+'0';
 31792                                  ;    display(menu_5);
 31793                                  ;
 31794                                  ;    /* See if there are free partitions */
 31795                                  ;    /* SR; 9/26/89; This check should be done only if the user asks to
 31796                                  ;       create a primary or extended partition and not for logical volumes */
 31797                                  ;
 31798                                  ;        /* display menu */
 31799                                  ;        display(menu_3);                                               /* AN000 */
 31800                                  ;        display(menu_9);
 31801                                  ;
 31802                                  ;        /* ############# ADD CODE HERE FOR THIS FUNCTION ############## */
 31803                                  ;        /* Do something about highlighting the available options and    */
 31804                                  ;        /* setting up defaults                                          */
 31805                                  ;        default_value = c(1);                                          /* AC000 */
 31806                                  ;        /* ############################################################ */
 31807                                  ;        /* setup default for prompt */
 31808                                  ;        insert[0] = c('1');                                            /* AC000 */
 31809                                  ;        display(menu_7);
 31810                                  ;        display(menu_10);
 31811                                  ;
 31812                                  ;        max_input = c(3);                                              /* AC000 */
 31813                                  ;
 31814                                  ;        input = get_num_input(default_value,max_input,input_row,input_col);
 31815                                  ;
 31816                                  ;        /* SR; 9/26/89; We check here for the extended volume creation case
 31817                                  ;           and remove it from the switch statement */
 31818                                  ;
 31819                                  ;        if (input == '3')
 31820                                  ;           {       /* Create a volume */
 31821                                  ;            if (find_partition_type(uc(EXTENDED)))
 31822                                  ;                volume_create();
 31823                                  ;            else
 31824                                  ;               {
 31825                                  ;                display(error_35);
 31826                                  ;                clear_screen(u(17),u(0),u(17),u(79));
 31827                                  ;                wait_for_ESC();
 31828                                  ;               }
 31829                                  ;           }
 31830                                  ;        else if (find_free_partition() != ((char)(NOT_FOUND)))
 31831                                  ;           {
 31832                                  ;            /* Go branch to the requested function */
 31833                                  ;            switch(input)
 31834                                  ;               BEGIN
 31835                                  ;                case '1':
 31836                                  ;                    dos_create_partition();
 31837                                  ;                    break;
 31838                                  ;
 31839                                  ;            	case '2':
 31840                                  ;                    if ((cur_disk >= c(1)) || (find_partition_type(uc(DOS12))) || (find_partition_type(uc(DOS16))) ||
 31841                                  ;                        (find_partition_type(uc(DOSNEW))))                   /* AN000 */             /* AC000 */
 31842                                  ;                    	ext_create_partition();
 31843                                  ;                    else
 31844                                  ;                       BEGIN                                               /* AN000 */
 31845                                  ;                    	/* don't have a primary partition yet, can't create an ext */
 31846                                  ;                    	display(error_19);                                  /* AN000 */
 31847                                  ;                    	clear_screen(u(17),u(0),u(17),u(79));               /* AN000 */
 31848                                  ;                    	wait_for_ESC();                                     /* AN000 */
 31849                                  ;                       END                                                 /* AN000 */
 31850                                  ;                    break;
 31851                                  ;
 31852                                  ;                case ESC:
 31853                                  ;                    break;
 31854                                  ;
 31855                                  ;                default:
 31856                                  ;                    internal_program_error();
 31857                                  ;                    break;
 31858                                  ;
 31859                                  ;               END
 31860                                  ;           }
 31861                                  ;        else
 31862                                  ;           {
 31863                                  ;            /* Display prompt telling there is no avail partition */
 31864                                  ;            display(error_10);
 31865                                  ;            input = wait_for_ESC();
 31866                                  ;           }
 31867                                  ;    /* clear the screen before going back to main menu */
 31868                                  ;    clear_screen(u(0),u(0),u(24),u(79));                               /* AC000 */
 31869                                  ;    return;
 31870                                  ;END
 31871                                  
 31872                                  create_partition:
 31873                                  		; 13/01/2019
 31874                                  
 31875                                  		;push	bp
 31876                                  		;mov	bp,sp
 31877                                  		;sub	sp,6
 31878                                  
 31879                                  		;mov	ax,79
 31880                                  		;push	ax
 31881                                  		;mov	ax,24
 31882                                  		;push	ax
 31883                                  		;sub	ax,ax
 31884                                  		;push	ax
 31885                                  		;push	ax
 31886                                  		;call	clear_screen
 31887                                  		;add	sp,8
 31888                                  
 31889 00004844 E817CC                  		call	CLS
 31890                                  
 31891                                  		;/* put up heading and ESC */
 31892                                  		
 31893                                  		;push	word [menu_8_segment]
 31894 00004847 1E                      		push	ds
 31895 00004848 FF36[039E]              		push	word [menu_8_offset]
 31896 0000484C E8D5CD                  		call	display
 31897                                  		;pop	bx
 31898                                  		;pop	bx
 31899                                  
 31900                                  		;push	word [menu_11_segment]
 31901 0000484F 1E                      		push	ds
 31902 00004850 FF36[099E]              		push	word [menu_11_offset]
 31903 00004854 E8CDCD                  		call	display
 31904                                  		;pop	bx
 31905                                  		;pop	bx
 31906                                  
 31907                                  		;/* Setup current drive msg */
 31908                                  
 31909 00004857 A0[E2CB]                		mov	al,[cur_disk]
 31910 0000485A 0431                    		add	al,'1'
 31911 0000485C A2[F4CC]                		mov	byte [insert],al
 31912                                  		
 31913                                  		;push	word [menu_5_segment]
 31914 0000485F 1E                      		push	ds
 31915 00004860 FF36[FD9D]              		push	word [menu_5_offset]
 31916 00004864 E8BDCD                  		call	display
 31917                                  		;pop	bx
 31918                                  		;pop	bx
 31919                                  
 31920                                  		;push	word [menu_3_segment]
 31921 00004867 1E                      		push	ds
 31922 00004868 FF36[F99D]              		push	word [menu_3_offset]
 31923 0000486C E8B5CD                  		call	display
 31924                                  		;pop	bx
 31925                                  		;pop	bx
 31926                                  		
 31927                                  		;push	word [menu_9_segment]
 31928 0000486F 1E                      		push	ds
 31929 00004870 FF36[059E]              		push	word [menu_9_offset]
 31930 00004874 E8ADCD                  		call	display
 31931                                  		;pop	bx
 31932                                  		;pop	bx
 31933                                  
 31934                                  		;/* setup default for prompt */
 31935                                  
 31936 00004877 C606[F4CC]31            		mov	byte [insert],'1'
 31937                                  		
 31938                                  		;push	word [menu_7_segment]
 31939 0000487C 1E                      		push	ds
 31940 0000487D FF36[019E]              		push	word [menu_7_offset]
 31941 00004881 E8A0CD                  		call	display
 31942                                  		;pop	bx
 31943                                  		;pop	bx
 31944                                  
 31945                                  		;push	word [menu_10_segment]
 31946 00004884 1E                      		push	ds
 31947 00004885 FF36[079E]              		push	word [menu_10_offset]
 31948 00004889 E898CD                  		call	display
 31949                                  		;pop	bx
 31950                                  		;pop	bx
 31951                                  
 31952                                  	;input = get_num_input(default_value,max_input,input_row,input_col);
 31953                                  
 31954 0000488C FF36[AAA0]              		push	word [input_col]
 31955 00004890 FF36[4CA1]              		push	word [input_row]
 31956 00004894 B003                    		mov	al,3
 31957 00004896 50                      		push	ax
 31958 00004897 B001                    		mov	al,1
 31959 00004899 50                      		push	ax
 31960 0000489A E8D7E1                  		call	get_num_input
 31961                                  		;add	sp,8
 31962                                  		;mov	[cp_input],al
 31963                                  		
 31964 0000489D A2[1ED0]                		mov	[_input],al
 31965                                  
 31966                                  		;if (input == '3')
 31967                                  
 31968 000048A0 3C33                    		cmp	al,'3'
 31969 000048A2 7513                    		jne	short cp_2
 31970                                  
 31971                                  		;/* Create a volume */
 31972                                  
 31973 000048A4 B005                    		mov	al,5 ; EXTENDED
 31974                                  		;push	ax
 31975 000048A6 E81BD5                  		call	find_partition_type
 31976                                  		;pop	bx
 31977                                  		;or	al, al
 31978                                  		;jz	short cp_1
 31979 000048A9 7205                    		jc	short cp_1		
 31980                                  
 31981 000048AB E8AC05                  		call	volume_create
 31982 000048AE EB6E                    		jmp	case_crea_part_break
 31983                                  cp_1:
 31984                                  		;push	word [error_35_seg]
 31985 000048B0 1E                      		push	ds
 31986 000048B1 FF36[C49E]              		push	word [error_35_off]
 31987 000048B5 EB48                    		jmp	short cp_9
 31988                                  
 31989                                  	;else if (find_free_partition() != ((char)(NOT_FOUND)))
 31990                                  cp_2:
 31991 000048B7 E8740E                  		call	find_free_partition
 31992 000048BA FEC0                    		inc	al
 31993 000048BC 7455                    		jz	short cp_10 ; NOT FOUND
 31994                                  
 31995                                  		;/* Go branch to the requested function */
 31996                                  switch_input7:
 31997                                  		;mov	al,[cp_input]
 31998 000048BE A0[1ED0]                		mov	al,[_input]
 31999                                  		;cbw
 32000                                  		;cmp	ax,'2'
 32001 000048C1 3C32                    		cmp	al,'2'
 32002 000048C3 7414                    		je	short case_crea_part_2 ; Create EXTENDED DOS partition
 32003 000048C5 7708                    		ja	short case_crea_part_DEF
 32004                                  
 32005 000048C7 2C1B                    		sub	al,1Bh ; ESC
 32006 000048C9 7453                    		jz	short case_crea_part_break ; ESCape key
 32007                                  
 32008 000048CB 2C16                    		sub	al,16h ; '1'
 32009 000048CD 7405                    		jz	short case_crea_part_1 ; Create primary DOS partition
 32010                                  case_crea_part_DEF:
 32011 000048CF E849EA                  		call	internal_program_error
 32012 000048D2 EB4A                    		jmp	short case_crea_part_break
 32013                                  case_crea_part_1:
 32014 000048D4 E84A00                  		call	dos_create_partition
 32015 000048D7 EB45                    		jmp	short case_crea_part_break
 32016                                  case_crea_part_2:
 32017                                  cp_6:  ; 25/01/2019
 32018 000048D9 803E[E2CB]01            		cmp	byte [cur_disk],1
 32019                                  		;jge	short cp_7
 32020 000048DE 7315                    		jnb	short cp_7
 32021                                  		
 32022 000048E0 B001                    		mov	al,1 ; DOS12  ; FAT 12
 32023                                  		;push	ax
 32024 000048E2 E8DFD4                  		call	find_partition_type
 32025                                  		;pop	bx
 32026                                  		;or	al,al
 32027                                  		;jnz	short cp_7
 32028 000048E5 730E                    		jnc	short cp_7		
 32029                                  
 32030 000048E7 B004                    		mov	al,4 ; DOS16  ; FAT 16
 32031                                  		;push	ax
 32032 000048E9 E8D8D4                  		call	find_partition_type
 32033                                  		;pop	bx
 32034                                  		;or	al,al
 32035                                  		;jnz	short cp_7
 32036 000048EC 7307                    		jnc	short cp_7		
 32037                                   
 32038 000048EE B006                    		mov	al,6 ; DOSNEW  ; FAT 16 big
 32039                                  		;push	ax
 32040 000048F0 E8D1D4                  		call	find_partition_type
 32041                                  		;pop	bx
 32042                                  		;or	al, al
 32043                                  		;jz	short cp_8
 32044 000048F3 7205                    		jc	short cp_8
 32045                                  cp_7:
 32046 000048F5 E89C03                  		call	ext_create_partition
 32047 000048F8 EB24                    		jmp	short case_crea_part_break
 32048                                  cp_8:
 32049                                  	;/* don't have a primary partition yet, can't create an ext */	
 32050                                  		;push	word [error_19_seg]
 32051 000048FA 1E                      		push	ds
 32052 000048FB FF36[A49E]              		push	word [error_19_off]
 32053                                  cp_9:
 32054 000048FF E822CD                  		call	display
 32055                                  		;pop	bx
 32056                                  		;pop	bx
 32057                                  
 32058 00004902 B84F00                  		mov	ax,79
 32059 00004905 50                      		push	ax
 32060 00004906 B81100                  		mov	ax,17
 32061 00004909 50                      		push	ax
 32062 0000490A 29C9                    		sub	cx,cx
 32063 0000490C 51                      		push	cx
 32064 0000490D 50                      		push	ax
 32065 0000490E E885CB                  		call	clear_screen
 32066                                  		;add	sp,8
 32067                                  
 32068 00004911 EB08                    		jmp	short cp_11
 32069                                  cp_10:
 32070                                  	;/* Display prompt telling there is no avail partition */
 32071                                  
 32072                                  		;push	word [error_10_seg]
 32073 00004913 1E                      		push	ds
 32074 00004914 FF36[969E]              		push	word [error_10_off]
 32075 00004918 E809CD                  		call	display
 32076                                  		;pop	bx
 32077                                  		;pop	bx
 32078                                  cp_11:
 32079 0000491B E856E8                  		call	wait_for_ESC
 32080                                  
 32081                                  case_crea_part_break:
 32082                                  	;/* clear the screen before going back to main menu */
 32083                                  
 32084                                  		;mov	ax,79
 32085                                  		;push	ax
 32086                                  		;mov	ax,24
 32087                                  		;push	ax
 32088                                  		;sub	ax,ax
 32089                                  		;push	ax
 32090                                  		;push	ax
 32091                                  		;call	clear_screen
 32092                                  
 32093                                  		;call	CLS
 32094                                  
 32095                                  		;mov	sp,bp
 32096                                  		;pop	bp
 32097                                  		;retn
 32098                                  
 32099 0000491E E93DCB                  		jmp	CLS
 32100                                  
 32101                                  ;/***************************************************************************************************/
 32102                                  ;/*  Screen for DOS_CREATE_PARTITION                                                                */
 32103                                  ;/*                                                                                                 */
 32104                                  ;/*     |00000000001111111111222222222233333333334444444444555555555566666666667777777777|          */
 32105                                  ;/*     |01234567890123456789012345678901234567890123456789012345678901234567890123456789|          */
 32106                                  ;/*   --|--------------------------------------------------------------------------------|          */
 32107                                  ;/*   00|                                                                                |          */
 32108                                  ;/*   01|                                                                                |          */
 32109                                  ;/*   02|                                                                                |          */
 32110                                  ;/*   03|                                                                                |          */
 32111                                  ;/*   04|                           Create Primary DOS Partition                         |menu_12   */
 32112                                  ;/*   05|                                                                                |          */
 32113                                  ;/*   06|    Current fixed disk drive: #                                                 |menu_5 #  */
 32114                                  ;/*   07|                                                                                |          */
 32115                                  ;/*   08|    Do you wish to use the maximum available size for a Primary DOS Partition   |menu_13   */
 32116                                  ;/*   09|    and make the partition active (Y/N).....................? [Y]               |menu_13   */
 32117                                  ;/*   10|                                                                                |          */
 32118                                  ;/*   11|                                                                                |          */
 32119                                  ;/*   12|                                                                                |          */
 32120                                  ;/*   13|                                                                                |          */
 32121                                  ;/*   14|                                                                                |          */
 32122                                  ;/*   15|                                                                                |          */
 32123                                  ;/*   16|                                                                                |          */
 32124                                  ;/*   17|                                                                                |          */
 32125                                  ;/*   18|                                                                                |          */
 32126                                  ;/*   19|                                                                                |          */
 32127                                  ;/*   20|                                                                                |          */
 32128                                  ;/*   21|                                                                                |          */
 32129                                  ;/*   22|                                                                                |          */
 32130                                  ;/*   23|                                                                                |          */
 32131                                  ;/*   24|    Press ESC to return to FDISK Options                                        |menu_11   */
 32132                                  ;/*   ------------------------------------------------------------------------------------          */
 32133                                  ;/*                                                                                                 */
 32134                                  ;/***************************************************************************************************/
 32135                                  
 32136                                  ; c_menus.c (MSDOS 6.0)
 32137                                  ;/*  */
 32138                                  ;/******************* START OF SPECIFICATIONS *******************/
 32139                                  ;/*                                                             */
 32140                                  ;/* SUBROUTINE NAME: DOS_CREATE_PARTITION                       */
 32141                                  ;/*                                                             */
 32142                                  ;/* DESCRIPTIVE NAME: Create default DOS partition on disk      */
 32143                                  ;/*                                                             */
 32144                                  ;/* FUNCTION: User is prompted to see if he wishes to use to    */
 32145                                  ;/*           set up a DOS partition in the maximum available   */
 32146                                  ;/*           size (limited to 32mb). If option is selected     */
 32147                                  ;/*           than partition is created and marked active. The  */
 32148                                  ;/*           partition is scanned to insure there are enough   */
 32149                                  ;/*           contiguous good sectors for DOS.                  */
 32150                                  ;/*                                                             */
 32151                                  ;/* NOTES: Screen can be exited via the ESC command before      */
 32152                                  ;/*        partition is created and nothing will change         */
 32153                                  ;/*                                                             */
 32154                                  ;/*        The following screen is managed:                     */
 32155                                  ;/*                                                             */
 32156                                  ;/*       |0000000000111111111122222222223333333333|            */
 32157                                  ;/*       |0123456789012345678901234567890123456789|            */
 32158                                  ;/*     --|----------------------------------------|            */
 32159                                  ;/*     00|                                        |            */
 32160                                  ;/*     01|                                        |            */
 32161                                  ;/*     02|                                        |            */
 32162                                  ;/*     03|                                        |            */
 32163                                  ;/*     04|Create DOS Partition                    |            */
 32164                                  ;/*     05|                                        |            */
 32165                                  ;/*     06|Current Fixed Disk Drive: #             |            */
 32166                                  ;/*     07|                                        |            */
 32167                                  ;/*     08|Do you wish to use the maximum size     |            */
 32168                                  ;/*     09|for a DOS partition and make the DOS    |            */
 32169                                  ;/*     10|partition active (Y/N).........? [Y]    |            */
 32170                                  ;/*     11|                                        |            */
 32171                                  ;/*     12|                                        |            */
 32172                                  ;/*     13|                                        |            */
 32173                                  ;/*     14|                                        |            */
 32174                                  ;/*     15|                                        |            */
 32175                                  ;/*     16|                                        |            */
 32176                                  ;/*     17|                                        |            */
 32177                                  ;/*     18|                                        |            */
 32178                                  ;/*     19|                                        |            */
 32179                                  ;/*     20|                                        |            */
 32180                                  ;/*     21|                                        |            */
 32181                                  ;/*     22|                                        |            */
 32182                                  ;/*     23|Press ESC to return to FDISK Options    |            */
 32183                                  ;/*     --------------------------------------------            */
 32184                                  ;/*                                                             */
 32185                                  ;/* ENTRY POINTS: dos_create_partition                          */
 32186                                  ;/*      LINKAGE: dos_create_partition();                       */
 32187                                  ;/*               NEAR CALL                                     */
 32188                                  ;/*                                                             */
 32189                                  ;/* INPUT: None                                                 */
 32190                                  ;/*                                                             */
 32191                                  ;/* EXIT-NORMAL: ERROR=FALSE                                    */
 32192                                  ;/*                                                             */
 32193                                  ;/* EXIT-ERROR: ERROR=TRUE                                      */
 32194                                  ;/*             GOTO internal_program_error if case statement   */
 32195                                  ;/*             failure when branching to requested function    */
 32196                                  ;/*                                                             */
 32197                                  ;/* EFFECTS: No data directly modified by this routine, but     */
 32198                                  ;/*          child routines will modify data.                   */
 32199                                  ;/*                                                             */
 32200                                  ;/* INTERNAL REFERENCES:                                        */
 32201                                  ;/*   ROUTINES:                                                 */
 32202                                  ;/*      clear_screen                                           */
 32203                                  ;/*      display                                                */
 32204                                  ;/*      get_yn_input                                           */
 32205                                  ;/*      wait_for_ESC                                           */
 32206                                  ;/*      input_dos_create                                       */
 32207                                  ;/*      make_partition                                         */
 32208                                  ;/*      check_bad_tracks                                       */
 32209                                  ;/*                                                             */
 32210                                  ;/*                                                             */
 32211                                  ;/* EXTERNAL REFERENCES:                                        */
 32212                                  ;/*   ROUTINES:                                                 */
 32213                                  ;/*                                                             */
 32214                                  ;/******************** END OF SPECIFICATIONS ********************/
 32215                                  
 32216                                  ;/*  */
 32217                                  ;void dos_create_partition()
 32218                                  ;
 32219                                  ;BEGIN
 32220                                  ;
 32221                                  ;    char   input;
 32222                                  ;    char   temp;
 32223                                  ;    char   second_disk_flag;                                            /* AN000 */
 32224                                  ;
 32225                                  ;    /* SR; 9/26/89; These variables are added for the various fixes */
 32226                                  ;
 32227                                  ;    unsigned long total_sectors;
 32228                                  ;    unsigned char  i;
 32229                                  ;    char  defined_drives;
 32230                                  ;    char  temp_cur_disk;
 32231                                  ;
 32232                                  ;    second_disk_flag = (FLAG)FALSE;                                     /* AN000 */
 32233                                  ;    input = c(NUL);                                                     /* AC000 */
 32234                                  ;    /* clear off screen */
 32235                                  ;    clear_screen(u(0),u(0),u(24),u(79));                                /* AC000 */
 32236                                  ;
 32237                                  ;    /* Put up header */
 32238                                  ;    display(menu_12);
 32239                                  ;
 32240                                  ;    /* Set up current disk message */
 32241                                  ;    insert[0] = cur_disk+1+'0';
 32242                                  ;    display(menu_5);
 32243                                  ;
 32244                                  ;    /* Display ESC prompt */
 32245                                  ;    display(menu_11);
 32246                                  ;
 32247                                  ;    /* See if already exists */
 32248                                  ;    if ((!find_partition_type(uc(DOS12))) && (!find_partition_type(uc(DOS16))) && (!find_partition_type(uc(DOSNEW))))  /* AC000 */
 32249                                  ;
 32250                                  ;       BEGIN
 32251                                  ;
 32252                                  ;        /* SR; 9/26/89; Ported from Olivetti fix. The min. no. of sectors
 32253                                  ;           in a partition must be >64 for BIOS to recognize the drive */
 32254                                  ;
 32255                                  ;       temp = find_part_free_space(c(PRIMARY));
 32256                                  ;       total_sectors = (long)free_space[temp].space * max_sector[cur_disk] * max_head[cur_disk];
 32257                                  ;       if (total_sectors < 64)
 32258                                  ;          {
 32259                                  ;           display(error_10);      /**** No room on disk */
 32260                                  ;           input = wait_for_ESC();
 32261                                  ;           return;  /*C06*/
 32262                                  ;          }
 32263                                  ;        /* SR; 9/26/89; We do not allow creation of a drive on the second
 32264                                  ;           hard disk if there are already 23 drives on the 1st hard disk */
 32265                                  ;        else                   /*C07*/
 32266                                  ;           {
 32267                                  ;            defined_drives = c(0);
 32268                                  ;            temp_cur_disk = cur_disk;
 32269                                  ;
 32270                                  ;            /* Search both drives for defined drives */
 32271                                  ;            for (i = 0; i < number_of_drives; i++)
 32272                                  ;               {
 32273                                  ;                cur_disk = (c(i));
 32274                                  ;
 32275                                  ;                /* See if there is a primary drive letter */
 32276                                  ;                if ((find_partition_type(uc(DOS12))) ||
 32277                                  ;                    (find_partition_type(uc(DOS16))) ||
 32278                                  ;                    (find_partition_type(uc(DOSNEW))))
 32279                                  ;                    defined_drives++;
 32280                                  ;
 32281                                  ;                /* See if extended partition on disk */
 32282                                  ;                if (find_partition_type(uc(EXTENDED)))
 32283                                  ;                    /* Get number of logical drives */
 32284                                  ;                    defined_drives += get_num_logical_dos_drives();
 32285                                  ;               }
 32286                                  ;            /* Restore cur_disk to original */
 32287                                  ;            cur_disk = temp_cur_disk;
 32288                                  ;
 32289                                  ;            /* See if 26 or less drives total */
 32290                                  ;            if (defined_drives > c(23))
 32291                                  ;               /* Reached the maximum */
 32292                                  ;               {
 32293                                  ;                clear_screen(u(16),u(0),u(23),u(79));
 32294                                  ;                display(error_27);
 32295                                  ;                input = wait_for_ESC();
 32296                                  ;                return;
 32297                                  ;               }
 32298                                  ;           }
 32299                                  ;
 32300                                  ;        /* Display prompt, depending on what disk */
 32301                                  ;        if (cur_disk == c(0))                                           /* AC000 */
 32302                                  ;            /* Put up make active partition message */
 32303                                  ;            display(menu_13);
 32304                                  ;        else
 32305                                  ;            BEGIN
 32306                                  ;            /* Second disk, so dont put up prompt mentioning active partition */
 32307                                  ;            second_disk_flag = (FLAG)TRUE;                              /* AN000 */
 32308                                  ;            display(menu_45);                                           /* AC000 */
 32309                                  ;            END
 32310                                  ;        /* Get Y/N input */
 32311                                  ;        input = get_yn_input(c(Yes),input_row,input_col);               /* AC000 AC011 */
 32312                                  ;
 32313                                  ;        /* Go handle input */
 32314                                  ;        switch(input)
 32315                                  ;            BEGIN
 32316                                  ;            case 1:                                                     /* AC000 */
 32317                                  ;                if ( second_disk_flag == (FLAG)FALSE)
 32318                                  ;                    BEGIN
 32319                                  ;                    /* Go get the biggest area left */
 32320                                  ;                    temp = find_part_free_space(c(PRIMARY));            /* AC000 */
 32321                                  ;                    make_partition(free_space[temp].space,temp,uc(ACTIVE),c(PRIMARY)); /* AC000 */
 32322                                  ;                    reboot_flag = (FLAG)TRUE;                           /* AC000 */
 32323                                  ;                    if (number_of_drives == uc(1))                      /* AN000 */
 32324                                  ;                        BEGIN                                           /* AN000 */
 32325                                  ;                        write_info_to_disk();
 32326                                  ;                        reboot_system();                                /* AC000 */
 32327                                  ;                        END                                             /* AN000 */
 32328                                  ;                    clear_screen(u(16),u(0),u(23),u(79));               /* AN000 */
 32329                                  ;
 32330                                  ;                    display(status_12);                                 /* AN000 */
 32331                                  ;                    wait_for_ESC();
 32332                                  ;                    break;
 32333                                  ;                    END
 32334                                  ;                else
 32335                                  ;                    BEGIN                                               /* AN000 */
 32336                                  ;                    /* Go get the biggest area left */                  /* AN000 */
 32337                                  ;                    temp = find_part_free_space(c(PRIMARY));            /* AN000 */
 32338                                  ;                    make_partition(free_space[temp].space,temp,uc(NUL),c(PRIMARY)); /* AN000 */
 32339                                  ;                    reboot_flag = (FLAG)TRUE;                           /* AN000 */
 32340                                  ;                    clear_screen(u(16),u(0),u(23),u(79));               /* AN000 */
 32341                                  ;
 32342                                  ;                    display(status_12);                                 /* AN000 */
 32343                                  ;                    wait_for_ESC();
 32344                                  ;                    break;
 32345                                  ;                    END
 32346                                  ;
 32347                                  ;            case  0:
 32348                                  ;                input_dos_create();                               /* AC000 */
 32349                                  ;                break;
 32350                                  ;
 32351                                  ;            case ESC:
 32352                                  ;                break;   /* take no action */
 32353                                  ;
 32354                                  ;            default:
 32355                                  ;                internal_program_error();
 32356                                  ;            END
 32357                                  ;        END
 32358                                  ;    else
 32359                                  ;        BEGIN
 32360                                  ;        /* Display partition table-it will return if no partitions there */
 32361                                  ;        table_display();
 32362                                  ;
 32363                                  ;        /* Primary partition already exists message */
 32364                                  ;        display(error_8);
 32365                                  ;        wait_for_ESC();
 32366                                  ;        END
 32367                                  ;   return;
 32368                                  ;END
 32369                                  
 32370                                  ; 13/01/2019
 32371                                  struc f
 32372 00000000 ????                    .space: resw 1
 32373 00000002 ????                    .start: resw 1
 32374 00000004 ????                    .end:   resw 1
 32375                                  endstruc
 32376                                  
 32377                                  dos_create_partition:
 32378                                  		; 13/01/2019
 32379                                  
 32380                                  	%define second_disk_flag bp-16
 32381                                  	%define defined_drives	 bp-14
 32382                                  	%define cdp_i		 bp-12
 32383                                  	%define temp_cur_disk	 bp-10
 32384                                  	%define cdp_temp	 bp-8
 32385                                  
 32386 00004921 55                      		push	bp
 32387 00004922 89E5                    		mov	bp,sp
 32388 00004924 83EC10                  		sub	sp,16
 32389 00004927 56                      		push	si
 32390 00004928 28C0                    		sub	al,al
 32391 0000492A 8846F0                  		mov	[second_disk_flag],al
 32392                                  
 32393                                  		;/* clear off screen */		
 32394                                  
 32395                                  		;mov	ax,79
 32396                                  		;push	ax
 32397                                  		;mov	ax,24
 32398                                  		;push	ax
 32399                                  		;sub	ax,ax
 32400                                  		;push	ax
 32401                                  		;push	ax
 32402                                  		;call	clear_screen
 32403                                  		;add	sp,8
 32404                                  
 32405 0000492D E82ECB                  		call	CLS
 32406                                  
 32407                                  		;/* Put up header */
 32408                                  
 32409                                  		;push	word [menu_12_segment]
 32410 00004930 1E                      		push	ds
 32411 00004931 FF36[0B9E]              		push	word [menu_12_offset]
 32412 00004935 E8ECCC                  		call	display
 32413                                  		;pop	bx
 32414                                  		;pop	bx
 32415                                  
 32416                                  		;/* Set up current disk message */
 32417                                  
 32418 00004938 A0[E2CB]                		mov	al,[cur_disk]
 32419 0000493B 0431                    		add	al,'1'
 32420 0000493D A2[F4CC]                		mov	[insert],al
 32421                                  
 32422                                  		;push	word [menu_5_segment]
 32423 00004940 1E                      		push	ds
 32424 00004941 FF36[FD9D]              		push	word [menu_5_offset]
 32425 00004945 E8DCCC                  		call	display
 32426                                  		;pop	bx
 32427                                  		;pop	bx
 32428                                  
 32429                                  		;/* Display ESC prompt */
 32430                                  
 32431                                  		;push	word [menu_11_segment]
 32432 00004948 1E                      		push	ds
 32433 00004949 FF36[099E]              		push	word [menu_11_offset]
 32434 0000494D E8D4CC                  		call	display
 32435                                  		;pop	bx
 32436                                  		;pop	bx
 32437                                  
 32438                                  		;/* See if already exists */
 32439                                  
 32440 00004950 B001                    		mov	al,1 ; DOS12 ; FAT12
 32441                                  		;push	ax
 32442 00004952 E86FD4                  		call	find_partition_type
 32443                                  		;pop	bx
 32444                                  		;or	al,al
 32445                                  		;jnz	short cdp_1
 32446 00004955 730E                    		jnc	short cdp_1
 32447                                  
 32448 00004957 B004                    		mov	al,4 ; DOS16 ; FAT16
 32449                                  		;push	ax
 32450 00004959 E868D4                  		call	find_partition_type
 32451                                  		;pop	bx
 32452                                  		;or	al,al
 32453                                  		;jnz	short cdp_1
 32454 0000495C 7307                    		jnc	short cdp_1
 32455                                  
 32456 0000495E B006                    		mov	al,6 ; DOSNEW ; FAT16 big
 32457                                  		;push	ax
 32458 00004960 E861D4                  		call	find_partition_type
 32459                                  		;pop	bx
 32460                                  		;or	al,al
 32461                                  		;jz	short cdp_2
 32462 00004963 7203                    		jc	short cdp_2
 32463                                  cdp_1:
 32464 00004965 E94A01                  		jmp	cdp_19
 32465                                  cdp_2:
 32466                                  ;	temp = find_part_free_space(c(PRIMARY));
 32467                                  ;       total_sectors = (long)free_space[temp].space * max_sector[cur_disk] * max_head[cur_disk];
 32468                                  
 32469 00004968 30C0                    		xor	al,al ; 14/01/2019
 32470                                  		;push	ax
 32471 0000496A E83107                  		call	find_part_free_space
 32472                                  		;pop	bx
 32473 0000496D 8846F8                  		mov	[cdp_temp],al
 32474                                  
 32475 00004970 A0[E2CB]                		mov	al,[cur_disk]
 32476 00004973 98                      		cbw
 32477 00004974 89C3                    		mov	bx,ax
 32478 00004976 8A87[AEA0]              		mov	al,[max_sector+bx]
 32479 0000497A 28E4                    		sub	ah,ah
 32480 0000497C 29D2                    		sub	dx,dx
 32481 0000497E 52                      		push	dx  ; multiplier_hw	
 32482 0000497F 50                      		push	ax  ; multiplier_lw
 32483                                  		;mov	al,22
 32484 00004980 B00A                    		mov	al,10 ; 14/01/2019
 32485                                  		;imul	byte [cdp_temp]
 32486 00004982 F666F8                  		mul	byte [cdp_temp]
 32487 00004985 89C6                    		mov	si,ax
 32488 00004987 8B84[F0CB]              		mov	ax,[free_space.space+si]
 32489 0000498B D1E3                    		shl	bx,1
 32490 0000498D F7A7[B6A0]              		mul	word [max_head+bx]
 32491 00004991 52                      		push	dx ; multiplicand_hw
 32492 00004992 50                      		push	ax ; multiplicand_lw
 32493 00004993 E845CC                  		call	mul32
 32494                                  			; DX:AX =  Total (available partition) sectors (of free space)
 32495                                  
 32496                                  		; if (total_sectors < 64)
 32497                                  
 32498 00004996 09D2                    		or	dx,dx
 32499 00004998 750D                    		jnz	short cdp_3
 32500                                  
 32501 0000499A 83F840                  		cmp	ax,64
 32502 0000499D 7308                    		jnb	short cdp_3
 32503                                  
 32504                                  		;/**** No room on disk */
 32505                                  
 32506                                  		;push	word [error_10_seg]
 32507 0000499F 1E                      		push	ds
 32508 000049A0 FF36[969E]              		push	word [error_10_off]
 32509 000049A4 E91301                  		jmp	cdp_20
 32510                                  cdp_3:
 32511 000049A7 C646F200                		mov	byte [defined_drives],0
 32512 000049AB A0[E2CB]                		mov	al,[cur_disk]
 32513 000049AE 8846F6                  		mov	[temp_cur_disk],al
 32514 000049B1 C646F400                		mov	byte [cdp_i],0
 32515 000049B5 EB2E                    		jmp	short cdp_8
 32516                                  cdp_4:
 32517                                  		;/* See if there is a primary drive letter */
 32518                                  
 32519 000049B7 8A46F4                  		mov	al,[cdp_i]
 32520 000049BA A2[E2CB]                		mov	[cur_disk],al
 32521 000049BD B001                    		mov	al,1 ; DOS12
 32522                                  		;push	ax
 32523 000049BF E802D4                  		call	find_partition_type
 32524                                  		;pop	bx
 32525                                  		;or	al, al
 32526                                  		;jnz	short cdp_5
 32527 000049C2 730E                    		jnc	short cdp_5
 32528                                  
 32529 000049C4 B004                    		mov	al, 4 ; DOS16
 32530                                  		;push	ax
 32531 000049C6 E8FBD3                  		call	find_partition_type
 32532                                  		;pop	bx
 32533                                  		;or	al, al
 32534                                  		;jnz	short cdp_5
 32535 000049C9 7307                    		jnc	short cdp_5
 32536                                  		
 32537 000049CB B006                    		mov	al,6
 32538                                  		;push	ax
 32539 000049CD E8F4D3                  		call	find_partition_type
 32540                                  		;pop	bx
 32541                                  		;or	al, al
 32542                                  		;jz	short cdp_6
 32543 000049D0 7203                    		jc	short cdp_6
 32544                                  cdp_5:
 32545 000049D2 FE46F2                  		inc	byte [defined_drives]
 32546                                  cdp_6:
 32547                                  		; /* See if extended partition on disk */
 32548                                  
 32549 000049D5 B005                    		mov	al,5 ; EXTENDED
 32550                                  		;push	ax
 32551 000049D7 E8EAD3                  		call	find_partition_type
 32552                                  		;pop	bx
 32553                                  		;or	al, al
 32554                                  		;jz	short cdp_7
 32555 000049DA 7206                    		jc	short cdp_7
 32556                                  
 32557 000049DC E839FE                  		call	get_num_logical_dos_drives
 32558 000049DF 0046F2                  		add	[defined_drives],al
 32559                                  cdp_7:
 32560 000049E2 FE46F4                  		inc	byte [cdp_i]
 32561                                  cdp_8:
 32562                                  		;/* Search both drives for defined drives */
 32563                                  
 32564 000049E5 A0[E3C3]                		mov	al,[number_of_drives]
 32565 000049E8 3846F4                  		cmp	[cdp_i],al
 32566 000049EB 72CA                    		jb	short cdp_4
 32567                                  
 32568                                  		;/* Restore cur_disk  to original */
 32569                                  
 32570 000049ED 8A46F6                  		mov	al,[temp_cur_disk]
 32571 000049F0 A2[E2CB]                		mov	[cur_disk],al
 32572                                  
 32573                                  	; We do not allow creation of a drive on the second
 32574                                  	; hard disk if there are already 23 drives on the 1st hard disk */
 32575                                  
 32576                                    		;/* See if 26 or less drives total */
 32577                                              	; if (defined_drives > c(23))
 32578                                  
 32579 000049F3 807EF217                		cmp	byte [defined_drives],23
 32580 000049F7 7E1A                    		jle	short cdp_9
 32581                                  
 32582                                  		;/* Reached the maximum */
 32583                                  
 32584 000049F9 B84F00                  		mov	ax,79
 32585 000049FC 50                      		push	ax
 32586 000049FD B81700                  		mov	ax,23
 32587 00004A00 50                      		push	ax
 32588 00004A01 29C0                    		sub	ax,ax
 32589 00004A03 50                      		push	ax
 32590 00004A04 B81000                  		mov	ax,16
 32591 00004A07 50                      		push	ax
 32592 00004A08 E88BCA                  		call	clear_screen
 32593                                  		;add	sp,8
 32594                                  
 32595                                  		;push	word [error_27_seg]
 32596 00004A0B 1E                      		push	ds
 32597 00004A0C FF36[B49E]              		push	word [error_27_off]
 32598 00004A10 E9A700                  		jmp	cdp_20
 32599                                  cdp_9:
 32600                                  		;/* Display prompt, depending on what disk */
 32601                                  
 32602 00004A13 803E[E2CB]00            		cmp	byte [cur_disk],0
 32603 00004A18 7507                    		jne	short cdp_10
 32604                                  		;push	word [menu_13_segment]
 32605 00004A1A 1E                      		push	ds
 32606 00004A1B FF36[0D9E]              		push	word [menu_13_offset]
 32607 00004A1F EB09                    		jmp	short cdp_11
 32608                                  cdp_10:
 32609                                  		; /* Second disk, so dont put up prompt mentioning active partition */
 32610                                  
 32611 00004A21 C646F001                		mov	byte [second_disk_flag],1
 32612                                  		;push	word [menu_45_segment]
 32613 00004A25 1E                      		push	ds
 32614 00004A26 FF36[0F9E]              		push	word [menu_45_offset]
 32615                                  cdp_11:
 32616 00004A2A E8F7CB                  		call	display
 32617                                  		;pop	bx
 32618                                  		;pop	bx
 32619                                  
 32620                                  		;/* Get Y/N input */
 32621                                   	; input = get_yn_input(c(Yes),input_row,input_col); 
 32622                                  
 32623 00004A2D FF36[AAA0]              		push	word [input_col]
 32624 00004A31 FF36[4CA1]              		push	word [input_row]
 32625 00004A35 A0[D9C3]                		mov	al,[Yes]
 32626 00004A38 50                      		push	ax
 32627 00004A39 E812E6                  		call	get_yn_input
 32628                                  		;add	sp,6
 32629                                  switch_input8:
 32630                                  		;/* Go handle input */
 32631                                  
 32632                                  		;cbw
 32633                                  		;cmp	ax,1Bh
 32634 00004A3C 3C1B                    		cmp	al,1Bh ; ESCape key
 32635 00004A3E 7502                    		jne	short cdp_13
 32636 00004A40 EB7E                    		jmp	case_dos_create_break  ; /* take no action */
 32637                                  cdp_13:
 32638 00004A42 770A                    		ja	short case_dos_create_DEF
 32639 00004A44 08C0                    		or	al,al
 32640 00004A46 7502                    		jnz	short cdp_14 ; 'Y'es or invalid
 32641 00004A48 EB63                    		jmp	case_dos_create_0 ; 'N'o
 32642                                  cdp_14:
 32643 00004A4A FEC8                    		dec	al
 32644 00004A4C 7405                    		jz	short case_dos_create_1 ; 'Y'es
 32645                                  case_dos_create_DEF:
 32646 00004A4E E8CAE8                  		call	internal_program_error
 32647 00004A51 EB6D                    		jmp	case_dos_create_break
 32648                                  case_dos_create_1:
 32649                                  		; /* Go get the biggest area left */
 32650                                  
 32651 00004A53 28C0                    		sub	al,al
 32652                                  		;push	ax
 32653 00004A55 E84606                  		call	find_part_free_space
 32654                                  		;pop	bx
 32655                                  		;mov	[cdp_temp],al
 32656 00004A58 88C2                    		mov	dl,al
 32657                                  		
 32658 00004A5A 28C0                    		sub	al,al   ; PRIMARY
 32659 00004A5C 50                      		push	ax	; mp_type (byte) - PRIMARY -
 32660                                  
 32661                                  		;mov	al,[cdp_temp]
 32662                                  		;mov	dl,al		
 32663                                  		;mov	cl,22
 32664 00004A5D B10A                    		mov	cl,10 ; 14/01/2019
 32665 00004A5F F6E1                    		mul	cl
 32666 00004A61 89C3                    		mov	bx,ax
 32667 00004A63 8B8F[F0CB]              		mov	cx,[free_space.space+bx]
 32668                                  
 32669 00004A67 807EF000                		cmp	byte [second_disk_flag],0
 32670 00004A6B 751C                    		jne	short cdp_17
 32671                                  
 32672                                  		;sub	al,al
 32673                                  		;push	ax
 32674                                  		;call	find_part_free_space
 32675                                  		;pop	bx
 32676                                  		;mov	[cdp_temp],al
 32677                                  		;sub	al,al
 32678                                  		;push	ax
 32679                                  
 32680 00004A6D B080                    		mov	al,80h  ; BOOTABLE
 32681 00004A6F 50                      		push	ax	; mp_bootable (byte) - BOOTABLE -
 32682                                  
 32683                                  		;mov	al,[cdp_temp]
 32684                                  		;push	ax
 32685                                  		;mov	cl,22
 32686                                  		;imul	cl
 32687                                  		;mov	bx,ax
 32688                                  		;push	word [free_space.space+bx]
 32689                                  
 32690 00004A70 52                      		push	dx  ; dl = [cdp_temp]  ; mp_free_ptr (byte)
 32691 00004A71 51                      		push	cx  ; cx = [free_space.space+bx] ; mp_size (word)			
 32692                                  
 32693 00004A72 E8DB0A                  		call	make_partition
 32694                                  		;add	sp,8
 32695                                  
 32696 00004A75 C606[78A0]01            		mov	byte [reboot_flag],1
 32697 00004A7A 803E[E3C3]01            		cmp	byte [number_of_drives],1
 32698 00004A7F 7513                    		jne	short cdp_18
 32699 00004A81 E847EC                  		call	write_info_to_disk
 32700 00004A84 E85EEB                  		call	reboot_system
 32701 00004A87 EB0B                    		jmp	short cdp_18
 32702                                  cdp_17:
 32703                                  		;sub	al,al
 32704                                  		;push	ax
 32705                                  		;call	find_part_free_space
 32706                                  		;pop	bx
 32707                                  		;mov	[cdp_temp],al
 32708                                  		;sub	al,al
 32709                                  		;push	ax
 32710                                  
 32711 00004A89 50                      		push	ax  ; al = 0 ; mp_bootable - not bootable -
 32712                                   		
 32713                                  		;mov	al,[cdp_temp]
 32714                                  		;push	ax
 32715                                  		;mov	cl,22
 32716                                  		;imul	cl
 32717                                  		;mov	bx,ax
 32718                                  		;push	word [free_space.space+bx]
 32719                                  
 32720 00004A8A 52                      		push	dx  ; dl = [cdp_temp]  ; mp_free_ptr
 32721 00004A8B 51                      		push	cx  ; cx = [free_space.space+bx] ; mp_size		
 32722                                  
 32723 00004A8C E8C10A                  		call	make_partition
 32724                                  		;add	sp,8
 32725                                  
 32726 00004A8F C606[78A0]01            		mov	byte [reboot_flag],1
 32727                                  cdp_18:
 32728 00004A94 B84F00                  		mov	ax,79
 32729 00004A97 50                      		push	ax
 32730 00004A98 B81700                  		mov	ax,23
 32731 00004A9B 50                      		push	ax
 32732 00004A9C 29C0                    		sub	ax,ax
 32733 00004A9E 50                      		push	ax
 32734 00004A9F B81000                  		mov	ax,16
 32735 00004AA2 50                      		push	ax
 32736 00004AA3 E8F0C9                  		call	clear_screen
 32737                                  		;add	sp,8
 32738                                  		
 32739                                  		;push	word [status_12_seg]
 32740 00004AA6 1E                      		push	ds
 32741 00004AA7 FF36[7F9E]              		push	word [status_12_off]
 32742 00004AAB EB0D                    		jmp	short cdp_20
 32743                                  
 32744                                  case_dos_create_0:
 32745 00004AAD E81500                  		call	input_dos_create
 32746 00004AB0 EB0E                    		jmp	short case_dos_create_break
 32747                                  cdp_19:
 32748                                  	;/* Display partition table - it will return if no partitions there */
 32749                                  
 32750 00004AB2 E8C2E3                  		call	table_display
 32751                                  
 32752                                  		;/* Primary partition already exists message */
 32753                                  
 32754                                  		;push	word [error_8_seg]
 32755 00004AB5 1E                      		push	ds
 32756 00004AB6 FF36[929E]              		push	word [error_8_off]
 32757                                  cdp_20:
 32758 00004ABA E867CB                  		call	display
 32759                                  		;pop	bx
 32760                                  		;pop	bx
 32761                                  
 32762 00004ABD E8B4E6                  		call	wait_for_ESC
 32763                                  
 32764                                  case_dos_create_break:
 32765 00004AC0 5E                      		pop	si
 32766 00004AC1 89EC                    		mov	sp,bp
 32767 00004AC3 5D                      		pop	bp
 32768 00004AC4 C3                      		retn
 32769                                  
 32770                                  ; fdisk.msg (MSDOS 6.0)
 32771                                  ;/***************************************************************************************************/
 32772                                  ;/*  Screen for INPUT_DOS_CREATE                                                                    */
 32773                                  ;/*                                                                                                 */
 32774                                  ;/*     |00000000001111111111222222222233333333334444444444555555555566666666667777777777|          */
 32775                                  ;/*     |01234567890123456789012345678901234567890123456789012345678901234567890123456789|          */
 32776                                  ;/*   --|--------------------------------------------------------------------------------|          */
 32777                                  ;/*   00|                                                                                |          */
 32778                                  ;/*   01|                                                                                |          */
 32779                                  ;/*   02|                                                                                |          */
 32780                                  ;/*   03|                                                                                |          */
 32781                                  ;/*   04|                           Create Primary DOS Partition                         |menu_12 # */
 32782                                  ;/*   05|                                                                                |          */
 32783                                  ;/*   06|    Current fixed disk drive: #                                                 |menu_5 #  */
 32784                                  ;/*   07|                                                                                |          */
 32785                                  ;/*   08|    Partition Status   Type    Size in Mbytes   Percentage of Disk Used         |menu_14   */
 32786                                  ;/*   09|     ## #        #    #######       ####        ###%                            |          */
 32787                                  ;/*   10|     ## #        #    #######       ####        ###%                            |          */
 32788                                  ;/*   11|     ## #        #    #######       ####        ###%                            |          */
 32789                                  ;/*   12|     ## #        #    #######       ####        ###%                            |          */
 32790                                  ;/*   13|                                                                                |          */
 32791                                  ;/*   14|    Total disk space is #### Mbytes (1 Mbyte = 1048576 bytes)                   |menu_15   */
 32792                                  ;/*   15|    Maximum space available for partition is #### Mbytes (###%)                 |menu_16   */
 32793                                  ;/*   16|                                                                                |          */
 32794                                  ;/*   17|                                                                                |          */
 32795                                  ;/*   18|    Enter partition size in Mbytes or percent of disk space (%) to              |menu_39   */
 32796                                  ;/*   19|    create a Primary DOS Partition..................................[####]      |          */
 32797                                  ;/*   20|                                                                                |          */
 32798                                  ;/*   21|                                                                                |          */
 32799                                  ;/*   22|                                                                                |          */
 32800                                  ;/*   23|                                                                                |          */
 32801                                  ;/*   24|    Press ESC to return to FDISK Options                                        |menu_11   */
 32802                                  ;/*   ------------------------------------------------------------------------------------          */ 
 32803                                  ;/*                                                                                                 */
 32804                                  ;/***************************************************************************************************/
 32805                                  
 32806                                  ; c_menus.c (MSDOS 6.0)
 32807                                  ;/*  */
 32808                                  ;/******************* START OF SPECIFICATIONS *******************/
 32809                                  ;/*                                                             */
 32810                                  ;/* SUBROUTINE NAME: INPUT_DOS_CREATE                           */
 32811                                  ;/*                                                             */
 32812                                  ;/* DESCRIPTIVE NAME: Create DOS partition on disk              */
 32813                                  ;/*                                                             */
 32814                                  ;/* FUNCTION: Gets user specified size for partition (maximum   */
 32815                                  ;/*           is 32mb or largest contiguous freespace, which-   */
 32816                                  ;/*           ever is smaller). Default is largest avail free   */
 32817                                  ;/*           space. Partition is created to default size,unless*/
 32818                                  ;/*           user enters different size, but is not marked     */
 32819                                  ;/*           active. User specified size must be smaller or    */
 32820                                  ;/*           equal to the default size                         */
 32821                                  ;/*                                                             */
 32822                                  ;/* NOTES: Screen can be exited via the ESC command before      */
 32823                                  ;/*        partition is created and nothing will change         */
 32824                                  ;/*                                                             */
 32825                                  ;/*        The following screen is managed                      */
 32826                                  ;/*                                                             */
 32827                                  ;/*       |0000000000111111111122222222223333333333|            */
 32828                                  ;/*       |0123456789012345678901234567890123456789|            */
 32829                                  ;/*     --|----------------------------------------|            */
 32830                                  ;/*     00|                                        |            */
 32831                                  ;/*     01|                                        |            */
 32832                                  ;/*     02|                                        |            */
 32833                                  ;/*     03|                                        |            */
 32834                                  ;/*     04|Create DOS partition                    |            */
 32835                                  ;/*     05|                                        |            */
 32836                                  ;/*     06|Current Fixed Disk Drive: #             |            */
 32837                                  ;/*     07|                                        |            */
 32838                                  ;/*     08|Partition Status   Type  Start  End Size|            */
 32839                                  ;/*     09|                                        |            */
 32840                                  ;/*     10|                                        |            */
 32841                                  ;/*     11|                                        |            */
 32842                                  ;/*     12|                                        |            */
 32843                                  ;/*     13|                                        |            */
 32844                                  ;/*     14|Total disk space is #### cylinders.     |            */
 32845                                  ;/*     15|Maximum space available for partition   |            */
 32846                                  ;/*     16|is #### cylinders.                      |            */
 32847                                  ;/*     17|                                        |            */
 32848                                  ;/*     18|Enter partition size............: [####]|            */
 32849                                  ;/*     19|                                        |            */
 32850                                  ;/*     20|                                        |            */
 32851                                  ;/*     21|                                        |            */
 32852                                  ;/*     22|                                        |            */
 32853                                  ;/*     23|Press ESC to return to FDISK Options    |            */
 32854                                  ;/*     --------------------------------------------            */
 32855                                  ;/*                                                             */
 32856                                  ;/* ENTRY POINTS: input_dos_create                              */
 32857                                  ;/*      LINKAGE: input_dos_create();                           */
 32858                                  ;/*               NEAR CALL                                     */
 32859                                  ;/*                                                             */
 32860                                  ;/* INPUT: None                                                 */
 32861                                  ;/*                                                             */
 32862                                  ;/* EXIT-NORMAL: ERROR=FALSE                                    */
 32863                                  ;/*                                                             */
 32864                                  ;/* EXIT-ERROR: ERROR=TRUE                                      */
 32865                                  ;/*             GOTO internal_program_error if case statement   */
 32866                                  ;/*             failure when branching to requested function    */
 32867                                  ;/*                                                             */
 32868                                  ;/* EFFECTS: No data directly modified by this routine, but     */
 32869                                  ;/*          child routines will modify data.                   */
 32870                                  ;/*                                                             */
 32871                                  ;/* INTERNAL REFERENCES:                                        */
 32872                                  ;/*   ROUTINES:                                                 */
 32873                                  ;/*      clear_screen                                           */
 32874                                  ;/*      table_display                                          */
 32875                                  ;/*      get_num_input                                          */
 32876                                  ;/*      display                                                */
 32877                                  ;/*      wait_for_ESC                                           */
 32878                                  ;/*      make_partition                                         */
 32879                                  ;/*      check_bad_tracks                                       */
 32880                                  ;/*                                                             */
 32881                                  ;/* EXTERNAL REFERENCES:                                        */
 32882                                  ;/*   ROUTINES:                                                 */
 32883                                  ;/*                                                             */
 32884                                  ;/******************** END OF SPECIFICATIONS ********************/
 32885                                  
 32886                                  ;/*  */
 32887                                  ;void input_dos_create()
 32888                                  ;
 32889                                  ;BEGIN
 32890                                  ;
 32891                                  ;    unsigned  input;
 32892                                  ;    unsigned  default_entry;
 32893                                  ;    char      temp;
 32894                                  ;
 32895                                  ;    input = u(NUL);                                                    /* AC000 */
 32896                                  ;    /* clear off screen */
 32897                                  ;    clear_screen(u(0),u(0),u(24),u(79));                               /* AC000 */
 32898                                  ;
 32899                                  ;    /* Put up heading */
 32900                                  ;    display(menu_12);
 32901                                  ;
 32902                                  ;    /* Setup and print current disk */
 32903                                  ;    insert[0] = cur_disk+1+'0';
 32904                                  ;    display(menu_5);
 32905                                  ;
 32906                                  ;    /* Print ESC prompt */
 32907                                  ;    display(menu_11);
 32908                                  ;
 32909                                  ;    /* Display partition table-it will return if no partitions there */
 32910                                  ;    table_display();
 32911                                  ;
 32912                                  ;    sprintf(insert,"%4.0d",total_mbytes[cur_disk]);
 32913                                  ;    display(menu_15);
 32914                                  ;
 32915                                  ;    /* Get the free space */
 32916                                  ;    temp = find_part_free_space(c(PRIMARY));                           /* AC000 */
 32917                                  ;
 32918                                  ;    /* Is there any ?*/
 32919                                  ;    if (free_space[temp].mbytes_unused != u(0))                        /* AC000 */
 32920                                  ;
 32921                                  ;        BEGIN
 32922                                  ;        /* Display disk space */
 32923                                  ;        sprintf(insert,"%4.0d",total_mbytes[cur_disk]);
 32924                                  ;        display(menu_15);
 32925                                  ;
 32926                                  ;        /* Setup and print max partition size */
 32927                                  ;
 32928                                  ;        sprintf(insert,"%4.0d%3.0d%%",
 32929                                  ;                free_space[temp].mbytes_unused,
 32930                                  ;                free_space[temp].percent_unused);
 32931                                  ;        display(menu_16);
 32932                                  ;
 32933                                  ;        /* Force repeats on the input until something valid (Non-Zero return) */
 32934                                  ;        default_entry = (unsigned)free_space[temp].mbytes_unused;      /* AC000 */
 32935                                  ;        valid_input = (FLAG)FALSE;                                     /* AC000 */
 32936                                  ;
 32937                                  ;        while (!valid_input)
 32938                                  ;
 32939                                  ;            BEGIN
 32940                                  ;            /* Display prompt */
 32941                                  ;            sprintf(insert,"%4.0d",default_entry);
 32942                                  ;            display(menu_39);
 32943                                  ;
 32944                                  ;            input = get_large_num_input(default_entry,free_space[temp].mbytes_unused,free_space[temp].percent_unused,menu_39,u(0),error_13);       /* AC000 */
 32945                                  ;
 32946                                  ;            /* Update default in case of error, so it gets displayed and used */
 32947                                  ;            /* if user presses CR only */
 32948                                  ;
 32949                                  ;            default_entry = input;
 32950                                  ;            clear_screen(u(19),u(0),u(23),u(79));                     /* AC000 */
 32951                                  ;            END
 32952                                  ;
 32953                                  ;        if (input != ((unsigned)(ESC_FLAG)))                          /* AC000 */
 32954                                  ;
 32955                                  ;            BEGIN
 32956                                  ;            /* Change input to cylinders */
 32957                                  ;            /* check to see if input was in percent or mbytes */
 32958                                  ;
 32959                                  ;            if (PercentFlag)                                          /* AN000 */
 32960                                  ;                BEGIN                                                 /* AN000 */
 32961                                  ;                if (input == free_space[temp].percent_unused)
 32962                                  ;                    input = free_space[temp].space;                   /* AN000 */
 32963                                  ;                else                                                  /* AN000 */
 32964                                  ;                    input = percent_to_cylinders(input,total_disk[cur_disk]);
 32965                                  ;                END                                                   /* AN000 */
 32966                                  ;            else                                                      /* AN000 */
 32967                                  ;                BEGIN                                                 /* AN000 */
 32968                                  ;                if (input == free_space[temp].mbytes_unused)
 32969                                  ;                    input = free_space[temp].space;                   /* AN000 */
 32970                                  ;                else                                                  /* AN000 */
 32971                                  ;                    input = (unsigned)mbytes_to_cylinders(input,
 32972                                  ;                                                          cur_disk);  /* AN004 */
 32973                                  ;                END                                                   /* AN000 */
 32974                                  ;
 32975                                  ;            /* Initialize PecentFlag back to FALSE */
 32976                                  ;            PercentFlag = (FLAG)FALSE;                                /* AN000 */
 32977                                  ;
 32978                                  ;            /* SR; 9/26/89; Display error message if input value = 0 */
 32979                                  ;
 32980                                  ;            if (input == 0)
 32981                                  ;               {
 32982                                  ;                display(error_28);
 32983                                  ;                wait_for_ESC();
 32984                                  ;               }
 32985                                  ;            else
 32986                                  ;               {
 32987                                  ;            	/* Go create the partition */
 32988                                  ;            	make_partition(input,temp,uc(NUL),c(PRIMARY));         /* AC000 */
 32989                                  ;
 32990                                  ;            	/* clear off the old prompt */
 32991                                  ;            	clear_screen(u(13),u(0),u(19),u(79));                  /* AC000 */
 32992                                  ;
 32993                                  ;            	/* Reissue the partition info */
 32994                                  ;            	table_display();
 32995                                  ;
 32996                                  ;            	/* display the "okay, we did it" msg */
 32997                                  ;            	if (number_of_drives == uc(1))                         /* AN000 */
 32998                                  ;                	display(status_5);
 32999                                  ;            	else
 33000                                  ;                    BEGIN                                             /* AN000 */
 33001                                  ;                    clear_screen(u(16),u(0),u(23),u(79));             /* AN000 */
 33002                                  ;                    display(status_12);                               /* AN000 */
 33003                                  ;                    END                                               /* AN000 */
 33004                                  ;
 33005                                  ;            	wait_for_ESC();
 33006                                  ;
 33007                                  ;            	reboot_flag = TRUE;
 33008                                  ;               }
 33009                                  ;
 33010                                  ;            END
 33011                                  ;        END
 33012                                  ;    /* SR; 9/26/89; Display error if insufficient space for partition */
 33013                                  ;    else
 33014                                  ;        {
 33015                                  ;        display(error_10);
 33016                                  ;        wait_for_ESC();
 33017                                  ;        }
 33018                                  ;    return;
 33019                                  ;END
 33020                                  
 33021                                  input_dos_create:
 33022                                  		; 14/01/2019
 33023                                  
 33024                                  	%define idc_def_entry	bp-6
 33025                                  	%define	idc_temp	bp-4
 33026                                  	%define idc_input	bp-2
 33027                                  
 33028 00004AC5 55                      		push	bp
 33029 00004AC6 89E5                    		mov	bp,sp
 33030 00004AC8 83EC06                  		sub	sp,6
 33031                                  
 33032                                  		;push	si
 33033                                  
 33034                                  		;/* clear off screen */
 33035                                  		
 33036                                  		;mov	ax,79
 33037                                  		;push	ax
 33038                                  		;mov	ax,24
 33039                                  		;push	ax
 33040                                  		;sub	ax,ax
 33041                                  		;mov	[idc_input],ax
 33042                                  		;push	ax
 33043                                  		;push	ax
 33044                                  		;call	clear_screen
 33045                                  		;add	sp,8
 33046                                  
 33047 00004ACB E890C9                  		call	CLS
 33048                                  
 33049 00004ACE C746FE0000              		mov	word [idc_input],0
 33050                                  
 33051                                  		;/* Put up heading */
 33052                                  
 33053                                  		;push	word [menu_12_segment]
 33054 00004AD3 1E                      		push	ds
 33055 00004AD4 FF36[0B9E]              		push	word [menu_12_offset]
 33056 00004AD8 E849CB                  		call	display
 33057                                  		;pop	bx
 33058                                  		;pop	bx
 33059                                  
 33060                                  		;/* Setup and print current disk */
 33061                                  
 33062 00004ADB A0[E2CB]                		mov	al,[cur_disk]
 33063 00004ADE 0431                    		add	al,'1'
 33064 00004AE0 A2[F4CC]                		mov	[insert],al
 33065                                  		;push	word [menu_5_segment]
 33066 00004AE3 1E                      		push	ds
 33067 00004AE4 FF36[FD9D]              		push	word [menu_5_offset]
 33068 00004AE8 E839CB                  		call	display
 33069                                  		;pop	bx
 33070                                  		;pop	bx
 33071                                  
 33072                                  		;/* Print ESC prompt */
 33073                                  
 33074                                  		;push	word [menu_11_segment]
 33075 00004AEB 1E                      		push	ds
 33076 00004AEC FF36[099E]              		push	word [menu_11_offset]
 33077 00004AF0 E831CB                  		call	display
 33078                                  		;pop	bx
 33079                                  		;pop	bx
 33080                                  
 33081                                  	;/* Display partition table - it will return if no partitions there */
 33082                                  
 33083 00004AF3 E881E3                  		call	table_display
 33084                                  
 33085 00004AF6 A0[E2CB]                		mov	al,[cur_disk]
 33086 00004AF9 98                      		cbw
 33087 00004AFA 89C3                    		mov	bx,ax
 33088 00004AFC D1E3                    		shl	bx,1
 33089 00004AFE FFB7[D6A0]              		push	word [total_mbytes+bx]
 33090 00004B02 B8[926F]                		mov	ax,idc_tot_mb_format ; "%4.1d"
 33091 00004B05 50                      		push	ax
 33092 00004B06 B8[F4CC]                		mov	ax,insert
 33093 00004B09 50                      		push	ax
 33094 00004B0A E8B8D7                  		call	sprintf
 33095 00004B0D 83C406                  		add	sp,6
 33096                                  
 33097                                  		;push	word [menu_15_segment]
 33098 00004B10 1E                      		push	ds
 33099 00004B11 FF36[139E]              		push	word [menu_15_offset]
 33100 00004B15 E80CCB                  		call	display
 33101                                  		;pop	bx
 33102                                  		;pop	bx
 33103                                  
 33104                                  		;/* Get the free space */
 33105                                  
 33106 00004B18 28C0                    		sub	al,al ; 0
 33107                                  		;push	ax
 33108 00004B1A E88105                  		call	find_part_free_space
 33109                                  		;pop	bx
 33110 00004B1D 8846FC                  		mov	[idc_temp],al
 33111                                  
 33112                                  		;mov	cl,22
 33113 00004B20 B10A                    		mov	cl,10 ; 14/01/2019
 33114                                  		;imul	cl
 33115 00004B22 F6E1                    		mul	cl
 33116 00004B24 89C3                    		mov	bx,ax
 33117                                  
 33118                                  		;/* Is there any ?*/
 33119                                  
 33120 00004B26 83BF[F6CB]00            		cmp	word [free_space.mbytes_unused+bx],0
 33121 00004B2B 7503                    		jne	short idc_1
 33122 00004B2D E95501                  		jmp	idc_12
 33123                                  idc_1:
 33124                                  		; /* Display disk space */
 33125                                  
 33126 00004B30 A0[E2CB]                		mov	al,[cur_disk]
 33127 00004B33 98                      		cbw
 33128 00004B34 89C6                    		mov	si,ax
 33129 00004B36 D1E6                    		shl	si,1
 33130 00004B38 FFB4[D6A0]              		push	word [total_mbytes+si]
 33131 00004B3C B8[926F]                		mov	ax,idc_tot_mb_format ; "%4.1d"
 33132 00004B3F 50                      		push	ax
 33133 00004B40 B8[F4CC]                		mov	ax,insert
 33134 00004B43 50                      		push	ax
 33135 00004B44 89DE                    		mov	si,bx
 33136 00004B46 E87CD7                  		call	sprintf
 33137 00004B49 83C406                  		add	sp,6
 33138                                  
 33139                                  		;push	word [menu_15_segment]
 33140 00004B4C 1E                      		push	ds
 33141 00004B4D FF36[139E]              		push	word [menu_15_offset]
 33142 00004B51 E8D0CA                  		call	display
 33143                                  		;pop	bx
 33144                                  		;pop	bx
 33145                                  
 33146                                  		;/* Setup and print max partition size */
 33147                                  
 33148 00004B54 FFB4[F8CB]              		push	word [free_space.percent_unused+si]
 33149 00004B58 FFB4[F6CB]              		push	word [free_space.mbytes_unused+si]
 33150 00004B5C B8[986F]                		mov	ax,idc_mb_pcent_format ; "%4.1d%3.1d%%"
 33151 00004B5F 50                      		push	ax
 33152 00004B60 B8[F4CC]                		mov	ax, insert
 33153 00004B63 50                      		push	ax
 33154 00004B64 E85ED7                  		call	sprintf
 33155 00004B67 83C408                  		add	sp,8
 33156                                  
 33157                                  		;push	word [menu_16_segment]
 33158 00004B6A 1E                      		push	ds
 33159 00004B6B FF36[159E]              		push	word [menu_16_offset]
 33160 00004B6F E8B2CA                  		call	display
 33161                                  		;pop	bx
 33162                                  		;pop	bx
 33163                                  
 33164 00004B72 8B84[F6CB]              		mov	ax,[free_space.mbytes_unused+si]
 33165 00004B76 8946FA                  		mov	[idc_def_entry],ax
 33166 00004B79 C606[ECCB]00            		mov	byte  [valid_input],0
 33167                                  idc_2:
 33168                                  		;/* Display prompt */
 33169                                  
 33170 00004B7E FF76FA                  		push	word [idc_def_entry]
 33171 00004B81 B8[926F]                		mov	ax,idc_def_entry_format ; "%4.1d"
 33172 00004B84 50                      		push	ax
 33173 00004B85 B8[F4CC]                		mov	ax,insert
 33174 00004B88 50                      		push	ax
 33175 00004B89 E839D7                  		call	sprintf
 33176 00004B8C 83C406                  		add	sp,6
 33177                                  
 33178                                  		;push	word [menu_39_segment]
 33179 00004B8F 1E                      		push	ds
 33180 00004B90 FF36[179E]              		push	word [menu_39_offset]
 33181 00004B94 E88DCA                  		call	display
 33182                                  		;pop	bx
 33183                                  		;pop	bx
 33184                                  
 33185                                  		;push	word [error_13_seg]   	
 33186 00004B97 1E                      		push	ds		       ; glni_err_msg_seg	
 33187 00004B98 FF36[9A9E]              		push	word [error_13_off]    ; glni_err_msg
 33188 00004B9C 29C0                    		sub	ax,ax
 33189 00004B9E 50                      		push	ax		       ; glni_prompt_loc	
 33190                                  		;push	word [menu_39_segment]
 33191 00004B9F 1E                      		push	ds		       ; glni_input_msg_seg	
 33192 00004BA0 FF36[179E]              		push	word [menu_39_offset]  ; glni_input_msg
 33193                                  		;mov	al,22
 33194 00004BA4 B00A                    		mov	al,10 ; 14/01/2019
 33195                                  		;imul	byte [idc_temp]
 33196 00004BA6 F666FC                  		mul	byte [idc_temp]
 33197 00004BA9 89C3                    		mov	bx,ax
 33198 00004BAB FFB7[F8CB]              		push	word [free_space.percent_unused+bx] ; glni_max_pc
 33199 00004BAF FFB7[F6CB]              		push	word [free_space.mbytes_unused+bx]  ; glni_max_num
 33200 00004BB3 FF76FA                  		push	word [idc_def_entry]	; glni_input_def
 33201 00004BB6 E8CC07                  		call	get_large_num_input
 33202                                  		;add	sp,16
 33203                                  
 33204                                  	;/* Update default in case of error, so it gets displayed and used */
 33205                                  	;/* if user presses CR only */
 33206                                  
 33207 00004BB9 8946FE                  		mov	[idc_input],ax
 33208 00004BBC 8946FA                  		mov	[idc_def_entry],ax
 33209                                  
 33210 00004BBF B84F00                  		mov	ax,79
 33211 00004BC2 50                      		push	ax
 33212 00004BC3 B81700                  		mov	ax,23
 33213 00004BC6 50                      		push	ax
 33214 00004BC7 29C0                    		sub	ax,ax
 33215 00004BC9 50                      		push	ax
 33216 00004BCA B81300                  		mov	ax,19
 33217 00004BCD 50                      		push	ax
 33218 00004BCE E8C5C8                  		call	clear_screen
 33219                                  		;add	sp,8
 33220                                  
 33221                                  	;/* Force repeats on the input until something valid (Non-Zero return) */
 33222                                  
 33223 00004BD1 803E[ECCB]00            		cmp	byte [valid_input],0
 33224 00004BD6 74A6                    		je	short idc_2
 33225                                  
 33226 00004BD8 837EFEFE                		cmp	word [idc_input],0FFFEh ; -2 ; ESC flag?
 33227 00004BDC 7503                    		jne	short idc_3
 33228 00004BDE E9AF00                  		jmp	idc_14
 33229                                  
 33230                                  idc_3:
 33231                                  		;/* Change input to cylinders */
 33232                                  		;/* check to see if input was in percent or mbytes */
 33233                                  
 33234                                  		;mov	al,22
 33235 00004BE1 B00A                    		mov	al,10 ; 14/01/2019
 33236                                  		;imul	byte [idc_temp]
 33237 00004BE3 F666FC                  		mul	byte [idc_temp]
 33238 00004BE6 89C3                    		mov	bx,ax
 33239 00004BE8 8B46FE                  		mov	ax,[idc_input]
 33240                                  
 33241 00004BEB 803E[E0C3]00            		cmp	byte [PercentFlag],0
 33242 00004BF0 741B                    		je	short idc_6
 33243                                  
 33244                                  		;mov	al,22
 33245                                  		;;imul	byte [idc_temp]
 33246                                  		;mul	byte [idc_temp]
 33247                                  		;mov	bx,ax
 33248                                  		;mov	ax,[idc_input]
 33249                                  
 33250 00004BF2 3987[F8CB]              		cmp	[free_space.percent_unused+bx],ax
 33251 00004BF6 7506                    		jne	short idc_5 ; < 100
 33252                                  idc_4:
 33253 00004BF8 8B87[F0CB]              		mov	ax,[free_space.space+bx]
 33254 00004BFC EB1F                    		jmp	short idc_8
 33255                                  idc_5:
 33256                                  		; 19/01/2019
 33257                                  
 33258                                  		;mov	al,[cur_disk]
 33259                                  		;cbw
 33260                                  		;mov	bx,ax
 33261                                  		;shl	bx,1
 33262                                  		
 33263 00004BFE 8A1E[E2CB]              		mov	bl,[cur_disk]
 33264                                  		;xor	bh,bh ; bh = 0
 33265 00004C02 D0E3                    		shl	bl,1
 33266                                  
 33267                                  		; ax = [idc_input]  ; percent in
 33268                                  		
 33269                                  		;push	word [total_disk+bx]
 33270 00004C04 8B8F[C6A0]              		mov	cx,[total_disk+bx] ; total cylinders
 33271                                  		;push	word [idc_input]
 33272                                  		;mov	ax,[idc_input] ; < 100
 33273 00004C08 E8150B                  		call	percent_to_cylinders
 33274 00004C0B EB10                    		jmp	short idc_7
 33275                                  idc_6:
 33276                                  		;mov	al,22
 33277                                  		;imul	byte [idc_temp]
 33278                                  		;mul	byte [idc_temp]
 33279                                  		;mov	bx,ax
 33280                                  		;mov	ax,[idc_input]
 33281                                  
 33282 00004C0D 3987[F6CB]              		cmp	[free_space.mbytes_unused+bx],ax
 33283 00004C11 74E5                    		jz	short idc_4
 33284                                  
 33285 00004C13 A0[E2CB]                		mov	al,[cur_disk]
 33286 00004C16 50                      		push	ax
 33287 00004C17 FF76FE                  		push	word [idc_input]
 33288 00004C1A E8AC0A                  		call	mbytes_to_cylinders
 33289                                  idc_7:
 33290                                  		;pop	bx
 33291                                  		;pop	bx
 33292                                  idc_8:
 33293 00004C1D 8946FE                  		mov	[idc_input],ax
 33294                                  
 33295                                  		;/* Initialize PecentFlag back to FALSE */
 33296                                  
 33297 00004C20 C606[E0C3]00            		mov	byte [PercentFlag],0
 33298                                  
 33299                                  		; Display error message if input value = 0 */
 33300                                  
 33301 00004C25 09C0                    		or	ax,ax
 33302 00004C27 7507                    		jnz	short idc_9
 33303                                  		
 33304                                  		;push	word [error_28_seg]
 33305 00004C29 1E                      		push	ds
 33306 00004C2A FF36[B69E]              		push	word [error_28_off]
 33307 00004C2E EB5A                    		jmp	short idc_13
 33308                                  idc_9:
 33309                                  		;/* Go create the partition */
 33310                                  		;make_partition(input,temp,uc(NUL),c(PRIMARY));
 33311                                  
 33312 00004C30 28C0                    		sub	al,al ; 0
 33313 00004C32 50                      		push	ax		 ; mp_type - PRIMARY -  
 33314 00004C33 50                      		push	ax		 ; mp_bootable - not bootable - 
 33315 00004C34 8A46FC                  		mov	al,[idc_temp]
 33316 00004C37 50                      		push	ax		 ; mp_free_ptr 
 33317 00004C38 FF76FE                  		push	word [idc_input] ; mp_size
 33318 00004C3B E81209                  		call	make_partition
 33319                                  		;add	sp,8
 33320                                  
 33321                                  		;/* clear off the old prompt */
 33322                                  
 33323 00004C3E B84F00                  		mov	ax,79
 33324 00004C41 50                      		push	ax
 33325 00004C42 B81300                  		mov	ax,19
 33326 00004C45 50                      		push	ax
 33327 00004C46 29C0                    		sub	ax,ax
 33328 00004C48 50                      		push	ax
 33329 00004C49 B80D00                  		mov	ax,13
 33330 00004C4C 50                      		push	ax
 33331 00004C4D E846C8                  		call	clear_screen
 33332                                  		;add	sp,8
 33333                                  
 33334                                  		;/* Reissue the partition info */
 33335                                  		
 33336 00004C50 E824E2                  		call	table_display
 33337                                  
 33338                                  		;/* display the "okay, we did it" msg */
 33339                                  		
 33340 00004C53 803E[E3C3]01            		cmp	byte [number_of_drives],1
 33341 00004C58 7507                    		jne	short idc_10
 33342                                  		
 33343                                  		;push	word [status_5_seg]
 33344 00004C5A 1E                      		push	ds
 33345 00004C5B FF36[739E]              		push	word [status_5_off]
 33346 00004C5F EB17                    		jmp	short idc_11
 33347                                  idc_10:
 33348 00004C61 B84F00                  		mov	ax,79
 33349 00004C64 50                      		push	ax
 33350 00004C65 B81700                  		mov	ax,23
 33351 00004C68 50                      		push	ax
 33352 00004C69 29C0                    		sub	ax,ax
 33353 00004C6B 50                      		push	ax
 33354 00004C6C B81000                  		mov	ax,16
 33355 00004C6F 50                      		push	ax
 33356 00004C70 E823C8                  		call	clear_screen
 33357                                  		;add	sp,8
 33358                                  
 33359                                  		;push	word [status_12_seg]
 33360 00004C73 1E                      		push	ds
 33361 00004C74 FF36[7F9E]              		push	word [status_12_off]
 33362                                  idc_11:
 33363 00004C78 E8A9C9                  		call	display
 33364                                  		;pop	bx
 33365                                  		;pop	bx
 33366                                  
 33367 00004C7B E8F6E4                  		call	wait_for_ESC
 33368                                  
 33369 00004C7E C606[78A0]01            		mov	byte [reboot_flag],1 ; TRUE
 33370 00004C83 EB0B                    		jmp	short idc_14
 33371                                  idc_12:
 33372                                  		; Display error if insufficient space for partition */
 33373                                  
 33374                                  		;push	word [error_10_seg]
 33375 00004C85 1E                      		push	ds
 33376 00004C86 FF36[969E]              		push	word [error_10_off]
 33377                                  idc_13:
 33378 00004C8A E897C9                  		call	display
 33379                                  		;pop	bx
 33380                                  		;pop	bx
 33381                                  
 33382 00004C8D E8E4E4                  		call	wait_for_ESC
 33383                                  idc_14:
 33384                                  		;pop	si
 33385                                  
 33386 00004C90 89EC                    		mov	sp, bp
 33387 00004C92 5D                      		pop	bp
 33388 00004C93 C3                      		retn
 33389                                  
 33390                                  ;/***************************************************************************************************/
 33391                                  ;/*  Screen for EXT_CREATE_PARTITION                                                                */
 33392                                  ;/*                                                                                                 */
 33393                                  ;/*     |00000000001111111111222222222233333333334444444444555555555566666666667777777777|          */
 33394                                  ;/*     |01234567890123456789012345678901234567890123456789012345678901234567890123456789|          */
 33395                                  ;/*   --|--------------------------------------------------------------------------------|          */
 33396                                  ;/*   00|                                                                                |          */
 33397                                  ;/*   01|                                                                                |          */
 33398                                  ;/*   02|                                                                                |          */
 33399                                  ;/*   03|                                                                                |          */
 33400                                  ;/*   04|                           Create Extended DOS Partition                        |menu_17   */
 33401                                  ;/*   05|                                                                                |          */
 33402                                  ;/*   06|    Current fixed disk drive: #                                                 |menu_5 #  */
 33403                                  ;/*   07|                                                                                |          */
 33404                                  ;/*   08|    Partition Status   Type    Size in Mbytes   Percentage of Disk Used         |menu_14 # */
 33405                                  ;/*   09|     ##  #       #   #######       ####                   ###%                  |          */
 33406                                  ;/*   10|     ##  #       #   #######       ####                   ###%                  |          */
 33407                                  ;/*   11|     ##  #       #   #######       ####                   ###%                  |          */
 33408                                  ;/*   12|     ##  #       #   #######       ####                   ###%                  |          */
 33409                                  ;/*   13|                                                                                |          */
 33410                                  ;/*   14|    Total disk space is #### Mbytes (1 Mbyte = 1048576 bytes)                   |menu_15 # */
 33411                                  ;/*   15|    Maximum space available for partition is #### Mbytes (##%)                  |menu_16 # */
 33412                                  ;/*   16|                                                                                |          */
 33413                                  ;/*   17|                                                                                |          */
 33414                                  ;/*   18|    Enter partition size in Mbytes or percent of disk space (%) to              |menu_42 # */
 33415                                  ;/*   19|    create an Extended DOS Partition................................[####]      |          */
 33416                                  ;/*   20|                                                                                |          */
 33417                                  ;/*   21|                                                                                |          */
 33418                                  ;/*   22|                                                                                |          */
 33419                                  ;/*   23|                                                                                |          */
 33420                                  ;/*   24|    Press ESC to continue                                                       |menu_46   */
 33421                                  ;/*   ------------------------------------------------------------------------------------          */ 
 33422                                  ;/*                                                                                                 */
 33423                                  ;/***************************************************************************************************/
 33424                                  
 33425                                  ; c_menus.c (MSDOS 6.0)
 33426                                  ;/*  */
 33427                                  ;/******************* START OF SPECIFICATIONS *******************/
 33428                                  ;/*                                                             */
 33429                                  ;/* SUBROUTINE NAME: EXT_CREATE_PARTITION                       */
 33430                                  ;/*                                                             */
 33431                                  ;/* DESCRIPTIVE NAME: Create EXTENDED DOS partition             */
 33432                                  ;/*                                                             */
 33433                                  ;/* FUNCTION: Gets user specified size for EXTENDED partition   */
 33434                                  ;/*           (Maximum is largest contiguous freespace). The    */
 33435                                  ;/*           default is the largest available freespace.       */
 33436                                  ;/*           space. Partition is created to default size,      */
 33437                                  ;/*           unless user enters different size, but is not     */
 33438                                  ;/*           marked as active. User specified size must be     */
 33439                                  ;/*           smaller or equal to default size                  */
 33440                                  ;/*                                                             */
 33441                                  ;/* NOTES: Screen can be exited via the ESC command before      */
 33442                                  ;/*        partition is created and nothing will change         */
 33443                                  ;/*                                                             */
 33444                                  ;/*        The following screen is managed                      */
 33445                                  ;/*                                                             */
 33446                                  ;/*       |0000000000111111111122222222223333333333|            */
 33447                                  ;/*       |0123456789012345678901234567890123456789|            */
 33448                                  ;/*     --|----------------------------------------|            */
 33449                                  ;/*     00|                                        |            */
 33450                                  ;/*     01|                                        |            */
 33451                                  ;/*     02|                                        |            */
 33452                                  ;/*     03|                                        |            */
 33453                                  ;/*     04|Create EXTENDED DOS partition           |            */
 33454                                  ;/*     05|                                        |            */
 33455                                  ;/*     06|Current Fixed Disk Drive: #             |            */
 33456                                  ;/*     07|                                        |            */
 33457                                  ;/*     08|Partition Status   Type  Start  End Size|            */
 33458                                  ;/*     09|                                        |            */
 33459                                  ;/*     10|                                        |            */
 33460                                  ;/*     11|                                        |            */
 33461                                  ;/*     12|                                        |            */
 33462                                  ;/*     13|                                        |            */
 33463                                  ;/*     14|Total disk space is  #### cylinders.    |            */
 33464                                  ;/*     15|Maximum space available for partition   |            */
 33465                                  ;/*     16|is #### cylinders.                      |            */
 33466                                  ;/*     17|                                        |            */
 33467                                  ;/*     18|Enter partition size............: [####]|            */
 33468                                  ;/*     19|                                        |            */
 33469                                  ;/*     20|                                        |            */
 33470                                  ;/*     21|                                        |            */
 33471                                  ;/*     22|                                        |            */
 33472                                  ;/*     23|Press ESC to return to FDISK Options    |            */
 33473                                  ;/*     --------------------------------------------            */
 33474                                  ;/*                                                             */
 33475                                  ;/* ENTRY POINTS: EXTENDED_create_partition                     */
 33476                                  ;/*      LINKAGE: EXTENDED_create_partition();                  */
 33477                                  ;/*               NEAR CALL                                     */
 33478                                  ;/*                                                             */
 33479                                  ;/* INPUT: None                                                 */
 33480                                  ;/*                                                             */
 33481                                  ;/* EXIT-NORMAL: ERROR=FALSE                                    */
 33482                                  ;/*                                                             */
 33483                                  ;/* EXIT-ERROR: ERROR=TRUE                                      */
 33484                                  ;/*             GOTO internal_program_error if case statement   */
 33485                                  ;/*             failure when branching to requested function    */
 33486                                  ;/*                                                             */
 33487                                  ;/* EFFECTS: No data directly modified by this routine, but     */
 33488                                  ;/*          child routines will modify data.                   */
 33489                                  ;/*                                                             */
 33490                                  ;/* INTERNAL REFERENCES:                                        */
 33491                                  ;/*   ROUTINES:                                                 */
 33492                                  ;/*      clear_screen                                           */
 33493                                  ;/*      table_display                                          */
 33494                                  ;/*      get_num_input                                          */
 33495                                  ;/*      display                                                */
 33496                                  ;/*      find_partition_type                                    */
 33497                                  ;/*      wait_for_ESC                                           */
 33498                                  ;/*      make_partition                                         */
 33499                                  ;/*                                                             */
 33500                                  ;/* EXTERNAL REFERENCES:                                        */
 33501                                  ;/*   ROUTINES:                                                 */
 33502                                  ;/*                                                             */
 33503                                  ;/******************** END OF SPECIFICATIONS ********************/
 33504                                  
 33505                                  ;/*  */
 33506                                  ;void ext_create_partition()
 33507                                  ;
 33508                                  ;BEGIN
 33509                                  ;
 33510                                  ;    unsigned  input;
 33511                                  ;    unsigned  default_entry;
 33512                                  ;    char      temp;
 33513                                  ;
 33514                                  ;    input = u(NUL);                                                    /* AC000 */
 33515                                  ;    /* clear off screen */
 33516                                  ;    clear_screen(u(0),u(0),u(24),u(79));                               /* AC000 */
 33517                                  ;
 33518                                  ;    /* Put up heading */
 33519                                  ;    display(menu_17);
 33520                                  ;
 33521                                  ;    /* Setup and print current disk */
 33522                                  ;    insert[0] = cur_disk+1+'0';
 33523                                  ;    display(menu_5);
 33524                                  ;
 33525                                  ;    /* print ESC prompt */
 33526                                  ;    display(menu_11);
 33527                                  ;
 33528                                  ;    /* Display partition table-it will return if no partitions there */
 33529                                  ;        table_display();
 33530                                  ;
 33531                                  ;    /* Go see if primary already exists and ext doesn't */
 33532                                  ;    if ((cur_disk >= c(1)) || (find_partition_type(uc(DOS12))) || (find_partition_type(uc(DOS16))) ||
 33533                                  ;        (find_partition_type(uc(DOSNEW))))                                            /* AC000 */
 33534                                  ;        BEGIN
 33535                                  ;        if (!find_partition_type(uc(EXTENDED)))                         /* AC000 */
 33536                                  ;            /* We can go create one now */
 33537                                  ;            BEGIN
 33538                                  ;
 33539                                  ;            /* Get the free space */
 33540                                  ;            temp = find_part_free_space(c(EXTENDED));                   /* AC000 */
 33541                                  ;
 33542                                  ;            /* Is there any ?*/
 33543                                  ;            /* SR; 9/26/89; Instead of checking only the percentage which
 33544                                  ;               could be off because of rounding errors, we also check the
 33545                                  ;               mbytes available */
 33546                                  ;
 33547                                  ;            if (free_space[temp].space != u(0) &&                       /* AC000 */
 33548                                  ;                (free_space[temp].percent_unused != u(0) ||
 33549                                  ;                 free_space[temp].mbytes_unused != u(0)))
 33550                                  ;                BEGIN
 33551                                  ;
 33552                                  ;                /* Display disk space */
 33553                                  ;                sprintf(insert,"%4.0d",total_mbytes[cur_disk]);
 33554                                  ;                display(menu_15);
 33555                                  ;
 33556                                  ;                /* Setup and print max partition size */
 33557                                  ;
 33558                                  ;                sprintf(insert,"%4.0d%3.0d%%",
 33559                                  ;                        free_space[temp].mbytes_unused,
 33560                                  ;                        free_space[temp].percent_unused);
 33561                                  ;                display(menu_16);
 33562                                  ;
 33563                                  ;                /* Force repeats on the input until something valid (Non-Zero return) */
 33564                                  ;                /* Display MBytes unless MBytes == 0, then display percent */
 33565                                  ;                if (free_space[temp].mbytes_unused == u(0))             /* AN000 */
 33566                                  ;                    BEGIN                                               /* AN000 */
 33567                                  ;                    default_entry = (unsigned)free_space[temp].percent_unused; /* AC000 */
 33568                                  ;                    PercentFlag = (FLAG)TRUE;                           /* AN000 */
 33569                                  ;                    END                                                 /* AN000 */
 33570                                  ;                else                                                    /* AN000 */
 33571                                  ;                    BEGIN
 33572                                  ;                    default_entry = (unsigned)free_space[temp].mbytes_unused; /* AC000 */
 33573                                  ;                    PercentFlag = (FLAG)FALSE;                          /* AN000 */
 33574                                  ;                    END
 33575                                  ;
 33576                                  ;                valid_input = (FLAG)FALSE;                              /* AC000 */
 33577                                  ;
 33578                                  ;                while (!valid_input)
 33579                                  ;                    BEGIN
 33580                                  ;                    /* Display prompt */
 33581                                  ;                    if (!PercentFlag)                                   /* AN000 */
 33582                                  ;                        sprintf(insert,"%4.0d",default_entry);
 33583                                  ;                    else                                                /* AN000 */
 33584                                  ;                        sprintf(insert,"%3.0d%%",default_entry);        /* AN000 */
 33585                                  ;                    display(menu_42);                                   /* AC000 */
 33586                                  ;
 33587                                  ;                    input = get_large_num_input(default_entry,free_space[temp].mbytes_unused,free_space[temp].percent_unused,menu_42,u(0),error_13);   /*  AC000 */
 33588                                  ;
 33589                                  ;                    /* Update default in case of error, so it gets displayed and used */
 33590                                  ;                    /* if user presses CR only */
 33591                                  ;
 33592                                  ;                    default_entry = input;
 33593                                  ;                    clear_screen(u(19),u(0),u(23),u(79));                /* AC000 */
 33594                                  ;                    END
 33595                                  ;
 33596                                  ;                if (input != ((unsigned)(ESC_FLAG)))                          /* AC000 */
 33597                                  ;                    BEGIN
 33598                                  ;
 33599                                  ;                    /* Change input to cylinders */
 33600                                  ;                    if (PercentFlag)                                          /* AN000 */
 33601                                  ;                        BEGIN                                                 /* AN000 */
 33602                                  ;                        if (input == free_space[temp].percent_unused)
 33603                                  ;                            input = free_space[temp].space;                   /* AN000 */
 33604                                  ;                        else                                                  /* AN000 */
 33605                                  ;                            input = percent_to_cylinders(input,total_disk[cur_disk]);
 33606                                  ;                        END                                                   /* AN000 */
 33607                                  ;                    else                                                      /* AN000 */
 33608                                  ;                        BEGIN                                                 /* AN000 */
 33609                                  ;                        if (input == free_space[temp].mbytes_unused)
 33610                                  ;                            input = free_space[temp].space;                   /* AN000 */
 33611                                  ;                        else                                                  /* AN000 */
 33612                                  ;                            input = (unsigned)mbytes_to_cylinders(input,
 33613                                  ;                                                                  cur_disk);  /* AN004 */
 33614                                  ;                        END                                                   /* AN000 */
 33615                                  ;
 33616                                  ;
 33617                                  ;                    /* Initialize PecentFlag back to FALSE */
 33618                                  ;                    PercentFlag = (FLAG)FALSE;                                /* AN000 */
 33619                                  ;
 33620                                  ;                    /* SR; 9/26/89; Display error message if input value = 0 */
 33621                                  ;
 33622                                  ;                    if (input == 0)
 33623                                  ;                       {
 33624                                  ;                        display(error_28);
 33625                                  ;                        wait_for_ESC();
 33626                                  ;                       }
 33627                                  ;                    else
 33628                                  ;                       {
 33629                                  ;
 33630                                  ;                    	/* Go create the partition */
 33631                                  ;                    	make_partition(input,temp,uc(NUL),c(EXTENDED));     /* AC000 */
 33632                                  ;
 33633                                  ;                    	/* clear off the old prompt */
 33634                                  ;                    	clear_screen(u(13),u(0),u(19),u(79));               /* AC000 */
 33635                                  ;
 33636                                  ;                    	/* Display the updated partition information */
 33637                                  ;                    	table_display();
 33638                                  ;
 33639                                  ;                    	/* Tell user we created it */
 33640                                  ;                    	display(status_6);
 33641                                  ;                    	wait_for_ESC();
 33642                                  ;
 33643                                  ;                    	reboot_flag = (FLAG)TRUE;                           /* AC000 */
 33644                                  ;
 33645                                  ;                    	/* Go allow him to create disk volumes */
 33646                                  ;                    	volume_create();
 33647                                  ;                       }
 33648                                  ;                    END
 33649                                  ;                END
 33650                                  ;            else
 33651                                  ;                BEGIN
 33652                                  ;                /* No room */
 33653                                  ;                display(error_10);
 33654                                  ;                wait_for_ESC();
 33655                                  ;                END
 33656                                  ;            END
 33657                                  ;        else
 33658                                  ;            BEGIN
 33659                                  ;            /* Already have ext partition, tell user and bow out */
 33660                                  ;            display(error_9);
 33661                                  ;            wait_for_ESC();
 33662                                  ;            END
 33663                                  ;        END
 33664                                  ;    else
 33665                                  ;        BEGIN
 33666                                  ;        /* don't have a primary partition yet, can't create an ext */
 33667                                  ;        display(error_19);
 33668                                  ;        wait_for_ESC();
 33669                                  ;        END
 33670                                  ;
 33671                                  ;    return;
 33672                                  ;END
 33673                                  
 33674                                  ext_create_partition:
 33675                                  		; 25/01/2019
 33676                                  
 33677                                  	%define ecp_default_entry bp-6
 33678                                  	%define ecp_temp	  bp-4
 33679                                  	%define ecp_input	  bp-2
 33680                                  
 33681 00004C94 55                      		push	bp
 33682 00004C95 89E5                    		mov	bp,sp
 33683 00004C97 83EC06                  		sub	sp,6
 33684                                  
 33685                                  		;push	si
 33686                                  		
 33687                                  		;/* clear off screen */
 33688                                  
 33689                                  		;mov	ax,79
 33690                                  		;push	ax
 33691                                  		;mov	ax,24
 33692                                  		;push	ax
 33693                                  		;sub	ax,ax
 33694                                  		;mov	[ecp_input],ax
 33695                                  		;push	ax
 33696                                  		;push	ax
 33697                                  		;call	clear_screen
 33698                                  		;add	sp,8
 33699                                  		
 33700 00004C9A E8C1C7                  		call	CLS
 33701                                  
 33702 00004C9D C746FE0000              		mov	word [ecp_input],0
 33703                                  
 33704                                  		;/* Put up heading */
 33705                                  
 33706                                  		;push	word [menu_17_segment]
 33707 00004CA2 1E                      		push	ds
 33708 00004CA3 FF36[199E]              		push	word [menu_17_offset]
 33709 00004CA7 E87AC9                  		call	display
 33710                                  		;pop	bx
 33711                                  		;pop	bx
 33712                                  
 33713                                  		;/* Setup and print current disk */
 33714                                  
 33715 00004CAA A0[E2CB]                		mov	al,[cur_disk]
 33716 00004CAD 0431                    		add	al,'1'
 33717 00004CAF A2[F4CC]                		mov	[insert],al
 33718                                  
 33719                                  		;push	word [menu_5_segment]
 33720 00004CB2 1E                      		push	ds
 33721 00004CB3 FF36[FD9D]              		push	word [menu_5_offset]
 33722 00004CB7 E86AC9                  		call	display
 33723                                  		;pop	bx
 33724                                  		;pop	bx
 33725                                  
 33726                                  		;/* print ESC prompt */
 33727                                  
 33728                                  		;push	word [menu_11_segment]
 33729 00004CBA 1E                      		push	ds
 33730 00004CBB FF36[099E]              		push	word [menu_11_offset]
 33731 00004CBF E862C9                  		call	display
 33732                                  		;pop	bx
 33733                                  		;pop	bx
 33734                                  
 33735                                  	;/* Display partition table-it will return if no partitions there */
 33736                                  
 33737 00004CC2 E8B2E1                  		call	table_display
 33738                                  
 33739                                  	;/* Go see if primary already exists and ext doesn't */
 33740                                  
 33741                                  ; *** ('create_partition', 'cp_6:') ***
 33742                                  ;
 33743                                  ;		cmp	bytew [cur_disk],1
 33744                                  ;		;jge	short ecp_1
 33745                                  ;		jnb	short ecp_1
 33746                                  ;
 33747                                  ;		mov	al,1 ; DOS12
 33748                                  ;		;push	ax
 33749                                  ;		call	find_partition_type
 33750                                  ;		;pop	bx
 33751                                  ;		;or	al,al
 33752                                  ;		;jnz	short ecp_1
 33753                                  ;		jnc	short ecp_1
 33754                                  ;		
 33755                                  ;		mov	al,4 ; DOS16
 33756                                  ;		;push	ax
 33757                                  ;		call	find_partition_type
 33758                                  ;		;pop	bx
 33759                                  ;		;or	al, al
 33760                                  ;		;jnz	short ecp_1
 33761                                  ;		jnc	short ecp_1
 33762                                  ;		
 33763                                  ;		mov	al,6  ; DOSNEW
 33764                                  ;		;push	ax
 33765                                  ;		call	find_partition_type
 33766                                  ;		;pop	bx
 33767                                  ;		;or	al,al
 33768                                  ;		;jnz	short ecp_1
 33769                                  ;		jnc	short ecp_1
 33770                                  ;
 33771                                  ;	;/* don't have a primary partition yet, can't create an ext */
 33772                                  ;
 33773                                  ;		jmp	ecp_19
 33774                                  
 33775                                  ecp_1:
 33776 00004CC5 B005                    		mov	al,5 ; EXTENDED
 33777                                  		;push	ax
 33778 00004CC7 E8FAD0                  		call	find_partition_type
 33779                                  		;pop	bx
 33780                                  		;or	al,al
 33781                                  		;jz	short ecp_2
 33782 00004CCA 7203                    		jc	short ecp_2
 33783 00004CCC E97C01                  		jmp	ecp_18
 33784                                  
 33785                                  		;/* We can go create one now */
 33786                                  ecp_2:
 33787                                  		;/* Get the free space */
 33788                                  
 33789                                  		; temp = find_part_free_space(c(EXTENDED));    
 33790                                  
 33791 00004CCF B005                    		mov	al,5
 33792                                  		;push	ax
 33793 00004CD1 E8CA03                  		call	find_part_free_space
 33794                                  		;pop	bx
 33795 00004CD4 8846FC                  		mov	[ecp_temp],al
 33796                                  
 33797                                  		;/* Is there any ?*/
 33798                                  	
 33799                                  	;Instead of checking only the percentage which
 33800                                  	;could be off because of rounding errors, we also check the
 33801                                  	;mbytes available */
 33802                                  
 33803                                  		;mov	cl,22
 33804                                  		;imul	cl
 33805 00004CD7 B10A                    		mov	cl,10
 33806 00004CD9 F6E1                    		mul	cl
 33807                                  		;mov	bx,ax
 33808 00004CDB 89C6                    		mov	si,ax ; /***/
 33809 00004CDD 31C0                    		xor	ax,ax ; 0
 33810                                  		;cmp	word [free_space.space+bx],0
 33811 00004CDF 3984[F0CB]              		cmp	[free_space.space+si],ax ; 0
 33812 00004CE3 7503                    		jne	short ecp_3
 33813 00004CE5 E95C01                  		jmp	ecp_17
 33814                                  ecp_3:
 33815                                  		;cmp	word [free_space.percent_unused+bx],0
 33816 00004CE8 3984[F8CB]              		cmp	[free_space.percent_unused+si],ax ; 0
 33817 00004CEC 7509                    		jne	short ecp_4
 33818                                  		;cmp	word [free_space.mbytes_unused+bx],0
 33819 00004CEE 3987[F6CB]              		cmp	[free_space.mbytes_unused+bx],ax ; 0
 33820 00004CF2 7503                    		jne	short ecp_4
 33821 00004CF4 E94D01                  		jmp	ecp_17
 33822                                  ecp_4:
 33823                                  		;/* Display disk space */
 33824                                  		;sprintf(insert,"%4.0d",total_mbytes[cur_disk]);
 33825                                  		;display(menu_15);
 33826                                  
 33827                                  		;mov	al,[cur_disk]
 33828                                  		;cbw
 33829                                  		;mov	bx,ax
 33830 00004CF7 8A1E[E2CB]              		mov	bl,[cur_disk]
 33831 00004CFB 30FF                    		xor	bh,bh
 33832                                  		;shl	bx,1
 33833 00004CFD D0E3                    		shl	bl,1
 33834 00004CFF FFB7[D6A0]              		push	word [total_mbytes+bx]
 33835 00004D03 B8[926F]                		mov	ax,ecp_size_format ; "%4.1d"
 33836 00004D06 50                      		push	ax
 33837 00004D07 B8[F4CC]                		mov	ax,insert
 33838 00004D0A 50                      		push	ax
 33839 00004D0B E8B7D5                  		call	sprintf
 33840 00004D0E 83C406                  		add	sp,6
 33841                                  
 33842                                  		;push	word [menu_15_segment]
 33843 00004D11 1E                      		push	ds
 33844 00004D12 FF36[139E]              		push	word [menu_15_offset]
 33845 00004D16 E80BC9                  		call	display
 33846                                  		;pop	bx
 33847                                  		;pop	bx
 33848                                  
 33849                                  		;/* Setup and print max partition size */
 33850                                  		;sprintf(insert,"%4.0d%3.0d%%",
 33851                                  		;	free_space[temp].mbytes_unused,
 33852                                  		;	free_space[temp].percent_unused);
 33853                                  		;display(menu_16);
 33854                                  
 33855                                  		;;mov	al,22
 33856                                  		;;imul	byte [ecp_temp]
 33857                                  		;mov	al,10
 33858                                  		;mul	byte [ecp_temp]
 33859                                  		;;mov	bx,ax
 33860                                  		;mov	si,ax ; /***/
 33861                                  		
 33862                                  		;push	word [free_space.percent_unused+bx]
 33863 00004D19 FFB4[F8CB]              		push	word [free_space.percent_unused+si] ; /***/
 33864                                  		;push	word [free_space.mbytes_unused+bx]
 33865 00004D1D FFB4[F6CB]              		push	word [free_space.mbytes_unused+si] ; /***/
 33866 00004D21 B8[986F]                		mov	ax,ecp_mb_pcent_format ; "%4.1d%3.1d%%"
 33867 00004D24 50                      		push	ax
 33868 00004D25 B8[F4CC]                		mov	ax,insert
 33869 00004D28 50                      		push	ax
 33870                                  		;mov	si,bx
 33871 00004D29 E899D5                  		call	sprintf
 33872 00004D2C 83C408                  		add	sp,8
 33873                                  
 33874                                  		;push	word [menu_16_segment]
 33875 00004D2F 1E                      		push	ds
 33876 00004D30 FF36[159E]              		push	word [menu_16_offset]
 33877 00004D34 E8EDC8                  		call	display
 33878                                  		;pop	bx
 33879                                  		;pop	bx
 33880                                  
 33881                                  	;/* Force repeats on the input until something valid (Non-Zero return) */
 33882                                  	;/* Display MBytes unless MBytes == 0, then display percent */
 33883                                  
 33884 00004D37 83BC[F6CB]00            		cmp	word [free_space.mbytes_unused+si],0
 33885 00004D3C 750E                    		jne	short ecp_5
 33886 00004D3E 8B84[F8CB]              		mov	ax,[free_space.percent_unused+si]
 33887 00004D42 8946FA                  		mov	[ecp_default_entry],ax
 33888 00004D45 C606[E0C3]01            		mov	byte [PercentFlag],1  ; PercentFlag = (FLAG)TRUE;    
 33889 00004D4A EB0C                    		jmp	short ecp_6
 33890                                  ecp_5:
 33891                                  		;;mov	al,22
 33892                                  		;mov	al,10
 33893                                  		;;imul	byte [ecp_temp]
 33894                                  		;mul	byte [ecp_temp]
 33895                                  		;;mov	bx,ax
 33896                                  		;mov	si,ax ; /***/
 33897                                  		
 33898                                  		;mov	ax,[free_space.mbytes_unused+bx]
 33899 00004D4C 8B84[F6CB]              		mov	ax,[free_space.mbytes_unused+si] ; /***/
 33900 00004D50 8946FA                  		mov	[ecp_default_entry],ax
 33901 00004D53 C606[E0C3]00            		mov	byte [PercentFlag],0  ; PercentFlag = (FLAG)FALSE;     
 33902                                  ecp_6:
 33903 00004D58 C606[ECCB]00            		mov	byte [valid_input],0  ; valid_input = (FLAG)FALSE; 
 33904                                  ecp_7:
 33905 00004D5D FF76FA                  		push	word [ecp_default_entry] ; 25/01/2019
 33906                                  
 33907 00004D60 803E[E0C3]00            		cmp	byte [PercentFlag],0
 33908 00004D65 7505                    		jne	short ecp_8
 33909                                  
 33910                                  		;/* Display prompt */
 33911                                  		;if (!PercentFlag)
 33912                                  		;   sprintf(insert,"%4.0d",default_entry);
 33913                                  		;else
 33914                                  		;   sprintf(insert,"%3.0d%%",default_entry);
 33915                                  		;display(menu_42);     
 33916                                  
 33917                                  		;push	word [ecp_default_entry]
 33918 00004D67 B8[926F]                		mov	ax,ecp_mb_format ; "%4.1d"
 33919 00004D6A EB03                    		jmp	short ecp_9
 33920                                  ecp_8:
 33921                                  		;push	word [ecp_default_entry]
 33922 00004D6C B8[A56F]                		mov	ax,ecp_pcent_format ; "%3.1d%%"
 33923                                  ecp_9:
 33924 00004D6F 50                      		push	ax
 33925 00004D70 B8[F4CC]                		mov	ax,insert
 33926 00004D73 50                      		push	ax
 33927 00004D74 E84ED5                  		call	sprintf
 33928 00004D77 83C406                  		add	sp,6
 33929                                  
 33930                                  		;push	word [menu_42_segment]
 33931 00004D7A 1E                      		push	ds
 33932 00004D7B FF36[1B9E]              		push	word [menu_42_offset]
 33933 00004D7F E8A2C8                  		call	display
 33934                                  		;pop	bx
 33935                                  		;pop	bx
 33936                                  
 33937                                  	;input = get_large_num_input(default_entry,free_space[temp].mbytes_unused,
 33938                                  	;		free_space[temp].percent_unused,menu_42,u(0),error_13);
 33939                                  
 33940                                  		;push	word [error_13_seg]
 33941 00004D82 1E                      		push	ds
 33942 00004D83 FF36[9A9E]              		push	word [error_13_off]
 33943 00004D87 29C0                    		sub	ax,ax ; 0
 33944 00004D89 50                      		push	ax
 33945                                  
 33946                                  		;push	word [menu_42_segment]
 33947 00004D8A 1E                      		push	ds
 33948 00004D8B FF36[1B9E]              		push	word [menu_42_offset]
 33949                                  		
 33950                                  		;;mov	al,22
 33951                                  		;mov	al,10
 33952                                  		;;imul	byte [ecp_temp]
 33953                                  		;mul	byte [ecp_temp]
 33954                                  		;;mov	bx,ax
 33955                                  		;mov	si,ax ; /***/
 33956                                  
 33957                                  		;push	word [free_space.percent_unused+bx]
 33958                                  		;push	word [free_space.mbytes_unused+bx]
 33959 00004D8F FFB4[F8CB]              		push	word [free_space.percent_unused+si] ; /***/
 33960 00004D93 FFB4[F6CB]              		push	word [free_space.mbytes_unused+si] ; /***/
 33961 00004D97 FF76FA                  		push	word [ecp_default_entry]
 33962 00004D9A E8E805                  		call	get_large_num_input
 33963                                  		;add	sp,16
 33964                                  
 33965 00004D9D 8946FE                  		mov	[ecp_input],ax
 33966                                  
 33967                                  	;/* Update default in case of error, so it gets displayed and used */
 33968                                  	;/* if user presses CR only */
 33969                                  
 33970 00004DA0 8946FA                  		mov	[ecp_default_entry],ax
 33971                                  
 33972 00004DA3 B84F00                  		mov	ax,79
 33973 00004DA6 50                      		push	ax
 33974 00004DA7 B81700                  		mov	ax,23
 33975 00004DAA 50                      		push	ax
 33976 00004DAB 29C0                    		sub	ax,ax
 33977 00004DAD 50                      		push	ax
 33978 00004DAE B81300                  		mov	ax,19
 33979 00004DB1 50                      		push	ax
 33980 00004DB2 E8E1C6                  		call	clear_screen
 33981                                  		;add	sp,8
 33982                                  
 33983                                  		;while (!valid_input)
 33984                                  
 33985 00004DB5 803E[ECCB]00            		cmp	byte [valid_input],0
 33986 00004DBA 74A1                    		je	short ecp_7
 33987                                  
 33988                                  		; if (input != ((unsigned)(ESC_FLAG)))  
 33989                                  
 33990 00004DBC 837EFEFE                		cmp	word [ecp_input],0FFFEh ; ESC_FLAG
 33991 00004DC0 7503                    		jne	short ecp_10
 33992 00004DC2 E99100                  		jmp	ecp_21
 33993                                  ecp_10:
 33994                                  		;/* Change input to cylinders */
 33995                                  
 33996                                  		;;mov	al,22
 33997                                  		;mov	al,10
 33998                                  		;;imul	byte [ecp_temp]
 33999                                  		;mul	byte [ecp_temp]
 34000                                  		;;mov	bx,ax
 34001                                  		;mov	si,ax ; /***/
 34002                                  
 34003                                  		; if (PercentFlag) 
 34004                                  
 34005 00004DC5 8B46FE                  		mov	ax,[ecp_input] ; **   
 34006                                  
 34007 00004DC8 803E[E0C3]00            		cmp	byte [PercentFlag],0
 34008 00004DCD 741D                    		je	short ecp_13  ; else
 34009                                  		
 34010                                  		;;mov	al,22
 34011                                  		;mov	al,10
 34012                                  		;;imul	byte [ecp_temp]
 34013                                  		;mul	byte [ecp_temp]
 34014                                  		;;mov	bx,ax
 34015                                  		;mov	si,ax ; /***/
 34016                                  
 34017                                  		; if (input == free_space[temp].percent_unused)
 34018                                  
 34019                                  		;mov	ax,[ecp_input] ; **
 34020                                  		;cmp	[free_space.percent_unused+bx],ax
 34021 00004DCF 3984[F8CB]              		cmp	[free_space.percent_unused+si],ax ; /***/
 34022 00004DD3 7506                    		jne	short ecp_12  ; else
 34023                                  ecp_11:
 34024                                  		;input = free_space[temp].space;
 34025                                  		
 34026                                  		;mov	ax,[free_space.space+bx]
 34027 00004DD5 8B84[F0CB]              		mov	ax,[free_space.space+si] ; /***/
 34028 00004DD9 EB1F                    		jmp	short ecp_15
 34029                                  ecp_12:	
 34030                                  	;input = percent_to_cylinders(input,total_disk[cur_disk]);
 34031                                  
 34032                                  		;mov	al,[cur_disk]
 34033                                  		;cbw
 34034                                  		;mov	bx,ax
 34035                                  		;shl	bx,1
 34036 00004DDB 8A1E[E2CB]              		mov	bl,[cur_disk]
 34037 00004DDF 28FF                    		sub	bh,bh
 34038 00004DE1 D0E3                    		shl	bl,1	
 34039                                  		;push	word [total_disk+bx]
 34040 00004DE3 8B8F[C6A0]              		mov	cx,[total_disk+bx]  ;total cylinders
 34041                                  		;;push	word [ecp_input]
 34042                                  		;mov	ax,[ecp_input]
 34043                                  			; cx = total cylinders (of the disk)
 34044                                  			; ax = percent in (word, <= 100)
 34045 00004DE7 E83609                  		call	percent_to_cylinders
 34046 00004DEA EB0E                    		jmp	short ecp_14
 34047                                  ecp_13:
 34048                                  		;;mov	al,22
 34049                                  		;mov	al,10
 34050                                  		;;imul	byte [ecp_temp]
 34051                                  		;mul	byte [ecp_temp]
 34052                                  		;;mov	bx,ax
 34053                                  		;mov	si,ax ; /***/
 34054                                  
 34055                                  		;if (input == free_space[temp].mbytes_unused)
 34056                                  		;   input = free_space[temp].space; 
 34057                                  
 34058                                  		;mov	ax,[ecp_input] ; **
 34059                                  		;cmp	[free_space.mbytes_unused+bx],ax
 34060 00004DEC 3984[F6CB]              		cmp	[free_space.mbytes_unused+si],ax ; /***/
 34061 00004DF0 74E3                    		je	short ecp_11
 34062                                  
 34063                                  		;else
 34064                                  
 34065                                  	; input = (unsigned)mbytes_to_cylinders(input,cur_disk); 
 34066                                  
 34067                                  		;mov	al,[cur_disk]
 34068                                  		;push	ax
 34069 00004DF2 FF36[E2CB]              		push	word [cur_disk] ; 25/01/2019
 34070                                  		;push	word [ecp_input]
 34071 00004DF6 50                      		push	ax ; **
 34072 00004DF7 E8CF08                  		call	mbytes_to_cylinders
 34073                                  ecp_14:
 34074                                  		;pop	bx
 34075                                  		;pop	bx
 34076                                  ecp_15:	
 34077                                  		;mov	[ecp_input],ax ; *
 34078                                  
 34079                                  		;/* Initialize PecentFlag back to FALSE */
 34080                                  
 34081 00004DFA C606[E0C3]00            		mov	byte [PercentFlag],0 ; PercentFlag = (FLAG)FALSE;   
 34082                                  
 34083                                  		; Display error message if input value = 0 */
 34084                                  
 34085 00004DFF 09C0                    		or	ax,ax
 34086 00004E01 7507                    		jnz	short ecp_16
 34087                                  
 34088                                  		;push	word [error_28_seg]
 34089 00004E03 1E                      		push	ds
 34090 00004E04 FF36[B69E]              		push	word [error_28_off]
 34091 00004E08 EB46                    		jmp	short ecp_20
 34092                                  ecp_16:
 34093                                  		;/* Go create the partition */
 34094                                  
 34095 00004E0A 89C1                    		mov	cx,ax ; *
 34096                                  
 34097 00004E0C B005                    		mov	al,5 ; EXTENDED
 34098 00004E0E 50                      		push	ax		 ; mp_type (byte) - EXTENDED -
 34099 00004E0F 28C0                    		sub	al,al ; 0
 34100 00004E11 50                      		push	ax		 ; mp_bootable (byte) - not bootable -
 34101 00004E12 8A46FC                  		mov	al,[ecp_temp]
 34102 00004E15 50                      		push	ax		 ; mp_free_ptr (byte)
 34103                                  		;push	word [ecp_input] ; mp_size (word)
 34104 00004E16 51                      		push	cx  ; *
 34105 00004E17 E83607                  		call	make_partition
 34106                                  		;add	sp,8
 34107                                  
 34108                                  		;* clear off the old prompt */
 34109                                  
 34110 00004E1A B84F00                  		mov	ax,79
 34111 00004E1D 50                      		push	ax
 34112 00004E1E B81300                  		mov	ax,19
 34113 00004E21 50                      		push	ax
 34114 00004E22 29C0                    		sub	ax,ax
 34115 00004E24 50                      		push	ax
 34116 00004E25 B80D00                  		mov	ax,13
 34117 00004E28 50                      		push	ax
 34118 00004E29 E86AC6                  		call	clear_screen
 34119                                  		;add	sp,8
 34120                                  
 34121                                  		;/* Display the updated partition information */
 34122                                  
 34123 00004E2C E848E0                  		call	table_display
 34124                                  
 34125                                  		;/* Tell user we created it */
 34126                                  
 34127                                  		;push	word [status_6_seg]
 34128 00004E2F 1E                      		push	ds
 34129 00004E30 FF36[759E]              		push	word [status_6_off]
 34130 00004E34 E8EDC7                  		call	display
 34131                                  		;pop	bx
 34132                                  		;pop	bx
 34133                                  		
 34134 00004E37 E83AE3                  		call	wait_for_ESC
 34135                                  
 34136 00004E3A C606[78A0]01            		mov	byte [reboot_flag],1  ;reboot_flag = (FLAG)TRUE; 
 34137                                  
 34138                                  		;/* Go allow him to create disk volumes */
 34139                                  
 34140 00004E3F E81800                  		call	volume_create
 34141 00004E42 EB12                    		jmp	short ecp_21
 34142                                  ecp_17:		
 34143                                  		;/* No room */
 34144                                  		
 34145                                  		;display(error_10);
 34146                                  
 34147                                  		;push	word [error_10_seg]
 34148 00004E44 1E                      		push	ds
 34149 00004E45 FF36[969E]              		push	word [error_10_off]
 34150 00004E49 EB05                    		jmp	short ecp_20
 34151                                  ecp_18:
 34152                                  	;/* Already have ext partition, tell user and bow out */
 34153                                  		
 34154                                  		;display(error_9);
 34155                                  
 34156                                  		;push	word [error_9_seg]
 34157 00004E4B 1E                      		push	ds
 34158 00004E4C FF36[949E]              		push	word [error_9_off]
 34159                                  ;		jmp	short ecp_20
 34160                                  ;ecp_19:
 34161                                  ;	;/* don't have a primary partition yet, can't create an ext */
 34162                                  ;
 34163                                  ;		;display(error_19);
 34164                                  ;
 34165                                  ;		;push	word [error_19_seg]
 34166                                  ;		push	ds
 34167                                  ;		push	word [error_19_off]
 34168                                  ecp_20:
 34169 00004E50 E8D1C7                  		call	display
 34170                                  		;pop	bx
 34171                                  		;pop	bx
 34172                                  
 34173 00004E53 E81EE3                  		call	wait_for_ESC  ; wait_for_ESC();
 34174                                  ecp_21:
 34175                                  		;pop	si
 34176                                  
 34177 00004E56 89EC                    		mov	sp,bp
 34178 00004E58 5D                      		pop	bp
 34179 00004E59 C3                      		retn
 34180                                  
 34181                                  ;/*  */
 34182                                  ;/******************* START OF SPECIFICATIONS *******************/
 34183                                  ;/*                                                             */
 34184                                  ;/* SUBROUTINE NAME: VOLUME_CREATE                              */
 34185                                  ;/*                                                             */
 34186                                  ;/* DESCRIPTIVE NAME: Create DOS disk volumes                   */
 34187                                  ;/*                                                             */
 34188                                  ;/* FUNCTION: Create the boot record/partition table structure  */
 34189                                  ;/*           needed to support the DOS disk volume arch in     */
 34190                                  ;/*           the EXTENDED partition. Volume is created to the  */
 34191                                  ;/*           the default size (largest contiguous freespace or */
 34192                                  ;/*           32mb, whichever smaller) or to the user specified */
 34193                                  ;/*           size (must be smaller or equal to default size).  */
 34194                                  ;/*           The volume boot record is created, and the appro- */
 34195                                  ;/*           priate pointers in other volume partition tables  */
 34196                                  ;/*           are generated.                                    */
 34197                                  ;/*                                                             */
 34198                                  ;/*                                                             */
 34199                                  ;/* NOTES: Screen can be exited via the ESC command before      */
 34200                                  ;/*        partition is created and nothing will change         */
 34201                                  ;/*                                                             */
 34202                                  ;/*        The following screen is managed                      */
 34203                                  ;/*                                                             */
 34204                                  ;/*       |0000000000111111111122222222223333333333|            */
 34205                                  ;/*       |0123456789012345678901234567890123456789|            */
 34206                                  ;/*     --|----------------------------------------|            */
 34207                                  ;/*     00|Create DOS Disk Volume                  |            */
 34208                                  ;/*     01|                                        |            */
 34209                                  ;/*     02|Vol Start End  Size                     |            */
 34210                                  ;/*     03| #  ####  #### ####                     |            */
 34211                                  ;/*     04|                                        |            */
 34212                                  ;/*     05|                                        |            */
 34213                                  ;/*     06|                                        |            */
 34214                                  ;/*     07|                                        |            */
 34215                                  ;/*     08|                                        |            */
 34216                                  ;/*     09|                                        |            */
 34217                                  ;/*     10|                                        |            */
 34218                                  ;/*     11|                                        |            */
 34219                                  ;/*     12|                                        |            */
 34220                                  ;/*     13|                                        |            */
 34221                                  ;/*     14|                                        |            */
 34222                                  ;/*     15|                                        |            */
 34223                                  ;/*     16|Total partition size is #### cylinders. |            */
 34224                                  ;/*     17|Maximum space available for disk        |            */
 34225                                  ;/*     18|volume is #### cylinders.               |            */
 34226                                  ;/*     19|                                        |            */
 34227                                  ;/*     20|Enter disk volume size..........: [####]|            */
 34228                                  ;/*     21|                                        |            */
 34229                                  ;/*     22|                                        |            */
 34230                                  ;/*     23|Press ESC to return to FDISK Options    |            */
 34231                                  ;/*     --------------------------------------------            */
 34232                                  ;/*                                                             */
 34233                                  ;/* ENTRY POINTS: Volume_Create                                 */
 34234                                  ;/*      LINKAGE: Volume_Create ()                              */
 34235                                  ;/*           NEAR CALL                                         */
 34236                                  ;/*                                                             */
 34237                                  ;/* INPUT: None                                                 */
 34238                                  ;/*                                                             */
 34239                                  ;/* EXIT-NORMAL: ERROR=FALSE                                    */
 34240                                  ;/*                                                             */
 34241                                  ;/* EXIT-ERROR: ERROR=TRUE                                      */
 34242                                  ;/*             GOTO internal_program_error if case statement   */
 34243                                  ;/*             failure when branching to requested function    */
 34244                                  ;/*                                                             */
 34245                                  ;/* EFFECTS: No data directly modified by this routine, but     */
 34246                                  ;/*          child routines will modify data.                   */
 34247                                  ;/*                                                             */
 34248                                  ;/* INTERNAL REFERENCES:                                        */
 34249                                  ;/*   ROUTINES:                                                 */
 34250                                  ;/*      clear_screen                                           */
 34251                                  ;/*      display                                                */
 34252                                  ;/*      volume_display                                         */
 34253                                  ;/*      get_num_input                                          */
 34254                                  ;/*      wait_for_ESC                                           */
 34255                                  ;/*      make_partition                                         */
 34256                                  ;/*                                                             */
 34257                                  ;/* EXTERNAL REFERENCES:                                        */
 34258                                  ;/*   ROUTINES:                                                 */
 34259                                  ;/*                                                             */
 34260                                  ;/******************** END OF SPECIFICATIONS ********************/
 34261                                  
 34262                                  ;/*  */
 34263                                  ;void volume_create()
 34264                                  ;
 34265                                  ;BEGIN
 34266                                  ;
 34267                                  ;    unsigned  input;
 34268                                  ;    unsigned  default_entry;
 34269                                  ;    char  drive_letter;
 34270                                  ;    char  location;
 34271                                  ;    char  ext_location;
 34272                                  ;    unsigned char  i;
 34273                                  ;    char  defined_drives;
 34274                                  ;    char  temp_cur_disk;
 34275                                  ;    unsigned ext_part_percent_unused;                           /* AN000 */
 34276                                  ;    unsigned ext_part_num;                                      /* AN000 */
 34277                                  ;
 34278                                  ;    input = u(NUL);                                             /* AC000 */
 34279                                  ;
 34280                                  ;    /* clear off screen */
 34281                                  ;    clear_screen(u(0),u(0),u(24),u(79));                        /* AC000 */
 34282                                  ;
 34283                                  ;    /* Display header */
 34284                                  ;    display (menu_18);
 34285                                  ;
 34286                                  ;    /* print ESC prompt */
 34287                                  ;    display(menu_11);
 34288                                  ;
 34289                                  ;    /* Display volume info */
 34290                                  ;    drive_letter = volume_display();
 34291                                  ;
 34292                                  ;    /* Loop until done */
 34293                                  ;    input = u(NUL);                                             /* AC000 */
 34294                                  ;    while (input != ((unsigned)(ESC_FLAG)))                     /* AC000 */
 34295                                  ;
 34296                                  ;        BEGIN
 34297                                  ;        /* See if we have hit the max number of drives */
 34298                                  ;        defined_drives = c(0);                                  /* AC000 */
 34299                                  ;        temp_cur_disk = cur_disk;
 34300                                  ;
 34301                                  ;        /* Search both drives for defined drives */
 34302                                  ;        for (i = uc(0); i < number_of_drives; i++)              /* AC000 */
 34303                                  ;
 34304                                  ;            BEGIN
 34305                                  ;            cur_disk = ((char)(i));
 34306                                  ;
 34307                                  ;            /* See if there is a primary drive letter */
 34308                                  ;            if ((find_partition_type(uc(DOS12))) || (find_partition_type(uc(DOS16))) || (find_partition_type(uc(DOSNEW)))) /*AC000*/
 34309                                  ;                defined_drives++;
 34310                                  ;
 34311                                  ;            /* See if extended partition on disk */
 34312                                  ;            if (find_partition_type(uc(EXTENDED)))              /* AC000 */
 34313                                  ;                BEGIN
 34314                                  ;                /* Get number of logical drives */
 34315                                  ;                defined_drives = defined_drives + get_num_logical_dos_drives();
 34316                                  ;                END
 34317                                  ;            END
 34318                                  ;        /* Restore cur_disk to original */
 34319                                  ;        cur_disk = temp_cur_disk;
 34320                                  ;
 34321                                  ;        /* See if 26 or less drives total */
 34322                                  ;        if ((defined_drives < c(24)) &&             /*C07*/
 34323                                  ;            (get_num_logical_dos_drives() < c(23))) /*C07*/
 34324                                  ;            BEGIN
 34325                                  ;            location = find_ext_free_space();
 34326                                  ;
 34327                                  ;            /* find the number of the extended partiton to figure out percent */
 34328                                  ;            ext_part_num = find_partition_location(uc(EXTENDED));       /* AN000 */
 34329                                  ;
 34330                                  ;            /* Set the percent used */
 34331                                  ;            ext_part_percent_unused =
 34332                                  ;                cylinders_to_percent(free_space[location].space,
 34333                                  ;                ((part_table[cur_disk][ext_part_num].end_cyl-part_table[cur_disk][ext_part_num].start_cyl)+1));
 34334                                  ;
 34335                                  ;            /* Is there any ?*/
 34336                                  ;
 34337                                  ;            /* SR; 9/26/89; Instead of checking only the percentage which
 34338                                  ;               could be off because of rounding errors, we also check the
 34339                                  ;               mbytes available */
 34340                                  ;
 34341                                  ;            if (free_space[location].space != u(0) &&
 34342                                  ;                (free_space[location].percent_unused != u(0) ||
 34343                                  ;                 free_space[location].mbytes_unused != u(0)))    /*C02*/
 34344                                  ;                BEGIN
 34345                                  ;
 34346                                  ;                /* Display disk space */
 34347                                  ;                sprintf(insert,"%4.0d",get_partition_size(uc(EXTENDED)) );
 34348                                  ;                display(menu_21);
 34349                                  ;
 34350                                  ;                /* Setup and print max partition size */
 34351                                  ;
 34352                                  ;                sprintf(insert,"%4.0d%3.0d%%",
 34353                                  ;                        free_space[location].mbytes_unused,
 34354                                  ;                        ext_part_percent_unused);
 34355                                  ;                display(menu_22);
 34356                                  ;
 34357                                  ;                /* Force repeats on the input until something valid (Non-Zero return) */
 34358                                  ;                /* If MBytes unused  is equel to zero, display percent unused */
 34359                                  ;                if (free_space[location].mbytes_unused == u(0))         /* AN000 */
 34360                                  ;                    BEGIN                                               /* AN000 */
 34361                                  ;                    default_entry = (unsigned)ext_part_percent_unused;     /* AN000 */
 34362                                  ;                    PercentFlag = (FLAG)TRUE;                           /* AN000 */
 34363                                  ;                    END                                                 /* AN000 */
 34364                                  ;                else                                                    /* AN000 */
 34365                                  ;                    BEGIN                                               /* AN000 */
 34366                                  ;                    default_entry = (unsigned)free_space[location].mbytes_unused;   /* AC000 */
 34367                                  ;                    PercentFlag = (FLAG)FALSE;                          /* AN000 */
 34368                                  ;                    END                                                 /* AN000 */
 34369                                  ;
 34370                                  ;                valid_input = (FLAG)FALSE;                              /* AC000 */
 34371                                  ;
 34372                                  ;                while (!valid_input)
 34373                                  ;                    BEGIN
 34374                                  ;                    /* Display prompt */
 34375                                  ;                    if (!PercentFlag)                                   /* AN000 */
 34376                                  ;                        sprintf(insert,"%4.0d",default_entry);
 34377                                  ;                    else                                                /* AN000 */
 34378                                  ;                        sprintf(insert,"%3.0d%%",default_entry);        /* AN000 */
 34379                                  ;
 34380                                  ;                    display(menu_40);
 34381                                  ;
 34382                                  ;                    input = get_large_num_input(default_entry,free_space[location].mbytes_unused,ext_part_percent_unused,menu_40,u(0),error_12); /* AC000*/
 34383                                  ;
 34384                                  ;                    /* Update default in case of error, so it gets displayed and used */
 34385                                  ;                    /* if user presses CR only */
 34386                                  ;
 34387                                  ;                    default_entry = input;
 34388                                  ;                    clear_screen(u(19),u(0),u(23),u(79));               /* AC000 */
 34389                                  ;                    END
 34390                                  ;
 34391                                  ;                if (input != ((unsigned)(ESC_FLAG)))                    /* AC000 */
 34392                                  ;                    BEGIN
 34393                                  ;
 34394                                  ;                    /* Change input to cylinders */
 34395                                  ;                    if (PercentFlag)                                          /* AN000 */
 34396                                  ;                        BEGIN                                                 /* AN000 */
 34397                                  ;                        if (input == ext_part_percent_unused)
 34398                                  ;                            input = free_space[location].space;               /* AN000 */
 34399                                  ;                        else                                                  /* AN000 */
 34400                                  ;                            input = percent_to_cylinders(input,((part_table[cur_disk][ext_part_num].end_cyl-part_table[cur_disk][ext_part_num].start_cyl)+1));
 34401                                  ;                        END                                                   /* AN000 */
 34402                                  ;                    else                                                      /* AN000 */
 34403                                  ;                        BEGIN                                                 /* AN000 */
 34404                                  ;                        if (input == free_space[location].mbytes_unused)
 34405                                  ;                            input = free_space[location].space;                   /* AN000 */
 34406                                  ;                        else                                                  /* AN000 */
 34407                                  ;                            input = (unsigned)mbytes_to_cylinders(input,
 34408                                  ;                                                                  cur_disk);  /* AN004 */
 34409                                  ;                        END                                                   /* AN000 */
 34410                                  ;
 34411                                  ;                    /* Initialize PecentFlag back to FALSE */
 34412                                  ;                    PercentFlag = (FLAG)FALSE;                                  /* AN000 */
 34413                                  ;
 34414                                  ;                    /* SR; 9/26/89; Display error message if input value = 0 */
 34415                                  ;
 34416                                  ;                    if (input == 0)
 34417                                  ;                       {
 34418                                  ;                        display(error_28);
 34419                                  ;                        wait_for_ESC();
 34420                                  ;                       }
 34421                                  ;                    else
 34422                                  ;                       {
 34423                                  ;                    	/* go create the entry and find out where it put it */
 34424                                  ;                    	ext_location = make_volume(input,location);
 34425                                  ;
 34426                                  ;                    	/* clear off the old prompt */
 34427                                  ;                    	clear_screen(u(15),u(0),u(19),u(79));               /* AC000 */
 34428                                  ;
 34429                                  ;                    	reboot_flag = (FLAG)TRUE;                           /* AC000 */
 34430                                  ;
 34431                                  ;                    	/* Display the updated partition information */
 34432                                  ;                    	drive_letter = volume_display();
 34433                                  ;
 34434                                  ;                    	/* Tell user we created it */
 34435                                  ;                    	display(status_7);
 34436                                  ;                       }
 34437                                  ;                    END
 34438                                  ;                END
 34439                                  ;            else
 34440                                  ;                BEGIN
 34441                                  ;                /* No space left or already max'd on the devices */
 34442                                  ;                /* Get rid of the size prompts */
 34443                                  ;                clear_screen(u(17),u(0),u(21),u(79));                   /* AC000 */
 34444                                  ;                display(error_20);
 34445                                  ;                volume_display();
 34446                                  ;                wait_for_ESC();                         /* KWC, 11-01-87 */
 34447                                  ;                input = u(ESC_FLAG);                    /* KWC, 11-01-87 */
 34448                                  ;                END
 34449                                  ;            END
 34450                                  ;        else
 34451                                  ;            BEGIN
 34452                                  ;            /* Reached the maximum */
 34453                                  ;            /* Get rid of the size prompts */
 34454                                  ;            clear_screen(u(17),u(0),u(21),u(79));                       /* AC000 */
 34455                                  ;            display(error_27);
 34456                                  ;            /* Force an exit with ESC */
 34457                                  ;            wait_for_ESC();                         /* KWC, 11-01-87 */
 34458                                  ;            input = u(ESC_FLAG);                    /* KWC, 11-01-87 */
 34459                                  ;            END
 34460                                  ;        END
 34461                                  ;    clear_screen(u(0),u(0),u(24),u(79));                               /* AC000 */
 34462                                  ;    return;
 34463                                  ;END
 34464                                  
 34465                                  volume_create:
 34466                                  		; 23/01/2019
 34467                                  
 34468                                  	%define vc_defined_drives	 bp-14 	;bp-16
 34469                                  	%define vc_ext_part_pcent_unused bp-12 	;bp-14
 34470                                  	%define vc_location		 bp-10	;bp-12
 34471                                  	%define vc_i		 	 bp-8	;bp-10
 34472                                  	%define vc_temp_cur_disk 	 bp-6	;bp-8
 34473                                  	%define vc_default_entry 	 bp-4	;bp-6
 34474                                  	;%define vc_ext_part_num  	 	;bp-4
 34475                                  	%define vc_input	 	 bp-2	;bp-2
 34476                                  
 34477 00004E5A 55                      		push	bp
 34478 00004E5B 89E5                    		mov	bp,sp
 34479 00004E5D 83EC0E                  		sub	sp,14
 34480                                  
 34481                                  		;/* clear off screen */
 34482                                  
 34483                                  		;push	si
 34484                                  		
 34485                                  		;mov	ax,79
 34486                                  		;push	ax
 34487                                  		;mov	ax,24
 34488                                  		;push	ax
 34489                                  		;sub	ax,ax
 34490                                  		;push	ax
 34491                                  		;push	ax
 34492                                  		;call	clear_screen
 34493                                  		;add	sp,8
 34494                                  
 34495 00004E60 E8FBC5                  		call	CLS
 34496                                  
 34497                                  		;/* Display header */
 34498                                  
 34499                                  		;push	word [menu_18_segment]
 34500 00004E63 1E                      		push	ds
 34501 00004E64 FF36[1F9E]              		push	word [menu_18_offset]
 34502 00004E68 E8B9C7                  		call	display
 34503                                  		;pop	bx
 34504                                  		;pop	bx
 34505                                  
 34506                                  		;/* print ESC prompt */
 34507                                  		
 34508                                  		;push	word [menu_11_segment]
 34509 00004E6B 1E                      		push	ds
 34510 00004E6C FF36[099E]              		push	word [menu_11_offset]
 34511 00004E70 E8B1C7                  		call	display
 34512                                  		;pop	bx
 34513                                  		;pop	bx
 34514                                  
 34515                                  		;/* Display volume info */
 34516                                  
 34517 00004E73 E86CE3                  		call	volume_display
 34518                                  
 34519                                  		;/* Loop until done */
 34520                                  
 34521 00004E76 C746FE0000              		mov	word [vc_input],0
 34522                                  vc_1:
 34523                                  		;/* See if we have hit the max number of drives */
 34524                                  
 34525 00004E7B C646F200                		mov	byte [vc_defined_drives],0
 34526 00004E7F A0[E2CB]                		mov	al,[cur_disk]
 34527 00004E82 8846FA                  		mov	[vc_temp_cur_disk],al
 34528 00004E85 C646F800                		mov	byte [vc_i],0
 34529 00004E89 EB2E                    		jmp	short vc_6
 34530                                  vc_2:
 34531 00004E8B 8A46F8                  		mov	al,[vc_i]
 34532 00004E8E A2[E2CB]                		mov	[cur_disk],al
 34533                                  
 34534 00004E91 B001                    		mov	al,1 ; DOS12
 34535                                  		;push	ax
 34536 00004E93 E82ECF                  		call	find_partition_type
 34537                                  		;pop	bx
 34538                                  		;or	al,al
 34539                                  		;jnz	short vc_3
 34540 00004E96 730E                    		jnc	short vc_3
 34541                                  
 34542 00004E98 B004                    		mov	al,4  ; DOS16
 34543                                  		;push	ax
 34544 00004E9A E827CF                  		call	find_partition_type
 34545                                  		;pop	bx
 34546                                  		;or	al,al
 34547                                  		;jnz	short vc_3
 34548 00004E9D 7307                    		jnc	short vc_3
 34549                                  
 34550 00004E9F B006                    		mov	al,6 ; DOSNEW
 34551                                  		;push	ax
 34552 00004EA1 E820CF                  		call	find_partition_type
 34553                                  		;pop	bx
 34554                                  		;or	al,al
 34555                                  		;jz	short vc_4
 34556 00004EA4 7203                    		jc	short vc_4
 34557                                  vc_3:
 34558 00004EA6 FE46F2                  		inc	byte [vc_defined_drives]
 34559                                  vc_4:
 34560 00004EA9 B005                    		mov	al,5 ; EXTENDED
 34561                                  		;push	ax
 34562 00004EAB E816CF                  		call	find_partition_type
 34563                                  		;pop	bx
 34564                                  		;or	al,al
 34565                                  		;jz	short vc_5
 34566 00004EAE 7206                    		jc	short vc_5
 34567                                  
 34568 00004EB0 E865F9                  		call	get_num_logical_dos_drives
 34569 00004EB3 0046F2                  		add	[vc_defined_drives],al
 34570                                  vc_5:
 34571 00004EB6 FE46F8                  		inc	byte [vc_i]
 34572                                  vc_6:
 34573                                  		;/* Search both drives for defined drives */
 34574                                  		;for (i = uc(0); i < number_of_drives; i++)  
 34575                                  
 34576 00004EB9 A0[E3C3]                		mov	al,[number_of_drives]
 34577 00004EBC 3846F8                  		cmp	[vc_i],al
 34578 00004EBF 72CA                    		jb	short vc_2
 34579                                  
 34580                                  		;/* Restore cur_disk to original */
 34581 00004EC1 8A46FA                  		mov	al,[vc_temp_cur_disk]
 34582 00004EC4 A2[E2CB]                		mov	[cur_disk],al
 34583                                  
 34584                                  		;/* See if 26 or less drives total */
 34585                                  
 34586 00004EC7 807EF218                		cmp	byte [vc_defined_drives],24
 34587                                  		;jge	short vc_7
 34588 00004ECB 7307                    		jnb	short vc_7
 34589                                  
 34590 00004ECD E848F9                  		call	get_num_logical_dos_drives
 34591 00004ED0 3C17                    		cmp	al,23
 34592                                  		;jl	short vc_8
 34593 00004ED2 7203                    		jb	short vc_8
 34594                                  vc_7:
 34595 00004ED4 E9A301                  		jmp	vc_24
 34596                                  vc_8:
 34597 00004ED7 E87F08                  		call	find_ext_free_space
 34598 00004EDA 8846F6                  		mov	[vc_location],al
 34599                                  
 34600                                  	;/* find the number of the extended partiton to figure out percent */
 34601                                  	;ext_part_num = find_partition_location(uc(EXTENDED));
 34602                                  
 34603                                  		;mov	al,5
 34604                                  		;push	ax
 34605                                  		;call	find_partition_location
 34606                                  		;pop	bx
 34607                                  		;cbw
 34608                                  		;mov	[vc_ext_part_num],ax
 34609                                  		
 34610 00004EDD B005                    		mov	al,5 ; EXTENDED
 34611 00004EDF E8E2CE                  		call	find_partition_type
 34612                                  		;mov	[vc_ext_part_num],cl
 34613                                  
 34614                                  		;/* Set the percent used */
 34615                                  
 34616 00004EE2 A0[E2CB]                		mov	al,[cur_disk]
 34617                                  		;cbw
 34618                                  		;shl	ax,1
 34619                                  		;shl	ax,1
 34620                                  		;add	ax,[vc_ext_part_num]
 34621 00004EE5 D0E0                    		shl	al,1
 34622 00004EE7 D0E0                    		shl	al,1
 34623                                  		;add	al,[vc_ext_part_num]
 34624 00004EE9 00C8                    		add	al,cl
 34625                                  
 34626                                  		;mov	cx,46
 34627                                  		;mul	cx
 34628 00004EEB B12E                    		mov	cl,46
 34629 00004EED F6E1                    		mul	cl
 34630 00004EEF 89C3                    		mov	bx,ax
 34631                                  
 34632                                  		;mov	ax,[part_table_end_cyl+bx]
 34633                                  		;sub	ax,[part_table_start_cyl+bx]
 34634                                  		;inc	ax
 34635                                  		;push	ax
 34636                                  
 34637 00004EF1 8B8F[28C4]              		mov	cx,[part_table_end_cyl+bx]
 34638 00004EF5 2B8F[23C4]              		sub	cx,[part_table_start_cyl+bx]
 34639 00004EF9 41                      		inc	cx ; extended dos partition cylinders - divisor -
 34640                                  
 34641 00004EFA 89CF                    		mov	di,cx ; ***--
 34642                                  
 34643                                  		;mov	al,22
 34644 00004EFC B00A                    		mov	al,10
 34645                                  		;imul	byte [vc_location]
 34646 00004EFE F666F6                  		mul	byte [vc_location]
 34647                                  		;mov	bx,ax
 34648                                  		;push	word [free_space.space+bx]
 34649 00004F01 89C6                    		mov	si,ax ; **--
 34650 00004F03 8B9C[F0CB]              		mov	bx,[free_space.space+si]  ; volume cylinders - dividend -
 34651 00004F07 E8AFC6                  		call	cylinders_to_percent
 34652                                  		;pop	bx
 34653                                  		;pop	bx
 34654 00004F0A 8946F4                  		mov	[vc_ext_part_pcent_unused],ax
 34655                                  
 34656                                  		;/* Is there any ?*/
 34657                                  
 34658                                  	;Instead of checking only the percentage which
 34659                                  	;could be off because of rounding errors, we also check the
 34660                                  	; mbytes available */
 34661                                  
 34662                                  	;if (free_space[location].space != u(0) &&
 34663                                  	;   (free_space[location].percent_unused != u(0) ||
 34664                                  	;    free_space[location].mbytes_unused != u(0)))
 34665                                  
 34666 00004F0D 31C0                    		xor	ax,ax
 34667                                  		;cmp	word free_space.space+si],0
 34668 00004F0F 3984[F0CB]              		cmp	[free_space.space+si],ax ; 0
 34669 00004F13 7503                    		jne	short vc_9
 34670 00004F15 E94301                  		jmp	vc_23
 34671                                  vc_9:
 34672                                  		;cmp	word [free_space.percent_unused+si],0
 34673 00004F18 3984[F8CB]              		cmp	[free_space.percent_unused+si],ax; 0
 34674 00004F1C 7509                    		jne	short vc_10
 34675                                  		;cmp	word [free_space.mbytes_unused+si],0
 34676 00004F1E 3984[F6CB]              		cmp	[free_space.mbytes_unused+si],ax ; 0
 34677 00004F22 7503                    		jne	short vc_10
 34678 00004F24 E93401                  		jmp	vc_23
 34679                                  vc_10:
 34680                                  		;/* Display disk space */
 34681                                  		;sprintf(insert,"%4.0d",get_partition_size(uc(EXTENDED)) );
 34682                                  		;display(menu_21);
 34683                                  
 34684                                  		;mov	al,5
 34685                                  		;push	ax
 34686 00004F27 B605                    		mov	dh,5
 34687 00004F29 E8FCE3                  		call	get_partition_size
 34688                                  		;pop	bx
 34689                                  
 34690                                  		; ax = extended dos partition size (in megabytes)
 34691                                  
 34692 00004F2C 50                      		push	ax
 34693 00004F2D B8[926F]                		mov	ax,v_psize_format ; "%4.1d"
 34694 00004F30 50                      		push	ax
 34695 00004F31 B8[F4CC]                		mov	ax,insert
 34696 00004F34 50                      		push	ax
 34697 00004F35 E88DD3                  		call	sprintf
 34698 00004F38 83C406                  		add	sp,6
 34699                                  
 34700                                  		;push	word [menu_21_segment]
 34701 00004F3B 1E                      		push	ds
 34702 00004F3C FF36[299E]              		push	word [menu_21_offset]
 34703 00004F40 E8E1C6                  		call	display
 34704                                  		;pop	bx
 34705                                  		;pop	bx
 34706                                  
 34707                                  	;/* Setup and print max partition size */
 34708                                  	;
 34709                                  	;	sprintf(insert,"%4.0d%3.0d%%",
 34710                                  	;	free_space[location].mbytes_unused,
 34711                                  	;	ext_part_percent_unused);
 34712                                  	;	display(menu_22);,
 34713                                  
 34714 00004F43 FF76F4                  		push	word [vc_ext_part_pcent_unused]
 34715                                  
 34716                                  		;;mov	al,22
 34717                                  		;mov	al,10
 34718                                  		;;imul	byte [vc_location]
 34719                                  		;mul	byte [vc_location]
 34720                                  		;mov	bx,ax
 34721                                  
 34722                                  		;push	word [free_space.mbytes_unused+bx]
 34723 00004F46 FFB4[F6CB]              		push	word [free_space.mbytes_unused+si] ; **--
 34724 00004F4A B8[986F]                		mov	ax,v_mb_percent_format ; "%4.1d%3.1d%%"
 34725 00004F4D 50                      		push	ax
 34726 00004F4E B8[F4CC]                		mov	ax,insert
 34727 00004F51 50                      		push	ax
 34728                                  		;mov	si,bx ; **--
 34729 00004F52 E870D3                  		call	sprintf
 34730 00004F55 83C408                  		add	sp,8
 34731                                  
 34732                                  		;push	word [menu_22_segment]
 34733 00004F58 1E                      		push	ds
 34734 00004F59 FF36[2B9E]              		push	word [menu_22_offset]
 34735 00004F5D E8C4C6                  		call	display
 34736                                  		;pop	bx
 34737                                  		;pop	bx
 34738                                  
 34739                                  	;/* Force repeats on the input until something valid (Non-Zero return) */
 34740                                  	;/* If MBytes unused is equal to zero, display percent unused */
 34741                                  	;if (free_space[location].mbytes_unused == u(0))  
 34742                                  
 34743 00004F60 83BC[F6CB]00            		cmp	word [free_space.mbytes_unused+si],0 ;**--
 34744 00004F65 750D                    		jne	short vc_11
 34745                                  
 34746                                  		;default_entry = (unsigned)ext_part_percent_unused;
 34747                                  
 34748 00004F67 8B46F4                  		mov	ax,[vc_ext_part_pcent_unused]
 34749 00004F6A 8946FC                  		mov	[vc_default_entry],ax
 34750 00004F6D C606[E0C3]01            		mov	byte [PercentFlag],1 ; PercentFlag = (FLAG)TRUE;
 34751 00004F72 EB0C                    		jmp	short vc_12
 34752                                  vc_11: 
 34753                                  	;default_entry = (unsigned)free_space[location].mbytes_unused;   
 34754                                  
 34755                                  		;;mov	al,22
 34756                                  		;mov	al,10
 34757                                  		;;imul	byte [vc_location]
 34758                                  		;mul	byte [vc_location]
 34759                                  		;mov	bx,ax
 34760                                  
 34761                                  		;mov	ax,[free_space.mbytes_unused+bx]
 34762 00004F74 8B84[F6CB]              		mov	ax,[free_space.mbytes_unused+si] ; **--
 34763 00004F78 8946FC                  		mov	[vc_default_entry],ax
 34764 00004F7B C606[E0C3]00            		mov	byte [PercentFlag],0 ; PercentFlag = (FLAG)FALSE;   
 34765                                  vc_12:	
 34766 00004F80 C606[ECCB]00            		mov	byte [valid_input],0 ; valid_input = (FLAG)FALSE; 
 34767                                  vc_13:	
 34768                                  		;/* Display prompt */
 34769                                  
 34770                                  	;if (!PercentFlag)
 34771                                  	;    sprintf(insert,"%4.0d",default_entry);
 34772                                  	;else
 34773                                  	;    sprintf(insert,"%3.0d%%",default_entry);
 34774                                  
 34775 00004F85 FF76FC                  		push	word [vc_default_entry]
 34776                                  
 34777 00004F88 803E[E0C3]00            		cmp	byte [PercentFlag],0
 34778 00004F8D 7505                    		jne	short vc_14
 34779                                  
 34780                                  		;push	word [vc_default_entry]
 34781 00004F8F B8[926F]                		mov	ax,v_mbytes_format ; "%4.1d"
 34782 00004F92 EB03                    		jmp	short vc_15
 34783                                  vc_14:
 34784                                  		;push	word [vc_default_entry]
 34785 00004F94 B8[A56F]                		mov	ax,v_percent_format ; "%3.1d%%"
 34786                                  vc_15:
 34787 00004F97 50                      		push	ax
 34788 00004F98 B8[F4CC]                		mov	ax,insert
 34789 00004F9B 50                      		push	ax
 34790 00004F9C E826D3                  		call	sprintf
 34791 00004F9F 83C406                  		add	sp,6
 34792                                  
 34793                                  		;display(menu_40);
 34794                                  
 34795                                  		;push	word [menu_40_segment]
 34796 00004FA2 1E                      		push	ds
 34797 00004FA3 FF36[2D9E]              		push	word [menu_40_offset]
 34798 00004FA7 E87AC6                  		call	display
 34799                                  		;pop	bx
 34800                                  		;pop	bx
 34801                                  
 34802                                  ;input = get_large_num_input(default_entry,free_space[location].mbytes_unused,ext_part_percent_unused,menu_40,u(0),error_12)
 34803                                  
 34804                                  		;push	word [error_12_seg]
 34805 00004FAA 1E                      		push	ds			; glni_err_msg_seg	
 34806 00004FAB FF36[989E]              		push	word [error_12_off]	; glni_err_msg
 34807 00004FAF 29C0                    		sub	ax,ax
 34808 00004FB1 50                      		push	ax			; glni_prompt_loc
 34809                                  		;push	word [menu_40_segment]	
 34810 00004FB2 1E                      		push	ds			; glni_input_msg_seg
 34811 00004FB3 FF36[2D9E]              		push	word [menu_40_offset]	; glni_input_msg
 34812 00004FB7 FF76F4                  		push	word [vc_ext_part_pcent_unused] ; glni_max_pc
 34813                                  
 34814                                  		;;mov	al,22
 34815                                  		;mov	al,10
 34816                                  		;;imul	byte [vc_location]
 34817                                  		;mul	byte [vc_location]
 34818                                  		;mov	bx,ax
 34819                                  
 34820                                  		;push	word [free_space.mbytes_unused+bx] ; glni_max_num
 34821 00004FBA FFB4[F6CB]              		push	word [free_space.mbytes_unused+si] ; **--
 34822 00004FBE FF76FC                  		push	word [vc_default_entry]	; glni_input_def
 34823 00004FC1 E8C103                  		call	get_large_num_input
 34824                                  		;add	sp,16
 34825 00004FC4 8946FE                  		mov	[vc_input],ax
 34826                                  
 34827                                  	;/* Update default in case of error, so it gets displayed and used */
 34828                                  	;/* if user presses CR only */
 34829                                  	;
 34830                                  	;	default_entry = input;
 34831                                  
 34832 00004FC7 8946FC                  		mov	[vc_default_entry],ax
 34833                                  
 34834 00004FCA B84F00                  		mov	ax,79
 34835 00004FCD 50                      		push	ax
 34836 00004FCE B81700                  		mov	ax,23
 34837 00004FD1 50                      		push	ax
 34838 00004FD2 29C0                    		sub	ax,ax
 34839 00004FD4 50                      		push	ax
 34840 00004FD5 B81300                  		mov	ax,19
 34841 00004FD8 50                      		push	ax
 34842 00004FD9 E8BAC4                  		call	clear_screen
 34843                                  		;add	sp,8
 34844                                  
 34845                                  		;while (!valid_input)
 34846                                  
 34847 00004FDC 803E[ECCB]00            		cmp	byte [valid_input],0
 34848 00004FE1 74A2                    		je	short vc_13
 34849                                  
 34850                                  		;if (input != ((unsigned)(ESC_FLAG)))  
 34851                                  
 34852 00004FE3 837EFEFE                		cmp	word [vc_input],0FFFEh
 34853 00004FE7 7503                    		jne	short vc_16
 34854                                  		;jmp	vc_26
 34855 00004FE9 E9AB00                  		jmp	vc_27
 34856                                  vc_16:
 34857                                  		; /* Change input to cylinders */
 34858                                  
 34859                                  		;;mov	al,22
 34860                                  		;mov	al,10
 34861                                  		;;imul	byte [vc_location]
 34862                                  		;mul	byte [vc_location]
 34863                                  		;mov	bx,ax
 34864                                  
 34865 00004FEC 8B46FE                  		mov	ax,[vc_input]
 34866                                  
 34867 00004FEF 803E[E0C3]00            		cmp	byte [PercentFlag],0
 34868 00004FF4 7417                    		je	short vc_19
 34869                                  
 34870                                  ;if (input == ext_part_percent_unused)
 34871                                  ;   input = free_space[location].space;
 34872                                  ;else
 34873                                  ;   input = percent_to_cylinders(input,((part_table[cur_disk][ext_part_num].end_cyl-
 34874                                  ;           part_table[cur_disk][ext_part_num].start_cyl)+1));
 34875                                  
 34876                                  		;mov	ax,[vc_input]
 34877                                  
 34878 00004FF6 3946F4                  		cmp	[vc_ext_part_pcent_unused],ax
 34879 00004FF9 7506                    		jne	short vc_18
 34880                                  
 34881                                  		;;mov	al,22
 34882                                  		;mov	al,10
 34883                                  		;;imul	byte [vc_location]
 34884                                  		;mul	byte [vc_location]
 34885                                  		;mov	bx,ax
 34886                                  vc_17:
 34887                                  		;mov	ax,[free_space.space+bx]
 34888 00004FFB 8B84[F0CB]              		mov	ax,[free_space.space+si]
 34889 00004FFF EB1C                    		jmp	short vc_21
 34890                                  vc_18:
 34891                                  		;mov	al,[cur_disk]
 34892                                  		;;cbw
 34893                                  		;;shl	ax,1
 34894                                  		;;shl	ax,1
 34895                                  		;;add	ax,[vc_ext_part_num]
 34896                                  		;shl	al,1
 34897                                  		;shl	al,1
 34898                                  		;add	al,[vc_ext_part_num]
 34899                                  		;;mov	cx,46
 34900                                  		;;mul	cx
 34901                                  		;mov	cl,46
 34902                                  		;mul	cl
 34903                                  		;mov	bx,ax
 34904                                  
 34905                                  		;mov	ax,[part_table_end_cyl+bx]
 34906                                  		;sub	ax,[part_table_start_cyl+bx]
 34907                                  		;inc	ax
 34908                                  		;push	ax
 34909                                  
 34910                                  		;mov	cx,[part_table_end_cyl+bx]
 34911                                  		;sub	cx,[part_table_start_cyl+bx]
 34912                                  		;inc	cx ; available volume size in cylinders
 34913                                  
 34914 00005001 89F9                    		mov	cx,di ; ***--
 34915                                  		
 34916                                  		;push	word [vc_input]
 34917                                  		;mov	ax,[vc_input]  ; percentage input
 34918 00005003 E81A07                  		call	percent_to_cylinders  ; convert percent to cylinders
 34919                                  
 34920 00005006 C606[E0C3]00            		mov	byte [PercentFlag],0
 34921                                  
 34922 0000500B EB10                    		jmp	short vc_20
 34923                                  vc_19:
 34924                                  		;;mov	al,22
 34925                                  		;mov	al,10
 34926                                  		;;imul	byte [vc_location]
 34927                                  		;mul	byte [vc_location]
 34928                                  		;mov	bx,ax
 34929                                  
 34930                                  	;if (input == free_space[location].mbytes_unused)
 34931                                  	;    input = free_space[location].space;
 34932                                  	;else
 34933                                  	;    input = (unsigned)mbytes_to_cylinders(input,cur_disk); 
 34934                                  
 34935                                  		;mov	ax,[vc_input]
 34936                                  
 34937                                  		;cmp	[free_space.mbytes_unused+bx],ax
 34938 0000500D 3984[F6CB]              		cmp	[free_space.mbytes_unused+si],ax
 34939 00005011 74E8                    		je	short vc_17
 34940                                  
 34941                                  		;mov	al,[cur_disk]
 34942                                  		;push	ax		; mtc_which_disk
 34943 00005013 FF36[E2CB]              		push	word [cur_disk]
 34944 00005017 FF76FE                  		push	word [vc_input] ; mtc_mbytes_in
 34945 0000501A E8AC06                  		call	mbytes_to_cylinders
 34946                                  vc_20:
 34947                                  		;pop	bx
 34948                                  		;pop	bx
 34949                                  vc_21:
 34950                                  		;mov	[vc_input],ax
 34951                                  
 34952                                  		;/* Initialize PecentFlag back to FALSE */
 34953                                  		; PercentFlag = (FLAG)FALSE;   
 34954                                  
 34955                                  		;mov	byte [PercentFlag],0
 34956                                  
 34957                                  		;Display error message if input value = 0 */
 34958                                  
 34959 0000501D 09C0                    		or	ax,ax ; cylinders
 34960 0000501F 750E                    		jnz	short vc_22
 34961                                  
 34962                                  		;push	word [error_28_seg]
 34963 00005021 1E                      		push	ds
 34964 00005022 FF36[B69E]              		push	word [error_28_off]
 34965 00005026 E8FBC5                  		call	display
 34966                                  		;pop	bx
 34967                                  		;pop	bx
 34968                                  
 34969 00005029 E848E1                  		call	wait_for_ESC
 34970                                  		;jmp	vc_26
 34971 0000502C E94CFE                  		jmp	vc_1
 34972                                  vc_22:
 34973                                  		;/* go create the entry and find out where it put it */
 34974                                  		;ext_location = make_volume(input,location);
 34975                                  
 34976                                  		;mov	al,[vc_location]
 34977                                  		;push	ax
 34978 0000502F FF76F6                  		push	word [vc_location] ; mv_free_ptr
 34979                                  		;push	word [vc_input]
 34980                                  		;mov	ax,[vc_input]
 34981 00005032 50                      		push	ax ; volume size, mv_size
 34982 00005033 E88C09                  		call	make_volume
 34983                                  		;pop	bx
 34984                                  		;pop	bx
 34985                                  
 34986                                  		;/* clear off the old prompt */
 34987                                  		
 34988 00005036 B84F00                  		mov	ax,79
 34989 00005039 50                      		push	ax
 34990 0000503A B81300                  		mov	ax,19
 34991 0000503D 50                      		push	ax
 34992 0000503E 29C0                    		sub	ax,ax
 34993 00005040 50                      		push	ax
 34994 00005041 B80F00                  		mov	ax,15
 34995 00005044 50                      		push	ax
 34996 00005045 E84EC4                  		call	clear_screen
 34997                                  		;add	sp,8
 34998                                  
 34999 00005048 C606[78A0]01            		mov	byte [reboot_flag],1 ; reboot_flag = (FLAG)TRUE;  
 35000                                  
 35001                                  		;/* Display the updated partition information */ 
 35002                                     
 35003 0000504D E892E1                  		call	volume_display
 35004                                  
 35005                                  		;/* Tell user we created it */
 35006                                  
 35007                                  		;push	word [status_7_seg]
 35008 00005050 1E                      		push	ds
 35009 00005051 FF36[779E]              		push	word [status_7_off]
 35010 00005055 E8CCC5                  		call	display
 35011                                  		;pop	bx
 35012                                  		;pop	bx
 35013                                  		;jmp	short vc_26
 35014 00005058 E920FE                  		jmp	vc_1
 35015                                  vc_23:
 35016                                  		;/* No space left or already max'd on the devices */
 35017                                  		;/* Get rid of the size prompts */
 35018                                  		;clear_screen(u(17),u(0),u(21),u(79));
 35019                                  		;display(error_20);
 35020                                  		;volume_display();
 35021                                  		;wait_for_ESC();
 35022                                  		;input = u(ESC_FLAG);
 35023                                  
 35024 0000505B B84F00                  		mov	ax,79
 35025 0000505E 50                      		push	ax
 35026 0000505F B81500                  		mov	ax,21
 35027 00005062 50                      		push	ax
 35028 00005063 29C0                    		sub	ax,ax
 35029 00005065 50                      		push	ax
 35030 00005066 B81100                  		mov	ax,17
 35031 00005069 50                      		push	ax
 35032 0000506A E829C4                  		call	clear_screen
 35033                                  		;add	sp,8
 35034                                  
 35035                                  		;push	word [error_20_seg]
 35036 0000506D 1E                      		push	ds
 35037 0000506E FF36[A69E]              		push	word [error_20_off]
 35038 00005072 E8AFC5                  		call	display
 35039                                  		;pop	bx
 35040                                  		;pop	bx
 35041 00005075 E86AE1                  		call	volume_display
 35042 00005078 EB1A                    		jmp	short vc_25
 35043                                  vc_24:	 
 35044                                  		;/* Reached the maximum */
 35045                                  		;/* Get rid of the size prompts */
 35046                                  		;clear_screen(u(17),u(0),u(21),u(79));
 35047                                  		;display(error_27);
 35048                                  
 35049 0000507A B84F00                  		mov	ax,79
 35050 0000507D 50                      		push	ax
 35051 0000507E B81500                  		mov	ax,21
 35052 00005081 50                      		push	ax
 35053 00005082 29C0                    		sub	ax,ax
 35054 00005084 50                      		push	ax
 35055 00005085 B81100                  		mov	ax,17
 35056 00005088 50                      		push	ax
 35057 00005089 E80AC4                  		call	clear_screen
 35058                                  		;add	sp,8
 35059                                  
 35060                                  		;push	word [error_27_seg]
 35061 0000508C 1E                      		push	ds
 35062 0000508D FF36[B49E]              		push	word [error_27_off]
 35063 00005091 E890C5                  		call	display
 35064                                  		;pop	bx
 35065                                  		;pop	bx
 35066                                  vc_25:		
 35067                                  		;/* Force an exit with ESC */
 35068                                  
 35069 00005094 E8DDE0                  		call	wait_for_ESC ; wait_for_ESC();    
 35070                                  		;mov	word [vc_input],0FFFEh ; input = u(ESC_FLAG);  
 35071                                  ;		jmp	short vc_27
 35072                                  ;
 35073                                  ;		;while (input != ((unsigned)(ESC_FLAG)))
 35074                                  ;vc_26:
 35075                                  ;		cmp	word [vc_input],0FFFEh
 35076                                  ;		je	short vc_27
 35077                                  ;		jmp	vc_1
 35078                                  vc_27:
 35079                                  		;clear_screen(u(0),u(0),u(24),u(79));      
 35080                                  
 35081                                  		;mov	ax,79
 35082                                  		;push	ax
 35083                                  		;mov	ax,24
 35084                                  		;push	ax
 35085                                  		;sub	ax,ax
 35086                                  		;push	ax
 35087                                  		;push	ax
 35088                                  		;call	clear_screen
 35089                                  		;add	sp,8
 35090                                  		
 35091 00005097 E8C4C3                  		call	CLS
 35092                                  
 35093                                  		;pop	si
 35094                                  
 35095 0000509A 89EC                    		mov	sp,bp
 35096 0000509C 5D                      		pop	bp
 35097                                  
 35098                                  		;return;
 35099 0000509D C3                      		retn
 35100                                  
 35101                                  ; ----------------------------------------------------------------------------
 35102                                  ; space.c (FDISK, MSDOS 6.0, 1991)	
 35103                                  ; ----------------------------------------------------------------------------
 35104                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 14/01/2019)
 35105                                  
 35106                                  ;char find_part_free_space(type)
 35107                                  ;
 35108                                  ;char   type;
 35109                                  ;
 35110                                  ;BEGIN
 35111                                  ;
 35112                                  ;char        i;
 35113                                  ;char        partition_count;
 35114                                  ;char        last_found_partition;
 35115                                  ;unsigned    temp;
 35116                                  ;char        freespace_count;
 35117                                  ;char        any_partition;
 35118                                  ;unsigned    temp_size;
 35119                                  ;
 35120                                  ;        /* Sort the partition table */
 35121                                  ;        sort_part_table(c(4));                                          /* AC000 */
 35122                                  ;
 35123                                  ;        /* Intialize free space to zero */
 35124                                  ;        for (i = c(0); i < c(5); i++)                                   /* AC000 */
 35125                                  ;           BEGIN
 35126                                  ;            free_space[i].space = u(0);                                 /* AC000 */
 35127                                  ;            free_space[i].start = u(0);                                 /* AC000 */
 35128                                  ;            free_space[i].end = u(0);                                   /* AC000 */
 35129                                  ;            free_space[i].mbytes_unused = f(0);                         /* AC000 */  /* AN000 */
 35130                                  ;            free_space[i].percent_unused = u(0);                        /* AC000 */  /* AN000 */
 35131                                  ;           END
 35132                                  ;
 35133                                  ;        /* Find space between start of disk and first partition */
 35134                                  ;        partition_count = c(0);                                         /* AC000 */
 35135                                  ;
 35136                                  ;        any_partition = FALSE;
 35137                                  ;        for (i = c(0); i < c(4); i++)                                   /* AC000 */
 35138                                  ;           BEGIN
 35139                                  ;            if (part_table[cur_disk][sort[i]].sys_id != uc(0))          /* AC000 */
 35140                                  ;               BEGIN
 35141                                  ;                /* Found a partition, get the space */
 35142                                  ;
 35143                                  ;                free_space[0].start = u(0);                             /* AC000 */
 35144                                  ;
 35145                                  ;                /* This is a special case - the extended partition can not start */
 35146                                  ;                /* on cylinder 0 due too its archetecture. Protect against that here */
 35147                                  ;                if (type == c(EXTENDED))                                /* AC000 */
 35148                                  ;                   BEGIN
 35149                                  ;                    free_space[0].start = u(1);                         /* AC000 */
 35150                                  ;                  END
 35151                                  ;
 35152                                  ;                /* free space ends before start of next valid partition */
 35153                                  ;                if (part_table[cur_disk][sort[i]].start_cyl > u(0))     /* AC000 */
 35154                                  ;                   BEGIN
 35155                                  ;                    free_space[0].end = part_table[cur_disk][sort[i]].start_cyl-1;
 35156                                  ;                    free_space[0].space = part_table[cur_disk][sort[i]].start_cyl-free_space[0].start; /*C04*/
 35157                                  ;                   END
 35158                                  ;
 35159                                  ;                free_space[0].mbytes_unused =
 35160                                  ;                    cylinders_to_mbytes(free_space[0].space,cur_disk);  /* AN004 */
 35161                                  ;                free_space[0].percent_unused = (unsigned)cylinders_to_percent(free_space[0].space,total_disk[cur_disk]); /* AN000 */
 35162                                  ;
 35163                                  ;                partition_count = i;
 35164                                  ;                last_found_partition = sort[i];
 35165                                  ;                any_partition = TRUE;
 35166                                  ;                break;
 35167                                  ;               END
 35168                                  ;           END
 35169                                  ;        /* See if any partitions were there */
 35170                                  ;        if (any_partition)
 35171                                  ;           BEGIN
 35172                                  ;            /* Look for space between the rest of the partitions */
 35173                                  ;            freespace_count = c(1);                                     /* AC000 */
 35174                                  ;            for (i = partition_count+1; i < c(4); i++)                  /* AC000 */
 35175                                  ;               BEGIN
 35176                                  ;                if (part_table[cur_disk][sort[i]].sys_id != uc(0))      /* AC000 */
 35177                                  ;                   BEGIN
 35178                                  ;                    /* Check to see if more than one partition on a cylinder (i.e. XENIX bad block)  */
 35179                                  ;                    /* If so, leave the space at zero */
 35180                                  ;
 35181                                  ;                    if (part_table[cur_disk][sort[i]].start_cyl != part_table[cur_disk][last_found_partition].end_cyl)
 35182                                  ;                       BEGIN
 35183                                  ;                        /* No, things are normal */
 35184                                  ;                        /* Get space between the end of the last one and the start of the next one */
 35185                                  ;                        free_space[freespace_count].space = part_table[cur_disk][sort[i]].start_cyl
 35186                                  ;                           - (part_table[cur_disk][last_found_partition].end_cyl+1);
 35187                                  ;
 35188                                  ;                        temp_size = (part_table[cur_disk][sort[i]].start_cyl -
 35189                                  ;                             part_table[cur_disk][last_found_partition].end_cyl);
 35190                                  ;
 35191                                  ;                        if (temp_size != u(0) )                         /* AC000 */
 35192                                  ;                           BEGIN
 35193                                  ;                            free_space[freespace_count].space = temp_size - u(1);  /* AC000 */
 35194                                  ;                           END
 35195                                  ;                       END
 35196                                  ;
 35197                                  ;                    free_space[freespace_count].start = part_table[cur_disk][last_found_partition].end_cyl+1;
 35198                                  ;                    free_space[freespace_count].end = part_table[cur_disk][sort[i]].start_cyl -1;
 35199                                  ;                    free_space[freespace_count].mbytes_unused =
 35200                                  ;                         cylinders_to_mbytes(free_space[freespace_count].space,cur_disk); /* AN004 */
 35201                                  ;                    free_space[freespace_count].percent_unused = (unsigned)
 35202                                  ;                         cylinders_to_percent(free_space[freespace_count].space,total_disk[cur_disk]);  /* AN000 */
 35203                                  ;
 35204                                  ;                    /* update the last found partition */
 35205                                  ;                    last_found_partition = sort[i];
 35206                                  ;                    freespace_count++;
 35207                                  ;                   END
 35208                                  ;               END
 35209                                  ;            /* Find the space between the last partition and the end of the disk */
 35210                                  ;            /* SR; 10/10/89; Make sure that freespace cannot become negative */
 35211                                  ;
 35212                                  ;            if ( total_disk[cur_disk] >
 35213                                  ;                 part_table[cur_disk][last_found_partition].end_cyl )
 35214                                  ;               {
 35215                                  ;            	free_space[freespace_count].space = (total_disk[cur_disk]
 35216                                  ;                                     	-  part_table[cur_disk][last_found_partition].end_cyl)-1;
 35217                                  ;            	free_space[freespace_count].start = part_table[cur_disk][last_found_partition].end_cyl+1;
 35218                                  ;            	free_space[freespace_count].end = total_disk[cur_disk]-1;
 35219                                  ;            	free_space[freespace_count].mbytes_unused =
 35220                                  ;                 	cylinders_to_mbytes(free_space[freespace_count].space,cur_disk);    /* AN004 */
 35221                                  ;            	free_space[freespace_count].percent_unused =
 35222                                  ;                 	cylinders_to_percent(free_space[freespace_count].space,total_disk[cur_disk]); /* AN000 */
 35223                                  ;               }
 35224                                  ;            END
 35225                                  ;         else
 35226                                  ;           BEGIN
 35227                                  ;            /* No partitions found, show entire space as free */
 35228                                  ;            free_space[0].start = u(0);                                 /* AC000 */
 35229                                  ;
 35230                                  ;            /* This is a special case - the extended partition can not start */
 35231                                  ;            /* on cylinder 0 due too its architecture. Protect against that here */
 35232                                  ;            if (type == c(EXTENDED))                                    /* AC000 */
 35233                                  ;               BEGIN
 35234                                  ;                free_space[0].start = u(1);                             /* AC000 */
 35235                                  ;               END
 35236                                  ;            free_space[0].end = total_disk[cur_disk]-1;
 35237                                  ;            free_space[0].space = (free_space[0].end - free_space[0].start)+1;
 35238                                  ;            free_space[0].mbytes_unused =
 35239                                  ;                 cylinders_to_mbytes(free_space[0].space,cur_disk);    /* AN004 */
 35240                                  ;            free_space[0].percent_unused =
 35241                                  ;                 cylinders_to_percent(free_space[0].space,total_disk[cur_disk]); /* AN000 */
 35242                                  ;           END
 35243                                  ;
 35244                                  ;         /* Find largest free space, and verify the golden tracks while we are at it */
 35245                                  ;         do
 35246                                  ;            BEGIN
 35247                                  ;             temp = u(0);                                               /* AC000 */
 35248                                  ;
 35249                                  ;             /* Zip thru the table */
 35250                                  ;             for (i = c(0); i < c(5); i++)                              /* AC000 */
 35251                                  ;                BEGIN
 35252                                  ;                 /* Is this one bigger ? */
 35253                                  ;                 if (free_space[i].space > temp)
 35254                                  ;                    BEGIN
 35255                                  ;                     temp = free_space[i].space;
 35256                                  ;                     last_found_partition = i;
 35257                                  ;                    END
 35258                                  ;                END
 35259                                  ;
 35260                                  ;             /* If there is any free space, go verify it */
 35261                                  ;             temp = u(0);
 35262                                  ;             if (free_space[last_found_partition].space != u(0))        /* AC000 */
 35263                                  ;               BEGIN
 35264                                  ;                /* Go verify the tracks */
 35265                                  ;                temp = verify_tracks(last_found_partition,c(PRIMARY));  /* AC000 */
 35266                                  ;               END
 35267                                  ;             /* Move up to next golden track */
 35268                                  ;             free_space[last_found_partition].start = free_space[last_found_partition].start+temp;
 35269                                  ;             free_space[last_found_partition].space = free_space[last_found_partition].space-temp;
 35270                                  ;             free_space[last_found_partition].mbytes_unused =
 35271                                  ;                  cylinders_to_mbytes(free_space[last_found_partition].space,cur_disk);    /* AN004 */
 35272                                  ;             free_space[last_found_partition].percent_unused = (unsigned)
 35273                                  ;                  cylinders_to_percent(free_space[last_found_partition].space,total_disk[cur_disk]);                      /* AN000 */
 35274                                  ;             END
 35275                                  ;
 35276                                  ;            /* Repeat the loop if the start was moved due to bad tracks */
 35277                                  ;            /* Unless we're past the end of the free space */
 35278                                  ;            while ((temp != u(0)) && (free_space[last_found_partition].space != u(0)));    /* AC000 */
 35279                                  ;
 35280                                  ;        /* Don't create a partition larger than DOS can handle */                                       /*C05*/
 35281                                  ;        if((type == c(PRIMARY)) && (free_space[last_found_partition].mbytes_unused > u(MAX_PART_SIZE))) /*C05*/
 35282                                  ;          BEGIN                                                                                         /*C05*/
 35283                                  ;          free_space[last_found_partition].space =                                                      /*C05*/
 35284                                  ;           mbytes_to_cylinders(f(MAX_PART_SIZE),cur_disk) - 1;                                          /*C05*/
 35285                                  ;          free_space[last_found_partition].end =                                                        /*C05*/
 35286                                  ;           free_space[last_found_partition].start+free_space[last_found_partition].space-1;             /*C05*/
 35287                                  ;          free_space[last_found_partition].mbytes_unused =                                              /*C05*/
 35288                                  ;           cylinders_to_mbytes(free_space[last_found_partition].space,cur_disk);                        /*C05*/
 35289                                  ;          free_space[last_found_partition].percent_unused = (unsigned)                                  /*C05*/
 35290                                  ;           cylinders_to_percent(free_space[last_found_partition].space,total_disk[cur_disk]);           /*C05*/
 35291                                  ;          END                                                                                           /*C05*/
 35292                                  ;
 35293                                  ;        /* Return with the pointer to the largest free space */
 35294                                  ;        return(last_found_partition);
 35295                                  ;END
 35296                                  
 35297                                  find_part_free_space:
 35298                                  		; 17/01/2019
 35299                                  		; 14/01/2019
 35300                                  
 35301                                  	%define fpfs_type	bp-12 ; 25/01/2019
 35302                                  
 35303                                  	%define fpfs_i			bp-10	;bp-14
 35304                                  	%define last_found_partition	bp-8	;bp-12
 35305                                  	%define fpfs_temp		bp-6	;bp-10
 35306                                  	%define freespace_count		bp-4	;bp-8
 35307                                  	%define fpfs_partition_count	bp-2	;bp-6
 35308                                  	;%define fpfs_anypartition		;bp-4
 35309                                  
 35310                                  	;%define fpfs_type	bp+4
 35311                                  
 35312 0000509E 55                      		push	bp
 35313 0000509F 89E5                    		mov	bp,sp
 35314                                  		;;sub	sp,14
 35315                                  		;sub	sp,10  ; 20/01/2019
 35316 000050A1 83EC0C                  		sub	sp,12  ; 25/01/2019
 35317                                  
 35318                                  		;push	di
 35319                                  		;push	si
 35320                                  
 35321                                    		;/* Sort the partition table */
 35322                                  
 35323                                  		;mov	al,4
 35324                                  		;push	ax
 35325 000050A4 B104                    		mov	cl,4
 35326 000050A6 E8FCD8                  		call	sort_part_table
 35327                                  		;pop	bx
 35328                                  
 35329                                  		;/* Initialize free space to zero */
 35330                                  
 35331                                  		;mov	byte [fpfs_i],0
 35332                                  fpfs_1:
 35333                                  		;mov	al,22
 35334                                  		;;imul	byte [fpfs_i]
 35335                                  		;mul	byte [fpfs_i]
 35336                                  		;mov	bx,ax
 35337                                  		;sub	ax,ax ; 0
 35338                                  		;mov	[free_space.space+bx],ax
 35339                                  		;mov	[free_space.start+bx],ax
 35340                                  		;mov	[free_space.end+bx],ax
 35341                                  		;mov	[free_space.mbytes_unused+bx],ax
 35342                                  		;mov	[free_space.percent_unused+bx],ax
 35343                                  		;inc	byte [fpfs_i]
 35344                                  		;cmp	byte [fpfs_i],5
 35345                                  		;jl	short fpfs_1
 35346                                  		
 35347                                  		;push	cs
 35348                                  		;pop	es
 35349 000050A9 BF[F0CB]                		mov	di,fspc ; free_space.space
 35350 000050AC B91900                  		mov	cx,5*5 ; (5*10/2) ; 17/01/2019
 35351 000050AF 31C0                    		xor	ax,ax ; 0
 35352 000050B1 F3AB                    		rep	stosw
 35353                                  
 35354                                  		;sub	al,al
 35355 000050B3 8846FE                  		mov	[fpfs_partition_count],al ; 0
 35356                                  		;mov	[fpfs_anypartition],al ; 0
 35357 000050B6 8846F6                  		mov	[fpfs_i],al ; 0
 35358 000050B9 EB11                    		jmp	short fpfs_3
 35359                                  fpfs_2:	
 35360 000050BB FE46F6                  		inc	byte [fpfs_i]
 35361                                  ;fpfs_3:
 35362 000050BE 807EF604                		cmp	byte [fpfs_i],4
 35363 000050C2 7203                    		jb	short fpfs_4
 35364                                  		;jmp	fpfs_7
 35365 000050C4 E99E01                  		jmp	fpfs_16
 35366                                  fpfs_4:
 35367                                  	; /* Find space between start of disk and first partition */
 35368                                  
 35369                                  		; 17/01/2019
 35370                                  		;mov	al,[cur_disk]
 35371                                  		;;cbw
 35372                                  		;;shl	ax,1
 35373                                  		;;shl	ax,1
 35374                                  		;;mov	cx,ax
 35375                                  		;shl	al,1
 35376                                  		;shl	al,1
 35377                                  		;mov	cl,al
 35378                                  
 35379 000050C7 8A46F6                  		mov	al,[fpfs_i]
 35380                                  		;cbw
 35381 000050CA 30E4                    		xor	ah,ah
 35382                                  fpfs_3:
 35383                                  		; 17/01/2019
 35384 000050CC 8A0E[E2CB]              		mov	cl,[cur_disk]
 35385 000050D0 D0E1                    		shl	cl,1
 35386 000050D2 D0E1                    		shl	cl,1
 35387                                  
 35388 000050D4 89C3                    		mov	bx,ax
 35389                                  
 35390 000050D6 8A87[F0C3]              		mov	al,[sort+bx]
 35391                                  		;cbw
 35392                                  		;add	ax,cx
 35393 000050DA 00C8                    		add	al,cl
 35394                                  
 35395                                  		;mov	cx,46
 35396                                  		;imul	cx
 35397 000050DC B12E                    		mov	cl,46
 35398 000050DE F6E1                    		mul	cl
 35399 000050E0 89C3                    		mov	bx,ax
 35400                                  
 35401 000050E2 80BF[25C4]00            		cmp	byte [part_table_sys_id+bx],0
 35402 000050E7 74D2                    		je	short fpfs_2
 35403                                  
 35404 000050E9 31C0                    		xor	ax,ax
 35405                                  
 35406                                  		;free_space[0].start = u(0);  
 35407                                  
 35408                                  		;mov	word [free_space.start],0
 35409 000050EB 807EF405                		cmp	byte [fpfs_type],5  ; EXTENDED
 35410 000050EF 7502                    		jne	short fpfs_5
 35411                                  
 35412                                  	;/* This is a special case - the extended partition can not start */
 35413                                  	;/* on cylinder 0 due too its architecture. Protect against that here */
 35414                                  
 35415                                  		;free_space[0].start = u(1);  
 35416                                  
 35417                                  		;mov	word [free_space_start],1
 35418                                  
 35419 000050F1 FEC0                    		inc	al  ; ax = 1
 35420                                  fpfs_5:
 35421                                  		;/* Found a partition, get the space */	
 35422                                  
 35423 000050F3 A3[F2CB]                		mov	[free_space.start],ax ; 0 or 1
 35424                                  
 35425                                  		;mov	al,[cur_disk]
 35426                                  		;;cbw
 35427                                  		;;shl	ax,1
 35428                                  		;;shl	ax,1
 35429                                  		;;mov	cx,ax
 35430                                  		;mov	cl,al
 35431                                  		;mov	al,[fpfs_i]
 35432                                  		;;cbw
 35433                                  		;; ah = 0
 35434                                  		;mov	bx,ax
 35435                                  		;mov	al,[sort+bx]
 35436                                  		;;cbw
 35437                                  		;;add	ax,cx
 35438                                  		;add	al,cl
 35439                                  		;;mov	cx,46
 35440                                  		;;imul	cx
 35441                                  		;mov	cl,46
 35442                                  		;mul	cl	
 35443                                  		;mov	bx,ax
 35444                                  
 35445                                  		;/* free space ends before start of next valid partition */
 35446                                  		
 35447                                  		;cmp	word [part_table_start_cyl+bx],0
 35448                                  		;je	short fpfs_6
 35449                                  		;mov	ax,[part_table_start_cyl+bx]
 35450                                  		
 35451 000050F6 8B87[23C4]              		mov	ax,[part_table_start_cyl+bx]
 35452 000050FA 09C0                    		or	ax,ax
 35453 000050FC 740E                    		jz	short fpfs_6
 35454                                  
 35455                                  	;free_space[0].end = part_table[cur_disk][sort[i]].start_cyl-1;
 35456                                  	;free_space[0].space = part_table[cur_disk][sort[i]].start_cyl-free_space[0].start;
 35457                                  
 35458 000050FE 89C1                    		mov	cx,ax
 35459 00005100 48                      		dec	ax 
 35460 00005101 A3[F4CB]                		mov	[free_space.end],ax
 35461 00005104 2B0E[F2CB]              		sub	cx,[free_space.start]
 35462 00005108 890E[F0CB]              		mov	[free_space.space],cx
 35463                                  fpfs_6:	
 35464                                  	;free_space[0].mbytes_unused = cylinders_to_mbytes(free_space[0].space,cur_disk);
 35465                                  
 35466                                  		;mov	al,[cur_disk]
 35467                                  		;push	ax
 35468                                  		;push	word [free_space.space]
 35469                                  
 35470 0000510C 8A1E[E2CB]              		mov	bl,[cur_disk]
 35471 00005110 30FF                    		xor	bh,bh
 35472                                  
 35473 00005112 A1[F0CB]                		mov	ax,[free_space.space]
 35474                                  
 35475 00005115 E84EC4                  		call	cylinders_to_mbytes
 35476                                  		;pop	bx
 35477                                  		;pop	bx
 35478                                  
 35479 00005118 A3[F6CB]                		mov	[free_space.mbytes_unused],ax
 35480                                  
 35481                                  ;free_space[0].percent_unused = cylinders_to_percent(free_space[0].space,total_disk[cur_disk]);
 35482                                  
 35483 0000511B A0[E2CB]                		mov	al,[cur_disk]
 35484 0000511E 98                      		cbw
 35485 0000511F 89C3                    		mov	bx,ax
 35486 00005121 D1E3                    		shl	bx,1
 35487                                  		;push	word [total_disk+bx]
 35488 00005123 8B8F[C6A0]              		mov	cx,[total_disk+bx]	; Total (disk) cylinders -divisor-
 35489                                  		;push	word [free_space.space]
 35490 00005127 8B1E[F0CB]              		mov	bx,[free_space.space]	; Partition cylinders -dividend-
 35491                                  
 35492 0000512B E88BC4                  		call	cylinders_to_percent
 35493                                  		;pop	bx
 35494                                  		;pop	bx
 35495                                  
 35496 0000512E A3[F8CB]                		mov	[free_space.percent_unused],ax
 35497                                  
 35498                                  		;partition_count = i;
 35499                                  		;last_found_partition = sort[i];
 35500                                  		;any_partition = TRUE;
 35501                                  
 35502 00005131 8A46F6                  		mov	al,[fpfs_i]
 35503 00005134 8846FE                  		mov	[fpfs_partition_count],al
 35504 00005137 98                      		cbw
 35505 00005138 89C3                    		mov	bx,ax
 35506 0000513A 8A87[F0C3]              		mov	al,[sort+bx]
 35507 0000513E 8846F8                  		mov	[last_found_partition],al
 35508                                  		;mov	byte [fpfs_anypartition],1
 35509                                  ;fpfs_7:	
 35510                                  ;		;/* See if any partitions were there */
 35511                                  ;		cmp	byte [fpfs_anypartition],0
 35512                                  ;		jne	short fpfs_8
 35513                                  ;		jmp	fpfs_16
 35514                                  fpfs_8:	
 35515                                  		;/* Look for space between the rest of the partitions */
 35516                                  
 35517 00005141 C646FC01                		mov	byte [freespace_count],1
 35518 00005145 8A46FE                  		mov	al,[fpfs_partition_count]
 35519 00005148 FEC0                    		inc	al
 35520 0000514A 8846F6                  		mov	[fpfs_i],al
 35521 0000514D E9A000                  		jmp	fpfs_13
 35522                                  fpfs_9:
 35523                                  		;mov	al,[cur_disk]
 35524                                  		;cbw
 35525                                  		;shl	ax,1
 35526                                  		;shl	ax,1
 35527                                  		;mov	cx,ax
 35528 00005150 8A0E[E2CB]              		mov	cl,[cur_disk]
 35529 00005154 D0E1                    		shl	cl,1
 35530 00005156 D0E1                    		shl	cl,1   ; =**=
 35531 00005158 8A46F6                  		mov	al,[fpfs_i]
 35532 0000515B 98                      		cbw
 35533 0000515C 89C3                    		mov	bx,ax
 35534 0000515E 8A87[F0C3]              		mov	al,[sort+bx]
 35535                                  		;cbw
 35536                                  		;add	ax,cx
 35537 00005162 00C8                    		add	al,cl  ; =**=
 35538                                  		;mov	bx,46
 35539                                  		;imul	bx
 35540 00005164 B32E                    		mov	bl,46
 35541 00005166 F6E3                    		mul	bl
 35542 00005168 89C6                    		mov	si,ax  ; ****
 35543                                  	
 35544                                  	;if (part_table[cur_disk][sort[i]].sys_id != uc(0))
 35545                                  
 35546 0000516A 80BC[25C4]00            		cmp	byte [part_table_sys_id+si],0 ;****
 35547                                  		;jne	short fpfs_10
 35548                                  		;jmp	fpfs_12
 35549 0000516F 747C                    		je	short fpfs_12 ; 17/01/2019
 35550                                  fpfs_10:
 35551                                  	;/* Check to see if more than one partition on a cylinder (i.e. XENIX bad block)  */
 35552                                  	;/* If so, leave the space at zero */
 35553                                  
 35554                                  ;if (part_table[cur_disk][sort[i]].start_cyl != part_table[cur_disk][last_found_partition].end_cyl)
 35555                                  
 35556 00005171 8A46F8                  		mov	al,[last_found_partition]
 35557                                  		;cbw
 35558                                  		;add	ax,cx
 35559 00005174 00C8                    		add	al,cl ; =**=
 35560                                  		;imul	bx
 35561 00005176 F6E3                    		mul	bl
 35562 00005178 89C3                    		mov	bx,ax
 35563                                  		;mov	ax,[part_table_end_cyl+bx]
 35564 0000517A 8B97[28C4]              		mov	dx,[part_table_end_cyl+bx] ;****	
 35565                                  		;cmp	[part_table_start_cyl+si],ax
 35566                                  		;je	short fpfs_11
 35567                                  
 35568 0000517E B00A                    		mov	al,10
 35569 00005180 F666FC                  		mul	byte [freespace_count]
 35570 00005183 89C7                    		mov	di,ax  ;***
 35571                                  
 35572 00005185 3994[23C4]              		cmp	[part_table_start_cyl+si],dx  ;****
 35573 00005189 740D                    		je	short fpfs_11
 35574                                  		
 35575                                  	;/* No, things are normal */
 35576                                  	;/* Get space between the end of the last one and the start of the next one */
 35577                                  
 35578                                  	; free_space[freespace_count].space = part_table[cur_disk][sort[i]].start_cyl
 35579                                  	;                           - (part_table[cur_disk][last_found_partition].end_cyl+1);
 35580                                  
 35581                                  		;sub	ax,[part_table_start_cyl+si]
 35582                                  		;neg	ax
 35583                                  		;dec	ax
 35584                                  		;mov	dx,ax
 35585                                  		
 35586                                  		;;mov	al,22
 35587                                  		;mov	al,10
 35588                                  		;;imul	byte [freespace_count]
 35589                                  		;mul	byte [freespace_count]
 35590                                  		;mov	bx,ax
 35591                                  
 35592                                  		;mov	[free_space.space+bx],dx  ; free_space[freespace_count].space
 35593                                  
 35594 0000518B 89D0                    		mov	ax,dx  ; part_table[cur_disk][last_found_partition].end_cyl
 35595 0000518D 2B84[23C4]              		sub	ax,[part_table_start_cyl+si] ; part_table[cur_disk][sort[i]].start_cyl
 35596 00005191 F7D8                    		neg	ax
 35597 00005193 48                      		dec	ax  ; - 1		
 35598                                  
 35599 00005194 8985[F0CB]              		mov	[free_space.space+di],ax  ; free_space[freespace_count].space
 35600                                  fpfs_11:
 35601                                  	;free_space[freespace_count].start = part_table[cur_disk][last_found_partition].end_cyl+1;
 35602                                          ;free_space[freespace_count].end = part_table[cur_disk][sort[i]].start_cyl-1;
 35603                                          ;free_space[freespace_count].mbytes_unused =
 35604                                          ;	cylinders_to_mbytes(free_space[freespace_count].space,cur_disk);
 35605                                          ;free_space[freespace_count].percent_unused = (unsigned)
 35606                                          ;       cylinders_to_percent(free_space[freespace_count].space,total_disk[cur_disk]);
 35607                                  
 35608                                  		;mov	al,[cur_disk]
 35609                                  		;cbw
 35610                                  		;shl	ax,1
 35611                                  		;shl	ax,1
 35612                                  		;mov	cx,ax
 35613                                  		;mov	al,[last_found_partition]
 35614                                  		;cbw
 35615                                  		;add	ax,cx
 35616                                  		;mov	bx,46
 35617                                  		;imul	bx
 35618                                  		;mov	si,ax
 35619                                  		;mov	ax,[part_table_end_cyl+si]
 35620                                  		;inc	ax
 35621                                  		;mov	dx,ax
 35622                                  		
 35623 00005198 42                      		inc	dx ;  part_table[cur_disk][last_found_partition].end_cyl+1
 35624                                  
 35625                                  		;mov	al,22
 35626                                  		;imul	byte [freespace_count]
 35627                                  		;mov	si,ax
 35628                                  		;mov	[free_space.start+si],dx
 35629                                  		
 35630 00005199 8995[F2CB]              		mov	[free_space.start+di],dx ; ***
 35631                                  		
 35632 0000519D 8A46F6                  		mov	al,[fpfs_i]
 35633 000051A0 98                      		cbw
 35634                                  		;mov	di,ax
 35635                                  		;mov	al,[sort+di]
 35636 000051A1 89C3                    		mov	bx,ax
 35637 000051A3 8A87[F0C3]              		mov	al,[sort+bx]		
 35638                                  
 35639                                  		;cbw
 35640                                  		;add	ax,cx
 35641 000051A7 00C8                    		add	al,cl ; =**=
 35642                                  		
 35643                                  		;mov	cl,[cur_disk]
 35644                                  		;imul	bx
 35645                                  		;mov	bx,ax
 35646                                  
 35647                                  		; 17/01/2019
 35648 000051A9 B12E                    		mov	cl,46
 35649 000051AB F6E1                    		mul	cl
 35650 000051AD 89C6                    		mov	si,ax
 35651                                  		
 35652                                  		;mov	ax,[part_table_start_cyl+bx]
 35653 000051AF 8B84[23C4]              		mov	ax,[part_table_start_cyl+si] ;****
 35654 000051B3 48                      		dec	ax
 35655                                  		;mov	[free_space.end+si],ax
 35656 000051B4 8985[F4CB]              		mov	[free_space.end+di],ax ;***
 35657                                  
 35658                                  		;mov	al,[cur_disk]
 35659                                  		;push	ax
 35660                                  		;push	word [free_space.space+si]
 35661                                  		
 35662 000051B8 8A1E[E2CB]              		mov	bl,[cur_disk]
 35663                                  		; bh = 0
 35664 000051BC 8B85[F0CB]              		mov	ax,[free_space.space+di] ;***
 35665 000051C0 E8A3C3                  		call	cylinders_to_mbytes
 35666                                  		;pop	bx
 35667                                  		;pop	bx
 35668                                  		;mov	[free_space.mbytes_unused+si],ax
 35669                                  		
 35670 000051C3 8985[F6CB]              		mov	[free_space.mbytes_unused+di],ax ;***
 35671                                  
 35672 000051C7 A0[E2CB]                		mov	al,[cur_disk]
 35673 000051CA 98                      		cbw
 35674 000051CB 89C3                    		mov	bx,ax
 35675 000051CD D1E3                    		shl	bx,1
 35676                                  		;push	word [total_disk+bx]
 35677 000051CF 8B8F[C6A0]              		mov	cx,[total_disk+bx] ; -divisor-
 35678                                  		;push	word [free_space.space+si]
 35679 000051D3 8B9D[F0CB]              		mov	bx,[free_space.space+di] ;*** -dividend-
 35680 000051D7 E8DFC3                  		call	cylinders_to_percent
 35681                                  		;pop	bx
 35682                                  		;pop	bx
 35683                                  
 35684                                  		;mov	[free_space.percent_unused+si],ax
 35685 000051DA 8985[F8CB]              		mov	[free_space.percent_unused+di],ax ;***
 35686                                  
 35687                                  		; 17/01/2019
 35688                                  		;mov	al,[sort+di]
 35689                                  
 35690 000051DE 8A5EF6                  		mov	bl,[fpfs_i]
 35691 000051E1 30FF                    		xor	bh,bh
 35692 000051E3 8A87[F0C3]              		mov	al,[sort+bx]
 35693                                  		
 35694 000051E7 8846F8                  		mov	[last_found_partition],al
 35695                                  
 35696 000051EA FE46FC                  		inc	byte [freespace_count]
 35697                                  fpfs_12:
 35698 000051ED FE46F6                  		inc	byte [fpfs_i]
 35699                                  fpfs_13:
 35700                                  	;  for (i = partition_count+1; i < c(4); i++)
 35701                                  
 35702 000051F0 807EF604                		cmp	byte [fpfs_i],4
 35703 000051F4 7D03                    		jge	short fpfs_14
 35704 000051F6 E957FF                  		jmp	fpfs_9
 35705                                  fpfs_14:
 35706                                  	;/* Find the space between the last partition and the end of the disk */
 35707                                  	;/* Make sure that freespace cannot become negative */
 35708                                  	;
 35709                                  	;  if ( total_disk[cur_disk] >
 35710                                  	;     part_table[cur_disk][last_found_partition].end_cyl )
 35711                                  
 35712 000051F9 A0[E2CB]                		mov	al,[cur_disk]
 35713 000051FC 98                      		cbw
 35714                                  		;mov	bx,ax
 35715                                  		;mov	al,[last_found_partition]
 35716                                  		;cbw
 35717                                  		;mov	cx,bx
 35718                                  		;shl	bx,1
 35719                                  		;shl	bx,1
 35720                                  		;add	ax,bx
 35721 000051FD D0E0                    		shl	al,1
 35722 000051FF 89C6                    		mov	si,ax
 35723 00005201 D0E0                    		shl	al,1
 35724 00005203 0246F8                  		add	al,[last_found_partition]
 35725                                  		;mov	bx,46
 35726                                  		;imul	bx
 35727                                  		;mov	bx,ax
 35728                                  		;mov	si,cx
 35729                                  		;shl	si,1
 35730 00005206 B12E                    		mov	cl,46
 35731 00005208 F6E1                    		mul	cl
 35732 0000520A 89C3                    		mov	bx,ax
 35733 0000520C 8B84[C6A0]              		mov	ax,[total_disk+si]
 35734 00005210 3987[28C4]              		cmp	[part_table_end_cyl+bx],ax
 35735 00005214 7203                    		jb	short fpfs_15
 35736 00005216 E98B00                  		jmp	fpfs_18
 35737                                  fpfs_15:
 35738                                  	;free_space[freespace_count].space = (total_disk[cur_disk]
 35739                                  	;      	-  part_table[cur_disk][last_found_partition].end_cyl)-1;
 35740                                  	;free_space[freespace_count].start = part_table[cur_disk][last_found_partition].end_cyl+1;
 35741                                  	;free_space[freespace_count].end = total_disk[cur_disk]-1;
 35742                                  	;free_space[freespace_count].mbytes_unused =
 35743                                  	;      	cylinders_to_mbytes(free_space[freespace_count].space,cur_disk);
 35744                                  	;free_space[freespace_count].percent_unused =
 35745                                  	;      	cylinders_to_percent(free_space[freespace_count].space,total_disk[cur_disk]);
 35746                                  
 35747 00005219 89C1                    		mov	cx,ax
 35748 0000521B 2B87[28C4]              		sub	ax,[part_table_end_cyl+bx]
 35749 0000521F 48                      		dec	ax
 35750 00005220 89C2                    		mov	dx,ax
 35751                                  		;mov	al,22
 35752 00005222 B00A                    		mov	al,10
 35753                                  		;imul	byte [freespace_count]
 35754 00005224 F666FC                  		mul	byte [freespace_count]
 35755 00005227 89C6                    		mov	si,ax
 35756 00005229 8994[F0CB]              		mov	[free_space.space+si],dx
 35757 0000522D 8B87[28C4]              		mov	ax,[part_table_end_cyl+bx]
 35758 00005231 40                      		inc	ax
 35759 00005232 8984[F2CB]              		mov	[free_space.start+si],ax
 35760 00005236 49                      		dec	cx
 35761 00005237 898C[F4CB]              		mov	[free_space.end+si],cx
 35762                                  		
 35763                                  		;mov	al,[cur_disk]
 35764                                  		;push	ax
 35765 0000523B 8A1E[E2CB]              		mov	bl,[cur_disk]
 35766 0000523F 30FF                    		xor	bh,bh
 35767                                  		;push	word [free_space.space+si]
 35768 00005241 8B84[F0CB]              		mov	ax,[free_space.space+si]
 35769 00005245 E81EC3                  		call	cylinders_to_mbytes
 35770                                  		;pop	bx
 35771                                  		;pop	bx
 35772 00005248 8984[F6CB]              		mov	[free_space.mbytes_unused+si],ax
 35773 0000524C A0[E2CB]                		mov	al,[cur_disk]
 35774 0000524F 98                      		cbw
 35775 00005250 89C3                    		mov	bx,ax
 35776 00005252 D1E3                    		shl	bx,1
 35777                                  		;push	word [total_disk+bx]
 35778 00005254 8B8F[C6A0]              		mov	cx,[total_disk+bx]
 35779                                  		;push	word [free_space.space+si]
 35780 00005258 8B9C[F0CB]              		mov	bx,[free_space.space+si]
 35781 0000525C E85AC3                  		call	cylinders_to_percent
 35782                                  		;pop	bx
 35783                                  		;pop	bx
 35784 0000525F 8984[F8CB]              		mov	[free_space.percent_unused+si],ax
 35785 00005263 EB3F                    		jmp	short fpfs_18
 35786                                  fpfs_16:
 35787                                  		;/* No partitions found, show entire space as free */
 35788                                  
 35789                                  		;free_space[0].start = u(0);
 35790                                  
 35791 00005265 29C0                    		sub	ax,ax
 35792                                  		;mov	word [free_space.start],0
 35793                                  
 35794                                  	;/* This is a special case - the extended partition can not start */
 35795                                  	;/* on cylinder 0 due too its architecture. Protect against that here */
 35796                                  	;if (type == c(EXTENDED))
 35797                                  	;   BEGIN
 35798                                  	;      free_space[0].start = u(1);
 35799                                  	;   END
 35800 00005267 807EF405                		cmp	byte [fpfs_type],5 ; EXTENDED
 35801 0000526B 7502                    		jne	short fpfs_17
 35802                                  		
 35803                                  		;mov	word [free_space.start],1
 35804 0000526D FEC0                    		inc	al
 35805                                  fpfs_17:
 35806 0000526F A3[F2CB]                		mov	[free_space.start],ax ; 0 or 1
 35807                                  
 35808                                  	;free_space[0].end = total_disk[cur_disk]-1;
 35809                                  	;free_space[0].space = (free_space[0].end - free_space[0].start)+1;
 35810                                  	;free_space[0].mbytes_unused =
 35811                                  	;     cylinders_to_mbytes(free_space[0].space,cur_disk);
 35812                                  	;free_space[0].percent_unused =
 35813                                  	;     cylinders_to_percent(free_space[0].space,total_disk[cur_disk]);
 35814                                  
 35815 00005272 A0[E2CB]                		mov	al,[cur_disk]
 35816 00005275 98                      		cbw
 35817                                  		;mov	bx,ax
 35818                                  		;shl	bx,1
 35819                                  		;mov	ax,[total_disk+bx]
 35820 00005276 D0E0                    		shl	al,1
 35821 00005278 89C6                    		mov	si,ax
 35822 0000527A 8B84[C6A0]              		mov	ax,[total_disk+si] 
 35823 0000527E 48                      		dec	ax
 35824 0000527F A3[F4CB]                		mov	[free_space.end],ax
 35825 00005282 2B06[F2CB]              		sub	ax,[free_space.start]
 35826 00005286 40                      		inc	ax
 35827 00005287 A3[F0CB]                		mov	[free_space.space],ax
 35828                                  		;mov	cl,[cur_disk]
 35829                                  		;push	cx
 35830                                  		;push	ax
 35831 0000528A 30FF                    		xor	bh,bh
 35832 0000528C 8A1E[E2CB]              		mov	bl,[cur_disk]
 35833 00005290 E8D3C2                  		call	cylinders_to_mbytes
 35834                                  		;pop	bx
 35835                                  		;pop	bx
 35836 00005293 A3[F6CB]                		mov	[free_space.mbytes_unused],ax
 35837                                  		;mov	al,[cur_disk]
 35838                                  		;cbw
 35839                                  		;mov	bx,ax
 35840                                  		;shl	bx,1
 35841                                  		;push	word [total_disk+bx]
 35842 00005296 8B8C[C6A0]              		mov	cx,[total_disk+si] 
 35843                                  		;push	word [free_space.space]
 35844 0000529A 8B1E[F0CB]              		mov	bx,[free_space.space]
 35845 0000529E E818C3                  		call	cylinders_to_percent
 35846                                  		;pop	bx
 35847                                  		;pop	bx
 35848 000052A1 A3[F8CB]                		mov	[free_space.percent_unused],ax
 35849                                  fpfs_18:
 35850                                  	;/* Find largest free space, and verify the golden tracks while we are at it */
 35851                                  	;         do
 35852                                  	;            BEGIN
 35853                                  	;             temp = u(0);
 35854                                  	;
 35855                                  	;             /* Zip thru the table */
 35856                                  	;             for (i = c(0); i < c(5); i++)
 35857                                  	;                BEGIN
 35858                                  	;                 /* Is this one bigger ? */
 35859                                  	;                 if (free_space[i].space > temp)
 35860                                  	;                    BEGIN
 35861                                  	;                     temp = free_space[i].space;
 35862                                  	;                     last_found_partition = i;
 35863                                  	;                    END
 35864                                  	;                END
 35865                                  
 35866 000052A4 29C0                    		sub	ax,ax
 35867 000052A6 8946FA                  		mov	[fpfs_temp],ax ; 0
 35868 000052A9 8846F6                  		mov	[fpfs_i],al ; 0
 35869                                  fpfs_19:
 35870                                  		;mov	al,22
 35871 000052AC B00A                    		mov	al,10
 35872                                  		;imul	byte [fpfs_i]
 35873 000052AE F666F6                  		mul	byte [fpfs_i]
 35874 000052B1 89C3                    		mov	bx,ax
 35875                                  		; 17/01/2019
 35876                                  		;mov	ax,[fpfs_temp]
 35877                                  		;cmp	[free_space.space+bx],ax
 35878                                  		;jbe	short fpfs_20
 35879 000052B3 8B87[F0CB]              		mov	ax,[free_space.space+bx] 
 35880 000052B7 3B46FA                  		cmp	ax,[fpfs_temp]
 35881 000052BA 7609                    		jbe	short fpfs_20
 35882                                  		;mov	ax,[free_space.space+bx]
 35883 000052BC 8946FA                  		mov	[fpfs_temp],ax
 35884 000052BF 8A46F6                  		mov	al,[fpfs_i]
 35885 000052C2 8846F8                  		mov	[last_found_partition],al
 35886                                  fpfs_20:
 35887 000052C5 FE46F6                  		inc	byte [fpfs_i]
 35888                                  
 35889 000052C8 807EF605                		cmp	byte [fpfs_i],5
 35890 000052CC 72DE                    		jb	short fpfs_19
 35891                                  
 35892                                  		;/* If there is any free space, go verify it */
 35893                                  
 35894 000052CE C746FA0000              		mov	word [fpfs_temp],0
 35895                                  
 35896                                  		;mov	al,22
 35897                                  		;imul	byte [last_found_partition]
 35898 000052D3 B00A                    		mov	al,10
 35899 000052D5 F666F8                  		mul	byte [last_found_partition]
 35900 000052D8 89C3                    		mov	bx,ax
 35901                                  
 35902                                  	;if (free_space[last_found_partition].space != u(0))
 35903                                  	;   BEGIN
 35904                                  	;     /* Go verify the tracks */
 35905                                  	;    temp = verify_tracks(last_found_partition,c(PRIMARY));
 35906                                  	;  END
 35907 000052DA 83BF[F0CB]00            		cmp	word [free_space.space+bx],0
 35908 000052DF 740D                    		je	short fpfs_21
 35909                                  
 35910 000052E1 28C0                    		sub	al,al ; 0 ; type = PRIMARY
 35911 000052E3 50                      		push	ax
 35912 000052E4 8A46F8                  		mov	al,[last_found_partition] ; pointer
 35913 000052E7 50                      		push	ax
 35914 000052E8 E8FD07                  		call	verify_tracks
 35915                                  		;pop	bx
 35916                                  		;pop	bx
 35917 000052EB 8946FA                  		mov	[fpfs_temp],ax	; offset from original cylinder number
 35918                                  fpfs_21:
 35919                                  
 35920                                  ; /* Move up to next golden track */
 35921                                  ;free_space[last_found_partition].start = free_space[last_found_partition].start+temp;
 35922                                  ;free_space[last_found_partition].space = free_space[last_found_partition].space-temp;
 35923                                  ;free_space[last_found_partition].mbytes_unused =
 35924                                  ;        cylinders_to_mbytes(free_space[last_found_partition].space,cur_disk);
 35925                                  ;free_space[last_found_partition].percent_unused = (unsigned)
 35926                                  ;        cylinders_to_percent(free_space[last_found_partition].space,total_disk[cur_disk]);
 35927                                  
 35928                                  		;mov	al,22
 35929 000052EE B00A                    		mov	al,10
 35930                                  		;imul	byte [last_found_partition]
 35931 000052F0 F666F8                  		mul	byte [last_found_partition] 
 35932 000052F3 89C3                    		mov	bx,ax
 35933 000052F5 8B46FA                  		mov	ax,[fpfs_temp]
 35934 000052F8 0187[F2CB]              		add	[free_space.start+bx],ax
 35935                                  		;mov	cl,[cur_disk]
 35936                                  		;push	cx
 35937 000052FC 2987[F0CB]              		sub	[free_space.space+bx],ax
 35938                                  		;push	word [free_space.space+bx]
 35939 00005300 8B87[F0CB]              		mov	ax,[free_space.space+bx]
 35940 00005304 89DE                    		mov	si,bx ; *
 35941 00005306 8A1E[E2CB]              		mov	bl,[cur_disk]
 35942                                  		; bh = 0
 35943 0000530A E859C2                  		call	cylinders_to_mbytes
 35944                                  		;pop	bx
 35945                                  		;pop	bx
 35946 0000530D 8984[F6CB]              		mov	[free_space.mbytes_unused+si],ax ; *
 35947                                  		
 35948 00005311 A0[E2CB]                		mov	al,[cur_disk]
 35949 00005314 98                      		cbw
 35950 00005315 89C3                    		mov	bx,ax
 35951 00005317 D1E3                    		shl	bx,1
 35952                                  		;push	word [total_disk+bx]
 35953 00005319 8B8F[C6A0]              		mov	cx,[total_disk+bx]
 35954                                  		;push	word [free_space.space+si]
 35955 0000531D 8B9C[F0CB]              		mov	bx,[free_space.space+si] ; *
 35956 00005321 E895C2                  		call	cylinders_to_percent
 35957                                  		;pop	bx
 35958                                  		;pop	bx
 35959 00005324 8984[F8CB]              		mov	[free_space.percent_unused+si],ax ; *
 35960                                  
 35961                                  	;/* Repeat the loop if the start was moved due to bad tracks */
 35962                                  	;/* Unless we're past the end of the free space */
 35963                                  	; while ((temp != u(0)) && (free_space[last_found_partition].space != u(0))); 
 35964                                  
 35965 00005328 29C0                    		sub	ax,ax ; 17/01/2019
 35966                                  
 35967                                  		;cmp	word [fpfs_temp],0
 35968 0000532A 3946FA                  		cmp	[fpfs_temp],ax ; 0
 35969 0000532D 7409                    		je	short fpfs_22
 35970                                  
 35971                                  		;;mov	al,22
 35972                                  		;mov	al,10
 35973                                  		;;imul	byte [last_found_partition]
 35974                                  		;mul	byte [last_found_partition]
 35975                                  		;mov	bx,ax
 35976                                  		;cmp	word [free_space.space+bx],0
 35977                                  		;je	short fpfs_22
 35978                                  		;jmp	fpfs_18
 35979                                  
 35980                                  		; 17/01/2019
 35981                                  		;cmp	word [free_space.space+si],0 ; *
 35982 0000532F 3984[F0CB]              		cmp	[free_space.space+si],ax ; 0
 35983 00005333 7403                    		je	short short fpfs_22
 35984 00005335 E96CFF                  		jmp	fpfs_18
 35985                                  fpfs_22:
 35986                                  ;if((type == c(PRIMARY)) && (free_space[last_found_partition].mbytes_unused > u(MAX_PART_SIZE)))
 35987                                  
 35988                                  		;cmp	byte [fpfs_type],0 ; 0 for primary dos partition
 35989 00005338 3846F4                  		cmp	[fpfs_type],al ; 0
 35990 0000533B 7541                    		jne	short fpfs_23	   ; 5 for extended partition	
 35991                                  		
 35992                                  		; 17/01/2019
 35993                                  
 35994                                  		;;mov	al,22
 35995                                  		;mov	al,10
 35996                                  		;;imul	byte [last_found_partition]
 35997                                  		;mul	byte [last_found_partition]
 35998                                  		;mov	bx,ax
 35999                                  
 36000                                  	;/* Don't create a partition larger than DOS can handle */
 36001                                  
 36002                                  fefs_18: ; 20/01/2019
 36003                                  		;cmp	word [free_space.mbytes_unused+bx],2048 ; 2GB limit
 36004 0000533D 81BC[F6CB]0008          		cmp	word [free_space.mbytes_unused+si],2048 ; 17/01/2019
 36005 00005343 7639                    		jbe	short fpfs_23
 36006                                  
 36007 00005345 A0[E2CB]                		mov	al,[cur_disk]
 36008                                  		;xor	ah,ah ; ah = 0
 36009                                  		;mov	di,ax ; *
 36010                                  
 36011 00005348 50                      		push	ax ; * ; 19/01/2019
 36012                                  
 36013 00005349 50                      		push	ax
 36014 0000534A B80008                  		mov	ax,2048
 36015 0000534D 50                      		push	ax
 36016                                  		;mov	si,bx
 36017 0000534E E87803                  		call	mbytes_to_cylinders
 36018                                  		;pop	bx
 36019                                  		;pop	bx
 36020                                  
 36021 00005351 5F                      		pop	di ; * ; 20/01/2019
 36022                                  
 36023 00005352 48                      		dec	ax  ; max. available cylinders (for DOS partition)
 36024                                  
 36025 00005353 8984[F0CB]              		mov	[free_space.space+si],ax
 36026                                  		
 36027                                  		;mov	ax,[free_space.start+si]
 36028                                  		;add	ax,[free_space.space+si]
 36029                                  
 36030 00005357 0384[F2CB]              		add	ax,[free_space.start+si]
 36031                                   
 36032 0000535B 48                      		dec	ax
 36033 0000535C 8984[F4CB]              		mov	[free_space.end+si],ax
 36034                                  
 36035                                  		;mov	al,[cur_disk]
 36036                                  		;push	ax
 36037                                  		;push	word [free_space.space+si]
 36038 00005360 8B84[F0CB]              		mov	ax,[free_space.space+si]
 36039 00005364 89FB                    		mov	bx,di ; *
 36040 00005366 E8FDC1                  		call	cylinders_to_mbytes
 36041                                  		;pop	bx
 36042                                  		;pop	bx
 36043                                  
 36044 00005369 8984[F6CB]              		mov	[free_space.mbytes_unused+si],ax
 36045                                  
 36046                                  		;mov	al,[cur_disk]
 36047                                  		;cbw
 36048                                  		;mov	bx,ax
 36049                                  		;mov	bx,di ; *
 36050                                  		;shl	bl,1
 36051                                  		;;push	word [total_disk+bx]
 36052                                  		;mov	cx,[total_disk+bx]
 36053 0000536D D1E7                    		shl	di,1 ; *
 36054 0000536F 8B8D[C6A0]              		mov	cx,[total_disk+di] ; 20/01/2019 
 36055                                  		;push	word [free_space.space+si]
 36056 00005373 8B9C[F0CB]              		mov	bx,[free_space.space+si]
 36057 00005377 E83FC2                  		call	cylinders_to_percent
 36058                                  		;pop	bx
 36059                                  		;pop	bx
 36060 0000537A 8984[F8CB]              		mov	[free_space.percent_unused+si],ax
 36061                                  fpfs_23:
 36062                                  	; /* Return with the pointer to the largest free space */
 36063                                  
 36064 0000537E 8A46F8                  		mov	al,[last_found_partition] ; mov al,[bp-8]
 36065                                  
 36066                                  		;pop	si
 36067                                  		;pop	di
 36068                                  
 36069 00005381 89EC                    		mov	sp,bp
 36070 00005383 5D                      		pop	bp
 36071 00005384 C3                      		retn
 36072                                  
 36073                                  ; ----------------------------------------------------------------------------
 36074                                  ; input.c (FDISK, MSDOS 6.0, 1991)	
 36075                                  ; ----------------------------------------------------------------------------
 36076                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 17/01/2019)
 36077                                  
 36078                                  ;XFLOAT get_large_num_input(input_default,max_num,max_percent,input_message,prompt_location,error_message)
 36079                                  ;
 36080                                  ;unsigned    input_default;                                          /* AC000 */
 36081                                  ;unsigned    max_num;
 36082                                  ;unsigned    max_percent;
 36083                                  ;char far   *input_message;
 36084                                  ;char far   *error_message;
 36085                                  ;unsigned   prompt_location;
 36086                                  ;
 36087                                  ;BEGIN
 36088                                  ;
 36089                                  ;    char           input;
 36090                                  ;    XFLOAT         large_input;                                     /* AC000 */
 36091                                  ;    char           default_used;
 36092                                  ;    FLAG           enter_flag;                                       /*C12*/
 36093                                  ;
 36094                                  ;    /* Assume bad input */
 36095                                  ;    valid_input = FALSE;
 36096                                  ;
 36097                                  ;    /* Assume no input, and use default */
 36098                                  ;    default_used = TRUE;
 36099                                  ;
 36100                                  ;    /* Assume ENTER key not pressed yet */                           /*C12*/
 36101                                  ;    enter_flag = FALSE;                                              /*C12*/
 36102                                  ;
 36103                                  ;    /* Initialize the input value */
 36104                                  ;    large_input = u(0);                                             /* AC000 */
 36105                                  ;
 36106                                  ;    /* Loop until we get good stuff */
 36107                                  ;    while (valid_input == FALSE)
 36108                                  ;
 36109                                  ;        BEGIN
 36110                                  ;        /* position the cursor */
 36111                                  ;        VIOSETCURPOS(input_row,input_col,u(0));                     /* AC000 */
 36112                                  ;
 36113                                  ;        /* Flush the keyboard buffer and get the next pressed key */
 36114                                  ;
 36115                                  ;        input = get_char_input();
 36116                                  ;
 36117                                  ;        /* Go handle different inputs */
 36118                                  ;        switch(input)
 36119                                  ;            BEGIN
 36120                                  ;            case ESC:
 36121                                  ;                valid_input = TRUE;
 36122                                  ;                large_input = ((unsigned)(ESC_FLAG));
 36123                                  ;                break;
 36124                                  ;
 36125                                  ;            case CR:
 36126                                  ;                BEGIN
 36127                                  ;                if (PercentFlag)
 36128                                  ;                    BEGIN
 36129                                  ;                    /* Set the input to the default if there is one there and nothing else entered */
 36130                                  ;                    if ((input_default != u(NUL)) && (default_used))  /* AC000 */
 36131                                  ;                        large_input = input_default;
 36132                                  ;                    /* See if input is less or equal to max_value */
 36133                                  ;                    if (large_input <= max_percent)
 36134                                  ;                        BEGIN
 36135                                  ;                        if (large_input != u(0))
 36136                                  ;                            valid_input = TRUE;
 36137                                  ;                        else
 36138                                  ;                            display(error_28);
 36139                                  ;                        END
 36140                                  ;                    else
 36141                                  ;                        display(error_message);
 36142                                  ;                    END
 36143                                  ;                else
 36144                                  ;                    BEGIN
 36145                                  ;                    /* Set the input to the default if there is one there and nothing else entered */
 36146                                  ;                    if ((input_default != u(NUL)) && (default_used))  /* AC000 */
 36147                                  ;                        large_input = input_default;
 36148                                  ;                    /* See if input is less or equal to max_value */
 36149                                  ;                    if (large_input <= max_num)
 36150                                  ;                        BEGIN
 36151                                  ;                        if (large_input != u(0))
 36152                                  ;                            valid_input = TRUE;
 36153                                  ;                        else
 36154                                  ;                            display(error_28);
 36155                                  ;                        END
 36156                                  ;                    else
 36157                                  ;                        display(error_message);
 36158                                  ;                    END
 36159                                  ;                enter_flag = TRUE;                                      /*C12*/
 36160                                  ;                break;
 36161                                  ;                END
 36162                                  ;
 36163                                  ;            case BACKSPACE:
 36164                                  ;                if (PercentFlag)
 36165                                  ;                    PercentFlag = (FLAG)FALSE;                      /* AN000 */
 36166                                  ;                else
 36167                                  ;                    large_input = large_input / 10;
 36168                                  ;
 36169                                  ;                /* Indicate that we are not using the default */
 36170                                  ;                default_used = FALSE;
 36171                                  ;                sprintf(&insert[prompt_location],"%4.0d",large_input);  /* AN000 */
 36172                                  ;                display(input_message);
 36173                                  ;                break;
 36174                                  ;
 36175                                  ;            case PERCENT:                                           /* AN000 */
 36176                                  ;
 36177                                  ;                if (PercentFlag == (FLAG)FALSE)
 36178                                  ;                    BEGIN                                           /* AN000 */
 36179                                  ;                    PercentFlag = (FLAG)TRUE;                       /* AN000 */
 36180                                  ;                    /* Round down if > 999.9 */
 36181                                  ;                    if (large_input > u(999))                       /* AN000 */
 36182                                  ;                        large_input = (large_input%1000);           /* AN000 */
 36183                                  ;                    sprintf(&insert[prompt_location],"%3.0d%%",large_input);  /* AN000 */
 36184                                  ;                    /* Indicate that we are not using the default */
 36185                                  ;                    default_used = FALSE;                           /* AN000 */
 36186                                  ;                    display(input_message);                         /* AN000 */
 36187                                  ;                    END                                             /* AN000 */
 36188                                  ;                else
 36189                                  ;                    display(error_33);                              /* AN000 */
 36190                                  ;
 36191                                  ;                break;                                              /* AN000 */
 36192                                  ;
 36193                                  ;            case '0':                                                   /*C12*/
 36194                                  ;            case '1':                                                   /*C12*/
 36195                                  ;            case '2':                                                   /*C12*/
 36196                                  ;            case '3':                                                   /*C12*/
 36197                                  ;            case '4':                                                   /*C12*/
 36198                                  ;            case '5':                                                   /*C12*/
 36199                                  ;            case '6':                                                   /*C12*/
 36200                                  ;            case '7':                                                   /*C12*/
 36201                                  ;            case '8':                                                   /*C12*/
 36202                                  ;            case '9':                                                   /*C12*/
 36203                                  ;                if (enter_flag == TRUE)                                 /*C12*/
 36204                                  ;                    BEGIN                                               /*C12*/
 36205                                  ;                    large_input = u(0);                                 /*C12*/
 36206                                  ;                    default_used = FALSE;                               /*C12*/
 36207                                  ;                    PercentFlag = FALSE;                                /*C12*/
 36208                                  ;                    enter_flag = FALSE;                                 /*C12*/
 36209                                  ;                    END                                                 /*C12*/
 36210                                  ;                if ((PercentFlag == FALSE) && (large_input < 1000))     /*C12*/
 36211                                  ;                    BEGIN                                               /*C12*/
 36212                                  ;                    /* Add this digit in */                             /*C12*/
 36213                                  ;                    large_input = (large_input * 10) +                  /*C12*/
 36214                                  ;                                  (XFLOAT)(input - '0');                /*C12*/
 36215                                  ;                                                                        /*C12*/
 36216                                  ;                    /* Put it in the message */                         /*C12*/
 36217                                  ;                    number_in_msg((XFLOAT)large_input,prompt_location); /*C12*/
 36218                                  ;                    display(input_message);                             /*C12*/
 36219                                  ;                                                                        /*C12*/
 36220                                  ;                    /* Indicate that we are not using the default */    /*C12*/
 36221                                  ;                    default_used = FALSE;                               /*C12*/
 36222                                  ;                    PercentFlag = (FLAG)FALSE;                          /*C12*/
 36223                                  ;                    END                                                 /*C12*/
 36224                                  ;                else                                                    /*C12*/
 36225                                  ;                    display(error_33);                                  /*C12*/
 36226                                  ;                break;                                                  /*C12*/
 36227                                  ;                                                                        /*C12*/
 36228                                  ;            default:                                                    /*C12*/
 36229                                  ;                if ((PercentFlag == FALSE) && (large_input < 1000))     /*C12*/
 36230                                  ;                    BEGIN                                               /*C12*/
 36231                                  ;                    /* Setup error message */                           /*C12*/
 36232                                  ;                    insert[0] = c('0');                                 /*C12*/
 36233                                  ;                    insert[1] = c('-');                                 /*C12*/
 36234                                  ;                    insert[2] = c('9');                                 /*C12*/
 36235                                  ;                    display(error_31);                                  /*C12*/
 36236                                  ;                    END                                                 /*C12*/
 36237                                  ;                else                                                    /*C12*/
 36238                                  ;                    display(error_33);                                  /*C12*/
 36239                                  ;            END
 36240                                  ;        END
 36241                                  ;
 36242                                  ;    return(large_input);
 36243                                  ;END
 36244                                  
 36245                                  get_large_num_input:
 36246                                  		; 17/01/2019
 36247                                  
 36248                                  	%define large_input	   bp-8
 36249                                  	%define glni_enter_flag	   bp-6
 36250                                  	%define glni_def_used	   bp-4
 36251                                  	%define glni_input	   bp-2
 36252                                  	%define glni_input_def	   bp+4
 36253                                  	%define glni_max_num	   bp+6
 36254                                  	%define glni_max_pc	   bp+8
 36255                                  	%define glni_input_msg	   bp+10
 36256                                  	%define glni_input_msg_seg bp+12
 36257                                  	%define glni_prompt_loc	   bp+14
 36258                                  	%define glni_err_msg	   bp+16
 36259                                  	%define glni_err_msg_seg   bp+18
 36260                                  
 36261 00005385 55                      		push	bp
 36262 00005386 89E5                    		mov	bp,sp
 36263 00005388 83EC08                  		sub	sp,8
 36264                                  		
 36265                                  		;/* Assume no input, and use default */
 36266 0000538B C646FC01                		mov	byte [glni_def_used],1 ; default_used = TRUE;
 36267                                  
 36268 0000538F 28C0                    		sub	al,al ; 0
 36269                                  
 36270                                  		;/* Assume bad input */
 36271 00005391 A2[ECCB]                		mov	[valid_input],al ; valid_input = FALSE;
 36272                                  
 36273                                  		;/* Assume ENTER key not pressed yet */  
 36274 00005394 8846FA                  		mov	[glni_enter_flag],al  ; enter_flag = FALSE;   
 36275                                  
 36276                                  		;/* Initialize the input value */
 36277 00005397 C746F80000              		mov	word [large_input],0 ; large_input = u(0);      
 36278 0000539C E99E01                  		jmp	glni_29
 36279                                  glni_1:
 36280                                  		;/* Loop until we get good stuff */
 36281                                  		;while (valid_input == FALSE)
 36282                                  
 36283                                  		;/* position the cursor */
 36284                                  		
 36285                                  		;push	word [input_row]
 36286                                  		;push	word [input_col]
 36287                                  		;sub	ax,ax
 36288                                  		;push	ax
 36289 0000539F 8A36[4CA1]              		mov	dh,[input_row]
 36290 000053A3 8A16[AAA0]              		mov	dl,[input_col]
 36291 000053A7 E876D8                  		call	VIOSETCURPOS
 36292                                  
 36293                                  	;/* Flush the keyboard buffer and get the next pressed key */
 36294                                  
 36295 000053AA E866D8                  		call	get_char_input  ; input = get_char_input();
 36296 000053AD 8846FE                  		mov	[glni_input],al
 36297                                  
 36298                                  	; /* Go handle different inputs */
 36299                                  		 ; switch(input)
 36300                                  switch_input12:
 36301                                  		;cbw
 36302                                  		;sub	ax,8
 36303 000053B0 2C08                    		sub	al,8  ; 08h (8)  - BACKSPACE key
 36304 000053B2 7503                    		jnz	short glni_3
 36305 000053B4 E9B400                  		jmp	case_gln_backspace
 36306                                  glni_3:
 36307                                  		;sub	ax,5  ; 0Dh (13) - ENTER/CR key
 36308 000053B7 2C05                    		sub	al,5
 36309 000053B9 744B                    		jz	short case_gln_CR
 36310                                  		;sub	ax,14 ; 1Bh (27) - ESC key
 36311 000053BB 2C0E                    		sub	al,14
 36312 000053BD 743A                    		jz	short case_gln_ESC
 36313                                  		;sub	ax,10 ; 25h (37) - '%' character/key
 36314 000053BF 2C0A                    		sub	al,10
 36315 000053C1 7503                    		jnz	short glni_4
 36316 000053C3 E9DA00                  		jmp	case_gln_percent
 36317                                  glni_4:
 36318                                  		;sub	ax,11 ; 30h (48) - '0' character/key
 36319 000053C6 2C0B                    		sub	al,11 
 36320 000053C8 7207                    		jb	short case_gln_default
 36321                                  		;sub	ax,9  ; 39h (57) - '9' character/key
 36322 000053CA 2C09                    		sub	al,9
 36323 000053CC 7703                    		ja	short case_gln_default
 36324 000053CE E91201                  		jmp	case_gln_dec_digits ; one of decimal digits
 36325                                  case_gln_default:
 36326                                  		; default:
 36327                                  	;if ((PercentFlag == FALSE) && (large_input < 1000))  
 36328 000053D1 803E[E0C3]00                		cmp	byte [PercentFlag],0
 36329 000053D6 7507                    		jne	short glni_6
 36330 000053D8 817EF8E803              		cmp	word [large_input], 1000
 36331 000053DD 7203                    		jb	short glni_7
 36332                                  glni_6:
 36333 000053DF E95301                  		jmp	glni_27  ; else 
 36334                                  				 ;       display(error_33); 
 36335                                  glni_7:
 36336                                  		;/* Setup error message */
 36337                                  		;insert[0] = c('0');
 36338                                       		;insert[1] = c('-');
 36339                                                  ;insert[2] = c('9');       
 36340                                  		;display(error_31);   
 36341 000053E2 C606[F4CC]30            		mov	byte [insert],'0'
 36342 000053E7 C606[F5CC]2D            		mov	byte [insert+1],'-'
 36343 000053EC C606[F6CC]39            		mov	byte [insert+2],'9'
 36344                                  		;push	word [error_31_seg]
 36345 000053F1 1E                      		push	ds
 36346 000053F2 FF36[BC9E]              		push	word [error_31_off]
 36347 000053F6 E94101                  		jmp	glni_28
 36348                                  case_gln_ESC:
 36349                                  		;case ESC:
 36350 000053F9 C606[ECCB]01            		mov	byte [valid_input],1  ; valid_input = TRUE;
 36351                                  		;large_input = ((unsigned)(ESC_FLAG));
 36352 000053FE C746F8FEFF              		mov	word [large_input],0FFFEh
 36353 00005403 E93701                  		jmp	glni_29  ; break;
 36354                                  case_gln_CR:
 36355 00005406 803E[E0C3]00            		cmp	byte [PercentFlag],0  ; if (PercentFlag)
 36356 0000540B 7437                    		je	short glni_15
 36357                                  	;/* Set the input to the default if there is one there and nothing else entered */
 36358                                  	;if ((input_default != u(NUL)) && (default_used)) 
 36359 0000540D 837E0400                		cmp	word [glni_input_def],0
 36360 00005411 740C                    		je	short glini_10
 36361 00005413 807EFC00                		cmp	byte [glni_def_used],0
 36362 00005417 7406                    		je	short glini_10
 36363 00005419 8B4604                  		mov	ax,[glni_input_def]
 36364 0000541C 8946F8                  		mov	[large_input],ax  ; large_input = input_default;
 36365                                  glini_10:
 36366                                  		;if (large_input <= max_percent)
 36367 0000541F 8B4608                  		mov	ax,[glni_max_pc]
 36368 00005422 3946F8                  		cmp	[large_input],ax
 36369 00005425 770D                    		ja	short glni_12 ; display(error_message);
 36370                                  		;if (large_input != u(0))
 36371 00005427 837EF800                		cmp	word [large_input],0
 36372 0000542B 7437                    		je	short glni_17  ; display(error_28);
 36373                                  glni_11:
 36374 0000542D C606[ECCB]01            		mov	byte [valid_input],1  ; valid_input = TRUE;
 36375 00005432 EB09                    		jmp	short glni_14
 36376                                  glni_12:
 36377                                  		;display(error_message);
 36378 00005434 FF7612                  		push	word [glni_err_msg_seg]
 36379 00005437 FF7610                  		push	word [glni_err_msg]
 36380                                  glni_13:
 36381 0000543A E8E7C1                  		call	display
 36382                                  		;pop	bx
 36383                                  		;pop	bx
 36384                                  glni_14:
 36385 0000543D C646FA01                		mov	byte [glni_enter_flag],1  ; enter_flag = TRUE;
 36386 00005441 E9F900                  		jmp	glni_29  ; break;
 36387                                  glni_15:
 36388                                  		; else
 36389                                   	;/* Set the input to the default if there is one there and nothing else entered */
 36390                                  	;if ((input_default != u(NUL)) && (default_used))
 36391 00005444 837E0400                		cmp	word [glni_input_def],0
 36392 00005448 740C                    		je	short glni_16
 36393 0000544A 807EFC00                		cmp	byte [glni_def_used],0
 36394 0000544E 7406                    		je	short glni_16
 36395 00005450 8B4604                  		mov	ax,[glni_input_def]
 36396 00005453 8946F8                  		mov	[large_input],ax ;  large_input = input_default;
 36397                                  glni_16:
 36398                                  		;/* See if input is less or equal to max_value */
 36399                                  		;if (large_input <= max_num)
 36400 00005456 8B4606                  		mov	ax,[glni_max_num]
 36401 00005459 3946F8                  		cmp	[large_input],ax
 36402 0000545C 77D6                    		ja	short glni_12
 36403                                  		;if (large_input != u(0))
 36404 0000545E 837EF800                		cmp	word [large_input],0
 36405 00005462 75C9                    		jne	short glni_11
 36406                                  glni_17:
 36407                                  		;display(error_28);
 36408                                  		;push	word [error_28_seg]
 36409 00005464 1E                      		push	ds
 36410 00005465 FF36[B69E]              		push	word [error_28_off]
 36411 00005469 EBCF                    		jmp	short glni_13
 36412                                  case_gln_backspace:
 36413                                  		;case BACKSPACE:
 36414 0000546B 803E[E0C3]00            		cmp	byte [PercentFlag],0
 36415 00005470 7407                    		je	short glni_19
 36416 00005472 C606[E0C3]00            		mov	byte [PercentFlag],0  ; PercentFlag = (FLAG)FALSE;   
 36417 00005477 EB0D                    		jmp	short glni_20
 36418                                  glni_19:
 36419                                  		;large_input = large_input / 10;
 36420 00005479 B90A00                  		mov	cx,10
 36421 0000547C 8B46F8                  		mov	ax,[large_input]
 36422 0000547F 29D2                    		sub	dx,dx
 36423 00005481 F7F1                    		div	cx
 36424 00005483 8946F8                  		mov	[large_input],ax
 36425                                  glni_20:
 36426                                  		;/* Indicate that we are not using the default */
 36427 00005486 C646FC00                		mov	byte [glni_def_used],0 ; default_used = FALSE;
 36428                                  
 36429                                  	;sprintf(&insert[prompt_location],"%4.1d",large_input);
 36430                                  
 36431 0000548A FF76F8                  		push	word [large_input]
 36432 0000548D B8[926F]                		mov	ax,glni_num_format ; "%4.1d"
 36433 00005490 50                      		push	ax
 36434 00005491 8B460E                  		mov	ax,[glni_prompt_loc]
 36435 00005494 05[F4CC]                		add	ax,insert
 36436 00005497 50                      		push	ax
 36437 00005498 E82ACE                  		call	sprintf
 36438 0000549B 83C406                  		add	sp,6
 36439 0000549E EB3B                    		jmp	short glni_24
 36440                                  case_gln_percent:
 36441                                  		;case PERCENT:    
 36442 000054A0 803E[E0C3]00            		cmp	byte [PercentFlag],0
 36443 000054A5 7403                    		je	short glni_22
 36444 000054A7 E98B00                  		jmp	glni_27
 36445                                  glni_22:
 36446 000054AA C606[E0C3]01            		mov	byte [PercentFlag],1  ; PercentFlag = (FLAG)TRUE;   
 36447                                  		;/* Round down if > 999.9 */
 36448 000054AF 817EF8E703              		cmp	word [large_input],999
 36449 000054B4 760D                    		jbe	short glni_23
 36450 000054B6 B9E803                  		mov	cx,1000
 36451 000054B9 8B46F8                  		mov	ax,[large_input]
 36452 000054BC 29D2                    		sub	dx,dx
 36453 000054BE F7F1                    		div	cx
 36454 000054C0 8956F8                  		mov	[large_input],dx
 36455                                  glni_23:
 36456 000054C3 FF76F8                  		push	word [large_input]
 36457 000054C6 B8[A56F]                		mov	ax,percent_format ; "%3.1d%%"
 36458 000054C9 50                      		push	ax
 36459 000054CA 8B460E                  		mov	ax,[glni_prompt_loc]
 36460 000054CD 05[F4CC]                		add	ax,insert
 36461 000054D0 50                      		push	ax
 36462 000054D1 E8F1CD                  		call	sprintf
 36463 000054D4 83C406                  		add	sp,6
 36464                                  		;/* Indicate that we are not using the default */
 36465 000054D7 C646FC00                		mov	byte [glni_def_used],0 ; default_used = FALSE;
 36466                                  glni_24:
 36467                                  		; display(input_message);
 36468 000054DB FF760C                  		push	word [glni_input_msg_seg]
 36469 000054DE FF760A                  		push	word [glni_input_msg]
 36470 000054E1 EB57                    		jmp	short glni_28
 36471                                  case_gln_dec_digits:
 36472                                  		;case '0': 
 36473                                  		;...
 36474                                              	;case '9':  
 36475                                  		;if (enter_flag == TRUE) 
 36476 000054E3 807EFA01                		cmp	byte [glni_enter_flag],1
 36477 000054E7 7510                    		jne	short glni_26
 36478 000054E9 29C0                    		sub	ax,ax
 36479                                  		;mov	word [large_input],0  ; large_input = u(0);
 36480 000054EB 8946F8                  		mov	[large_input],ax ; 0
 36481                                  		;sub	al,al
 36482 000054EE 8846FC                  		mov	[glni_def_used],al ; default_used = FALSE; 
 36483 000054F1 A2[E0C3]                		mov	[PercentFlag],al ; PercentFlag = FALSE
 36484 000054F4 8846FA                  		mov	[glni_enter_flag],al ; enter_flag = FALSE; 
 36485 000054F7 EB0E                    		jmp	short glni_31  ; 17/01/2019
 36486                                  glni_26:
 36487                                  		;if ((PercentFlag == FALSE) && (large_input < 1000))  
 36488 000054F9 803E[E0C3]00            		cmp	byte [PercentFlag],0
 36489 000054FE 7535                    		jne	short glni_27
 36490 00005500 817EF8E803              		cmp	word [large_input],1000
 36491 00005505 732E                    		jnb	short glni_27
 36492                                  glni_31:
 36493                                  		;/* Add this digit in */ 
 36494                                  		
 36495                                  	;large_input = (large_input * 10) + (XFLOAT)(input - '0');  
 36496                                  
 36497                                  	; /* Put it in the message */
 36498                                          ;    number_in_msg((XFLOAT)large_input,prompt_location)
 36499                                  
 36500 00005507 FF760E                  		push	word [glni_prompt_loc] ; numinmsg_start, start address 
 36501 0000550A 8A46FE                  		mov	al,[glni_input]
 36502 0000550D 98                      		cbw
 36503 0000550E 89C1                    		mov	cx,ax
 36504 00005510 B80A00                  		mov	ax,10
 36505 00005513 F766F8                  		mul	word [large_input]
 36506 00005516 01C8                    		add	ax,cx
 36507 00005518 83E830                  		sub	ax,'0'
 36508 0000551B 8946F8                  		mov	[large_input],ax
 36509 0000551E 50                      		push	ax	; numinmsg_num, number
 36510 0000551F E8D9DA                  		call	number_in_msg
 36511                                  		;pop	bx
 36512                                  		;pop	bx
 36513                                  		
 36514                                  		;display(input_message);  
 36515 00005522 FF760C                  		push	word [glni_input_msg_seg]
 36516 00005525 FF760A                  		push	word [glni_input_msg]
 36517 00005528 E8F9C0                  		call	display
 36518                                  		;pop	bx
 36519                                  		;pop	bx
 36520                                  		
 36521                                  		;/* Indicate that we are not using the default */
 36522 0000552B 28C0                    		sub	al,al ; 0
 36523 0000552D 8846FC                  		mov	[glni_def_used],al  ; default_used = FALSE; 
 36524 00005530 A2[E0C3]                		mov	[PercentFlag],al ; PercentFlag = (FLAG)FALSE;   
 36525 00005533 EB08                    		jmp	short glni_29
 36526                                  glni_27:
 36527                                  		;display(error_33); 
 36528                                  		;push	word [error_33_seg]
 36529 00005535 1E                      		push	ds
 36530 00005536 FF36[C09E]              		push	word [error_33_off]
 36531                                  glni_28:
 36532 0000553A E8E7C0                  		call	display
 36533                                  		;pop	bx
 36534                                  		;pop	bx
 36535                                  glni_29:
 36536                                  		;/* Loop until we get good stuff */
 36537                                      		;while (valid_input == FALSE)
 36538 0000553D 803E[ECCB]00            		cmp	byte [valid_input],0
 36539 00005542 7503                    		jne	short glni_30
 36540 00005544 E958FE                  		jmp	glni_1
 36541                                  glni_30:
 36542                                  		;return(large_input);
 36543 00005547 8B46F8                  		mov	ax,[large_input]
 36544                                  		
 36545 0000554A 89EC                    		mov	sp,bp
 36546 0000554C 5D                      		pop	bp
 36547                                  		;retn
 36548 0000554D C21000                  		retn	16
 36549                                  
 36550                                  ; ----------------------------------------------------------------------------
 36551                                  ; makepart.c (FDISK, MSDOS 6.0, 1991)	
 36552                                  ; ----------------------------------------------------------------------------
 36553                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 19/01/2019)
 36554                                  
 36555                                  ;void make_partition(size,free_pointer,bootable,type)
 36556                                  ;
 36557                                  ;unsigned        size;
 36558                                  ;char            free_pointer;
 36559                                  ;unsigned char   bootable;
 36560                                  ;char            type;
 36561                                  ;
 36562                                  ;BEGIN
 36563                                  ;
 36564                                  ;    char table_pointer;
 36565                                  ;    unsigned i;
 36566                                  ;    unsigned char   temp;
 36567                                  ;    unsigned long   total_sectors;
 36568                                  ;
 36569                                  ;    /* Find a free spot to put it in */
 36570                                  ;    table_pointer = find_free_partition();
 36571                                  ;
 36572                                  ;    if (table_pointer != ((char)(NOT_FOUND)))
 36573                                  ;        BEGIN
 36574                                  ;        /* found a free partition, now lets go fill it up */
 36575                                  ;
 36576                                  ;        /* Do we need to make it active? */
 36577                                  ;        if (bootable == ((unsigned char)(ACTIVE)))
 36578                                  ;            BEGIN
 36579                                  ;
 36580                                  ;            /* Go clear out a previously active one */
 36581                                  ;            for (i=u(0); i <u(4); i++) 			/* AC000 */
 36582                                  ;                BEGIN
 36583                                  ;                if (part_table[cur_disk][i].boot_ind == uc(0x80))	/* AC000 */
 36584                                  ;                    BEGIN
 36585                                  ;                    part_table[cur_disk][i].changed = TRUE;
 36586                                  ;                    part_table[cur_disk][i].boot_ind = uc(0);	/* AC000 */
 36587                                  ;                    END
 36588                                  ;                END
 36589                                  ;
 36590                                  ;                /* Now mark the new one active */
 36591                                  ;                part_table[cur_disk][table_pointer].boot_ind = uc(0x80); /* AC000 */
 36592                                  ;            END
 36593                                  ;        else
 36594                                  ;            BEGIN
 36595                                  ;            /* Mark it as not active, leaving the others alone */
 36596                                  ;            part_table[cur_disk][table_pointer].boot_ind = uc(0);	/* AC000 */
 36597                                  ;            END
 36598                                  ;
 36599                                  ;            /* Go get the start cylinder */
 36600                                  ;            part_table[cur_disk][table_pointer].start_cyl = free_space[free_pointer].start;
 36601                                  ;
 36602                                  ;            /* Setup end cylinder */
 36603                                  ;            part_table[cur_disk][table_pointer].end_cyl = part_table[cur_disk][table_pointer].start_cyl + size - 1;
 36604                                  ;
 36605                                  ;            /* Start sector is always 1 */
 36606                                  ;            part_table[cur_disk][table_pointer].start_sector = uc(1);	/* AC000 */
 36607                                  ;
 36608                                  ;            /* End sector is always the last sector */
 36609                                  ;            part_table[cur_disk][table_pointer].end_sector = max_sector[cur_disk];
 36610                                  ;
 36611                                  ;            /* End head is always the last head */
 36612                                  ;            part_table[cur_disk][table_pointer].end_head = uc(max_head[cur_disk] -1); /* AC004 */
 36613                                  ;
 36614                                  ;            /* Start head is always 0 unless this is track 0 - then it is 1 */
 36615                                  ;            temp = uc(0);						/* AC000 */
 36616                                  ;            if (part_table[cur_disk][table_pointer].start_cyl == u(0))	/* AC000 */
 36617                                  ;                BEGIN
 36618                                  ;                temp = uc(1);						/* AC000 */
 36619                                  ;                END
 36620                                  ;            part_table[cur_disk][table_pointer].start_head = temp;
 36621                                  ;
 36622                                  ;            /* Figure out the total number of sectors */
 36623                                  ;            /* Total sectors in partition =                    */
 36624                                  ;            /* [(end_cyl - start_cyl)*(max_sector)*(max_head)] */
 36625                                  ;            /* - [start_head * max_sector]                     */
 36626                                  ;            /* Note: This is assuming a track or cylinder aligned partition */
 36627                                  ;
 36628                                  ;            /* First - get the total size in Cylinders assuming head 0 start*/
 36629                                  ;            total_sectors = ((unsigned long)(part_table[cur_disk][table_pointer].end_cyl -
 36630                                  ;                             part_table[cur_disk][table_pointer].start_cyl+1));
 36631                                  ;
 36632                                  ;            /* Now multiply it by the number of sectors and heads per track */
 36633                                  ;            total_sectors = total_sectors * max_sector[cur_disk] * max_head[cur_disk];
 36634                                  ;
 36635                                  ;            /* This will give us the total of sectors if it is cyl aligned */
 36636                                  ;            /* Now, if it isn't aligned on head 0, we need to subtract off */
 36637                                  ;            /* the skipped tracks in the first cylinder  */
 36638                                  ;
 36639                                  ;            /* Because the head is zero based, we can get the total number of */
 36640                                  ;            /* skipped sectors by multipling the head number by sectors per track */
 36641                                  ;            total_sectors = total_sectors - ((unsigned long)part_table[cur_disk][table_pointer].start_head) *
 36642                                  ;                             max_sector[cur_disk];
 36643                                  ;            part_table[cur_disk][table_pointer].num_sec = total_sectors;
 36644                                  ;
 36645                                  ;            /* Get the relative sector */
 36646                                  ;            /* Figure out the total number of sectors	*/
 36647                                  ;            /* Total sectors before partition =  	*/
 36648                                  ;            /* (start_cyl)*(max_sector)*(max_head)]	*/
 36649                                  ;            /* + [start_head * max_sector]		*/
 36650                                  ;            /* Note: This is assuming a track or cylinder aligned partition */
 36651                                  ;
 36652                                  ;            /* Start cyl will work because it is zero based */
 36653                                  ;            total_sectors = ((unsigned long)part_table[cur_disk][table_pointer].start_cyl);
 36654                                  ;
 36655                                  ;            /* Get sectors up to head 0 of the partition */
 36656                                  ;            total_sectors = total_sectors * max_sector[cur_disk] * max_head[cur_disk];
 36657                                  ;
 36658                                  ;            /* Because the head is zero based, we can get the total number of */
 36659                                  ;            /* skipped sectors by multipling the head number by sectors per track */
 36660                                  ;            total_sectors = total_sectors + ((unsigned long)part_table[cur_disk][table_pointer].start_head) *
 36661                                  ;                              max_sector[cur_disk];
 36662                                  ;            /* Save it! */
 36663                                  ;            part_table[cur_disk][table_pointer].rel_sec = total_sectors;
 36664                                  ;
 36665                                  ;            /* Setup the system id byte */
 36666                                  ;            if (type == ((char)(EXTENDED)))
 36667                                  ;                BEGIN
 36668                                  ;                temp = uc(EXTENDED);					/* AC000 */
 36669                                  ;                END
 36670                                  ;            else
 36671                                  ;                BEGIN
 36672                                  ;                if (type == ((char)(PRIMARY)))
 36673                                  ;                    BEGIN
 36674                                  ;                    /* Always set to 06h - let format worry about setting to correct value */
 36675                                  ;                    /* SR; 9/30/89; We fix up the size ourselves here. The
 36676                                  ;                       calculation is simple. If total_sectors > 65536 then
 36677                                  ;                       type = 06 else if total_sectors > 32680 then type = 04
 36678                                  ;                       else type = 01 */
 36679                                  ;
 36680                                  ;                    /* SR; 9/30/89; Calculate total_sectors from start
 36681                                  ;                       including the hidden sectors */
 36682                                  ;
 36683                                  ;                    total_sectors += part_table[cur_disk][table_pointer].num_sec;
 36684                                  ;
 36685                                  ;                    if ( (total_sectors >> 16) > 0 )
 36686                                  ;                        temp = uc(DOSNEW); /* Partition extends beyond the 32M boundary */
 36687                                  ;                    else if (part_table[cur_disk][table_pointer].num_sec > ul( FAT16_SIZE ))
 36688                                  ;                        temp = uc(DOS16);
 36689                                  ;                    else
 36690                                  ;                        temp = uc(DOS12);				/* AC000 */
 36691                                  ;                    END
 36692                                  ;                else
 36693                                  ;                    BEGIN
 36694                                  ;                    internal_program_error();
 36695                                  ;                    END
 36696                                  ;                END
 36697                                  ;
 36698                                  ;            /* We got the sys id, now put it in */
 36699                                  ;            part_table[cur_disk][table_pointer].sys_id = temp;
 36700                                  ;
 36701                                  ;            /* Set the changed flag */
 36702                                  ;            part_table[cur_disk][table_pointer].changed = TRUE;
 36703                                  ;
 36704                                  ;            /* Set the mbytes used */
 36705                                  ;            part_table[cur_disk][table_pointer].mbytes_used =
 36706                                  ;                cylinders_to_mbytes(size,cur_disk);			- /* AN004 */
 36707                                  ;
 36708                                  ;            /* Set the percent used */
 36709                                  ;            part_table[cur_disk][table_pointer].percent_used =
 36710                                  ;                cylinders_to_percent(((part_table[cur_disk][table_pointer].end_cyl-part_table[cur_disk][table_pointer].start_cyl)+1),
 36711                                  ;                total_disk[cur_disk]);                                  /* AN000 */
 36712                                  ;
 36713                                  ;            /* set the system to unknown and volume label to blanks */  /*C21*/
 36714                                  ;            strcpy(part_table[cur_disk][table_pointer].system,NOFORMAT); /*C21*/
 36715                                  ;            strcpy(part_table[cur_disk][table_pointer].vol_label,NOVOLUME); /*C21*/
 36716                                  ;        END
 36717                                  ;    else
 36718                                  ;        BEGIN
 36719                                  ;        /* This should not have happened */
 36720                                  ;        internal_program_error();
 36721                                  ;        return;
 36722                                  ;        END
 36723                                  ;
 36724                                  ;    return;
 36725                                  ;END
 36726                                  
 36727                                  make_partition:
 36728                                  		; 19/01/2019
 36729                                  
 36730                                  	;%define mp_temp4_lw	    bp-26
 36731                                  	;%define mp_temp4_hw	    bp-24
 36732                                  	;%define mp_temp3_lw	    bp-22
 36733                                  	;%define mp_temp3_hw	    bp-20
 36734                                  	;%define mp_temp2_lw	    bp-18
 36735                                  	;%define mp_temp2_hw	    bp-16
 36736                                  	;%define mp_temp1_lw	    bp-14
 36737                                  	;%define mp_temp1_hw	    bp-12
 36738                                  	
 36739                                  	%define mp_i		    bp-10
 36740                                  	%define mp_table_ptr	    bp-8
 36741                                  	%define mp_temp		    bp-6
 36742                                  	%define mp_total_sectors_lw bp-4
 36743                                  	%define mp_total_sectors_hw bp-2
 36744                                  
 36745                                  	%define mp_size		    bp+4
 36746                                  	%define mp_free_ptr	    bp+6
 36747                                  	%define mp_bootable	    bp+8
 36748                                  	%define mp_type		    bp+10
 36749                                  
 36750 00005550 55                      		push	bp
 36751 00005551 89E5                    		mov	bp,sp
 36752                                  		;sub	sp,26
 36753 00005553 83EC0A                  		sub	sp,10 ; 19/01/2019
 36754                                  		
 36755                                  		;push	di
 36756                                  		;push	si
 36757                                  
 36758                                  		;/* Find a free spot to put it in */
 36759 00005556 E8D501                  		call	find_free_partition
 36760 00005559 8846F8                  		mov	[mp_table_ptr],al
 36761                                  		;if (table_pointer != ((char)(NOT_FOUND)))
 36762 0000555C FEC0                    		inc	al
 36763 0000555E 7503                    		jnz	short mp_1 
 36764 00005560 E96101                  		jmp	mp_13
 36765                                  mp_1:
 36766                                  		;/* found a free partition, now lets go fill it up */
 36767                                  
 36768 00005563 B92E00                  		mov	cx,46 ; *- ; 19/01/2019
 36769                                  
 36770                                  		;/* Do we need to make it active? */
 36771 00005566 807E0880                		cmp	byte [mp_bootable],80h
 36772 0000556A 752E                    		jne	short mp_4
 36773                                  		
 36774                                  		;/* Go clear out a previously active one */
 36775 0000556C C646F600                		mov	byte [mp_i],0
 36776                                  mp_2:
 36777 00005570 A0[E2CB]                		mov	al,[cur_disk]
 36778                                  		;cbw
 36779                                  		;shl	ax,1
 36780                                  		;shl	ax,1
 36781                                  		;add	ax,[mp_i]
 36782 00005573 D0E0                    		shl	al,1
 36783 00005575 D0E0                    		shl	al,1
 36784 00005577 0246F6                  		add	al,[mp_i]
 36785                                  		
 36786                                  		;mov	cx,46
 36787                                  		;mul	cx
 36788                                  		;mov	cl,46
 36789 0000557A F6E1                    		mul	cl
 36790 0000557C 89C3                    		mov	bx,ax
 36791                                  
 36792 0000557E 80BF[20C4]80            		cmp	byte [part_table_boot_ind+bx],80h
 36793 00005583 750A                    		jne	short mp_3
 36794                                  		;part_table[cur_disk][i].changed = TRUE;
 36795 00005585 C687[33C4]01            		mov	byte [part_table_changed+bx],1
 36796 0000558A C687[20C4]00            		mov	byte [part_table_boot_ind+bx],0
 36797                                  mp_3:
 36798 0000558F FE46F6                  		inc	byte [mp_i]
 36799 00005592 807EF604                		cmp	byte [mp_i],4
 36800 00005596 72D8                    		jb	short mp_2
 36801                                  
 36802                                  		;/* Now mark the new one active */
 36803                                  		;part_table[cur_disk][table_pointer].boot_ind = uc(0x80);
 36804                                  
 36805                                  		;mov	al,[cur_disk]
 36806                                  		;;cbw
 36807                                  		;;shl	ax, 1
 36808                                  		;;shl	ax, 1
 36809                                  		;;mov	cx, ax
 36810                                  		;;mov	al,[mp_table_ptr]
 36811                                  		;;cbw
 36812                                  		;;add	ax,cx
 36813                                  		;shl	al,1
 36814                                  		;shl	al,1
 36815                                  		;add	al,[mp_table_ptr]
 36816                                  		;;mov	cx,46
 36817                                  		;;imul	cx
 36818                                  		;;mov	cl,46
 36819                                  		;mul	cl
 36820                                  		;mov	bx,ax
 36821                                  		;mov	[part_table_boot_ind+bx],80h
 36822                                  		;jmp	short mp_5,
 36823                                  
 36824 00005598 B580                    		mov	ch,80h ; *- ; 19/01/2019
 36825                                  mp_4:
 36826                                  		;/* Mark it as not active, leaving the others alone */
 36827 0000559A A0[E2CB]                		mov	al,[cur_disk]
 36828                                  		;cbw
 36829                                  		;shl	ax,1
 36830                                  		;shl	ax,1
 36831                                  		;mov	cx,ax
 36832                                  		;mov	al,[mp_table_ptr]
 36833                                  		;cbw
 36834                                  		;add	ax,cx
 36835                                  		;mov	cx,46
 36836                                  		;imul	cx
 36837                                  
 36838 0000559D D0E0                    		shl	al,1
 36839 0000559F D0E0                    		shl	al,1
 36840 000055A1 0246F8                  		add	al,[mp_table_ptr]
 36841                                  		;mov	cl,46
 36842 000055A4 F6E1                    		mul	cl
 36843 000055A6 89C3                    		mov	bx,ax
 36844                                  
 36845                                  		;mov	byte [part_table_boot_ind+bx],0
 36846 000055A8 88AF[20C4]              		mov	[part_table_boot_ind+bx],ch ; *- ; 19/01/2019
 36847                                  mp_5:
 36848                                  		;/* Go get the start cylinder */
 36849 000055AC B016                    		mov	al,22
 36850                                  		;imul	byte [mp_free_ptr]
 36851 000055AE F66606                  		mul	byte [mp_free_ptr]
 36852 000055B1 89C3                    		mov	bx,ax
 36853                                  		;mov	ax,[free_space.start+bx]
 36854                                  		;mov	cx,ax
 36855 000055B3 8B8F[F2CB]              		mov	cx,[free_space.start+bx]
 36856 000055B7 A0[E2CB]                		mov	al,[cur_disk]
 36857                                  		;cbw
 36858                                  		;ah = 0
 36859                                  		;mov	dx,ax ; *-**
 36860 000055BA 89C6                    		mov	si,ax ; **-	
 36861                                  		;shl	ax,1
 36862                                  		;shl	ax,1
 36863 000055BC D0E0                    		shl	al,1
 36864 000055BE D0E0                    		shl	al,1
 36865                                  		;mov	bx,ax
 36866                                  		;mov	al,[mp_table_ptr]
 36867                                  		;cbw
 36868                                  		;add	ax,bx
 36869 000055C0 0246F8                  		add	al,[mp_table_ptr]
 36870                                  		;mov	bx,46
 36871 000055C3 B32E                    		mov	bl,46
 36872                                  		;mov	si,dx ; *-**
 36873                                  		;imul	bx
 36874 000055C5 F6E3                    		mul	bl
 36875 000055C7 89C3                    		mov	bx,ax
 36876 000055C9 898F[23C4]              		mov	[part_table_start_cyl+bx],cx
 36877                                  		;/* Setup end cylinder */
 36878                                  		;part_table[cur_disk][table_pointer].end_cyl =
 36879 000055CD 034E04                  		add	cx,[mp_size]
 36880 000055D0 49                      		dec	cx  ; part_table[cur_disk][table_pointer].start_cyl + size - 1
 36881 000055D1 898F[28C4]              		mov	[part_table_end_cyl+bx],cx
 36882                                  		;/* Start sector is always 1 */
 36883 000055D5 C687[22C4]01            		mov	byte [part_table_start_sector+bx],1
 36884                                  		;/* End sector is always the last sector */
 36885 000055DA 8A84[AEA0]              		mov	al,[max_sector+si] ; **-
 36886 000055DE 8887[27C4]              		mov	[part_table_end_sector+bx],al
 36887                                  		;/* End head is always the last head */
 36888 000055E2 D1E6                    		shl	si,1  ;**-
 36889 000055E4 8A84[B6A0]              		mov	al,[max_head+si] ; **-
 36890 000055E8 FEC8                    		dec	al
 36891 000055EA 8887[26C4]              		mov	[part_table_end_head+bx],al
 36892                                  		;/* Start head is always 0 unless this is track 0 - then it is 1 */
 36893                                  		;mov	byte [mp_temp],0 ; temp = uc(0);         
 36894 000055EE 29D2                    		sub	dx,dx ; 0
 36895                                  		;cmp	word [part_table_start_cyl+bx],0
 36896 000055F0 3997[23C4]              		cmp	[part_table_start_cyl+bx],dx ; 0
 36897 000055F4 7502                    		jne	short mp_6
 36898                                  		;mov	byte [mp_temp],1 ; temp = uc(1);     
 36899 000055F6 FEC2                    		inc	dl  ; dl = 1 = [mp_temp]
 36900                                  mp_6:
 36901                                  		;mov	al,[cur_disk]
 36902                                  		;cbw
 36903                                  		;mov	cx,ax
 36904                                  		;shl	ax,1
 36905                                  		;shl	ax,1
 36906                                  		;mov	dx,ax
 36907                                  		;mov	al,[mp_table_ptr]
 36908                                  		;cbw
 36909                                  		;add	ax,dx
 36910                                  		;mov	bx,46
 36911                                  		;imul	bx
 36912                                  		;mov	bx,ax
 36913                                  		;mov	al,[mp_temp]
 36914                                  
 36915                                  		; part_table[cur_disk][table_pointer].start_head = temp;
 36916                                  		;mov	[part_table_start_head+bx],al ; 0 or 1
 36917 000055F8 8897[21C4]              		mov	[part_table_start_head+bx],dl ; 0 or 1
 36918                                  
 36919                                  		;/* Figure out the total number of sectors */
 36920                                              	;/* Total sectors in partition =                    */
 36921                                              	;/* [(end_cyl - start_cyl)*(max_sector)*(max_head)] */
 36922                                              	;/* - [start_head * max_sector]                     */
 36923                                              	;/* Note: This is assuming a track or cylinder aligned partition */
 36924                                  
 36925                                  		; dl = 0 or 1
 36926                                  		; dh = 0
 36927                                  
 36928 000055FC 28E4                    		sub	ah,ah ; 0
 36929                                  
 36930                                  		; AX = start head (0 or 1)
 36931                                  
 36932                                  		;sub	dx,dx ; 0
 36933                                  
 36934                                  		;push	dx	; multiplier_hw = 0
 36935                                  		;push	ax	; multiplier_lw  (0 or 1)
 36936                                  		;;mov	si,cx
 36937                                  		;shr	si,1 ; **-
 36938                                  		;mov	al,[max_sector+si] ; **-
 36939                                  		;push	dx	; multiplicand_hw
 36940                                  		;push	ax	; multiplicand_lw
 36941                                  		;mov	di,ax
 36942                                  		;mov	[mp_temp1_lw],di ; max_sector lw
 36943                                  		;mov	[mp_temp1_hw],dx ; max_sector hw
 36944                                  		;mov	di,bx
 36945                                  		;call	mul32
 36946                                  		;	; dx:ax = [start_head * max_sector] 
 36947                                  
 36948                                  		; **** modification by Erdogan Tan
 36949                                  
 36950 000055FE D1EE                    		shr	si,1
 36951 00005600 8A84[AEA0]              		mov	al,[max_sector+si]
 36952                                  
 36953 00005604 08D2                    		or	dl,dl ; dh = 0 , dl = start head (0 or 1)
 36954 00005606 7402                    		jz	short mp_15
 36955                                  
 36956 00005608 88C2                    		mov	dl,al	
 36957                                  mp_15:
 36958 0000560A 8956FA                  		mov	[mp_temp],dx ; **** ; 19/01/2019
 36959                                  	
 36960                                  		; ****
 36961                                  
 36962                                  		;push	word [mp_temp1_hw] ; multiplier_hw
 36963                                  		;push	word [mp_temp1_lw] ; multiplier_lw
 36964                                  		
 36965 0000560D D1E6                    		shl	si,1
 36966 0000560F 8B8C[B6A0]              		mov	cx,[max_head+si]
 36967                                  		;sub	bx,bx
 36968                                  		;push	bx  ; multiplicand_hw	
 36969                                  		;push	cx  ; multiplicand_lw
 36970                                  			; dx:ax = [start_head * max_sector] 	
 36971                                  		;mov	si,ax
 36972                                  		;mov	[mp_temp2_lw],si
 36973                                  		;mov	[mp_temp2_hw],dx
 36974                                  		;call	mul32
 36975                                  		;	; dx:ax = (max_sector)*(max_head)
 36976                                  
 36977                                  		; **** modification by Erdogan Tan ; 19/01/2019
 36978                                  
 36979                                  		; ax = max_sector (ah = 0)
 36980                                  		; cx = max_head   
 36981                                  
 36982 00005613 F7E1                    		mul	cx
 36983                                  			; dx:ax = (max_sector)*(max_head)
 36984                                  		; ****
 36985                                  
 36986 00005615 52                      		push	dx  ; multiplier_hw
 36987 00005616 50                      		push	ax  ; multiplier_lw	
 36988                                  
 36989                                  	;/* First - get the total size in Cylinders assuming head 0 start*/
 36990                                  	;total_sectors = ((unsigned long)(part_table[cur_disk][table_pointer].end_cyl -
 36991                                          ;                    part_table[cur_disk][table_pointer].start_cyl+1));
 36992                                  
 36993                                  		;mov	cx,[part_table_end_cyl+di]
 36994 00005617 8B8F[28C4]              		mov	cx,[part_table_end_cyl+bx] ; ****
 36995                                  		;sub	cx,[part_table_start_cyl+di]
 36996 0000561B 2B8F[23C4]              		sub	cx,[part_table_start_cyl+bx] ; ****
 36997 0000561F 41                      		inc	cx
 36998                                  			; cx = (end_cyl - start_cyl) + 1
 36999                                  
 37000                                  	;/* Now multiply it by the number of sectors and heads per track */
 37001                                  	;total_sectors = total_sectors * max_sector[cur_disk] * max_head[cur_disk];
 37002                                  
 37003                                  		;sub	bx,bx ; 0
 37004                                  		;push	bx 	; multiplicand_hw = 0	
 37005                                  		;push	cx	; multiplicand_lw
 37006                                  		;	; dx:ax = (max_sector)*(max_head)
 37007                                  		;	; (dx = 0)
 37008                                  		;mov	si,ax
 37009                                  		;mov	[mp_temp3_lw],si
 37010                                  		;mov	[mp_temp3_hw],dx
 37011                                  		;call	mul32
 37012                                  		;	; dx:ax = ((end_cyl - start_cyl) + 1) * (max_sector)*(max_head)
 37013                                  		;	; dx:ax = cylinders * (sectors per track * heads)
 37014                                  		;	; dx:ax = (cylinders*heads) * sectors per track
 37015                                  
 37016                                  		
 37017                                  		; **** modification by Erdogan Tan ; 19/01/2019
 37018                                  
 37019                                  		; ax = (max_sector)*(max_head) ; <= 16065 (max_head <= 255, max_sector <= 63)
 37020                                  		; dx = 0
 37021                                  		; cx = (end_cyl - start_cyl) + 1 = cylinders 
 37022                                  
 37023 00005620 89C7                    		mov	di,ax ; ***** (max_sector)*(max_head) 
 37024                                  
 37025 00005622 F7E1                    		mul	cx
 37026                                  			; dx:ax = (cylinders*heads) * sectors per track
 37027                                  
 37028                                  		; ****
 37029                                  
 37030                                  	;/* This will give us the total of sectors if it is cyl aligned */
 37031                                  	;/* Now, if it isn't aligned on head 0, we need to subtract off */
 37032                                  	;/* the skipped tracks in the first cylinder  */
 37033                                  
 37034                                  	;/* Because the head is zero based, we can get the total number of */
 37035                                  	;/* skipped sectors by multipling the head number by sectors per track */
 37036                                  	;total_sectors = 
 37037                                  	;	total_sectors - ((unsigned long)part_table[cur_disk][table_pointer].start_head) *
 37038                                  	;                       max_sector[cur_disk];
 37039                                  
 37040                                  		;sub	ax,[mp_temp2_lw] ; total_sectors = 
 37041                                  		;sbb	dx,[mp_temp2_hw] ; 	total_sectors - [start_head * max_sector] 
 37042                                  
 37043                                  		; **** modification by Erdogan Tan ; 19/01/2019
 37044                                  
 37045 00005624 8B4EFA                  		mov	cx,[mp_temp] ; **** ; [start_head * max_sector] = 0 or max_sector
 37046 00005627 E305                    		jcxz	mp_16
 37047                                  
 37048 00005629 29C8                    		sub	ax,cx ; cx = max_sector
 37049 0000562B 83DA00                  		sbb	dx,0
 37050                                  	
 37051                                  		; ****
 37052                                  mp_16:		
 37053                                  	;part_table[cur_disk][table_pointer].num_sec = total_sectors;	
 37054                                  
 37055                                  		;mov	[part_table_num_sec_lw+di],ax
 37056                                  		;mov	[part_table_num_sec_hw+di],dx
 37057                                  
 37058 0000562E 8987[2EC4]              		mov	[part_table_num_sec_lw+bx],ax ; ****
 37059 00005632 8997[30C4]              		mov	[part_table_num_sec_hw+bx],dx ; ****
 37060                                  
 37061                                  		;/* Get the relative sector */
 37062                                              	;/* Figure out the total number of sectors */
 37063                                              	;/* Total sectors before partition =       */
 37064                                  		;/* (start_cyl)*(max_sector)*(max_head)    */
 37065                                  		;/* + [start_head * max_sector]            */
 37066                                  		;/* Note: This is assuming a track or cylinder aligned partition */
 37067                                  
 37068                                  		;push	word [mp_temp1_hw]
 37069                                  		;push	word [mp_temp1_lw]
 37070                                  		;mov	al,[part_table_start_head+di]
 37071                                  		;sub	ah,ah
 37072                                  		;sub	dx,dx
 37073                                  		;push	dx
 37074                                  		;push	ax
 37075                                  		;call	mul32
 37076                                  		;	 ; dx:ax = [start_head * max_sector]  
 37077                                  
 37078                                  	;/* Start cyl will work because it is zero based */
 37079                                  	;total_sectors = ((unsigned long)part_table[cur_disk][table_pointer].start_cyl);
 37080                                  
 37081                                  	;/* Get sectors up to head 0 of the partition */
 37082                                          ;total_sectors = total_sectors * max_sector[cur_disk] * max_head[cur_disk];
 37083                                  
 37084                                  		;mov	cx,[part_table_start_cyl+di]
 37085                                  		;sub	bx,bx
 37086                                  		;push	bx
 37087                                  		;push	cx
 37088                                  		;push	word [mp_temp3_hw] ; (max_sector)*(max_head)
 37089                                  		;push	word [mp_temp3_lw]
 37090                                  		;mov	si, ax
 37091                                  		;mov	[mp_temp4_lw],si ; [start_head * max_sector]
 37092                                  		;mov	[mp_temp4_hw],dx
 37093                                  		;call	mul32
 37094                                  		;add	ax,[mp_temp4_lw] 
 37095                                  		;adc	dx,[mp_temp4_hw]
 37096                                  			
 37097                                  		; **** modification by Erdogan Tan ; 19/01/2019
 37098                                  
 37099                                  		; cx = (start_head * max_sector) = max_sector or cx = 0
 37100                                  		; di = (max_sector * max_head) 
 37101                                  
 37102 00005636 8B87[23C4]              		mov	ax,[part_table_start_cyl+bx]
 37103 0000563A F7E7                    		mul	di ; *****
 37104                                  			; dx:ax = part_table[cur_disk][table_pointer].start_cyl *
 37105                                  			;	  max_sector[cur_disk] * max_head[cur_disk]
 37106                                  
 37107 0000563C 01C8                    		add	ax,cx
 37108 0000563E 83D200                  		adc	dx,0
 37109                                  			; dx:ax =  Total sectors before partition = 
 37110                                  			;	   (start_cyl)*(max_sector * max_head)
 37111                                  			;	   + (start_head * max_sector)
 37112                                  
 37113                                  		; ****		  
 37114                                  
 37115                                  	;/* Because the head is zero based, we can get the total number of */
 37116                                  	;/* skipped sectors by multipling the head number by sectors per track */
 37117                                  	;total_sectors = 
 37118                                  	;	total_sectors + ((unsigned long)part_table[cur_disk][table_pointer].start_head) *
 37119                                  	;		max_sector[cur_disk];
 37120                                  
 37121 00005641 8946FC                  		mov	[mp_total_sectors_lw],ax  ; -**-
 37122 00005644 8956FE                  		mov	[mp_total_sectors_hw],dx  ; -**-	
 37123                                  
 37124                                  		;* Save it! */
 37125                                  		;part_table[cur_disk][table_pointer].rel_sec = total_sectors;
 37126                                  
 37127                                  		;mov	[part_table_rel_sec_lw+di],ax
 37128                                  		;mov	[part_table_rel_sec_hw+di],dx
 37129                                  
 37130 00005647 8987[2AC4]              		mov	[part_table_rel_sec_lw+bx],ax
 37131 0000564B 8997[2CC4]              		mov	[part_table_rel_sec_hw+bx],dx
 37132                                  
 37133                                  		;/* Setup the system id byte */
 37134                                  
 37135 0000564F 807E0A05                		cmp	byte [mp_type],5 ; EXTENDED
 37136 00005653 7504                    		jne	short mp_7
 37137                                  		;mov	byte [mp_temp],5
 37138 00005655 B005                    		mov	al,5 ; EXTENDED
 37139 00005657 EB1C                    		jmp	short mp_12
 37140                                  mp_7:
 37141                                  		;NOTE: If [mp_type] <> 5, it is 0 (there is not another possibility)
 37142                                  		
 37143                                  		;cmp	byte [mp_type],0 ; PRIMARY
 37144                                  		;jne	short mp_11  ; not possible !
 37145                                  		
 37146                                  		;mov	al,[cur_disk]
 37147                                  		;;cbw
 37148                                  		;;shl	ax,1
 37149                                  		;;shl	ax,1
 37150                                  		;;mov	cx,ax
 37151                                  		;;mov	al,[mp_table_ptr]
 37152                                  		;;cbw
 37153                                  		;;add	ax,cx
 37154                                  		;shl	al,1
 37155                                  		;shl	al,1
 37156                                  		;add	al,[mp_table_ptr]
 37157                                  		;;mov	cx,46
 37158                                  		;;imul	cx
 37159                                  		;mov	cl,46
 37160                                  		;mul	cl
 37161                                  		;mov	bx,ax
 37162                                  
 37163                                  	;/* Always set to 06h - let format worry about setting to correct value */
 37164                                          ;/* SR; 9/30/89; We fix up the size ourselves here. The
 37165                                          ;	calculation is simple. If total_sectors > 65536 then
 37166                                          ;	type = 06 else if total_sectors > 32680 then type = 04
 37167                                          ;       else type = 01 */
 37168                                  
 37169                                          ;/* SR; 9/30/89; Calculate total_sectors from start
 37170                                          ; including the hidden sectors */
 37171                                  
 37172                                  	; total_sectors += part_table[cur_disk][table_pointer].num_sec;
 37173                                  
 37174                                  		;mov	ax,[part_table_num_sec_lw+bx]
 37175                                  		;mov	dx,[part_table_num_sec_hw+bx]
 37176                                  		;add	[mp_total_sectors_lw],ax
 37177                                  		;adc	[mp_total_sectors_hw],dx
 37178                                  
 37179                                  		; ax = [mp_total_sectors_lw] ; -**-
 37180                                  		; dx = [mp_total_sectors_hw] ; -**-
 37181                                  
 37182 00005659 0387[2EC4]              		add	ax,[part_table_num_sec_lw+bx]  ; -**-
 37183 0000565D 1397[30C4]              		adc	dx,[part_table_num_sec_hw+bx]  ; -**-	
 37184                                  		
 37185                                  	; if ( (total_sectors >> 16) > 0 )
 37186 00005661 7404                    		jz	short mp_8 ; [mp_total_sectors_hw] = 0
 37187                                  	; temp = uc(DOSNEW); /* Partition extends beyond the 32M boundary */
 37188                                  		;mov	byte [mp_temp],6
 37189 00005663 B006                    		mov	al,6 ; DOSNEW
 37190 00005665 EB0E                    		jmp	short mp_12
 37191                                  ;mp_8:
 37192                                  		;mov	al,[cur_disk]
 37193                                  		;cbw
 37194                                  		;shl	ax,1
 37195                                  		;shl	ax,1
 37196                                  		;mov	cx,ax
 37197                                  		;mov	al,[mp_table_ptr]
 37198                                  		;cbw
 37199                                  		;add	ax,cx
 37200                                  		;mov	cx,46
 37201                                  		;imul	cx
 37202                                  		;mov	bx,ax
 37203                                  		
 37204                                  		;cmp	word [part_table_num_sec_hw+bx],0
 37205                                  		;jne	short mp_9
 37206                                  mp_8:
 37207                                  	;if (part_table[cur_disk][table_pointer].num_sec > ul( FAT16_SIZE ))
 37208                                  
 37209 00005667 81BF[2EC4]A87F          		cmp	word [part_table_num_sec_lw+bx],32680 ; FAT16_SIZE = 32680
 37210 0000566D 7604                    		jbe	short mp_10 ;  if sectors <= 32680, it must be a FAT12 file system 
 37211                                  mp_9:
 37212                                  		;mov	byte [mp_temp],4 ; temp = uc(DOS16);
 37213 0000566F B004                    		mov	al,4
 37214 00005671 EB02                    		jmp	short mp_12
 37215                                  ;mp_11:
 37216                                  ;		call	internal_program_error
 37217                                  ;		jmp	short mp_12
 37218                                  mp_10:
 37219                                  		;mov	byte [mp_temp],1 ; temp = uc(DOS12); 
 37220 00005673 B001                    		mov	al,1
 37221                                  ;;		jmp	short mp_12
 37222                                  ;;mp_11:
 37223                                  ;;		call	internal_program_error
 37224                                  mp_12:
 37225                                  		;mov	al,[mp_table_ptr]
 37226                                  		;cbw
 37227                                  		;mov	cx,ax
 37228                                  		;mov	al,[cur_disk]
 37229                                  		;cbw
 37230                                  		;shl	ax,1
 37231                                  		;shl	ax,1
 37232                                  		;add	ax,cx
 37233                                  		;mov	bx,46
 37234                                  		;imul	bx
 37235                                  		;mov	si,ax
 37236                                  
 37237                                  		; /* We got the sys id, now put it in */
 37238                                              	;part_table[cur_disk][table_pointer].sys_id = temp;
 37239                                  
 37240                                  		;mov	al,[mp_temp]
 37241                                  
 37242                                  		;mov	[part_table_sys_id+si],al
 37243                                  		;mov	byte [part_table_changed+si],1
 37244 00005675 8887[25C4]              		mov	[part_table_sys_id+bx],al ; al = [mp_temp]
 37245                                  
 37246                                  		;/* Set the changed flag */
 37247                                              	;part_table[cur_disk][table_pointer].changed = TRUE;
 37248                                  
 37249 00005679 C687[33C4]01            		mov	byte [part_table_changed+bx],1
 37250                                  		
 37251 0000567E 89DE                    		mov	si,bx ; *
 37252                                  
 37253                                  		;mov	al,[cur_disk]
 37254                                  		;push	ax
 37255 00005680 8A1E[E2CB]              		mov	bl,[cur_disk]
 37256 00005684 30FF                    		xor	bh,bh
 37257 00005686 89DF                    		mov	di,bx ; **
 37258                                  
 37259                                  		;/* Set the mbytes used */
 37260                                  
 37261                                  		;push	word [mp_size]
 37262 00005688 8B4604                  		mov	ax,[mp_size]
 37263                                  		;mov	di,cx
 37264 0000568B E8D8BE                  		call	cylinders_to_mbytes
 37265                                  		;pop	bx
 37266                                  		;pop	bx
 37267 0000568E 8984[34C4]              		mov	[part_table_mbytes_used+si],ax  ; *
 37268                                  		
 37269                                  		;mov	al,[cur_disk]
 37270                                  		;cbw
 37271                                  		;mov	bx,ax
 37272                                  		;;shl	bx,1
 37273                                  		;shl	bl,1
 37274                                  		;push	word [total_disk+bx]
 37275                                  		
 37276                                  		;;shl	ax,1
 37277                                  		;;shl	ax,1
 37278                                  		;shl	al,1
 37279                                  		;shl	al,1
 37280                                  		;;add	ax,di
 37281                                  		;add	al,[mp_table_ptr]
 37282                                  		;;mov	cx,46
 37283                                  		;;imul	cx
 37284                                  		;mov	cl,46
 37285                                  		;mul	cl
 37286                                  		;mov	bx,ax
 37287                                  		
 37288                                  		;mov	ax,[part_table_end_cyl+bx]
 37289                                  		;sub	ax,[part_table_start_cyl+bx]
 37290                                  		;inc	ax
 37291                                  		;push	ax
 37292                                  
 37293                                  		;mov	si,bx
 37294                                  
 37295                                  		;/* Set the percent used */
 37296                                  
 37297 00005692 D1E7                    		shl	di,1 ; **
 37298 00005694 8B8D[C6A0]              		mov	cx,[total_disk+di] ; **
 37299                                  			; cx = total cylinders (of the disk)
 37300 00005698 8B9C[28C4]              		mov	bx,[part_table_end_cyl+si]
 37301 0000569C 2B9C[23C4]              		sub	bx,[part_table_start_cyl+si]		
 37302 000056A0 43                      		inc	bx
 37303                                  			; bx = number of cylinders (of the partition)
 37304 000056A1 E815BF                  		call	cylinders_to_percent
 37305                                  		;pop	bx
 37306                                  		;pop	bx
 37307 000056A4 8984[36C4]              		mov	[part_table_percent_used+si],ax ; percent (<=100)
 37308                                  
 37309                                  	;/* set the system to unknown and volume label to blanks */
 37310                                          ;strcpy(part_table[cur_disk][table_pointer].system,NOFORMAT)
 37311                                          ;strcpy(part_table[cur_disk][table_pointer].vol_label,NOVOLUME)
 37312                                  
 37313                                  		;mov	ax,NO_FORMAT ; "UNKNOWN	"
 37314                                  		;push	ax
 37315 000056A8 A0[E2CB]                		mov	al,[cur_disk]
 37316                                  		;cbw
 37317                                  		;shl	ax,1
 37318                                  		;shl	ax,1
 37319                                  		;add	ax,di
 37320                                  		;mov	cx,46
 37321                                  		;imul	cx
 37322                                  		;add	ax,part_table_system
 37323                                  		;push	ax
 37324                                  		;call	strcpy
 37325                                  		;pop	bx
 37326                                  		;pop	bx
 37327                                  
 37328 000056AB 89F3                    		mov	bx,si
 37329 000056AD BE[5370]                		mov	si,NO_FORMAT
 37330 000056B0 89DF                    		mov	di,bx
 37331 000056B2 81C7[44C4]              		add	di,part_table_system
 37332 000056B6 E874C6                  		call	strcpy
 37333                                  		
 37334                                  
 37335                                  		;mov	ax,NO_VOLUME
 37336                                  		;push	ax
 37337                                  		;mov	al,[cur_disk]
 37338                                  		;cbw
 37339                                  		;shl	ax,1
 37340                                  		;shl	ax,1
 37341                                  		;add	ax,di
 37342                                  		;mov	cx,46
 37343                                  		;imul	cx
 37344                                  		;add	ax,part_table_vol_label
 37345                                  		;push	ax
 37346                                  		;call	strcpy
 37347                                  		;pop	bx
 37348                                  		;pop	bx
 37349                                  
 37350                                  		;mov	si,NO_VOLUME ; [NO_VOLUME] = 0
 37351                                  		;mov	di,bx
 37352                                  		;add	di,part_table_vol_label
 37353                                  		;call	strcpy
 37354 000056B9 C687[38C4]00            		mov	byte [part_table_vol_label+bx],0 ; NOVOLUME
 37355                                  
 37356                                  		;jmp	short mp_14
 37357                                  ;mp_13:
 37358                                  ;		call	internal_program_error
 37359                                  mp_14:
 37360                                  		;pop	si
 37361                                  		;pop	di
 37362                                  
 37363 000056BE 89EC                    		mov	sp,bp
 37364 000056C0 5D                      		pop	bp
 37365                                  		;retn
 37366 000056C1 C20800                  		retn	8
 37367                                  mp_13:
 37368 000056C4 E854DC                  		call	internal_program_error
 37369 000056C7 EBF5                    		jmp	short mp_14
 37370                                  
 37371                                  ; ----------------------------------------------------------------------------
 37372                                  ; convert.c (FDISK, MSDOS 6.0, 1991)	
 37373                                  ; ----------------------------------------------------------------------------
 37374                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 19/01/2019)
 37375                                  
 37376                                  ;/***************************************************************************/
 37377                                  ;/*Routine name:  MBYTES_TO_CYLINDERS                                       */
 37378                                  ;/***************************************************************************/
 37379                                  ;/*                                                                         */
 37380                                  ;/*Description:   This routine will take input of MBtes and                 */
 37381                                  ;/*               convert it to cylinders rounding up to the next largest   */
 37382                                  ;/*               cylinder boundry.  Rounding up is done to make sure the   */
 37383                                  ;/*               requester is getting at least what he asked for to the    */
 37384                                  ;/*               next cylinder boundry.                                    */
 37385                                  ;/*                                                                         */
 37386                                  ;/*Called Procedures:    none                                               */
 37387                                  ;/*                                                                         */
 37388                                  ;/*                                                                         */
 37389                                  ;/*Change History: Created	5/30/87	DRM                                 */
 37390                                  ;/*                                                                         */
 37391                                  ;/*Input: Input                                                             */
 37392                                  ;/*                                                                         */
 37393                                  ;/*Output: Cylinders_out                                                    */
 37394                                  ;/*                                                                         */
 37395                                  ;/***************************************************************************/
 37396                                  
 37397                                  ;unsigned mbytes_to_cylinders(mbytes_in,which_disk)
 37398                                  ;
 37399                                  ;XFLOAT	mbytes_in;
 37400                                  ;char	which_disk;
 37401                                  ;
 37402                                  ;BEGIN
 37403                                  ;
 37404                                  ;unsigned	cylinders_out;
 37405                                  ;unsigned long	cylinders_out1;
 37406                                  ;unsigned long	number_of_sectors;
 37407                                  ;unsigned long	number_of_tracks;
 37408                                  ;unsigned long	divide_by;
 37409                                  ;
 37410                                  ;      /* If trying to create a 3.30 compatible 32 MB partition */
 37411                                  ;      /* Set the 32mb limit - round down                       */
 37412                                  ;      if (mbytes_in == (XFLOAT)32)
 37413                                  ;          BEGIN
 37414                                  ;          cylinders_out1 = ul(DOS_MAX);
 37415                                  ;          divide_by = ul((max_head[which_disk]) * ul(max_sector[which_disk]));
 37416                                  ;          cylinders_out = u(cylinders_out1 / divide_by);
 37417                                  ;          END
 37418                                  ;      else
 37419                                  ;          BEGIN
 37420                                  ;	   /* SR; 9/26/89; Long calculation incorrect */
 37421                                  ;	   number_of_sectors = ((ul(mbytes_in) * ul(ONE_MEG))/BYTES_PER_SECTOR);
 37422                                  ;
 37423                                  ;          /* SR; 9/26/89; Incorrect cast to int. Actually this modulo is */
 37424                                  ;          /* always 0 because ONE_MEG mod BYTES_PER_SECTOR = 0 */
 37425                                  ;	   if (((mbytes_in * ONE_MEG) % BYTES_PER_SECTOR) != (int)0)
 37426                                  ;	       number_of_sectors++;
 37427                                  ;	       number_of_tracks = ul((number_of_sectors / max_sector[which_disk]));
 37428                                  ;
 37429                                  ;          /* SR; 9/26/89; Changed int cast to unsigned */
 37430                                  ;	   if (((unsigned)number_of_sectors % max_sector[which_disk]) != 0)
 37431                                  ;	       number_of_tracks++;
 37432                                  ;	       cylinders_out = u((number_of_tracks / max_head[which_disk]));
 37433                                  ;
 37434                                  ;	   /* SR; 9/26/89; Changed int cast to unsigned */
 37435                                  ;	   if (((unsigned)number_of_tracks % max_head[which_disk]) != 0)
 37436                                  ;	       cylinders_out++;
 37437                                  ;          END
 37438                                  ;
 37439                                  ;      return(cylinders_out);
 37440                                  ;END
 37441                                  
 37442                                  mbytes_to_cylinders:
 37443                                  		; 19/01/2019
 37444                                  
 37445                                  	;%define mtc_num_sectors_lw bp-18
 37446                                  	;%define mtc_num_sectors_hw bp-16
 37447                                  	;%define mtc_cylinders_out  bp-6
 37448                                  	;%define mtc_num_tracks_lw  bp-4
 37449                                  	;%define mtc_num_tracks_hw  bp-2
 37450                                  	
 37451                                  	%define mtc_mbytes_in	bp+4
 37452                                  	%define mtc_which_disk	bp+6
 37453                                  
 37454 000056C9 55                      		push	bp
 37455 000056CA 89E5                    		mov	bp,sp
 37456                                  
 37457                                  		;sub	sp,18
 37458                                  		
 37459                                  		;push	di
 37460                                  		;push	si
 37461                                  
 37462                                  	;/* If trying to create a 3.30 compatible 32 MB partition */
 37463                                  	;/* Set the 32mb limit - round down  
 37464                                  		
 37465 000056CC 8A4606                  		mov	al,[mtc_which_disk]
 37466 000056CF 98                      		cbw	; ah = 0
 37467 000056D0 89C3                    		mov	bx,ax
 37468 000056D2 8A87[AEA0]              		mov	al,[max_sector+bx]
 37469 000056D6 89C6                    		mov	si,ax ; *+* ; 19/01/2019
 37470 000056D8 D0E3                    		shl	bl,1
 37471 000056DA 8BBF[B6A0]              		mov	di,[max_head+bx] ; *++* ; 19/01/2019
 37472                                  
 37473 000056DE 8B4604                  		mov	ax,[mtc_mbytes_in] ; 19/01/2019
 37474                                  
 37475                                  		;cmp	word [mtc_mbytes_in],32
 37476 000056E1 83F820                  		cmp	ax,32
 37477 000056E4 750C                    		jne	short mbtocyl_1
 37478                                  
 37479                                  		;mov	al,[mtc_which_disk]
 37480                                  		;cbw
 37481                                  		;mov	bx,ax
 37482                                  		;mov	al,[max_sector+bx]
 37483                                  		;;sub	ah,ah
 37484                                  		;mov	si,ax ; *+* ; 19/01/2019
 37485                                  		
 37486                                  		;;shl	bx,1
 37487                                  		;shl	bl,1
 37488                                  		;mul	word [max_head+bx]
 37489                                  
 37490 000056E6 F7E7                    		mul	di ; *++* ; 19/01/2019
 37491                                  
 37492                                  		;push	dx  ; divisor hw = 0
 37493                                  		;push	ax  ; divisor lw <= 16065 (255*63)
 37494 000056E8 89C1                    		mov	cx,ax ; 19/01/2019
 37495 000056EA B8FFFF                  		mov	ax,0FFFFh ; 65535 sectors
 37496                                  		;sub	dx,dx ; dx = 0
 37497                                  		;push	dx ; dividend hw
 37498                                  		;push	ax ; dividend lw
 37499                                  			; dx:ax = dividend (32 bit)
 37500                                  			; cx = divisor (16 bit)
 37501 000056ED E826BF                  		call	div32
 37502                                  			; dx:ax = quotient
 37503                                  			; bx = remainder
 37504 000056F0 EB28                    		jmp	short mbtocyl_4
 37505                                  mbtocyl_1:
 37506                                  	;number_of_sectors = ((ul(mbytes_in) * ul(ONE_MEG))/BYTES_PER_SECTOR);
 37507 000056F2 B104                    		mov	cl,4
 37508                                  		;mov	ax,[mtc_mbytes_in]
 37509 000056F4 29D2                    		sub	dx,dx
 37510                                  		;mov	bx,ax
 37511                                  		;mov	si,dx
 37512 000056F6 D3E0                    		shl	ax,cl ; 16
 37513 000056F8 89C2                    		mov	dx,ax ; 16*65536
 37514 000056FA 29C0                    		sub	ax,ax
 37515 000056FC B109                    		mov	cl,9  ; bytes / 512
 37516                                  		;mov	di,bx
 37517 000056FE E80CBF                  		call	shr32
 37518                                  			; dx:ax = sectors
 37519                                  		;mov	[mtc_num_sectors_lw],ax
 37520                                  		;mov	[mtc_num_sectors_hw],dx
 37521                                  		
 37522                                  	;Actually this modulo is always 0 because ONE_MEG mod BYTES_PER_SECTOR = 0
 37523                                  	
 37524                                  	;if (((mbytes_in * ONE_MEG) % BYTES_PER_SECTOR) != (int)0)
 37525                                  	;       number_of_sectors++;
 37526                                  
 37527                                  		;mov	cx,512
 37528                                  		;sub	bx,bx
 37529                                  		;push	bx
 37530                                  		;push	cx
 37531                                  		;mov	cl,4
 37532                                  		;shl	di,cl
 37533                                  		;sub	cx,cx
 37534                                  		;push	di
 37535                                  		;push	cx
 37536                                  		;call	_mod32
 37537                                  		;or	dx,ax
 37538                                  		;jz	short mbtocyl_2  ; always 0
 37539                                  		
 37540                                  		;mov	ax,[bp+mtc_num_sectors_lw]
 37541                                  		;mov	dx,[bp+mtc_num_sectors_hw]
 37542                                  		;add	ax,1
 37543                                  		;adc	dx,si
 37544                                  		;mov	[mtc_num_sectors_lw],ax
 37545                                  		;mov	[mtc_num_sectors_hw],dx
 37546                                  mbtocyl_2:
 37547                                  	;number_of_tracks = ul((number_of_sectors / max_sector[which_disk]));	
 37548                                  
 37549                                  		;mov	al,[mtc_which_disk]
 37550                                  		;cbw
 37551                                  		;mov	bx,ax
 37552                                  		;mov	al,[max_sector+bx]
 37553                                  		;sub	ah,ah
 37554                                  
 37555                                  		;mov	cx,ax
 37556 00005701 89F1                    		mov	cx,si ; *+* ; 19/01/2019
 37557                                  			; cl = [max_sector+bx]
 37558                                  			; ch = 0
 37559                                  		;sub	dx,dx
 37560                                  		;push	dx ; divisor hw = 0
 37561                                  		;push	ax ; divisor lw = sectors per track
 37562                                  		;push	word [mtc_num_sectors_hw] ; dividend hw
 37563                                  		;push	word [mtc_num_sectors_lw] ; dividend lw
 37564                                  		;mov	si,cx
 37565                                  		;call	div32
 37566                                  		
 37567                                  		;mov	dx,[mtc_num_sectors_hw]
 37568                                  		;mov	ax,[mtc_num_sectors_lw]	
 37569                                  
 37570                                  			; dx:ax = number of sectors (dividend)
 37571                                  			; cx = sectors per track (divisor)
 37572 00005703 E810BF                  		call	div32
 37573                                  			; dx:ax = quotient, number of tracks (cylinders*heads)
 37574                                  			; bx = remainder, sectors (less than spt)
 37575                                  
 37576                                  		;mov	[mtc_num_tracks_lw],ax
 37577                                  		;mov	[mtc_num_tracks_hw],dx
 37578                                  		
 37579                                  	;if (((unsigned)number_of_sectors % max_sector[which_disk]) != 0)
 37580                                  	;      number_of_tracks++;
 37581                                  
 37582                                  		;mov	ax,[mtc_num_sectors_lw]
 37583                                  		;sub	dx,dx
 37584                                  		;div	si
 37585                                  		;or	dx,dx
 37586                                  		;jz	short mbtocyl_3
 37587                                  		
 37588                                  		;mov	ax,[mtc_num_tracks_lw]
 37589                                  		;mov	dx,[mtc_num_tracks_hw]
 37590                                  		;add	ax,1
 37591                                  		;adc	dx,0
 37592                                  		;mov	[mtc_num_tracks_lw],ax
 37593                                  		;mov	[mtc_num_tracks_hw],dx
 37594                                  
 37595 00005706 09DB                    		or	bx,bx
 37596 00005708 7406                    		jz	short  mbtocyl_3
 37597                                  
 37598                                  		; round up
 37599 0000570A 83C001                  		add	ax,1 ; number_of_tracks++;
 37600 0000570D 83D200                  		adc	dx,0
 37601                                  mbtocyl_3:
 37602                                  		;mov	[mtc_num_tracks_lw],ax
 37603                                  		;mov	[mtc_num_tracks_hw],dx
 37604                                  
 37605                                  	;cylinders_out = u((number_of_tracks / max_head[which_disk]));
 37606                                  
 37607                                  		;mov	al,[mtc_which_disk]
 37608                                  		;cbw
 37609                                  		;mov	bx,ax
 37610                                  		;shl	bx,1
 37611                                  		;mov	ax,[max_head+bx]
 37612                                  
 37613                                  		;mov	cx,ax
 37614 00005710 89F9                    		mov	cx,di ; *++* ; 19/01/2019
 37615                                  			; cx = [max_head+bx]
 37616                                  		;sub	dx,dx
 37617                                  		;push	dx
 37618                                  		;push	ax
 37619                                  		;push	word [mtc_num_tracks_hw]
 37620                                  		;push	word [mtc_num_tracks_lw]
 37621                                  		;mov	si,ax
 37622                                  		;call	div32
 37623                                  
 37624                                  		;mov	ax,[mtc_num_tracks_lw]
 37625                                  		;mov	dx,[[mtc_num_tracks_hw]
 37626                                  			; dx:ax = number of tracks (dividend)	
 37627                                  			; cx = heads (divisor)
 37628 00005712 E801BF                  		call	div32
 37629                                  			 ; dx:ax = quotient, cylinders  ; dx = 0
 37630                                  			 ; bx = remainder, head 	
 37631                                  
 37632                                  		;mov	[mtc_cylinders_out],ax
 37633                                  
 37634                                  	;if (((unsigned)number_of_tracks % max_head[which_disk]) != 0)
 37635                                  	;      cylinders_out++;
 37636                                  
 37637                                  		;mov	ax,[mtc_num_tracks_lw]
 37638                                  		;sub	dx,dx
 37639                                  		;div	si
 37640                                  		;or	dx,dx
 37641                                  		;jz	short mbtocyl_5
 37642                                  
 37643 00005715 21DB                    		and	bx,bx
 37644 00005717 7501                    		jnz	short mbtocyl_5
 37645                                  		
 37646                                  		;mov	ax,[mtc_cylinders_out]
 37647 00005719 40                      		inc	ax  ; round up ; cylinders_out++
 37648                                  mbtocyl_4:
 37649                                  		;mov	[mtc_cylinders_out],ax
 37650                                  mbtocyl_5:
 37651                                  		;mov	ax,[mtc_cylinders_out]
 37652                                  
 37653                                  		; ax = cylinders
 37654                                  		
 37655                                  		;pop	si
 37656                                  		;pop	di
 37657                                  		
 37658 0000571A 89EC                    		mov	sp,bp
 37659 0000571C 5D                      		pop	bp
 37660                                  		;retn
 37661                                  
 37662 0000571D C20400                  		retn	4
 37663                                  
 37664                                  ;/***************************************************************************/
 37665                                  ;/*Routine name:  PERCENT_TO_CYLINDERS                                      */
 37666                                  ;/***************************************************************************/
 37667                                  ;/*                                                                         */
 37668                                  ;/*Description:   This routine will take input of percentage and            */
 37669                                  ;/*               convert it to cylinders rounding up to the next largest   */
 37670                                  ;/*               cylinder boundry.  Rounding up is done to make sure the   */
 37671                                  ;/*               requester is getting at least what he asked for to the    */
 37672                                  ;/*               next cylinder boundry.                                    */
 37673                                  ;/*                                                                         */
 37674                                  ;/*Called Procedures:    none                                               */
 37675                                  ;/*                                                                         */
 37676                                  ;/*                                                                         */
 37677                                  ;/*Change History: Created	5/30/87	DRM				    */
 37678                                  ;/*                                                                         */
 37679                                  ;/*Input: Input                                                             */
 37680                                  ;/*                                                                         */
 37681                                  ;/*Output: Cylinders_out                                                    */
 37682                                  ;/*                                                                         */
 37683                                  ;/***************************************************************************/
 37684                                  
 37685                                  ;XFLOAT percent_to_cylinders(percent_in,total_cylinders)
 37686                                  ;
 37687                                  ;unsigned percent_in;
 37688                                  ;unsigned total_cylinders;
 37689                                  ;
 37690                                  ;BEGIN
 37691                                  ;	XFLOAT	cylinders_out;
 37692                                  ;        cylinders_out = (unsigned)((ul(percent_in) * ul(total_cylinders)) / 100);
 37693                                  ;		 /* SR; 9/26/89; Typecast to long needed */
 37694                                  ;	if (((ul(percent_in) * ul(total_cylinders)) % 100) != u(0))
 37695                                  ;	   cylinders_out++;
 37696                                  ;	return(cylinders_out);
 37697                                  ;END
 37698                                  
 37699                                  percent_to_cylinders:
 37700                                  		; 19/01/2019
 37701                                  
 37702                                  	;%define ptc_cylinders_out   bp-2
 37703                                  	;%define ptc_percent_in	     bp+4
 37704                                  	;%define ptc_total_cylinders bp+6
 37705                                  
 37706                                  		; INPUT:
 37707                                  		;	CX = total cylinders (of the disk)
 37708                                  		;	AX = percent in (word, <= 100)
 37709                                  		; OUTPUT:
 37710                                  		;	AX = cylinders (of the partition)
 37711                                  		;
 37712                                   		; (modified registers: bx,cx,dx)
 37713                                  
 37714                                  		;push	bp
 37715                                  		;mov	bp,sp
 37716                                  		;sub	sp,2
 37717                                  		
 37718                                  		;push	di
 37719                                  		;push	si
 37720                                  		
 37721                                  		;;mov	ax,100
 37722                                  		;;cwd
 37723                                  		;;push	dx  ; divisor hw
 37724                                  		;;push	ax  ; divisor lw
 37725                                  		;;mov	ax,[ptc_total_cylinders]
 37726                                  		;;mul	word [ptc_percent_in]
 37727                                  		;;push	dx  ; dividend hw
 37728                                  		;;push	ax  ; dividend lw
 37729                                  		;;mov	si,ax
 37730                                  		;;mov	di,dx
 37731                                  		;;call	div32
 37732                                  
 37733                                  	;cylinders_out = (unsigned)((ul(percent_in) * ul(total_cylinders)) / 100);
 37734                                  
 37735                                  		;mov	ax,[ptc_total_cylinders]
 37736                                  		;mul	word [ptc_percent_in]
 37737                                  
 37738 00005720 F7E1                    		mul	cx ; total cylinders * percent in
 37739                                  
 37740                                  			; dx:ax = (100*cylinders/totalcylinders) * total cylinders 
 37741                                  
 37742 00005722 B96400                  		mov	cx,100
 37743                                  					
 37744                                  			; dx:ax = Dividend
 37745                                  			; cx = divisor (16 bit)
 37746                                  
 37747 00005725 E8EEBE                  		call	div32 ; ((100*cylinders/totalcylinders) * total cylinders) / 100 
 37748                                  			
 37749                                  			; DX:AX = Quotient 
 37750                                  			; BX = Remainder
 37751                                  
 37752                                  		;mov	[ptc_cylinders_out],ax  ; dx = 0
 37753                                  
 37754                                  		;mov	cx,100
 37755                                  		;sub	dx,dx
 37756                                  		;push	dx
 37757                                  		;push	cx
 37758                                  		;push	di
 37759                                  		;push	si
 37760                                  		;call	mod32
 37761                                  
 37762                                  		;or	dx,ax
 37763                                  		;jz	short pctocyl_1
 37764                                  
 37765                                  	;if (((ul(percent_in) * ul(total_cylinders)) % 100) != u(0))
 37766                                  	;   cylinders_out++;
 37767                                  
 37768 00005728 09DB                    		or	bx,bx
 37769 0000572A 7401                    		jz	short pctocyl_1 ; remainder = 0
 37770                                  
 37771                                  		;mov	ax,[ptc_cylinders_out]
 37772 0000572C 40                      		inc	ax  ; round up
 37773                                  		;mov	[ptc_cylinders_out],ax
 37774                                  pctocyl_1:
 37775                                  		;mov	ax,[ptc_cylinders_out]
 37776                                  		
 37777                                  		;pop	si
 37778                                  		;pop	di
 37779                                  		
 37780                                  		;mov	sp,bp
 37781                                  		;pop	bp
 37782                                  
 37783 0000572D C3                      		retn
 37784                                  
 37785                                  ; ----------------------------------------------------------------------------
 37786                                  ; partinfo.c (FDISK, MSDOS 6.0, 1991)	
 37787                                  ; ----------------------------------------------------------------------------
 37788                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 19/01/2019)
 37789                                  
 37790                                  ;char find_free_partition()
 37791                                  ;
 37792                                  ;BEGIN
 37793                                  ; char  i;
 37794                                  ;
 37795                                  ;    /* Look at all four partition entries for empty partition */
 37796                                  ;    for (i = c(0); i < c(4);i++)                             /* AC000 */
 37797                                  ;       BEGIN
 37798                                  ;
 37799                                  ;       /* if we find an empty one, return which one */
 37800                                  ;        if (part_table[cur_disk][i].num_sec == ul(0))        /* AC000 */
 37801                                  ;           BEGIN
 37802                                  ;            return(i);
 37803                                  ;            break;
 37804                                  ;           END
 37805                                  ;       END
 37806                                  ;    /* Did not find one, return NOT_FOUND */
 37807                                  ;    return(c(NOT_FOUND));                                    /* AC000 */
 37808                                  ;END
 37809                                  
 37810                                  find_free_partition:
 37811                                  		; 19/01/2019
 37812                                  
 37813                                  	%define	ffp_i	bp-2
 37814                                  
 37815                                  		;push	bp
 37816                                  		;mov	bp,sp
 37817                                  		;sub	sp,2
 37818                                  
 37819                                  	;/* Look at all four partition entries for empty partition */
 37820                                  	
 37821                                  		; for (i = c(0); i < c(4);i++)	
 37822                                  	
 37823                                  		;mov	byte [ffp_i],0
 37824 0000572E 31C9                    		xor	cx,cx ; 0
 37825 00005730 EB07                    		jmp	short ffp_2
 37826                                  ffp_1:
 37827                                  		;inc	byte [ffp_i]
 37828 00005732 FEC1                    		inc	cl
 37829                                  ;ffp_2:
 37830                                  		;cmp	byte [ffp_i],4
 37831                                  		;jge	short ffp_3
 37832 00005734 80F904                  		cmp	cl,4
 37833 00005737 731D                    		jnb	short ffp_3
 37834                                  ffp_2:		
 37835                                  		;/* if we find an empty one, return which one */
 37836                                  		
 37837                                  		;mov	al,[cur_disk]
 37838                                  		;cbw
 37839                                  		;shl	ax,1
 37840                                  		;shl	ax,1
 37841                                  		;mov	cx,ax
 37842                                  		
 37843 00005739 8A1E[E2CB]              		mov	bl,[cur_disk]
 37844 0000573D D0E3                    		shl	bl,1
 37845 0000573F D0E3                    		shl	bl,1		
 37846                                  
 37847                                  		;mov	al,[ffp_i]
 37848                                  		;cbw
 37849                                  		;add	ax,cx
 37850                                  
 37851 00005741 00CB                    		add	bl,cl ; cl = [ffp_i]
 37852                                  		
 37853                                  		;mov	cx,46
 37854                                  		;imul	cx
 37855 00005743 B02E                    		mov	al,46
 37856 00005745 F6E3                    		mul	bl		
 37857                                  
 37858 00005747 89C3                    		mov	bx,ax
 37859                                  
 37860                                  		;if (part_table[cur_disk][i].num_sec == ul(0)) 
 37861                                  
 37862 00005749 8B87[30C4]              		mov	ax,[part_table_num_sec_hw+bx]
 37863 0000574D 0B87[2EC4]              		or	ax,[part_table_num_sec_lw+bx]
 37864 00005751 75DF                    		jnz	short ffp_1
 37865                                  
 37866                                  		;mov	al,[ffp_i]
 37867 00005753 88C8                    		mov	al,cl  ; return(i);
 37868                                  		;jmp	short ffp_4
 37869 00005755 C3                      		retn
 37870                                  ffp_3:
 37871                                  		;/* Did not find one, return NOT_FOUND */
 37872                                  
 37873 00005756 B0FF                    		mov	al,0FFh ; -1 ; return(c(NOT_FOUND)); 
 37874                                  ffp_4:
 37875                                  		;mov	sp,bp
 37876                                  		;pop	bp
 37877 00005758 C3                      		retn
 37878                                  
 37879                                  ; ----------------------------------------------------------------------------
 37880                                  ; space.c (FDISK, MSDOS 6.0, 1991)	
 37881                                  ; ----------------------------------------------------------------------------
 37882                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 20/01/2019)
 37883                                  
 37884                                  ;char find_ext_free_space()
 37885                                  ;
 37886                                  ;BEGIN
 37887                                  ;
 37888                                  ;char   i;
 37889                                  ;char   partition_count;
 37890                                  ;char   last_found_partition;
 37891                                  ;unsigned    temp;
 37892                                  ;char   freespace_count;
 37893                                  ;char   any_partition;
 37894                                  ;char   ext_location;
 37895                                  ;
 37896                                  ;        /* Sort the partition table */
 37897                                  ;        sort_ext_table(c(23));                                          /* AC000 */
 37898                                  ;
 37899                                  ;        /* Initialize free space to zero */
 37900                                  ;        for (i = c(0); i < c(24); i++)                                  /* AC000 */
 37901                                  ;           BEGIN
 37902                                  ;            free_space[i].space = u(0);                                 /* AC000 */
 37903                                  ;            free_space[i].start = u(0);
 37904                                  ;            free_space[i].end = u(0);                                   /* AC000 */
 37905                                  ;            free_space[i].mbytes_unused = f(0);                         /* AN000 */
 37906                                  ;            free_space[i].percent_unused = u(0);                        /* AN000 */
 37907                                  ;           END
 37908                                  ;
 37909                                  ;        /* Find space between start of Extended partition and first volume */
 37910                                  ;        ext_location = find_partition_location(uc(EXTENDED));           /* AC000 */
 37911                                  ;
 37912                                  ;        partition_count = c(0);                                         /* AC000 */
 37913                                  ;
 37914                                  ;        any_partition = FALSE;
 37915                                  ;        for (i = c(0); i < c(23); i++)                                  /* AC000 */
 37916                                  ;           BEGIN
 37917                                  ;            if (ext_table[cur_disk][sort[i]].sys_id != uc(0))           /* AC000 */
 37918                                  ;               BEGIN
 37919                                  ;                /* Found a partition, get the space */
 37920                                  ;                free_space[0].space = ext_table[cur_disk][sort[i]].start_cyl - part_table[cur_disk][ext_location].start_cyl;
 37921                                  ;                free_space[0].start = part_table[cur_disk][ext_location].start_cyl;
 37922                                  ;                free_space[0].end = ext_table[cur_disk][sort[i]].start_cyl-1;
 37923                                  ;                free_space[0].mbytes_unused =
 37924                                  ;                     cylinders_to_mbytes(free_space[0].space,cur_disk); /* AN004 */
 37925                                  ;                free_space[0].percent_unused = (unsigned)cylinders_to_percent(free_space[0].space,total_disk[cur_disk]); /* AN000 */
 37926                                  ;
 37927                                  ;                partition_count = i;
 37928                                  ;                last_found_partition = sort[i];
 37929                                  ;                any_partition = TRUE;
 37930                                  ;                break;
 37931                                  ;               END
 37932                                  ;           END
 37933                                  ;        /* See if any partitions were there */
 37934                                  ;        if (any_partition)
 37935                                  ;           BEGIN
 37936                                  ;            /* Look for space between the rest of the partitions */
 37937                                  ;            freespace_count = c(1);                                     /* AC000 */
 37938                                  ;            for (i = partition_count+1; i < c(23); i++)                 /* AC000 */
 37939                                  ;               BEGIN
 37940                                  ;                if (ext_table[cur_disk][sort[i]].sys_id != uc(0))       /* AC000 */
 37941                                  ;                   BEGIN
 37942                                  ;
 37943                                  ;                    /* Get space between the end of the last one and the start of the next one */
 37944                                  ;                    temp = ext_table[cur_disk][sort[i]].start_cyl - (ext_table[cur_disk][last_found_partition].end_cyl+1);
 37945                                  ;                    free_space[freespace_count].space = temp;
 37946                                  ;                    free_space[freespace_count].start = ext_table[cur_disk][last_found_partition].end_cyl+1;
 37947                                  ;                    free_space[freespace_count].end = ext_table[cur_disk][sort[i]].start_cyl -1;
 37948                                  ;                    free_space[freespace_count].mbytes_unused =
 37949                                  ;                         cylinders_to_mbytes(free_space[freespace_count].space,cur_disk);   /* AN004 */
 37950                                  ;                    free_space[freespace_count].percent_unused = (unsigned)
 37951                                  ;                         cylinders_to_percent(free_space[freespace_count].space,total_disk[cur_disk]); /* AN000 */
 37952                                  ;
 37953                                  ;                    /* update the last found partition */
 37954                                  ;                    last_found_partition = sort[i];
 37955                                  ;                    freespace_count++;
 37956                                  ;                   END
 37957                                  ;               END
 37958                                  ;            /* Find the space between the last partition and the end of the extended partition */
 37959                                  ;            temp = part_table[cur_disk][ext_location].end_cyl -  ext_table[cur_disk][last_found_partition].end_cyl;
 37960                                  ;            free_space[freespace_count].space = temp;
 37961                                  ;            free_space[freespace_count].start = ext_table[cur_disk][last_found_partition].end_cyl+1;
 37962                                  ;            free_space[freespace_count].end = part_table[cur_disk][ext_location].end_cyl;
 37963                                  ;            free_space[freespace_count].mbytes_unused =
 37964                                  ;                 cylinders_to_mbytes(free_space[freespace_count].space,cur_disk);    /* AN004 */
 37965                                  ;            free_space[freespace_count].percent_unused = (unsigned)
 37966                                  ;                 cylinders_to_percent(free_space[freespace_count].space,total_disk[cur_disk]);  /* AN000 */
 37967                                  ;           END
 37968                                  ;        else
 37969                                  ;           BEGIN
 37970                                  ;            /* No partitions found, show entire space as free */
 37971                                  ;            free_space[0].space = (part_table[cur_disk][ext_location].end_cyl - part_table[cur_disk][ext_location].start_cyl) + 1;
 37972                                  ;            free_space[0].start = part_table[cur_disk][ext_location].start_cyl;
 37973                                  ;            free_space[0].end = part_table[cur_disk][ext_location].end_cyl;
 37974                                  ;            free_space[0].mbytes_unused =
 37975                                  ;                 cylinders_to_mbytes(free_space[0].space,cur_disk);  /* AN004 */
 37976                                  ;            free_space[0].percent_unused = (unsigned)cylinders_to_percent(free_space[0].space,total_disk[cur_disk]); /* AN000 */
 37977                                  ;           END
 37978                                  ;
 37979                                  ;         /* Find largest free space */
 37980                                  ;         temp = u(0);                                                   /* AC000 */
 37981                                  ;
 37982                                  ;         /* Find largest free space, and verify the golden tracks while we are at it */
 37983                                  ;         do
 37984                                  ;            BEGIN
 37985                                  ;             temp = u(0);                                               /* AC000 */
 37986                                  ;
 37987                                  ;             /* Zip thru the table */
 37988                                  ;             for (i = c(0); i < c(24); i++)                             /* AC000 */
 37989                                  ;                BEGIN
 37990                                  ;                 /* Is this one bigger ? */
 37991                                  ;                 if (free_space[i].space > temp)
 37992                                  ;                    BEGIN
 37993                                  ;                     temp = free_space[i].space;
 37994                                  ;                     last_found_partition = i;
 37995                                  ;                    END
 37996                                  ;                END
 37997                                  ;             /* If there is any free space, go verify it */
 37998                                  ;             temp = u(0);
 37999                                  ;             if (free_space[last_found_partition].space != u(0))       /* AC000 */
 38000                                  ;                BEGIN
 38001                                  ;
 38002                                  ;                 /* Go verify the tracks */
 38003                                  ;                 temp = verify_tracks(last_found_partition,c(EXTENDED)); /* AC000 */
 38004                                  ;                END
 38005                                  ;             /* Move up to next golden track */
 38006                                  ;             free_space[last_found_partition].start = free_space[last_found_partition].start+temp;
 38007                                  ;             free_space[last_found_partition].space = free_space[last_found_partition].space-temp;
 38008                                  ;             free_space[last_found_partition].mbytes_unused =
 38009                                  ;                  cylinders_to_mbytes(free_space[last_found_partition].space,cur_disk);    /* AN004 */
 38010                                  ;             free_space[last_found_partition].percent_unused =
 38011                                  ;                  cylinders_to_percent(free_space[last_found_partition].space,total_disk[cur_disk]); /* AN000 */
 38012                                  ;             END
 38013                                  ;             /* Repeat the loop if the start was moved due to bad tracks */
 38014                                  ;            /* Unless we're past the end of the free space */
 38015                                  ;            while ((temp !=u(0)) && (free_space[last_found_partition].space!= u(0)));  /* AC000 */
 38016                                  ;
 38017                                  ;        /* Don't create a partition larger than DOS can handle */                              /*C05*/
 38018                                  ;        if(free_space[last_found_partition].mbytes_unused > u(MAX_PART_SIZE))                  /*C05*/
 38019                                  ;          BEGIN                                                                                /*C05*/
 38020                                  ;          free_space[last_found_partition].space =                                             /*C05*/
 38021                                  ;           mbytes_to_cylinders(f(MAX_PART_SIZE),cur_disk) - 1;                                 /*C05*/
 38022                                  ;          free_space[last_found_partition].end =                                               /*C05*/
 38023                                  ;           free_space[last_found_partition].start+free_space[last_found_partition].space-1;    /*C05*/
 38024                                  ;          free_space[last_found_partition].mbytes_unused =                                     /*C05*/
 38025                                  ;           cylinders_to_mbytes(free_space[last_found_partition].space,cur_disk);               /*C05*/
 38026                                  ;          free_space[last_found_partition].percent_unused = (unsigned)                         /*C05*/
 38027                                  ;           cylinders_to_percent(free_space[last_found_partition].space,total_disk[cur_disk]);  /*C05*/
 38028                                  ;          END                                                                                  /*C05*/
 38029                                  ;
 38030                                  ;        /* Return with the pointer to the largest free space */
 38031                                  ;        return(last_found_partition);
 38032                                  ;END
 38033                                  
 38034                                  find_ext_free_space:
 38035                                  		; 21/01/2019
 38036                                  		; 20/01/2019
 38037                                  
 38038                                  	%define fefs_i		     	bp-12	;bp-14
 38039                                  	%define fefs_ext_location    	bp-10	;bp-12
 38040                                  	%define fefs_last_found_part 	bp-8	;bp-10
 38041                                  	%define fefs_temp	     	bp-6	;bp-8
 38042                                  	%define fefs_freespace_count 	bp-4	;bp-6
 38043                                  	%define fefs_partition_count 	bp-2	;bp-4
 38044                                  	%define fefs_any_partition   		;bp-2
 38045                                  
 38046 00005759 55                      		push	bp
 38047 0000575A 89E5                    		mov	bp,sp
 38048                                  		;sub	sp,14
 38049 0000575C 83EC0C                  		sub	sp,12
 38050                                  
 38051                                  		;push	di
 38052                                  		;push	si
 38053                                  
 38054                                  		;/* Sort the partition table */
 38055                                  
 38056                                  		;mov	al,23
 38057                                  		;push	ax
 38058 0000575F B117                    		mov	cl,23
 38059 00005761 E8ABD2                  		call	sort_ext_table
 38060                                  		;pop	bx
 38061                                  
 38062                                  		;/* Initialize free space to zero */
 38063                                  
 38064 00005764 31C0                    		xor	ax,ax ; 21/01/2019
 38065                                  
 38066                                  		;mov	word [fefs_i],0
 38067 00005766 8946F4                  		mov	[fefs_i],ax ; 0
 38068                                  fefs_1:
 38069                                  		;;mov	al,22
 38070                                  		;mov	al,10
 38071                                  		;;imul	byte [fefs_i]
 38072                                  		;mul	byte [fefs_i]
 38073                                  		;mov	bx,ax
 38074                                  		;sub	ax,ax
 38075                                  		;mov	[free_space.space+bx],ax
 38076                                  		;mov	[free_space.start+bx],ax
 38077                                  		;mov	[free_space.end+bx],ax
 38078                                  		;mov	[free_space.mbytes_unused+bx],ax
 38079                                  		;mov	[free_space.percent_unused+bx],ax
 38080                                  		;inc	byte [fefs_i]
 38081                                  		;cmp	byte [fefs_i],24
 38082                                  		;jl	short fefs_1
 38083                                  
 38084                                  		;push	cs
 38085                                  		;pop	es
 38086 00005769 BF[F0CB]                		mov	di,fspc ; free_space.space
 38087 0000576C B97800                  		mov	cx,24*5 ; (24*10/2) ; 20/01/2019
 38088                                  		;xor	ax,ax ; 0
 38089 0000576F F3AB                    		rep	stosw
 38090                                  
 38091                                  	;/* Find space between start of Extended partition and first volume */
 38092                                  
 38093                                  		;mov	al,5
 38094                                  		;push	ax
 38095                                  		;call	find_partition_location
 38096                                  		;pop	bx
 38097                                  
 38098                                  		;mov	[fefs_ext_location],al
 38099                                  		
 38100                                  		; 20/01/2019
 38101                                  		; get partition entry number of extended dos partion
 38102                                   		; 	(on current disk/drive)
 38103 00005771 B005                    		mov	al,5  ; EXTENDED partition ID
 38104 00005773 E84EC6                  		call	find_partition_type
 38105                                  		; CL = partition number (index), 0 to 3 or 4 (not found)
 38106                                  
 38107 00005776 884EF6                  		mov	[fefs_ext_location],cl
 38108                                  
 38109 00005779 28C0                    		sub	al,al ; 0
 38110 0000577B 8846FE                  		mov	[fefs_partition_count],al ; 0
 38111                                  		;mov	[fefs_any_partition],al ; 0
 38112                                  		;mov	[fefs_i],al ; 0
 38113                                  		;jmp	short fefs_3
 38114 0000577E EB0C                    		jmp	short fefs_4
 38115                                  fefs_2:
 38116 00005780 FE46F4                  		inc	byte [fefs_i]
 38117                                  fefs_3:
 38118 00005783 807EF417                		cmp	byte [fefs_i],23
 38119 00005787 7203                    		jb	short fefs_4
 38120                                  		;jmp	fefs_5
 38121                                  		;jnb	short fefs_5  ; [fefs_any_partition] = 0
 38122 00005789 E96001                  		jmp	fefs_11 ; [fefs_any_partition] = 0
 38123                                  fefs_4:
 38124 0000578C A0[E2CB]                		mov	al,[cur_disk]
 38125                                  		;cbw
 38126 0000578F B91800                  		mov	cx,24
 38127                                  		;mov	bx,ax
 38128 00005792 88C3                    		mov	bl,al
 38129                                  		;imul	cx
 38130 00005794 F6E1                    		mul	cl
 38131                                  		;mov	cx,ax ; ah = 0
 38132                                  		;mov	al,[fefs_i]
 38133                                  		;cbw
 38134                                  		;mov	si,ax
 38135 00005796 8B76F4                  		mov	si,[fefs_i] ; =**=
 38136                                  		;mov	al,[sort+si]
 38137 00005799 8A8C[F0C3]              		mov	cl,[sort+si]
 38138                                  		;cbw
 38139                                  		;add	ax,cx
 38140 0000579D 00C8                    		add	al,cl
 38141                                  		;mov	cx,46
 38142                                  		;imul	cx
 38143 0000579F B12E                    		mov	cl,46
 38144 000057A1 F6E1                    		mul	cl
 38145 000057A3 89C7                    		mov	di,ax
 38146                                  	
 38147 000057A5 80BD[5DA1]00            		cmp	byte [ext_table_sys_id+di],0
 38148 000057AA 74D4                    		je	short fefs_2
 38149                                  
 38150                                  		;shl	bx,1
 38151                                  		;shl	bx,1
 38152 000057AC D0E3                    		shl	bl,1
 38153 000057AE D0E3                    		shl	bl,1
 38154 000057B0 8A46F6                  		mov	al,[fefs_ext_location]
 38155                                  		;cbw
 38156                                  		;add	ax,bx
 38157 000057B3 00D8                    		add	al,bl
 38158                                  		;imul	cx
 38159 000057B5 F6E1                    		mul	cl
 38160 000057B7 89C3                    		mov	bx,ax
 38161                                  		;mov	ax,[part_table_start_cyl+bx]
 38162                                  		;mov	[free_space.start],ax
 38163 000057B9 8B97[23C4]              		mov	dx,[part_table_start_cyl+bx]
 38164 000057BD 8916[F2CB]              		mov	[free_space.start],dx
 38165 000057C1 8B8D[5BA1]              		mov	cx,[ext_table_start_cyl+di]
 38166                                  		;mov	dx,cx
 38167 000057C5 89C8                    		mov	ax,cx
 38168 000057C7 49                      		dec	cx
 38169 000057C8 890E[F4CB]              		mov	[free_space.end],cx
 38170                                  		;mov	cl,[cur_disk]
 38171                                  		;push	cx
 38172 000057CC 8A1E[E2CB]              		mov	bl,[cur_disk]	      ; BX = Drive number	
 38173 000057D0 30FF                    		xor	bh,bh
 38174 000057D2 53                      		push	bx ; *
 38175                                  		;sub	dx,ax
 38176 000057D3 29D0                    		sub	ax,dx
 38177                                  		;mov	[free_space.space],dx
 38178 000057D5 A3[F0CB]                		mov	[free_space.space],ax ; AX = CYLINDERS
 38179                                  		;push	dx
 38180                                  			; BX = drive number (0 to 7)
 38181                                  			; AX = cylinders
 38182 000057D8 E88BBD                  		call	cylinders_to_mbytes
 38183                                  		;pop	bx
 38184                                  		;pop	bx
 38185 000057DB A3[F6CB]                		mov	[free_space.mbytes_unused],ax
 38186                                  
 38187                                  		;mov	al,[cur_disk]
 38188                                  		;cbw
 38189                                  		;mov	bx,ax
 38190 000057DE 5B                      		pop	bx ; *
 38191                                  		;shl	bx,1
 38192 000057DF D0E3                    		shl	bl,1
 38193                                  		;push	word [total_disk+bx]
 38194 000057E1 8B8F[C6A0]              		mov	cx,[total_disk+bx]  ; total (disk) cylinders -divisor-
 38195                                  		;push	word [free_space.space]
 38196 000057E5 8B1E[F0CB]              		mov	bx,[free_space.space] ; num of cylinders (of partition) -dividend-
 38197 000057E9 E8CDBD                  		call	cylinders_to_percent
 38198                                  		;pop	bx
 38199                                  		;pop	bx
 38200 000057EC A3[F8CB]                		mov	[free_space.percent_unused],ax
 38201 000057EF 8A46F4                  		mov	al,[fefs_i]
 38202 000057F2 8846FE                  		mov	[fefs_partition_count],al
 38203 000057F5 8A84[F0C3]              		mov	al,[sort+si] ; =**=
 38204 000057F9 8846F8                  		mov	[fefs_last_found_part],al
 38205                                  		;mov	[fefs_any_partition],1
 38206                                  
 38207                                  		;/* See if any partitions were there */
 38208                                  ;fefs_5:
 38209                                  ;		cmp	byte [fefs_any_partition],0
 38210                                  ;		jne	short fefs_6
 38211                                  ;		jmp	fefs_11
 38212                                  fefs_6:
 38213                                  		;/* Look for space between the rest of the partitions */
 38214                                  
 38215 000057FC C646FC01                		mov	byte [fefs_freespace_count],1
 38216                                  		;mov	al,[fefs_partition_count]
 38217                                  		;inc	al
 38218                                  		;mov	[fefs_i],al
 38219                                  		;jmp	fefs_9
 38220                                  		; 21/01/2019
 38221 00005800 EB77                    		jmp	short fefs_8 ; inc byte [fefs_i]
 38222                                  fefs_7:
 38223 00005802 B018                    		mov	al,24
 38224                                  		;imul	byte [cur_disk]
 38225 00005804 F626[E2CB]              		mul	byte [cur_disk]
 38226                                  		;mov	cx,ax ; ah = 0
 38227 00005808 88C3                    		mov	bl,al ; ==*
 38228                                  		;mov	al,[fefs_i]
 38229                                  		;cbw
 38230                                  		;;mov	bx,ax
 38231 0000580A 8B76F4                  		mov	si,[fefs_i]  ; *==*
 38232                                  		;mov	al,[sort+bx]
 38233                                  		;cbw
 38234                                  		;add	ax,cx
 38235 0000580D 8A8C[F0C3]              		mov	cl,[sort+si] ; *==*
 38236 00005811 00C8                    		add	al,cl	
 38237                                  	
 38238                                  		;mov	si,46
 38239                                  		;imul	si
 38240 00005813 B12E                    		mov	cl,46
 38241 00005815 F6E1                    		mul	cl
 38242                                  
 38243 00005817 89C7                    		mov	di,ax
 38244                                  		
 38245 00005819 80BD[5DA1]00            		cmp	byte [ext_table_sys_id+di],0
 38246 0000581E 7459                    		je	short fefs_8
 38247                                  
 38248                                  	;/* Get space between the end of the last one and the start of the next one */
 38249                                  
 38250 00005820 8A46F8                  		mov	al,[fefs_last_found_part]
 38251                                  		;cbw
 38252                                  		;add	ax,cx
 38253 00005823 00D8                    		add	al,bl ; ==*
 38254                                  		;imul	si
 38255 00005825 F6E1                    		mul	cl ; * 46
 38256                                  		;mov	si,ax
 38257 00005827 89C3                    		mov	bx,ax ; ++=
 38258                                  
 38259                                  		; 21/01/2019
 38260                                  		;mov	ax,[ext_table_start_cyl+di]
 38261                                  		;mov	cx,ax
 38262 00005829 8B95[5BA1]              		mov	dx,[ext_table_start_cyl+di]
 38263 0000582D 89D1                    		mov	cx,dx
 38264                                  		;;sub	ax,[ext_table_end_cyl+si]
 38265                                  		;sub	ax,[ext_table_end_cyl+bx] ; ++=
 38266                                  		;dec	ax
 38267                                  		;mov	[fefs_temp],ax
 38268                                  		;mov	dx,ax
 38269 0000582F 2B97[60A1]              		sub	dx,[ext_table_end_cyl+bx] ; ++=
 38270 00005833 4A                      		dec	dx
 38271                                  		;mov	[fefs_temp],dx
 38272                                  
 38273                                  		;mov	al,22
 38274 00005834 B00A                    		mov	al,10
 38275                                  		;imul	byte [fefs_freespace_count]
 38276 00005836 F666FC                  		mul	byte [fefs_freespace_count]
 38277 00005839 89C7                    		mov	di,ax
 38278 0000583B 8995[F0CB]              		mov	[free_space.space+di],dx
 38279                                  		;mov	ax,[ext_table_end_cyl+si]
 38280 0000583F 8B87[60A1]              		mov	ax,[ext_table_end_cyl+bx] ; ++=
 38281 00005843 40                      		inc	ax
 38282 00005844 8985[F2CB]              		mov	[free_space.start+di],ax
 38283 00005848 49                      		dec	cx
 38284 00005849 898D[F4CB]              		mov	[free_space.end+di],cx
 38285                                  
 38286                                  		;mov	al,[cur_disk]
 38287                                  		;push	ax
 38288                                  		;push	word [free_space.space+di]
 38289                                  		;mov	si,bx
 38290                                  		
 38291 0000584D 28FF                    		sub	bh,bh
 38292 0000584F 8A1E[E2CB]              		mov	bl,[cur_disk]
 38293 00005853 53                      		push	bx ; *!*
 38294                                  
 38295                                  		;mov	ax,[free_space.space+di]
 38296 00005854 89D0                    		mov	ax,dx 
 38297                                  			; bx = drive number (0 to 7)
 38298                                  			; ax = cylinders
 38299 00005856 E80DBD                  		call	cylinders_to_mbytes
 38300                                  		;pop	bx
 38301                                  		;pop	bx
 38302                                  
 38303 00005859 8985[F6CB]              		mov	[free_space.mbytes_unused+di],ax
 38304                                  
 38305                                  		;mov	al,[cur_disk]
 38306                                  		;cbw
 38307                                  		;mov	bx,ax
 38308                                  		
 38309 0000585D 5B                      		pop	bx ;*!*
 38310                                  
 38311                                  		;shl	bx,1
 38312 0000585E D0E3                    		shl	bl,1
 38313                                  		;push	word [total_disk+bx]
 38314 00005860 8B8F[C6A0]              		mov	cx,[total_disk+bx]
 38315                                  		;push	word [free_space.space+di]
 38316 00005864 8B9D[F0CB]              		mov	bx,[free_space.space+di] 
 38317                                  			; cx = total (disk) cylinders -divisor-
 38318                                  			; bx = num of cylinders (of partition) -dividend-
 38319 00005868 E84EBD                  		call	cylinders_to_percent
 38320                                  		;pop	bx
 38321                                  		;pop	bx
 38322                                  
 38323 0000586B 8985[F8CB]              		mov	[free_space.percent_unused+di],ax
 38324                                  
 38325                                  		;/* update the last found partition */
 38326                                  
 38327 0000586F 8A84[F0C3]              		mov	al,[sort+si] ; *==*
 38328 00005873 8846F8                  		mov	[fefs_last_found_part],al
 38329 00005876 FE46FC                  		inc	byte [fefs_freespace_count]
 38330                                  fefs_8:
 38331                                  
 38332 00005879 FE46F4                  		inc	byte [fefs_i]
 38333                                  fefs_9:
 38334 0000587C 807EF417                		cmp	byte [fefs_i],23
 38335                                  		;jge	short fefs_10
 38336 00005880 7303                    		jnb	short fefs_10
 38337 00005882 E97DFF                  		jmp	fefs_7
 38338                                  fefs_10:
 38339                                  	;/* Find the space between the last partition and the end of the extended partition */
 38340                                  
 38341                                  		;mov	al,[fefs_last_found_part]
 38342 00005885 8A56F8                  		mov	dl,[fefs_last_found_part] ; -*-
 38343                                  		;cbw
 38344                                  		;mov	cx,24
 38345 00005888 B118                    		mov	cl,24
 38346                                  		;mov	dx,ax
 38347 0000588A A0[E2CB]                		mov	al,[cur_disk] ; *-*-
 38348                                  		;cbw
 38349                                  		;mov	bx,dx
 38350                                  		;mov	si,ax
 38351 0000588D 88C3                    		mov	bl,al ; *-*-
 38352                                  		;imul	cx
 38353 0000588F F6E1                    		mul	cl
 38354                                  		;add	ax,bx ; ah = 0
 38355 00005891 00D0                    		add	al,dl ; -*-
 38356                                  		;mov	cx,46
 38357                                  		;imul	cx
 38358 00005893 B12E                    		mov	cl,46
 38359 00005895 F6E1                    		mul	cl
 38360                                  		;mov	bx,ax
 38361 00005897 89C6                    		mov	si,ax ; -**-
 38362 00005899 8A46F6                  		mov	al,[fefs_ext_location]
 38363                                  		;cbw
 38364                                  		;shl	si,1
 38365                                  		;shl	si,1
 38366 0000589C D0E3                    		shl	bl,1 ; *-*-
 38367 0000589E D0E3                    		shl	bl,1
 38368                                  		;add	ax,si
 38369 000058A0 00D8                    		add	al,bl ; *-*-
 38370                                  		;imul	cx
 38371 000058A2 F6E1                    		mul	cl
 38372                                  		;mov	si,ax
 38373 000058A4 89C3                    		mov	bx,ax ; -***-
 38374                                  		;mov	ax,[part_table_end_cyl+si]
 38375 000058A6 8B8F[28C4]              		mov	cx,[part_table_end_cyl+bx] ; -***-
 38376                                  		;mov	cx,ax
 38377 000058AA 89CA                    		mov	dx,cx ; ++
 38378                                  		;sub	ax,[ext_table_end_cyl+bx]
 38379 000058AC 2B8C[60A1]              		sub	cx,[ext_table_end_cyl+si] ; -**-
 38380                                  		;;mov	[fefs_temp],ax
 38381                                  		;mov	[fefs_temp],cx ; *+
 38382                                  		;mov	dx,ax
 38383                                  		;mov	al,22
 38384 000058B0 B00A                    		mov	al,10
 38385                                  		;imul	byte [fefs_freespace_count]
 38386 000058B2 F666FC                  		mul	byte [fefs_freespace_count]
 38387                                  		;mov	si,ax
 38388 000058B5 89C7                    		mov	di,ax ; -****-
 38389                                  		;mov	[free_space.space+si],dx
 38390 000058B7 898D[F0CB]              		mov	[free_space.space+di],cx ; -****- ; *+
 38391                                  
 38392                                  		;mov	ax,[ext_table_end_cyl+bx]
 38393 000058BB 8B84[60A1]              		mov	ax,[ext_table_end_cyl+si] ; -**-
 38394 000058BF 40                      		inc	ax
 38395                                  		;mov	[free_space.start+si],ax
 38396 000058C0 8985[F2CB]              		mov	[free_space.start+di],ax ; -****-
 38397                                  		;mov	[free_space.end+si],cx
 38398 000058C4 8995[F4CB]              		mov	[free_space.end+di],dx ; -****- ; ++
 38399                                  		
 38400                                  		;mov	al,[cur_disk]
 38401                                  		;push	ax
 38402 000058C8 28FF                    		sub	bh,bh
 38403 000058CA 8A1E[E2CB]              		mov	bl,[cur_disk]
 38404 000058CE 53                      		push	bx ; +**
 38405                                  		;push	word [free_space.space+si]
 38406                                  		;mov	ax,[free_space.space+di] ; *+
 38407 000058CF 89C8                    		mov	ax,cx ; *+ ; 21/01/2019
 38408                                  			; bx = drive number (0 to 7)
 38409                                  			; ax = cylinders	
 38410 000058D1 E892BC                  		call	cylinders_to_mbytes
 38411                                  		;pop	bx
 38412                                  		;pop	bx
 38413                                  		;mov	[free_space.mbytes_unused+si],ax
 38414 000058D4 8985[F6CB]              		mov	[free_space.mbytes_unused+di],ax
 38415                                  
 38416                                  		;mov	al,[cur_disk]
 38417                                  		;cbw
 38418                                  		;mov	bx,ax
 38419                                  		
 38420 000058D8 5B                      		pop	bx ; +**
 38421                                  
 38422                                  		;shl	bx,1
 38423 000058D9 D0E3                    		shl	bl,1	
 38424                                  		
 38425                                  		;push	word [total_disk+bx]
 38426 000058DB 8B8F[C6A0]              		mov	cx,[total_disk+bx]
 38427                                  		;push	word [free_space.space+si]
 38428 000058DF 8B9D[F0CB]              		mov	bx,[free_space.space+di] 
 38429                                  			; cx = total (disk) cylinders -divisor-
 38430                                  			; bx = num of cylinders (of partition) -dividend-
 38431 000058E3 E8D3BC                  		call	cylinders_to_percent
 38432                                  		;pop	bx
 38433                                  		;pop	bx
 38434                                  		;mov	[free_space.percent_unused+si],ax
 38435 000058E6 8985[F8CB]              		mov	[free_space.percent_unused+di],ax
 38436 000058EA EB42                    		jmp	short fefs_12
 38437                                  fefs_11:
 38438                                  	;/* No partitions found, show entire space as free */
 38439                                  
 38440 000058EC A0[E2CB]                		mov	al,[cur_disk]
 38441 000058EF 98                      		cbw
 38442                                  
 38443 000058F0 50                      		push	ax ; **
 38444                                  
 38445                                  		;shl	ax,1
 38446                                  		;shl	ax,1
 38447 000058F1 D0E0                    		shl	al,1
 38448 000058F3 D0E0                    		shl	al,1
 38449                                  		;mov	cx,ax
 38450                                  		;mov	al,[fefs_ext_location]
 38451                                  		;cbw
 38452                                  		;add	ax,cx
 38453 000058F5 0246F6                  		add	al,[fefs_ext_location]
 38454                                  		;mov	cx,46
 38455                                  		;imul	cx
 38456 000058F8 B12E                    		mov	cl,46
 38457 000058FA F6E1                    		mul	cl
 38458 000058FC 89C3                    		mov	bx,ax
 38459                                  		; 21/01/2019
 38460 000058FE 8B87[28C4]              		mov	ax,[part_table_end_cyl+bx]
 38461                                  		;mov	cx,ax
 38462 00005902 A3[F4CB]                		mov	[free_space.end],ax
 38463 00005905 2B87[23C4]              		sub	ax,[part_table_start_cyl+bx]
 38464 00005909 40                      		inc	ax
 38465 0000590A A3[F0CB]                		mov	[free_space.space],ax
 38466 0000590D 8B97[23C4]              		mov	dx,[part_table_start_cyl+bx]
 38467 00005911 8916[F2CB]              		mov	[free_space.start],dx
 38468                                  		;mov	[free_space.end],cx
 38469                                  		;mov	cl,[cur_disk]
 38470                                  		;push	cx
 38471                                  		;push	ax
 38472 00005915 5B                      		pop	bx ; **
 38473 00005916 89DE                    		mov	si,bx ; **
 38474                                  			; bx = drive number (0 to 7)
 38475                                  			; ax = cylinders
 38476 00005918 E84BBC                  		call	cylinders_to_mbytes
 38477                                  		;pop	bx
 38478                                  		;pop	bx
 38479 0000591B A3[F6CB]                		mov	[free_space.mbytes_unused],ax
 38480                                  		
 38481                                  		;mov	al,[cur_disk]
 38482                                  		;cbw
 38483                                  		;mov	bx,ax
 38484                                  		;shl	bx,1
 38485 0000591E D1E6                    		shl	si,1 ; **
 38486                                  		;push	word [total_disk+bx]
 38487 00005920 8B8C[C6A0]              		mov	cx,[total_disk+si]
 38488                                  		;push	word [free_space.space]
 38489 00005924 8B1E[F0CB]              		mov	bx,[free_space.space] 	
 38490                                  			; cx = total (disk) cylinders -divisor-
 38491                                  			; bx = num of cylinders (of partition) -dividend-
 38492 00005928 E88EBC                  		call	cylinders_to_percent
 38493                                  		;pop	bx
 38494                                  		;pop	bx
 38495 0000592B A3[F8CB]                		mov	[free_space.percent_unused],ax
 38496                                  fefs_12:
 38497                                  		;mov	word [fefs_temp],0
 38498                                  fefs_13:
 38499                                  	;/* Find largest free space, and verify the golden tracks while we are at it */
 38500                                  
 38501 0000592E C746FA0000              		mov	word [fefs_temp],0
 38502                                  
 38503                                  		; /* Zip thru the table */
 38504                                  
 38505 00005933 C646F400                		mov	byte [fefs_i],0
 38506                                  fefs_14:
 38507                                  		;mov	al,22
 38508 00005937 B00A                    		mov	al,10
 38509                                  		;imul	byte [fefs_i]
 38510 00005939 F666F4                  		mul	byte [fefs_i]
 38511 0000593C 89C3                    		mov	bx,ax
 38512                                  		;mov	ax,[fefs_temp]
 38513 0000593E 8B87[F0CB]              		mov	ax,[free_space.space+bx]
 38514                                  		;cmp	[free_space.space+bx],ax
 38515 00005942 3B46FA                  		cmp	ax,[fefs_temp]
 38516 00005945 7609                    		jbe	short fefs_15
 38517                                  		;mov	ax,[free_space.space+bx]
 38518 00005947 8946FA                  		mov	[fefs_temp],ax
 38519 0000594A 8A46F4                  		mov	al,[fefs_i]
 38520 0000594D 8846F8                  		mov	[fefs_last_found_part],al
 38521                                  fefs_15:
 38522 00005950 FE46F4                  		inc	byte [fefs_i]
 38523 00005953 807EF418                		cmp	byte [fefs_i],24
 38524 00005957 72DE                    		jb	short fefs_14
 38525                                  
 38526                                  		;/* If there is any free space, go verify it */
 38527                                  
 38528 00005959 C746FA0000              		mov	word [fefs_temp],0
 38529                                  
 38530                                  		;mov	al,22
 38531 0000595E B00A                    		mov	al,10
 38532                                  		;imul	byte [fefs_last_found_part]
 38533 00005960 F666F8                  		mul	byte [fefs_last_found_part]
 38534 00005963 89C3                    		mov	bx,ax
 38535                                  
 38536 00005965 83BF[F0CB]00            		cmp	word [free_space.space+bx],0
 38537 0000596A 740D                    		je	short fefs_16
 38538                                  
 38539                                  		;/* Go verify the tracks */
 38540                                  
 38541 0000596C B005                    		mov	al,5 ; EXTENDED  ; type
 38542 0000596E 50                      		push	ax
 38543 0000596F 8A46F8                  		mov	al,[fefs_last_found_part] ; pointer
 38544 00005972 50                      		push	ax
 38545 00005973 E87201                  		call	verify_tracks
 38546                                  		;pop	bx
 38547                                  		;pop	bx
 38548 00005976 8946FA                  		mov	[fefs_temp],ax
 38549                                  fefs_16:
 38550                                  		;/* Move up to next golden track */
 38551                                  
 38552                                  		;mov	al,22
 38553 00005979 B00A                    		mov	al,10
 38554                                  		;imul	byte [fefs_last_found_part]
 38555 0000597B F666F8                  		mul	byte [fefs_last_found_part]
 38556                                  		;mov	bx,ax
 38557 0000597E 89C6                    		mov	si,ax
 38558 00005980 8B46FA                  		mov	ax,[fefs_temp]
 38559                                  		;add	[free_space.start+bx],ax
 38560 00005983 0184[F2CB]              		add	[free_space.start+si],ax
 38561                                  
 38562                                  		;mov	cl,[cur_disk]
 38563                                  		;push	cx
 38564                                  		;sub	[free_space.space+bx],ax
 38565                                  		;push	word [free_space.space+bx]
 38566                                  		;mov	si,bx
 38567 00005987 30FF                    		xor	bh,bh
 38568 00005989 8A1E[E2CB]              		mov	bl,[cur_disk]
 38569 0000598D 53                      		push	bx ; --*
 38570 0000598E 2984[F0CB]              		sub	[free_space.space+si],ax
 38571 00005992 8B84[F0CB]              		mov	ax,[free_space.space+si]
 38572                                  			; bx = drive number (0 to 7)
 38573                                  			; ax = cylinders
 38574 00005996 E8CDBB                  		call	cylinders_to_mbytes
 38575                                  		;pop	bx
 38576                                  		;pop	bx
 38577 00005999 8984[F6CB]              		mov	[free_space.mbytes_unused+si],ax
 38578                                  
 38579                                  		;mov	al,[cur_disk]
 38580                                  		;cbw
 38581                                  		;mov	bx,ax
 38582 0000599D 5B                      		pop	bx; --*
 38583                                  		;shl	bx,1
 38584 0000599E D0E3                    		shl	bl,1
 38585                                  		;push	word [total_disk+bx]
 38586 000059A0 8B8F[C6A0]              		mov	cx,[total_disk+bx]
 38587                                  		;push	word [free_space.space+si]
 38588 000059A4 8B9C[F0CB]              		mov	bx,[free_space.space+si]
 38589                                  			; cx = total (disk) cylinders -divisor-
 38590                                  			; bx = num of cylinders (of partition) -dividend-
 38591 000059A8 E80EBC                  		call	cylinders_to_percent
 38592                                  		;pop	bx
 38593                                  		;pop	bx
 38594 000059AB 8984[F8CB]              		mov	[free_space.percent_unused+si],ax
 38595                                  
 38596                                  	;/* Repeat the loop if the start was moved due to bad tracks */
 38597                                          ;/* Unless we're past the end of the free space */
 38598                                  
 38599 000059AF 31C0                    		xor	ax,ax ; 20/01/2019
 38600                                  
 38601                                  		;cmp	word [fefs_temp],0
 38602 000059B1 3946FA                  		cmp	[fefs_temp],ax ; 0
 38603 000059B4 7409                    		je	short fefs_17
 38604                                  
 38605                                  		;;mov	al,22
 38606                                  		;mov	al,10
 38607                                  		;;imul	byte [fefs_last_found_part]
 38608                                  		;mul	byte [fefs_last_found_part]
 38609                                  		;mov	bx,ax
 38610                                  		;;cmp	word [free_space.space+bx],0
 38611                                  		;cmp	word [free_space.space+si],0
 38612 000059B6 3984[F0CB]              		cmp	[free_space.space+si],ax ; 0
 38613 000059BA 7403                    		je	short fefs_17
 38614 000059BC E96FFF                  		jmp	fefs_13
 38615                                  fefs_17:
 38616                                  	;/* Don't create a partition larger than DOS can handle */ 
 38617                                  
 38618 000059BF E97BF9                  		jmp	fefs_18  ; 20/01/2019
 38619                                  
 38620                                  ;		;;mov	al,22
 38621                                  ;		;mov	al,10
 38622                                  ;		;;imul	byte [fefs_last_found_part]
 38623                                  ;		;mul	byte [fefs_last_found_part]
 38624                                  ;		;mov	bx,ax
 38625                                  ;
 38626                                  ;		;cmp	[free_space.mbytes_unused+bx],2048
 38627                                  ;		cmp	[free_space.mbytes_unused+si],2048  ; 2 GB limit
 38628                                  ;		jbe	short fefs_18
 38629                                  ;
 38630                                  ;		mov	al,[cur_disk]
 38631                                  ;		; ah = 0
 38632                                  ;
 38633                                  ;		push	ax ; *
 38634                                  ;		
 38635                                  ;		push	ax
 38636                                  ;		mov	ax,2048
 38637                                  ;		push	ax
 38638                                  ;		mov	si,bx
 38639                                  ;		call	mbytes_to_cylinders
 38640                                  ;		;pop	bx
 38641                                  ;		;pop	bx
 38642                                  ;
 38643                                  ;		pop	di ; *
 38644                                  ;
 38645                                  ;		dec	ax
 38646                                  ;
 38647                                  ;		mov	[free_space.space+si],ax
 38648                                  ;
 38649                                  ;		;mov	ax,[free_space.start+si]
 38650                                  ;		;add	ax,[free_space.space+si]
 38651                                  ;
 38652                                  ;		add	ax,[free_space.start+si]
 38653                                  ;
 38654                                  ;		dec	ax
 38655                                  ;		mov	[free_space.end+si],ax
 38656                                  ;
 38657                                  ;		;mov	al,[cur_disk]
 38658                                  ;		;push	ax
 38659                                  ;		;push	word [free_space.space+si]
 38660                                  ;		mov	ax,[free_space.space+si]
 38661                                  ;		mov	bx,di ; *
 38662                                  ;		call	cylinders_to_mbytes
 38663                                  ;		;pop	bx
 38664                                  ;		;pop	bx
 38665                                  ;
 38666                                  ;		mov	[free_space.mbytes_unused+si],ax
 38667                                  ;
 38668                                  ;		;mov	al,[cur_disk]
 38669                                  ;		;cbw
 38670                                  ;		;mov	bx,ax
 38671                                  ;		;shl	bx,1
 38672                                  ;		;push	word [total_disk+bx]
 38673                                  ;		shl	di,1 ; *
 38674                                  ;		mov	cx,[total_disk+di]
 38675                                  ;		;push	word [free_space.space+si]
 38676                                  ;		mov	bx,[free_space.space+si]
 38677                                  ;		call	cylinders_to_percent
 38678                                  ;		;pop	bx
 38679                                  ;		;pop	bx
 38680                                  ;		mov	[free_space.percent_unused+si],ax
 38681                                  ;fefs_18:
 38682                                  ;		mov	al,[fefs_last_found_part] ; mov al,[bp-8]
 38683                                  ;
 38684                                  ;		;pop	si
 38685                                  ;		;pop	di
 38686                                  ;
 38687                                  ;		mov	sp,bp
 38688                                  ;		pop	bp
 38689                                  ;		retn
 38690                                  
 38691                                  ; ----------------------------------------------------------------------------
 38692                                  ; makepart.c (FDISK, MSDOS 6.0, 1991)	
 38693                                  ; ----------------------------------------------------------------------------
 38694                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 21/01/2019)
 38695                                  
 38696                                  ;char make_volume(size,free_pointer)
 38697                                  ;
 38698                                  ;unsigned    size;
 38699                                  ;char   free_pointer;
 38700                                  ;
 38701                                  ;BEGIN
 38702                                  ;
 38703                                  ;    char table_pointer;
 38704                                  ;    unsigned ext_part_num;                                        /* AN000 */
 38705                                  ;    unsigned char   temp;
 38706                                  ;    unsigned long   total_sectors;
 38707                                  ;
 38708                                  ;    /* Find a free spot to put it in */
 38709                                  ;    table_pointer = find_free_ext();
 38710                                  ;
 38711                                  ;    if (table_pointer != ((char)(NOT_FOUND)))
 38712                                  ;       BEGIN
 38713                                  ;        /* found a free partition, now lets go fill it up */
 38714                                  ;
 38715                                  ;        /* This can never be marked active */
 38716                                  ;        ext_table[cur_disk][table_pointer].boot_ind = uc(0);     /* AC000 */
 38717                                  ;
 38718                                  ;        /* Go get the start cylinder */
 38719                                  ;        ext_table[cur_disk][table_pointer].start_cyl = free_space[free_pointer].start;
 38720                                  ;
 38721                                  ;        /* Setup end cylinder */
 38722                                  ;        ext_table[cur_disk][table_pointer].end_cyl = ext_table[cur_disk][table_pointer].start_cyl + size - 1;
 38723                                  ;
 38724                                  ;        /* Start sector is always 1 */
 38725                                  ;        ext_table[cur_disk][table_pointer].start_sector = uc(1);  /* AC000 */
 38726                                  ;
 38727                                  ;        /* End sector is always the last sector */
 38728                                  ;        ext_table[cur_disk][table_pointer].end_sector = max_sector[cur_disk];
 38729                                  ;
 38730                                  ;        /* End head is always the last head */
 38731                                  ;        ext_table[cur_disk][table_pointer].end_head = uc(max_head[cur_disk]-1);  /* AC004 */
 38732                                  ;
 38733                                  ;        /* Start head is always 1 - NOTE: This is a shortcut for PC-DOS */
 38734                                  ;        /* If this is being modified for IFS drivers this may not be the */
 38735                                  ;        /* the case - use caution */
 38736                                  ;        ext_table[cur_disk][table_pointer].start_head = uc(1);   /* AC000 */
 38737                                  ;
 38738                                  ;        /* Figure out the total number of sectors */
 38739                                  ;        /* Total sectors in partition =                    */
 38740                                  ;        /* [(end_cyl - start_cyl)*(max_sector)*(max_head)] */
 38741                                  ;        /* - [start_head * max_sector]                     */
 38742                                  ;        /* Note: This is assuming a track or cylinder aligned partition */
 38743                                  ;
 38744                                  ;        /* First - get the total size in Cylinders assuming head 0 start*/
 38745                                  ;        total_sectors = ((unsigned long)(ext_table[cur_disk][table_pointer].end_cyl -
 38746                                  ;          ext_table[cur_disk][table_pointer].start_cyl+1));
 38747                                  ;
 38748                                  ;        /* Now multiply it by the number of sectors and heads per track */
 38749                                  ;        total_sectors = total_sectors * max_sector[cur_disk] * max_head[cur_disk];
 38750                                  ;
 38751                                  ;        /* This will give us the total of sectors if it is cyl aligned */
 38752                                  ;        /* Now, if it isn't aligned on head 0, we need to subtract off */
 38753                                  ;        /* the skipped tracks in the first cylinder  */
 38754                                  ;
 38755                                  ;        /* Because the head is zero based, we can get the total number of */
 38756                                  ;        /* skipped sectors by multipling the head number by sectors per track */
 38757                                  ;        total_sectors = total_sectors - ((unsigned long)(ext_table[cur_disk][table_pointer].start_head *
 38758                                  ;                           max_sector[cur_disk]));
 38759                                  ;
 38760                                  ;        ext_table[cur_disk][table_pointer].num_sec = total_sectors;
 38761                                  ;
 38762                                  ;        /* Get the relative sector */
 38763                                  ;        /* Figure out the total number of sectors */
 38764                                  ;        /* Total sectors before partition = max_sector     */
 38765                                  ;        /* NOTE: Again, this is a PC-DOS 3.30 shortcut - by definition */
 38766                                  ;        /* a logical drive always starts on head 1, so there is always */
 38767                                  ;        /* one tracks worth of sectors before it. Hence, max_sector */
 38768                                  ;
 38769                                  ;        /* Save it! */
 38770                                  ;        ext_table[cur_disk][table_pointer].rel_sec = ((unsigned long)(max_sector[cur_disk]));
 38771                                  ;
 38772                                  ;        /* Setup the system id byte */
 38773                                  ;        /* Set to 06h - format will fix later on */
 38774                                  ;        /* EGH; 7/03/90; We fix up the size ourselves here. The
 38775                                  ;           calculation is simple. If total_sectors > 65536 then
 38776                                  ;           type = 06 else if total_sectors > 32680 then type = 04
 38777                                  ;           else type = 01 */
 38778                                  ;
 38779                                  ;        if (ext_table[cur_disk][table_pointer].num_sec > ul(65536))     /*C23*/
 38780                                  ;            temp = uc(DOSNEW);                                         /* AC000 */                                    /*  AN000  */
 38781                                  ;        else if (ext_table[cur_disk][table_pointer].num_sec > ul(FAT16_SIZE)) /*C23*/
 38782                                  ;            temp = uc(DOS16);                                           /*C23*/
 38783                                  ;        else                                                            /*C23*/
 38784                                  ;            temp = uc(DOS12);                                           /*C23*/
 38785                                  ;
 38786                                  ;        /* We got the sys id, now put it in */
 38787                                  ;        ext_table[cur_disk][table_pointer].sys_id = temp;
 38788                                  ;
 38789                                  ;        /* Set the changed flag */
 38790                                  ;        ext_table[cur_disk][table_pointer].changed = TRUE;
 38791                                  ;
 38792                                  ;        /* Set the mbytes used */
 38793                                  ;        ext_table[cur_disk][table_pointer].mbytes_used =
 38794                                  ;            cylinders_to_mbytes(size,cur_disk);                   /* AN004 */
 38795                                  ;
 38796                                  ;        /* find the number of the extended partition to figure out percent */
 38797                                  ;        ext_part_num = find_partition_location(uc(EXTENDED));              /* AN000 */
 38798                                  ;
 38799                                  ;        /* Set the percent used */
 38800                                  ;        ext_table[cur_disk][table_pointer].percent_used =
 38801                                  ;            cylinders_to_percent(((ext_table[cur_disk][table_pointer].end_cyl-ext_table[cur_disk][table_pointer].start_cyl)+1),
 38802                                  ;            ((part_table[cur_disk][ext_part_num].end_cyl-part_table[cur_disk][ext_part_num].start_cyl)+1)); /* AN000 */
 38803                                  ;
 38804                                  ;        /* set the system to unknown and volume label to blanks */
 38805                                  ;        strcpy(ext_table[cur_disk][table_pointer].system,NOFORMAT);     /* AN000 */
 38806                                  ;        strcpy(ext_table[cur_disk][table_pointer].vol_label,NOVOLUME);  /* AN000 */
 38807                                  ;
 38808                                  ;       END
 38809                                  ;    else
 38810                                  ;
 38811                                  ;       BEGIN
 38812                                  ;        /* This should not have happened */
 38813                                  ;        internal_program_error();
 38814                                  ;       END
 38815                                  ;
 38816                                  ;    return(table_pointer);
 38817                                  ;END
 38818                                  
 38819                                  make_volume:
 38820                                  		; 21/01/2019
 38821                                  
 38822                                  	;%define mv_total_secs_lw 	;bp-10	;bp-14
 38823                                  	;%define mv_total_secs_hw 	;bp-8	;bp-12
 38824                                  	%define mv_table_ptr	bp-2 	;bp-6	;bp-10
 38825                                  	;%define mv_ext_part_num 	;bp-4	;bp-8
 38826                                  	;%define mv_temp	 	;bp-2	;bp-6
 38827                                  
 38828                                  	%define mv_size		bp+4
 38829                                  	%define mv_free_ptr	bp+6
 38830                                  
 38831 000059C2 55                      		push	bp
 38832 000059C3 89E5                    		mov	bp,sp
 38833                                  
 38834                                  		;;;sub	sp,14
 38835                                  		;;sub	sp,10
 38836                                  		;sub	sp,2
 38837                                  
 38838                                  		;xor	ax,ax
 38839 000059C5 50                      		push	ax ; sub sp,2
 38840                                  
 38841                                  		;push	di
 38842                                  		;push	si
 38843                                  
 38844                                  		;/* Find a free spot to put it in */
 38845                                  		
 38846 000059C6 E8F900                  		call	find_free_ext
 38847 000059C9 8846FE                  		mov	[mv_table_ptr],al
 38848 000059CC FEC0                    		inc	al
 38849 000059CE 7503                    		jnz	short mv_1
 38850 000059D0 E9E700                  		jmp	mv_8
 38851                                  mv_1:
 38852                                  	;/* found a free partition, now lets go fill it up */
 38853                                  
 38854 000059D3 A0[E2CB]                		mov	al,[cur_disk]
 38855 000059D6 98                      		cbw
 38856                                  		;mov	cx,24
 38857 000059D7 B118                    		mov	cl,24
 38858 000059D9 89C3                    		mov	bx,ax  ; *****
 38859                                  		;imul	cx
 38860 000059DB F6E1                    		mul	cl
 38861                                  		;mov	cx,ax
 38862                                  
 38863                                  		;mov	al,[mv_table_ptr]
 38864                                  		;cbw
 38865                                  		;add	ax,cx
 38866                                  
 38867                                  		; ah = 0
 38868 000059DD 0246FE                  		add	al,[mv_table_ptr]
 38869                                  		
 38870                                  		;mov	cx,46
 38871                                  		;imul	cx
 38872 000059E0 B12E                    		mov	cl,46
 38873 000059E2 F6E1                    		mul	cl
 38874                                  
 38875 000059E4 89C6                    		mov	si,ax ; *-+*
 38876                                  
 38877                                  		;/* This can never be marked active */
 38878 000059E6 C684[58A1]00            		mov	byte [ext_table_boot_ind+si],0
 38879                                  
 38880                                  		;/* Go get the start cylinder */
 38881                                  
 38882                                  		;mov	al,22
 38883 000059EB B00A                    		mov	al,10
 38884                                  		;imul	byte [mv_free_ptr]
 38885 000059ED F66606                  		mul	byte [mv_free_ptr]
 38886 000059F0 89C7                    		mov	di,ax
 38887                                  
 38888 000059F2 8B85[F2CB]              		mov	ax,[free_space.start+di]
 38889 000059F6 8984[5BA1]              		mov	[ext_table_start_cyl+si],ax
 38890                                  
 38891                                  		;/* Setup end cylinder */
 38892                                  
 38893 000059FA 034604                  		add	ax,[mv_size]
 38894 000059FD 48                      		dec	ax
 38895 000059FE 8984[60A1]              		mov	[ext_table_end_cyl+si],ax
 38896                                  
 38897                                  		;/* Start sector is always 1 */
 38898                                  
 38899 00005A02 C684[5AA1]01            		mov	byte [ext_table_start_sector+si],1
 38900                                  
 38901                                  		;/* End sector is always the last sector */
 38902                                  
 38903 00005A07 8A87[AEA0]              		mov	al,[max_sector+bx]
 38904                                  		
 38905 00005A0B 28E4                    		sub	ah,ah
 38906 00005A0D 89C7                    		mov	di,ax ; -**- ; [start_head * max_sector]  
 38907                                  
 38908 00005A0F 8884[5FA1]              		mov	[ext_table_end_sector+si],al
 38909                                  		
 38910                                  		;/* End head is always the last head */
 38911                                  
 38912 00005A13 D1E3                    		shl	bx,1  ; *****
 38913 00005A15 8A8F[B6A0]              		mov	cl,[max_head+bx] ; num of (disk) heads
 38914 00005A19 88CC                    		mov	ah,cl ; 21/01/2019
 38915 00005A1B FEC9                    		dec	cl
 38916 00005A1D 888C[5EA1]              		mov	[ext_table_end_head+si],cl
 38917                                  
 38918                                  	;/* Start head is always 1 - NOTE: This is a shortcut for PC-DOS */
 38919                                  	;/* If this is being modified for IFS drivers this may not be the */
 38920                                  	;/* the case - use caution */
 38921                                  
 38922 00005A21 C684[59A1]01            		mov	byte [ext_table_start_head+si],1 ; start_head = 1
 38923                                  
 38924                                  	;/* Figure out the total number of sectors */
 38925                                  	;/* Total sectors in partition =                    */
 38926                                  	;/* [(end_cyl - start_cyl)*(max_sector)*(max_head)] */
 38927                                  	;/* - [start_head * max_sector]                     */
 38928                                  	;/* Note: This is assuming a track or cylinder aligned partition */
 38929                                  	;
 38930                                  	;/* First - get the total size in Cylinders assuming head 0 start*/
 38931                                  	;total_sectors = ((unsigned long)(ext_table[cur_disk][table_pointer].end_cyl -
 38932                                  	;          ext_table[cur_disk][table_pointer].start_cyl+1));
 38933                                  		
 38934                                  		;sub	ah,ah
 38935                                  		;mov	cx,ax
 38936                                  		;sub	dx,dx
 38937                                  		;push	dx
 38938                                  		;push	ax
 38939                                  		;mov	di,cx
 38940                                  		;mov	ax,[ext_table_end_cyl+si]
 38941                                  		;sub	ax,[ext_table_start_cyl+si]
 38942                                  		;inc	ax
 38943                                  		;mov	[mv_total_secs_lw],di
 38944                                  		;mov	[mv_total_secs_hw],dx
 38945                                  
 38946                                  	;/* Now multiply it by the number of sectors and heads per track */
 38947                                  	;total_sectors = total_sectors * max_sector[cur_disk] * max_head[cur_disk];
 38948                                  	;
 38949                                  	;/* This will give us the total of sectors if it is cyl aligned */
 38950                                  
 38951                                  
 38952                                  		;mul	word [max_head+bx]
 38953                                  		;push	dx
 38954                                  		;push	ax
 38955                                  		;call	mul32
 38956                                  
 38957                                  		; al = max_sector (sectors per track) <= 63
 38958                                  		; ah = max_head (heads) - 2 to 255
 38959                                  
 38960 00005A26 F6E4                    		mul	ah
 38961                                  			 ; ax <= 16065
 38962                                  
 38963 00005A28 8B8C[60A1]              		mov	cx,[ext_table_end_cyl+si]
 38964 00005A2C 2B8C[5BA1]              		sub	cx,[ext_table_start_cyl+si]
 38965 00005A30 41                      		inc	cx
 38966                                   
 38967 00005A31 F7E1                    		mul	cx
 38968                                  			 ; dx:ax = cylinders*heads*spt 
 38969                                  
 38970                                  	;/* Now, if it isn't aligned on head 0, we need to subtract off */
 38971                                  	;/* the skipped tracks in the first cylinder */
 38972                                  
 38973                                  	;/* Because the head is zero based, we can get the total number of */
 38974                                  	;/* skipped sectors by multipling the head number by sectors per track */
 38975                                  	;total_sectors = total_sectors - ((unsigned long)(ext_table[cur_disk][table_pointer].start_head *
 38976                                  	;                max_sector[cur_disk]));
 38977                                  
 38978 00005A33 31C9                    		xor	cx,cx
 38979                                  
 38980 00005A35 29F8                    		sub	ax,di  ; -**-  ; - [start_head * max_sector]  
 38981                                  		;sbb	dx,0
 38982 00005A37 19CA                    		sbb	dx,cx
 38983                                  
 38984                                  		;mov	cx,ax
 38985                                  		;mov	ax,di
 38986                                  		;mov	bx,dx
 38987                                  		;cwd
 38988                                  		;sub	cx,ax
 38989                                  		;sbb	bx,dx
 38990                                  		;mov	ax,cx
 38991                                  		;mov	dx,bx
 38992                                  		
 38993 00005A39 8984[66A1]              		mov	[ext_table_num_sec_lw+si],ax
 38994 00005A3D 8994[68A1]              		mov	[ext_table_num_sec_hw+si],dx
 38995                                  
 38996                                  	;/* Get the relative sector */
 38997                                  	;/* Figure out the total number of sectors */
 38998                                  	;/* Total sectors before partition = max_sector */
 38999                                  	;/* NOTE: Again, this is a PC-DOS 3.30 shortcut - by definition */
 39000                                  	;/* a logical drive always starts on head 1, so there is always */
 39001                                  	;/* one tracks worth of sectors before it. Hence, max_sector */
 39002                                  		
 39003                                  		;mov	ax,[mv_total_secs_lw]
 39004                                  		;mov	dx,[mv_total_secs_hw]
 39005                                  		;mov	[ext_table_rel_sec_lw+si],ax
 39006                                  		;mov	[ext_table_rel_sec_hw+si],dx
 39007                                  
 39008                                  		;/* Save it! */
 39009                                  
 39010 00005A41 89BC[62A1]              		mov	[ext_table_rel_sec_lw+si],di ; -**- ; max_sector
 39011                                  		;mov	word [ext_table_rel_sec_hw+si],0
 39012 00005A45 898C[64A1]              		mov	[ext_table_rel_sec_hw+si],cx ; 0
 39013                                  
 39014                                  mkvol_chk_fat16_limit:
 39015                                  		;/* Setup the system id byte */
 39016                                  		;/* Set to 06h - format will fix later on */
 39017                                  		;/* EGH; 7/03/90; We fix up the size ourselves here.
 39018                                  		; The calculation is simple. If total_sectors > 65536 then
 39019                                  		; type = 06 else if total_sectors > 32680 then type = 04
 39020                                  		; else type = 01 */
 39021                                  
 39022                                  		;cmp	word [ext_table_num_sec_hw+si],1
 39023 00005A49 83FA01                  		cmp	dx,1
 39024                                  		;jb	short mkvol_chk_fat12_limit
 39025 00005A4C 720A                    		jb	short mv_10
 39026 00005A4E 7704                    		ja	short mkvol_fat16big
 39027                                  		;cmp	word [ext_table_num_sec_lw+si],0
 39028                                  		;je	short mkvol_chk_fat12_limit
 39029                                  		
 39030 00005A50 21C0                    		and	ax,ax
 39031                                  		;jz	short mkvol_chk_fat12_limit
 39032 00005A52 7409                    	 	jz	short mkvol_fat16 ; partition size: 65536 sectors
 39033                                  mkvol_fat16big:
 39034                                  		;mov	byte [mv_temp],6  ; DOSNEW
 39035 00005A54 B006                    		mov	al,6
 39036 00005A56 EB0B                    		jmp	short mv_7
 39037                                  mkvol_chk_fat12_limit:
 39038                                  		;mov	al,[mv_table_ptr]
 39039                                  		;cbw
 39040                                  		;mov	cx,ax
 39041                                  		;mov	al,24
 39042                                  		;;imul	byte [cur_disk]
 39043                                  		;mul	byte [cur_disk]
 39044                                  		;add	ax,cx
 39045                                  		;mov	cx,46
 39046                                  		;imul	cx
 39047                                  		;mov	bx,ax
 39048                                  
 39049                                  		;;cmp	word [ext_table_num_sec_hw+bx],0
 39050                                  		;cmp	word [ext_table_num_sec_hw+si],0
 39051                                  		;jne	short mkvol_fat16
 39052                                  
 39053                                  		;and	dx,dx
 39054                                  		;jnz	short mkvol_fat16
 39055                                  mv_10:
 39056                                  		;;cmp	word [ext_table_num_sec_lw+bx],32680 ; FAT12 upper limit
 39057                                  		;cmp	word [ext_table_num_sec_lw+si],32680
 39058                                  		;jbe	short mkvol_fat12
 39059 00005A58 3DA87F                  		cmp	ax,32680
 39060 00005A5B 7604                    		jbe	short mkvol_fat12
 39061                                  mkvol_fat16:
 39062                                  		;mov	byte [mv_temp],4 ; DOS16
 39063 00005A5D B004                    		mov	al,4
 39064 00005A5F EB02                    		jmp	short mv_7
 39065                                  mkvol_fat12:
 39066                                  		;mov	byte [mv_temp],1 ; DOS12
 39067 00005A61 B001                    		mov	al,1
 39068                                  mv_7:
 39069                                  		;mov	al,[mv_table_ptr]
 39070                                  		;cbw
 39071                                  		;mov	cx,ax
 39072                                  		;mov	al,24
 39073                                  		;;imul	byte [cur_disk]
 39074                                  		;mul	byte [cur_disk]
 39075                                  		;add	ax,cx
 39076                                  		;;mov	bx,46
 39077                                  		;mov	bl,46
 39078                                  		;;imul	bx
 39079                                  		;mul	bl
 39080                                  		;mov	si,ax
 39081                                  
 39082                                  		;/* We got the sys id, now put it in */
 39083                                  
 39084                                  		;mov	al,[mv_temp]
 39085 00005A63 8884[5DA1]              		mov	[ext_table_sys_id+si],al
 39086                                  
 39087                                  		;/* Set the changed flag */
 39088                                  
 39089 00005A67 C684[6BA1]01            		mov	byte [ext_table_changed+si],1
 39090                                  
 39091                                  		;/* Set the mbytes used */
 39092                                  
 39093                                  		;mov	al,[cur_disk]
 39094                                  		;push	ax
 39095                                  		; bh = 0
 39096                                  		;mov	bl,[cur_disk]
 39097                                  		;;xor	bh,bh
 39098                                  
 39099 00005A6C D0EB                    		shr	bl,1 ; ***** 
 39100                                  			; bl = [cur_disk]
 39101                                  			; bh = 0 
 39102                                  
 39103                                  		;push	word [mv_size]
 39104                                  		;mov	di,cx
 39105 00005A6E 8B4604                  		mov	ax,[mv_size]
 39106 00005A71 E8F2BA                  		call	cylinders_to_mbytes
 39107                                  		;pop	bx
 39108                                  		;pop	bx
 39109 00005A74 8984[6CA1]              		mov	[ext_table_mbytes_used+si],ax
 39110                                  
 39111                                  	;/* find the number of the extended partition to figure out percent */
 39112                                  
 39113                                  		;mov	al,5 ; EXTENDED
 39114                                  		;push	ax
 39115                                  		;call	find_partition_location
 39116                                  		;pop	bx
 39117                                  		;cbw
 39118                                  		;mov	[mv_ext_part_num],ax
 39119                                  
 39120                                  		; get partition entry number of extended dos partion
 39121                                   		; 	(on current disk/drive)
 39122 00005A78 B005                    		mov	al,5  ; EXTENDED partition ID
 39123 00005A7A E847C3                  		call	find_partition_type
 39124                                  		; cl = partition number (index), 0 to 3 or 4 (not found)
 39125                                  
 39126                                  		;mov	[mv_ext_part_num],cl ; ***
 39127                                  
 39128                                  		;/* Set the percent used */
 39129                                  
 39130 00005A7D A0[E2CB]                		mov	al,[cur_disk]
 39131                                  		;cbw
 39132                                  		;mov	cx,ax
 39133                                  		
 39134                                  		;shl	ax,1
 39135                                  		;shl	ax,1
 39136 00005A80 D0E0                    		shl	al,1
 39137 00005A82 D0E0                    		shl	al,1		
 39138                                  
 39139                                  		;add	ax,[mv_ext_part_num]
 39140 00005A84 00C8                    		add	al,cl ; ***		
 39141                                  
 39142                                  		;mov	bx,46
 39143                                  		;mul	bx
 39144 00005A86 B12E                    		mov	cl,46
 39145 00005A88 F6E1                    		mul	cl
 39146 00005A8A 89C3                    		mov	bx,ax
 39147                                  
 39148                                  		;mov	ax,[part_table_end_cyl+bx]
 39149                                  		;sub	ax,[part_table_start_cyl+bx]
 39150                                  		;inc	ax
 39151                                  		;push	ax
 39152                                  
 39153 00005A8C 8B8F[28C4]              		mov	cx,[part_table_end_cyl+bx]
 39154 00005A90 2B8F[23C4]              		sub	cx,[part_table_start_cyl+bx]
 39155 00005A94 41                      		inc	cx  ; extended dos partition cylinders
 39156                                  
 39157                                  		;;mov	bx,24
 39158                                  		;mov	al,24
 39159                                  		;;mov	ax,cx
 39160                                  		;;imul	bx
 39161                                  		;mul	byte [cur_disk]
 39162                                  		;;add	ax,di
 39163                                  		;add	al,[mv_table_ptr]
 39164                                  		;;mov	cx,46
 39165                                  		;;imul	cx
 39166                                  		;mov	cl,46
 39167                                  		;mul	cl
 39168                                  		;mov	si,ax
 39169                                  
 39170                                  		;mov	ax,[ext_table_end_cyl+si]
 39171                                  		;sub	ax,[ext_table_start_cyl+si]
 39172                                  		;inc	ax
 39173                                  		;push	ax
 39174                                  
 39175 00005A95 8B9C[60A1]              		mov	bx,[ext_table_end_cyl+si]
 39176 00005A99 2B9C[5BA1]              		sub	bx,[ext_table_start_cyl+si]
 39177 00005A9D 43                      		inc	bx  ; dos volume cylinders
 39178 00005A9E E818BB                  		call	cylinders_to_percent
 39179                                  		;pop	bx
 39180                                  		;pop	bx
 39181 00005AA1 8984[6EA1]              		mov	[ext_table_percent_used+si],ax
 39182                                  
 39183                                  	;/* set the system to unknown and volume label to blanks */
 39184                                  		
 39185                                  		;mov	ax,_NOFORMAT ; "UNKNOWN	"
 39186                                  		;push	ax
 39187                                  		
 39188                                  		;mov	al,24
 39189                                  		;;imul	byte [cur_disk]
 39190                                  		;mul	byte [cur_disk]
 39191                                  		;add	ax,di
 39192                                  		;;mov	cx,46
 39193                                  		;mov	cl,46
 39194                                  		;;imul	cx
 39195                                  		;mul	cl
 39196                                  
 39197                                  		;add	ax,ext_table_system
 39198                                  		;push	ax
 39199                                  		
 39200 00005AA5 89F3                    		mov	bx,si ; *
 39201                                  
 39202 00005AA7 BE[5370]                		mov	si,NO_FORMAT ; 'UNKNOWN ' ; source 
 39203 00005AAA 89DF                    		mov	di,bx ; *
 39204 00005AAC 81C7[7CA1]              		add	di,ext_table_system ; destination 
 39205                                  
 39206 00005AB0 E87AC2                  		call	strcpy
 39207                                  		;pop	bx
 39208                                  		;pop	bx
 39209                                  
 39210                                  		;mov	ax,NOVOLUME
 39211                                  		;push	ax
 39212                                  
 39213                                  		;mov	al,24
 39214                                  		;;imul	byte [cur_disk]
 39215                                  		;mul	byte [cur_disk]
 39216                                  		;add	ax,di
 39217                                  		;mov	cx,46
 39218                                  		;imul	cx
 39219                                  
 39220                                  		;add	ax,ext_table_vol_label
 39221                                  		;push	ax
 39222                                  		;call	strcpy
 39223                                  		;pop	bx
 39224                                  		;pop	bx
 39225                                  		
 39226                                  		;mov	di,bx ; *
 39227                                  		;mov	byte [di+ext_table_vol_label],0 ; NOVOLUME
 39228 00005AB3 C687[70A1]00            		mov	byte [bx+ext_table_vol_label],0
 39229                                  
 39230 00005AB8 EB03                    		jmp	short mv_9
 39231                                  mv_8:
 39232                                  		;/* This should not have happened */
 39233 00005ABA E85ED8                  		call	internal_program_error
 39234                                  mv_9:
 39235                                  		;mov	al,[mv_table_ptr]
 39236                                  		
 39237                                  		;pop	si
 39238                                  		;pop	di
 39239                                  			   ; sp = bp-2	
 39240 00005ABD 58                      		pop	ax ; mov al,[mv_table_ptr] ; mov al,[bp-2]
 39241                                  			   ; mov sp,bp	
 39242                                  		
 39243                                  		;mov	sp,bp
 39244 00005ABE 5D                      		pop	bp
 39245                                  		;retn
 39246 00005ABF C20400                  		retn	4
 39247                                  
 39248                                  ; ----------------------------------------------------------------------------
 39249                                  ; partinfo.c (FDISK, MSDOS 6.0, 1991)	
 39250                                  ; ----------------------------------------------------------------------------
 39251                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 21/01/2019)
 39252                                  
 39253                                  ;char find_free_ext()
 39254                                  ;
 39255                                  ;BEGIN
 39256                                  ;
 39257                                  ; char   i;
 39258                                  ;
 39259                                  ;    /* Look at all 23 extended entries for empty partition */
 39260                                  ;    for (i = c(0); i < c(23);i++) 				/* AC000 */
 39261                                  ;       BEGIN
 39262                                  ;        /* if we find an empty one, return which one */
 39263                                  ;        if (ext_table[cur_disk][i].sys_id == uc(0))		/* AC000 */
 39264                                  ;           BEGIN
 39265                                  ;            return(i);
 39266                                  ;            break;
 39267                                  ;           END
 39268                                  ;       END
 39269                                  ;    return(c(NOT_FOUND));					/* AC000 */
 39270                                  ;END
 39271                                  
 39272                                  find_free_ext:
 39273                                  		; 21/01/2019
 39274                                  
 39275                                  	;%define ffe_i bp-2
 39276                                  
 39277                                  		;push	bp
 39278                                  		;mov	bp,sp
 39279                                  		;sub	sp,2
 39280                                  
 39281                                  		;mov	byte [ffe_i],0
 39282                                  		;xor	cx,cx
 39283 00005AC2 30C9                    		xor	cl,cl
 39284 00005AC4 EB07                    		jmp	short ffe_2
 39285                                  ffe_1:
 39286                                  		;inc	byte [ffe_i]
 39287 00005AC6 FEC1                    		inc	cl
 39288                                  ;ffe_2:
 39289                                  		;cmp	byte [ffe_i],23
 39290                                  		;jge	short ffe_3
 39291 00005AC8 80F917                  		cmp	cl,23
 39292 00005ACB 7318                    		jnb	short ffe_3
 39293                                  ffe_2:
 39294                                  		;mov	al,[ffe_i]
 39295                                  		;cbw
 39296                                  		;mov	cx,ax
 39297 00005ACD B018                    		mov	al,24
 39298                                  		;imul	byte [cur_disk]
 39299 00005ACF F626[E2CB]              		mul	byte [cur_disk]
 39300                                  		;add	ax,cx
 39301 00005AD3 00C8                    		add	al,cl
 39302                                  		;mov	cx,46
 39303                                  		;imul	cx
 39304 00005AD5 B32E                    		mov	bl,46
 39305 00005AD7 F6E3                    		mul	bl
 39306 00005AD9 89C3                    		mov	bx,ax
 39307 00005ADB 80BF[5DA1]00            		cmp	byte [ext_table_sys_id+bx],0
 39308 00005AE0 75E4                    		jne	short ffe_1
 39309                                  		;mov	al,[ffe_i]
 39310 00005AE2 88C8                    		mov	al,cl
 39311                                  		;jmp	short ffe_4
 39312 00005AE4 C3                      		retn
 39313                                  ffe_3:
 39314 00005AE5 B0FF                    		mov	al,0FFh	; NOT_FOUND
 39315                                  ffe_4:
 39316                                  		;mov	sp,bp
 39317                                  		;pop	bp
 39318                                  		
 39319 00005AE7 C3                      		retn
 39320                                  
 39321                                  ; ----------------------------------------------------------------------------
 39322                                  ; int13.c (FDISK, MSDOS 6.0, 1991)	
 39323                                  ; ----------------------------------------------------------------------------
 39324                                  ; Modified and simplified for Assembly language (by Erdogan Tan, 26/01/2019)
 39325                                  
 39326                                  ; 28/01/2019
 39327                                  
 39328                                  ;/*  */
 39329                                  ;unsigned verify_tracks(pointer,type)
 39330                                  ;
 39331                                  ;char pointer;
 39332                                  ;char type;
 39333                                  ;
 39334                                  ;BEGIN
 39335                                  ;  unsigned	i;
 39336                                  ;
 39337                                  ;  /* SR; 9/29/89; Temp store */
 39338                                  ;  unsigned	j;
 39339                                  ;  unsigned	sectors_per_fat;
 39340                                  ;  unsigned	cur_cyl;
 39341                                  ;  unsigned	verify_cyl;
 39342                                  ;  unsigned	num_tracks;
 39343                                  ;  unsigned	retry_flg;
 39344                                  ;  unsigned	long   total_sectors;
 39345                                  ;  char	golden_tracks;
 39346                                  ;  char	retry;
 39347                                  ;  unsigned char cur_head;					     /* AC004 */
 39348                                  ;
 39349                                  ;  char far *buffer_pointer = boot_record;
 39350                                  ;
 39351                                  ;  for (i=u(0); i< u(BYTES_PER_SECTOR);i++)                        /* AC000 */
 39352                                  ;     BEGIN
 39353                                  ;      /* Put something other then 0's so that unformatted FAT looks full */
 39354                                  ;
 39355                                  ;      boot_record[i] = uc(0xF6);                                /* AC000 */
 39356                                  ;     END
 39357                                  ;
 39358                                  ;  /* Get the start cylinder for the sweep */
 39359                                  ;  cur_cyl = free_space[pointer].start;
 39360                                  ;
 39361                                  ;  /* Also keep track of what it is */
 39362                                  ;  verify_cyl = cur_cyl;
 39363                                  ;
 39364                                  ;  /* Initialize the start head -assume 0*/
 39365                                  ;  cur_head = uc(0);                                             /* AC004 */
 39366                                  ;
 39367                                  ;  /* SR; 9/29/89; cur_head should be 1 for extended partitions too */
 39368                                  ;  if (((type == c(PRIMARY)) && (cur_cyl == u(0))) || type == c(EXTENDED))  /* AC000 */
 39369                                  ;    BEGIN
 39370                                  ;
 39371                                  ;     /* It's head 1 - NOTE: This is convience for PC-DOS because it is */
 39372                                  ;     /* always this way - This may have to be beefed up for IFS  */
 39373                                  ;     cur_head = uc(1);                                          /* AC004 */
 39374                                  ;    END
 39375                                  ;
 39376                                  ;  /* Now go figure out the number of golden sectors needed. Use the */
 39377                                  ;  /* allocation equation in the fixed disk section of DOS Tech Ref. */
 39378                                  ;  /*                                                                */
 39379                                  ;  /*  TS = Free cyl's * sector/track * track/cyl                    */
 39380                                  ;  /*  RS = 1                                                        */
 39381                                  ;  /*  D  = 512                                                      */
 39382                                  ;  /*  BPD = 32                                                      */
 39383                                  ;  /*  BPS = BYTES_PER_SECTOR                                        */
 39384                                  ;  /*  CF = 2                                                        */
 39385                                  ;  /*  SPF = Solve                                                   */
 39386                                  ;  /*  SPC = 4 or 8                                                  */
 39387                                  ;  /*  BPC = 1.5 or 2                                                */
 39388                                  ;  /*                                                                */
 39389                                  ;  /*  Golden Sectors = RS + 2(SPF) + BPD(D)  + (DOSFILES)           */
 39390                                  ;  /*                                 ------   if bootable           */
 39391                                  ;  /*                                  BPS                           */
 39392                                  ;
 39393                                  ;  total_sectors = ((unsigned long)free_space[pointer].space) * max_head[cur_disk] * max_sector[cur_disk];
 39394                                  ;
 39395                                  ;  /* Chop off one track if it starts on head 1 */
 39396                                  ;  if (cur_head == uc(1))                                          /* AC004 */
 39397                                  ;     BEGIN
 39398                                  ;      total_sectors = total_sectors - max_sector[cur_disk];
 39399                                  ;     END
 39400                                  ;
 39401                                  ;  /* See if 12 or 16 bit fat */
 39402                                  ;  if (total_sectors > (unsigned long)FAT16_SIZE)
 39403                                  ;     BEGIN
 39404                                  ;      /* SR; 9/30/89; We have to round up the sectors_per_fat.
 39405                                  ;         Calculate the denominator first */
 39406                                  ;
 39407                                  ;      j = 2 + (BYTES_PER_SECTOR * 2);
 39408                                  ;      /* 16 bit */
 39409                                  ;      /* SR; 9/30/89; To round up add j-1 and divide by j */
 39410                                  ;      sectors_per_fat = u(((total_sectors - 33) + j - 1) / j);      /*C00*/
 39411                                  ;     END
 39412                                  ;  else
 39413                                  ;     BEGIN
 39414                                  ;      /* SR; 9/30/89; We have to round up the sectors_per_fat.
 39415                                  ;      Calculate the denominator first. We have to round up the
 39416                                  ;      denominator too. The multiplying factor 16 = SPC * 2 */
 39417                                  ;
 39418                                  ;      j = 2 + (( BYTES_PER_SECTOR * 16 ) + 2 ) / 3;
 39419                                  ;      /* 12 bit */
 39420                                  ;      sectors_per_fat = u(((total_sectors - 33) + j - 1) / j);      /*C00*/
 39421                                  ;     END
 39422                                  ;
 39423                                  ;  /* Round up one just to handle any rounding errors */
 39424                                  ;  /* SR; 9/30/89; We have taken care of the rounding */
 39425                                  ;  /***SR; 9/30/89; sectors_per_fat++;   ***/
 39426                                  ;
 39427                                  ;  /* Now see how many tracks */
 39428                                  ;  num_tracks = (sectors_per_fat*2) + 33;
 39429                                  ;
 39430                                  ;  /* If primary and drive 0, add in enough for system files */
 39431                                  ;  if ((type == c(PRIMARY)) && (cur_disk == c(0)))                 /* AC000 */
 39432                                  ;     BEGIN
 39433                                  ;      num_tracks = num_tracks + SYSTEM_FILE_SECTORS;
 39434                                  ;     END
 39435                                  ;
 39436                                  ;   /* Handle upward rounding */         /* The problem with the IBM code is */
 39437                                  ;   if (num_tracks%max_sector[cur_disk] != u(0)) /* that if num_tracks is < max_sector[cur_disk] */
 39438                                  ;       BEGIN                           /* the num_tracks becomes 0 due to the integer  */
 39439                                  ;       num_tracks = num_tracks + max_sector[cur_disk]; /* division and num_tracks will not be inc'd .  */
 39440                                  ;       END                             /* This section of code overcomes that. */
 39441                                  ;
 39442                                  ;   /* Now convert to tracks */
 39443                                  ;   num_tracks = num_tracks/max_sector[cur_disk];
 39444                                  ;
 39445                                  ;   /* SR; 9/30/89; The number of tracks above does not take into
 39446                                  ;      account the wasted track 0 which contains the partition info.
 39447                                  ;      If cur_head = 0, then the above calculation would cause the
 39448                                  ;      last track in the partition to be not verified */
 39449                                  ;
 39450                                  ;   if ( cur_head == 0 )
 39451                                  ;           num_tracks++;
 39452                                  ;
 39453                                  ;   golden_tracks = FALSE;
 39454                                  ;
 39455                                  ;   while (!golden_tracks)
 39456                                  ;       {                               /* this allows resetting the starting cyl of the golden tracks */
 39457                                  ;       for (i = u(0);i < num_tracks; i++)
 39458                                  ;           {               /* this for loop is to write the number of golden tracks  AC000 */
 39459                                  ;           retry = c(0);                         /* AC000 */
 39460                                  ;           do
 39461                                  ;               {                                       /* this do loop is for retries */
 39462                                  ;               retry++;
 39463                                  ;               regs.h.ah = uc(VERIFY_DISK);          /* BC001 */ /* Specify the operation */
 39464                                  ;               regs.h.al = (unsigned char)max_sector[cur_disk]; /* Specify number of sectors */
 39465                                  ;               regs.h.cl = 1;  /* Specify the start sectors */
 39466                                  ;				 /* AC000 BC001 Scramble CX so that sectors and cyl's are in INT 13 format*/
 39467                                  ;               if (cur_cyl > u(255))                                 /* AC000 */
 39468                                  ;                   regs.h.cl = regs.h.cl | ((unsigned char)((cur_cyl/256) << 6));
 39469                                  ;               regs.h.ch = ((unsigned char)cur_cyl) & 0xFF;
 39470                                  ;               regs.h.dl = ((unsigned char)cur_disk) + 0x80; /* Specify the disk */
 39471                                  ;               regs.h.dh = cur_head;                       /* Specify the head */ /* AC004 */
 39472                                  ;               int86((int)DISK, &regs, &regs);   /* BC001 */ /* verify the track */
 39473                                  ;                   retry_flg = regs.x.cflag & 1; /* BN001 */
 39474                                  ;               }
 39475                                  ;           while ((retry_flg) && (retry != c(3))); /* BN001 */ /* retry loop */
 39476                                  ;
 39477                                  ;           /************************************************************/
 39478                                  ;           /* Check to see if cylinder was verified w/o errors.        */
 39479                                  ;           /************************************************************/
 39480                                  ;
 39481                                  ;           if (!retry_flg)
 39482                                  ;               {                                               /* BN001 */
 39483                                  ;           /*********************************************************/
 39484                                  ;           /* Cylinder verified correctly. So write boot sector     */
 39485                                  ;           /* and bump cylinder count, then go verify that cylinder.*/
 39486                                  ;           /* Do not pass the end of the partition free space.      */
 39487                                  ;           /*********************************************************/
 39488                                  ;               retry = 0;
 39489                                  ;               do
 39490                                  ;                   {
 39491                                  ;                   retry++;
 39492                                  ;                   regs.h.ah = uc(WRITE_DISK);          /* BN001 */ /* Specify the operation */
 39493                                  ;                   regs.h.al = 1;                       /* BN001 */ /* Write one sector only */
 39494                                  ;                   regs.h.cl = 1;                       /* BN001 */ /* Specify the start sectors */ /* AC000 BC001 Need to scramble CX for INT 13 format */
 39495                                  ;                   if (cur_cyl > u(255))                  /* BN001 */
 39496                                  ;                   regs.h.cl = regs.h.cl | ((unsigned char)((cur_cyl/256) << 6)); /* BN001 */
 39497                                  ;                   regs.h.ch = ((unsigned char)cur_cyl) & 0xFF;  /* BN001 */
 39498                                  ;                   regs.h.dl = ((unsigned char)cur_disk) + 0x80; /* BN001 */ /* Specify the disk */
 39499                                  ;                   regs.h.dh = cur_head;                       /* BN001 */ /* Specify the head */   /* AC004 */
 39500                                  ;                   regs.x.bx = FP_OFF(buffer_pointer);         /* BN001 */ /* Point at the place to write */
 39501                                  ;                   segregs.es = FP_SEG(buffer_pointer);        /* BN001 */
 39502                                  ;                   DiskIo(&regs,&regs,&segregs);               /* BN001 */ /* write the track */
 39503                                  ;                   retry_flg = regs.x.cflag & 1;               /* BN001 */
 39504                                  ;                   }
 39505                                  ;               while ((retry_flg) && (retry != c(3)));         /* BN001 */ /* retry loop */
 39506                                  ;               }
 39507                                  ;
 39508                                  ;           /* See if we had a good read */
 39509                                  ;           if (!retry_flg)                        /* AC000 */
 39510                                  ;               BEGIN
 39511                                  ;               golden_tracks = TRUE;
 39512                                  ;               /* Get the next head */
 39513                                  ;               cur_head++;
 39514                                  ;
 39515                                  ;               /* SR; 9/29/89; Head no. is pre-incremented and cannot
 39516                                  ;                  subtract 1 from max_head[cur_disk] */
 39517                                  ;               if (cur_head == (uc(max_head[cur_disk] )))       /* AC004 */
 39518                                  ;                   BEGIN
 39519                                  ;                   /* Up to the next cylinder */
 39520                                  ;                   cur_head = uc(0);                          /* AC004 */
 39521                                  ;                   cur_cyl++;
 39522                                  ;
 39523                                  ;                   /* Check to see if we've reached the end of the free_space*/
 39524                                  ;                   if (cur_cyl > free_space[pointer].end)
 39525                                  ;                       BEGIN
 39526                                  ;                       /* It is, so return with the cyl offset equal to the freespace */
 39527                                  ;                       return(free_space[pointer].space);
 39528                                  ;                       END
 39529                                  ;                   END
 39530                                  ;               END
 39531                                  ;           else
 39532                                  ;               BEGIN
 39533                                  ;               /* Get out of the for loop, with a false flag */
 39534                                  ;               golden_tracks = FALSE;
 39535                                  ;
 39536                                  ;               /* Bump up to the next cylinder boundary */
 39537                                  ;               cur_cyl++;
 39538                                  ;
 39539                                  ;               /* SR; 9/29/89; To get out of the loop we have to
 39540                                  ;                  check if there have been enough golden tracks or
 39541                                  ;                  not. The setting of the flag as above will not
 39542                                  ;                  get us out of the loop. We return with the cyl
 39543                                  ;                  offset equal to the freespace to indicate that
 39544                                  ;                  this freespace cannot be used */
 39545                                  ;
 39546                                  ;               if ( cur_cyl > free_space[pointer].end )
 39547                                  ;                   return( free_space[pointer].space );
 39548                                  ;
 39549                                  ;               cur_head = uc(0);                             /* AC004 */
 39550                                  ;
 39551                                  ;               /* Save the new verify start point */
 39552                                  ;               verify_cyl = cur_cyl;
 39553                                  ;
 39554                                  ;               break;
 39555                                  ;               END
 39556                                  ;           END  /* for num_tracks */
 39557                                  ;       } /*while !golden_tracks */
 39558                                  ;
 39559                                  ;  /* All done, return the offset from original cyl to the new one */
 39560                                  ;  return(verify_cyl - free_space[pointer].start);
 39561                                  ;END
 39562                                  
 39563                                  verify_tracks:
 39564                                  		; 26/01/2019
 39565                                  
 39566                                  	%define verify_cyl 	bp-14	;bp-22	;bp-26
 39567                                  	%define	cur_head   	bp-12	;bp-20	;bp-24
 39568                                  	;%define buffer_pointer_off 	;bp-18	;bp-20
 39569                                  	;%define buffer_pointer_seg 	;bp-16	;bp-18
 39570                                  	%define vt_i		bp-10	;bp-14	;bp-16
 39571                                  	%define num_tracks	bp-8	;bp-12	;bp-14
 39572                                  	;%define vt_total_secs_lw 	;bp-10	;bp-12
 39573                                  	;%define vt_total_secs_hw 	;bp-8	;bp-10
 39574                                  	%define vt_retry	bp-6		;bp-8
 39575                                  	%define cur_cyl		bp-4
 39576                                  	%define golden_tracks	bp-2
 39577                                  
 39578                                  	%define vt_pointer	bp+4
 39579                                  	%define vt_type		bp+6
 39580                                  
 39581 00005AE8 55                      		push	bp
 39582 00005AE9 89E5                    		mov	bp,sp
 39583                                  		;;sub	sp,28
 39584                                  		;sub	sp,22
 39585 00005AEB 83EC0E                  		sub	sp,14
 39586                                  
 39587                                  		;push	di
 39588                                  		;push	si
 39589                                  
 39590                                  		;char far *buffer_pointer = boot_record;
 39591                                  		
 39592                                  		;mov	word [buffer_pointer_off],boot_record
 39593                                  		;mov	[buffer_pointer_seg],ds
 39594                                  
 39595                                  		;for (i=u(0); i< u(BYTES_PER_SECTOR);i++)    
 39596                                  
 39597                                  		;mov	word [vt_i],0
 39598                                  
 39599                                  	;/* Put something other then 0's so that unformatted FAT looks full */
 39600                                  vt_01:
 39601                                  		;mov	bx,[vt_i]
 39602                                  		;mov	byte [boot_record+bx],0F6h  ; boot_record[i] = uc(0xF6);  
 39603                                  		;inc	word [vt_i]
 39604                                  		;cmp	[vt_i],512
 39605                                  		;jb	short vt_01
 39606                                  
 39607                                  		;push	cs
 39608                                  		;pop	es
 39609                                  
 39610 00005AEE B90001                  		mov	cx,256
 39611 00005AF1 BF[E0C9]                		mov	di,boot_record
 39612 00005AF4 B8F6F6                  		mov	ax,0F6F6h
 39613 00005AF7 F3AB                    		rep	stosw
 39614                                  		
 39615                                  		;mov	al,22
 39616 00005AF9 B00A                    		mov	al,10
 39617                                  		;imul	byte [vt_pointer]
 39618 00005AFB F66604                  		mul	byte [vt_pointer]
 39619                                  		;mov	bx,ax
 39620 00005AFE 89C6                    		mov	si,ax ; ***
 39621                                  
 39622                                  		;/* Get the start cylinder for the sweep */
 39623                                  		;cur_cyl = free_space[pointer].start;
 39624                                  		;
 39625                                  		;/* Also keep track of what it is */
 39626                                  		;verify_cyl = cur_cyl;
 39627                                  
 39628                                  		;mov	ax,[free_space.start+bx]
 39629 00005B00 8B84[F2CB]              		mov	ax,[free_space.start+si] ; ***
 39630 00005B04 8946FC                  		mov	[cur_cyl],ax
 39631 00005B07 8946F2                  		mov	[verify_cyl],ax
 39632                                  
 39633                                  		;/* Initialize the start head - assume 0*/
 39634                                  
 39635 00005B0A C646F400                		mov	byte [cur_head],0
 39636                                  
 39637                                  		;cur_head should be 1 for extended partitions too */
 39638                                  	;  if (((type == c(PRIMARY)) && (cur_cyl == u(0))) || type == c(EXTENDED))
 39639                                  	
 39640 00005B0E 807E0600                		cmp	byte [vt_type],0 ; PRIMARY
 39641 00005B12 7504                    		jne	short vt_02
 39642 00005B14 09C0                    		or	ax,ax
 39643 00005B16 7406                    		jz	short vt_03
 39644                                  vt_02:
 39645 00005B18 807E0605                		cmp	byte [vt_type],5 ; EXTENDED
 39646 00005B1C 7503                    		jne	short vt_04
 39647                                  vt_03:
 39648                                  	;/* It's head 1 - NOTE: This is convience for PC-DOS because it is */
 39649                                  	;/* always this way - This may have to be beefed up for IFS */
 39650                                  
 39651                                  		;mov	byte [cur_head],1
 39652 00005B1E FE46F4                  		inc	byte [cur_head] ; [cur_head] = 1
 39653                                  
 39654                                  ;  /* Now go figure out the number of golden sectors needed. Use the */
 39655                                  ;  /* allocation equation in the fixed disk section of DOS Tech Ref. */
 39656                                  ;  /*                                                                */
 39657                                  ;  /*  TS = Free cyl's * sector/track * track/cyl                    */
 39658                                  ;  /*  RS = 1                                                        */
 39659                                  ;  /*  D  = 512                                                      */
 39660                                  ;  /*  BPD = 32                                                      */
 39661                                  ;  /*  BPS = BYTES_PER_SECTOR                                        */
 39662                                  ;  /*  CF = 2                                                        */
 39663                                  ;  /*  SPF = Solve                                                   */
 39664                                  ;  /*  SPC = 4 or 8                                                  */
 39665                                  ;  /*  BPC = 1.5 or 2                                                */
 39666                                  ;  /*                                                                */
 39667                                  ;  /*  Golden Sectors = RS + 2(SPF) + BPD(D)  + (DOSFILES)           */
 39668                                  ;  /*                                 ------   if bootable           */
 39669                                  ;  /*                                  BPS                           */
 39670                                  
 39671                                  vt_04:
 39672                                  
 39673                                  ;total_sectors = ((unsigned long)free_space[pointer].space) * max_head[cur_disk] 
 39674                                  ;		* max_sector[cur_disk];
 39675                                  
 39676                                  		;mov	al,[cur_disk]
 39677                                  		;cbw
 39678                                  		;mov	bx,ax
 39679                                  		;mov	al,[max_sector+bx]
 39680                                  		;sub	ah,ah
 39681                                  		;sub	dx,dx
 39682                                  		;push	dx
 39683                                  		;push	ax
 39684                                  		;mov	cx,ax
 39685                                  
 39686 00005B21 A0[E2CB]                		mov	al,[cur_disk]
 39687 00005B24 98                      		cbw
 39688 00005B25 89C3                    		mov	bx,ax
 39689 00005B27 8A87[AEA0]              		mov	al,[max_sector+bx] ; <= 63
 39690 00005B2B 89C1                    		mov	cx,ax
 39691                                  
 39692                                  		;;mov	al,22
 39693                                  		;mov	al,10
 39694                                  		;;imul	byte [vt_pointer]
 39695                                  		;mul	byte [vt_pointer]
 39696                                  		;mov	si,ax ; ***
 39697                                  
 39698                                  		;shl	bx,1
 39699 00005B2D D0E3                    		shl	bl,1
 39700 00005B2F 8B87[B6A0]              		mov	ax,[max_head+bx] ; <= 255
 39701                                  		;mov	bx,dx
 39702                                  		
 39703                                  		;mul	word [free_space.space+si]
 39704                                  		;push	dx
 39705                                  		;push	ax
 39706                                  		;mov	si,cx
 39707                                  		;mov	di,bx
 39708                                  		;call	mul32
 39709                                  
 39710 00005B33 F7E1                    		mul	cx ; [max_sector] 
 39711                                  			;ax = [max_sector] * [max_head] <= 16065
 39712                                  			;dx = 0
 39713                                  
 39714 00005B35 F7A4[F0CB]              		mul	word [free_space.space+si]
 39715                                  
 39716                                  		;mov	[vt_total_secs_lw],ax
 39717                                  		;mov	[vt_total_secs_hw],dx
 39718                                  
 39719                                  		;/* Chop off one track if it starts on head 1 */
 39720                                  
 39721                                  	;if (cur_head == uc(1))
 39722                                  	;  BEGIN
 39723                                  	;    total_sectors = total_sectors - max_sector[cur_disk];
 39724                                  	;  END
 39725 00005B39 807EF401                		cmp	byte [cur_head],1
 39726 00005B3D 7506                    		jne	short vt_05
 39727                                  
 39728                                  		;sub	ax,si
 39729                                  		;sbb	dx,di
 39730                                  
 39731 00005B3F 31FF                    		xor	di,di ; 0
 39732                                  
 39733 00005B41 29C8                    		sub	ax,cx	; cx = max_sector[cur_disk]
 39734                                  		;sbb	dx,0
 39735 00005B43 19FA                    		sbb	dx,di ; sbb dx,0
 39736                                  
 39737                                  		;;mov	[vt_total_secs_lw],ax
 39738                                  		;;mov	[vt_total_secs_hw],dx
 39739                                  vt_05:
 39740                                  		;mov	[vt_total_secs_lw],ax
 39741                                  		;mov	[vt_total_secs_hw],dx
 39742                                  
 39743                                  		;cmp	dx,di
 39744                                  		;jne	short vt_06
 39745                                  
 39746                                  		;/* See if 12 or 16 bit fat */
 39747                                  		; if (total_sectors > (unsigned long)FAT16_SIZE)
 39748                                  
 39749 00005B45 21D2                    		and	dx,dx
 39750 00005B47 7505                    		jnz	short vt_06
 39751                                  
 39752 00005B49 3DA87F                  		cmp	ax,32680  ; FAT16_SIZE (FAT 12 size limit)
 39753 00005B4C 760A                    		jbe	short vt_07 ; FAT 12
 39754                                  vt_06:
 39755                                  		;/* We have to round up the sectors_per_fat.
 39756                                  		;   Calculate the denominator first */
 39757                                  
 39758                                  		;j = 2 + (BYTES_PER_SECTOR * 2);
 39759                                  
 39760                                  		;mov	ax,1026 ; j
 39761                                  		;cwd
 39762                                  
 39763 00005B4E B90204                  		mov	cx,1026 ; j  ; divisor
 39764                                  
 39765                                  		;/* 16 bit */
 39766                                  		;To round up add j-1 and divide by j */
 39767                                  		;sectors_per_fat = u(((total_sectors - 33) + j - 1) / j); 
 39768                                  
 39769                                  		;push	dx
 39770                                  		;push	ax
 39771                                  		;mov	ax,[vt_total_secs_lw]
 39772                                  		;mov	dx,[vt_total_secs_hw]
 39773                                  
 39774 00005B51 05E003                  		add	ax,992 ; 1026-33-1
 39775                                  		;adc	dx,0
 39776 00005B54 11FA                    		adc	dx,di ; adc dx,0
 39777 00005B56 EB06                    		jmp	short vt_08
 39778                                  vt_07:
 39779                                  		;We have to round up the sectors_per_fat.
 39780                                  		;Calculate the denominator first. We have to round up the
 39781                                  		;denominator too. The multiplying factor 16 = SPC * 2 */
 39782                                  
 39783                                  		;j = 2 + (( BYTES_PER_SECTOR * 16 ) + 2 ) / 3;
 39784                                  		
 39785                                  		;mov	ax,2733	; j (= 2731+2)
 39786                                  		;cwd
 39787                                  
 39788 00005B58 B9AD0A                  		mov	cx,2733	; j
 39789                                  
 39790                                  		;/* 12 bit */
 39791                                  		;sectors_per_fat = u(((total_sectors - 33) + j - 1) / j);
 39792                                  
 39793                                  		;push	dx
 39794                                  		;push	ax
 39795                                  		;mov	ax,[vt_total_secs_lw]
 39796                                  		;mov	dx,[vt_total_secs_hw]
 39797                                  		
 39798 00005B5B 058B0A                  		add	ax,2699 ; 2733-33-1  
 39799                                  			 ;ax <= 32680+2699
 39800                                  			 ;dx = 0
 39801                                  ;vt_08:
 39802                                  		;adc	dx,di
 39803                                  vt_08:
 39804                                  		;push	dx
 39805                                  		;push	ax
 39806                                  			; dx:ax = dividend (32 bit)
 39807                                  			; cx = divisor (16 bit)
 39808                                  
 39809 00005B5E E8B5BA                  		call	div32
 39810                                  			; ax = sectors per fat
 39811                                  
 39812                                  		;/* Round up one just to handle any rounding errors */
 39813                                  		;/* We have taken care of the rounding */
 39814                                  
 39815                                  		;/* Now see how many tracks */
 39816                                  		;num_tracks = (sectors_per_fat*2) + 33;
 39817                                  
 39818 00005B61 D1E0                    		shl	ax,1
 39819 00005B63 83C021                  		add	ax,33
 39820 00005B66 8946F8                  		mov	[num_tracks],ax
 39821                                  
 39822                                  	;/* If primary and drive 0, add in enough for system files */
 39823                                  
 39824                                  		;if ((type == c(PRIMARY)) && (cur_disk == c(0)))
 39825                                  		;   BEGIN
 39826                                  		;     num_tracks = num_tracks + SYSTEM_FILE_SECTORS;
 39827                                  		;   END
 39828                                  
 39829 00005B69 807E0600                		cmp	byte [vt_type],0 ; PRIMARY
 39830 00005B6D 750D                    		jne	short vt_09
 39831 00005B6F 803E[E2CB]00            		cmp	byte [cur_disk],0
 39832 00005B74 7506                    		jne	short vt_09
 39833 00005B76 05FA00                  		add	ax,250 ; SYSTEM_FILE_SECTORS
 39834 00005B79 8946F8                  		mov	[num_tracks],ax
 39835                                  vt_09:
 39836                                  		;/* Handle upward rounding */         
 39837                                  	
 39838                                  		;/* The problem with the IBM code is */
 39839                                  		;/* that if num_tracks is < max_sector[cur_disk] */
 39840                                  		;/* the num_tracks becomes 0 due to the integer */
 39841                                  		;/* division and num_tracks will not be inc'd. */
 39842                                  		;/* This section of code overcomes that. */
 39843                                  
 39844                                  		;if (num_tracks%max_sector[cur_disk] != u(0)) 
 39845                                  		;   BEGIN                          
 39846                                  		;     num_tracks = num_tracks + max_sector[cur_disk];
 39847                                  		;   END
 39848                                  
 39849                                  		;mov	al,[cur_disk]
 39850                                  		;cbw
 39851                                  		;mov	bx,ax
 39852 00005B7C 8A1E[E2CB]              		mov	bl,[cur_disk]
 39853 00005B80 28FF                    		sub	bh,bh		
 39854 00005B82 8A8F[AEA0]              		mov	cl,[max_sector+bx]
 39855 00005B86 28ED                    		sub	ch,ch ; 0
 39856 00005B88 8B46F8                  		mov	ax,[num_tracks]
 39857 00005B8B 29D2                    		sub	dx,dx ; 0
 39858 00005B8D F7F1                    		div	cx
 39859 00005B8F 09D2                    		or	dx,dx
 39860 00005B91 7405                    		jz	short vt_10
 39861 00005B93 014EF8                  		add	[num_tracks],cx
 39862                                  
 39863 00005B96 31D2                    		xor	dx,dx ; **
 39864                                  vt_10:
 39865                                  		;/* Now convert to tracks */
 39866                                  		;   num_tracks = num_tracks/max_sector[cur_disk];
 39867                                  
 39868                                  		;mov	al,[cur_disk]
 39869                                  		;cbw
 39870                                  		;mov	bx,ax
 39871                                  		;mov	cl,[max_sector+bx]
 39872                                  		;sub	ch,ch
 39873                                  		;mov	ax,[num_tracks]
 39874                                  		;sub	dx,dx ; **
 39875                                  
 39876 00005B98 8B46F8                  		mov	ax,[num_tracks]
 39877                                  
 39878 00005B9B F7F1                    		div	cx
 39879 00005B9D 8946F8                  		mov	[num_tracks],ax
 39880                                  
 39881                                  	;/* The number of tracks above does not take into
 39882                                  	;account the wasted track 0 which contains the partition info.
 39883                                  	;If cur_head = 0, then the above calculation would cause the
 39884                                  	;last track in the partition to be not verified */
 39885                                  
 39886                                  		;   if ( cur_head == 0 )
 39887                                  		;           num_tracks++;
 39888                                  
 39889 00005BA0 386EF4                  		cmp	[cur_head],ch ; 0
 39890 00005BA3 7503                    		jne	short vt_11
 39891 00005BA5 FF46F8                  		inc	word [num_tracks]
 39892                                  vt_11:
 39893 00005BA8 C646FE00                		mov	byte [golden_tracks],0 ; golden_tracks = FALSE;
 39894                                  vt_12:
 39895                                  	;/* this allows resetting the starting cyl of the golden tracks */	
 39896                                  
 39897                                  		;for (i = u(0);i < num_tracks; i++)
 39898                                  
 39899 00005BAC C746F60000              		mov	word [vt_i],0
 39900 00005BB1 EB03                    		jmp	short vt_14
 39901                                  vt_13:
 39902 00005BB3 FF46F6                  		inc	word [vt_i]
 39903                                  vt_14:
 39904                                  	;/* this for loop is to write the number of golden tracks */
 39905                                  
 39906 00005BB6 8B46F6                  		mov	ax,[vt_i]
 39907 00005BB9 3946F8                  		cmp	[num_tracks],ax
 39908 00005BBC 7703                    		ja	short vt_15
 39909                                  
 39910 00005BBE E9B600                  		jmp	vt_25
 39911                                  vt_15:
 39912                                  	;/* this for loop is to write the number of golden tracks */		
 39913                                  
 39914 00005BC1 C646FA00                		mov	byte [vt_retry],0
 39915                                  vt_16:
 39916                                  		; /* this do loop is for retries */
 39917                                  
 39918 00005BC5 FE46FA                  		inc	byte [vt_retry]
 39919                                  
 39920                                  		;mov	byte [regs_x_ax+1],4 ; verify
 39921                                  		;mov	al,[cur_disk]
 39922                                  		;cbw
 39923                                  		;mov	bx,ax
 39924                                  		;mov	al,[max_sector+bx]
 39925                                  		;mov	[regs_x_ax],al
 39926                                  		;mov	byte [regs_x_cx],1
 39927                                  
 39928 00005BC8 B101                    		mov	cl,1 	  ; /* Specify the start sectors */
 39929                                  
 39930                                  		;cmp	word [cur_cyl],255
 39931                                  		;jbe	short vt_17
 39932                                  
 39933 00005BCA 8B56FC                  		mov	dx,[cur_cyl]
 39934 00005BCD 81FAFF00                		cmp	dx,255
 39935 00005BD1 7605                    		jbe	short vt_17
 39936                                  
 39937                                  		;mov	ax,[cur_cyl]
 39938                                  		;shr	ax,1
 39939                                  		;shr	ax,1
 39940                                  		;and	al,0C1h
 39941                                  		;or	al,1
 39942                                  		;mov	byte [regs_x_cx],al
 39943                                  
 39944 00005BD3 C0E606                  		shl	dh,6
 39945 00005BD6 08F1                    		or	cl,dh  ; high two bits of cylinder in bits 7-6
 39946                                  vt_17:
 39947                                  		;mov	al,[cur_cyl]
 39948                                  		;mov	[regs_x_cx+1],al
 39949                                  		;mov	al,[cur_disk]
 39950                                  		;add	al,80h
 39951                                  		;mov	[regs_x_dx],al
 39952                                  		;mov	al,[cur_head]
 39953                                  		;mov	[regs_x_dx+1],al
 39954                                  		;mov	ax,regs_x_ax
 39955                                  		;push	ax
 39956                                  		;push	ax
 39957                                  		;mov	ax,13h
 39958                                  		;push	ax
 39959                                  		;call	int86
 39960                                  		;add	sp,6
 39961                                  
 39962 00005BD8 88D5                    		mov	ch,dl  ; byte [cur_cyl], low 8 bits of cylinder
 39963 00005BDA 8A76F4                  		mov	dh,[cur_head] ; /* Specify the head */
 39964 00005BDD 8A16[E2CB]              		mov	dl,[cur_disk] 
 39965 00005BE1 88D3                    		mov	bl,dl
 39966 00005BE3 80C280                  		add	dl,80h 	      ; /* Specify the disk */	
 39967                                   
 39968                                  		;regs.h.al = (unsigned char)max_sector[cur_disk];
 39969                                  
 39970                                  		;mov	bl,[cur_disk]
 39971 00005BE6 28FF                    		sub	bh,bh
 39972 00005BE8 8A87[AEA0]              		mov	al,[max_sector+bx]  ; /* Specify number of sectors */
 39973                                  
 39974                                  		; regs.h.ah = uc(VERIFY_DISK);
 39975 00005BEC B404                    		mov	ah,04h  ; verify disk sectors
 39976 00005BEE CD13                    		int	13h
 39977                                  
 39978                                  		; retry_flg = regs.x.cflag & 1;
 39979                                  
 39980                                  		;mov	al,[regs_x_cflag]
 39981                                  		;and	ax,1
 39982                                  		;jz	short vt_18
 39983                                  
 39984 00005BF0 7308                    		jnc	short vt_18
 39985                                  
 39986                                  		;while ((retry_flg) && (retry != c(3))); /* retry loop */
 39987                                  
 39988 00005BF2 807EFA03                		cmp	byte [vt_retry],3
 39989                                  		;jnz	short vt_16
 39990 00005BF6 72CD                    		jb	short vt_16
 39991                                  
 39992 00005BF8 EB66                    		jmp	short vt_24
 39993                                  ;vt_18:
 39994                                  	;/************************************************************/
 39995                                  	;/* Check to see if cylinder was verified w/o errors.        */
 39996                                  	;/************************************************************/
 39997                                  	
 39998                                  	;if (!retry_flg)
 39999                                  	;   {                 
 40000                                  		;or	ax,ax
 40001                                  		;jnz	short vt_21
 40002                                  vt_18:
 40003                                  	;/*********************************************************/
 40004                                  	;/* Cylinder verified correctly. So write boot sector     */
 40005                                  	;/* and bump cylinder count, then go verify that cylinder.*/
 40006                                  	;/* Do not pass the end of the partition free space.      */
 40007                                  	;/*********************************************************/
 40008                                  
 40009 00005BFA C646FA00                		mov	byte [vt_retry],0
 40010                                  	;do
 40011                                  	;	{
 40012                                  vt_19:
 40013 00005BFE FE46FA                  		inc	byte [vt_retry]
 40014                                  
 40015                                  		;mov	byte ptr [regs_x_ax+1],3  ; WRITE_DISK
 40016                                  		;mov	al,1	; /* Write one sector only */
 40017                                  		;mov	[regs_x_ax],al
 40018                                  		;mov	[regs_x_cx],al ; /* Specify the start sectors */
 40019                                  
 40020                                  		;if (cur_cyl > u(255)) 
 40021                                  
 40022 00005C01 B101                    		mov	cl,1 	  ; start sector	
 40023                                  
 40024                                  		;cmp	word [cur_cyl],255
 40025                                  		;jbe	short vt_20
 40026                                  
 40027 00005C03 8B56FC                  		mov	dx,[cur_cyl]
 40028 00005C06 81FAFF00                		cmp	dx,255
 40029 00005C0A 7605                    		jbe	short vt_20
 40030                                  
 40031                                  		;regs.h.cl = regs.h.cl | ((unsigned char)((cur_cyl/256) << 6));
 40032                                  
 40033                                  		;mov	ax,[cur_cyl]
 40034                                  		;shr	ax,1
 40035                                  		;shr	ax,1
 40036                                  		;and	al,0C1h
 40037                                  		;or	al,1
 40038                                  		;mov	[regs_x_cx],al
 40039                                  
 40040 00005C0C C0E606                  		shl	dh,6
 40041 00005C0F 08F1                    		or	cl,dh  ; high two bits of cylinder in bits 7-6
 40042                                  vt_20:
 40043                                  		;mov	al,[cur_cyl]
 40044                                  		;mov	[regs_x_cx+1],al
 40045                                  		;mov	al,[cur_disk]
 40046                                  		;add	al,80h
 40047                                  		;mov	[regs_x_dx],al	 ; /* Specify the disk */
 40048                                  		;mov	al,[cur_head]
 40049                                  		;mov	[regs_x_dx+1],al ; /* Specify the head */ 
 40050                                  		;mov	ax,[buffer_pointer_off]
 40051                                  		;mov	[regs_x_bx],ax
 40052                                  		;mov	ax,[buffer_pointer_seg]
 40053                                  		;mov	[segregs_es],ax
 40054                                  		;mov	ax,segregs_es
 40055                                  		;push	ax
 40056                                  		;mov	ax,regs_x_ax
 40057                                  		;push	ax
 40058                                  		;push	ax
 40059                                  		;call	DiskIo
 40060                                  		;add	sp,6
 40061                                  
 40062 00005C11 88D5                    		mov	ch,dl  ; byte [cur_cyl], low 8 bits of cylinder
 40063 00005C13 8A76F4                  		mov	dh,[cur_head]
 40064 00005C16 8A16[E2CB]              		mov	dl,[cur_disk]
 40065 00005C1A 80C280                  		add	dl,80h 
 40066                                  		;push	cs
 40067                                  		;pop	es
 40068 00005C1D BB[E0C9]                		mov	bx,boot_record
 40069 00005C20 B80103                  		mov	ax,0301h  ; write disk sectors 
 40070                                  				  ; (al = sector count = 1)
 40071 00005C23 CD13                    		int	13h
 40072                                  
 40073                                  		;/* See if we had a good read */
 40074                                  
 40075                                  		;retry_flg = regs.x.cflag & 1;  
 40076                                  
 40077                                  		;mov	al,[regs_x_cflag]
 40078                                  		;and	ax,1
 40079                                  		;jz	short vt_21
 40080                                  
 40081 00005C25 7308                    		jnc	short vt_21
 40082                                  
 40083                                  		;while ((retry_flg) && (retry != c(3)));  
 40084                                  		
 40085 00005C27 807EFA03                		cmp	byte [vt_retry],3
 40086 00005C2B 72D1                    		jb	short vt_19
 40087                                  
 40088 00005C2D EB31                    		jmp	short vt_24
 40089                                  ;vt_21:
 40090                                  		;or	ax,ax
 40091                                  		;jnz	short vt_24
 40092                                  vt_21:
 40093                                  		; if (!retry_flg)
 40094                                  
 40095 00005C2F C646FE01                		mov	byte [golden_tracks],1  ; golden_tracks = TRUE;
 40096                                  		
 40097                                  		;mov	al,[cur_disk] 
 40098                                  		;cbw
 40099                                  		;mov	bx,ax
 40100                                  		;shl	bx,1
 40101 00005C33 28FF                    		sub	bh,bh
 40102 00005C35 8A1E[E2CB]              		mov	bl,[cur_disk]
 40103 00005C39 D0E3                    		shl	bl,1
 40104                                  		
 40105                                  		;/* Get the next head */
 40106 00005C3B FE46F4                  		inc	byte [cur_head]  ; cur_head++;
 40107 00005C3E 8A46F4                  		mov	al,[cur_head]
 40108                                  
 40109                                  		;/* Head no. is pre-incremented and cannot
 40110                                  		;   subtract 1 from max_head[cur_disk] */
 40111                                  
 40112                                  		;if (cur_head == (uc(max_head[cur_disk] )))
 40113                                  		;   BEGIN
 40114                                  		; /* Up to the next cylinder */
 40115                                  		;      cur_head = uc(0);
 40116                                  		;      cur_cyl++;
 40117                                  
 40118 00005C41 3887[B6A0]              		cmp	[max_head+bx],al
 40119 00005C45 7510                    		jne	short vt_22
 40120 00005C47 C646F400                		mov	byte [cur_head],0
 40121                                  		
 40122                                  		;;mov	al,22
 40123                                  		;mov	al,10
 40124                                  		;;imul	byte [vt_pointer]
 40125                                  		;mul	byte [vt_pointer]
 40126                                  		;mov	bx,ax
 40127 00005C4B FF46FC                  		inc	word [cur_cyl]
 40128                                  
 40129                                  	;/* Check to see if we've reached the end of the free_space*/
 40130                                  
 40131                                  		;if (cur_cyl > free_space[pointer].end)
 40132                                  		;   BEGIN
 40133                                  	; /* It is, so return with the cyl offset equal to the freespace */
 40134                                  		;    return(free_space[pointer].space);
 40135                                  		;   END
 40136                                  
 40137 00005C4E 8B46FC                  		mov	ax,[cur_cyl]
 40138                                  		;cmp	[free_space.end+bx],ax
 40139 00005C51 3984[F4CB]              		cmp	[free_space.end+si],ax ; ***
 40140 00005C55 7203                    		jb	short vt_23
 40141                                  vt_22:
 40142 00005C57 E959FF                  		jmp	vt_13
 40143                                  vt_23:
 40144                                  		; return( free_space[pointer].space );
 40145                                  		;mov	ax,[free_space.space+bx]
 40146 00005C5A 8B84[F0CB]              		mov	ax,[free_space.space+si] ; ***
 40147 00005C5E EB27                    		jmp	short vt_27
 40148                                  	; else	
 40149                                  vt_24:
 40150                                  	;/* Get out of the for loop, with a false flag */
 40151                                  	
 40152                                  		;golden_tracks = FALSE;
 40153 00005C60 C646FE00                		mov	byte [golden_tracks],0
 40154                                  		
 40155                                  		;;mov	al,22
 40156                                  		;mov	al,10
 40157                                  		;;imul	byte [vt_pointer]
 40158                                  		;mul	byte [vt_pointer]
 40159                                  		;mov	bx,ax
 40160                                  
 40161                                  		;/* Bump up to the next cylinder boundary */
 40162                                  		
 40163                                  		;cur_cyl++;
 40164                                  		
 40165 00005C64 FF46FC                  		inc	word [cur_cyl]
 40166                                  
 40167                                  		;/* To get out of the loop we have to check if 
 40168                                  		;there have been enough golden tracks or not.
 40169                                  		;The setting of the flag as above will not get us 
 40170                                  		;out of the loop. We return with the cyl offset 
 40171                                  		;equal to the freespace to indicate that
 40172                                  		;this freespace cannot be used */
 40173                                  
 40174 00005C67 8B46FC                  		mov	ax,[cur_cyl]
 40175                                  
 40176                                  		;if ( cur_cyl > free_space[pointer].end )
 40177                                  		;     return( free_space[pointer].space );
 40178                                  
 40179                                  		;cmp	[free_space.end+bx],ax
 40180 00005C6A 3984[F4CB]              		cmp	[free_space.end+si],ax ; ***
 40181 00005C6E 72EA                    		jb	short vt_23
 40182                                  
 40183 00005C70 C646F400                		mov	byte [cur_head],0  ; cur_head = uc(0);   
 40184                                  
 40185                                  		;/* Save the new verify start point */
 40186                                  
 40187 00005C74 8946F2                  		mov	[verify_cyl],ax
 40188                                  vt_25:
 40189                                  		;while (!golden_tracks)
 40190                                  	
 40191 00005C77 807EFE00                		cmp	byte [golden_tracks],0
 40192 00005C7B 7503                    		jne	short vt_26
 40193                                  
 40194                                  	;/* this allows resetting the starting cyl of the golden tracks */
 40195                                  
 40196 00005C7D E92CFF                  		jmp	vt_12  ; /*while !golden_tracks */
 40197                                  vt_26:
 40198                                  	;/* All done, return the offset from original cyl to the new one */
 40199                                  	
 40200                                  		; return(verify_cyl - free_space[pointer].start);
 40201                                  
 40202                                  		;;mov	al,22
 40203                                  		;mov	al,10
 40204                                  		;;imul	byte [vt_pointer]
 40205                                  		;mul	byte [vt_pointer]
 40206                                  		;mov	bx,ax
 40207 00005C80 8B46F2                  		mov	ax,[verify_cyl]
 40208                                  		;sub	ax,[free_space.start+bx]
 40209 00005C83 2B84[F2CB]              		sub	ax,[free_space.start+si] ; ***
 40210                                  vt_27:
 40211                                  		;pop	si
 40212                                  		;pop	di
 40213                                  		
 40214 00005C87 89EC                    		mov	sp,bp
 40215 00005C89 5D                      		pop	bp
 40216                                  		;retn
 40217 00005C8A C20400                  		retn	4
 40218                                  
 40219                                  ;=============================================================================
 40220                                  ;        	TEMPORARY
 40221                                  ;=============================================================================
 40222                                  ; 10/11/2018
 40223                                  
 40224                                  ;print_parse_error_msg:
 40225                                  ;		;and	al,al
 40226                                  ;		;jnz	short ppe
 40227                                  ;		;retn
 40228                                  ;;ppe:
 40229                                  ;		push	ax
 40230                                  ;		mov	si,beep_next_line
 40231                                  ;		call	print_msg
 40232                                  ;		pop	bx
 40233                                  ;		dec	bx
 40234                                  ;		shl	bx,1
 40235                                  ;		add	bx,parse_error_tbl
 40236                                  ;
 40237                                  ;		mov	si,[bx]
 40238                                  ;		call	print_msg
 40239                                  ;		mov	si,next_line
 40240                                  ;		jmp	print_msg
 40241                                  ;
 40242                                  ;parse_error_tbl:
 40243                                  ;		;dw	_No_Error
 40244                                  ;		dw	_Too_Many	; 1
 40245                                  ;		dw	_Op_Missing	; 2
 40246                                  ;		dw	_Not_In_Sw	; 3
 40247                                  ;		dw	_Not_In_Key	; 4
 40248                                  ;		dw	_unused_err_no	;(5)
 40249                                  ;		dw	_Out_Of_Range	; 6
 40250                                  ;		dw	_Not_In_Val	; 7
 40251                                  ;		dw	_Not_In_Str	; 8
 40252                                  ;		dw	_Syntax		; 9
 40253                                  ;		; TEMPORARY!
 40254                                  ;		dw	_Invalid
 40255                                  
 40256                                  print_msg:
 40257 00005C8D B40E                    		mov	ah,0Eh
 40258 00005C8F BB0700                  		mov	bx,07h
 40259                                  pmsg_1:
 40260 00005C92 AC                      		lodsb
 40261 00005C93 20C0                    		and	al,al
 40262 00005C95 7404                    		jz	short pmsg_2
 40263 00005C97 CD10                    		int	10h
 40264 00005C99 EBF7                    		jmp	short pmsg_1
 40265                                  pmsg_2:
 40266 00005C9B C3                      		retn	
 40267                                  
 40268                                  beep_next_line:
 40269 00005C9C 07                      		db	07h
 40270                                  next_line:
 40271 00005C9D 0D0A00                  		db	0Dh,0Ah,0
 40272                                  
 40273                                  ;		; Note: Same error message order in COMMAND.COM 6.22 (*)
 40274                                  ;		;	offset 0A41h - INT 2Fh MULTDOS,MSG_RETRIEVAL ; 11/11/2018
 40275                                  ;_Too_Many:	;db	'Too many operands!',0
 40276                                  ;		db	'Too many parameters!',0 ; (*)
 40277                                  ;_Op_Missing:	;db	'Required operand missing!',0
 40278                                  ;		db	'Required parameter missing!',0 ; (*)
 40279                                  ;_Not_In_Sw:	;db	'Not in switch list provided!',0
 40280                                  ;		db	'Invalid switch!',0 ; (*)		
 40281                                  ;_Not_In_Key:	;db	'Not in keyword list provided!',0
 40282                                  ;		db	'Invalid keyword!',0 ; (*)
 40283                                  ;_unused_err_no: db	' ',0 ; (*)
 40284                                  ;_Out_Of_Range:	;db	'Out of range specified!',0
 40285                                  ;		;db	'Out of range!',0
 40286                                  ;		db	'Parameter value not in allowed range!',0 ; (*)	
 40287                                  ;_Not_In_Val:	;db	'Not in value list provided!',0
 40288                                  ;		;db	'Invalid size!',0
 40289                                  ;		db	'Parameter value not allowed!',0 ; (*)	
 40290                                  ;_Not_In_Str:	;db	'Not in string list provided!',0
 40291                                  ;		;db	'Invalid string!',0
 40292                                  ;		db	'Parameter value not allowed',0 ; (*)
 40293                                  ;_Syntax:	;db	'Syntax error!',0
 40294                                  ;		db	'Parameter format not correct!',0 ; (*)
 40295                                  ;_Invalid:	db	'Invalid command parameter(s)!',0 ; TEMPORARY!
 40296                                  
 40297                                  incorrect_dos_version:
 40298 00005CA0 0D0A                    		db	0Dh,0Ah
 40299 00005CA2 496E636F7272656374-     		db	'Incorrect DOS version!'
 40299 00005CAB 20444F532076657273-
 40299 00005CB4 696F6E21           
 40300 00005CB8 0D0A00                  		db	0Dh,0Ah,0
 40301                                  
 40302                                  ; ----------------------------------------------------------------------------
 40303                                  
 40304                                  ; TEMPORARY SUBROUTINES - 10/11/2018 
 40305                                  
 40306                                  fdisk_program_msg:
 40307 00005CBB 0D0A                    		db	0Dh,0Ah
 40308                                  		;db	'FDISK utility (v2) by Erdogan Tan - 2019'
 40309                                  		; 22/12/2022
 40310 00005CBD 464449534B20757469-     		db	'FDISK utility (v2) by Erdogan Tan [2019-2022]'
 40310 00005CC6 6C6974792028763229-
 40310 00005CCF 206279204572646F67-
 40310 00005CD8 616E2054616E205B32-
 40310 00005CE1 3031392D323032325D 
 40311 00005CEA 0D0A00                  		db	0Dh,0Ah,0
 40312                                  
 40313                                  print_fdisk_program_msg:
 40314 00005CED BE[BB5C]                		mov	si,fdisk_program_msg
 40315 00005CF0 EB9B                    		jmp	print_msg
 40316                                  
 40317                                  ;=============================================================================
 40318                                  ;        	initialized data
 40319                                  ;=============================================================================
 40320                                  
 40321                                  ; 13/11/2018
 40322                                  
 40323                                  align 2
 40324                                  
 40325 00005CF2 00000000                $M_EXT_ERR_ADDRS: dd 0	
 40326 00005CF6 00000000                $M_EXT_FILE:	dd 0
 40327 00005CFA 00000000                $M_EXT_COMMAND:	dd 0
 40328 00005CFE FFFFFFFF                $M_EXT_TERM:	dd 0FFFFFFFFh
 40329 00005D02 00000000                $M_PARSE_COMMAND: dd 0
 40330 00005D06 00000000                $M_PARSE_ADDRS:	dd 0
 40331 00005D0A FFFFFFFF                $M_PARSE_TERM:	dd 0FFFFFFFFh
 40332 00005D0E 00000000                $M_CRIT_ADDRS:	dd 0
 40333 00005D12 00000000                $M_CRIT_COMMAND: dd 0
 40334 00005D16 FFFFFFFF                $M_CRIT_TERM:	dd 0FFFFFFFFh
 40335 00005D1A FFFFFFFF                $M_DISK_PROC_ADDR: dd 0FFFFFFFFh
 40336 00005D1E 00000000                $M_CLASS_A_ADDRS: dd 0
 40337 00005D22 00000000                $M_CLASS_B_ADDRS: dd 0
 40338 00005D26 FFFFFFFF                $M_CLS_TERM:	dd 0FFFFFFFFh
 40339 00005D2A 00000000                $M_DBCS_VEC:	dd 0
 40340 00005D2E 0000                    $M_HANDLE:	dw 0
 40341 00005D30 00                      $M_SIZE:	db 0
 40342 00005D31 0D0A                    $M_CRLF:	dw 0A0Dh
 40343 00005D33 00                      $M_CLASS:	db 0
 40344 00005D34 0000                    $M_RETURN_ADDR:	dw 0
 40345 00005D36 0000                    $M_MSG_NUM:	dw 0
 40346 00005D38 0A00                    $M_DIVISOR:	dw 10
 40347 00005D3A 24242424242424          $M_TEMP_BUF:	db '$$$$$$$'
 40348 00005D41 24<rep 39h>             $M_THOU_SEPARA:	times 57 db '$' ; db 39h dup('$')
 40349 00005D7A 24                      $M_BUF_TERM:	db '$'
 40350                                  
 40351                                  		;db 0
 40352 00005D7B 90                      align 2
 40353                                  
 40354                                  ;	; MSDOS 6.0 (1991) FDISK.SKL file (content):
 40355                                  ;	
 40356                                  ;	:util FDISK                ;utility name
 40357                                  ;	:class A                   ;system messages
 40358                                  ;	;
 40359                                  ;	:use 1 COMMON1             ;"Incorrect DOS version"
 40360                                  ;	:use 2 COMMON2             ;"Insufficient Memory"
 40361                                  ;	:use 3 COMMON3             ;"Internal error loading messages"
 40362                                  ;	:use 8 EXTEND87            ;"Invalid parameter"
 40363                                  ;	:def 9  "Y",0              ;"Y"
 40364                                  ;	:def 10 "N",0              ;"N"
 40365                                  ;
 40366                                  ;	;    Options help messages (all class A) 300-399 RESERVED
 40367                                  ;	:def 300 FDISK /?
 40368                                  ;	:def 301 FDISK /?
 40369                                  ;
 40370                                  ;	;
 40371                                  ;	:class B
 40372                                  ;	:def 4 "Cannot FDISK with network loaded",CR,LF
 40373                                  ;	:def 5 "No fixed disks present",CR,LF
 40374                                  ;	:def 6 "Error reading fixed disk",CR,LF
 40375                                  ;	:def 7 "Error writing fixed disk",CR,LF
 40376                                  ;	:def 11 "The Master boot code has NOT been updated.",CR,LF 
 40377                                  
 40378                                  	; PC-DOS 7.0 FDISK.COM (unpacked & disassembled Offset: DGROUP:2262h)
 40379                                  
 40380                                  CLASS_A_msg_tbl:
 40381 00005D7C FF                      		db 0FFh	; Class identifer : UTILITY_MSG_CLASS
 40382 00005D7D 0700                    		dw 7	; COMMAND.COM version check : 7.0 (PC-DOS 7.0)
 40383 00005D7F 09                      		db 9	; Total number of messages in class
 40384 00005D80 0100                    		dw 1	; Message number: 1
 40385 00005D82 2400                    		dw 24h	; Message offset from previous word. / Addr: 2266h+24h
 40386 00005D84 0200                    		dw 2	; Message number: 2
 40387 00005D86 3800                    		dw 38h	; Message offset from previous word. / Addr: 226Ah+38h
 40388 00005D88 0300                    		dw 3	; $M_NUM
 40389 00005D8A 4B00                    		dw 4Bh	; $M_TXT_PTR
 40390 00005D8C 0800                    		dw 8
 40391 00005D8E 6400                    		dw 64h
 40392 00005D90 0900                    		dw 9	; Message number: 9
 40393 00005D92 7400                    		dw 74h
 40394 00005D94 0A00                    		dw 10
 40395 00005D96 7300                    		dw 73h
 40396 00005D98 2C01                    		dw 300	; Message number: 300
 40397 00005D9A 7200                    		dw 72h	; Message offset from previous word. / Addr: 227Eh+72h
 40398 00005D9C 2D01                    		dw 301
 40399 00005D9E 9E00                    		dw 9Eh
 40400 00005DA0 2E01                    		dw 302
 40401 00005DA2 AE00                    		dw 0AEh
 40402 00005DA4 17496E636F72726563-     		db 17h,'Incorrect DOS version',0Dh,0Ah
 40402 00005DAD 7420444F5320766572-
 40402 00005DB6 73696F6E0D0A       
 40403 00005DBC 16253120616C726561-     		db 16h,'%1 already installed',0Dh,0Ah
 40403 00005DC5 647920696E7374616C-
 40403 00005DCE 6C65640D0A         
 40404 00005DD3 1C2531206279746573-     		db 1Ch,'%1 bytes available on disk',0Dh,0Ah
 40404 00005DDC 20617661696C61626C-
 40404 00005DE5 65206F6E206469736B-
 40404 00005DEE 0D0A               
 40405 00005DF0 13496E76616C696420-     		db 13h,'Invalid parameter',0Dh,0Ah
 40405 00005DF9 706172616D65746572-
 40405 00005E02 0D0A               
 40406 00005E04 02                      		db 2
 40407 00005E05 5900                    _yes:		db 'Y',0
 40408 00005E07 02                      		db 2
 40409 00005E08 4E00                    _no:		db 'N',0
 40410 00005E0A 2F                      options_msg:	db 2Fh
 40411 00005E0B 436F6E666967757265-     		db 'Configures a hard disk for use with PC DOS.',0Dh,0Ah
 40411 00005E14 732061206861726420-
 40411 00005E1D 6469736B20666F7220-
 40411 00005E26 757365207769746820-
 40411 00005E2F 504320444F532E0D0A 
 40412 00005E38 0D0A                    		db 0Dh,0Ah
 40413 00005E3A 13                      _fdisk_st_row:	db 13h
 40414 00005E3B 464449534B205B2F53-     		db 'FDISK [/STATUS]'
 40414 00005E44 54415455535D       
 40415 00005E4A 0D0A                    		db 0Dh,0Ah
 40416 00005E4C 0D0A                    		db 0Dh,	0Ah
 40417 00005E4E 3D                      stats_desc_row:	db 3Dh
 40418 00005E4F 202020202F53544154-     		db '    /STATUS     Displays the status of the fixed disk drive',0Dh,0Ah
 40418 00005E58 555320202020204469-
 40418 00005E61 73706C617973207468-
 40418 00005E6A 652073746174757320-
 40418 00005E73 6F6620746865206669-
 40418 00005E7C 786564206469736B20-
 40418 00005E85 64726976650D0A     
 40419                                  
 40420                                  		;db 0
 40421                                  align 2
 40422                                  
 40423                                  	; PC-DOS 7.0 FDISK.COM (unpacked & disassembled Offset: DGROUP:237Dh)
 40424                                  
 40425                                  CLASS_B_msg_tbl:
 40426 00005E8C FF                      		db 0FFh	; Class identifer : UTILITY_MSG_CLASS
 40427 00005E8D 0700                    		dw 7	; COMMAND.COM version check : 7.0 (PC-DOS 7.0)
 40428 00005E8F 05                      		db 5	; Total number of messages in class
 40429 00005E90 0400                    		dw 4	; $M_NUM
 40430 00005E92 1400                    		dw 14h	; $M_TXT_PTR
 40431 00005E94 0500                    		dw 5	; Message number: 5
 40432 00005E96 3300                    		dw 33h	; Message offset from previous word. / Addr: 2285h+33h
 40433 00005E98 0600                    		dw 6
 40434 00005E9A 4800                    		dw 48h
 40435 00005E9C 0700                    		dw 7
 40436 00005E9E 5F00                    		dw 5Fh
 40437 00005EA0 0B00                    		dw 11	; Message number: 11
 40438 00005EA2 7600                    		dw 76h	; Message offset from previous word. / Addr: 2291h+76h
 40439 00005EA4 22                      		db 22h
 40440 00005EA5 43616E6E6F74204644-     		db 'Cannot FDISK with network loaded',0Dh,0Ah
 40440 00005EAE 49534B207769746820-
 40440 00005EB7 6E6574776F726B206C-
 40440 00005EC0 6F616465640D0A     
 40441 00005EC7 18                      		db 18h
 40442 00005EC8 4E6F20666978656420-     		db 'No fixed disks present',0Dh,0Ah
 40442 00005ED1 6469736B7320707265-
 40442 00005EDA 73656E740D0A       
 40443 00005EE0 1A                      		db 1Ah
 40444 00005EE1 4572726F7220726561-     		db 'Error reading fixed disk',0Dh,0Ah
 40444 00005EEA 64696E672066697865-
 40444 00005EF3 64206469736B0D0A   
 40445 00005EFB 1A                      		db 1Ah
 40446 00005EFC 4572726F7220777269-     		db 'Error writing fixed disk',0Dh,0Ah
 40446 00005F05 74696E672066697865-
 40446 00005F0E 64206469736B0D0A   
 40447 00005F16 2C                      		db 2Ch
 40448 00005F17 546865206D61737465-     		db 'The master boot code has NOT been updated.',0Dh,0Ah
 40448 00005F20 7220626F6F7420636F-
 40448 00005F29 646520686173204E4F-
 40448 00005F32 54206265656E207570-
 40448 00005F3B 64617465642E0D0A   
 40449                                  
 40450                                  		;db 0
 40451 00005F43 90                      align 2
 40452                                  
 40453                                  CLASS_1_msg_tbl:
 40454 00005F44 01                      		db 1	; Class identifier : EXT_ERR_CLASS
 40455 00005F45 0700                    		dw 7	; COMMAND.COM version check : 7.0 (PC-DOS 7.0)
 40456 00005F47 01                      		db 1	; Total number of messages in class
 40457 00005F48 FFFF                    		dw 0FFFFh ; $M_NUM = -1
 40458 00005F4A 0400                    		dw 4	; $M_TXT_PTR
 40459 00005F4C 11                      _EXT_ERR_CLASS:	db 17	; Msg length
 40460 00005F4D 457874656E64656420-     		db 'Extended Error %1'
 40460 00005F56 4572726F72202531   
 40461                                  
 40462                                  		;db 0
 40463                                  
 40464                                  CLASS_2_msg_tbl:
 40465 00005F5E 02                      		db 2	; Class identifier : PARSE_ERR_CLASS
 40466 00005F5F 0700                    		dw 7	; COMMAND.COM version check : 7.0 (PC-DOS 7.0)
 40467 00005F61 01                      		db 1	; Total number of messages in class
 40468 00005F62 FFFF                    		dw 0FFFFh ; $M_NUM = -1
 40469 00005F64 0400                    		dw 4	; $M_TXT_PTR
 40470 00005F66 0E                      _PARSE_ERR_CLASSS: db 14 ; Msg length
 40471 00005F67 506172736520457272-     		db 'Parse Error %1'
 40471 00005F70 6F72202531         
 40472                                  
 40473                                  		;db 0
 40474                                  
 40475                                  ; 24/11/2018
 40476                                  extFAT16:
 40477 00005F75 464154313620202000      FAT16:		db 'FAT16   ',0
 40478                                  extFAT12:
 40479 00005F7E 464154313220202000      FAT12:		db 'FAT12   ',0
 40480                                  extNOVOLUME:
 40481 00005F87 00                      NOVOLUME:	db 0
 40482                                  extUNKNOWN:
 40483 00005F88 554E4B4E4F574E2000      UNKNOWN:	db 'UNKNOWN ',0
 40484                                  
 40485                                  ; 26/11/2018
 40486                                  ;extFAT16:	db 'FAT16   ',0 
 40487                                  ;extFAT12:	db 'FAT12   ',0
 40488                                  ;extNOVOLUME:	db 0
 40489                                  ;extUNKNOWN:	db 'UNKNOWN ',0
 40490                                  
 40491 00005F91 90                      align 2
 40492                                  
 40493                                  master_boot_record:
 40494 00005F92 FA33C08ED0BC007C8B-     	db 0FAh, 33h, 0C0h, 8Eh, 0D0h, 0BCh, 00h, 7Ch, 8Bh, 0F4h, 50h, 07h, 50h, 1Fh, 0FBh, 0FCh
 40494 00005F9B F45007501FFBFC     
 40495 00005FA2 BF0006B90001F2A5EA-     	db 0BFh, 00h, 06h, 0B9h, 00h, 01h, 0F2h, 0A5h, 0EAh, 1Dh, 06h, 00h, 00h, 0BEh, 0BEh, 07h
 40495 00005FAB 1D060000BEBE07     
 40496 00005FB2 B304803C80740E803C-     	db 0B3h, 04h, 80h, 3Ch,	80h, 74h, 0Eh, 80h, 3Ch, 00h, 75h, 1Ch,	83h, 0C6h, 10h,	0FEh
 40496 00005FBB 00751C83C610FE     
 40497 00005FC2 CB75EFCD188B148B4C-     	db 0CBh, 75h, 0EFh, 0CDh, 18h, 8Bh, 14h, 8Bh, 4Ch, 02h,	8Bh, 0EEh, 83h,	0C6h, 10h, 0FEh
 40497 00005FCB 028BEE83C610FE     
 40498 00005FD2 CB741A803C0074F4BE-     	db 0CBh, 74h, 1Ah, 80h,	3Ch, 00h, 74h, 0F4h, 0BEh, 8Bh,	06h, 0ACh, 3Ch,	00h, 74h, 0Bh
 40498 00005FDB 8B06AC3C00740B     
 40499 00005FE2 56BB0700B40ECD105E-     	db 56h,	0BBh, 07h, 00h,	0B4h, 0Eh, 0CDh, 10h, 5Eh, 0EBh, 0F0h, 0EBh, 0FEh, 0BFh, 05h, 00h
 40499 00005FEB EBF0EBFEBF0500     
 40500 00005FF2 BB007CB8010257CD13-     	db 0BBh, 00h, 7Ch, 0B8h, 01h, 02h, 57h,	0CDh, 13h, 5Fh,	73h, 0Ch, 33h, 0C0h, 0CDh, 13h
 40500 00005FFB 5F730C33C0CD13     
 40501 00006002 4F75EDBEA306EBD3BE-     	db 4Fh,	75h, 0EDh, 0BEh, 0A3h, 06h, 0EBh, 0D3h,	0BEh, 0C2h, 06h, 0BFh, 0FEh, 7Dh, 81h, 3Dh
 40501 0000600B C206BFFE7D813D     
 40502 00006012 55AA75C78BF5EA007C-     	db 55h,	0AAh, 75h, 0C7h, 8Bh, 0F5h, 0EAh, 00h, 7Ch, 00h, 00h, 49h, 6Eh,	76h, 61h, 6Ch
 40502 0000601B 0000496E76616C     
 40503 00006022 696420706172746974-     	db 69h,	64h, 20h, 70h, 61h, 72h, 74h, 69h, 74h,	69h, 6Fh, 6Eh, 20h, 74h, 61h, 62h
 40503 0000602B 696F6E20746162     
 40504 00006032 6C65004572726F7220-     	db 6Ch,	65h, 00h, 45h, 72h, 72h, 6Fh, 72h, 20h,	6Ch, 6Fh, 61h, 64h, 69h, 6Eh, 67h
 40504 0000603B 6C6F6164696E67     
 40505 00006042 206F7065726174696E-     	db 20h,	6Fh, 70h, 65h, 72h, 61h, 74h, 69h, 6Eh,	67h, 20h, 73h, 79h, 73h, 74h, 65h
 40505 0000604B 67207379737465     
 40506 00006052 6D004D697373696E67-     	db 6Dh,	00h, 4Dh, 69h, 73h, 73h, 69h, 6Eh, 67h,	20h, 6Fh, 70h, 65h, 72h, 61h, 74h
 40506 0000605B 206F7065726174     
 40507 00006062 696E67207379737465-     	db 69h,	6Eh, 67h, 20h, 73h, 79h, 73h, 74h, 65h,	6Dh, 00h, 00h, 00h, 00h, 00h, 00h
 40507 0000606B 6D000000000000     
 40508 00006072 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40508 0000607B 00000000000000     
 40509 00006082 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40509 0000608B 00000000000000     
 40510 00006092 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40510 0000609B 00000000000000     
 40511 000060A2 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40511 000060AB 00000000000000     
 40512 000060B2 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40512 000060BB 00000000000000     
 40513 000060C2 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40513 000060CB 00000000000000     
 40514 000060D2 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40514 000060DB 00000000000000     
 40515 000060E2 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40515 000060EB 00000000000000     
 40516 000060F2 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40516 000060FB 00000000000000     
 40517 00006102 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40517 0000610B 00000000000000     
 40518 00006112 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40518 0000611B 00000000000000     
 40519 00006122 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40519 0000612B 00000000000000     
 40520 00006132 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40520 0000613B 00000000000000     
 40521 00006142 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40521 0000614B 00000000000000     
 40522 00006152 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40522 0000615B 00000000000000     
 40523 00006162 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40523 0000616B 00000000000000     
 40524 00006172 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40524 0000617B 00000000000000     
 40525 00006182 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 55h, 0AAh
 40525 0000618B 000000000055AA     
 40526                                  mbr_hd1:
 40527 00006192 FA33C08ED0BC007C8B-     	db 0FAh, 33h, 0C0h, 8Eh, 0D0h, 0BCh, 00h, 7Ch, 8Bh, 0F4h, 50h, 07h, 50h, 1Fh, 0FBh, 0FCh
 40527 0000619B F45007501FFBFC     
 40528 000061A2 BF0006B90001F2A5EA-     	db 0BFh, 00h, 06h, 0B9h, 00h, 01h, 0F2h, 0A5h, 0EAh, 1Dh, 06h, 00h, 00h, 0BEh, 0BEh, 07h
 40528 000061AB 1D060000BEBE07     
 40529 000061B2 B304803C80740E803C-     	db 0B3h, 04h, 80h, 3Ch,	80h, 74h, 0Eh, 80h, 3Ch, 00h, 75h, 1Ch,	83h, 0C6h, 10h,	0FEh
 40529 000061BB 00751C83C610FE     
 40530 000061C2 CB75EFCD188B148B4C-     	db 0CBh, 75h, 0EFh, 0CDh, 18h, 8Bh, 14h, 8Bh, 4Ch, 02h,	8Bh, 0EEh, 83h,	0C6h, 10h, 0FEh
 40530 000061CB 028BEE83C610FE     
 40531 000061D2 CB741A803C0074F4BE-     	db 0CBh, 74h, 1Ah, 80h,	3Ch, 00h, 74h, 0F4h, 0BEh, 8Bh,	06h, 0ACh, 3Ch,	00h, 74h, 0Bh
 40531 000061DB 8B06AC3C00740B     
 40532 000061E2 56BB0700B40ECD105E-     	db 56h,	0BBh, 07h, 00h,	0B4h, 0Eh, 0CDh, 10h, 5Eh, 0EBh, 0F0h, 0EBh, 0FEh, 0BFh, 05h, 00h
 40532 000061EB EBF0EBFEBF0500     
 40533 000061F2 BB007CB8010257CD13-     	db 0BBh, 00h, 7Ch, 0B8h, 01h, 02h, 57h,	0CDh, 13h, 5Fh,	73h, 0Ch, 33h, 0C0h, 0CDh, 13h
 40533 000061FB 5F730C33C0CD13     
 40534 00006202 4F75EDBEA306EBD3BE-     	db 4Fh,	75h, 0EDh, 0BEh, 0A3h, 06h, 0EBh, 0D3h,	0BEh, 0C2h, 06h, 0BFh, 0FEh, 7Dh, 81h, 3Dh
 40534 0000620B C206BFFE7D813D     
 40535 00006212 55AA75C78BF5EA007C-     	db 55h,	0AAh, 75h, 0C7h, 8Bh, 0F5h, 0EAh, 00h, 7Ch, 00h, 00h, 49h, 6Eh,	76h, 61h, 6Ch
 40535 0000621B 0000496E76616C     
 40536 00006222 696420706172746974-     	db 69h,	64h, 20h, 70h, 61h, 72h, 74h, 69h, 74h,	69h, 6Fh, 6Eh, 20h, 74h, 61h, 62h
 40536 0000622B 696F6E20746162     
 40537 00006232 6C65004572726F7220-     	db 6Ch,	65h, 00h, 45h, 72h, 72h, 6Fh, 72h, 20h,	6Ch, 6Fh, 61h, 64h, 69h, 6Eh, 67h
 40537 0000623B 6C6F6164696E67     
 40538 00006242 206F7065726174696E-     	db 20h,	6Fh, 70h, 65h, 72h, 61h, 74h, 69h, 6Eh,	67h, 20h, 73h, 79h, 73h, 74h, 65h
 40538 0000624B 67207379737465     
 40539 00006252 6D004D697373696E67-     	db 6Dh,	00h, 4Dh, 69h, 73h, 73h, 69h, 6Eh, 67h,	20h, 6Fh, 70h, 65h, 72h, 61h, 74h
 40539 0000625B 206F7065726174     
 40540 00006262 696E67207379737465-     	db 69h,	6Eh, 67h, 20h, 73h, 79h, 73h, 74h, 65h,	6Dh, 00h, 00h, 00h, 00h, 00h, 00h
 40540 0000626B 6D000000000000     
 40541 00006272 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40541 0000627B 00000000000000     
 40542 00006282 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40542 0000628B 00000000000000     
 40543 00006292 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40543 0000629B 00000000000000     
 40544 000062A2 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40544 000062AB 00000000000000     
 40545 000062B2 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40545 000062BB 00000000000000     
 40546 000062C2 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40546 000062CB 00000000000000     
 40547 000062D2 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40547 000062DB 00000000000000     
 40548 000062E2 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40548 000062EB 00000000000000     
 40549 000062F2 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40549 000062FB 00000000000000     
 40550 00006302 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40550 0000630B 00000000000000     
 40551 00006312 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40551 0000631B 00000000000000     
 40552 00006322 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40552 0000632B 00000000000000     
 40553 00006332 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40553 0000633B 00000000000000     
 40554 00006342 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40554 0000634B 00000000000000     
 40555 00006352 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40555 0000635B 00000000000000     
 40556 00006362 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40556 0000636B 00000000000000     
 40557 00006372 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40557 0000637B 00000000000000     
 40558 00006382 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 55h, 0AAh
 40558 0000638B 000000000055AA     
 40559                                  mbr_hd2:
 40560 00006392 FA33C08ED0BC007C8B-     	db 0FAh, 33h, 0C0h, 8Eh, 0D0h, 0BCh, 00h, 7Ch, 8Bh, 0F4h, 50h, 07h, 50h, 1Fh, 0FBh, 0FCh
 40560 0000639B F45007501FFBFC     
 40561 000063A2 BF0006B90001F2A5EA-     	db 0BFh, 00h, 06h, 0B9h, 00h, 01h, 0F2h, 0A5h, 0EAh, 1Dh, 06h, 00h, 00h, 0BEh, 0BEh, 07h
 40561 000063AB 1D060000BEBE07     
 40562 000063B2 B304803C80740E803C-     	db 0B3h, 04h, 80h, 3Ch,	80h, 74h, 0Eh, 80h, 3Ch, 00h, 75h, 1Ch,	83h, 0C6h, 10h,	0FEh
 40562 000063BB 00751C83C610FE     
 40563 000063C2 CB75EFCD188B148B4C-     	db 0CBh, 75h, 0EFh, 0CDh, 18h, 8Bh, 14h, 8Bh, 4Ch, 02h,	8Bh, 0EEh, 83h,	0C6h, 10h, 0FEh
 40563 000063CB 028BEE83C610FE     
 40564 000063D2 CB741A803C0074F4BE-     	db 0CBh, 74h, 1Ah, 80h,	3Ch, 00h, 74h, 0F4h, 0BEh, 8Bh,	06h, 0ACh, 3Ch,	00h, 74h, 0Bh
 40564 000063DB 8B06AC3C00740B     
 40565 000063E2 56BB0700B40ECD105E-     	db 56h,	0BBh, 07h, 00h,	0B4h, 0Eh, 0CDh, 10h, 5Eh, 0EBh, 0F0h, 0EBh, 0FEh, 0BFh, 05h, 00h
 40565 000063EB EBF0EBFEBF0500     
 40566 000063F2 BB007CB8010257CD13-     	db 0BBh, 00h, 7Ch, 0B8h, 01h, 02h, 57h,	0CDh, 13h, 5Fh,	73h, 0Ch, 33h, 0C0h, 0CDh, 13h
 40566 000063FB 5F730C33C0CD13     
 40567 00006402 4F75EDBEA306EBD3BE-     	db 4Fh,	75h, 0EDh, 0BEh, 0A3h, 06h, 0EBh, 0D3h,	0BEh, 0C2h, 06h, 0BFh, 0FEh, 7Dh, 81h, 3Dh
 40567 0000640B C206BFFE7D813D     
 40568 00006412 55AA75C78BF5EA007C-     	db 55h,	0AAh, 75h, 0C7h, 8Bh, 0F5h, 0EAh, 00h, 7Ch, 00h, 00h, 49h, 6Eh,	76h, 61h, 6Ch
 40568 0000641B 0000496E76616C     
 40569 00006422 696420706172746974-     	db 69h,	64h, 20h, 70h, 61h, 72h, 74h, 69h, 74h,	69h, 6Fh, 6Eh, 20h, 74h, 61h, 62h
 40569 0000642B 696F6E20746162     
 40570 00006432 6C65004572726F7220-     	db 6Ch,	65h, 00h, 45h, 72h, 72h, 6Fh, 72h, 20h,	6Ch, 6Fh, 61h, 64h, 69h, 6Eh, 67h
 40570 0000643B 6C6F6164696E67     
 40571 00006442 206F7065726174696E-     	db 20h,	6Fh, 70h, 65h, 72h, 61h, 74h, 69h, 6Eh,	67h, 20h, 73h, 79h, 73h, 74h, 65h
 40571 0000644B 67207379737465     
 40572 00006452 6D004D697373696E67-     	db 6Dh,	00h, 4Dh, 69h, 73h, 73h, 69h, 6Eh, 67h,	20h, 6Fh, 70h, 65h, 72h, 61h, 74h
 40572 0000645B 206F7065726174     
 40573 00006462 696E67207379737465-     	db 69h,	6Eh, 67h, 20h, 73h, 79h, 73h, 74h, 65h,	6Dh, 00h, 00h, 00h, 00h, 00h, 00h
 40573 0000646B 6D000000000000     
 40574 00006472 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40574 0000647B 00000000000000     
 40575 00006482 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40575 0000648B 00000000000000     
 40576 00006492 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40576 0000649B 00000000000000     
 40577 000064A2 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40577 000064AB 00000000000000     
 40578 000064B2 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40578 000064BB 00000000000000     
 40579 000064C2 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40579 000064CB 00000000000000     
 40580 000064D2 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40580 000064DB 00000000000000     
 40581 000064E2 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40581 000064EB 00000000000000     
 40582 000064F2 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40582 000064FB 00000000000000     
 40583 00006502 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40583 0000650B 00000000000000     
 40584 00006512 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40584 0000651B 00000000000000     
 40585 00006522 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40585 0000652B 00000000000000     
 40586 00006532 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40586 0000653B 00000000000000     
 40587 00006542 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40587 0000654B 00000000000000     
 40588 00006552 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40588 0000655B 00000000000000     
 40589 00006562 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40589 0000656B 00000000000000     
 40590 00006572 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40590 0000657B 00000000000000     
 40591 00006582 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 55h, 0AAh
 40591 0000658B 000000000055AA     
 40592                                  mbr_hd3:
 40593 00006592 FA33C08ED0BC007C8B-     	db 0FAh, 33h, 0C0h, 8Eh, 0D0h, 0BCh, 00h, 7Ch, 8Bh, 0F4h, 50h, 07h, 50h, 1Fh, 0FBh, 0FCh
 40593 0000659B F45007501FFBFC     
 40594 000065A2 BF0006B90001F2A5EA-     	db 0BFh, 00h, 06h, 0B9h, 00h, 01h, 0F2h, 0A5h, 0EAh, 1Dh, 06h, 00h, 00h, 0BEh, 0BEh, 07h
 40594 000065AB 1D060000BEBE07     
 40595 000065B2 B304803C80740E803C-     	db 0B3h, 04h, 80h, 3Ch,	80h, 74h, 0Eh, 80h, 3Ch, 00h, 75h, 1Ch,	83h, 0C6h, 10h,	0FEh
 40595 000065BB 00751C83C610FE     
 40596 000065C2 CB75EFCD188B148B4C-     	db 0CBh, 75h, 0EFh, 0CDh, 18h, 8Bh, 14h, 8Bh, 4Ch, 02h,	8Bh, 0EEh, 83h,	0C6h, 10h, 0FEh
 40596 000065CB 028BEE83C610FE     
 40597 000065D2 CB741A803C0074F4BE-     	db 0CBh, 74h, 1Ah, 80h,	3Ch, 00h, 74h, 0F4h, 0BEh, 8Bh,	06h, 0ACh, 3Ch,	00h, 74h, 0Bh
 40597 000065DB 8B06AC3C00740B     
 40598 000065E2 56BB0700B40ECD105E-     	db 56h,	0BBh, 07h, 00h,	0B4h, 0Eh, 0CDh, 10h, 5Eh, 0EBh, 0F0h, 0EBh, 0FEh, 0BFh, 05h, 00h
 40598 000065EB EBF0EBFEBF0500     
 40599 000065F2 BB007CB8010257CD13-     	db 0BBh, 00h, 7Ch, 0B8h, 01h, 02h, 57h,	0CDh, 13h, 5Fh,	73h, 0Ch, 33h, 0C0h, 0CDh, 13h
 40599 000065FB 5F730C33C0CD13     
 40600 00006602 4F75EDBEA306EBD3BE-     	db 4Fh,	75h, 0EDh, 0BEh, 0A3h, 06h, 0EBh, 0D3h,	0BEh, 0C2h, 06h, 0BFh, 0FEh, 7Dh, 81h, 3Dh
 40600 0000660B C206BFFE7D813D     
 40601 00006612 55AA75C78BF5EA007C-     	db 55h,	0AAh, 75h, 0C7h, 8Bh, 0F5h, 0EAh, 00h, 7Ch, 00h, 00h, 49h, 6Eh,	76h, 61h, 6Ch
 40601 0000661B 0000496E76616C     
 40602 00006622 696420706172746974-     	db 69h,	64h, 20h, 70h, 61h, 72h, 74h, 69h, 74h,	69h, 6Fh, 6Eh, 20h, 74h, 61h, 62h
 40602 0000662B 696F6E20746162     
 40603 00006632 6C65004572726F7220-     	db 6Ch,	65h, 00h, 45h, 72h, 72h, 6Fh, 72h, 20h,	6Ch, 6Fh, 61h, 64h, 69h, 6Eh, 67h
 40603 0000663B 6C6F6164696E67     
 40604 00006642 206F7065726174696E-     	db 20h,	6Fh, 70h, 65h, 72h, 61h, 74h, 69h, 6Eh,	67h, 20h, 73h, 79h, 73h, 74h, 65h
 40604 0000664B 67207379737465     
 40605 00006652 6D004D697373696E67-     	db 6Dh,	00h, 4Dh, 69h, 73h, 73h, 69h, 6Eh, 67h,	20h, 6Fh, 70h, 65h, 72h, 61h, 74h
 40605 0000665B 206F7065726174     
 40606 00006662 696E67207379737465-     	db 69h,	6Eh, 67h, 20h, 73h, 79h, 73h, 74h, 65h,	6Dh, 00h, 00h, 00h, 00h, 00h, 00h
 40606 0000666B 6D000000000000     
 40607 00006672 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40607 0000667B 00000000000000     
 40608 00006682 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40608 0000668B 00000000000000     
 40609 00006692 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40609 0000669B 00000000000000     
 40610 000066A2 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40610 000066AB 00000000000000     
 40611 000066B2 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40611 000066BB 00000000000000     
 40612 000066C2 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40612 000066CB 00000000000000     
 40613 000066D2 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40613 000066DB 00000000000000     
 40614 000066E2 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40614 000066EB 00000000000000     
 40615 000066F2 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40615 000066FB 00000000000000     
 40616 00006702 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40616 0000670B 00000000000000     
 40617 00006712 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40617 0000671B 00000000000000     
 40618 00006722 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40618 0000672B 00000000000000     
 40619 00006732 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40619 0000673B 00000000000000     
 40620 00006742 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40620 0000674B 00000000000000     
 40621 00006752 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40621 0000675B 00000000000000     
 40622 00006762 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40622 0000676B 00000000000000     
 40623 00006772 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40623 0000677B 00000000000000     
 40624 00006782 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 55h, 0AAh
 40624 0000678B 000000000055AA     
 40625                                  mbr_5:
 40626 00006792 FA33C08ED0BC007C8B-     	db 0FAh, 33h, 0C0h, 8Eh, 0D0h, 0BCh, 00h, 7Ch, 8Bh, 0F4h, 50h, 07h, 50h, 1Fh, 0FBh, 0FCh
 40626 0000679B F45007501FFBFC     
 40627 000067A2 BF0006B90001F2A5EA-     	db 0BFh, 00h, 06h, 0B9h, 00h, 01h, 0F2h, 0A5h, 0EAh, 1Dh, 06h, 00h, 00h, 0BEh, 0BEh, 07h
 40627 000067AB 1D060000BEBE07     
 40628 000067B2 B304803C80740E803C-     	db 0B3h, 04h, 80h, 3Ch,	80h, 74h, 0Eh, 80h, 3Ch, 00h, 75h, 1Ch,	83h, 0C6h, 10h,	0FEh
 40628 000067BB 00751C83C610FE     
 40629 000067C2 CB75EFCD188B148B4C-     	db 0CBh, 75h, 0EFh, 0CDh, 18h, 8Bh, 14h, 8Bh, 4Ch, 02h,	8Bh, 0EEh, 83h,	0C6h, 10h, 0FEh
 40629 000067CB 028BEE83C610FE     
 40630 000067D2 CB741A803C0074F4BE-     	db 0CBh, 74h, 1Ah, 80h,	3Ch, 00h, 74h, 0F4h, 0BEh, 8Bh,	06h, 0ACh, 3Ch,	00h, 74h, 0Bh
 40630 000067DB 8B06AC3C00740B     
 40631 000067E2 56BB0700B40ECD105E-     	db 56h,	0BBh, 07h, 00h,	0B4h, 0Eh, 0CDh, 10h, 5Eh, 0EBh, 0F0h, 0EBh, 0FEh, 0BFh, 05h, 00h
 40631 000067EB EBF0EBFEBF0500     
 40632 000067F2 BB007CB8010257CD13-     	db 0BBh, 00h, 7Ch, 0B8h, 01h, 02h, 57h,	0CDh, 13h, 5Fh,	73h, 0Ch, 33h, 0C0h, 0CDh, 13h
 40632 000067FB 5F730C33C0CD13     
 40633 00006802 4F75EDBEA306EBD3BE-     	db 4Fh,	75h, 0EDh, 0BEh, 0A3h, 06h, 0EBh, 0D3h,	0BEh, 0C2h, 06h, 0BFh, 0FEh, 7Dh, 81h, 3Dh
 40633 0000680B C206BFFE7D813D     
 40634 00006812 55AA75C78BF5EA007C-     	db 55h,	0AAh, 75h, 0C7h, 8Bh, 0F5h, 0EAh, 00h, 7Ch, 00h, 00h, 49h, 6Eh,	76h, 61h, 6Ch
 40634 0000681B 0000496E76616C     
 40635 00006822 696420706172746974-     	db 69h,	64h, 20h, 70h, 61h, 72h, 74h, 69h, 74h,	69h, 6Fh, 6Eh, 20h, 74h, 61h, 62h
 40635 0000682B 696F6E20746162     
 40636 00006832 6C65004572726F7220-     	db 6Ch,	65h, 00h, 45h, 72h, 72h, 6Fh, 72h, 20h,	6Ch, 6Fh, 61h, 64h, 69h, 6Eh, 67h
 40636 0000683B 6C6F6164696E67     
 40637 00006842 206F7065726174696E-     	db 20h,	6Fh, 70h, 65h, 72h, 61h, 74h, 69h, 6Eh,	67h, 20h, 73h, 79h, 73h, 74h, 65h
 40637 0000684B 67207379737465     
 40638 00006852 6D004D697373696E67-     	db 6Dh,	00h, 4Dh, 69h, 73h, 73h, 69h, 6Eh, 67h,	20h, 6Fh, 70h, 65h, 72h, 61h, 74h
 40638 0000685B 206F7065726174     
 40639 00006862 696E67207379737465-     	db 69h,	6Eh, 67h, 20h, 73h, 79h, 73h, 74h, 65h,	6Dh, 00h, 00h, 00h, 00h, 00h, 00h
 40639 0000686B 6D000000000000     
 40640 00006872 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40640 0000687B 00000000000000     
 40641 00006882 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40641 0000688B 00000000000000     
 40642 00006892 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40642 0000689B 00000000000000     
 40643 000068A2 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40643 000068AB 00000000000000     
 40644 000068B2 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40644 000068BB 00000000000000     
 40645 000068C2 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40645 000068CB 00000000000000     
 40646 000068D2 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40646 000068DB 00000000000000     
 40647 000068E2 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40647 000068EB 00000000000000     
 40648 000068F2 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40648 000068FB 00000000000000     
 40649 00006902 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40649 0000690B 00000000000000     
 40650 00006912 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40650 0000691B 00000000000000     
 40651 00006922 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40651 0000692B 00000000000000     
 40652 00006932 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40652 0000693B 00000000000000     
 40653 00006942 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40653 0000694B 00000000000000     
 40654 00006952 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40654 0000695B 00000000000000     
 40655 00006962 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40655 0000696B 00000000000000     
 40656 00006972 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40656 0000697B 00000000000000     
 40657 00006982 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 55h, 0AAh
 40657 0000698B 000000000055AA     
 40658                                  mbr_6:
 40659 00006992 FA33C08ED0BC007C8B-     	db 0FAh, 33h, 0C0h, 8Eh, 0D0h, 0BCh, 00h, 7Ch, 8Bh, 0F4h, 50h, 07h, 50h, 1Fh, 0FBh, 0FCh
 40659 0000699B F45007501FFBFC     
 40660 000069A2 BF0006B90001F2A5EA-     	db 0BFh, 00h, 06h, 0B9h, 00h, 01h, 0F2h, 0A5h, 0EAh, 1Dh, 06h, 00h, 00h, 0BEh, 0BEh, 07h
 40660 000069AB 1D060000BEBE07     
 40661 000069B2 B304803C80740E803C-     	db 0B3h, 04h, 80h, 3Ch,	80h, 74h, 0Eh, 80h, 3Ch, 00h, 75h, 1Ch,	83h, 0C6h, 10h,	0FEh
 40661 000069BB 00751C83C610FE     
 40662 000069C2 CB75EFCD188B148B4C-     	db 0CBh, 75h, 0EFh, 0CDh, 18h, 8Bh, 14h, 8Bh, 4Ch, 02h,	8Bh, 0EEh, 83h,	0C6h, 10h, 0FEh
 40662 000069CB 028BEE83C610FE     
 40663 000069D2 CB741A803C0074F4BE-     	db 0CBh, 74h, 1Ah, 80h,	3Ch, 00h, 74h, 0F4h, 0BEh, 8Bh,	06h, 0ACh, 3Ch,	00h, 74h, 0Bh
 40663 000069DB 8B06AC3C00740B     
 40664 000069E2 56BB0700B40ECD105E-     	db 56h,	0BBh, 07h, 00h,	0B4h, 0Eh, 0CDh, 10h, 5Eh, 0EBh, 0F0h, 0EBh, 0FEh, 0BFh, 05h, 00h
 40664 000069EB EBF0EBFEBF0500     
 40665 000069F2 BB007CB8010257CD13-     	db 0BBh, 00h, 7Ch, 0B8h, 01h, 02h, 57h,	0CDh, 13h, 5Fh,	73h, 0Ch, 33h, 0C0h, 0CDh, 13h
 40665 000069FB 5F730C33C0CD13     
 40666 00006A02 4F75EDBEA306EBD3BE-     	db 4Fh,	75h, 0EDh, 0BEh, 0A3h, 06h, 0EBh, 0D3h,	0BEh, 0C2h, 06h, 0BFh, 0FEh, 7Dh, 81h, 3Dh
 40666 00006A0B C206BFFE7D813D     
 40667 00006A12 55AA75C78BF5EA007C-     	db 55h,	0AAh, 75h, 0C7h, 8Bh, 0F5h, 0EAh, 00h, 7Ch, 00h, 00h, 49h, 6Eh,	76h, 61h, 6Ch
 40667 00006A1B 0000496E76616C     
 40668 00006A22 696420706172746974-     	db 69h,	64h, 20h, 70h, 61h, 72h, 74h, 69h, 74h,	69h, 6Fh, 6Eh, 20h, 74h, 61h, 62h
 40668 00006A2B 696F6E20746162     
 40669 00006A32 6C65004572726F7220-     	db 6Ch,	65h, 00h, 45h, 72h, 72h, 6Fh, 72h, 20h,	6Ch, 6Fh, 61h, 64h, 69h, 6Eh, 67h
 40669 00006A3B 6C6F6164696E67     
 40670 00006A42 206F7065726174696E-     	db 20h,	6Fh, 70h, 65h, 72h, 61h, 74h, 69h, 6Eh,	67h, 20h, 73h, 79h, 73h, 74h, 65h
 40670 00006A4B 67207379737465     
 40671 00006A52 6D004D697373696E67-     	db 6Dh,	00h, 4Dh, 69h, 73h, 73h, 69h, 6Eh, 67h,	20h, 6Fh, 70h, 65h, 72h, 61h, 74h
 40671 00006A5B 206F7065726174     
 40672 00006A62 696E67207379737465-     	db 69h,	6Eh, 67h, 20h, 73h, 79h, 73h, 74h, 65h,	6Dh, 00h, 00h, 00h, 00h, 00h, 00h
 40672 00006A6B 6D000000000000     
 40673 00006A72 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40673 00006A7B 00000000000000     
 40674 00006A82 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40674 00006A8B 00000000000000     
 40675 00006A92 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40675 00006A9B 00000000000000     
 40676 00006AA2 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40676 00006AAB 00000000000000     
 40677 00006AB2 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40677 00006ABB 00000000000000     
 40678 00006AC2 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40678 00006ACB 00000000000000     
 40679 00006AD2 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40679 00006ADB 00000000000000     
 40680 00006AE2 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40680 00006AEB 00000000000000     
 40681 00006AF2 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40681 00006AFB 00000000000000     
 40682 00006B02 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40682 00006B0B 00000000000000     
 40683 00006B12 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40683 00006B1B 00000000000000     
 40684 00006B22 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40684 00006B2B 00000000000000     
 40685 00006B32 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40685 00006B3B 00000000000000     
 40686 00006B42 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40686 00006B4B 00000000000000     
 40687 00006B52 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40687 00006B5B 00000000000000     
 40688 00006B62 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40688 00006B6B 00000000000000     
 40689 00006B72 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40689 00006B7B 00000000000000     
 40690 00006B82 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 55h, 0AAh
 40690 00006B8B 000000000055AA     
 40691                                  mbr_7:
 40692 00006B92 FA33C08ED0BC007C8B-     	db 0FAh, 33h, 0C0h, 8Eh, 0D0h, 0BCh, 00h, 7Ch, 8Bh, 0F4h, 50h, 07h, 50h, 1Fh, 0FBh, 0FCh
 40692 00006B9B F45007501FFBFC     
 40693 00006BA2 BF0006B90001F2A5EA-     	db 0BFh, 00h, 06h, 0B9h, 00h, 01h, 0F2h, 0A5h, 0EAh, 1Dh, 06h, 00h, 00h, 0BEh, 0BEh, 07h
 40693 00006BAB 1D060000BEBE07     
 40694 00006BB2 B304803C80740E803C-     	db 0B3h, 04h, 80h, 3Ch,	80h, 74h, 0Eh, 80h, 3Ch, 00h, 75h, 1Ch,	83h, 0C6h, 10h,	0FEh
 40694 00006BBB 00751C83C610FE     
 40695 00006BC2 CB75EFCD188B148B4C-     	db 0CBh, 75h, 0EFh, 0CDh, 18h, 8Bh, 14h, 8Bh, 4Ch, 02h,	8Bh, 0EEh, 83h,	0C6h, 10h, 0FEh
 40695 00006BCB 028BEE83C610FE     
 40696 00006BD2 CB741A803C0074F4BE-     	db 0CBh, 74h, 1Ah, 80h,	3Ch, 00h, 74h, 0F4h, 0BEh, 8Bh,	06h, 0ACh, 3Ch,	00h, 74h, 0Bh
 40696 00006BDB 8B06AC3C00740B     
 40697 00006BE2 56BB0700B40ECD105E-     	db 56h,	0BBh, 07h, 00h,	0B4h, 0Eh, 0CDh, 10h, 5Eh, 0EBh, 0F0h, 0EBh, 0FEh, 0BFh, 05h, 00h
 40697 00006BEB EBF0EBFEBF0500     
 40698 00006BF2 BB007CB8010257CD13-     	db 0BBh, 00h, 7Ch, 0B8h, 01h, 02h, 57h,	0CDh, 13h, 5Fh,	73h, 0Ch, 33h, 0C0h, 0CDh, 13h
 40698 00006BFB 5F730C33C0CD13     
 40699 00006C02 4F75EDBEA306EBD3BE-     	db 4Fh,	75h, 0EDh, 0BEh, 0A3h, 06h, 0EBh, 0D3h,	0BEh, 0C2h, 06h, 0BFh, 0FEh, 7Dh, 81h, 3Dh
 40699 00006C0B C206BFFE7D813D     
 40700 00006C12 55AA75C78BF5EA007C-     	db 55h,	0AAh, 75h, 0C7h, 8Bh, 0F5h, 0EAh, 00h, 7Ch, 00h, 00h, 49h, 6Eh,	76h, 61h, 6Ch
 40700 00006C1B 0000496E76616C     
 40701 00006C22 696420706172746974-     	db 69h,	64h, 20h, 70h, 61h, 72h, 74h, 69h, 74h,	69h, 6Fh, 6Eh, 20h, 74h, 61h, 62h
 40701 00006C2B 696F6E20746162     
 40702 00006C32 6C65004572726F7220-     	db 6Ch,	65h, 00h, 45h, 72h, 72h, 6Fh, 72h, 20h,	6Ch, 6Fh, 61h, 64h, 69h, 6Eh, 67h
 40702 00006C3B 6C6F6164696E67     
 40703 00006C42 206F7065726174696E-     	db 20h,	6Fh, 70h, 65h, 72h, 61h, 74h, 69h, 6Eh,	67h, 20h, 73h, 79h, 73h, 74h, 65h
 40703 00006C4B 67207379737465     
 40704 00006C52 6D004D697373696E67-     	db 6Dh,	00h, 4Dh, 69h, 73h, 73h, 69h, 6Eh, 67h,	20h, 6Fh, 70h, 65h, 72h, 61h, 74h
 40704 00006C5B 206F7065726174     
 40705 00006C62 696E67207379737465-     	db 69h,	6Eh, 67h, 20h, 73h, 79h, 73h, 74h, 65h,	6Dh, 00h, 00h, 00h, 00h, 00h, 00h
 40705 00006C6B 6D000000000000     
 40706 00006C72 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40706 00006C7B 00000000000000     
 40707 00006C82 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40707 00006C8B 00000000000000     
 40708 00006C92 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40708 00006C9B 00000000000000     
 40709 00006CA2 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40709 00006CAB 00000000000000     
 40710 00006CB2 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40710 00006CBB 00000000000000     
 40711 00006CC2 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40711 00006CCB 00000000000000     
 40712 00006CD2 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40712 00006CDB 00000000000000     
 40713 00006CE2 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40713 00006CEB 00000000000000     
 40714 00006CF2 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40714 00006CFB 00000000000000     
 40715 00006D02 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40715 00006D0B 00000000000000     
 40716 00006D12 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40716 00006D1B 00000000000000     
 40717 00006D22 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40717 00006D2B 00000000000000     
 40718 00006D32 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40718 00006D3B 00000000000000     
 40719 00006D42 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40719 00006D4B 00000000000000     
 40720 00006D52 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40720 00006D5B 00000000000000     
 40721 00006D62 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40721 00006D6B 00000000000000     
 40722 00006D72 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40722 00006D7B 00000000000000     
 40723 00006D82 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 55h, 0AAh
 40723 00006D8B 000000000055AA     
 40724                                  
 40725                                  mbr_8:
 40726 00006D92 FA33C08ED0BC007C8B-     	db 0FAh, 33h, 0C0h, 8Eh, 0D0h, 0BCh, 00h, 7Ch, 8Bh, 0F4h, 50h, 07h, 50h, 1Fh, 0FBh, 0FCh
 40726 00006D9B F45007501FFBFC     
 40727 00006DA2 BF0006B90001F2A5EA-     	db 0BFh, 00h, 06h, 0B9h, 00h, 01h, 0F2h, 0A5h, 0EAh, 1Dh, 06h, 00h, 00h, 0BEh, 0BEh, 07h
 40727 00006DAB 1D060000BEBE07     
 40728 00006DB2 B304803C80740E803C-     	db 0B3h, 04h, 80h, 3Ch,	80h, 74h, 0Eh, 80h, 3Ch, 00h, 75h, 1Ch,	83h, 0C6h, 10h,	0FEh
 40728 00006DBB 00751C83C610FE     
 40729 00006DC2 CB75EFCD188B148B4C-     	db 0CBh, 75h, 0EFh, 0CDh, 18h, 8Bh, 14h, 8Bh, 4Ch, 02h,	8Bh, 0EEh, 83h,	0C6h, 10h, 0FEh
 40729 00006DCB 028BEE83C610FE     
 40730 00006DD2 CB741A803C0074F4BE-     	db 0CBh, 74h, 1Ah, 80h,	3Ch, 00h, 74h, 0F4h, 0BEh, 8Bh,	06h, 0ACh, 3Ch,	00h, 74h, 0Bh
 40730 00006DDB 8B06AC3C00740B     
 40731 00006DE2 56BB0700B40ECD105E-     	db 56h,	0BBh, 07h, 00h,	0B4h, 0Eh, 0CDh, 10h, 5Eh, 0EBh, 0F0h, 0EBh, 0FEh, 0BFh, 05h, 00h
 40731 00006DEB EBF0EBFEBF0500     
 40732 00006DF2 BB007CB8010257CD13-     	db 0BBh, 00h, 7Ch, 0B8h, 01h, 02h, 57h,	0CDh, 13h, 5Fh,	73h, 0Ch, 33h, 0C0h, 0CDh, 13h
 40732 00006DFB 5F730C33C0CD13     
 40733 00006E02 4F75EDBEA306EBD3BE-     	db 4Fh,	75h, 0EDh, 0BEh, 0A3h, 06h, 0EBh, 0D3h,	0BEh, 0C2h, 06h, 0BFh, 0FEh, 7Dh, 81h, 3Dh
 40733 00006E0B C206BFFE7D813D     
 40734 00006E12 55AA75C78BF5EA007C-     	db 55h,	0AAh, 75h, 0C7h, 8Bh, 0F5h, 0EAh, 00h, 7Ch, 00h, 00h, 49h, 6Eh,	76h, 61h, 6Ch
 40734 00006E1B 0000496E76616C     
 40735 00006E22 696420706172746974-     	db 69h,	64h, 20h, 70h, 61h, 72h, 74h, 69h, 74h,	69h, 6Fh, 6Eh, 20h, 74h, 61h, 62h
 40735 00006E2B 696F6E20746162     
 40736 00006E32 6C65004572726F7220-     	db 6Ch,	65h, 00h, 45h, 72h, 72h, 6Fh, 72h, 20h,	6Ch, 6Fh, 61h, 64h, 69h, 6Eh, 67h
 40736 00006E3B 6C6F6164696E67     
 40737 00006E42 206F7065726174696E-     	db 20h,	6Fh, 70h, 65h, 72h, 61h, 74h, 69h, 6Eh,	67h, 20h, 73h, 79h, 73h, 74h, 65h
 40737 00006E4B 67207379737465     
 40738 00006E52 6D004D697373696E67-     	db 6Dh,	00h, 4Dh, 69h, 73h, 73h, 69h, 6Eh, 67h,	20h, 6Fh, 70h, 65h, 72h, 61h, 74h
 40738 00006E5B 206F7065726174     
 40739 00006E62 696E67207379737465-     	db 69h,	6Eh, 67h, 20h, 73h, 79h, 73h, 74h, 65h,	6Dh, 00h, 00h, 00h, 00h, 00h, 00h
 40739 00006E6B 6D000000000000     
 40740 00006E72 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40740 00006E7B 00000000000000     
 40741 00006E82 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40741 00006E8B 00000000000000     
 40742 00006E92 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40742 00006E9B 00000000000000     
 40743 00006EA2 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40743 00006EAB 00000000000000     
 40744 00006EB2 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40744 00006EBB 00000000000000     
 40745 00006EC2 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40745 00006ECB 00000000000000     
 40746 00006ED2 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40746 00006EDB 00000000000000     
 40747 00006EE2 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40747 00006EEB 00000000000000     
 40748 00006EF2 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40748 00006EFB 00000000000000     
 40749 00006F02 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40749 00006F0B 00000000000000     
 40750 00006F12 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40750 00006F1B 00000000000000     
 40751 00006F22 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40751 00006F2B 00000000000000     
 40752 00006F32 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40752 00006F3B 00000000000000     
 40753 00006F42 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40753 00006F4B 00000000000000     
 40754 00006F52 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40754 00006F5B 00000000000000     
 40755 00006F62 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40755 00006F6B 00000000000000     
 40756 00006F72 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 40756 00006F7B 00000000000000     
 40757 00006F82 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 55h, 0AAh
 40757 00006F8B 000000000055AA     
 40758                                  
 40759                                  numinmsg_format:
 40760                                  		;db '%4.1d',0
 40761                                  glni_num_format:      ; 17/01/2019		
 40762                                  idc_tot_mb_format:
 40763                                  idc_def_entry_format: ; 14/01/2019
 40764                                  ld_p_size_format:
 40765                                  nd_p_size_format:
 40766                                  disk_size_format:
 40767                                  v_psize_format:	; 23/01/2019
 40768                                  v_mbytes_format:
 40769                                  ecp_size_format: ; 25/01/2019
 40770                                  ecp_mb_format:
 40771 00006F92 25342E316400            p_size_format:	db '%4.1d',0
 40772                                  v_mb_percent_format: ; 23/01/2019
 40773                                  ecp_mb_pcent_format: ; 25/01/2019
 40774                                  idc_mb_pcent_format:
 40775 00006F98 25342E316425332E31-     		db '%4.1d%3.1d%%',0
 40775 00006FA1 64252500           
 40776                                  v_percent_format:
 40777                                  ecp_pcent_format:
 40778 00006FA5 25332E3164252500        percent_format:	db '%3.1d%%',0
 40779                                  ;v_percent_format:db '%3.1d%%',0
 40780 00006FAD 2E222F5C5B5D3A7C3C-     invstrchars:	db '."/\[]:|<>+=;,',0
 40780 00006FB6 3E2B3D3B2C00       
 40781 00006FBC 00                      		db 0
 40782 00006FBD 202000                  twospace:	db '  ',0
 40783 00006FC0 2563256300              twochars:	db '%c%c',0
 40784                                  ptbl_row_format:
 40785 00006FC5 252D322E3273256325-     		db '%-2.2s%c%c%-7.7s%-11.11s%4.1d%-8.8s%3.1d%%',0
 40785 00006FCE 63252D372E3773252D-
 40785 00006FD7 31312E31317325342E-
 40785 00006FE0 3164252D382E387325-
 40785 00006FE9 332E3164252500     
 40786                                  align 2
 40787 00006FF0 25632563252D31312E-     eptbl_row_format:  db '%c%c%-11.11s%4.1d%-8.8s%3.1d%%',0
 40787 00006FF9 31317325342E316425-
 40787 00007002 2D382E387325332E31-
 40787 0000700B 64252500           
 40788 0000700F 25312E306425632563-     cd_pt_row_format:  db '%1.0d%c%c%4.1d%4.1d%3.1d%%',0
 40788 00007018 25342E316425342E31-
 40788 00007021 6425332E3164252500 
 40789 0000702A 25632563256325342E-     drv_mb_row_format: db '%c%c%c%4.1d%8c',0
 40789 00007033 316425386300       
 40790 00007039 25632563256325342E-     cdrv_mb_format:	   db '%c%c%c%4.1d%8c',0
 40790 00007042 316425386300       
 40791 00007048 25312E306425312E30-     cdrive_format:	   db '%1.0d%1.0d',0
 40791 00007051 6400               
 40792                                  
 40793 00007053 554E4B4E4F574E2000      NO_FORMAT:	db 'UNKNOWN ',0
 40794 0000705C 00                      NO_VOLUME:	db 0
 40795 0000705D 554E4B4E4F574E2000      _NOFORMAT:	db 'UNKNOWN ',0
 40796 00007066 00                      _NOVOLUME:	db 0
 40797 00007067 2F50524900              PRI:		db '/PRI',0
 40798 0000706C 2F45585400              EXT:		db '/EXT',0
 40799 00007071 2F4C4F4700              LOG:		db '/LOG',0
 40800 00007076 2F5100                  QUIET:		db '/Q',0
 40801 00007079 2F53544154555300        STATUS:		db '/STATUS',0
 40802 00007081 2F3F00                  OPTIONS:	db '/?',0
 40803 00007084 2F4D425200              MBR:		db '/MBR',0
 40804 00007089 3A5C3F3F3F3F3F3F3F-     FILE_NAME:	db ':\????????.???',0
 40804 00007092 3F2E3F3F3F00       
 40805                                  
 40806                                  align 2
 40807                                  
 40808 00007098 [F4CC]                  pinsert:	dw insert
 40809 0000709A 00000000                NOVAL:		dd 0
 40810                                  
 40811 0000709E 0000                    _$P_ordinal:	dw 0
 40812 000070A0 0000                    _$P_RC:		dw 0
 40813 000070A2 0000                    _$P_SI_Save:	dw 0
 40814 000070A4 0000                    _$P_DX:		dw 0
 40815 000070A6 00                      _$P_Terminator:	db 0
 40816 000070A7 0000                    _$P_DBCSEV_OFF:	dw 0
 40817 000070A9 0000                    _$P_DBCSEV_SEG:	dw 0
 40818                                  _$P_Flags:
 40819 000070AB 00                      _$P_Flags1:	db 0
 40820 000070AC 00                      _$P_Flags2:	db 0
 40821 000070AD 0000                    _$P_SaveSI_Cmpx: dw 0
 40822 000070AF 0000                    _$P_KEYorSW_Ptr: dw 0
 40823 000070B1 0000                    _$P_Save_EOB:	dw 0
 40824 000070B3 0000                    _$P_Found_SYNONYM: dw 0
 40825 000070B5 00<rep 80h>             _$P_STRING_BUF:	times 128 db 0		; Pick a operand from command line
 40826 00007135 00                      _$P_Got_Time:	db 0
 40827 00007136 FFFF                    _$P_Country_Info: dw _$P_NeedToBeRead ; 0FFFFh
 40828                                  		;times 32 db 0
 40829 00007138 00<rep 1Bh>             		times _$P_CDI.size - 2 db 0
 40830 00007153 0000                    _$P_1st_Val:	dw 0
 40831 00007155 0000                    _$P_2nd_Val:	dw 0
 40832 00007157 0000                    _$P_3rd_Val:	dw 0
 40833 00007159 0000                    _$P_4th_Val:	dw 0
 40834 0000715B FF                      _$P_Char_CAP_Ptr: db 0FFh
 40835 0000715C 0000                    		dw 0
 40836 0000715E 0000                    		dw 0
 40837 00007160 00                      _$P_err_flag:	db 0
 40838                                  
 40839                                  ; 15/12/2018
 40840                                  
 40841                                  ;/************************************************************************/
 40842                                  ;/*  FDISK MESSAGES                                                      */
 40843                                  ;/*                                                                      */
 40844                                  ;/* Portions of the screen that are handled in the msg are indicated on  */
 40845                                  ;/* the listing of the screen with the message name given. If the text   */
 40846                                  ;/* message is defined in another screen, then the name is followed by   */
 40847                                  ;/* a "#" character                                                      */
 40848                                  ;/*                                                                      */
 40849                                  ;/* NOTE TO TRANSLATORS                                                  */
 40850                                  ;/* The characters inside the <> and the  are control characters and   */
 40851                                  ;/* should not be translated. The Control characters are defined as      */
 40852                                  ;/* follows:                                                             */
 40853                                  ;/*                                                                      */
 40854                                  ;/* <H> - Highlight the following text                                   */
 40855                                  ;/* <R> - Regular text                                                   */
 40856                                  ;/* <U> - Underline the following text                                   */
 40857                                  ;/* <B> - Blink the following text                                       */
 40858                                  ;/* <O> - Turn off Blink                                                 */
 40859                                  ;/* <Y> - Print YES character, as set by define                          */
 40860                                  ;/* <N> - Print NO character, as set by define                           */
 40861                                  ;/* <W> - Sound the beep                                                 */
 40862                                  ;/* <S> - Save cursor position for later use                             */
 40863                                  ;/* <G> - Cursor position left justified and regular proceed to right    */
 40864                                  ;/* <C> - Clear the screen out from control char to end of line          */
 40865                                  ;/* <I> - Insert character from Insert[] string. This string must be set */
 40866                                  ;/*       up prior to displaying the message. The first <I> will insert  */
 40867                                  ;/*       Insert[0], the second Insert[1], etc....This will move the     */
 40868                                  ;/*       cursor one postition. The Insert%% string will be initialized  */
 40869                                  ;/*                                                                      */
 40870                                  ;/*  Multiple control characters can be between the <>.                  */
 40871                                  ;/*                                                                      */
 40872                                  ;/*  The  indicates Row and column for the text and has the format of  */
 40873                                  ;/*  rrcc where the numbers are decimal and zero based .first row/col  */
 40874                                  ;/*  is 00. The numbers are in decimal, and must be 2 characters, which  */
 40875                                  ;/*  means rows/cols 0-9 should be listed as 00-09. For example, the 5th */
 40876                                  ;/*  row, 3rd column on the screen would be listed as 0402.            */
 40877                                  ;/*                                                                      */
 40878                                  ;/*  The column number is always the column desired. The row number is   */
 40879                                  ;/*  an offset from the previous row. For example, if the text just      */
 40880                                  ;/*  printed is on row 6, and the next text should be printed 2 rows     */
 40881                                  ;/*  down in column 0, then the control strin would be 0201. The first */
 40882                                  ;/*  row specified in the message is assumed to be based off of row 0,   */
 40883                                  ;/*  it would actually specify the actual row for the start of the msg   */
 40884                                  ;/*  to be printed.                                                      */
 40885                                  ;/*                                                                      */
 40886                                  ;/************************************************************************/
 40887                                  
 40888                                  ; 01/12/2018
 40889                                  ; FORMATTED MENU TEXT
 40890                                  
 40891 00007161 063030303406            menu_1:		db 6,'0004',6
 40892 00007167 3C523E202020202020-     		db '<R>                           PC DOS Version 7.0 '
 40892 00007170 202020202020202020-
 40892 00007179 202020202020202020-
 40892 00007182 202020504320444F53-
 40892 0000718B 2056657273696F6E20-
 40892 00007194 372E3020           
 40893 00007198 063031303406            		db 6,'0104',6
 40894 0000719E 3C523E202020202020-     		db '<R>                         Fixed Disk Setup Program '
 40894 000071A7 202020202020202020-
 40894 000071B0 202020202020202020-
 40894 000071B9 204669786564204469-
 40894 000071C2 736B20536574757020-
 40894 000071CB 50726F6772616D20   
 40895 000071D3 063031303406            		db 6,'0104',6
 40896 000071D9 3C523E202020202020-     		db '<R>                Copyright (c) IBM Corporation 1983 - 1994',0
 40896 000071E2 202020202020202020-
 40896 000071EB 20436F707972696768-
 40896 000071F4 74202863292049424D-
 40896 000071FD 20436F72706F726174-
 40896 00007206 696F6E203139383320-
 40896 0000720F 2D203139393400     
 40897 00007216 063034303406            menu_2:		db 6,'0404',6
 40898 0000721C 3C483E202020202020-     		db '<H>                             FDISK Options '
 40898 00007225 202020202020202020-
 40898 0000722E 202020202020202020-
 40898 00007237 202020202046444953-
 40898 00007240 4B204F7074696F6E73-
 40898 00007249 20                 
 40899 0000724A 063036303406            		db 6,'0604',6
 40900 00007250 3C483E312E203C523E-     		db '<H>1. <R>Create DOS partition or Logical DOS Drive '
 40900 00007259 43726561746520444F-
 40900 00007262 532070617274697469-
 40900 0000726B 6F6E206F72204C6F67-
 40900 00007274 6963616C20444F5320-
 40900 0000727D 447269766520       
 40901 00007283 063031303406            		db 6,'0104',6
 40902 00007289 3C483E322E203C523E-     		db '<H>2. <R>Set active partition '
 40902 00007292 536574206163746976-
 40902 0000729B 652070617274697469-
 40902 000072A4 6F6E20             
 40903 000072A7 063031303406            		db 6,'0104',6
 40904 000072AD 3C483E332E203C523E-     		db '<H>3. <R>Delete partition or Logical DOS Drive '
 40904 000072B6 44656C657465207061-
 40904 000072BF 72746974696F6E206F-
 40904 000072C8 72204C6F676963616C-
 40904 000072D1 20444F532044726976-
 40904 000072DA 6520               
 40905 000072DC 063031303406            		db 6,'0104',6
 40906 000072E2 3C483E342E203C523E-     		db '<H>4. <R>Display partition information '
 40906 000072EB 446973706C61792070-
 40906 000072F4 6172746974696F6E20-
 40906 000072FD 696E666F726D617469-
 40906 00007306 6F6E20             
 40907 00007309 063131303406            		db 6,'1104',6
 40908 0000730F 3C523E507265737320-     		db '<R>Press <H>Esc<R> to exit FDISK',0
 40908 00007318 3C483E4573633C523E-
 40908 00007321 20746F206578697420-
 40908 0000732A 464449534B00       
 40909 00007330 063038303406            menu_3:		db 6,'0804',6
 40910 00007336 3C523E43686F6F7365-     		db '<R>Choose one of the following:',0
 40910 0000733F 206F6E65206F662074-
 40910 00007348 686520666F6C6C6F77-
 40910 00007351 696E673A00         
 40911 00007356 063134303406            menu_4:		db 6,'1404',6
 40912 0000735C 3C483E352E203C523E-     		db '<H>5. <R>Change current fixed disk drive',0
 40912 00007365 4368616E6765206375-
 40912 0000736E 7272656E7420666978-
 40912 00007377 6564206469736B2064-
 40912 00007380 7269766500         
 40913 00007385 063036303406            menu_5:		db 6,'0604',6
 40914 0000738B 3C523E43757272656E-     		db '<R>Current fixed disk drive: <H><I>',0
 40914 00007394 742066697865642064-
 40914 0000739D 69736B206472697665-
 40914 000073A6 3A203C483E3C493E00 
 40915 000073AF 063230303406            menu_6:		db 6,'2004',6
 40916 000073B5 3C483E5741524E494E-     		db '<H>WARNING! <R>No partitions are set active - disk 1 is not startable unless '
 40916 000073BE 4721203C523E4E6F20-
 40916 000073C7 706172746974696F6E-
 40916 000073D0 732061726520736574-
 40916 000073D9 20616374697665202D-
 40916 000073E2 206469736B20312069-
 40916 000073EB 73206E6F7420737461-
 40916 000073F4 727461626C6520756E-
 40916 000073FD 6C65737320         
 40917 00007402 063031303406            		db 6,'0104',6
 40918 00007408 3C523E612070617274-     		db '<R>a partition is set active',0
 40918 00007411 6974696F6E20697320-
 40918 0000741A 736574206163746976-
 40918 00007423 6500               
 40919 00007425 063137303406            menu_7:		db 6,'1704',6
 40920 0000742B 3C523E456E74657220-     		db '<R>Enter choice: <H>[<S> ]',0
 40920 00007434 63686F6963653A203C-
 40920 0000743D 483E5B3C533E205D00 
 40921 00007446 063034303406            menu_8:		db 6,'0404',6
 40922 0000744C 3C483E202020202020-     		db '<H>                Create DOS Partition or Logical DOS Drive',0
 40922 00007455 202020202020202020-
 40922 0000745E 204372656174652044-
 40922 00007467 4F5320506172746974-
 40922 00007470 696F6E206F72204C6F-
 40922 00007479 676963616C20444F53-
 40922 00007482 20447269766500     
 40923 00007489 063130303406            menu_9:		db 6,'1004',6
 40924 0000748F 3C483E312E203C523E-     		db '<H>1. <R>Create Primary DOS Partition '
 40924 00007498 437265617465205072-
 40924 000074A1 696D61727920444F53-
 40924 000074AA 20506172746974696F-
 40924 000074B3 6E20               
 40925 000074B5 063031303406            		db 6,'0104',6
 40926 000074BB 3C483E322E203C523E-     		db '<H>2. <R>Create Extended DOS Partition',0
 40926 000074C4 437265617465204578-
 40926 000074CD 74656E64656420444F-
 40926 000074D6 532050617274697469-
 40926 000074DF 6F6E00             
 40927 000074E2 063132303406            menu_10:	db 6,'1204',6
 40928 000074E8 3C483E332E203C523E-     		db '<H>3. <R>Create Logical DOS Drive(s) in the Extended DOS Partition',0
 40928 000074F1 437265617465204C6F-
 40928 000074FA 676963616C20444F53-
 40928 00007503 204472697665287329-
 40928 0000750C 20696E207468652045-
 40928 00007515 7874656E6465642044-
 40928 0000751E 4F5320506172746974-
 40928 00007527 696F6E00           
 40929 0000752B 063234303406            menu_11:	db 6,'2404',6
 40930 00007531 3C523E507265737320-     		db '<R>Press <H>Esc<R> to return to FDISK Options',0
 40930 0000753A 3C483E4573633C523E-
 40930 00007543 20746F207265747572-
 40930 0000754C 6E20746F2046444953-
 40930 00007555 4B204F7074696F6E73-
 40930 0000755E 00                 
 40931 0000755F 063034303406            menu_12:	db 6,'0404',6
 40932 00007565 3C483E202020202020-     		db '<H>                      Create Primary DOS Partition',0
 40932 0000756E 202020202020202020-
 40932 00007577 202020202020204372-
 40932 00007580 65617465205072696D-
 40932 00007589 61727920444F532050-
 40932 00007592 6172746974696F6E00 
 40933 0000759B 063038303406            menu_13:	db 6,'0804',6
 40934 000075A1 3C523E446F20796F75-     		db '<R>Do you wish to use the maximum available size for a Primary DOS Partition '
 40934 000075AA 207769736820746F20-
 40934 000075B3 75736520746865206D-
 40934 000075BC 6178696D756D206176-
 40934 000075C5 61696C61626C652073-
 40934 000075CE 697A6520666F722061-
 40934 000075D7 205072696D61727920-
 40934 000075E0 444F53205061727469-
 40934 000075E9 74696F6E20         
 40935 000075EE 063031303406            		db 6,'0104',6
 40936 000075F4 3C523E616E64206D61-     		db '<R>and make the partition active (<Y>/<N>).....................? <H>[<S> ]',0
 40936 000075FD 6B6520746865207061-
 40936 00007606 72746974696F6E2061-
 40936 0000760F 637469766520283C59-
 40936 00007618 3E2F3C4E3E292E2E2E-
 40936 00007621 2E2E2E2E2E2E2E2E2E-
 40936 0000762A 2E2E2E2E2E2E2E2E2E-
 40936 00007633 3F203C483E5B3C533E-
 40936 0000763C 205D00             
 40937 0000763F 063038303406            menu_45:	db 6,'0804',6
 40938 00007645 3C523E446F20796F75-     		db '<R>Do you wish to use the maximum available size for a Primary DOS Partition '
 40938 0000764E 207769736820746F20-
 40938 00007657 75736520746865206D-
 40938 00007660 6178696D756D206176-
 40938 00007669 61696C61626C652073-
 40938 00007672 697A6520666F722061-
 40938 0000767B 205072696D61727920-
 40938 00007684 444F53205061727469-
 40938 0000768D 74696F6E20         
 40939 00007692 063031303406            		db 6,'0104',6
 40940 00007698 3C523E283C593E2F3C-     		db '<R>(<Y>/<N>)...................................................? '
 40940 000076A1 4E3E292E2E2E2E2E2E-
 40940 000076AA 2E2E2E2E2E2E2E2E2E-
 40940 000076B3 2E2E2E2E2E2E2E2E2E-
 40940 000076BC 2E2E2E2E2E2E2E2E2E-
 40940 000076C5 2E2E2E2E2E2E2E2E2E-
 40940 000076CE 2E2E2E2E2E2E2E2E2E-
 40940 000076D7 3F20               
 40941 000076D9 3C483E5B3C533E205D-     		db '<H>[<S> ]',0
 40941 000076E2 00                 
 40942 000076E3 063038303406            menu_14:	db 6,'0804',6
 40943 000076E9 3C523E506172746974-     		db '<R>Partition  Status   Type    Volume Label  Mbytes   System   Usage '
 40943 000076F2 696F6E202053746174-
 40943 000076FB 757320202054797065-
 40943 00007704 20202020566F6C756D-
 40943 0000770D 65204C6162656C2020-
 40943 00007716 4D6279746573202020-
 40943 0000771F 53797374656D202020-
 40943 00007728 557361676520       
 40944 0000772E 063031303406            		db 6,'0104',6
 40945 00007734 3C523E203C49493E20-     		db '<R> <II> <HI>         <RI>    <IIIIIII>   <IIIIIIIIIII>   <IIII> '
 40945 0000773D 3C48493E2020202020-
 40945 00007746 202020203C52493E20-
 40945 0000774F 2020203C4949494949-
 40945 00007758 49493E2020203C4949-
 40945 00007761 494949494949494949-
 40945 0000776A 3E2020203C49494949-
 40945 00007773 3E20               
 40946 00007775 20203C494949494949-     		db '  <IIIIIIII>   <IIII> '
 40946 0000777E 49493E2020203C4949-
 40946 00007787 49493E20           
 40947 0000778B 063031303406            		db 6,'0104',6
 40948 00007791 3C523E203C49493E20-     		db '<R> <II> <HI>         <RI>    <IIIIIII>   <IIIIIIIIIII>   <IIII> '
 40948 0000779A 3C48493E2020202020-
 40948 000077A3 202020203C52493E20-
 40948 000077AC 2020203C4949494949-
 40948 000077B5 49493E2020203C4949-
 40948 000077BE 494949494949494949-
 40948 000077C7 3E2020203C49494949-
 40948 000077D0 3E20               
 40949 000077D2 20203C494949494949-     		db '  <IIIIIIII>   <IIII> '
 40949 000077DB 49493E2020203C4949-
 40949 000077E4 49493E20           
 40950 000077E8 063031303406            		db 6,'0104',6
 40951 000077EE 3C523E203C49493E20-     		db '<R> <II> <HI>         <RI>    <IIIIIII>   <IIIIIIIIIII>   <IIII> '
 40951 000077F7 3C48493E2020202020-
 40951 00007800 202020203C52493E20-
 40951 00007809 2020203C4949494949-
 40951 00007812 49493E2020203C4949-
 40951 0000781B 494949494949494949-
 40951 00007824 3E2020203C49494949-
 40951 0000782D 3E20               
 40952 0000782F 20203C494949494949-     		db '  <IIIIIIII>   <IIII> '
 40952 00007838 49493E2020203C4949-
 40952 00007841 49493E20           
 40953 00007845 063031303406            		db 6,'0104',6
 40954 0000784B 3C523E203C49493E20-     		db '<R> <II> <HI>         <RI>    <IIIIIII>   <IIIIIIIIIII>   <IIII> '
 40954 00007854 3C48493E2020202020-
 40954 0000785D 202020203C52493E20-
 40954 00007866 2020203C4949494949-
 40954 0000786F 49493E2020203C4949-
 40954 00007878 494949494949494949-
 40954 00007881 3E2020203C49494949-
 40954 0000788A 3E20               
 40955 0000788C 20203C494949494949-     		db '  <IIIIIIII>   <IIII>'
 40955 00007895 49493E2020203C4949-
 40955 0000789E 49493E             
 40956 000078A1 00                      		db 0
 40957 000078A2 063134303406            menu_15:	db 6,'1404',6
 40958 000078A8 3C523E546F74616C20-     		db '<R>Total disk space is <HIIIIR> Mbytes (1 Mbyte = 1048576 bytes)',0
 40958 000078B1 6469736B2073706163-
 40958 000078BA 65206973203C484949-
 40958 000078C3 4949523E204D627974-
 40958 000078CC 6573202831204D6279-
 40958 000078D5 7465203D2031303438-
 40958 000078DE 353736206279746573-
 40958 000078E7 2900               
 40959 000078E9 063135303406            menu_16:	db 6,'1504',6
 40960 000078EF 3C52433E4D6178696D-     		db '<RC>Maximum space available for partition is <HIIIIR> Mbytes (<HIIIIR>)',0
 40960 000078F8 756D20737061636520-
 40960 00007901 617661696C61626C65-
 40960 0000790A 20666F722070617274-
 40960 00007913 6974696F6E20697320-
 40960 0000791C 3C4849494949523E20-
 40960 00007925 4D627974657320283C-
 40960 0000792E 4849494949523E2900 
 40961 00007937 063138303406            menu_39:	db 6,'1804',6
 40962 0000793D 3C52433E456E746572-     		db '<RC>Enter partition size in Mbytes or percent of disk space (%) to '
 40962 00007946 20706172746974696F-
 40962 0000794F 6E2073697A6520696E-
 40962 00007958 204D6279746573206F-
 40962 00007961 722070657263656E74-
 40962 0000796A 206F66206469736B20-
 40962 00007973 737061636520282529-
 40962 0000797C 20746F20           
 40963 00007980 063031303406            		db 6,'0104',6
 40964 00007986 3C52433E6372656174-     		db '<RC>create a Primary DOS Partition...............................'
 40964 0000798F 652061205072696D61-
 40964 00007998 727920444F53205061-
 40964 000079A1 72746974696F6E2E2E-
 40964 000079AA 2E2E2E2E2E2E2E2E2E-
 40964 000079B3 2E2E2E2E2E2E2E2E2E-
 40964 000079BC 2E2E2E2E2E2E2E2E2E-
 40964 000079C5 2E2E               
 40965 000079C7 2E2E3A203C483E5B3C-     		db '..: <H>[<IIISI>]',0
 40965 000079D0 49494953493E5D00   
 40966 000079D8 063034303406            menu_17:	db 6,'0404',6
 40967 000079DE 3C483E202020202020-     		db '<H>                      Create Extended DOS Partition',0
 40967 000079E7 202020202020202020-
 40967 000079F0 202020202020204372-
 40967 000079F9 656174652045787465-
 40967 00007A02 6E64656420444F5320-
 40967 00007A0B 506172746974696F6E-
 40967 00007A14 00                 
 40968 00007A15 063138303406            menu_42:	db 6,'1804',6
 40969 00007A1B 3C52433E456E746572-     		db '<RC>Enter partition size in Mbytes or percent of disk space (%) to '
 40969 00007A24 20706172746974696F-
 40969 00007A2D 6E2073697A6520696E-
 40969 00007A36 204D6279746573206F-
 40969 00007A3F 722070657263656E74-
 40969 00007A48 206F66206469736B20-
 40969 00007A51 737061636520282529-
 40969 00007A5A 20746F20           
 40970 00007A5E 063031303406            		db 6,'0104',6
 40971 00007A64 3C52433E6372656174-     		db '<RC>create an Extended DOS Partition..............................: <H>[<IIISI>]',0
 40971 00007A6D 6520616E2045787465-
 40971 00007A76 6E64656420444F5320-
 40971 00007A7F 506172746974696F6E-
 40971 00007A88 2E2E2E2E2E2E2E2E2E-
 40971 00007A91 2E2E2E2E2E2E2E2E2E-
 40971 00007A9A 2E2E2E2E2E2E2E2E2E-
 40971 00007AA3 2E2E2E3A203C483E5B-
 40971 00007AAC 3C49494953493E5D00 
 40972 00007AB5 063234303406            menu_46:	db 6,'2404',6
 40973 00007ABB 3C523E507265737320-     		db '<R>Press <H>Esc<R> to continue<S>',0
 40973 00007AC4 3C483E4573633C523E-
 40973 00007ACD 20746F20636F6E7469-
 40973 00007AD6 6E75653C533E00     
 40974 00007ADD 063031303406            menu_18:	db 6,'0104',6
 40975 00007AE3 3C48433E2020202020-     		db '<HC>       Create Logical DOS Drive(s) in the Extended DOS Partition',0
 40975 00007AEC 202043726561746520-
 40975 00007AF5 4C6F676963616C2044-
 40975 00007AFE 4F5320447269766528-
 40975 00007B07 732920696E20746865-
 40975 00007B10 20457874656E646564-
 40975 00007B19 20444F532050617274-
 40975 00007B22 6974696F6E00       
 40976 00007B28 063033303006            menu_19:	db 6,'0300',6
 40977 00007B2E 3C523E44727620566F-     		db '<R>Drv Volume Label  Mbytes  System  Usage'
 40977 00007B37 6C756D65204C616265-
 40977 00007B40 6C20204D6279746573-
 40977 00007B49 202053797374656D20-
 40977 00007B52 205573616765       
 40978 00007B58 063031303006            		db 6,'0100',6
 40979 00007B5E 3C483E3C49493E2020-     		db '<H><II>  <RIIIIIIIIIII>    <IIII>  <IIIIIIII>  <IIII>'
 40979 00007B67 3C5249494949494949-
 40979 00007B70 494949493E20202020-
 40979 00007B79 3C494949493E20203C-
 40979 00007B82 49494949494949493E-
 40979 00007B8B 20203C494949493E   
 40980 00007B93 063031303006            		db 6,'0100',6
 40981 00007B99 3C483E3C49493E2020-     		db '<H><II>  <RIIIIIIIIIII>    <IIII>  <IIIIIIII>  <IIII>'
 40981 00007BA2 3C5249494949494949-
 40981 00007BAB 494949493E20202020-
 40981 00007BB4 3C494949493E20203C-
 40981 00007BBD 49494949494949493E-
 40981 00007BC6 20203C494949493E   
 40982 00007BCE 063031303006            		db 6,'0100',6
 40983 00007BD4 3C483E3C49493E2020-     		db '<H><II>  <RIIIIIIIIIII>    <IIII>  <IIIIIIII>  <IIII>'
 40983 00007BDD 3C5249494949494949-
 40983 00007BE6 494949493E20202020-
 40983 00007BEF 3C494949493E20203C-
 40983 00007BF8 49494949494949493E-
 40983 00007C01 20203C494949493E   
 40984 00007C09 063031303006            		db 6,'0100',6
 40985 00007C0F 3C483E3C49493E2020-     		db '<H><II>  <RIIIIIIIIIII>    <IIII>  <IIIIIIII>  <IIII>'
 40985 00007C18 3C5249494949494949-
 40985 00007C21 494949493E20202020-
 40985 00007C2A 3C494949493E20203C-
 40985 00007C33 49494949494949493E-
 40985 00007C3C 20203C494949493E   
 40986 00007C44 063031303006            		db 6,'0100',6
 40987 00007C4A 3C483E3C49493E2020-     		db '<H><II>  <RIIIIIIIIIII>    <IIII>  <IIIIIIII>  <IIII>'
 40987 00007C53 3C5249494949494949-
 40987 00007C5C 494949493E20202020-
 40987 00007C65 3C494949493E20203C-
 40987 00007C6E 49494949494949493E-
 40987 00007C77 20203C494949493E   
 40988 00007C7F 063031303006            		db 6,'0100',6
 40989 00007C85 3C483E3C49493E2020-     		db '<H><II>  <RIIIIIIIIIII>    <IIII>  <IIIIIIII>  <IIII>',0
 40989 00007C8E 3C5249494949494949-
 40989 00007C97 494949493E20202020-
 40989 00007CA0 3C494949493E20203C-
 40989 00007CA9 49494949494949493E-
 40989 00007CB2 20203C494949493E00 
 40990 00007CBB 063130303006            menu_43:	db 6,'1000',6
 40991 00007CC1 3C483E3C49493E2020-     		db '<H><II>  <RIIIIIIIIIII>    <IIII>  <IIIIIIII>  <IIII>'
 40991 00007CCA 3C5249494949494949-
 40991 00007CD3 494949493E20202020-
 40991 00007CDC 3C494949493E20203C-
 40991 00007CE5 49494949494949493E-
 40991 00007CEE 20203C494949493E   
 40992 00007CF6 063031303006            		db 6,'0100',6
 40993 00007CFC 3C483E3C49493E2020-     		db '<H><II>  <RIIIIIIIIIII>    <IIII>  <IIIIIIII>  <IIII>'
 40993 00007D05 3C5249494949494949-
 40993 00007D0E 494949493E20202020-
 40993 00007D17 3C494949493E20203C-
 40993 00007D20 49494949494949493E-
 40993 00007D29 20203C494949493E   
 40994 00007D31 063031303006            		db 6,'0100',6
 40995 00007D37 3C483E3C49493E2020-     		db '<H><II>  <RIIIIIIIIIII>    <IIII>  <IIIIIIII>  <IIII>'
 40995 00007D40 3C5249494949494949-
 40995 00007D49 494949493E20202020-
 40995 00007D52 3C494949493E20203C-
 40995 00007D5B 49494949494949493E-
 40995 00007D64 20203C494949493E   
 40996 00007D6C 063031303006            		db 6,'0100',6
 40997 00007D72 3C483E3C49493E2020-     		db '<H><II>  <RIIIIIIIIIII>    <IIII>  <IIIIIIII>  <IIII>'
 40997 00007D7B 3C5249494949494949-
 40997 00007D84 494949493E20202020-
 40997 00007D8D 3C494949493E20203C-
 40997 00007D96 49494949494949493E-
 40997 00007D9F 20203C494949493E   
 40998 00007DA7 063031303006            		db 6,'0100',6
 40999 00007DAD 3C483E3C49493E2020-     		db '<H><II>  <RIIIIIIIIIII>    <IIII>  <IIIIIIII>  <IIII>'
 40999 00007DB6 3C5249494949494949-
 40999 00007DBF 494949493E20202020-
 40999 00007DC8 3C494949493E20203C-
 40999 00007DD1 49494949494949493E-
 40999 00007DDA 20203C494949493E   
 41000 00007DE2 063031303006            		db 6,'0100',6
 41001 00007DE8 3C483E3C49493E2020-     		db '<H><II>  <RIIIIIIIIIII>    <IIII>  <IIIIIIII>  <IIII>',0
 41001 00007DF1 3C5249494949494949-
 41001 00007DFA 494949493E20202020-
 41001 00007E03 3C494949493E20203C-
 41001 00007E0C 49494949494949493E-
 41001 00007E15 20203C494949493E00 
 41002 00007E1E 063033343106            menu_20:	db 6,'0341',6
 41003 00007E24 3C523E44727620566F-     		db '<R>Drv Volume Label  Mbytes  System  Usage'
 41003 00007E2D 6C756D65204C616265-
 41003 00007E36 6C20204D6279746573-
 41003 00007E3F 202053797374656D20-
 41003 00007E48 205573616765       
 41004 00007E4E 063031343106            		db 6,'0141',6
 41005 00007E54 3C483E3C49493E2020-     		db '<H><II>  <RIIIIIIIIIII>    <IIII>  <IIIIIIII>  <IIII>'
 41005 00007E5D 3C5249494949494949-
 41005 00007E66 494949493E20202020-
 41005 00007E6F 3C494949493E20203C-
 41005 00007E78 49494949494949493E-
 41005 00007E81 20203C494949493E   
 41006 00007E89 063031343106            		db 6,'0141',6
 41007 00007E8F 3C483E3C49493E2020-     		db '<H><II>  <RIIIIIIIIIII>    <IIII>  <IIIIIIII>  <IIII>'
 41007 00007E98 3C5249494949494949-
 41007 00007EA1 494949493E20202020-
 41007 00007EAA 3C494949493E20203C-
 41007 00007EB3 49494949494949493E-
 41007 00007EBC 20203C494949493E   
 41008 00007EC4 063031343106            		db 6,'0141',6
 41009 00007ECA 3C483E3C49493E2020-     		db '<H><II>  <RIIIIIIIIIII>    <IIII>  <IIIIIIII>  <IIII>'
 41009 00007ED3 3C5249494949494949-
 41009 00007EDC 494949493E20202020-
 41009 00007EE5 3C494949493E20203C-
 41009 00007EEE 49494949494949493E-
 41009 00007EF7 20203C494949493E   
 41010 00007EFF 063031343106            		db 6,'0141',6
 41011 00007F05 3C483E3C49493E2020-     		db '<H><II>  <RIIIIIIIIIII>    <IIII>  <IIIIIIII>  <IIII>'
 41011 00007F0E 3C5249494949494949-
 41011 00007F17 494949493E20202020-
 41011 00007F20 3C494949493E20203C-
 41011 00007F29 49494949494949493E-
 41011 00007F32 20203C494949493E   
 41012 00007F3A 063031343106            		db 6,'0141',6
 41013 00007F40 3C483E3C49493E2020-     		db '<H><II>  <RIIIIIIIIIII>    <IIII>  <IIIIIIII>  <IIII>'
 41013 00007F49 3C5249494949494949-
 41013 00007F52 494949493E20202020-
 41013 00007F5B 3C494949493E20203C-
 41013 00007F64 49494949494949493E-
 41013 00007F6D 20203C494949493E   
 41014 00007F75 063031343106            		db 6,'0141',6
 41015 00007F7B 3C483E3C49493E2020-     		db '<H><II>  <RIIIIIIIIIII>    <IIII>  <IIIIIIII>  <IIII>',0
 41015 00007F84 3C5249494949494949-
 41015 00007F8D 494949493E20202020-
 41015 00007F96 3C494949493E20203C-
 41015 00007F9F 49494949494949493E-
 41015 00007FA8 20203C494949493E00 
 41016 00007FB1 063130343106            menu_44:	db 6,'1041',6
 41017 00007FB7 3C483E3C49493E2020-     		db '<H><II>  <RIIIIIIIIIII>    <IIII>  <IIIIIIII>  <IIII>'
 41017 00007FC0 3C5249494949494949-
 41017 00007FC9 494949493E20202020-
 41017 00007FD2 3C494949493E20203C-
 41017 00007FDB 49494949494949493E-
 41017 00007FE4 20203C494949493E   
 41018 00007FEC 063031343106            		db 6,'0141',6
 41019 00007FF2 3C483E3C49493E2020-     		db '<H><II>  <RIIIIIIIIIII>    <IIII>  <IIIIIIII>  <IIII>'
 41019 00007FFB 3C5249494949494949-
 41019 00008004 494949493E20202020-
 41019 0000800D 3C494949493E20203C-
 41019 00008016 49494949494949493E-
 41019 0000801F 20203C494949493E   
 41020 00008027 063031343106            		db 6,'0141',6
 41021 0000802D 3C483E3C49493E2020-     		db '<H><II>  <RIIIIIIIIIII>    <IIII>  <IIIIIIII>  <IIII>'
 41021 00008036 3C5249494949494949-
 41021 0000803F 494949493E20202020-
 41021 00008048 3C494949493E20203C-
 41021 00008051 49494949494949493E-
 41021 0000805A 20203C494949493E   
 41022 00008062 063031343106            		db 6,'0141',6
 41023 00008068 3C483E3C49493E2020-     		db '<H><II>  <RIIIIIIIIIII>    <IIII>  <IIIIIIII>  <IIII>'
 41023 00008071 3C5249494949494949-
 41023 0000807A 494949493E20202020-
 41023 00008083 3C494949493E20203C-
 41023 0000808C 49494949494949493E-
 41023 00008095 20203C494949493E   
 41024 0000809D 063031343106            		db 6,'0141',6
 41025 000080A3 3C483E3C49493E2020-     		db '<H><II>  <RIIIIIIIIIII>    <IIII>  <IIIIIIII>  <IIII>',0
 41025 000080AC 3C5249494949494949-
 41025 000080B5 494949493E20202020-
 41025 000080BE 3C494949493E20203C-
 41025 000080C7 49494949494949493E-
 41025 000080D0 20203C494949493E00 
 41026 000080D9 063137303406            menu_21:	db 6,'1704',6
 41027 000080DF 3C52433E546F74616C-     		db '<RC>Total Extended DOS Partition size is <HIIIIR> Mbytes (1 MByte'
 41027 000080E8 20457874656E646564-
 41027 000080F1 20444F532050617274-
 41027 000080FA 6974696F6E2073697A-
 41027 00008103 65206973203C484949-
 41027 0000810C 4949523E204D627974-
 41027 00008115 6573202831204D4279-
 41027 0000811E 7465               
 41028 00008120 203D20313034383537-     		db ' = 1048576 bytes)',0
 41028 00008129 362062797465732900 
 41029 00008132 063138303406            menu_22:	db 6,'1804',6
 41030 00008138 3C52433E4D6178696D-     		db '<RC>Maximum space available for logical drive is <HIIIIR> Mbytes '
 41030 00008141 756D20737061636520-
 41030 0000814A 617661696C61626C65-
 41030 00008153 20666F72206C6F6769-
 41030 0000815C 63616C206472697665-
 41030 00008165 206973203C48494949-
 41030 0000816E 49523E204D62797465-
 41030 00008177 7320               
 41031 00008179 3C483E283C49494949-     		db '<H>(<IIII>)',0
 41031 00008182 3E2900             
 41032 00008185 063230303406            menu_40:	db 6,'2004',6
 41033 0000818B 3C52433E456E746572-     		db '<RC>Enter logical drive size in Mbytes or percent of disk space (%)'
 41033 00008194 206C6F676963616C20-
 41033 0000819D 64726976652073697A-
 41033 000081A6 6520696E204D627974-
 41033 000081AF 6573206F7220706572-
 41033 000081B8 63656E74206F662064-
 41033 000081C1 69736B207370616365-
 41033 000081CA 20282529           
 41034 000081CE 2E2E2E3C483E5B3C49-     		db '...<H>[<IIISI>]',0
 41034 000081D7 494953493E5D00     
 41035 000081DE 063034303406            menu_23:	db 6,'0404',6
 41036 000081E4 3C483E202020202020-     		db '<H>                          Set Active Partition',0
 41036 000081ED 202020202020202020-
 41036 000081F6 202020202020202020-
 41036 000081FF 202053657420416374-
 41036 00008208 697665205061727469-
 41036 00008211 74696F6E00         
 41037 00008216 063136303406            menu_24:	db 6,'1604',6
 41038 0000821C 3C523E456E74657220-     		db '<R>Enter the number of the partition you want to make active.....'
 41038 00008225 746865206E756D6265-
 41038 0000822E 72206F662074686520-
 41038 00008237 706172746974696F6E-
 41038 00008240 20796F752077616E74-
 41038 00008249 20746F206D616B6520-
 41038 00008252 6163746976652E2E2E-
 41038 0000825B 2E2E               
 41039 0000825D 2E2E2E2E2E2E3A203C-     		db '......: <H>[<S> ]',0
 41039 00008266 483E5B3C533E205D00 
 41040 0000826F 063034303406            menu_25:	db 6,'0404',6
 41041 00008275 3C483E202020202020-     		db '<H>                Delete DOS Partition or Logical DOS Drive',0
 41041 0000827E 202020202020202020-
 41041 00008287 2044656C6574652044-
 41041 00008290 4F5320506172746974-
 41041 00008299 696F6E206F72204C6F-
 41041 000082A2 676963616C20444F53-
 41041 000082AB 20447269766500     
 41042 000082B2 063130303406            menu_26:	db 6,'1004',6
 41043 000082B8 3C48433E312E20203C-     		db '<HC>1.  <R>Delete Primary DOS Partition '
 41043 000082C1 523E44656C65746520-
 41043 000082CA 5072696D6172792044-
 41043 000082D3 4F5320506172746974-
 41043 000082DC 696F6E20           
 41044 000082E0 063031303406            		db 6,'0104',6
 41045 000082E6 3C48433E322E20203C-     		db '<HC>2.  <R>Delete Extended DOS Partition',0
 41045 000082EF 523E44656C65746520-
 41045 000082F8 457874656E64656420-
 41045 00008301 444F53205061727469-
 41045 0000830A 74696F6E00         
 41046 0000830F 063132303406            menu_27:	db 6,'1204',6
 41047 00008315 3C48433E332E20203C-     		db '<HC>3.  <R>Delete Logical DOS Drive(s) in the Extended DOS Partition',0
 41047 0000831E 523E44656C65746520-
 41047 00008327 4C6F676963616C2044-
 41047 00008330 4F5320447269766528-
 41047 00008339 732920696E20746865-
 41047 00008342 20457874656E646564-
 41047 0000834B 20444F532050617274-
 41047 00008354 6974696F6E00       
 41048 0000835A 063133303406            menu_57:	db 6,'1304',6
 41049 00008360 3C48433E342E20203C-     		db '<HC>4.  <R>Delete Non-DOS Partition',0
 41049 00008369 523E44656C65746520-
 41049 00008372 4E6F6E2D444F532050-
 41049 0000837B 6172746974696F6E00 
 41050 00008384 063034303406            menu_28:	db 6,'0404',6
 41051 0000838A 3C483E202020202020-     		db '<H>                      Delete Primary DOS Partition',0
 41051 00008393 202020202020202020-
 41051 0000839C 202020202020204465-
 41051 000083A5 6C657465205072696D-
 41051 000083AE 61727920444F532050-
 41051 000083B7 6172746974696F6E00 
 41052 000083C0 063139303406            menu_55:	db 6,'1904',6
 41053 000083C6 3C4842433E5741524E-     		db '<HBC>WARNING! <OR>Data in the deleted Primary DOS Partition will be lost. '
 41053 000083CF 494E4721203C4F523E-
 41053 000083D8 4461746120696E2074-
 41053 000083E1 68652064656C657465-
 41053 000083EA 64205072696D617279-
 41053 000083F3 20444F532050617274-
 41053 000083FC 6974696F6E2077696C-
 41053 00008405 6C206265206C6F7374-
 41053 0000840E 2E20               
 41054 00008410 063031303406            		db 6,'0104',6
 41055 00008416 3C523E576861742070-     		db '<R>What primary partition do you want to delete..? <H>[<S> ]<R>',0
 41055 0000841F 72696D617279207061-
 41055 00008428 72746974696F6E2064-
 41055 00008431 6F20796F752077616E-
 41055 0000843A 7420746F2064656C65-
 41055 00008443 74652E2E3F203C483E-
 41055 0000844C 5B3C533E205D3C523E-
 41055 00008455 00                 
 41056 00008456 063232303406            menu_56:	db 6,'2204',6
 41057 0000845C 3C52433E446F20796F-     		db '<RC>Do you wish to continue (<Y>/<N>).................? <H>[<S> ]',0
 41057 00008465 75207769736820746F-
 41057 0000846E 20636F6E74696E7565-
 41057 00008477 20283C593E2F3C4E3E-
 41057 00008480 292E2E2E2E2E2E2E2E-
 41057 00008489 2E2E2E2E2E2E2E2E2E-
 41057 00008492 3F203C483E5B3C533E-
 41057 0000849B 205D00             
 41058 0000849E 063034303406            menu_30:	db 6,'0404',6
 41059 000084A4 3C483E202020202020-     		db '<H>                      Delete Extended DOS Partition',0
 41059 000084AD 202020202020202020-
 41059 000084B6 202020202020204465-
 41059 000084BF 6C6574652045787465-
 41059 000084C8 6E64656420444F5320-
 41059 000084D1 506172746974696F6E-
 41059 000084DA 00                 
 41060 000084DB 063136303406            menu_31:	db 6,'1604',6
 41061 000084E1 3C4842433E5741524E-     		db '<HBC>WARNING! <OR>Data in the deleted Extended DOS Partition will be lost. '
 41061 000084EA 494E4721203C4F523E-
 41061 000084F3 4461746120696E2074-
 41061 000084FC 68652064656C657465-
 41061 00008505 6420457874656E6465-
 41061 0000850E 6420444F5320506172-
 41061 00008517 746974696F6E207769-
 41061 00008520 6C6C206265206C6F73-
 41061 00008529 742E20             
 41062 0000852C 063031303406            		db 6,'0104',6
 41063 00008532 3C52433E446F20796F-     		db '<RC>Do you wish to continue (<Y>/<N>).................? <H>[<S> ]',0
 41063 0000853B 75207769736820746F-
 41063 00008544 20636F6E74696E7565-
 41063 0000854D 20283C593E2F3C4E3E-
 41063 00008556 292E2E2E2E2E2E2E2E-
 41063 0000855F 2E2E2E2E2E2E2E2E2E-
 41063 00008568 3F203C483E5B3C533E-
 41063 00008571 205D00             
 41064 00008574 063031303406            menu_32:	db 6,'0104',6
 41065 0000857A 3C483E202020202020-     		db '<H>        Delete Logical DOS Drive(s) in the Extended DOS Partition',0
 41065 00008583 202044656C65746520-
 41065 0000858C 4C6F676963616C2044-
 41065 00008595 4F5320447269766528-
 41065 0000859E 732920696E20746865-
 41065 000085A7 20457874656E646564-
 41065 000085B0 20444F532050617274-
 41065 000085B9 6974696F6E00       
 41066 000085BF 063139303406            menu_33:	db 6,'1904',6
 41067 000085C5 3C4842433E5741524E-     		db '<HBC>WARNING! <OR>Data in a deleted Logical DOS Drive will be lost. '
 41067 000085CE 494E4721203C4F523E-
 41067 000085D7 4461746120696E2061-
 41067 000085E0 2064656C6574656420-
 41067 000085E9 4C6F676963616C2044-
 41067 000085F2 4F5320447269766520-
 41067 000085FB 77696C6C206265206C-
 41067 00008604 6F73742E20         
 41068 00008609 063031303406            		db 6,'0104',6
 41069 0000860F 3C52433E5768617420-     		db '<RC>What drive do you want to delete...............................? <H>[<S> ]',0
 41069 00008618 647269766520646F20-
 41069 00008621 796F752077616E7420-
 41069 0000862A 746F2064656C657465-
 41069 00008633 2E2E2E2E2E2E2E2E2E-
 41069 0000863C 2E2E2E2E2E2E2E2E2E-
 41069 00008645 2E2E2E2E2E2E2E2E2E-
 41069 0000864E 2E2E2E2E3F203C483E-
 41069 00008657 5B3C533E205D00     
 41070 0000865E 063232303406            menu_34:	db 6,'2204',6
 41071 00008664 3C523E41726520796F-     		db '<R>Are you sure (<Y>/<N>)..............................? <H>[<S> ]',0
 41071 0000866D 75207375726520283C-
 41071 00008676 593E2F3C4E3E292E2E-
 41071 0000867F 2E2E2E2E2E2E2E2E2E-
 41071 00008688 2E2E2E2E2E2E2E2E2E-
 41071 00008691 2E2E2E2E2E2E2E2E2E-
 41071 0000869A 2E3F203C483E5B3C53-
 41071 000086A3 3E205D00           
 41072 000086A7 063231303406            menu_41:	db 6,'2104',6
 41073 000086AD 3C523E456E74657220-     		db '<R>Enter Volume Label..............................? <H>[<S>           ]',0
 41073 000086B6 566F6C756D65204C61-
 41073 000086BF 62656C2E2E2E2E2E2E-
 41073 000086C8 2E2E2E2E2E2E2E2E2E-
 41073 000086D1 2E2E2E2E2E2E2E2E2E-
 41073 000086DA 2E2E2E2E2E2E3F203C-
 41073 000086E3 483E5B3C533E202020-
 41073 000086EC 20202020202020205D-
 41073 000086F5 00                 
 41074 000086F6 063034303406            menu_58:	db 6,'0404',6
 41075 000086FC 3C483E202020202020-     		db '<H>                        Delete Non-DOS Partition',0
 41075 00008705 202020202020202020-
 41075 0000870E 202020202020202020-
 41075 00008717 44656C657465204E6F-
 41075 00008720 6E2D444F5320506172-
 41075 00008729 746974696F6E00     
 41076 00008730 063136303406            menu_59:	db 6,'1604',6
 41077 00008736 3C4842433E5741524E-     		db '<HBC>WARNING! <OR>Data in the deleted Non-DOS Partition will be lost. '
 41077 0000873F 494E4721203C4F523E-
 41077 00008748 4461746120696E2074-
 41077 00008751 68652064656C657465-
 41077 0000875A 64204E6F6E2D444F53-
 41077 00008763 20506172746974696F-
 41077 0000876C 6E2077696C6C206265-
 41077 00008775 206C6F73742E20     
 41078 0000877C 063031303406            		db 6,'0104',6
 41079 00008782 3C52433E5768617420-     		db '<RC>What Non-DOS partition do you want to delete..? <H>[<S> ]<R>',0
 41079 0000878B 4E6F6E2D444F532070-
 41079 00008794 6172746974696F6E20-
 41079 0000879D 646F20796F75207761-
 41079 000087A6 6E7420746F2064656C-
 41079 000087AF 6574652E2E3F203C48-
 41079 000087B8 3E5B3C533E205D3C52-
 41079 000087C1 3E00               
 41080 000087C3 063034303406            menu_35:	db 6,'0404',6
 41081 000087C9 3C483E202020202020-     		db '<H>                      Display Partition Information',0
 41081 000087D2 202020202020202020-
 41081 000087DB 202020202020204469-
 41081 000087E4 73706C617920506172-
 41081 000087ED 746974696F6E20496E-
 41081 000087F6 666F726D6174696F6E-
 41081 000087FF 00                 
 41082 00008800 063137303406            menu_36:	db 6,'1704',6
 41083 00008806 3C52433E5468652045-     		db '<RC>The Extended DOS Partition contains Logical DOS Drives. '
 41083 0000880F 7874656E6465642044-
 41083 00008818 4F5320506172746974-
 41083 00008821 696F6E20636F6E7461-
 41083 0000882A 696E73204C6F676963-
 41083 00008833 616C20444F53204472-
 41083 0000883C 697665732E20       
 41084 00008842 063031303406            		db 6,'0104',6
 41085 00008848 3C52433E446F20796F-     		db '<RC>Do you want to display the logical drive information (<Y>/<N>)'
 41085 00008851 752077616E7420746F-
 41085 0000885A 20646973706C617920-
 41085 00008863 746865206C6F676963-
 41085 0000886C 616C20647269766520-
 41085 00008875 696E666F726D617469-
 41085 0000887E 6F6E20283C593E2F3C-
 41085 00008887 4E3E29             
 41086 0000888A 2E2E2E2E2E2E3F3C48-     		db '......?<H>[<S> ]',0
 41086 00008893 3E5B3C533E205D00   
 41087 0000889B 063031303406            menu_37:	db 6,'0104',6
 41088 000088A1 3C483E202020202020-     		db '<H>                  Display Logical DOS Drive Information',0
 41088 000088AA 202020202020202020-
 41088 000088B3 202020446973706C61-
 41088 000088BC 79204C6F676963616C-
 41088 000088C5 20444F532044726976-
 41088 000088CE 6520496E666F726D61-
 41088 000088D7 74696F6E00         
 41089 000088DC 063030303406            menu_47:	db 6,'0004',6
 41090 000088E2 3C483E202020202020-     		db '<H>                     Change Current Fixed Disk Drive',0
 41090 000088EB 202020202020202020-
 41090 000088F4 202020202020436861-
 41090 000088FD 6E6765204375727265-
 41090 00008906 6E7420466978656420-
 41090 0000890F 4469736B2044726976-
 41090 00008918 6500               
 41091 0000891A 063032303006            menu_48:	db 6,'0200',6
 41092 00008920 3C523E20204469736B-     		db '<R>  Disk   Drv   Mbytes   Free   Usage'
 41092 00008929 202020447276202020-
 41092 00008932 4D6279746573202020-
 41092 0000893B 467265652020205573-
 41092 00008944 616765             
 41093 00008947 063031303406            		db 6,'0104',6
 41094 0000894D 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 41094 00008956 3C5249493E20202020-
 41094 0000895F 3C494949493E202020-
 41094 00008968 203C494949493E2020-
 41094 00008971 20203C494949493E   
 41095 00008979 063031303406            		db 6,'0104',6
 41096 0000897F 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 41096 00008988 3C5249493E20202020-
 41096 00008991 3C494949493E202020-
 41096 0000899A 203C494949493E2020-
 41096 000089A3 20203C494949493E   
 41097 000089AB 063031303406            		db 6,'0104',6
 41098 000089B1 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 41098 000089BA 3C5249493E20202020-
 41098 000089C3 3C494949493E202020-
 41098 000089CC 203C494949493E2020-
 41098 000089D5 20203C494949493E   
 41099 000089DD 063031303406            		db 6,'0104',6
 41100 000089E3 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 41100 000089EC 3C5249493E20202020-
 41100 000089F5 3C494949493E202020-
 41100 000089FE 203C494949493E2020-
 41100 00008A07 20203C494949493E   
 41101 00008A0F 063031303406            		db 6,'0104',6
 41102 00008A15 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 41102 00008A1E 3C5249493E20202020-
 41102 00008A27 3C494949493E202020-
 41102 00008A30 203C494949493E2020-
 41102 00008A39 20203C494949493E   
 41103 00008A41 063031303406            		db 6,'0104',6
 41104 00008A47 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 41104 00008A50 3C5249493E20202020-
 41104 00008A59 3C494949493E202020-
 41104 00008A62 203C494949493E2020-
 41104 00008A6B 20203C494949493E   
 41105 00008A73 063031303406            		db 6,'0104',6
 41106 00008A79 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 41106 00008A82 3C5249493E20202020-
 41106 00008A8B 3C494949493E202020-
 41106 00008A94 203C494949493E2020-
 41106 00008A9D 20203C494949493E   
 41107 00008AA5 063031303406            		db 6,'0104',6
 41108 00008AAB 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>',0
 41108 00008AB4 3C5249493E20202020-
 41108 00008ABD 3C494949493E202020-
 41108 00008AC6 203C494949493E2020-
 41108 00008ACF 20203C494949493E00 
 41109 00008AD8 063131303406            menu_49:	db 6,'1104',6
 41110 00008ADE 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 41110 00008AE7 3C5249493E20202020-
 41110 00008AF0 3C494949493E202020-
 41110 00008AF9 203C494949493E2020-
 41110 00008B02 20203C494949493E   
 41111 00008B0A 063031303406            		db 6,'0104',6
 41112 00008B10 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 41112 00008B19 3C5249493E20202020-
 41112 00008B22 3C494949493E202020-
 41112 00008B2B 203C494949493E2020-
 41112 00008B34 20203C494949493E   
 41113 00008B3C 063031303406            		db 6,'0104',6
 41114 00008B42 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 41114 00008B4B 3C5249493E20202020-
 41114 00008B54 3C494949493E202020-
 41114 00008B5D 203C494949493E2020-
 41114 00008B66 20203C494949493E   
 41115 00008B6E 063031303406            		db 6,'0104',6
 41116 00008B74 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 41116 00008B7D 3C5249493E20202020-
 41116 00008B86 3C494949493E202020-
 41116 00008B8F 203C494949493E2020-
 41116 00008B98 20203C494949493E   
 41117 00008BA0 063031303406            		db 6,'0104',6
 41118 00008BA6 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 41118 00008BAF 3C5249493E20202020-
 41118 00008BB8 3C494949493E202020-
 41118 00008BC1 203C494949493E2020-
 41118 00008BCA 20203C494949493E   
 41119 00008BD2 063031303406            		db 6,'0104',6
 41120 00008BD8 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 41120 00008BE1 3C5249493E20202020-
 41120 00008BEA 3C494949493E202020-
 41120 00008BF3 203C494949493E2020-
 41120 00008BFC 20203C494949493E   
 41121 00008C04 063031303406            		db 6,'0104',6
 41122 00008C0A 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 41122 00008C13 3C5249493E20202020-
 41122 00008C1C 3C494949493E202020-
 41122 00008C25 203C494949493E2020-
 41122 00008C2E 20203C494949493E   
 41123 00008C36 063031303406            		db 6,'0104',6
 41124 00008C3C 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>',0
 41124 00008C45 3C5249493E20202020-
 41124 00008C4E 3C494949493E202020-
 41124 00008C57 203C494949493E2020-
 41124 00008C60 20203C494949493E00 
 41125 00008C69 063032343106            menu_50:	db 6,'0241',6
 41126 00008C6F 3C523E20204469736B-     		db '<R>  Disk   Drv   Mbytes   Free   Usage'
 41126 00008C78 202020447276202020-
 41126 00008C81 4D6279746573202020-
 41126 00008C8A 467265652020205573-
 41126 00008C93 616765             
 41127 00008C96 063031343506            		db 6,'0145',6
 41128 00008C9C 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 41128 00008CA5 3C5249493E20202020-
 41128 00008CAE 3C494949493E202020-
 41128 00008CB7 203C494949493E2020-
 41128 00008CC0 20203C494949493E   
 41129 00008CC8 063031343506            		db 6,'0145',6
 41130 00008CCE 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 41130 00008CD7 3C5249493E20202020-
 41130 00008CE0 3C494949493E202020-
 41130 00008CE9 203C494949493E2020-
 41130 00008CF2 20203C494949493E   
 41131 00008CFA 063031343506            		db 6,'0145',6
 41132 00008D00 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 41132 00008D09 3C5249493E20202020-
 41132 00008D12 3C494949493E202020-
 41132 00008D1B 203C494949493E2020-
 41132 00008D24 20203C494949493E   
 41133 00008D2C 063031343506            		db 6,'0145',6
 41134 00008D32 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 41134 00008D3B 3C5249493E20202020-
 41134 00008D44 3C494949493E202020-
 41134 00008D4D 203C494949493E2020-
 41134 00008D56 20203C494949493E   
 41135 00008D5E 063031343506            		db 6,'0145',6
 41136 00008D64 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 41136 00008D6D 3C5249493E20202020-
 41136 00008D76 3C494949493E202020-
 41136 00008D7F 203C494949493E2020-
 41136 00008D88 20203C494949493E   
 41137 00008D90 063031343506            		db 6,'0145',6
 41138 00008D96 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 41138 00008D9F 3C5249493E20202020-
 41138 00008DA8 3C494949493E202020-
 41138 00008DB1 203C494949493E2020-
 41138 00008DBA 20203C494949493E   
 41139 00008DC2 063031343506            		db 6,'0145',6
 41140 00008DC8 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 41140 00008DD1 3C5249493E20202020-
 41140 00008DDA 3C494949493E202020-
 41140 00008DE3 203C494949493E2020-
 41140 00008DEC 20203C494949493E   
 41141 00008DF4 063031343506            		db 6,'0145',6
 41142 00008DFA 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>',0
 41142 00008E03 3C5249493E20202020-
 41142 00008E0C 3C494949493E202020-
 41142 00008E15 203C494949493E2020-
 41142 00008E1E 20203C494949493E00 
 41143 00008E27 063131343506            menu_51:	db 6,'1145',6
 41144 00008E2D 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 41144 00008E36 3C5249493E20202020-
 41144 00008E3F 3C494949493E202020-
 41144 00008E48 203C494949493E2020-
 41144 00008E51 20203C494949493E   
 41145 00008E59 063031343506            		db 6,'0145',6
 41146 00008E5F 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 41146 00008E68 3C5249493E20202020-
 41146 00008E71 3C494949493E202020-
 41146 00008E7A 203C494949493E2020-
 41146 00008E83 20203C494949493E   
 41147 00008E8B 063031343506            		db 6,'0145',6
 41148 00008E91 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 41148 00008E9A 3C5249493E20202020-
 41148 00008EA3 3C494949493E202020-
 41148 00008EAC 203C494949493E2020-
 41148 00008EB5 20203C494949493E   
 41149 00008EBD 063031343506            		db 6,'0145',6
 41150 00008EC3 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 41150 00008ECC 3C5249493E20202020-
 41150 00008ED5 3C494949493E202020-
 41150 00008EDE 203C494949493E2020-
 41150 00008EE7 20203C494949493E   
 41151 00008EEF 063031343506            		db 6,'0145',6
 41152 00008EF5 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 41152 00008EFE 3C5249493E20202020-
 41152 00008F07 3C494949493E202020-
 41152 00008F10 203C494949493E2020-
 41152 00008F19 20203C494949493E   
 41153 00008F21 063031343506            		db 6,'0145',6
 41154 00008F27 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 41154 00008F30 3C5249493E20202020-
 41154 00008F39 3C494949493E202020-
 41154 00008F42 203C494949493E2020-
 41154 00008F4B 20203C494949493E   
 41155 00008F53 063031343506            		db 6,'0145',6
 41156 00008F59 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>'
 41156 00008F62 3C5249493E20202020-
 41156 00008F6B 3C494949493E202020-
 41156 00008F74 203C494949493E2020-
 41156 00008F7D 20203C494949493E   
 41157 00008F85 063031343506            		db 6,'0145',6
 41158 00008F8B 3C48493E2020202020-     		db '<HI>     <RII>    <IIII>    <IIII>    <IIII>',0
 41158 00008F94 3C5249493E20202020-
 41158 00008F9D 3C494949493E202020-
 41158 00008FA6 203C494949493E2020-
 41158 00008FAF 20203C494949493E00 
 41159 00008FB8 063230303406            menu_52:	db 6,'2004',6
 41160 00008FBE 3C523E2831204D4279-     		db '<R>(1 MByte = 1048576 bytes)',0
 41160 00008FC7 7465203D2031303438-
 41160 00008FD0 353736206279746573-
 41160 00008FD9 2900               
 41161 00008FDB 063231303406            menu_53:	db 6,'2104',6
 41162 00008FE1 3C523E456E74657220-     		db '<R>Enter Fixed Disk Drive Number (1-<I>).......................<H>[<SI>]',0
 41162 00008FEA 466978656420446973-
 41162 00008FF3 6B204472697665204E-
 41162 00008FFC 756D6265722028312D-
 41162 00009005 3C493E292E2E2E2E2E-
 41162 0000900E 2E2E2E2E2E2E2E2E2E-
 41162 00009017 2E2E2E2E2E2E2E2E2E-
 41162 00009020 3C483E5B3C53493E5D-
 41162 00009029 00                 
 41163 0000902A 063031303406            menu_54:	db 6,'0104',6
 41164 00009030 3C483E202020202020-     		db '<H>                         Fixed Disk Drive Status',0
 41164 00009039 202020202020202020-
 41164 00009042 202020202020202020-
 41164 0000904B 204669786564204469-
 41164 00009054 736B20447269766520-
 41164 0000905D 53746174757300     
 41165 00009064 063133303406            menu_38:	db 6,'1304',6
 41166 0000906A 3C483E53797374656D-     		db '<H>System will now restart '
 41166 00009073 2077696C6C206E6F77-
 41166 0000907C 207265737461727420 
 41167 00009085 063032303406            		db 6,'0204',6
 41168 0000908B 3C523E496E73657274-     		db '<R>Insert DOS system diskette in drive A: '
 41168 00009094 20444F532073797374-
 41168 0000909D 656D206469736B6574-
 41168 000090A6 746520696E20647269-
 41168 000090AF 766520413A20       
 41169 000090B5 063031303406            		db 6,'0104',6
 41170 000090BB 3C523E507265737320-     		db '<R>Press any key when ready . . .<S>',0
 41170 000090C4 616E79206B65792077-
 41170 000090CD 68656E207265616479-
 41170 000090D6 202E202E202E3C533E-
 41170 000090DF 00                 
 41171 000090E0 06                      menu_60:	db 6
 41172 000090E1 31333034                		db '1304'
 41173 000090E5 06                      		db 6
 41174 000090E6 3C483E53797374656D-     		db '<H>System will now restart '
 41174 000090EF 2077696C6C206E6F77-
 41174 000090F8 207265737461727420 
 41175 00009101 06                      		db 6
 41176 00009102 30333034                		db '0304'
 41177 00009106 06                      		db 6
 41178 00009107 3C523E507265737320-     		db '<R>Press any key when ready . . .<S>',0
 41178 00009110 616E79206B65792077-
 41178 00009119 68656E207265616479-
 41178 00009122 202E202E202E3C533E-
 41178 0000912B 00                 
 41179                                  
 41180                                  ; STATUS MESSAGES
 41181                                  ; 01/12/2018
 41182 0000912C 063231303406            status_1:	db 6,'2104',6
 41183 00009132 3C43483E5072696D61-     		db '<CH>Primary DOS Partition deleted '
 41183 0000913B 727920444F53205061-
 41183 00009144 72746974696F6E2064-
 41183 0000914D 656C6574656420     
 41184 00009154 063031303006            		db 6,'0100',6
 41185 0000915A 3C43573E00              		db '<CW>',0
 41186 0000915F 063231303406            status_2:	db 6,'2104',6
 41187 00009165 3C43483E457874656E-     		db '<CH>Extended DOS Partition deleted '
 41187 0000916E 64656420444F532050-
 41187 00009177 6172746974696F6E20-
 41187 00009180 64656C6574656420   
 41188 00009188 063031303006            		db 6,'0100',6
 41189 0000918E 3C43573E00              		db '<CW>',0
 41190 00009193 063030303406            status_3:	db 6,'0004',6
 41191 00009199 3C483E447269766520-     		db '<H>Drive deleted',0
 41191 000091A2 64656C6574656400   
 41192 000091AA 063231303406            status_4:	db 6,'2104',6
 41193 000091B0 3C43483E5061727469-     		db '<CH>Partition <I> made active '
 41193 000091B9 74696F6E203C493E20-
 41193 000091C2 6D6164652061637469-
 41193 000091CB 766520             
 41194 000091CE 063031303006            		db 6,'0100',6
 41195 000091D4 3C43573E00              		db '<CW>',0
 41196 000091D9 063231303406            status_5:	db 6,'2104',6
 41197 000091DF 3C43483E5072696D61-     		db '<CH>Primary DOS Partition created '
 41197 000091E8 727920444F53205061-
 41197 000091F1 72746974696F6E2063-
 41197 000091FA 72656174656420     
 41198 00009201 063031303006            		db 6,'0100',6
 41199 00009207 3C43573E00              		db '<CW>',0
 41200 0000920C 063231303406            status_6:	db 6,'2104',6
 41201 00009212 3C43483E457874656E-     		db '<CH>Extended DOS Partition created '
 41201 0000921B 64656420444F532050-
 41201 00009224 6172746974696F6E20-
 41201 0000922D 6372656174656420   
 41202 00009235 063031303006            		db 6,'0100',6
 41203 0000923B 3C43573E00              		db '<CW>',0
 41204 00009240 063232303406            status_7:	db 6,'2204',6
 41205 00009246 3C43483E4C6F676963-     		db '<CH>Logical DOS Drive created, drive letters changed or added<W>',0
 41205 0000924F 616C20444F53204472-
 41205 00009258 697665206372656174-
 41205 00009261 65642C206472697665-
 41205 0000926A 206C65747465727320-
 41205 00009273 6368616E676564206F-
 41205 0000927C 722061646465643C57-
 41205 00009285 3E00               
 41206 00009287 063231303406            status_8:	db 6,'2104',6
 41207 0000928D 3C43483E4E6F207061-     		db '<CH>No partitions defined '
 41207 00009296 72746974696F6E7320-
 41207 0000929F 646566696E656420   
 41208 000092A7 063031303006            		db 6,'0100',6
 41209 000092AD 3C433E00                		db '<C>',0
 41210 000092B1 063130303406            status_9:	db 6,'1004',6
 41211 000092B7 3C43483E4E6F206C6F-     		db '<CH>No logical drives defined '
 41211 000092C0 676963616C20647269-
 41211 000092C9 76657320646566696E-
 41211 000092D2 656420             
 41212 000092D5 063031303006            		db 6,'0100',6
 41213 000092DB 3C433E00                		db '<C>',0
 41214 000092DF 063138303406            status_10:	db 6,'1804',6
 41215 000092E5 3C43483E4472697665-     		db '<CH>Drive letters have been changed or deleted<W>',0
 41215 000092EE 206C65747465727320-
 41215 000092F7 68617665206265656E-
 41215 00009300 206368616E67656420-
 41215 00009309 6F722064656C657465-
 41215 00009312 643C573E00         
 41216 00009317 063030303406            status_11:	db 6,'0004',6
 41217 0000931D 3C483E447269766520-     		db '<H>Drive redirected',0
 41217 00009326 726564697265637465-
 41217 0000932F 6400               
 41218 00009331 063231303406            status_12:	db 6,'2104',6
 41219 00009337 3C43483E5072696D61-     		db '<CH>Primary DOS Partition created, drive letters changed or added '
 41219 00009340 727920444F53205061-
 41219 00009349 72746974696F6E2063-
 41219 00009352 7265617465642C2064-
 41219 0000935B 72697665206C657474-
 41219 00009364 657273206368616E67-
 41219 0000936D 6564206F7220616464-
 41219 00009376 656420             
 41220 00009379 063031303006            		db 6,'0100',6
 41221 0000937F 3C43573E00              		db '<CW>',0
 41222 00009384 063231303406            status_13:	db 6,'2104',6
 41223 0000938A 3C43483E4E6F6E2D44-     		db '<CH>Non-DOS Partition deleted '
 41223 00009393 4F5320506172746974-
 41223 0000939C 696F6E2064656C6574-
 41223 000093A5 656420             
 41224 000093A8 063031303006            		db 6,'0100',6
 41225 000093AE 3C43573E00              		db '<CW>',0
 41226                                  
 41227                                  ; ERROR MESSAGES
 41228                                  ; 17/11/2018
 41229                                  
 41230                                  ;-- FDISK.MSG (MSDOS 6.0, FDISK) --
 41231                                  ;/*                                                                      */
 41232                                  ;/* The following character strings are required to display the          */
 41233                                  ;/* error messages. These have form: error_xx                            */
 41234                                  ;/*                                                                      */
 41235                                  ;/* Note: In order to overlay any previous message on the screen, these  */
 41236                                  ;/*       messages are all 2 lines long. The second line may only be     */
 41237                                  ;/*       a blank line. If 2 lines are needed for translation, use the   */
 41238                                  ;/*       second line for text.  Exceptions are those msgs on line 0.    */
 41239                                  ;/*       and those messages that start on line 23                       */
 41240                                  ;/*                                                                      */
 41241                                  
 41242                                  error_1:	
 41243 000093B3 063030303406            		db 6,'0004',6
 41244 000093B9 3C43483E4E6F206669-     		db '<CH>No fixed disks present. '
 41244 000093C2 786564206469736B73-
 41244 000093CB 2070726573656E742E-
 41244 000093D4 20                 
 41245 000093D5 063031303006            		db 6,'0100',6
 41246 000093DB 3C43573E00              		db '<CW>',0
 41247                                  error_2:	
 41248 000093E0 063232303406            		db 6,'2204',6
 41249 000093E6 3C43483E4572726F72-     		db '<CH>Error reading fixed disk. '
 41249 000093EF 2072656164696E6720-
 41249 000093F8 666978656420646973-
 41249 00009401 6B2E20             
 41250 00009404 063031303006            		db 6,'0100',6
 41251 0000940A 3C43573E00              		db '<CW>',0
 41252                                  error_3:		
 41253 0000940F 063232303406            		db 6,'2204',6
 41254 00009415 3C43483E4572726F72-     		db '<CH>Error writing fixed disk. '
 41254 0000941E 2077726974696E6720-
 41254 00009427 666978656420646973-
 41254 00009430 6B2E20             
 41255 00009433 063031303006            		db 6,'0100',6
 41256 00009439 3C43573E00              		db '<CW>',0
 41257                                  error_4:
 41258 0000943E 063030303406            		db 6,'0004',6
 41259 00009444 3C4348573E496E636F-     		db '<CHW>Incorrect DOS version.',0
 41259 0000944D 727265637420444F53-
 41259 00009456 2076657273696F6E2E-
 41259 0000945F 00                 
 41260                                  error_5:
 41261 00009460 063030303406            		db 6,'0004',6
 41262 00009466 3C4348573E43616E6E-     		db '<CHW>Cannot FDISK with network loaded.',0
 41262 0000946F 6F7420464449534B20-
 41262 00009478 77697468206E657477-
 41262 00009481 6F726B206C6F616465-
 41262 0000948A 642E00             
 41263                                  error_6:
 41264 0000948D 063232303406            		db 6,'2204',6
 41265 00009493 3C43483E4E6F205072-     		db '<CH>No Primary DOS Partition to delete. '
 41265 0000949C 696D61727920444F53-
 41265 000094A5 20506172746974696F-
 41265 000094AE 6E20746F2064656C65-
 41265 000094B7 74652E20           
 41266 000094BB 063031303006            		db 6,'0100',6
 41267 000094C1 3C43573E00              		db '<CW>',0
 41268                                  error_7:
 41269 000094C6 063232303406            		db 6,'2204',6
 41270 000094CC 3C43483E4E6F204578-     		db '<CH>No Extended DOS Partition to delete. '
 41270 000094D5 74656E64656420444F-
 41270 000094DE 532050617274697469-
 41270 000094E7 6F6E20746F2064656C-
 41270 000094F0 6574652E20         
 41271 000094F5 063031303006            		db 6,'0100',6
 41272 000094FB 3C43573E00              		db '<CW>',0
 41273                                  error_8:
 41274 00009500 063232303406            		db 6,'2204',6
 41275 00009506 3C43483E5072696D61-     		db '<CH>Primary DOS Partition already exists. '
 41275 0000950F 727920444F53205061-
 41275 00009518 72746974696F6E2061-
 41275 00009521 6C7265616479206578-
 41275 0000952A 697374732E20       
 41276 00009530 063031303006            		db 6,'0100',6
 41277 00009536 3C43573E00              		db '<CW>',0
 41278                                  error_9:
 41279 0000953B 063232303406            		db 6,'2204',6
 41280 00009541 3C43483E457874656E-     		db '<CH>Extended DOS Partition already exists. '
 41280 0000954A 64656420444F532050-
 41280 00009553 6172746974696F6E20-
 41280 0000955C 616C72656164792065-
 41280 00009565 78697374732E20     
 41281 0000956C 063031303006            		db 6,'0100',6
 41282 00009572 3C43573E00              		db '<CW>',0
 41283                                  error_10:
 41284 00009577 063232303406            		db 6,'2204',6
 41285 0000957D 3C43483E4E6F207370-     		db '<CH>No space to create a DOS partition. '
 41285 00009586 61636520746F206372-
 41285 0000958F 65617465206120444F-
 41285 00009598 532070617274697469-
 41285 000095A1 6F6E2E20           
 41286 000095A5 063031303006            		db 6,'0100',6
 41287 000095AB 3C43573E00              		db '<CW>',0
 41288                                  
 41289 000095B0 063232303406            error_12:	db 6,'2204',6
 41290 000095B6 3C43483E5265717565-     		db '<CH>Requested logical drive size exceeds the maximum available sp'
 41290 000095BF 73746564206C6F6769-
 41290 000095C8 63616C206472697665-
 41290 000095D1 2073697A6520657863-
 41290 000095DA 656564732074686520-
 41290 000095E3 6D6178696D756D2061-
 41290 000095EC 7661696C61626C6520-
 41290 000095F5 7370               
 41291 000095F7 6163652E3C573E20        		db 'ace.<W> '
 41292 000095FF 063031303006            		db 6,'0100',6
 41293 00009605 3C43573E00              		db '<CW>',0
 41294 0000960A 063232303406            error_13:	db 6,'2204',6
 41295 00009610 3C43483E5265717565-     		db '<CH>Requested partition size exceeds the maximum available space.'
 41295 00009619 737465642070617274-
 41295 00009622 6974696F6E2073697A-
 41295 0000962B 652065786365656473-
 41295 00009634 20746865206D617869-
 41295 0000963D 6D756D20617661696C-
 41295 00009646 61626C652073706163-
 41295 0000964F 652E               
 41296 00009651 3C573E20                		db '<W> '
 41297 00009655 063031303006            		db 6,'0100',6
 41298 0000965B 3C43573E00              		db '<CW>',0
 41299 00009660 063232303406            error_14:	db 6,'2204',6
 41300 00009666 3C43483E4E6F207061-     		db '<CH>No partitions to delete. '
 41300 0000966F 72746974696F6E7320-
 41300 00009678 746F2064656C657465-
 41300 00009681 2E20               
 41301 00009683 063031303006            		db 6,'0100',6
 41302 00009689 3C43573E00              		db '<CW>',0
 41303 0000968E 063232303406            error_15:	db 6,'2204',6
 41304 00009694 3C43483E546865206F-     		db '<CH>The only startable partition on Drive 1 is already set active'
 41304 0000969D 6E6C79207374617274-
 41304 000096A6 61626C652070617274-
 41304 000096AF 6974696F6E206F6E20-
 41304 000096B8 447269766520312069-
 41304 000096C1 7320616C7265616479-
 41304 000096CA 207365742061637469-
 41304 000096D3 7665               
 41305 000096D5 2E3C573E20              		db '.<W> '
 41306 000096DA 063031303006            		db 6,'0100',6
 41307 000096E0 3C43573E00              		db '<CW>',0
 41308 000096E5 063232303406            error_16:	db 6,'2204',6
 41309 000096EB 3C43483E4E6F207061-     		db '<CH>No partitions to make active. '
 41309 000096F4 72746974696F6E7320-
 41309 000096FD 746F206D616B652061-
 41309 00009706 63746976652E20     
 41310 0000970D 063031303006            		db 6,'0100',6
 41311 00009713 3C43573E00              		db '<CW>',0
 41312 00009718 063232303406            error_17:	db 6,'2204',6
 41313 0000971E 3C43483E5061727469-     		db '<CH>Partition selected (<I>) is not startable, active partition not '
 41313 00009727 74696F6E2073656C65-
 41313 00009730 6374656420283C493E-
 41313 00009739 29206973206E6F7420-
 41313 00009742 737461727461626C65-
 41313 0000974B 2C2061637469766520-
 41313 00009754 706172746974696F6E-
 41313 0000975D 206E6F7420         
 41314 00009762 6368616E6765642E3C-     		db 'changed.<W>',0
 41314 0000976B 573E00             
 41315 0000976E 063232303406            error_19:	db 6,'2204',6
 41316 00009774 3C43483E43616E6E6F-     		db '<CH>Cannot create Extended DOS Partition without '
 41316 0000977D 742063726561746520-
 41316 00009786 457874656E64656420-
 41316 0000978F 444F53205061727469-
 41316 00009798 74696F6E2077697468-
 41316 000097A1 6F757420           
 41317 000097A5 063031303406            		db 6,'0104',6
 41318 000097AB 3C43483E5072696D61-     		db '<CH>Primary DOS Partition on disk 1.<W>',0
 41318 000097B4 727920444F53205061-
 41318 000097BD 72746974696F6E206F-
 41318 000097C6 6E206469736B20312E-
 41318 000097CF 3C573E00           
 41319 000097D3 063232303406            error_20:	db 6,'2204',6
 41320 000097D9 3C43483E416C6C2061-     		db '<CH>All available space in the Extended DOS Partition '
 41320 000097E2 7661696C61626C6520-
 41320 000097EB 737061636520696E20-
 41320 000097F4 74686520457874656E-
 41320 000097FD 64656420444F532050-
 41320 00009806 6172746974696F6E20 
 41321 0000980F 063031303406            		db 6,'0104',6
 41322 00009815 3C43483E6973206173-     		db '<CH>is assigned to logical drives.<W>',0
 41322 0000981E 7369676E656420746F-
 41322 00009827 206C6F676963616C20-
 41322 00009830 6472697665732E3C57-
 41322 00009839 3E00               
 41323 0000983B 063232303406            error_21:	db 6,'2204',6
 41324 00009841 3C43483E43616E6E6F-     		db '<CH>Cannot delete Extended DOS Partition while logical drives exist.<W>',0
 41324 0000984A 742064656C65746520-
 41324 00009853 457874656E64656420-
 41324 0000985C 444F53205061727469-
 41324 00009865 74696F6E207768696C-
 41324 0000986E 65206C6F676963616C-
 41324 00009877 206472697665732065-
 41324 00009880 786973742E3C573E00 
 41325 00009889 063232303406            error_22:	db 6,'2204',6
 41326 0000988F 3C43483E416C6C206C-     		db '<CH>All logical drives deleted in the Extended DOS Partition.<W>',0
 41326 00009898 6F676963616C206472-
 41326 000098A1 697665732064656C65-
 41326 000098AA 74656420696E207468-
 41326 000098B3 6520457874656E6465-
 41326 000098BC 6420444F5320506172-
 41326 000098C5 746974696F6E2E3C57-
 41326 000098CE 3E00               
 41327 000098D0 063232303406            error_23:	db 6,'2204',6
 41328 000098D6 3C433E20                		db '<C> '
 41329 000098DA 063031303406            		db 6,'0104',6
 41330 000098E0 3C4348493E20697320-     		db '<CHI> is not a choice. Please enter <III>.<W>',0
 41330 000098E9 6E6F7420612063686F-
 41330 000098F2 6963652E20506C6561-
 41330 000098FB 736520656E74657220-
 41330 00009904 3C4949493E2E3C573E-
 41330 0000990D 00                 
 41331 0000990E 063232303406            error_24:	db 6,'2204',6
 41332 00009914 3C43483E5741524E49-     		db '<CH>WARNING! The partition set active is not startable.<W>',0
 41332 0000991D 4E4721205468652070-
 41332 00009926 6172746974696F6E20-
 41332 0000992F 736574206163746976-
 41332 00009938 65206973206E6F7420-
 41332 00009941 737461727461626C65-
 41332 0000994A 2E3C573E00         
 41333 0000994F 063232303406            error_25:	db 6,'2204',6
 41334 00009955 3C43483E204F6E6C79-     		db '<CH> Only non-startable partitions exist. '
 41334 0000995E 206E6F6E2D73746172-
 41334 00009967 7461626C6520706172-
 41334 00009970 746974696F6E732065-
 41334 00009979 786973742E20       
 41335 0000997F 063031303006            		db 6,'0100',6
 41336 00009985 3C43573E00              		db '<CW>',0
 41337 0000998A 063232303406            error_26:	db 6,'2204',6
 41338 00009990 3C43483E4F6E6C7920-     		db '<CH>Only partitions on Drive 1 can be made active.<W>',0
 41338 00009999 706172746974696F6E-
 41338 000099A2 73206F6E2044726976-
 41338 000099AB 6520312063616E2062-
 41338 000099B4 65206D616465206163-
 41338 000099BD 746976652E3C573E00 
 41339 000099C6 063232303406            error_27:	db 6,'2204',6
 41340 000099CC 3C43483E4D6178696D-     		db '<CH>Maximum number of Logical DOS Drives installed.<W>',0
 41340 000099D5 756D206E756D626572-
 41340 000099DE 206F66204C6F676963-
 41340 000099E7 616C20444F53204472-
 41340 000099F0 6976657320696E7374-
 41340 000099F9 616C6C65642E3C573E-
 41340 00009A02 00                 
 41341 00009A03 063232303406            error_28:	db 6,'2204',6
 41342 00009A09 3C43483E43616E6E6F-     		db '<CH>Cannot create a zero size partition. '
 41342 00009A12 742063726561746520-
 41342 00009A1B 61207A65726F207369-
 41342 00009A24 7A6520706172746974-
 41342 00009A2D 696F6E2E20         
 41343 00009A32 063031303006            		db 6,'0100',6
 41344 00009A38 3C43573E00              		db '<CW>',0
 41345 00009A3D 063232303406            error_29:	db 6,'2204',6
 41346 00009A43 3C43483E4472697665-     		db '<CH>Drive <II> already deleted. '
 41346 00009A4C 203C49493E20616C72-
 41346 00009A55 656164792064656C65-
 41346 00009A5E 7465642E20         
 41347 00009A63 063031303006            		db 6,'0100',6
 41348 00009A69 3C43573E00              		db '<CW>',0
 41349 00009A6E 063232303406            error_30:	db 6,'2204',6
 41350 00009A74 3C4348423E556E6162-     		db '<CHB>Unable to access Drive <I>.<OW>',0
 41350 00009A7D 6C6520746F20616363-
 41350 00009A86 657373204472697665-
 41350 00009A8F 203C493E2E3C4F573E-
 41350 00009A98 00                 
 41351 00009A99 063233303406            error_31:	db 6,'2304',6
 41352 00009A9F 3C43483E496E76616C-     		db '<CH>Invalid entry, please enter <III>.<W>',0
 41352 00009AA8 696420656E7472792C-
 41352 00009AB1 20706C656173652065-
 41352 00009ABA 6E746572203C494949-
 41352 00009AC3 3E2E3C573E00       
 41353 00009AC9 063232303406            error_32:	db 6,'2204',6
 41354 00009ACF 3C43483E43616E6E6F-     		db '<CH>Cannot delete Primary DOS Partition on drive 1  '
 41354 00009AD8 742064656C65746520-
 41354 00009AE1 5072696D6172792044-
 41354 00009AEA 4F5320506172746974-
 41354 00009AF3 696F6E206F6E206472-
 41354 00009AFC 69766520312020     
 41355 00009B03 063031303406            		db 6,'0104',6
 41356 00009B09 3C43483E7768656E20-     		db '<CH>when an Extended DOS Partition exists.<W>',0
 41356 00009B12 616E20457874656E64-
 41356 00009B1B 656420444F53205061-
 41356 00009B24 72746974696F6E2065-
 41356 00009B2D 78697374732E3C573E-
 41356 00009B36 00                 
 41357 00009B37 063232303006            error_33:	db 6,'2200',6
 41358 00009B3D 3C433E20                		db '<C> '
 41359 00009B41 063031303406            		db 6,'0104',6
 41360 00009B47 3C43483E496E76616C-     		db '<CH>Invalid entry.<W>',0
 41360 00009B50 696420656E7472792E-
 41360 00009B59 3C573E00           
 41361 00009B5D 063232303406            error_34:	db 6,'2204',6
 41362 00009B63 3C43483E566F6C756D-     		db '<CH>Volume label does not match.<W>',0
 41362 00009B6C 65206C6162656C2064-
 41362 00009B75 6F6573206E6F74206D-
 41362 00009B7E 617463682E3C573E00 
 41363 00009B87 063232303406            error_35:	db 6,'2204',6
 41364 00009B8D 3C43483E43616E6E6F-     		db '<CH>Cannot create Logical DOS Drive without '
 41364 00009B96 742063726561746520-
 41364 00009B9F 4C6F676963616C2044-
 41364 00009BA8 4F5320447269766520-
 41364 00009BB1 776974686F757420   
 41365 00009BB9 063031303406            		db 6,'0104',6
 41366 00009BBF 3C43483E616E204578-     		db '<CH>an Extended DOS Partition on the current drive.<W>',0
 41366 00009BC8 74656E64656420444F-
 41366 00009BD1 532050617274697469-
 41366 00009BDA 6F6E206F6E20746865-
 41366 00009BE3 2063757272656E7420-
 41366 00009BEC 64726976652E3C573E-
 41366 00009BF5 00                 
 41367 00009BF6 063232303406            error_36:	db 6,'2204',6
 41368 00009BFC 3C43483E4E6F204C6F-     		db '<CH>No Logical DOS Drive(s) to delete. '
 41368 00009C05 676963616C20444F53-
 41368 00009C0E 204472697665287329-
 41368 00009C17 20746F2064656C6574-
 41368 00009C20 652E20             
 41369 00009C23 063031303006            		db 6,'0100',6
 41370 00009C29 3C43573E00              		db '<CW>',0
 41371 00009C2E 063232303406            error_37:	db 6,'2204',6
 41372 00009C34 3C43483E5061727469-     		db '<CH>Partition selected is not a Primary DOS Partition '
 41372 00009C3D 74696F6E2073656C65-
 41372 00009C46 63746564206973206E-
 41372 00009C4F 6F742061205072696D-
 41372 00009C58 61727920444F532050-
 41372 00009C61 6172746974696F6E20 
 41373 00009C6A 063031303006            		db 6,'0100',6
 41374 00009C70 3C43573E00              		db '<CW>',0
 41375 00009C75 063232303406            error_38:	db 6,'2204',6
 41376 00009C7B 3C43483E4E6F204E6F-     		db '<CH>No Non-DOS Partition to delete. '
 41376 00009C84 6E2D444F5320506172-
 41376 00009C8D 746974696F6E20746F-
 41376 00009C96 2064656C6574652E20 
 41377 00009C9F 063031303006            		db 6,'0100',6
 41378 00009CA5 3C43573E00              		db '<CW>',0
 41379 00009CAA 063232303406            error_39:	db 6,'2204',6
 41380 00009CB0 3C43483E5061727469-     		db '<CH>Partition selected is not a Non-DOS Partition '
 41380 00009CB9 74696F6E2073656C65-
 41380 00009CC2 63746564206973206E-
 41380 00009CCB 6F742061204E6F6E2D-
 41380 00009CD4 444F53205061727469-
 41380 00009CDD 74696F6E20         
 41381 00009CE2 063031303006            		db 6,'0100',6
 41382 00009CE8 3C43573E00              		db '<CW>',0
 41383                                  
 41384                                  ;-- FDISK.MSG (MSDOS 6.0, FDISK) --
 41385                                  ;/*                                                                      */
 41386                                  ;/* The following message is only included as an aide to debug message   */
 41387                                  ;/* strings during translations. The FDISK message formatter will attempt*/
 41388                                  ;/* to the best of its ability to catch invalid message strings and      */
 41389                                  ;/* print the error. This message should NEVER appear for a user, so it  */
 41390                                  ;/* is not neccessary to translate this message                          */
 41391                                  ;/*                                                                      */
 41392                                  
 41393                                  debug_msg:
 41394 00009CED 063232303006            		db 6,'2200',6
 41395 00009CF3 3C4857423E4D657373-     		db '<HWB>Message string error <I>. See header of FDISKC.MSG for error'
 41395 00009CFC 61676520737472696E-
 41395 00009D05 67206572726F72203C-
 41395 00009D0E 493E2E205365652068-
 41395 00009D17 6561646572206F6620-
 41395 00009D20 464449534B432E4D53-
 41395 00009D29 4720666F7220657272-
 41395 00009D32 6F72               
 41396 00009D34 20646566696E697469-     		db ' definition',0
 41396 00009D3D 6F6E00             
 41397                                  
 41398                                  internal_error:
 41399 00009D40 063232303406            		db 6,'2204',6
 41400 00009D46 3C4842573E496E7465-     		db '<HBW>Internal error',0
 41400 00009D4F 726E616C206572726F-
 41400 00009D58 7200               
 41401                                  ; 14/12/2018
 41402                                  stack_error:
 41403 00009D5A 063232303406            		db 6,'2204',6
 41404 00009D60 3C4842573E53746163-     		db '<HBW>Stack overflow',0
 41404 00009D69 6B206F766572666C6F-
 41404 00009D72 7700               
 41405                                  fp_error:
 41406 00009D74 063232303406            		db 6,'2204',6
 41407 00009D7A 3C4842573E466C6F61-     		db '<HBW>Floating-point support not loaded',0
 41407 00009D83 74696E672D706F696E-
 41407 00009D8C 7420737570706F7274-
 41407 00009D95 206E6F74206C6F6164-
 41407 00009D9E 656400             
 41408                                  
 41409                                  ;-- FDISK.MSG (MSDOS 6.0, FDISK) --
 41410                                  ;/*                                                                      */
 41411                                  ;/* The following are not translatable. They are the partition names     */
 41412                                  ;/*                                                                      */
 41413                                  
 41414 00009DA1 2A2052656D6F746520-     txtRemote:	db '* Remote * ',0
 41414 00009DAA 2A2000             
 41415 00009DAD 50524920444F5300        txtPriDos:	db 'PRI DOS',0
 41416 00009DB5 2058454E49582000        txtXenix:	db ' XENIX ',0
 41417 00009DBD 45585420444F5300        txtExtDos:	db 'EXT DOS',0
 41418 00009DC5 205461626C652000        txtTable:	db ' Table ',0
 41419 00009DCD 2050432F49582000        txtPcIx:	db ' PC/IX ',0
 41420                                  ;txtHpFs	db ' HPFS  ',0
 41421 00009DD5 204E544653202000        txtNTFS:	db ' NTFS  ',0 ; 17/11/2018	
 41422 00009DDD 4E4F56454C4C2000        txtNovell:	db 'NOVELL ',0
 41423 00009DE5 2043502F4D202000        txtCpM:		db ' CP/M  ',0
 41424 00009DED 4E6F6E2D444F5300        txtNonDos:	db 'Non-DOS',0
 41425                                  
 41426                                  ; MENU (FORMATTED) TEXT ADDRESS POINTERS
 41427                                  ; 01/12/2018
 41428                                  
 41429 00009DF5 [6171]                  menu_1_offset:	dw menu_1
 41430                                  ;menu_1_segment: dw DGROUP
 41431 00009DF7 [1672]                  menu_2_offset: dw menu_2
 41432                                  ;menu_2_segment: dw DGROUP
 41433 00009DF9 [3073]                  menu_3_offset: dw menu_3
 41434                                  ;menu_3_segment: dw DGROUP
 41435 00009DFB [5673]                  menu_4_offset: dw menu_4
 41436                                  ;menu_4_segment: dw DGROUP
 41437 00009DFD [8573]                  menu_5_offset: dw menu_5
 41438                                  ;menu_5_segment: dw DGROUP
 41439 00009DFF [AF73]                  menu_6_offset: dw menu_6
 41440                                  ;menu_6_segment: dw DGROUP
 41441 00009E01 [2574]                  menu_7_offset: dw menu_7
 41442                                  ;menu_7_segment: dw DGROUP
 41443 00009E03 [4674]                  menu_8_offset: dw menu_8
 41444                                  ;menu_8_segment: dw DGROUP
 41445 00009E05 [8974]                  menu_9_offset: dw menu_9
 41446                                  ;menu_9_segment: dw DGROUP
 41447 00009E07 [E274]                  menu_10_offset: dw menu_10
 41448                                  ;menu_10_segment: dw DGROUP
 41449 00009E09 [2B75]                  menu_11_offset: dw menu_11
 41450                                  ;menu_11_segment: dw DGROUP
 41451 00009E0B [5F75]                  menu_12_offset: dw menu_12
 41452                                  ;menu_12_segment: dw DGROUP
 41453 00009E0D [9B75]                  menu_13_offset: dw menu_13
 41454                                  ;menu_13_segment: dw DGROUP
 41455 00009E0F [3F76]                  menu_45_offset: dw menu_45
 41456                                  ;menu_45_segment: dw DGROUP
 41457 00009E11 [E376]                  menu_14_offset: dw menu_14
 41458                                  ;menu_14_segment: dw DGROUP
 41459 00009E13 [A278]                  menu_15_offset: dw menu_15
 41460                                  ;menu_15_segment: dw DGROUP
 41461 00009E15 [E978]                  menu_16_offset: dw menu_16
 41462                                  ;menu_16_segment: dw DGROUP
 41463 00009E17 [3779]                  menu_39_offset: dw menu_39
 41464                                  ;menu_39_segment: dw DGROUP
 41465 00009E19 [D879]                  menu_17_offset: dw menu_17
 41466                                  ;menu_17_segment: dw DGROUP
 41467 00009E1B [157A]                  menu_42_offset: dw menu_42
 41468                                  ;menu_42_segment: dw DGROUP
 41469 00009E1D [B57A]                  menu_46_offset: dw menu_46
 41470                                  ;menu_46_segment: dw DGROUP
 41471 00009E1F [DD7A]                  menu_18_offset: dw menu_18
 41472                                  ;menu_18_segment: dw DGROUP
 41473 00009E21 [287B]                  menu_19_offset: dw menu_19
 41474                                  ;menu_19_segment: dw DGROUP
 41475 00009E23 [BB7C]                  menu_43_offset: dw menu_43
 41476                                  ;menu_43_segment: dw DGROUP
 41477 00009E25 [1E7E]                  menu_20_offset: dw menu_20
 41478                                  ;menu_20_segment: dw DGROUP
 41479 00009E27 [B17F]                  menu_44_offset: dw menu_44
 41480                                  ;menu_44_segment: dw DGROUP
 41481 00009E29 [D980]                  menu_21_offset: dw menu_21
 41482                                  ;menu_21_segment: dw DGROUP
 41483 00009E2B [3281]                  menu_22_offset: dw menu_22
 41484                                  ;menu_22_segment: dw DGROUP
 41485 00009E2D [8581]                  menu_40_offset: dw menu_40
 41486                                  ;menu_40_segment: dw DGROUP
 41487 00009E2F [DE81]                  menu_23_offset: dw menu_23
 41488                                  ;menu_23_segment: dw DGROUP
 41489 00009E31 [1682]                  menu_24_offset: dw menu_24
 41490                                  ;menu_24_segment: dw DGROUP
 41491 00009E33 [6F82]                  menu_25_offset: dw menu_25
 41492                                  ;menu_25_segment: dw DGROUP
 41493 00009E35 [B282]                  menu_26_offset: dw menu_26
 41494                                  ;menu_26_segment: dw DGROUP
 41495 00009E37 [0F83]                  menu_27_offset: dw menu_27
 41496                                  ;menu_27_segment: dw DGROUP
 41497 00009E39 [5A83]                  menu_57_offset: dw menu_57
 41498                                  ;menu_57_segment: dw DGROUP
 41499 00009E3B [8483]                  menu_28_offset: dw menu_28
 41500                                  ;menu_28_segment: dw DGROUP
 41501 00009E3D [C083]                  menu_55_offset: dw menu_55
 41502                                  ;menu_55_segment: dw DGROUP
 41503 00009E3F [5684]                  menu_56_offset: dw menu_56
 41504                                  ;menu_56_segment: dw DGROUP
 41505 00009E41 [9E84]                  menu_30_offset: dw menu_30
 41506                                  ;menu_30_segment: dw DGROUP
 41507 00009E43 [DB84]                  menu_31_offset: dw menu_31
 41508                                  ;menu_31_segment: dw DGROUP
 41509 00009E45 [7485]                  menu_32_offset: dw menu_32
 41510                                  ;menu_32_segment: dw DGROUP
 41511 00009E47 [BF85]                  menu_33_offset: dw menu_33
 41512                                  ;menu_33_segment: dw DGROUP
 41513 00009E49 [5E86]                  menu_34_offset: dw menu_34
 41514                                  ;menu_34_segment: dw DGROUP
 41515 00009E4B [A786]                  menu_41_offset: dw menu_41
 41516                                  ;menu_41_segment: dw DGROUP
 41517 00009E4D [F686]                  menu_58_offset: dw menu_58
 41518                                  ;menu_58_segment: dw DGROUP
 41519 00009E4F [3087]                  menu_59_offset: dw menu_59
 41520                                  ;menu_59_segment: dw DGROUP
 41521 00009E51 [C387]                  menu_35_offset: dw menu_35
 41522                                  ;menu_35_segment: dw DGROUP
 41523 00009E53 [0088]                  menu_36_offset: dw menu_36
 41524                                  ;menu_36_segment: dw DGROUP
 41525 00009E55 [9B88]                  menu_37_offset: dw menu_37
 41526                                  ;menu_37_segment: dw DGROUP
 41527 00009E57 [DC88]                  menu_47_offset: dw menu_47
 41528                                  ;menu_47_segment: dw DGROUP
 41529 00009E59 [1A89]                  menu_48_offset: dw menu_48
 41530                                  ;menu_48_segment: dw DGROUP
 41531 00009E5B [D88A]                  menu_49_offset: dw menu_49
 41532                                  ;menu_49_segment: dw DGROUP
 41533 00009E5D [698C]                  menu_50_offset: dw menu_50
 41534                                  ;menu_50_segment: dw DGROUP
 41535 00009E5F [278E]                  menu_51_offset: dw menu_51
 41536                                  ;menu_51_segment: dw DGROUP
 41537 00009E61 [B88F]                  menu_52_offset: dw menu_52
 41538                                  ;menu_52_segment: dw DGROUP
 41539 00009E63 [DB8F]                  menu_53_offset: dw menu_53
 41540                                  ;menu_53_segment: dw DGROUP
 41541 00009E65 [2A90]                  menu_54_offset: dw menu_54
 41542                                  ;menu_54_segment: dw DGROUP
 41543 00009E67 [6490]                  menu_38_offset: dw menu_38
 41544                                  ;menu_38_segment: dw DGROUP
 41545 00009E69 [E090]                  menu_60_offset: dw menu_60
 41546                                  ;menu_60_segment: dw DGROUP
 41547                                  
 41548                                  ; STATUS MESSAGE ADDRESS POINTERS
 41549                                  ; 01/12/2018
 41550                                  
 41551 00009E6B [2C91]                  status_1_off:	dw status_1
 41552                                  ;status_1_seg:	dw DGROUP
 41553 00009E6D [5F91]                  status_2_off:	dw status_2
 41554                                  ;status_2_seg:	dw DGROUP
 41555 00009E6F [9391]                  status_3_off:	dw status_3
 41556                                  ;status_3_seg:	dw DGROUP
 41557 00009E71 [AA91]                  status_4_off:	dw status_4
 41558                                  ;status_4_seg:	dw DGROUP
 41559 00009E73 [D991]                  status_5_off:	dw status_5
 41560                                  ;status_5_seg:	dw DGROUP
 41561 00009E75 [0C92]                  status_6_off:	dw status_6
 41562                                  ;status_6_seg:	dw DGROUP
 41563 00009E77 [4092]                  status_7_off:	dw status_7
 41564                                  ;status_7_seg:	dw DGROUP
 41565 00009E79 [8792]                  status_8_off:	dw status_8
 41566                                  ;status_8_seg:	dw DGROUP
 41567 00009E7B [B192]                  status_9_off:	dw status_9
 41568                                  ;status_9_seg:	dw DGROUP
 41569 00009E7D [DF92]                  status_10_off:	dw status_10
 41570                                  ;status_10_seg:	dw DGROUP
 41571                                  ;status_11_off:	dw status_11
 41572                                  ;status_11_seg:	dw DGROUP
 41573 00009E7F [3193]                  status_12_off:	dw status_12
 41574                                  ;status_12_seg:	dw DGROUP
 41575 00009E81 [8493]                  status_13_off:	dw status_13
 41576                                  ;status_13_seg:	dw DGROUP
 41577                                  
 41578                                  ; ERROR MESSAGE ADDRESS POINTERS
 41579                                  ; 17/11/2018
 41580                                  
 41581 00009E83 90                      align 2
 41582                                  
 41583 00009E84 [B393]                  error_1_off:	dw error_1
 41584                                  ;error_1_seg:	dw DGROUP
 41585 00009E86 [E093]                  error_2_off:	dw error_2
 41586                                  ;error_2_seg:	dw DGROUP
 41587 00009E88 [0F94]                  error_3_off:	dw error_3
 41588                                  ;error_3_seg:	dw DGROUP
 41589 00009E8A [3E94]                  error_4_off:	dw error_4
 41590                                  ;error_4_seg:	dw DGROUP
 41591 00009E8C [6094]                  error_5_off:	dw error_5
 41592                                  ;error_5_seg:	dw DGROUP
 41593 00009E8E [8D94]                  error_6_off:	dw error_6
 41594                                  ;error_6_seg:	dw DGROUP
 41595 00009E90 [C694]                  error_7_off:	dw error_7
 41596                                  ;error_7_seg:	dw DGROUP
 41597 00009E92 [0095]                  error_8_off:	dw error_8
 41598                                  ;error_8_seg:	dw DGROUP
 41599 00009E94 [3B95]                  error_9_off:	dw error_9
 41600                                  ;error_9_seg:	dw DGROUP
 41601 00009E96 [7795]                  error_10_off:	dw error_10
 41602                                  ;error_10_seg:	dw DGROUP
 41603 00009E98 [B095]                  error_12_off:	dw error_12
 41604                                  ;error_12_seg:	dw DGROUP
 41605 00009E9A [0A96]                  error_13_off:	dw error_13
 41606                                  ;error_13_seg:	dw DGROUP
 41607 00009E9C [6096]                  error_14_off:	dw error_14
 41608                                  ;error_14_seg:	dw DGROUP
 41609 00009E9E [8E96]                  error_15_off:	dw error_15
 41610                                  ;error_15_seg:	dw DGROUP
 41611 00009EA0 [E596]                  error_16_off:	dw error_16
 41612                                  ;error_16_seg:	dw DGROUP
 41613 00009EA2 [1897]                  error_17_off:	dw error_17
 41614                                  ;error_17_seg:	dw DGROUP
 41615 00009EA4 [6E97]                  error_19_off:	dw error_19
 41616                                  ;error_19_seg:	dw DGROUP
 41617 00009EA6 [D397]                  error_20_off:	dw error_20
 41618                                  ;error_20_seg:	dw DGROUP
 41619 00009EA8 [3B98]                  error_21_off:	dw error_21
 41620                                  ;error_21_seg:	dw DGROUP
 41621 00009EAA [8998]                  error_22_off:	dw error_22
 41622                                  ;error_22_seg:	dw DGROUP
 41623 00009EAC [D098]                  error_23_off:	dw error_23
 41624                                  ;error_23_seg:	dw DGROUP
 41625 00009EAE [0E99]                  error_24_off:	dw error_24
 41626                                  ;error_24_seg:	dw DGROUP
 41627 00009EB0 [4F99]                  error_25_off:	dw error_25
 41628                                  ;error_25_seg:	dw DGROUP
 41629 00009EB2 [8A99]                  error_26_off:	dw error_26
 41630                                  ;error_26_seg:	dw DGROUP
 41631 00009EB4 [C699]                  error_27_off:	dw error_27
 41632                                  ;error_27_seg:	dw DGROUP
 41633 00009EB6 [039A]                  error_28_off:	dw error_28
 41634                                  ;error_28_seg:	dw DGROUP
 41635 00009EB8 [3D9A]                  error_29_off:	dw error_29
 41636                                  ;error_29_seg:	dw DGROUP
 41637 00009EBA [6E9A]                  error_30_off:	dw error_30
 41638                                  ;error_30_seg:	dw DGROUP
 41639 00009EBC [999A]                  error_31_off:	dw error_31
 41640                                  ;error_31_seg:	dw DGROUP
 41641 00009EBE [C99A]                  error_32_off:	dw error_32
 41642                                  ;error_32_seg:	dw DGROUP
 41643 00009EC0 [379B]                  error_33_off:	dw error_33
 41644                                  ;error_33_seg:	dw DGROUP
 41645 00009EC2 [5D9B]                  error_34_off:	dw error_34
 41646                                  ;error_34_seg:	dw DGROUP
 41647 00009EC4 [879B]                  error_35_off:	dw error_35
 41648                                  ;error_35_seg:	dw DGROUP
 41649 00009EC6 [F69B]                  error_36_off:	dw error_36
 41650                                  ;error_36_seg:	dw DGROUP
 41651 00009EC8 [2E9C]                  error_37_off:	dw error_37
 41652                                  ;error_37_seg:	dw DGROUP
 41653 00009ECA [759C]                  error_38_off:	dw error_38
 41654                                  ;error_38_seg:	dw DGROUP
 41655 00009ECC [AA9C]                  error_39_off:	dw error_39
 41656                                  ;error_39_seg:	dw DGROUP
 41657                                  
 41658 00009ECE [ED9C]                  debug_msg_off:	dw debug_msg
 41659                                  ;debug_msg_seg:	dw DGROUP
 41660                                  
 41661                                  ; 18/12/2018
 41662 00009ED0 [409D]                  inter_err_off:	dw internal_error
 41663                                  ;inter_err_seg:	dw DGROUP
 41664                                  
 41665                                  ; 14/12/2018
 41666                                  stackerror_msg_off:
 41667 00009ED2 [5A9D]                  		dw stack_error
 41668                                  ;stackerror_msg_seg:
 41669                                  ;		dw DGROUP		 
 41670                                  
 41671                                  fperror_msg_off:
 41672 00009ED4 [749D]                  		dw fp_error
 41673                                  ;fperror_msg_seg:
 41674                                  ;		de DGROUP
 41675                                  
 41676                                  ; 26/11/2018
 41677 00009ED6 [A19D]                  REMOTE:		dw txtRemote
 41678 00009ED8 [AD9D]                  PRIDOS:		dw txtPriDos
 41679 00009EDA [B59D]                  XENIX:		dw txtXenix
 41680 00009EDC [BD9D]                  EXTDOS:		dw txtExtDos
 41681 00009EDE [C59D]                  TABLE:		dw txtTable
 41682 00009EE0 [CD9D]                  PCIX:		dw txtPcIx
 41683                                  ;HPFS:		dw txtHpFs
 41684 00009EE2 [D59D]                  NTFS:		dw txtNTFS
 41685 00009EE4 [DD9D]                  NOVELL:		dw txtNovell
 41686 00009EE6 [E59D]                  CPM:		dw txtCpM
 41687 00009EE8 [ED9D]                  NONDOS:		dw txtNonDos
 41688                                  
 41689                                  ; 07/12/2018
 41690                                  ;_atopsp:	dw 0
 41691                                  ;_aexit_rtn:	dw _exit_
 41692                                  ;_asizds:	dw 0
 41693                                  
 41694                                  ; 14/12/2018 (no need to  _nheap_desc)
 41695                                  ; 09/12/2018
 41696 00009EEA 0000050000000000        _nheap_desc:	db 0, 0, 5, 0, 0, 0, 0,	0
 41697 00009EF2 0000000000000000        		db 0, 0, 0, 0, 0, 0, 0,	0
 41698 00009EFA 0000000000000000        		db 0, 0, 0, 0, 0, 0, 0,	0
 41699                                  
 41700 00009F02 0000                    errno:		dw 0
 41701                                  
 41702                                  ;umaskval:	dw 0
 41703                                  ;_pspadr:	dw 0
 41704 00009F04 0000                    _psp:		dw 0
 41705                                  
 41706 00009F06 00                      _dosvermajor:	db 0
 41707 00009F07 00                      _dosverminor:	db 0
 41708                                  
 41709                                  ; 14/12/2018 (cleaning)
 41710                                  
 41711                                  ;;_osmode	db 0
 41712                                  
 41713                                  ;_doserrno:	dw 0
 41714                                  ;_nfile		dw 20
 41715                                  ;
 41716                                  ;_osfile:	db 81h,81h,81h
 41717                                  ;		db 01h,01h
 41718                                  ;		times 15 db 0	
 41719                                  
 41720                                  ; 17/11/2018
 41721                                  
 41722                                  ; ctype.h (MSDOS 6.0)
 41723                                  
 41724                                  ;/* set bit masks for the possible character types */
 41725                                  
 41726                                  ;#define _UPPER        0x1       /* upper case letter */
 41727                                  ;#define _LOWER        0x2       /* lower case letter */
 41728                                  ;#define _DIGIT        0x4       /* digit[0-9] */
 41729                                  ;#define _SPACE        0x8       /* tab, carriage return, newline, */
 41730                                  ;                                /* vertical tab or form feed */
 41731                                  ;#define _PUNCT       0x10       /* punctuation character */
 41732                                  ;#define _CONTROL     0x20       /* control character */
 41733                                  ;#define _BLANK       0x40       /* space char */
 41734                                  ;#define _HEX         0x80       /* hexadecimal digit */
 41735                                  
 41736                                  ;/* the character classification macro definitions */
 41737                                  
 41738                                  ;#define isalpha(c)      ( (_ctype+1)[c] & (_UPPER|_LOWER) )
 41739                                  ;#define isupper(c)      ( (_ctype+1)[c] & _UPPER )
 41740                                  ;#define islower(c)      ( (_ctype+1)[c] & _LOWER )
 41741                                  ;#define isdigit(c)      ( (_ctype+1)[c] & _DIGIT )
 41742                                  ;#define isxdigit(c)     ( (_ctype+1)[c] & _HEX )
 41743                                  ;#define isspace(c)      ( (_ctype+1)[c] & _SPACE )
 41744                                  ;#define ispunct(c)      ( (_ctype+1)[c] & _PUNCT )
 41745                                  ;#define isalnum(c)      ( (_ctype+1)[c] & (_UPPER|_LOWER|_DIGIT) )
 41746                                  ;#define isprint(c)      ( (_ctype+1)[c] & (_BLANK|_PUNCT|_UPPER|_LOWER|_DIGIT) )
 41747                                  ;#define isgraph(c)      ( (_ctype+1)[c] & (_PUNCT|_UPPER|_LOWER|_DIGIT) )
 41748                                  ;#define iscntrl(c)      ( (_ctype+1)[c] & _CONTROL )
 41749                                  ;
 41750                                  ;#define toupper(c)      ( (islower(c)) ? _toupper(c) : (c) )
 41751                                  ;#define tolower(c)      ( (isupper(c)) ? _tolower(c) : (c) )
 41752                                  ;
 41753                                  ;#define _tolower(c)     ( (c)-'A'+'a' )
 41754                                  ;#define _toupper(c)     ( (c)-'a'+'A' )
 41755                                  ;
 41756                                  ;#define isascii(c)      ( (unsigned)(c) < 0x80 )
 41757                                  ;#define toascii(c)      ( (c) & 0x7f )
 41758                                  
 41759                                  align 2
 41760 00009F08 00                      	db 0
 41761                                  
 41762                                  ;isdigit(*s) -c-
 41763                                  ;[isdigit+bx] -asm-
 41764                                  
 41765                                  _ctype:		; (PC-DOS 7.0 FDISK.COM - segment 4, offset 543Eh)
 41766 00009F09 00                      	db 0
 41767                                  isdigit: ; Table for numeric character check	; _ctype+1
 41768 00009F0A 202020202020202020-     	db 20h,	20h, 20h, 20h, 20h, 20h, 20h, 20h, 20h, 28h, 28h, 28h, 28h, 28h, 20h, 20h
 41768 00009F13 28282828282020     
 41769 00009F1A 202020202020202020-     	db 20h,	20h, 20h, 20h, 20h, 20h, 20h, 20h, 20h,	20h, 20h, 20h, 20h, 20h, 20h, 20h
 41769 00009F23 20202020202020     
 41770 00009F2A 481010101010101010-     	db 48h,	10h, 10h, 10h, 10h, 10h, 10h, 10h, 10h,	10h, 10h, 10h, 10h, 10h, 10h, 10h
 41770 00009F33 10101010101010     
 41771 00009F3A 848484848484848484-     	db 84h,	84h, 84h, 84h, 84h, 84h, 84h, 84h, 84h,	84h, 10h, 10h, 10h, 10h, 10h, 10h
 41771 00009F43 84101010101010     
 41772 00009F4A 108181818181810101-     	db 10h,	81h, 81h, 81h, 81h, 81h, 81h, 01h, 01h,	01h, 01h, 01h, 01h, 01h, 01h, 01h
 41772 00009F53 01010101010101     
 41773 00009F5A 010101010101010101-     	db 01h,	01h, 01h, 01h, 01h, 01h, 01h, 01h, 01h,	01h, 01h, 10h, 10h, 10h, 10h, 10h
 41773 00009F63 01011010101010     
 41774 00009F6A 108282828282820202-     	db 10h,	82h, 82h, 82h, 82h, 82h, 82h, 02h, 02h,	02h, 02h, 02h, 02h, 02h, 02h, 02h
 41774 00009F73 02020202020202     
 41775 00009F7A 020202020202020202-     	db 02h,	02h, 02h, 02h, 02h, 02h, 02h, 02h, 02h,	02h, 02h, 10h, 10h, 10h, 10h, 20h
 41775 00009F83 02021010101020     
 41776 00009F8A 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 41776 00009F93 00000000000000     
 41777 00009F9A 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 41777 00009FA3 00000000000000     
 41778 00009FAA 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 41778 00009FB3 00000000000000     
 41779 00009FBA 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 41779 00009FC3 00000000000000     
 41780 00009FCA 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 41780 00009FD3 00000000000000     
 41781 00009FDA 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 41781 00009FE3 00000000000000     
 41782 00009FEA 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 41782 00009FF3 00000000000000     
 41783 00009FFA 000000000000000000-     	db 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h,	00h, 00h, 00h, 00h, 00h, 00h, 00h
 41783 0000A003 00000000000000     
 41784                                  
 41785                                  ; 26/11/2018
 41786                                  
 41787                                  ;align 2
 41788                                  ;_cpush:	dw 0FFFFh
 41789                                  ;retadr:	dw 0
 41790                                  
 41791                                  ; 14/12/2018 (no need to err_conv_tbl)
 41792                                  ;err_conv_tbl:
 41793                                  ;		db 00h,	16h, 02h, 02h, 18h, 0Dh, 09h, 0Ch, 0Ch,	0Ch
 41794                                  ;		db 07h,	08h, 16h, 16h, 0FFh, 02h, 0Dh, 12h, 02h, 0FFh
 41795                                  
 41796                                  ; 06/12/2018
 41797                                  	; The following defines the lookup table for changing states
 41798                                  	; This is actually two table combined into one.
 41799                                  	; The lower nybble of each byte gives the character
 41800                                  	; class of any character -- i.e.
 41801                                  	;   charclass = lookuptable[char-' '] & 0xF;
 41802                                  	; The upper nybble of each byte gives the next state to enter -- i.e.
 41803                                  	;   newstate = looptable[charclass][oldstate] >> 4;
 41804                                  
 41805                                  	; The table below is generated by maketab.c -- use this program
 41806                                  	; to make changes.
 41807                                  
 41808 0000A00A 0600000600010000        lookuptable:	db 06h, 00h, 00h, 06h, 00h, 01h, 00h, 00h
 41809 0000A012 1000030600060210        		db 10h, 00h, 03h, 06h, 00h, 06h, 02h, 10h
 41810 0000A01A 0445454505050505        		db 04h, 45h, 45h, 45h, 05h, 05h, 05h, 05h
 41811 0000A022 0535300050000000        		db 05h, 35h, 30h, 00h, 50h, 00h, 00h, 00h
 41812 0000A02A 0020203050580708        		db 00h, 20h, 20h, 30h, 50h, 58h, 07h, 08h
 41813 0000A032 0030303057500700        		db 00h, 30h, 30h, 30h, 57h, 50h, 07h, 00h
 41814 0000A03A 0020200000000000        		db 00h, 20h, 20h, 00h, 00h, 00h, 00h, 00h
 41815 0000A042 0860606060606000        		db 08h, 60h, 60h, 60h, 60h, 60h, 60h, 00h
 41816 0000A04A 0070707878787808        		db 00h, 70h, 70h, 78h, 78h, 78h, 78h, 08h
 41817 0000A052 0708000007000808        		db 07h, 08h, 00h, 00h, 07h, 00h, 08h, 08h
 41818 0000A05A 0800000800080000        		db 08h, 00h, 00h, 08h, 00h, 08h, 00h, 00h
 41819 0000A062 08                      		db 08h
 41820                                  
 41821 0000A063 286E756C6C29            nullstring:	db '(null)'
 41822 0000A069 0600                    nullstrlen:	dw 6	; string to print when null string passed
 41823                                  
 41824 0000A06B 90                      		align 2
 41825 0000A06C FFFF                    		dw 0FFFFh
 41826                                  end_of_bss:	
 41827                                  		;dw 8B10h   ; File Size + BSS
 41828 0000A06E [24D0]                  		dw end_of_file ; 10/12/2018
 41829                                  
 41830                                  ; 14/12/2018 (cleaning)
 41831                                  
 41832                                  ; 07/12/2018
 41833                                  ;_iob:
 41834                                  ;STDIN:		dw _bufin
 41835                                  ;STDIN_cnt:	dw 0
 41836                                  ;STDIN_base:	dw _bufin
 41837                                  ;STDIN_flag:	db 1
 41838                                  ;STDIN_file:	db 0
 41839                                  ;
 41840                                  ;STDOUT:	dw 0
 41841                                  ;STDOUT_cnt:	dw 0
 41842                                  ;STDOUT_base:	dw 0
 41843                                  ;STDOUT_flag:	db 2
 41844                                  ;STDOUT_file:	db 1
 41845                                  ;
 41846                                  ;STDERR:	dw 0
 41847                                  ;STDERR_cnt:	dw 0
 41848                                  ;STDERR_base:	dw 0
 41849                                  ;STDERR_flag:	db 2
 41850                                  ;STDERR_file:	db 2
 41851                                  ;
 41852                                  ;STDAUX:	dw 0
 41853                                  ;STDAUX_cnt:	dw 0
 41854                                  ;STDAUX_base:	dw 0
 41855                                  ;STDAUX_flag:	db 84h
 41856                                  ;STDAUX_file:	db 3
 41857                                  ;
 41858                                  ;STDPRN:	dw 0
 41859                                  ;STDPRN_cnt:	dw 0
 41860                                  ;STDPRN_base:	dw 0
 41861                                  ;STDPRN_flag:	db 2
 41862                                  ;STDPRN_file:	db 4
 41863                                  ;
 41864                                  ;	times 120 db 0
 41865                                  ;
 41866                                  ;_iob2:
 41867                                  ;_iob2_flag2:	db 1
 41868                                  ;_iob2_charbuf:	db 0
 41869                                  ;_iob2_bufsiz:	dw 512
 41870                                  ;_iob2_tmpnum:	dw 0
 41871                                  ;_iob2_padding:	dw 0
 41872                                  ;		
 41873                                  ;	times 152 db 0
 41874                                  
 41875                                  ; CMISTDAT.ASM ; miscellaneous C run-time data
 41876                                  ; MSDOS Visual C++ 1.0
 41877                                  
 41878                                  ;_cfltcvt_tab:
 41879 0000A070 [662A]                  _cfltcvt:	dw _fptrap
 41880 0000A072 [662A]                  _cropzeros	dw _fptrap
 41881                                  ;		dw _fptrap
 41882 0000A074 [662A]                  _forcdecpt	dw _fptrap
 41883                                  ;		dw _fptrap
 41884 0000A076 [662A]                  _cldcvt:	dw _fptrap
 41885                                  ;	
 41886                                  ;	times 8 db 0
 41887                                  ;_amblksiz:	dw 2000h ; 09/12/2018
 41888                                  ;_aDBswpflg:	dw 0
 41889                                  ;_aDBswpchk:	dw _aDBretaddr
 41890                                  ;_aDBrterr:	dw _aDBretaddr
 41891                                  ;_aDBexit:	dw _aDBretaddr
 41892                                  ;	
 41893                                  ;	times 4 db 0
 41894                                  ; 
 41895                                  ; 13/12/2018
 41896                                  ;strbuf:	; Stream Buffer (for sprintf)
 41897                                  ;_strbuf_ptr:	dw 7E7Eh
 41898                                  ;_strbuf_cnt:	dw 7E7Eh
 41899                                  ;_strbuf_base:	dw 7E7Eh
 41900                                  ;_strbuf_flag:	db 7Eh
 41901                                  ;_strbuf_file:	db 7Eh
 41902                                  ;
 41903                                  ;xontab:	db 7Eh
 41904                                  ;		db 7Eh
 41905                                  
 41906                                  ;=============================================================================
 41907                                  ;        	uninitialized data
 41908                                  ;=============================================================================
 41909                                  
 41910                                  bss_start:
 41911                                  
 41912                                  ABSOLUTE bss_start
 41913                                  
 41914                                  alignb 2
 41915                                  
 41916                                  ; SEGMENT 4 - DGROUP ---------------------------------------------------------
 41917                                  
 41918 0000A078 ??                      reboot_flag:	resb 1
 41919 0000A079 <res 11h>               dx_buff:	resb 17
 41920 0000A08A ????????????????        dx_buff_file_system: resb 8
 41921 0000A092 ??                      video_mode:	resb 1
 41922 0000A093 ??                      		resb 1
 41923                                  p_px:					; PARMSX block structure
 41924 0000A094 ??                      p_px_p_minp:	 resb 1			; Minimum positional number
 41925 0000A095 ??                      p_px_p_maxp:	 resb 1			; Maximum positional number
 41926 0000A096 ????                    p_px_p_con1_ptr: resw 1			; Address of the 1st CONTROL block
 41927 0000A098 ??                      p_px_p_maxs:	 resb 1			; # OF SWITCHES
 41928 0000A099 ????                    p_px_p_swi1_ptr: resw 1			; DESCRIPTION OF SWITCH 1
 41929 0000A09B ????                    p_px_p_swi2_ptr: resw 1			; REPEATS maxs-1 TIMES
 41930 0000A09D ????                    p_px_p_swi3_ptr: resw 1
 41931 0000A09F ????                    p_px_p_swi4_ptr: resw 1
 41932 0000A0A1 ????                    p_px_p_swi5_ptr: resw 1
 41933 0000A0A3 ??                      p_px_p_maxk:	 resb 1			; # OF KEYWORDS
 41934                                  
 41935 0000A0A4 ??                      disk_flag:	 resb 1
 41936                                  p_p:					; PARMS block structure
 41937 0000A0A5 ????                    p_p_p_parmxs_ptr:      resw 1		; Address of PARMSX		
 41938 0000A0A7 ??                      p_p_p_num_extra:       resb 1		; Number of extra stuff
 41939 0000A0A8 ??                      p_p_p_len_extra_delim: resb 1		; Length of extra delimiter
 41940 0000A0A9 ??                      p_p_p_extra_delim:     resb 1		; Extra delimiter
 41941                                  
 41942 0000A0AA ????                    input_col:	resw 1
 41943 0000A0AC ??                      No:		resb 1
 41944 0000A0AD ??                      		resb 1
 41945                                  
 41946 0000A0AE ????????????????        max_sector:	resb 8
 41947 0000A0B6 <res 10h>               max_head:	resw 8
 41948 0000A0C6 <res 10h>               total_disk:	resw 8
 41949 0000A0D6 <res 10h>               total_mbytes:	resw 8
 41950                                  
 41951 0000A0E6 ????????                		resw 2
 41952                                  ;regs:
 41953                                  ;regs_x_ax:	resw 1
 41954                                  ;regs_x_bx:	resw 1
 41955                                  ;regs_x_cx:	resw 1
 41956                                  ;regs_x_dx:	resw 1
 41957                                  ;regs_x_si:	resw 1
 41958                                  ;regs_x_di:	resw 1
 41959                                  ;regs_x_cflag:	resb 1
 41960                                  ;		resb 1
 41961                                  
 41962 0000A0EA ??                      sublistp_size:	    resb 1
 41963 0000A0EB ??                      sublistp_res:	    resb 1
 41964 0000A0EC ????                    sublistp_value:	    resw 1
 41965 0000A0EE ????                    sublistp_value_seg: resw 1
 41966 0000A0F0 ??                      sublistp_id:	    resb 1
 41967 0000A0F1 ??                      sublistp_flags:	    resb 1
 41968 0000A0F2 ??                      sublistp_max_width: resb 1
 41969 0000A0F3 ??                      sublistp_min_width: resb 1
 41970 0000A0F4 ??                      sublistp_pad_char:  resb 1
 41971 0000A0F5 ??                      		resb 1
 41972                                  p_swi1:
 41973 0000A0F6 ????                    p_swi1_sp_match_flag:	 resw 1
 41974 0000A0F8 ????                    p_swi1_sp_function_flag: resw 1
 41975 0000A0FA ????                    p_swi1_sp_buff1_ptr:	 resw 1
 41976 0000A0FC ????                    p_swi1_sp_val1_ptr:	 resw 1
 41977 0000A0FE ??                      p_swi1_sp_nid:		 resb 1
 41978 0000A0FF ??????????              p_swi1_sp_switch1:	 resb 5
 41979 0000A104 ??????????              p_swi1_sp_switch2:	 resb 5
 41980 0000A109 ??????????              p_swi1_sp_switch3:	 resb 5
 41981 0000A10E ??                      primary_flag:	resb 1
 41982 0000A10F ??                      		resb 1
 41983                                  
 41984                                  p_swi2:
 41985 0000A110 ????                    p_swi2_sp_match_flag:	 resw 1
 41986 0000A112 ????                    p_swi2_sp_function_flag: resw 1
 41987 0000A114 ????                    p_swi2_sp_buff1_ptr:	 resw 1
 41988 0000A116 ????                    p_swi2_sp_val1_ptr:	 resw 1
 41989 0000A118 ??                      p_swi2_sp_nid:		 resb 1
 41990 0000A119 ??????                  p_swi2_sp_switch4:	 resb 3
 41991                                  
 41992                                  p_swi3:
 41993 0000A11C ????                    p_swi3_sp_match_flag:	 resw 1
 41994 0000A11E ????                    p_swi3_sp_function_flag: resw 1
 41995 0000A120 ????                    p_swi3_sp_buff1_ptr:	 resw 1
 41996 0000A122 ????                    p_swi3_sp_val1_ptr:	 resw 1
 41997 0000A124 ??                      p_swi3_sp_nid:		 resb 1
 41998 0000A125 ????????????????        p_swi3_sp_switch5:	 resb 8
 41999                                  
 42000 0000A12D ??                      next_letter:	resb 1
 42001 0000A12E ??                      display_page:	resb 1
 42002 0000A12F ??                      		resb 1
 42003                                  p_swi4:
 42004 0000A130 ????                    p_swi4_sp_match_flag:	 resw 1
 42005 0000A132 ????                    p_swi4_sp_function_flag: resw 1
 42006 0000A134 ????                    p_swi4_sp_buff1_ptr:	 resw 1
 42007 0000A136 ????                    p_swi4_sp_val1_ptr:	 resw 1
 42008 0000A138 ??                      p_swi4_sp_nid:		 resb 1
 42009 0000A139 ??????                  p_swi4_sp_switch6:	 resb 3
 42010                                  
 42011 0000A13C ??                      mbr_flag:	resb 1
 42012 0000A13D ??                      		resb 1
 42013                                  
 42014                                  ; 14/12/2018 (no need to _bufin for FDISK2.COM) 
 42015                                  
 42016                                  ;_bufin:	resb 512
 42017                                  
 42018                                  p_swi5:
 42019 0000A13E ????                    p_swi5_sp_match_flag:	 resw 1
 42020 0000A140 ????                    p_swi5_sp_function_flag: resw 1
 42021 0000A142 ????                    p_swi5_sp_buff1_ptr:	 resw 1
 42022 0000A144 ????                    p_swi5_sp_val1_ptr:	 resw 1
 42023 0000A146 ??                      p_swi5_sp_nid:	 	 resb 1
 42024 0000A147 ??????????              p_swi5_sp_switch7:	 resb 5
 42025                                  
 42026 0000A14C ????                    input_row:	resw 1
 42027 0000A14E ??                      quiet_flag:	resb 1
 42028 0000A14F ??                      		resb 1
 42029                                  
 42030 0000A150 ????????????????        good_disk:	resb 8
 42031                                  
 42032                                  ; LOGICAL PARTITION DATA STRUCTURE
 42033                                  ; (for logical paritions in extended paritions)
 42034                                  ; 23/11/2018
 42035                                  ; 8 extended partitions (on 8 hard disks -8 physical drives-)
 42036                                  ; 24 logical drives (46 bytes) per extended partition
 42037                                  ; 8832 bytes (8*24*46)
 42038                                  
 42039 0000A158 ??                      ext_table_boot_ind:	resb 1
 42040 0000A159 ??                      ext_table_start_head:	resb 1
 42041 0000A15A ??                      ext_table_start_sector: resb 1
 42042 0000A15B ????                    ext_table_start_cyl:	resw 1
 42043 0000A15D ??                      ext_table_sys_id:	resb 1
 42044 0000A15E ??                      ext_table_end_head:	resb 1
 42045 0000A15F ??                      ext_table_end_sector:	resb 1
 42046 0000A160 ????                    ext_table_end_cyl:	resw 1
 42047 0000A162 ????                    ext_table_rel_sec_lw:	resw 1
 42048 0000A164 ????                    ext_table_rel_sec_hw:	resw 1
 42049 0000A166 ????                    ext_table_num_sec_lw:	resw 1
 42050 0000A168 ????                    ext_table_num_sec_hw:	resw 1
 42051 0000A16A ??                      			resb 1
 42052 0000A16B ??                      ext_table_changed:	resb 1
 42053 0000A16C ????                    ext_table_mbytes_used:	resw 1
 42054 0000A16E ????                    ext_table_percent_used:	resw 1
 42055 0000A170 <res Ch>                ext_table_vol_label:	resb 12
 42056 0000A17C <res 9h>                ext_table_system:	resb 9
 42057 0000A185 ??                      ext_table_drive_letter:	resb 1
 42058 0000A186 <res 3F4h>              		resb 1012 ; 46*22
 42059 0000A57A ??                      ep0_lp23_boot_ind:	resb 1
 42060 0000A57B ??                      ep0_lp23_start_head:	resb 1
 42061 0000A57C ??                      ep0_lp23_start_sector:	resb 1
 42062 0000A57D ????                    ep0_lp23_start_cyl:	resw 1 ; 06/01/2019
 42063 0000A57F ??                      ep0_lp23_sys_id:	resb 1
 42064 0000A580 ??                      ep0_lp23_end_head:	resb 1
 42065 0000A581 ??                      ep0_lp23_end_sector:	resb 1
 42066 0000A582 ????                    ep0_lp23_end_cyl:	resw 1 ; 06/01/2019
 42067 0000A584 ????                    ep0_lp23_rel_sec_lw:	resw 1
 42068 0000A586 ????                    ep0_lp23_rel_sec_hw:	resw 1
 42069 0000A588 ????                    ep0_lp23_num_sec_lw:	resw 1
 42070 0000A58A ????                    ep0_lp23_num_sec_hw:	resw 1
 42071 0000A58C ??                      			resb 1 ; 06/01/2019
 42072 0000A58D ??                      ep0_lp23_changed: 	resb 1
 42073 0000A58E ????                    ep0_lp23_mbytes_used:	resw 1
 42074 0000A590 ????                    ep0_lp23_percent_used:	resw 1
 42075 0000A592 <res Ch>                ep0_lp23_vol_label:	resb 12
 42076 0000A59E <res 9h>                ep0_lp23_system:	resb 9
 42077 0000A5A7 ??                      ep0_lp23_drive_letter:	resb 1
 42078 0000A5A8 <res 1E30h>             		resb 7728 ; 7*46*24
 42079                                  
 42080 0000C3D8 ??                      mono_flag:	resb 1
 42081 0000C3D9 ??                      Yes:		resb 1
 42082                                  ;segregs:
 42083                                  ;segregs_es:	resw 1
 42084                                  ;segregs_cs:	resw 1
 42085                                  ;segregs_ss:	resw 1
 42086                                  ;segregs_ds:	resw 1
 42087 0000C3DA ????                    extended_buff:	resw 1
 42088                                  
 42089                                  ;total_disk:	resw 8
 42090                                  
 42091 0000C3DC ??                      primary_partition_count: resb 1
 42092 0000C3DD ??                      		resb 1
 42093 0000C3DE ????                    primary_buff:	resw 1
 42094 0000C3E0 ??                      PercentFlag:	resb 1
 42095 0000C3E1 ??                      logical_flag:	resb 1
 42096 0000C3E2 ??                      status_flag:	resb 1
 42097 0000C3E3 ??                      number_of_drives: resb 1
 42098 0000C3E4 ??                      extended_flag:	resb 1
 42099                                  
 42100                                  sp_val:
 42101 0000C3E5 ??                      sp_val_p_values:	resb 1
 42102 0000C3E6 ??                      sp_val_p_range:		resb 1
 42103 0000C3E7 ??                      sp_val_p_range_one: 	resb 1
 42104 0000C3E8 ????????                sp_val_p_low_range: 	resd 1
 42105 0000C3EC ????                    sp_val_p_high_range:   	resw 1
 42106 0000C3EE ??                      sp_val_p_high_range_2: 	resb 1
 42107                                  
 42108 0000C3EF ??                      sort_1:			resb 1
 42109 0000C3F0 <res 18h>               sort:			resb 24
 42110                                  
 42111                                  p_val:
 42112 0000C408 ??                      p_val_p_values		resb 1
 42113 0000C409 ??                      p_val_p_range:		resb 1
 42114 0000C40A ??                      p_val_p_range_one:	resb 1
 42115 0000C40B ????????                p_val_p_low_range:	resd 1
 42116 0000C40F ????????                p_val_p_high_range:	resd 1
 42117 0000C413 ??                      no_fatal_error:	resb 1
 42118                                  p_con:
 42119 0000C414 ????                    p_con_p_match_flag:	resw 1
 42120 0000C416 ????                    p_con_p_function_flag:	resw 1
 42121 0000C418 ????                    p_con_p_buff1_ptr:	resw 1
 42122 0000C41A ????                    p_con_p_val1_ptr:	resw 1
 42123 0000C41C ??                      p_con_nid:		resb 1
 42124 0000C41D ??                      cur_disk_buff:		resb 1
 42125                                  
 42126                                  ; 13/12/2018
 42127 0000C41E ??                      video_attribute: resb 1
 42128 0000C41F ??                      		 resb 1
 42129                                  
 42130                                  ; PARTITION DATA STRUCTURE
 42131                                  ; 32 (4*8) partitions (on 8 hard disks -8 physical drives-)
 42132                                  ; 46 byte partition data structure per partition
 42133                                  ; (4*46 bytes per disk)
 42134                                  
 42135 0000C420 ??                      part_table_boot_ind:	 resb 1
 42136 0000C421 ??                      part_table_start_head:	 resb 1
 42137 0000C422 ??                      part_table_start_sector: resb 1
 42138 0000C423 ????                    part_table_start_cyl:	 resw 1
 42139 0000C425 ??                      part_table_sys_id:	 resb 1
 42140 0000C426 ??                      part_table_end_head:	 resb 1
 42141 0000C427 ??                      part_table_end_sector:	 resb 1
 42142 0000C428 ????                    part_table_end_cyl:	 resw 1
 42143 0000C42A ????                    part_table_rel_sec_lw:	 resw 1
 42144 0000C42C ????                    part_table_rel_sec_hw:	 resw 1
 42145 0000C42E ????                    part_table_num_sec_lw:	 resw 1
 42146 0000C430 ????                    part_table_num_sec_hw:	 resw 1
 42147 0000C432 ??                      			 resb 1
 42148 0000C433 ??                      part_table_changed:	 resb 1
 42149 0000C434 ????                    part_table_mbytes_used:  resw 1
 42150 0000C436 ????                    part_table_percent_used: resw 1
 42151 0000C438 <res Ch>                part_table_vol_label:	 resb 12
 42152 0000C444 <res 9h>                part_table_system:	 resb 9
 42153 0000C44D ??                      part_table_drive_letter: resb 1
 42154 0000C44E <res 14h>               		       resb 20
 42155 0000C462 ????                    pt_part2_mbytes_used:  resw 1
 42156 0000C464 ????                    pt_part2_percent_used: resw 1
 42157 0000C466 <res 16h>               		       resb 22
 42158 0000C47C <res 14h>               		       resb 20
 42159 0000C490 ????                    pt_part3_mbytes_used:  resw 1
 42160 0000C492 ????                    pt_part3_percent_used: resw 1
 42161 0000C494 <res 16h>               		       resb 22
 42162 0000C4AA <res 14h>               		       resb 20
 42163 0000C4BE ????                    pt_part4_mbytes_used:  resw 1
 42164 0000C4C0 ????                    pt_part4_percent_used: resw 1
 42165 0000C4C2 <res 16h>               		       resb 22
 42166 0000C4D8 <res 508h>              		resb 1288 ; 22/11/2018 (4*46*7 = 1288)
 42167                                  
 42168                                  ;max_sector:	resb 8
 42169 0000C9E0 <res 200h>              boot_record:	resb 512
 42170 0000CBE0 ????                    logical_buff:	resw 1
 42171 0000CBE2 ??                      cur_disk:	resb 1
 42172 0000CBE3 ??                      		resb 1
 42173 0000CBE4 ??                      p_buff:		   resb 1
 42174 0000CBE5 ??                      p_buff_p_item_tag: resb 1
 42175 0000CBE6 ????                    p_buff_p_synonym:  resw 1
 42176 0000CBE8 ????????                p_buff_p_value:	   resd 1
 42177 0000CBEC ??                      valid_input:	resb 1
 42178 0000CBED ??                      		resb 1
 42179 0000CBEE ????                    Parse_Ptr:	resw 1
 42180                                  
 42181                                  ; 14/11/2019
 42182                                  fspc:		; 5*10 words (for free space calculations)
 42183                                  
 42184                                  ; Space 1 - unused cylinders before partition 0
 42185                                  ; Space 2 - unused cylinders between partition 0 & 1 
 42186                                  ; Space 3 - unused cylinders between partition 1 & 2 
 42187                                  ; Space 5 - unused cylinders between partition 2 & 3 
 42188                                  ; Space 5 - unused cylinders after partition 3
 42189                                  
 42190                                  ; 13/01/2019
 42191 0000CBF0 ????                    free_space.space:   	   resw 1
 42192 0000CBF2 ????                    free_space.start:   	   resw 1
 42193 0000CBF4 ????                    free_space.end:	   	   resw 1
 42194 0000CBF6 ????                    free_space.mbytes_unused:  resw 1
 42195 0000CBF8 ????                    free_space.percent_unused: resw 1
 42196                                  		;resb 520
 42197                                  		;resw 4*5  ; 17/01/2019
 42198 0000CBFA <res E6h>               		resw  23*5 ; 20/01/2019		 	
 42199                                  
 42200 0000CCE0 ??                      disk_access:	 resb 1
 42201 0000CCE1 ??                      dac_access_flag: resb 1
 42202 0000CCE2 ??                      sp_buff:	    resb 1
 42203 0000CCE3 ??                      sp_buff_p_item_tag: resb 1
 42204 0000CCE4 ????                    sp_buff_p_synonym:  resw 1
 42205 0000CCE6 <res Ah>                sp_buff_p_value:    resb 10
 42206                                  
 42207                                  ; 13/12/2018
 42208 0000CCF0 ????                    outbuf_ptr:	resw 1 ; offset insert (insert+)
 42209 0000CCF2 ????                    outbuf_cnt:	resw 1 ; 800
 42210                                  
 42211 0000CCF4 <res 320h>              insert:		resb 800
 42212                                  
 42213 0000D014 ????                    dataoffset_end_2: resw 1
 42214                                  
 42215                                  ; 10/11/2018
 42216 0000D016 ????                    _argc:  resw 1
 42217 0000D018 ????                    _argv:	resw 1
 42218 0000D01A ????                    retadr:	resw 1
 42219 0000D01C ????                    _temp:	resw 1
 42220 0000D01E ????                    _input: resw 1
 42221 0000D020 ????????                _pgmptr: resd 1
 42222                                  		
 42223                                  ; SEGMENT 5 - Uninitialized --------------------------------------------------
 42224                                  
 42225                                  ;resb 2048
 42226                                  
 42227                                  alignb 2
 42228                                  
 42229                                  end_of_file: 
