; ****************************************************************************
; FDISK.ASM (FDISK.COM) - MSDOS 3.3 Hard Disk Partitioning Utility
; 	    by Erdogan Tan				  (for MSDOS/WINDOWS)
; ****************************************************************************
; Last Update: 22/10/2018
; ----------------------------------------------------------------------------
; Beginning: 21/10/2018
; ----------------------------------------------------------------------------
; Assembler: NASM version 2.11
; ----------------------------------------------------------------------------
; Modified from disassembled source code of FDISK.COM by Alan Jay Weiner, 1983
; ****************************************************************************
; nasm fdisk.s -l fdisk.txt -o FDISK.COM
; ============================================================================
;
; ---------------------------------------------------------------------------
; -	This file is generated by The Interactive Disassembler (IDA)	    -
; -	Copyright (c) 2010 by Hex-Rays SA, <support@hex-rays.com>	    -
; -			 Licensed to: Freeware version			    -
; ---------------------------------------------------------------------------
;
; Input	MD5   :	B4080FCD526BEB3060C00FCC3FF4E9CC

; File Name   :	D:\Documents and Settings\Erdoðan Tan\Desktop\FDISK.COM
; Format      :	MS-DOS COM-file
; Base Address:	0h Range: 100h-1702h Loaded length: 1602h

; ============================================================================

	[BITS 16]
	[ORG 100h]

start:
	jmp	code_start

	dw	2018
	dw	01A1h

	db	0
; ----------------------------------------------------------------------------

	db 'FDISK utility Copyright 1983 Phoenix Software Associates, Ltd'
	db 0Dh,0Ah
	db 'written by Alan Jay Weiner'
	db 1Ah

	; FDISK.COM file - 05/06/1985 
	; (It is seen as, there is a modification on 1983 code for FAT16 FS)
	; (Also this modification may be reason of unused code in FDISK.COM.) 

;MBR_ADDR:	dw	MBR
buffer:		dw	end_of_file+2

current_partition:
p_status:	db	0
start_head:	db	0
start_cyl_sec:	dw	0
partition_type:	db	0
end_head:	db	0
end_cyl_sec:	dw	0
start_lba_lw:	dw	0
start_lba_hw:	dw	0
sectors_lba_lw:	dw	0
sectors_lba_hw:	dw	0

pt_start_cyl:	dw	0
pt_end_cyl:	dw	0
pt_cylinders:	dw	0
file_system:	db	1
cpartition_number:
		db	0
partition:	db	0
drive:		db	80h ; 0
disk_number:	db	'1' ; 0
wait_for_input:	db	0
max_avl_cylinders: 
		dw	0
next_start_cylinder: 
		dw	0
cylinders:	dw	0
start_cyl:	dw	0
active_part_input:
		db	0
active_partition:
		db	0

; ----------------------------------------------------------------------------

code_start:
		push	cs
		pop	es
		mov	dx,CLSSET
		call	write_on_screen
		;mov	byte [drive],80h
		;mov	byte [disk_number],'1'
		;mov	byte [wait_for_input],0
		call	get_harddisk_parameters
		jnc	short read_mb_sector
		mov	dx,NOFDISKPMSG ; "\r\n\nNo fixed disks present.\r\n\n"
		call	write_on_screen
		jmp	short terminate

read_mb_sector:
		call	read_mbr

start_screen:

;       |0000000000111111111122222222223333333333|  MAIN MENU   ;
;       |0123456789012345678901234567890123456789|              ;
;     --------------------------------------------              ;
;     00|                                        | FDISKOPMPAGE ;
;     01|                                        |              ;
;     02|                                        |              ;
;     03|                                        |              ;
;     04|FDISK Options                           |              ;
;     05|                                        |              ;
;     06|Current Fixed Disk Drive: 1             |              ;
;     07|                                        |              ;
;     08|                                        |              ;
;     09|Choose one of the following:            |              ;
;     10|                                        |              ;
;     11|    1.  Create DOS Partition            |              ;
;     12|    2.  Change Active Partition         |              ;
;     13|    3.  Delete DOS Partition            |              ;
;     14|    4.  Display Partition Data          |              ;
;     15|    5.  Select Next Fixed Disk Drive    |              ;
;     16|                                        |              ;
;     17|Enter choice: [1]                       |              ;
;     18|                                        |              ;
;     19|                                        |              ;
;     20|                                        |              ;
;     21|                                        |              ;
;     22|                                        |              ;
;     23|# is not a choice.  Enter a choice.     | WRONGSELECT  ;
;     24|Press ESC to return to DOS.             |              ;
;     --------------------------------------------              ;

		mov	dx,FDISKOPMPAGE
		call	write_on_screen
so1:
		mov	dx,[opnum_cpos]
		call	set_cursor_position
		mov	al,[def_opnum]
		call	select_option_number
		mov	bx,input_num_ftbl
		call	input_type_function
so2:
		mov	dx,WRONGSELECT
		call	write_on_screen
		jmp	short so1

op_cancel_exit:
		cmp	byte [wait_for_input],0
		jne	short getch_reboot
		mov	dx,cls1
		call	write_on_screen
terminate:
		mov	ah,0
		int	21h		; DOS -	PROGRAM	TERMINATION

getch_reboot:
		mov	dx,cls_reboot_msg
		call	write_on_screen
		call	getchar
		mov	dx,cls2
		call	write_on_screen
		jmp	0FFFFh:0

; ----------------------------------------------------------------------------

input_num_ftbl:	db	'1'
		dw	op_create_dosp  ; Create DOS Partition
		db	'2'
		dw	op_chg_activep	; Change Active Partition
		db	'3'
		dw	op_delete_dosp	; Delete DOS Partition
		db	'4'
		dw	op_display_pt	; Display Partition Data
		db	'5'
		dw	op_sel_nxt_disk	; Select Next Fixed Disk Drive

		db	27  ; 1Bh (ESCape) ; Cancel, Return to DOS 
		dw	op_cancel_exit
		db	0

; ----------------------------------------------------------------------------

op_create_dosp:		; Create DOS Partition	
		mov	dx,createdosp_msg
		call	write_on_screen
		call	dos_partitions
		jnz	short create_dosp
		call	display_partition_table
		mov	dx,alreadydosp_msg
		call	write_on_screen
		jmp	cdosp5

; ----------------------------------------------------------------------------

create_dosp: ; The disk hasn't got a DOS partition, let's create DOS partition

;       |00000000001111111111222222222233333333334444444444| CREATE MENU     ;
;       |01234567890123456789012345678901234567890123456789|                 ;
;     ------------------------------------------------------                 ;
;     00|                                                  | PTABLEHEADER    ;
;     01|                                                  |                 ;
;     02|                                                  |                 ;
;     03|                                                  |                 ;
;     04|Create DOS partition                              | createdosp_msg  ;
;     05|                                                  |                 ;
;     06|Current Fixed Disk Drive: 1                       |                 ;
;     07|                                                  |                 ;
;     08|                                                  |                 ;
;     09|Partition   Status   Type   Start   End   Size    |                 ;
;     10|    1          A     DOS        0    63     64    | DOSPTABLEROW    ;
;     11|                                                  |                 ;
;     12|                                                  |                 ;
;     13|                                                  |                 ;
;     14|Total disk space is    64 cylinders               | TOTALDISKSIZE   ;
;     15|The current active partition is 1                 | CURACTIVEPART   ;
;     16|                                                  |                 ;
;     17|                                                  |                 ;
;     18|                                                  |                 ;
;     19|Fixed disk already has a DOS partition.           | alreadydosp_msg ;
;     20|                                                  |                 ;
;     21|                                                  |                 ;
;     22|                                                  |                 ;
;     23|                                                  |                 ;
;     24|Press Esc to return to FDISK Options _            |                 ;
;     ------------------------------------------------------                 ;

		mov	cl,1
		call	find_first_partition
		jnc	short cdosp2
		mov	dx,empty_pt
		call	write_on_screen
		mov	al,[_yes_]
		call	select_option_number
		mov	bx,input_yn_ftbl
		call	input_type_function
		mov	dx,beep1
		call	write_on_screen
		jmp	short create_dosp
cdosp1:
		mov	word [start_cyl],0
		mov	ax,[totalcylinders]
		mov	[cylinders],ax
		mov	byte [p_status],80h
		jmp	short cdosp4
cdosp2:
		call	display_partition_table
		mov	cl,4
		call	find_first_partition
		jnc	short cdosp7
		mov	byte [p_status],0
		call	get_max_available_space
		cmp	word [max_avl_cylinders],0
		je	short cdosp7
		mov	dx,maxavlspace_msg
		call	write_on_screen

;       |00000000001111111111222222222233333333334444444444| CREATE MENU     ;
;       |01234567890123456789012345678901234567890123456789|                 ;
;     ------------------------------------------------------                 ;
;     00|                                                  |                 ;
;     01|                                                  |                 ;
;     02|                                                  |                 ;
;     03|                                                  |                 ;
;     04|Create DOS partition                              |                 ;
;     05|                                                  |                 ;
;     06|Current Fixed Disk Drive: 1                       |                 ;
;     07|                                                  |                 ;
;     08|                                                  |                 ;
;     09|No partitions defined.				   |                 ;
;     10|                                                  |                 ;
;     11|                                                  |                 ;
;     12|                                                  |                 ;
;     13|                                                  |                 ;
;     14|Total disk space is    64 cylinders               |                 ;
;     15|Maximum available space is    64                  | maxavlspace_msg ;
;     16|cylinders at cylinder     0                       |                 ;
;     17|                                                  |                 ;
;     18|Enter partition size............: [  64]          | enterpsize_msg  ;
;     19|                                                  |                 ;
;     20|                                                  |                 ;
;     21|                                                  |                 ;
;     22|                                                  |                 ;
;     23|                                                  |                 ;
;     24|Press Esc to return to FDISK Options              |                 ;
;     ------------------------------------------------------                 ;

cdosp3:
		mov	dx,enterpsize_msg
		call	write_on_screen
		mov	ax,[max_avl_cylinders]
		mov	cl,4
		call	get_and_write_number
		jc	short cdosp6
		or	ax,ax
		jz	short cdosp8
		mov	[cylinders],ax
		cmp	ax,1023
		ja	short cdosp8
		mov	dx,entstartcyl_msg
		call	write_on_screen
		mov	ax,[next_start_cylinder]
		mov	cl,4
		call	get_and_write_number
		jc	short cdosp6
		mov	[start_cyl],ax
		cmp	ax,1023
		ja	short cdosp9
		mov	dx,blank34193919
		call	write_on_screen
cdosp4:
		call	set_primary_dos_partion
		call	prepare_pt_entry
		jc	short cdosp9
		call	create_primary_dos_partition
		call	write_mbr
		mov	byte [wait_for_input],1
		call	display_partition_table
cdosp5:
		jmp	redo1
cdosp6:
		jmp	start_screen
cdosp7:
		mov	dx,noptspace_msg
		call	write_on_screen
		jmp	redo1
cdosp8:
		mov	dx,zerocyl_msg
		call	write_on_screen
		jmp	short cdosp3
cdosp9:
		mov	dx,nocylspace_msg
		call	write_on_screen
		jmp	short cdosp3

; ----------------------------------------------------------------------------

set_primary_dos_partion: ; Set partition tbl parameters for new DOS partition
		mov	byte [start_head],0
		mov	ax,[start_cyl]
		ror	ah,1
		ror	ah,1
		and	ah,0C0h
		or	ah,1
		mov	byte [start_cyl_sec],ah
		mov	byte [start_cyl_sec+1],al
		mov	al,[file_system]
		mov	[partition_type],al
		mov	al,[heads]
		mov	[end_head],al
		mov	ax,[start_cyl]
		add	ax,[cylinders]
		dec	ax
		ror	ah,1
		ror	ah,1
		and	ah,0C0h
		or	ah,[sectors]
		mov	byte [end_cyl_sec], ah
		mov	byte [end_cyl_sec+1],al
		retn

; ----------------------------------------------------------------------------

input_yn_ftbl:	db	'Y'  ; Yes/No answer to the question for create menu
		dw	cdosp1
		db	'y'
		dw	cdosp1
		db	'N'
		dw	cdosp2
		db	'n'
		dw	cdosp2
		db	1Bh ; ESCape (27)  ; Cancel, Return to main menu
		dw	start_screen
		db	0

; ----------------------------------------------------------------------------

op_chg_activep:		; Change Active Partition

;       |00000000001111111111222222222233333333334444444444| CHG ACTIVE PART ;
;       |01234567890123456789012345678901234567890123456789|                 ;
;     ------------------------------------------------------                 ;
;     00|                                                  | chgactpart_msg  ;
;     01|                                                  |                 ;
;     02|                                                  |                 ;
;     03|                                                  |                 ;
;     04|Change Active Partition                           |  		     ;
;     05|                                                  |                 ;
;     06|Current Fixed Disk Drive: 1                       |                 ;
;     07|                                                  |                 ;
;     08|                                                  |                 ;
;     09|Partition   Status   Type   Start   End   Size    | PTABLEHEADER    ;
;     10|    1          A     DOS        0    63     64    | DOSPTABLEROW    ;
;     11|                                                  |                 ;
;     12|                                                  |                 ;
;     13|                                                  |                 ;
;     14|Total disk space is    64 cylinders               |                 ;
;     15|                                                  |                 ;
;     16|                                                  |                 ;
;     17|                                                  |                 ;
;     18|Enter the number of the partition you want        | entptomkact_msg ;
;     19|to make active..................: [_]             |                 ;
;     20|                                                  |                 ;
;     21|                                                  |                 ;
;     22|                                                  |                 ;
;     23|                                                  |                 ;
;     24|                                                  |                 ;
;     ------------------------------------------------------                 ;

		mov	dx,chgactpart_msg
		call	write_on_screen
		call	display_partition_table
		mov	cl,2
		call	find_first_partition
		jnc	short chg_ap2
		mov	cl,1
		call	find_first_partition
		jc	short chg_ap1
		cmp	byte [p_status],80h
		jne	short chg_ap2
		jmp	short chg_ap8
chg_ap1:
		jmp	short chg_ap7
chg_ap2:
		call	dos_partitions
		jz	short chg_ap3
		mov	byte [cpartition_number],1
chg_ap3:
		mov	dx,entptomkact_msg
		call	write_on_screen
		mov	al,[cpartition_number]
		xor	ah,ah
		mov	cl,1
		call	get_and_write_number
		jc	short chg_ap9
		mov	[active_part_input],al
		or	al,al
		jz	short chg_ap6
		mov	cl,al
		call	find_first_partition
		jc	short chg_ap6
		mov	byte [partition],0
chg_ap4:
		inc	byte [partition]
		call	get_partition_params
		jc	short chg_ap5
		mov	byte [p_status],0
		call	move_partition_params
		loop	chg_ap4
chg_ap5:
		mov	cl,[active_part_input]
		call	find_first_partition
		mov	byte [p_status],80h
		call	move_partition_params
		call	write_mbr
		add	byte [active_part_input],'0'
		mov	dx,madeactive_msg
		call	write_on_screen
		call	display_partition_table
		jmp	redo1
chg_ap6:
		add	byte [active_part_input],'0'
		mov	dx,isnotchoice_msg
		call	write_on_screen
		jmp	short chg_ap2
chg_ap7:
		mov	dx,noptoactive_msg
		call	write_on_screen
		jmp	redo1
chg_ap8:			; "Partition # is already active."
		mov	dx,alrdyactive_msg
		call	write_on_screen
		jmp	redo1
chg_ap9:
		jmp	start_screen

; ----------------------------------------------------------------------------

op_delete_dosp:		; Delete DOS Partition

;       |00000000001111111111222222222233333333334444444444| DELETE MENU     ;
;       |01234567890123456789012345678901234567890123456789|                 ;
;     ------------------------------------------------------                 ;
;     00|                                                  | deldp_msg       ;
;     01|                                                  |                 ;
;     02|                                                  |                 ;
;     03|                                                  |                 ;
;     04|Delete DOS partition                              |  		     ;
;     05|                                                  |                 ;
;     06|Current Fixed Disk Drive: 1                       |                 ;
;     07|                                                  |                 ;
;     08|                                                  |                 ;
;     09|Partition   Status   Type   Start   End   Size    | PTABLEHEADER    ;
;     10|    1          A     DOS        0    63     64    | DOSPTABLEROW    ;
;     11|                                                  |                 ;
;     12|                                                  |                 ;
;     13|                                                  |                 ;
;     14|Total disk space is    64 cylinders               |                 ;
;     15|The current active partition is 1                 |                 ;
;     16|                                                  |                 ;
;     17|                                                  |                 ;
;     18|Warning!  Data in the DOS partition               | deldp_warn_msg  ;
;     19|could be lost.  Do you wish to                    |                 ;
;     20|continue...................................? [N]  |                 ;
;     21|                                                  |                 ;
;     22|                                                  |                 ;
;     23|                                                  |                 ;
;     24|Press Esc to return to FDISK Options              |                 ;
;     ------------------------------------------------------                 ;

		mov	dx,deldp_msg
		call	write_on_screen
		call	display_partition_table
		call	dos_partitions
		jz	short deldosp1
		mov	dx,no_dosp_del_msg
		call	write_on_screen
		jmp	short deldosp8
deldosp1:
		mov	dx,deldp_warn_msg
		call	write_on_screen
deldosp2:
		mov	dx,[delanswer_cpos]
deldosp3:
		call	set_cursor_position
		mov	al,[_no_]
		call	select_option_number
		mov	bx,deldosp_yn_tbl
		call	input_type_function
		mov	dx,beep2
		call	write_on_screen
		jmp	short deldosp2

; ----------------------------------------------------------------------------

deldosp_yn_tbl:	db	'Y' ; Yes/No answer to the question for delete menu	
		dw	deldosp_yes
		db	'y'
		dw	deldosp_yes
		db	'N'
		dw	start_screen
		db	'n'
		dw	start_screen
		db	1Bh ; ESCape	; Cancel, Return to main menu
		dw	start_screen
		db	0

deldosp_yes:
		mov	byte [partition],1
deldosp4:
		call	get_partition_params
		jc	short deldosp7
		mov	al,[file_system]
		cmp	al,[partition_type]
		je	short deldosp5
		cmp	byte [partition_type],4
		jne	short deldosp6
deldosp5:
		call	delete_pte
deldosp6:
		inc	byte [partition]
		jmp	short deldosp4
deldosp7:
		mov	byte [wait_for_input],1
		call	write_mbr
		call	display_partition_table
deldosp8:
		jmp	redo1

; ----------------------------------------------------------------------------

op_display_pt:		; Display Partition Table/Data
		mov	dx,DISPLAYPTPAGE
		call	write_on_screen
		call	display_partition_table
		jmp	redo1

; ----------------------------------------------------------------------------

op_sel_nxt_disk:
		cmp	byte [harddisks],1
		jne	short snxt1
		jmp	so2
snxt1:
		inc	byte [drive]
		inc	byte [disk_number]
		mov	al,[drive]
		and	al,7Fh
		cmp	al,[harddisks]
		jb	short snxt2
		mov	byte [drive],80h
		mov	byte [disk_number],'1'
snxt2:
		call	read_mbr
		jmp	start_screen

; ----------------------------------------------------------------------------

display_partition_table: 	; Display Partition Data
		call	check_set_pt_order
		call	get_active_partition
		mov	bx,[buffer]
		add	bx,1CAh ; 1BEh + 12
		mov	cx,4
		xor	ax,ax
dpt1:
		or	ax,[bx]
		or	ax,[bx+2]
		add	bx,16
		loop	dpt1
		or	ax,ax
		jnz	short dpt2
		mov	dx,nopartdef_msg
		call	write_on_screen
		jmp	short dpt6
dpt2:
		mov	dx,PTABLEHEADER
		call	write_on_screen
		mov	byte [cpartition_number],'1'
		mov	byte [partition], 1
dpt3:
		call	get_partition_params
		jc	short dpt6
		mov	ax,[sectors_lba_lw]
		or	ax,[sectors_lba_hw]
		jz	short dpt5
		mov	dx,DOSPTABLEROW
		cmp	byte [partition_type],1
		je	short dpt4
		cmp	byte [partition_type],4
		je	short dpt4
		mov	dx,NONDOSPTABLEROW
dpt4:
		call	write_on_screen
		inc	byte [cpartition_number]
dpt5:
		inc	byte [partition]
		jmp	short dpt3
dpt6:
		mov	dx,TOTALDISKSIZE
		call	write_on_screen
		cmp	byte [active_partition],0FFh  ; -1
		je	short dpt7
		mov	dx,CURACTIVEPART
		call	write_on_screen
dpt7:
		retn

; ----------------------------------------------------------------------------

dos_partitions:  ; Check for a DOS partition is present or not
		mov	byte [cpartition_number],1
		mov	byte [partition],1
dp1:
		call	get_partition_params
		jc	short dp3
		cmp	word [sectors_lba_lw],0
		je	short dp2
		mov	al,[file_system]
		cmp	al,[partition_type]
		je	short dp4
		cmp	byte [partition_type],4
		je	short dp4
		inc	byte [cpartition_number]
dp2:
		inc	byte [partition]
		jmp	short dp1
dp3:
		xor	al, al
		inc	al
dp4:
		retn

; ----------------------------------------------------------------------------

find_first_partition:	; Find first valid/existing partition 
			; (CL = start partition number/index in PT for search)
		xor	ch,ch
		mov	byte [partition],0
ffp1:
		inc	byte [partition]
		call	get_partition_params
		jc	short ffp2
		cmp	word [sectors_lba_lw],0
		je	short ffp1
		loop	ffp1
		;clc		 ; cf = 0 -> partition index in [partition] 
ffp2:				 ; cf = 1 -> there is not a valid partition!
		retn

; ----------------------------------------------------------------------------

redo1:		; Return to main menu
		mov	dx,finalcpos	; Final cursor position for getchar
		call	write_on_screen
redo2:
		call	getchar		; Get a character from keyboard input
		cmp	al,1Bh ; ESC	; Cancel/ESCape key
		jne	short redo3
		jmp	start_screen
redo3:
		mov	dx,beep4	; beep sound (wtty with al=07h)
		call	write_on_screen
		jmp	short redo2

; ----------------------------------------------------------------------------

get_active_partition:	; Get (present) active partititon number (as '1'..'4')
		mov	byte [partition],0
		mov	byte [cpartition_number],'1'
gapart1:
		inc	byte [partition]
		call	get_partition_params
		jc	short gapart3
		cmp	word [sectors_lba_lw],0
		je	short gapart1
		cmp	byte [p_status],80h
		je	short gapart2
		inc	byte [cpartition_number]
		jmp	short gapart1
gapart2:
		mov	al,[cpartition_number]
		mov	[active_partition],al
		;clc
		retn
gapart3:
		mov	byte [active_partition],0FFh ; -1 ; not found !
		;stc
		retn

; ----------------------------------------------------------------------------

harddisks:	db	0
heads:		db	0
totalcylinders:	dw	0
sectors:	db	0
cyl_sectors:	dw	0

; ----------------------------------------------------------------------------

get_harddisk_parameters: ; Get disk/CHS parameters as base of FDISK functions
		mov	dl,80h
		mov	ah,8
		int	13h	; DISK - DISK -	GET CURRENT DRIVE PARAMETERS
				;		(XT,AT,XT286,CONV,PS)
				; DL = drive number
				; Return:
				;    	CF set on error,
				;	AH = status code
				;	BL = drive type
				;	CX = maximum value for cylinder&sector 
				; 	DL = number of consecutive drives
				; 	DH = maximum value for head number
				;	ES:DI -> drive parameter
		jc	short ghdp_retn
		mov	[harddisks],dl
		mov	[heads],dh
		mov	[cyl_sectors],cx
		push	cx
		and	cl,3Fh
		mov	[sectors],cl
		pop	cx
		xchg	ch,cl
		rol	ch,1
		rol	ch,1
		and	cx,3FFh
		inc	cx
		mov	[totalcylinders],cx
		;mov	al,[harddisks]
		;cmp	al,1
		cmp	dl,1
ghdp_retn:
		retn

; ----------------------------------------------------------------------------

read_mbr:	; Read Master Boot Record/Sector (C=0,H=1,S=1)
		mov	ah,2
		mov	al,1
		mov	cx,1
		mov	dh,0
		mov	dl,[drive]
		push	cs
		pop	es
		mov	bx,[buffer]  ; Master Boot sector buffer address
		int	13h	; DISK - READ SECTORS INTO MEMORY
				;    AL = number of sectors to read, 
				;    CH = track, CL = sector
				;    DH = head, DL = drive,
				;    ES:BX -> buffer to fill
				; Return: 
				;    CF set on error,
				;    AH = status,
				;    AL = number of sectors read
		mov	bx,[buffer]
		cmp	word [bx+510],0AA55h
		je	short read_mbr_retn
		mov	di,bx
		mov	cx,512
		xor	al,al
		rep stosb
read_mbr_retn:
		retn

; ----------------------------------------------------------------------------

write_mbr:	; Write Master Boot Record/Sector (C=0,H=1,S=1)
		; (Master Boot sector code will be restored by FDISK utility)

		mov	di,[buffer]
		mov	word [di+510],0AA55h
		;mov	si,[MBR_ADDR] ; FDISK Master Boot sector code address
		mov	si,MBR
		mov	cx,1BEh ; Move MBR code (till Partition Table offset)
		rep movsb
		mov	ah,3
		mov	al,1
		mov	cx,1
		mov	dh,0
		mov	dl,[drive]
		push	cs
		pop	es
		mov	bx,[buffer]
		int	13h	; DISK - WRITE SECTORS FROM MEMORY
				;    AL = number of sectors to write,
				;    CH = track, CL = sector
				;    DH = head, DL = drive,
				;    ES:BX -> buffer
				; Return:
				;    CF set on error,
				;    AH = status,
				;    AL = number of sectors written
		retn

; ----------------------------------------------------------------------------

get_partition_params:	; Convert PT entry params to cylinder (word) values
			; (PTE index in [Partition] will be used)
		push	ax
		push	bx
		push	cx
		push	si
		push	di
		call	locate_partition
		jc	short sp_pop_retn
		mov	di,current_partition
		mov	cx,16
		rep movsb
		mov	ax,[start_cyl_sec]
		call	get_cylinder
		mov	[pt_start_cyl],ax
		mov	ax,[end_cyl_sec]
		call	get_cylinder
		mov	[pt_end_cyl],ax
		sub	ax,[pt_start_cyl]
		inc	ax
		mov	[pt_cylinders],ax
		clc
sp_pop_retn:
		pop	di
		pop	si
		pop	cx
		pop	bx
		pop	ax
		retn

; ----------------------------------------------------------------------------

create_primary_dos_partition: ; Create a DOS partition in Master Boot buffer
			      ; (if there is an empty partition table entry)	
		call	calc_partition_lba
		call	cyl0_sec1_fix ; Move start addr to head 1 if it is 0
		mov	bx,[buffer]
		add	bx,1FAh  ; 1BEh+48+12 ; Start sector (LBA) address
		mov	cx,4
search_empty_pte:
		xor	ax,ax
		or	ax,[bx]
		or	ax,[bx+2]
		jz	short set_pte
		sub	bx,16	; next entry/row (in parition table)
		loop	search_empty_pte
		stc	; there is not an empty entry/row in partition table!		
		retn
set_pte:
		mov	si,current_partition  ; PTE setup address of FDISK
		sub	bx,12	; Move BX to beginning of the PTE/row
		mov	di,bx		; Target PTE
		mov	cx,16
		rep movsb
		clc
		retn

; ----------------------------------------------------------------------------

move_partition_params:	; Move FDISK setup (PTE) to the PTE in MBR buffer
			; (Partition/Entry index in [partition] will be used)
		call	locate_partition
		mov	di,si
		mov	si,current_partition
		mov	cx,16
		rep movsb
		retn

; ----------------------------------------------------------------------------

delete_pte:		; Delete partition table entry (partition) in MBR buff
			; (Partition/Entry index in [partition] will be used)
		call	locate_partition
		jc	short delete_pte_retn
		mov	di,si
		mov	cx,16
		xor	al,al
		rep stosb
		;clc
delete_pte_retn:
		retn

; ----------------------------------------------------------------------------

pt_swapped:	db	0

; ----------------------------------------------------------------------------

check_set_pt_order:	; Re-order partition table entries in CYLINDER order
		mov	si,[buffer]	; MBR buffer
		add	si,1BEh		; Partition table offet
		mov	di,si
		add	di,16		; Next partition/entry
		mov	cx,3
		mov	byte [pt_swapped],0 ; Reset swap flag
cspto_1:
		cmp	word [si+12],0  ; Partition's Start Sector = 0 ?
		je	short cspto_2
		mov	ax,[si+2]
		call	get_cylinder
		mov	bx,ax
		mov	ax,[di+6]
		call	get_cylinder
		cmp	ax,bx
		jnb	short cspto_2
		call	swap_partition_rows
		inc	byte [pt_swapped] ; PT entries are swapped
cspto_2:
		mov	si,di
		add	di,16		; Next partition/entry
		loop	cspto_1
		cmp	byte [pt_swapped],0  ; There is a PTE swap ?
		jne	short check_set_pt_order ;  Yes, re-check/re-do
		retn			     ; No, it is finished.	

; ----------------------------------------------------------------------------

swap_partition_rows:	; Exchange/Swap partition data of requested PT entries
			; (PT entries are addressed by SI and DI registers)  
		push	cx
		push	si
		push	di
		mov	cx,16
spr_loop:
		mov	al,[si]
		xchg	al,[di]
		mov	[si],al
		inc	si
		inc	di
		loop	spr_loop
		pop	di
		pop	si
		pop	cx
		retn

; ----------------------------------------------------------------------------

get_cylinder:	; Convert partition table Cyl+Sec entry to cylinder value
		xchg	al,ah	; Low 8 bits of cylinder is in AL
		rol	ah,1	; High two bits of cylinder were in bit 7 & 8
		rol	ah,1	; .. now, they are in bit 0 & 1 of AH
		and	ax,3FFh	; Mask cyl value with 1023 (mask AH with 3)
		retn

; ----------------------------------------------------------------------------

locate_partition: ; Return address of resuested partition table entry
		  ; (Partition/Entry index in [partition] will be used)		
		mov	al,[partition]
		cmp	al,5
		cmc
		jc	short lpar_retn ; cf = 1, invalid index (> 4) 
		cbw
		dec	al
		mov	cl,4
		shl	al,cl ; *16
		mov	si,[buffer]	; FDISK MBR buffer address
		add	si,1BEh		; Partition table offset in MBR buff
		add	si,ax		; + partition table entry offset
		clc	; clear carry flag (this may not be necessary here!?)
			; ((because SI+AX always must/will be less than 64K)) 
lpar_retn:
		retn

; ----------------------------------------------------------------------------

calc_partition_lba: ; Convert CHS values (of current partition) to LBA address
		mov	ax,[start_cyl_sec]
		call	get_cylinder ; Get normalized/word cylinder value
		mov	bx,ax
		mov	al,[heads]   ; Heads-1 (< 255) -the last head number-	
		inc	al	     ; Number of heads (<=255)	
		cbw	; AL -> AX)
		mul	bx	     ; AX = Start Track (StartCYLINDER*Heads) 	
		mov	cl,[sectors] ; Sectors per track (<= 63)
		xor	ch,ch
		mul	cx	     ; DX:AX = Start Sector (SPT*StartTRACK)	
		mov	[start_lba_lw],ax
		mov	[start_lba_hw],dx
		mov	ax,[end_cyl_sec]
		call	get_cylinder
		sub	ax,bx
		inc	ax
		mov	bx,ax
		mov	al,[heads]   ; Heads-1 (<255) -the last head number-
		inc	al	     ; Number of heads (<=255)	  	
		cbw	; AL -> AX
		mul	bx	     ; AX = End Track (EndCYLINDER*Heads) 	
		mov	cl,[sectors]
		xor	ch,ch
		mul	cx	     ; DX:AX = End Sector (SPT*EndTRACK)	
		mov	[sectors_lba_lw],ax
		mov	[sectors_lba_hw],dx
		retn

; ----------------------------------------------------------------------------

cyl0_sec1_fix:	; Move start address to cylinder=0, head=1, sector=1 
		;      if start address is 0 (cylinder=0, head=0, sector=1)
		cmp	word [start_cyl_sec],1
		jne	short no_start_cyl_fix
		cmp	byte [start_head],0
		jne	short no_start_cyl_fix
		mov	byte [start_head],1
		mov	al,[sectors] ; SPT (Sectors Per Track)
		cbw
		add	[start_lba_lw],ax	; start = start + SPT	
		sub	[sectors_lba_lw],ax	; size = size - SPT
		;   (If SPT=63, start LBA is 63; if SPT=17, start LBA is 17) 
no_start_cyl_fix:
		retn

; ----------------------------------------------------------------------------

present_end_cylinder:	dw	0

; ----------------------------------------------------------------------------

get_max_available_space: ; Get maximum available space between partitions
			 ;					as cylinders
		call	check_set_pt_order
		mov	word [next_start_cylinder],0
		mov	word [max_avl_cylinders],0
		mov	word [present_end_cylinder],0FFFFh ; -1
		mov	byte [partition],0
gmac1:
		inc	byte [partition]
		call	get_partition_params
		jc	short gmac3
		mov	ax,[sectors_lba_lw]
gmac2:
		or	ax, ax
		jz	short gmac1
		mov	ax, [start_cyl_sec]
		call	get_cylinder
		call	set_present_avl_space ; Calculate space (as cylinders) 
			 ; between current/requested cyl and previous end cyl)									       	
		jmp	short gmac1
gmac3:
		mov	ax,[totalcylinders]
		call	set_present_avl_space 
		dec	word [max_avl_cylinders]
		retn

; ----------------------------------------------------------------------------

start_cylinder:	dw	0
end_cylinder:	dw	0
		;times 4 db 0

; ----------------------------------------------------------------------------

prepare_pt_entry:
		call	check_set_pt_order
		mov	word [present_end_cylinder],0FFFFh ; -1
		mov	si,[buffer]
		add	si,1BEh ; MBR Partition Table offset
		mov	cx,4
		mov	ax,[start_cyl_sec]
		call	get_cylinder
		mov	[start_cylinder],ax
		mov	ax,[end_cyl_sec]
		call	get_cylinder
		mov	[end_cylinder],ax
ppte1:
		cmp	word [si+12],0
		jz	short ppte2	; Empty PTE
		mov	ax,[si+2]
		call	get_cylinder
		cmp	ax,[end_cylinder]
		ja	short ppte3
		mov	ax,[si+6]
		call	get_cylinder
		mov	[present_end_cylinder],ax
ppte2:
		add	si,16
		loop	ppte1
		mov	ax,[end_cylinder]
		cmp	ax,[totalcylinders]
		jge	short ppte_error
ppte3:
		mov	ax,[start_cylinder]
		cmp	ax,[present_end_cylinder]
		jle	short ppte_error
		clc
		retn
ppte_error:
		stc
		retn

; ----------------------------------------------------------------------------

set_present_avl_space:
		; Calculate available space (in cylinders unit) 
		; between current/requested cylinder and present end cyl)
		; AX = Current/requested cylinder number
		; [present_end_cylinder] = end cylinder of present partition	
		sub	ax,[present_end_cylinder]
		cmp	ax,[max_avl_cylinders] ; Max. available (conseq) cyls
		jbe	short no_set_max_avl_cyl
		mov	[max_avl_cylinders],ax
		mov	ax,[present_end_cylinder]
		inc	ax
		mov	[next_start_cylinder],ax ; Start cylinder of the next
						 ; partition may be just after
						 ; (+1 to) the end cylinder
						 ; of the present parition    
no_set_max_avl_cyl:
		mov	ax,[end_cyl_sec]
		call	get_cylinder
		mov	[present_end_cylinder],ax ; present end cylinder ..
				; (.. will be previous for the next partition)
		retn

; ----------------------------------------------------------------------------

; FDISK menu data and messages (with menu page format/control characters)

CLSSET:		db	6
		db	0Dh
		db	0Ah
		db	0
NOFDISKPMSG:	db	0Dh,0Ah
		db	0Ah
		db	'No fixed disks present.',0Dh,0Ah
		db	0Ah,0
FDISKOPMPAGE:	db	5 ; Set Cursor Position
		db	0 ; Column 0	
		db	4 ; Row 4
		db	16
		db	19 
		db	'FDISK Options'
		db	20
		db	0Dh
		db	0Ah
		db	0Ah
		db	14
		dw	harddisks
		db	1
		db	5
		db	0
		db	6
		db	'Current Fixed Disk Drive:'
		db	20h
		db	19
		db	11
		dw	disk_number
		db	20
		db	0Fh
		db	5
		db	0
		db	9
		db	'Choose one of the following:',0Dh,0Ah
		db	0Ah
		db	'    ',13h,'1',14h,'. Create DOS Partition',0Dh,0Ah
		db	'    ',13h,'2',14h,'. Change Active Partition',0Dh,0Ah
		db	'    ',13h,'3',14h,'. Delete DOS Partition',0Dh,0Ah
		db	'    ',13h,'4',14h,'. Display Partition Data',0Dh,0Ah
		db	14
		dw	harddisks
		db	1
		db	'    ',13h,'5',14h,'. Select Next Fixed Disk Drive',0Dh,0Ah
		db	0Fh
		db	5
		db	0
		db	17
		db	'Enter choice: ',13h,'[ ]',14h
		db	5
		db	0
		db	24
		db	'Press ',13h,'Esc',14h,' to return to DOS.',0
WRONGSELECT:	db	5
		db	0
		db	23
		db	11
		dw	selected_opnum
		db	7,'  is not a choice.  Enter a choice.',0
def_opnum:	db	'1'
opnum_cpos:	dw	110Fh ; Column 17, Row 15
DISPLAYPTPAGE:	db	5
		db	0
		db	4
		db	13h,'Display Partition Information',14h,9,5,0
		db	8
		db	16
		db	5
		db	0
		db	24
		db	'Press ',13h,'Esc',14h,' to return to FDISK Options',0
TOTALDISKSIZE:	db	5
		db	0
		db	14
		db	'Total disk space is '
		db	4
		dw	totalcylinders
		db	' cylinders'
		db	0
CURACTIVEPART:	db	5
		db	0
		db	15
		db	'The current active partition is '
		db	11
		dw	active_partition
		db	5
		db	0
		db	24
		db	'Press ',13h,'Esc'
		db	14h
		db	20h
		db	'to return to FDISK Options'
		db	0
PTABLEHEADER:	db	5
		db	0
		db	9
		db	'Partition   Status   Type   Start   End   Size'
		db	9
		db	0Dh
		db	0Ah
		db	9
		db	0Ah
		db	9
		db	0Ah
		db	9
		db	0Ah
		db	9
		db	5
		db	0
		db	10
		db	0
DOSPTABLEROW:	times 4 db 20h
		db	11
		dw	cpartition_number
		times 10 db 20h
		db	12
		dw	current_partition
		db	80h
		db	'A'
		db	0Fh
		db	14
		dw	current_partition
		db	80h
		db	'N'
		db	0Fh
		db	'     DOS    '
		db	4
		dw	pt_start_cyl
		db	20h
		db	4
		dw	pt_end_cyl
		db	20h
		db	20h
		db	4
		dw	pt_cylinders
		db	0Dh
		db	0Ah
		db	0
NONDOSPTABLEROW: times 4 db 20h
		db	11
		dw	cpartition_number
		times 10 db 20h
		db	12
		dw	current_partition
		db	80h
		db	'A'
		db	0Fh
		db	14
		dw	current_partition
		db	80h
		db	'N'
		db	0Fh
		db	'   non-DOS  '
		db	4
		dw	pt_start_cyl
		db	20h
		db	4
		dw	pt_end_cyl
		db	20h
		db	20h
		db	4
		dw	pt_cylinders
		db	0Dh
		db	0Ah
		db	0
nopartdef_msg:	db	5
		db	0
		db	9
		db	'No partitions defined.'
		db	9
		db	0Dh
		db	0Ah
		db	9
		db	0Ah
		db	9
		db	0Ah
		db	9
		db	0Ah
		db	9
		db	0
		db	20h
createdosp_msg	db	5
		db	0
		db	4
		db	13h
		db	'Create DOS partition'
		db	14h
		db	9
		db	5
		db	0
		db	8
		db	16
		db	0
		db	20h
alreadydosp_msg: db	5
		db	0
		db	19
		db	13h
		db	'Fixed disk already has a DOS partition.'
		db	14h
		db	0
empty_pt:	db	5
		db	0
		db	9
		db	'Do you wish to use the entire fixed',0Dh,0Ah
		db	'disk for DOS (Y/N).........................'
		db	20h
		db	13h
		db	'[ ]'
		db	14h
		db	5
		db	0
		db	24
		db	'Press Esc to return to FDISK Options'
		db	5
		db	45
		db	10
		db	0
maxavlspace_msg: db	5
		db	0
		db	15
		db	'Maximum available space is'
		db	20h
		db	4
		dw	max_avl_cylinders
		db	0Dh
		db	0Ah
		db	'cylinders at cylinder'
		db	20h
		db	4
		dw	next_start_cylinder
		db	0
enterpsize_msg:	db	5
		db	0
		db	12h
		db	'Enter partition size............: [    ]'
		db	8
		db	8
		db	0
entstartcyl_msg: db	5
		db	0
		db	21
		db	9
		db	0Dh
		db	0Ah
		db	9
		db	5
		db	34
		db	18
		db	20h
		db	5
		db	39
		db	18
		db	20h
		db	0Dh
		db	0Ah
		db	'Enter starting cylinder number..: [    ]'
		db	8
		db	8
		db	0
zerocyl_msg:	db	5
		db	0
		db	21
		db	'No space for a 0 cylinder partition.'
		db	9
		db	0Dh
		db	0Ah
		db	9
		db	0
noptspace_msg:	db	5
		db	0
		db	18
		db	'No space for a DOS partition'
		db	0
nocylspace_msg:	db	5
		db	0
		db	21
		db	'No space for a'
		db	4
		dw	cylinders
		db	' cylinder partition'
		db	9
		db	0Dh
		db	0Ah
		db	'at cylinder'
		db	4
		dw	start_cyl
		db	9
		db	0
		db	5
		db	0
		db	21
		db	'Dos partition created'
		db	0
blank34193919:	db	5
		db	34
		db	19
		db	20h
		db	5
		db	39
		db	19
		db	20h
		db	0
_yes_:		db	'Y'
beep1:		db	7
		db	0
chgactpart_msg:	db	5
		db	0
		db	4
		db	13h
		db	'Change Active Partition'
		db	14h
		db	9
		db	5
		db	0
		db	8
		db	16
		db	0
entptomkact_msg: db	5
		db	0
		db	18
		db	'Enter the number of the partition you want',0Dh,0Ah
		db	'to make active..................: [ ]'
		db	8
		db	8
		db	0
isnotchoice_msg: db	5
		db	0
		db	22
		db	11
		dw	active_part_input
		db	'  is not a choice.'
		db	'  Enter a choice.'
		db	0
madeactive_msg:	db	5
		db	0
		db	0Fh
		db	9
		db	5
		db	0
		db	18
		db	'Partition '
		db	11
		dw	active_part_input
		db	' made active.'
		db	9
		db	0Dh
		db	0Ah
		db	9
		db	0
alrdyactive_msg: db	5
		db	0
		db	18
		db	13h
		db	'Partition 1 is already active.'
		db	14h
		db	0
		db	5
		db	0
		db	0Fh
		db	'The current active partition is '
		db	11
		dw	cpartition_number
		db	0
noptoactive_msg: db	5
		db	0
		db	18
		db	'No partitions to make active.'
		db	0
deldp_msg:	db	5
		db	0
		db	4
		db	13h
		db	'Delete DOS partition'
		db	14h
		db	9
		db	5
		db	0
		db	8
		db	16
		db	5
		db	0
		db	24
		db	'Press ',13h,'Esc'
		db	14h
		db	' to return to FDISK Options'
		db	0
deldp_warn_msg:	db	5
		db	0
		db	18
		db	7
		db	19
		db	'Warning!  Data in the DOS partition',0Dh,0Ah
		db	'could be lost.'
		db	20h
		db	20h
		db	'Do you wish to',0Dh,0Ah
		db	'continue...................................? [ ]'
		db	20
		db	0
delanswer_cpos:	db	46
		db	20
_no_:		db	'N'
beep2:		db	7
		db	0
no_dosp_del_msg: db	5
		db	0
		db	18
		db	'No DOS partition to delete.'
		db	7
		db	0
beep3:		db	7
		db	0
cls1:		db	6
		db	0
cls_reboot_msg:	db	6
		db	5
		db	0
		db	16
		db	'System will now reboot',0Dh,0Ah
		db	0Ah
		db	'Insert DOS diskette in drive A:',0Dh,0Ah
		db	'Press any key when ready . . .'
		db	0
cls2		db	6
		db	0
finalcpos	db	5
		db	37
		db	24
		db	0
beep4		db	7
		db	0

; ----------------------------------------------------------------------------

write_on_screen: ; Write/Display partition data and messages on screen
		 ; (Videe mode 4h, int 10h will be used for menu pages)
write_on:	
		push	bx
		push	dx
		push	si
		mov	si,dx
w_get_char:
		lodsb
		cmp	al,20h
		jb	short w_function
w_put_char:
		call	chr_out
		jmp	short w_get_char

; ----------------------------------------------------------------------------

w_function:	; Write characters (strings) and perform requested function
		; for menu format/positioning/control characters
		cbw
		mov	bx,ax
		add	bx,ax
		jmp	word [bx+function]

; ----------------------------------------------------------------------------

NOT_USED: ; This is put here for compatibility with original FDISK code (1985)
		nop
w_pop_retn:	; Return from (w_function) write on screen function
		pop	si
		pop	dx
		pop	bx
		retn

; ----------------------------------------------------------------------------

function:	; Function jump table/addresses for format/positioning/control
		; characters between 0 to 30.
		dw	w_pop_retn		; 0 (return)
		dw	w_byte_out		; 1 (write pointed byte as hex num)
		dw	NOT_USED		; 2
		;dw	w_word_out		; 3 (write pointed word as hex num)
		dw	NOT_USED		; 3
		dw	w_decimal_number	; 4 (write number as decimal)
		dw	w_set_cpos		; 5 (Set Cursor position)
		dw	w_clear_screen		; 6 (clear screen)
		dw	w_put_char		; 7 (write character)
		dw	w_put_char		; 8	
		dw	w_blank_row		; 9 (clear row)
		dw	w_put_char		; 10
		dw	w_char_indirect		; 11 (write pointed char)
		dw	w_comp_num_skip_nz	; 12 (comp & skip text if nums are not equal)
		dw	w_put_char		; 13
		dw	w_comp_num_skip_z	; 14 (comp & skip text if nums are equal)	
		dw	w_get_char		; 15 (get caracter from keyboard)
		dw	w_cls_down		; 16 (clear rows down from current row)
		;dw	w_blink_on		; 17 (Enable blinking)
		;dw	w_blink_off		; 18 (Disable blinking)
		dw	NOT_USED		; 17
		dw	NOT_USED		; 18
		dw	w_bold_on		; 19 (Enable highlighting)
		dw	w_bold_off		; 20 (Disable highlighting)	
		dw	NOT_USED		; 21		
		dw	NOT_USED		; 22
		dw	NOT_USED		; 23
		;dw	w_bg_hli		; 24 (Enable BG highligting & blinking)
		;dw	w_fg_hli		; 25 (Enable FG highligting & blinking)	
		dw	NOT_USED		; 24
		dw	NOT_USED		; 25
		dw	w_put_char		; 26
		dw	w_put_char		; 27
		dw	w_put_char		; 28
		dw	w_put_char		; 29
		dw	w_put_char		; 30
		dw	NOT_USED		; 31
nothing:
		dw	NOT_USED		; 32

; ----------------------------------------------------------------------------

w_clear_screen:		; Clear (all) screen
		call	clear_screen
		jmp	short w_get_char

; ----------------------------------------------------------------------------

w_blank_row:		; Clear screen row
		call	blank_row
		jmp	short w_get_char

; ----------------------------------------------------------------------------

w_cls_down:		; Clear screen from the requested row to down
		call	clear_screen_down
		jmp	short w_get_char

; ----------------------------------------------------------------------------

w_set_cpos:		;  Set cursor position
			; (following bytes are for cursor row and column)
		lodsw
		mov	dx, ax ; DL = row, DH = column
		call	set_cursor_position
		jmp	short w_get_char

; ----------------------------------------------------------------------------

w_char_indirect:	; Write character in the following address
		lodsw
		mov	bx,ax
		mov	al,[bx]
		jmp	w_put_char

; ----------------------------------------------------------------------------

w_byte_out:		; Write (byte) hex number in the following address
		lodsw
		mov	bx,ax
		mov	al,[bx]
		call	conv_byte_out
		jmp	w_get_char

; ----------------------------------------------------------------------------

;w_word_out:	; Write (word) hex number in the following address
		;lodsw
		;mov	bx,ax
		;mov	ax,[bx]
		;call	put_word
		;jmp	w_get_char

; ----------------------------------------------------------------------------

w_decimal_number:	; Write
		lodsw
		mov	bx,ax
		mov	ax,[bx]

		;call	convert_to_decimal
		;jmp	w_get_char

		mov	bx,10000 ; Divisor (proper for 5 digits, <= 65535)	
		mov	cl,0	; Leading zero must not be written
		call	write_digits
		jmp	w_get_char

; ----------------------------------------------------------------------------

w_comp_num_skip_nz:
		lodsw
		mov	bx,ax
		lodsb
		cmp	al,[bx]
		jnz	short skip_text
		jmp	w_get_char

; ----------------------------------------------------------------------------

w_comp_num_skip_z:
		lodsw
		mov	bx,ax
		lodsb
		cmp	al,[bx]
		jz	short skip_text
		jmp	w_get_char

; ----------------------------------------------------------------------------

skip_text:
		lodsb
		cmp	al,0Fh
		jnz	short skip_text
		jmp	w_get_char

; ----------------------------------------------------------------------------

;w_blink_on:
		;call	blink_on
		;jmp	w_get_char

; ----------------------------------------------------------------------------

;w_blink_off:
		;call	blink_off
		;jmp	w_get_char

; ----------------------------------------------------------------------------

w_bold_on:
		call	hli_on
		jmp	w_get_char

; ----------------------------------------------------------------------------

w_bold_off:
		call	hli_off
		jmp	w_get_char

; ----------------------------------------------------------------------------

;w_bg_hli:
		;call	bg_hli_blink_on
		;jmp	w_get_char

; ----------------------------------------------------------------------------

;w_fg_hli:
		;call	fg_hli_blink_on
		;jmp	w_get_char

; ----------------------------------------------------------------------------

;convert_to_decimal:
;		; Convert number (in AX) to decimal number digits/chars
;		; and write them out (on screen at current cursor position)
;
;		pushf
;		push	ax
;		push	bx
;		push	cx
;		push	dx
;		push	bp
;		push	si
;		push	di
;		push	ds
;		push	es
;		mov	bx,10000 ; Divisor (proper for 5 digits, <= 65535)	
;		mov	cl,0	; Leading zero must not be written
;cnvtodec1:
;		push	ax
;		xor	dx,dx
;		div	bx
;		;cmp	cl,0FEh ; -2
;		;jnz	short cnvtodec2
;		;cmp	al,0
;		;jnz	short cnvtodec3
;		;jmp	short cnvtodec4
;cnvtodec2:
;		cmp	al,cl
;		jne	short cnvtodec3 ; write if it is not a leading zero
;			; Blank leading zeros (use space instead of '0')
;		push	ax
;		mov	al,20h	; space/blank
;		call	chr_out
;		pop	ax
;		jmp	short cnvtodec4
;cnvtodec3:
;		add	al,'0'	 ; Convert to digit character as '0' to '9'
;		call	chr_out
;		sub	al,'0'	 ; Convert back to single digit number again
;		mov	cl,0FFh ; -1 ; Write zeros -'0'- now on
;cnvtodec4:
;		mul	bx	; multiply the qoutient with BX
;		mov	dx,ax	; this is a number with multiplies of BX
;		pop	ax 	; restore the num at the beginning of this proc	
;		sub	ax,dx	; get difference (< the divisor in BX)
;		push	ax	; save it
;		mov	ax,bx	; Divide the divisor by 10
;		mov	bx,10
;		xor	dx,dx
;		div	bx
;		mov	bx,ax	; save the new divisor in bx
;		pop	ax	; restore difference (for previous divisor)
;		cmp	bx,1	; If the new divisor > 1 (may be 10,100,1000)
;		ja	short cnvtodec1 ; repeat this procedure for the new digit
;		mov	cl,0FFh ; -1 ; Write zeros -'0'- now on
;		cmp	bx,0
;		jnz	short cnvtodec1 ; If the quotient is not ZERO
;				  ; repeat this procedure for the next digit
;				  ;( a '0' will be written at its position)
;		pop	es
;		pop	ds
;		pop	di
;		pop	si
;		pop	bp
;		pop	dx
;		pop	cx
;		pop	bx
;		pop	ax
;		popf
;		retn

; ----------------------------------------------------------------------------

;put_word:	; Write word in AX (as hexadecimal number)
		;push	ax
		;mov	al,ah ; Write high byte of AX	
		;call	conv_byte_out
		;pop	ax
			      ; Write low byte of AX	

; ----------------------------------------------------------------------------

conv_byte_out:	; Write byte in AL (as hexadecimal number)
		push	ax  ; Save AL (AX)
			; Move/Shift high 4 bits of AL to low 4 bits
		shr	ax,1
		shr	ax,1
		shr	ax,1
		shr	ax,1
			; Write high 4 bits of AL (as low 4 bits of AL)
		call	bin_to_digit
		pop	ax  ; Restore AL (AX)
			; Write low 4 bits of AL

; ----------------------------------------------------------------------------

bin_to_digit:	; Convert low 4 bits of AL to hex digits ('0'..'F')
		and	al,0Fh
		add	al,'0'
		cmp	al,'9'
		jbe	short btd_retn
		add	al,'7' ; 'A' to 'F'
btd_retn:
		;call	chr_out
		;retn

; ----------------------------------------------------------------------------

chr_out:	; Write character on screen (AX is preserved)
		push	ax
		call	write_character	; Write char on screen (via int 10h)
		pop	ax
chr_out_retn:
		retn

; ----------------------------------------------------------------------------

opnum:		db	0
selected_opnum:	db	0

; ----------------------------------------------------------------------------

select_option_number:	; Select menu option
			;    (waits input as number or ESC for cancel/return)
		mov	[opnum],al
		;jmp	short sopnum2
sopnum1:
		mov	al,[opnum]
sopnum2:
		mov	[selected_opnum],al
		call	write_character
		mov	al,8  ; Backspace (move cursor back)
		call	write_character
sopnum3:
		call	getchar
		and	al,7Fh ; ASCII 0-7Fh
		cmp	al,0Dh ; CR   ; Carriage Return (ENTER) key	
		je	short sopnum5 ; means selected option will be applied
		cmp	al,8   ; BS	
		je	short sopnum1
		cmp	al,7Fh ; DEL
		je	short sopnum1
		cmp	al,1Bh ; ESC
		je	short sopnum4
		cmp	al,20h ; SPC
		jb	short sopnum3
		jmp	short sopnum2
sopnum4:
		mov	byte [selected_opnum],1Bh ; ESC (cancel)
sopnum5:
		mov	al,[selected_opnum] ; selected option
		retn

; ----------------------------------------------------------------------------

strtnumber:	dw	0
maxdigits:	db	0
inputdigits:	db	0
input_numcalc:	dw	0
input_chr:	db	0

; ----------------------------------------------------------------------------

get_and_write_number: 
		; Get a number via keyboard inputs and write its digits
		; AX = default/beginning value, CL = max. number of digits	
		mov	[strtnumber],ax
		mov	[input_numcalc],ax
		mov	[maxdigits],cl
		mov	byte [inputdigits], 0
wnum1:
		mov	dx,last_digit  ; the last (possible) digit address
		mov	al,[maxdigits]
		cbw
		sub	dx,ax
		inc	dx ; DX = start address of (the number) digits
		call	write_on_screen ; Write default val/num at first
		mov	ax,1
		mov	cl,[maxdigits]
		dec	cl
		jcxz	wnum3
wnum2:
		mov	bl,10
		mul	bl
		loop	wnum2
wnum3:
		mov	bx,ax
		;mov	cx,0 ; CL/CX is already ZERO !
		mov	ax,[input_numcalc]
		call	write_digits
		mov	al,8
		call	write_character
wnum4:
		call	getchar
		mov	bx,input_type_tbl
		mov	[input_chr],al
		call	input_type_function
		mov	dx,beep3
		call	write_on_screen
		jmp	short wnum4

; ----------------------------------------------------------------------------

input_type_tbl:	; Function table for (user) input number digits
		; CR, DEL, BS, ESC chars
		; (the 1st character is a digit or function char
		; and following word is the function address for it.)

		db	'0' 
		dw	number_input
		db	'1'
		dw	number_input
		db	'2'
		dw	number_input
		db	'3'
		dw	number_input
		db	'4'
		dw	number_input
		db	'5'
		dw	number_input
		db	'6'
		dw	number_input
		db	'7'
		dw	number_input
		db	'8'
		dw	number_input
		db	'9'
		dw	number_input
		db	0Dh
		dw	cr_input
		db	8
		dw	back_space_input
		db	7Fh
		dw	back_space_input
		db	1Bh
		dw	esc_key_input
		db	0

; ----------------------------------------------------------------------------

number_input:
		; Get/Build a number via keyboard inputs and write its digits
		; [maxdigits] = max. number of digits
		; [inputdigits] = count of input number digits before this one
		; [input_chr] = the last digit character ('0' to '9') 		

		mov	bl,[maxdigits]
		cmp	bl,[inputdigits]
		je	short numinput2
		mov	al,[input_chr]
		sub	al,'0'
		cbw
		mov	bx,ax
		mov	ax,[input_numcalc]
		cmp	byte [inputdigits],0
		jne	short numinput1  ; If previous count of input digits
				         ; is not 0, current value of
				         ; [input_numcalc] is multiplied by 10
		xor	ax,ax
numinput1:
		mov	cx,10
		mul	cx
		add	ax,bx	    ; add the value of current digit (input)
		jc	short numinput2	; number exceeds 65535, retry
		cmp	dx,0
		jne	short numinput2 ; number exceeds 65535, retry
		mov	[input_numcalc],ax ; recent value of the input number
		inc	byte [inputdigits] ; +1 digit
numinput2:
		jmp	wnum1

; ----------------------------------------------------------------------------

cr_input:	; Carriage return (Enter key) completes number digits input
		mov	ax,[input_numcalc] ; calculated input number
		clc
		retn

; ----------------------------------------------------------------------------

esc_key_input:	; ESC key/char (1Bh) cancels number (digits) input
		stc
		retn

; ----------------------------------------------------------------------------

back_space_input: 
		; Backspace (BS or DEL key) char deletes the last digit
		; (the value of the number input will be changed to previous)
		cmp	byte [inputdigits],0 ; is there number input by user
		je	short bsi_ok	     ; no, return to redo (wnum1)	
		mov	ax,[input_numcalc]   ; yes, use it (previous number)	
		xor	dx,dx
		mov	cx,10		     ; divide number by	10 
		div	cx		     ; to remove the last digit and 
		mov	[input_numcalc],ax   ; (so) recalculate the number		
		dec	byte [inputdigits]   ; (last digit has been removed)	 
		jnz	short bsi_ok ; (there is an input num at least with 1 digit)
		mov	ax,[strtnumber] ; restore default/beginning number
		mov	[input_numcalc],ax  ; if there is not an input number  
bsi_ok:
		jmp	wnum1	; return to redo (try again till a CR or ESC)

; ----------------------------------------------------------------------------

number_digits:	; Space for 11 digits (for number input by the user)
		times	10 db 08h

last_digit:	db	0

; ----------------------------------------------------------------------------

write_digits:	; Write/Display digits of the number in AX -max. 5 digits-
		; BX = divisor (10,100,1000,10000)
		; (Decimal number will be written at current cursor position.)
		; CL = 0 (for wd2:) if the leading zero will not be written.

		pushf
		push	ax
		push	bx
		push	cx
		push	dx
		push	bp
		push	si
		push	di
		push	ds
		push	es
wd1:
		push	ax
		xor	dx,dx
		div	bx
		;cmp	cl,-2 ; 0FEh
		;jnz	short wd2
		;cmp	al,0
		;jnz	short wd3
		;jmp	short wd4
wd2:
		cmp	al,cl
		jne	short wd3 ; write digit -if it is not a leading zero-
			; AL=0 & CL=0, write blank/space instead of zero
		push	ax
		mov	al,20h ; space/blank
		call	write_character
		pop	ax
		jmp	short wd4
wd3:
		add	al,'0'  ; Convert to digit character as '0' to '9'
		call	write_character
		sub	al,'0'  ; Convert back to single digit number again
		mov	cl,-1 ; 0FFh ; next zero(s) -'0'- will be written
wd4:
		mul	bx	; multiply the qoutient with BX
		mov	dx,ax	; this is a number with multiplies of BX
		pop	ax 	; restore the num at the beginning of this proc	
		sub	ax,dx	; get difference (< the divisor in BX)
		push	ax	; save it
		mov	ax,bx	; Divide the divisor by 10
		mov	bx,10
		xor	dx,dx
		div	bx
		mov	bx,ax	; save the new divisor in bx
		pop	ax	; restore difference (for previous divisor)
		cmp	bx,1	  ; If the new divisor > 1 (may be 10,100,1000)
		ja	short wd1 ; repeat this procedure for the new digit
				
		mov	cl,-1 ; 0FFh ; next zero(s) -'0'- will be written
		cmp	bx,0
		jne	short wd1 ; If the quotient is not ZERO
				  ; repeat this procedure for the next digit
				  ;( a '0' will be written at its position)
		pop	es
		pop	ds
		pop	di
		pop	si
		pop	bp
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		popf
		retn

; ----------------------------------------------------------------------------

getchar:	; Get a character from keyboard buffer (or getchar from STDIN)
		mov	ah,7
		int	21h	; DOS -	DIRECT STDIN INPUT, NO ECHO
		retn

; ----------------------------------------------------------------------------

input_type_function: ; Function table for character/number/digit input(s)
		; If AL>0 and AL=[BX], jump the routine in [BX+2] 
		cmp	byte [bx],0
		je	short cit_retn
		cmp	al,[bx]
		je	short cit_ok ; same char
		; check the next character in the table
		; (every function has 1+2 -char+pointer- bytes in the table)
		inc	bx
		inc	bx
		inc	bx
		jmp	short input_type_function
cit_ok:
		inc	bx
		mov	ax,[bx] ; get function address (as offset)
		pop	bx
		push	ax
cit_retn:
		retn

; ----------------------------------------------------------------------------

chr_attributes:	db	07h    ; Default (start) attrib of chars to be written

; ----------------------------------------------------------------------------

write_character:	; Write ASCII character (in AL) by using int 10h (wtty)	
		cmp	al,20h
		jb	short wtty

		push	ax
		push	bx
		push	cx
		push	dx
		push	bp
		mov	ah,9
		xor	bh,bh
		mov	bl,[chr_attributes] ; Character attributes to be applied
		mov	cx,1
		int	10h	; - VIDEO - WRITE ATTRIBUTES/CHARACTERS	AT CURSOR POSITION
				;  AL = character, BH = display page
				;  BL = attributes of character (alpha modes) 
				; 	or color (graphics modes)
				;  CX = number of times to write character
		mov	ah,3
		int	10h	; - VIDEO - READ CURSOR	POSITION
				; BH = page number
				; Return: DH,DL	= row,column, 
				;	  CH = cursor start line, CL = cursor end line
		inc	dl
		cmp	dl,80
		jb	short set_cpos
		xor	dl,dl
		inc	dh
		cmp	dh,24
		jb	short set_cpos
		xor	dh, dh
set_cpos:
		mov	ah,2
		int	10h

		pop	bp
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		retn

; ----------------------------------------------------------------------------

wtty:			; tty write (write character and advance cursor)
		push	ax
		push	bx
		push	bp
		mov	ah,0Eh
		xor	bl,bl
		int	10h	; - VIDEO - WRITE CHARACTER AND	ADVANCE	CURSOR (TTY WRITE)
				; AL = character, BH = display page (alpha modes)
				; BL = foreground color	(graphics modes)
		pop	bp
		pop	bx
		pop	ax
		retn

; ----------------------------------------------------------------------------

;write_dos_string: 	; Write DOS string at the addr in DX (end char = '$')
		;push	ax
		;push	si
		;mov	si,dx
;wds_next_char:
		;lodsb
		;cmp	al,'$'
		;je	short wds_retn
		;call	write_character
		;jmp	short wds_next_char
wds_retn:
		;pop	si
		;pop	ax
		;retn

; ----------------------------------------------------------------------------

clear_screen:	; Clear (current) video page (screen)
		; (and set cursor pos. to left-top corner of the page/screen)
		xor	cx,cx
		mov	dh,24
		mov	dl,80
		mov	bh,[chr_attributes]
		mov	al,0
		mov	ah,6
		int	10h	; - VIDEO - SCROLL PAGE	UP
				; AL = number of lines to scroll window	
				;		(0 = blank whole window)
				; BH = attributes to be	used on	blanked	lines
				; CH,CL	= row,column of	upper left corner of window to scroll
				; DH,DL	= row,column of	lower right corner of window
		xor	dx,dx
		xor	bh,bh
		mov	ah,2
		int	10h	; - VIDEO - SET	CURSOR POSITION
				; DH,DL	= row, column (0,0 = upper left)
				; BH = page number
		retn

; ----------------------------------------------------------------------------

clear_row:
	     ; Clear (current) screen/page row by filling spaces (blank chars) 
blank_row:
		mov	al,20h  ; ASCII code of the space (blank) character
		mov	ah,9	
		xor	bh,bh	; Video page 0 - FDISK uses default video page only! 
		mov	bl,[chr_attributes]  ; current character attributes
		mov	cx,80 ; Video mode 3 - 80 characters per row
		int	10h	; - VIDEO - WRITE ATTRIBUTES/CHARACTERS	AT CURSOR POSITION
				;  AL = character, BH = display page
				;  BL = attributes of character (alpha modes) 
				;	or color (graphics modes)
				;  CX = number of times to write character
		retn

; ----------------------------------------------------------------------------

clear_screen_down:
		; Clear (current) screen/page rows (via INT 10h scroll method) 
		; from the next of current row, to down.
		; (Example: If curr. row is 10, row 11 to 24 will be cleared.) 

		call	blank_row
		mov	ah,3
		int	10h	; - VIDEO - READ CURSOR	POSITION
				; BH = page number
				; Return: DH,DL	= row,column,
				;   CH = cursor start line, CL = cursor end line
		cmp	dh,24
		je	short csd_retn
		mov	ch,dh
		inc	ch
		xor	cl,cl
		mov	dh,24
		mov	dl,80
		mov	bh,7
		mov	al,0
		mov	ah,6
		int	10h	; - VIDEO - SCROLL PAGE	UP
				; AL = number of lines to scroll window	
				;		(0 = blank whole window)
				; BH = attributes to be	used on	blanked	lines
				; CH,CL	= row,column of	upper left corner of window to scroll
				; DH,DL	= row,column of	lower right corner of window
csd_retn:
		retn

; ----------------------------------------------------------------------------

;blink_on:	; Enable character blinking 
		;or	byte [chr_attributes],80h
		;retn

; ----------------------------------------------------------------------------

;blink_off:	; Disable character blinking 
		;and	byte [chr_attributes],7Fh
		;retn

; ----------------------------------------------------------------------------

hli_on:		; Enable character highlighting 
		or	byte [chr_attributes],08h
		retn

; ----------------------------------------------------------------------------

hli_off:	; Disable character highlighting 
		and	byte [chr_attributes],0F7h
		retn

; ----------------------------------------------------------------------------

;bg_hli_blink_on: ; Enable character background highlighting & blinking
		;and	byte [chr_attributes],88h
		;or	byte [chr_attributes],70h
		;retn

; ----------------------------------------------------------------------------

;fg_hli_blink_on: ; Enable char. foreground/color highlighting & blinking
		;and	byte [chr_attributes],88h
		;or	byte [chr_attributes],07h
		;retn

; ----------------------------------------------------------------------------

set_cursor_position:	; Set cursor position on the default video page
		mov	bh,0  ; Video page 0 - Default video page for FDISK	
		mov	ah,2
		int	10h	; - VIDEO - SET	CURSOR POSITION
				; DH,DL	= row, column (0,0 = upper left)
				; BH = page number
		retn

; ============================================================================

_61Dh	equ	600h+mbr0-MBR
_6BDh	equ	600h+mbr_err3-MBR
_69Eh 	equ	600h+mbr_err2-MBR	 
_685h 	equ	600h+mbr_err1-MBR

align 2
	
; ----------------------------------------------------------------------------

MBR:		; FDISK (1983/1985) - Master Boot Record/Sector (for MSDOS)
	
		; Setup segment registers and stack, then
		; Move masterboot sector to 0:600h, before
		; loading the active partition's boot sector at 0:7C00h.

		xor	ax,ax
		cli
		mov	ss,ax
		mov	sp,7C00h
		mov	es,ax
		mov	ds,ax
		sti
		mov	si,sp
		mov	di,600h 
		mov	cx,512
		cld
		rep movsb

		jmp	0:_61Dh

; ----------------------------------------------------------------------------

mbr0:		mov	al, 4
		mov	si,600h+1BEh ; 7BEh ; Partition Table offset
mbr1:
		; Check for active partition
		cmp	byte [si],80h ; is there an active partition ?
		je	short mbr2 ; yes, launch it (if it is single active)
		add	si,10h
		dec	al
		jnz	short mbr1
		mov	si,_6BDh ; mbr_err3 : 'Invalid partition table'	
		jmp	short mbr8
mbr2:
		; Check for another active partition (error!)
		mov	di,si
		mov	dx,[si]
		mov	cx,[si+2]
mbr3:
		add	si,10h
		dec	al
		jz	short mbr4
		cmp	byte [si],80h
		jne	short mbr3
		mov	si,_6BDh ; mbr_err3 : 'Invalid partition table'		
		jmp	short mbr8
mbr4:
		mov	bp,5	; Retry count
mbr5:
		mov	bx,7C00h
		mov	ax,201h
		int	13h	; DISK - READ SECTORS INTO MEMORY
				; AL = number of sectors to read,
				; CH = track, CL = sector
				; DH = head, DL	= drive, ES:BX -> buffer to fill
				; Return: CF set on error, 
				;	AH = status, AL = number of sectors read
		jnc	short mbr6
		xor	ax,ax
		int	13h	; DISK - RESET DISK SYSTEM
				; DL = drive (if bit 7 is set 
				;	 both hard disks and floppy disks reset)
		dec	bp
		jnz	short mbr5 ; Retry
		mov	si,_69Eh ; mbr_err2 : 'Error loading operating system'
		jmp	short mbr8 ; Write/Display error message and hang!
mbr6:
		; If Boot Sector offset 510 does not contain a 0AA55h (signature)
		; it is not a valid boot sector (code).
		cmp	word [7DFEh],0AA55h
		jnz	short mbr7
			; Valid (DOS) boot sector code, let's run it.
		mov	si,di
		jmp	0:7C00h ; Jump to start address of the loaded boot sector
mbr7:
		mov	si,_685h ; mbr_err1 : 'Missing operating system'	
mbr8: 		; Write Error Message
		cs
		lodsb	
		or	al,al
		jz	short mbr9
		mov	ah,0Eh
		int	10h	; - VIDEO - WRITE CHARACTER AND	ADVANCE	CURSOR (TTY WRITE)
				; AL = character, BH = display page (alpha modes)
				; BL = foreground color	(graphics modes)
		jmp	short mbr8
mbr9:
		sti	; Enable interrupts during the infinitive loop
mbr10:
		jmp	short mbr10  ; hang! infinive loop till restart/reset
; ----------------------------------------------------------------------------
mbr_err:
mbr_err1:	db	'Missing operating system',0
mbr_err2:	db	'Error loading operating system',0
mbr_err3:	db	'Invalid partition table',0
mbr_author:	db	'Author - Siegmar Schmidt',0  ; 1983 ? (writer of this MBR)
		;times	110h db 0
		times	(MBR+510)-$ db 0
		dw	0AA55h
;end_of_file:
		dw	01A1h ; The signature by Erdogan Tan
end_of_file:	dw	2018  ; Year 2018, Istanbul, Turkiye	