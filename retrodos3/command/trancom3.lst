     1                                  ; TRANSIENT PART OF COMMAND.COM
     2                                  ; ****************************************************************************
     3                                  ; COMMAND.COM (MSDOS 3.3 Command Interpreter) - RETRO DOS v3.0 by ERDOGAN TAN
     4                                  ; ----------------------------------------------------------------------------
     5                                  ; Last Update: 02/03/2023 ((Prev: 20/10/2018))
     6                                  ; ----------------------------------------------------------------------------
     7                                  ; Beginning: 21/04/2018 (COMMAND.COM v2.11) - 11/09/2018 (COMMAND.COM v3.30)
     8                                  ; ----------------------------------------------------------------------------
     9                                  ; Assembler: NASM version 2.11  
    10                                  ; ----------------------------------------------------------------------------
    11                                  ;	    ((nasm command3.s -l command3.lst -o COMMAND.COM)) 	
    12                                  ; ----------------------------------------------------------------------------
    13                                  ; Derived from 'COMMAND.ASM' file of MSDOS 2.11 (IBM PCDOS v2.11) source code
    14                                  ; by Microsoft, 18/08/1983
    15                                  ; ****************************************************************************
    16                                  ; Modified from 'COMMAND2.S' (MSDOS 2.11 COMMAND.COM) source code
    17                                  ; in NASM syntax (by Erdogan Tan), 05/05/2018
    18                                  ; ----------------------------------------------------------------------------
    19                                  ;; 11/09/2018 - Erdogan Tan
    20                                  ; (Note: I haven't got MSDOS 3.3 COMMAND.COM src files; so, I need to continue
    21                                  ; by using disassembled COMMAND.COM -v3.30- and MSDOS 6.0 OS source files.)
    22                                  ; ----------------------------------------------------------------------------
    23                                  ; MSDOS 6.0 source files:
    24                                  ;;============================================================================
    25                                  ; This MSDOS source code is verified & modified by using IDA Pro Disassembler
    26                                  ; (MSDOS 3.30 COMMAND.COM) output in TASM syntax (11/09/2018..29/09/2018)
    27                                  ;;============================================================================
    28                                  ;
    29                                  ; COMMAND.COM v6.0 source files:
    30                                  ;      command1.asm, command2.asm, rucode.asm, stub.asm, rdata.asm, init.asm,
    31                                  ;      iparse.asm, uinit.asm, tcode.asm, tbatch.asm, tbatch2.asm, tfor.asm,
    32                                  ;      dir.asm, cratio.asm, tcmd1b.asm, tcmd2a.asm, tcmd2b.asm, tenv.asm,
    33                                  ;      tenv2.asm, tmisc1.asm, tmisc2.asm, tpipe.asm, parse2.asm, path1.asm,
    34                                  ;      path2.asm, tucode.asm, copy.asm, copypr1.asm, copypr2.asm, cparse.asm,
    35                                  ;      tparse.asm, tprintf.asm, loadhi.asm, tdata.asm, tspc.asm
    36                                  ;
    37                                  ; COMMAND.COM v2.11 source files:
    38                                  ;      COMMAND.ASM (+ DOSYM.ASM,DEVSYM.ASM,COMSW.ASM,COMEQU.ASM,IFEQU.ASM)
    39                                  ;      RUCODE.ASM, RDATA.ASM, INIT.ASM, UINIT.ASM
    40                                  ;      TCODE.ASM, TCODE2.ASM, TCODE3.ASM, TCODE4.ASM, TCODE5.ASM,
    41                                  ;      TUCODE.ASM, COPY.ASM, COPYPROC.ASM, CPARSE.ASM, TDATA.ASM, TSPC.ASM
    42                                  ;
    43                                  
    44                                  ; ***************************************************************************
    45                                  ; *	This file is generated by The Interactive Disassembler (IDA)	    *
    46                                  ; *	Copyright (c) 2010 by Hex-Rays SA,<support@hex-rays.com>	    *
    47                                  ; *			 Licensed to: Freeware version			    *
    48                                  ; ***************************************************************************
    49                                  ;
    50                                  ; Input	MD5   :	4A83EECE0CFAF68D62F627D71F5D1FAF
    51                                  
    52                                  ; File Name   :	D:\Documents and Settings\Erdoðan Tan\Desktop\command3t.bin
    53                                  ; Format      :	Binary file
    54                                  ; Base Address:	0000h Range: 0000h - 4D5Ch Loaded length: 4D5Ch
    55                                  
    56                                  ; ***************************************************************************
    57                                  
    58                                  ; (command3.s -> COMTRANS: INCBIN "TRANCOM3.BIN") ; 24/09/2018
    59                                  
    60                                  ; ----------------------------------------------------------------------------
    61                                  ;	    ((nasm trancom3.s -l trancom3.lst -o TRANCOM3.BIN)) 	
    62                                  ; ----------------------------------------------------------------------------
    63                                  
    64                                  ;============================================================================
    65                                  ; SYSCALL.INC, MSDOS 6.0, 1991
    66                                  ;============================================================================
    67                                  ; 21/09/2018 - Retro DOS v3.0
    68                                  
    69                                  ;	SCCSID = @(#)syscall.asm	1.1 85/04/10
    70                                  ;BREAK <system call definitions>
    71                                  
    72                                  ;
    73                                  ;	Microsoft Confidential
    74                                  ;	Copyright (C) Microsoft Corporation 1991
    75                                  ;	All Rights Reserved.
    76                                  ;
    77                                  
    78                                  ;SUBTTL	system call definitions
    79                                  ;PAGE
    80                                  
    81                                  Abort				EQU 0	;  0	  0
    82                                  STD_CON_INPUT			EQU 1	;  1	  1
    83                                  Std_Con_Output			EQU 2	;  2	  2
    84                                  Std_Aux_Input			EQU 3	;  3	  3
    85                                  Std_Aux_Output			EQU 4	;  4	  4
    86                                  Std_Printer_Output		EQU 5	;  5	  5
    87                                  RAW_CON_IO			EQU 6	;  6	  6
    88                                  RAW_CON_INPUT			EQU 7	;  7	  7
    89                                  STD_CON_INPUT_NO_ECHO		EQU 8	;  8	  8
    90                                  STD_CON_STRING_OUTPUT		EQU 9	;  9	  9
    91                                  STD_CON_STRING_INPUT		EQU 10	; 10	  A
    92                                  Std_Con_Input_Status		EQU 11	; 11	  B
    93                                  STD_CON_INPUT_FLUSH		EQU 12	; 12	  C
    94                                  DISK_RESET			EQU 13	; 13	  D
    95                                  SET_DEFAULT_DRIVE		EQU 14	; 14	  E
    96                                  FCB_Open			EQU 15	; 15	  F
    97                                  FCB_Close			EQU 16	; 16	 10
    98                                  DIR_SEARCH_FIRST		EQU 17	; 17	 11
    99                                  DIR_SEARCH_NEXT 		EQU 18	; 18	 12
   100                                  FCB_DELETE			EQU 19	; 19	 13
   101                                  FCB_Seq_Read			EQU 20	; 20	 14
   102                                  FCB_Seq_Write			EQU 21	; 21	 15
   103                                  FCB_Create			EQU 22	; 22	 16
   104                                  FCB_RENAME			EQU 23	; 23	 17
   105                                  GET_DEFAULT_DRIVE		EQU 25	; 25	 19
   106                                  SET_DMA 			EQU 26	; 26	 1A
   107                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   108                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   109                                  ;									   ;
   110                                  Get_Default_DPB 		EQU 31	; 31	 1F
   111                                  ;									   ;
   112                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   113                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   114                                  FCB_Random_Read 		EQU 33	; 33	 21
   115                                  FCB_Random_Write		EQU 34	; 34	 22
   116                                  Get_FCB_File_Length		EQU 35	; 35	 23
   117                                  Get_FCB_Position		EQU 36	; 36	 24
   118                                  SET_INTERRUPT_VECTOR		EQU 37	; 37	 25
   119                                  Create_Process_Data_Block	EQU 38	; 38	 26
   120                                  FCB_Random_Read_Block		EQU 39	; 39	 27
   121                                  FCB_Random_Write_Block		EQU 40	; 40	 28
   122                                  PARSE_FILE_DESCRIPTOR		EQU 41	; 41	 29
   123                                  GET_DATE			EQU 42	; 42	 2A
   124                                  SET_DATE			EQU 43	; 43	 2B
   125                                  GET_TIME			EQU 44	; 44	 2C
   126                                  SET_TIME			EQU 45	; 45	 2D
   127                                  SET_VERIFY_ON_WRITE		EQU 46	; 46	 2E
   128                                  ; Extended functionality group
   129                                  Get_DMA 			EQU 47	; 47	 2F
   130                                  GET_VERSION			EQU 48	; 48	 30
   131                                  Keep_Process			EQU 49	; 49	 31
   132                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   133                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   134                                  ;									   ;
   135                                  Get_DPB 			EQU 50	; 50	 32
   136                                  ;									   ;
   137                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   138                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   139                                  SET_CTRL_C_TRAPPING		EQU 51	; 51	 33
   140                                  Get_InDOS_Flag			EQU 52	; 52	 34
   141                                  GET_INTERRUPT_VECTOR		EQU 53	; 53	 35
   142                                  GET_DRIVE_FREESPACE		EQU 54	; 54	 36
   143                                  CHAR_OPER			EQU 55	; 55	 37
   144                                  INTERNATIONAL			EQU 56	; 56	 38
   145                                  ;   Directory Group
   146                                  MKDIR				EQU 57	; 57	 39
   147                                  RMDIR				EQU 58	; 58	 3A
   148                                  CHDIR				EQU 59	; 59	 3B
   149                                  ;   File Group
   150                                  CREAT				EQU 60	; 60	 3C
   151                                  OPEN				EQU 61	; 61	 3D
   152                                  CLOSE				EQU 62	; 62	 3E
   153                                  READ				EQU 63	; 63	 3F
   154                                  WRITE				EQU 64	; 64	 40
   155                                  UNLINK				EQU 65	; 65	 41
   156                                  LSEEK				EQU 66	; 66	 42
   157                                  CHMod				EQU 67	; 67	 43
   158                                  IOCTL				EQU 68	; 68	 44
   159                                  XDUP				EQU 69	; 69	 45
   160                                  XDup2				EQU 70	; 70	 46
   161                                  CURRENT_DIR			EQU 71	; 71	 47
   162                                  ;    Memory Group
   163                                  ALLOC				EQU 72	; 72	 48
   164                                  DEALLOC				EQU 73	; 73	 49
   165                                  SETBLOCK			EQU 74	; 74	 4A
   166                                  ;    Process Group
   167                                  EXEC				EQU 75	; 75	 4B
   168                                  EXIT				EQU 76	; 76	 4C
   169                                  WAITPROCESS			EQU 77	; 77	 4D
   170                                  FIND_FIRST			EQU 78	; 78	 4E
   171                                  ;   Special Group
   172                                  FIND_NEXT			EQU 79	; 79	 4F
   173                                  ; SPECIAL SYSTEM GROUP
   174                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   175                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   176                                  ;									   ;
   177                                  SET_CURRENT_PDB 		EQU 80	; 80	 50
   178                                  GET_CURRENT_PDB 		EQU 81	; 81	 51
   179                                  Get_In_Vars			EQU 82	; 82	 52
   180                                  SetDPB				EQU 83	; 83	 53
   181                                  ;									   ;
   182                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   183                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   184                                  GET_VERIFY_ON_WRITE		EQU 84	; 84	 54
   185                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   186                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   187                                  ;									   ;
   188                                  DUP_PDB 			EQU 85	; 85	 55
   189                                  ;									   ;
   190                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   191                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   192                                  Rename				EQU 86	; 86	 56
   193                                  FILE_TIMES			EQU 87	; 87	 57
   194                                  AllocOper			EQU 88	; 88	 58
   195                                  ; Network extention system calls
   196                                  GETEXTENDEDERROR		EQU 89	; 89	 59
   197                                  CREATETEMPFILE			EQU 90	; 90	 5A
   198                                  CreateNewFile			EQU 91	; 91	 5B
   199                                  LockOper			EQU 92	; 92	 5C Lock and Unlock
   200                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   201                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   202                                  ;									   ;
   203                                  SERVERCALL			EQU 93	; 93	 5D CommitAll, ServerDOSCall,
   204                                  					;	    CloseByName, CloseUser,
   205                                  					;	    CloseUserProcess,
   206                                  					;	    GetOpenFileList
   207                                  ;									   ;
   208                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   209                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   210                                  UserOper			EQU 94	; 94	 5E Get and Set
   211                                  AssignOper			EQU 95	; 95	 5F On, Off, Get, Set, Cancel
   212                                  XNAMETRANS			EQU 96	; 96	 60
   213                                  PathParse			EQU 97	; 97	 61
   214                                  GetCurrentPSP			EQU 98	; 98	 62
   215                                  Hongeul 			EQU 99	; 99	 63
   216                                  ECS_CALL			EQU 99	; 99	 63  ;; DBCS support
   217                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   218                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   219                                  ;									   ;
   220                                  Set_Printer_Flag		EQU 100 ; 100	 64
   221                                  ;									   ;
   222                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   223                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   224                                  GetExtCntry			EQU 101 ; 101	 65
   225                                  GETSETCDPG			EQU 102 ; 102	 66
   226                                  ExtHandle			EQU 103 ; 103	 67
   227                                  Commit				EQU 104 ; 104	 68
   228                                  GetSetMediaID			EQU 105 ; 105	 69
   229                                  IFS_IOCTL			EQU 107 ; 107	 6B
   230                                  ExtOpen 			EQU 108 ; 108	 6C
   231                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   232                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   233                                  ;                                                                          ;
   234                                  ;ifdef ROMEXEC
   235                                  ;ROM_FIND_FIRST			EQU 109 ; 109    6D
   236                                  ;ROM_FIND_NEXT			EQU 110 ; 110    6E
   237                                  ;ROM_EXCLUDE			EQU 111 ; 111	 6F			; M035
   238                                  ;endif
   239                                  ;                                                                          ;
   240                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   241                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   242                                  ;
   243                                  ;
   244                                  Set_Oem_Handler 		EQU 248 ; 248	 F8
   245                                  OEM_C1				EQU 249 ; 249	 F9
   246                                  OEM_C2				EQU 250 ; 250	 FA
   247                                  OEM_C3				EQU 251 ; 251	 FB
   248                                  OEM_C4				EQU 252 ; 252	 FC
   249                                  OEM_C5				EQU 253 ; 253	 FD
   250                                  OEM_C6				EQU 254 ; 254	 FE
   251                                  OEM_C7				EQU 255 ; 255	 FF
   252                                  
   253                                  ;============================================================================
   254                                  ; DOSSYM.INC, MSDOS 6.0, 1991
   255                                  ;============================================================================
   256                                  ; 21/09/2018 - Retro DOS v3.0
   257                                  
   258                                  ;BREAK <Control character definitions>
   259                                  
   260                                  c_DEL	    EQU     7Fh 		;    ASCII rubout or delete previous char
   261                                  c_BS	    EQU     08h 		; ^H ASCII backspace
   262                                  c_CR	    EQU     0Dh 		; ^M ASCII carriage return
   263                                  c_LF	    EQU     0Ah 		; ^J ASCII linefeed
   264                                  c_ETB	    EQU     17h 		; ^W ASCII end of transmission
   265                                  c_NAK	    EQU     15h 		; ^U ASCII negative acknowledge
   266                                  c_ETX	    EQU     03h 		; ^C ASCII end of text
   267                                  c_HT	    EQU     09h 		; ^I ASCII tab
   268                                  
   269                                  ;============================================================================
   270                                  ; DIRENT.INC, MSDOS 6.0, 1991
   271                                  ;============================================================================
   272                                  ; 21/09/2018 - Retro DOS v3.0
   273                                  
   274                                  ;Break <Directory entry>
   275                                  
   276                                  ; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
   277                                  
   278                                  ;	NOTE:  These offsets are also used in the DTA for
   279                                  ;	extended FCB SearchFirst/Next. DIR_NAME lines up
   280                                  ;	with the FCB filename field, and the rest of the
   281                                  ;	DIR_ENTRY fields follow. -DavidOls
   282                                  
   283                                  ;**	DIRENT.INC - FAT Directory Entry Definition
   284                                  ;
   285                                  ;	+---------------------------+
   286                                  ;	|  (12 BYTE) filename/ext   |	    0	    0
   287                                  ;	+---------------------------+
   288                                  ;	|     (BYTE) attributes     |	    11	    B
   289                                  ;	+---------------------------+
   290                                  ;	|    (10 BYTE) reserved     |	    12	    C
   291                                  ;	+---------------------------+
   292                                  ;	| (WORD) time of last write |	    22	    16
   293                                  ;	+---------------------------+
   294                                  ;	| (WORD) date of last write |	    24	    18
   295                                  ;	+---------------------------+
   296                                  ;	|   (WORD) First cluster    |	    26	    1A
   297                                  ;	+---------------------------+
   298                                  ;	|     (DWORD) file size     |	    28	    1C
   299                                  ;	+---------------------------+
   300                                  ;
   301                                  ;   First byte of filename  = E5 -> free directory entry
   302                                  ;			    = 00 -> end of allocated directory
   303                                  ;   Time:   Bits 0-4=seconds/2, bits 5-10=minute, 11-15=hour
   304                                  ;   Date:   Bits 0-4=day, bits 5-8=month, bits 9-15=year-1980
   305                                  ;
   306                                  
   307                                  STRUC DIR_ENTRY
   308 00000000 <res Bh>                .DIR_NAME:	RESB  11	; file name
   309 0000000B ??                      .DIR_ATTR:	RESB  1		; attribute bits
   310 0000000C ????                    .DIR_CODEPG:	RESW  1		; code page DOS 4.00
   311 0000000E ????                    .DIR_EXTCLUSTER: RESW 1		; extended attribute starting cluster
   312 00000010 ??                      .DIR_ATTR2:	RESB  1		; reserved
   313 00000011 ??????????              .DIR_PAD:	RESB  5		; reserved for expansion
   314 00000016 ????                    .DIR_TIME:	RESW  1		; time of last write
   315 00000018 ????                    .DIR_DATE:	RESW  1		; date of last write
   316 0000001A ????                    .DIR_FIRST:	RESW  1		; first allocation unit of file
   317 0000001C ????                    .DIR_SIZE_L:	RESW  1		; low 16 bits of file size
   318 0000001E ????                    .DIR_SIZE_H:	RESW  1		; high 16 bits of file size
   319                                  .size:
   320                                  
   321                                  ;	    Caution: An extended FCB SearchFirst/Next on a network
   322                                  ;	    drive under Novell Netware 286 or 386 returns the time/date
   323                                  ;	    in the SIZE fields for subdirectory files. Ordinarily,
   324                                  ;	    this field is zero for subdirectory files.
   325                                  
   326                                  ENDSTRUC
   327                                  
   328                                  ATTR_READ_ONLY	equ	 1h
   329                                  ATTR_HIDDEN	equ	 2h
   330                                  ATTR_SYSTEM	equ	 4h
   331                                  ATTR_VOLUME_ID	equ	 8h
   332                                  ATTR_DIRECTORY	equ	10h
   333                                  ATTR_ARCHIVE	equ	20h
   334                                  ATTR_DEVICE	equ	40h	; This is a VERY special bit.
   335                                  				;   NO directory entry on a disk EVER
   336                                  				;   has this bit set. It is set non-zero
   337                                  				;   when a device is found by GETPATH
   338                                  
   339                                  ATTR_ALL	equ	ATTR_HIDDEN+ATTR_SYSTEM+ATTR_DIRECTORY
   340                                  				; OR of hard attributes for FINDENTRY
   341                                  
   342                                  ATTR_IGNORE	equ	ATTR_READ_ONLY+ATTR_ARCHIVE+ATTR_DEVICE
   343                                  				; ignore this(ese) attribute(s) during
   344                                  				; search first/next
   345                                  
   346                                  ATTR_CHANGEABLE equ	ATTR_READ_ONLY+ATTR_HIDDEN+ATTR_SYSTEM+ATTR_ARCHIVE
   347                                  				; changeable via CHMOD
   348                                  
   349                                  DIRFREE 	equ	0E5h	; stored in dir_name[0] to indicate free slot
   350                                  
   351                                  ;============================================================================
   352                                  ; ERROR.INC, MSDOS 6.0, 1991
   353                                  ;============================================================================
   354                                  ; 21/09/2018 - Retro DOS v3.0
   355                                  
   356                                  ;**	ERROR.INC - DOS Error Codes
   357                                  ;
   358                                  ;    The newer (DOS 2.0 and above) "XENIX-style" calls
   359                                  ;    return error codes through AX.	If an error occurred then
   360                                  ;    the carry bit will be set and the error code is in AX.	If no error
   361                                  ;    occurred then the carry bit is reset and AX contains returned info.
   362                                  ;
   363                                  ;    Since the set of error codes is being extended as we extend the operating
   364                                  ;    system, we have provided a means for applications to ask the system for a
   365                                  ;    recommended course of action when they receive an error.
   366                                  ;
   367                                  ;    The GetExtendedError system call returns a universal error, an error
   368                                  ;    location and a recommended course of action.	The universal error code is
   369                                  ;    a symptom of the error REGARDLESS of the context in which GetExtendedError
   370                                  ;    is issued.
   371                                  
   372                                  
   373                                  ;	2.0 error codes
   374                                  
   375                                  error_invalid_function		EQU	1
   376                                  ERROR_FILE_NOT_FOUND		EQU	2
   377                                  error_path_not_found		EQU	3
   378                                  ERROR_TOO_MANY_OPEN_FILES	EQU	4
   379                                  ERROR_ACCESS_DENIED		EQU	5
   380                                  error_invalid_handle		EQU	6
   381                                  error_arena_trashed		EQU	7
   382                                  ERROR_NOT_ENOUGH_MEMORY 	EQU	8
   383                                  error_invalid_block		EQU	9
   384                                  error_bad_environment		EQU	10
   385                                  ERROR_BAD_FORMAT		EQU	11
   386                                  error_invalid_access		EQU	12
   387                                  ERROR_INVALID_DATA		EQU	13
   388                                  ;**** reserved			EQU	14	; *****
   389                                  error_invalid_drive		EQU	15
   390                                  error_current_directory 	EQU	16
   391                                  error_not_same_device		EQU	17
   392                                  error_no_more_files		EQU	18
   393                                  
   394                                  ;	These are the universal int 24 mappings for the old INT 24 set of errors
   395                                  
   396                                  ERROR_WRITE_PROTECT		EQU	19
   397                                  error_bad_unit			EQU	20
   398                                  error_not_ready 		EQU	21
   399                                  error_bad_command		EQU	22
   400                                  error_CRC			EQU	23
   401                                  error_bad_length		EQU	24
   402                                  error_Seek			EQU	25
   403                                  error_not_DOS_disk		EQU	26
   404                                  error_sector_not_found		EQU	27
   405                                  error_out_of_paper		EQU	28
   406                                  error_write_fault		EQU	29
   407                                  error_read_fault		EQU	30
   408                                  ERROR_GEN_FAILURE		EQU	31
   409                                  
   410                                  ;	the new 3.0 error codes reported through INT 24
   411                                  
   412                                  error_sharing_violation 	EQU	32
   413                                  error_lock_violation		EQU	33
   414                                  error_wrong_disk		EQU	34
   415                                  ERROR_FCB_UNAVAILABLE		EQU	35
   416                                  ERROR_SHARING_BUFFER_EXCEEDED	EQU	36
   417                                  error_Code_Page_Mismatched	EQU	37    ; DOS 4.00	;AN000;
   418                                  error_handle_EOF		EQU	38    ; DOS 4.00	;AN000;
   419                                  ERROR_HANDLE_DISK_FULL		EQU	39    ; DOS 4.00	;AN000;
   420                                  
   421                                  ;	New OEM network-related errors are 50-79
   422                                  
   423                                  error_not_supported		EQU	50
   424                                  
   425                                  error_net_access_denied		EQU	65	;M028
   426                                  
   427                                  ;	End of INT 24 reportable errors
   428                                  
   429                                  error_file_exists		EQU	80
   430                                  error_DUP_FCB			EQU	81	; *****
   431                                  error_cannot_make		EQU	82
   432                                  error_FAIL_I24			EQU	83
   433                                  
   434                                  ;	New 3.0 network related error codes
   435                                  
   436                                  error_out_of_structures 	EQU	84
   437                                  error_Already_assigned		EQU	85
   438                                  error_invalid_password		EQU	86
   439                                  error_invalid_parameter 	EQU	87
   440                                  error_NET_write_fault		EQU	88
   441                                  error_sys_comp_not_loaded	EQU	90    ; DOS 4.00	;AN000;
   442                                  
   443                                  ;============================================================================
   444                                  ; DEVSYM.INC, MSDOS 6.0, 1991
   445                                  ;============================================================================
   446                                  ; 22/09/2018 - Retro DOS v3.0
   447                                  
   448                                  ;**	DevSym.inc - Device Symbols
   449                                  
   450                                  ;	THE DEVICE TABLE LIST HAS THE FORM:
   451                                  
   452                                  STRUC SYSDEV
   453 00000000 ????????                .NEXT:	RESD 1			;POINTER TO NEXT DEVICE HEADER
   454 00000004 ????                    .ATT:	RESW 1			;ATTRIBUTES OF THE DEVICE
   455 00000006 ????                    .STRAT:	RESW 1			;STRATEGY ENTRY POINT
   456 00000008 ????                    .INT:	RESW 1			;INTERRUPT ENTRY POINT
   457 0000000A ????????????????        .NAME:	RESB 8			;NAME OF DEVICE (ONLY FIRST BYTE USED FOR BLOCK)
   458                                  .size:
   459                                  ENDSTRUC
   460                                  
   461                                  ; 24/09/2018
   462                                  DEVTYP	EQU   8000H	; BIT 15 - 1  IF CHAR, 0 IF BLOCK
   463                                  
   464                                  ;============================================================================
   465                                  ; CURDIR.INC, MSDOS 6.0, 1991
   466                                  ;============================================================================
   467                                  ; 21/09/2018 - Retro DOS v3.0
   468                                  
   469                                  DIRSTRLEN	EQU	64+3		; Max length in bytes of directory strings
   470                                  
   471                                  ;============================================================================
   472                                  ; COMEQU.ASM, MSDOS 6.0, 1991
   473                                  ;============================================================================
   474                                  ; 21/09/2018 - Retro DOS v3.0
   475                                  
   476                                  ;/*
   477                                  ; *                      Microsoft Confidential
   478                                  ; *                      Copyright (C) Microsoft Corporation 1991
   479                                  ; *                      All Rights Reserved.
   480                                  ; */
   481                                  ;	SCCSID = @(#)comequ.asm 1.1 85/05/14
   482                                  ;	SCCSID = @(#)comequ.asm 1.1 85/05/14
   483                                  ;*************************************
   484                                  ; COMMAND EQUs which are not switch dependant
   485                                  
   486                                  ;		include	curdir.inc	; to get DIRSTRLEN
   487                                  ;		Note dossym.inc must already have been included!
   488                                  
   489                                  GET_COMMAND_STATE	equ	5500h	; check for existing COMMAND
   490                                  GET_ROMCOMMAND_STATE	equ	5501h	; check for existing ROM COMMAND
   491                                  
   492                                  SYM		EQU	">"
   493                                  
   494                                  LINESPERPAGE	EQU	25		;AC000; default lines per page
   495                                  
   496                                  NORMPERLIN	EQU	1
   497                                  WIDEPERLIN	EQU	5
   498                                  COMBUFLEN	EQU	128		; Length of commmand buffer
   499                                  BatLen		EQU	32		; buffer for batch files
   500                                  YES_ECHO	EQU	1		; echo line
   501                                  NO_ECHO 	EQU	0		; don't echo line
   502                                  NO_ECHO_CHAR	EQU	"@"             ; don't echo line if this is first char
   503                                  call_in_progress EQU	1		; indicate we're in the CALL command
   504                                  length_call	EQU	4		; length of CALL
   505                                  max_nest	EQU    10		; max # levels of batch nesting allowed
   506                                  FAIL_ALLOWED	EQU    00001000b	; critical error
   507                                  RETRY_ALLOWED	EQU    00010000b	; critical error
   508                                  IGNORE_ALLOWED	EQU    00100000b	; critical error
   509                                  nullcommand	EQU    1		; no command on command line
   510                                  end_of_line	EQU    -1		;AN000; end of line return from parser
   511                                  end_of_line_out EQU	0		;AN000; end of line for output
   512                                  end_of_line_in	EQU	0dh		;AN000; end of line for input
   513                                  result_number	EQU	1		;AN000; number returned from parser
   514                                  result_string	EQU	3		;AN000; string returned from parser
   515                                  result_filespec EQU	5		;AN000; filespec returned from parser
   516                                  result_drive	EQU	6		;AN000; drive returned from parser
   517                                  result_date	EQU	7		;AN000; date returned from parser
   518                                  result_time	EQU	8		;AN000; time returned from parser
   519                                  result_no_error EQU	0		;AN000; no error returned from parser
   520                                  no_cont_flag	EQU	0		;AN000; no control flags for message
   521                                  util_msg_class	EQU	-1		;AN000; message class for utility
   522                                  ext_msg_class	EQU	1		;AN000; message class for extended error
   523                                  parse_msg_class EQU	2		;AN000; message class for parse error
   524                                  crit_msg_class	EQU	3		;AN000; message class for critical error
   525                                  ext_crlf_class	EQU	081h		;AN054; message class for extended error with no CRLF
   526                                  colon_char	EQU	":"             ;AN000; colon character
   527                                  crt_ioctl_ln	EQU	14		;AN000; default length of data for display ioctl
   528                                  text_mode	EQU	1		;AN000; text mode return from ioctl
   529                                  get_generic	EQU	07Fh		;AN000; generic ioctl - get device info
   530                                  set_crit_dev	EQU	0100H		;AN000; device attribute for critical error on I/0
   531                                  mult_ansi	EQU	01Ah		;AC064; multiplex for ansi.sys
   532                                  mult_shell_get	EQU	01902h		;AC065; multiplex for Shell - get next command
   533                                  mult_shell_brk	EQU	01903h		;AN000; multiplex for Shell - ^C batch check
   534                                  shell_action	equ	0ffh		;AN000; SHELL - return for taking SHELL specific action
   535                                  bat_not_open	EQU	-1		;AN000; batch handle will be set to this if not open
   536                                  bat_open_handle EQU	19		;AN000; handle will be in this position in JFN table
   537                                  Ptr_seg_pos	equ	7		;AN000; Offset from start of message block for subst segment
   538                                  Ptr_off_pos	equ	5		;AN000; Offset from start of message block for subst offset
   539                                  %define Parm_off_pos	word [2]	;AN000; Offset from start of subst list for subst offset
   540                                  parm_block_size equ	11		;AN000; size of message subst block
   541                                  blank		equ	" "             ;AN000; blank character
   542                                  no_subst	equ	0		;AN000; no substitutions for messages
   543                                  one_subst	equ	1		;AN000; one substitution for messages
   544                                  no_handle_out	equ	-1		;AN000; use function 1 thru 12 for message retriever
   545                                  res_subst	equ	2		;AN000; offset from start of message definition to number of subst
   546                                  read_open_mode	equ   0000000000000000b ;AN024; extended open mode for read
   547                                  deny_write	equ   0000000000100000b	; deny write sharing mode ;M031
   548                                  deny_none	equ   0000000001000000b	; deny none sharing mode ;Myyy	
   549                                  read_open_flag	equ   0000000100000001b ;AN000; extended open flags for read
   550                                  write_open_mode equ   0000000000000001b ;AN024; extended open mode for read
   551                                  write_open_flag equ   0000000100000001b ;AN000; extended open flags for read
   552                                  creat_open_flag equ   0000000100010010b ;AN000; extended open flags for read
   553                                  capital_A	equ	'A'             ;AC000;
   554                                  vbar		equ	'|'             ;AC000;
   555                                  labracket	equ	'<'             ;AC000;
   556                                  rabracket	equ	'>'             ;AC000;
   557                                  dollar		equ	'$'             ;AC000;
   558                                  lparen		equ	'('             ;AC000;
   559                                  rparen		equ	')'             ;AC000;
   560                                  nullrparen	equ	29h		;AC000;
   561                                  in_word 	equ	4e49h		;AC000; 'NI'  ('IN' backwards)
   562                                  do_word 	equ	4f44h		;AC000; 'OD'  ('DO' backwards)
   563                                  star		equ	'*'             ;AC000;
   564                                  plus_chr	equ	'+'             ;AC000;
   565                                  ;small_a 	equ	'a'             ;AC000;
   566                                  ;small_z 	equ	'z'             ;AC000;
   567                                  dot_chr 	equ	'.'             ;AC000;
   568                                  tab_chr 	equ	9		;AN032;
   569                                  equal_chr	equ	'='             ;AN032;
   570                                  semicolon	equ	';'             ;AN049;
   571                                  dot_qmark	equ	2e3fh		;AC000; '.?'
   572                                  dot_colon	equ	2e3ah		;AC000; '.:'
   573                                  capital_n	equ	0		;AC000; result from Y/N call if N entered
   574                                  capital_y	equ	1		;AC000; result from Y/N call if Y entered
   575                                  AppendInstall	equ	0B700H		;AN020; append install check
   576                                  AppendDOS	equ	0B702H		;AN020; append DOS version check
   577                                  AppendGetState	equ	0B706H		;AN020; append get current state
   578                                  AppendSetState	equ	0B707H		;AN020; append set current state
   579                                  AppendTruename	equ	0B711H		;AN042; Get file's real location for Batch
   580                                  SEARCH_ATTR	equ	ATTR_READ_ONLY+ATTR_HIDDEN+ATTR_DIRECTORY  ;AC042;
   581                                  
   582                                  ;*************************************
   583                                  ;* PARSE ERROR MESSAGES
   584                                  ;*************************************
   585                                  
   586                                  MoreArgs_Ptr	equ	1		;AN000;"Too many parameters" message number
   587                                  LessArgs_Ptr	equ	2		;AN000;"Required parameter missing" message number
   588                                  BadSwt_Ptr	equ	3		;AN000;"Invalid switch" message number
   589                                  BadParm_Ptr	equ	10		;AN000;"Invalid parameter" message number
   590                                  
   591                                  ;*************************************
   592                                  ;* EQUATES FOR MESSAGE RETRIEVER
   593                                  ;*************************************
   594                                  
   595                                  GET_EXTENDED_MSG	EQU	0	;AN000;  get extended message address
   596                                  SET_EXTENDED_MSG	EQU	1	;AN000;  set extended message address
   597                                  GET_PARSE_MSG		EQU	2	;AN000;  get parse message address
   598                                  SET_PARSE_MSG		EQU	3	;AN000;  set parse message address
   599                                  GET_CRITICAL_MSG	EQU	4	;AN000;  get critical message address
   600                                  SET_CRITICAL_MSG	EQU	5	;AN000;  set critical message address
   601                                  MESSAGE_2F		EQU	46	;AN000;  minor code for message retriever
   602                                  
   603                                  ;*********************************
   604                                  ;* EQUATES FOR INT 10H
   605                                  ;*********************************
   606                                  
   607                                  VIDEO_IO_INT		EQU	10H	;AN000;  equate for int 10h
   608                                  SET_VIDEO_MODE		EQU	0	;AN000;  set video mode
   609                                  SET_CURSOR_POSITION	EQU	2	;AN000;  set new cursor position
   610                                  SCROLL_VIDEO_PAGE	EQU	6	;AN000;  scroll active page up
   611                                  VIDEO_ATTRIBUTE 	EQU	7	;AN000;  attribute to be used on blank line
   612                                  SET_COLOR_PALETTE	EQU	11	;AN000;  set color for video
   613                                  GET_VIDEO_STATE 	EQU	15	;AN000;  get current video state
   614                                  VIDEO_ALPHA		EQU	3	;AN000;  alpha video is 3 or below
   615                                  VIDEO_BW		EQU	7	;AN000;  mode for 80X25 black & white
   616                                  
   617                                  ALTPIPECHR	equ	"|"             ; alternate pipe character
   618                                  
   619                                  FCB		EQU	5CH
   620                                  
   621                                  STRUC VARSTRUC
   622 00000000 ??                      .ISDIR:		RESB	1
   623 00000001 ??                      .SIZ:		RESB	1
   624 00000002 ????                    .TTAIL:		RESW	1
   625 00000004 ??                      .INFO:		RESB	1
   626 00000005 <res 57h>               .BUF:		RESB	DIRSTRLEN + 20
   627                                  .size:
   628                                  ENDSTRUC
   629                                  ;
   630                                  ; Flags for internal command parsing
   631                                  ;
   632                                  FCHECKDRIVE	equ	00000001b	; validate drive letter
   633                                  FSWITCHALLOWED	equ	00000010b	; switches allowed
   634                                  FLIMITHELP	equ	00000100b	; /? must appear alone
   635                                  
   636                                  ;
   637                                  ; Test switches
   638                                  ;
   639                                  fParse		EQU	0001h		; display results of parseline
   640                                  
   641                                  ;
   642                                  ; Batch segment structure
   643                                  ;
   644                                  ;   BYTE    type of segment
   645                                  ;   BYTE    echo state of parent on entry to batch file
   646                                  ;   WORD    segment of last batch file
   647                                  ;   WORD    segment for FOR command
   648                                  ;   BYTE    FOR flag state on entry to batch file
   649                                  ;   DWORD   offset for next line
   650                                  ;   10 WORD pointers to parameters.  -1 is empty parameter
   651                                  ;   ASCIZ   file name (with . and ..)
   652                                  ;   BYTES   CR-terminated parameters
   653                                  ;   BYTE    0 flag to indicate end of parameters
   654                                  ;
   655                                  
   656                                  BATCHTYPE   equ 0
   657                                  
   658                                  STRUC BATCHSEGMENT
   659 00000000 ??                      .BatType:	RESB	1		; signature
   660 00000001 ??                      .BatEchoFlag:	RESB	1		; G state of echo
   661                                  ;.BatchEOF:	RESB	1		; records if EOF reached on file
   662 00000002 ????                    .BatLast: 	RESW	1		; G segment of last batch file
   663 00000004 ????                    .BatForPtr:	RESW	1		; G segment for FOR command
   664 00000006 ??                      .BatForFlag:	RESB	1		; G state of FOR
   665 00000007 ????????                .BatSeek:	RESD	1		; lseek position of next char
   666 0000000B <res 14h>               .BatParm:	RESW	10		; pointers to parameters
   667 0000001F ??                      .BatFile:	RESB	1		; beginning of batch file name
   668                                  .SIZE:
   669                                  ENDSTRUC
   670                                  
   671                                  ANULL		equ	0		; terminates an argv string
   672                                  ARGMAX		equ	64		; max args on a command line
   673                                  ARGBLEN 	equ	2*128		; 1char each plus term NUL
   674                                  tplen		equ	64		; max size of one argument
   675                                  arg_cnt_error	equ	1		; number of args > MAXARG
   676                                  arg_buf_ovflow	equ	2		; overflowed argbuffer
   677                                  
   678                                  STRUC ARGV_ELE				; elements in the argv array
   679 00000000 ????                    .argpointer:	RESW	1		; pointer to the argstring
   680 00000002 ??                      .argflags:	RESB	1		; cparse flags for this argstring
   681 00000003 ????                    .argstartel:	RESW	1		; the result of cparse's [STARTEL]
   682 00000005 ????                    .arglen:	RESW	1		; cparse's char count + one (for null)
   683 00000007 ????                    .argsw_word:	RESW	1		; any switches after this? what kinds?
   684 00000009 ????                    .arg_ocomptr:	RESW	1		; pointer into original command string
   685                                  .SIZE:
   686                                  ENDSTRUC
   687                                  
   688                                  STRUC ARG_UNIT
   689 00000000 <res 2C0h>              .argv:		RESB	ARGMAX * ARGV_ELE.SIZE
   690 000002C0 ????                    .argvcnt:	RESW	1		; number of arguments
   691 000002C2 ????                    .argswinfo:	RESW	1		; Switch information for entire line
   692 000002C4 <res 200h>              .argbuf:	RESW	ARGBLEN		; storage for argv strings
   693 000004C4 <res 80h>               .argforcombuf:	RESB	COMBUFLEN	; Original for loop command string
   694                                  .SIZE:
   695                                  ENDSTRUC
   696                                  
   697                                  ; Parse flags - 13/10/2018
   698                                  special_delim	equ	128
   699                                  path_sep 	equ	4
   700                                  wildcard 	equ	2
   701                                  sw_flag		equ	1
   702                                  
   703                                  SWITCHQUES 	EQU	20h
   704                                  SWITCHV 	EQU	10h
   705                                  SWITCHB 	EQU	08h
   706                                  SWITCHA 	EQU	04h
   707                                  SWITCHP 	EQU	02h
   708                                  SWITCHW 	EQU	01h
   709                                  FSWITCH 	EQU	8000h
   710                                  FBADSWITCH	EQU	4000h
   711                                  
   712                                  SWITCHDIR	EQU	SWITCHP+SWITCHW+FSWITCH
   713                                  SWITCHCOPY	EQU	SWITCHV+SWITCHA+SWITCHB+FSWITCH
   714                                  ; 13/10/2018
   715                                  ;SWITCHCOPY	EQU	801Ch
   716                                  NOT_SWITCHCOPY	EQU	7FE3h
   717                                  
   718                                  ; Equates for initialization
   719                                  ;
   720                                  INITINIT	equ	01h		; initialization in progress
   721                                  INITSPECIAL	equ	02h		; in initialization time/date routine
   722                                  INITCTRLC	equ	04h		; already in ^C handler
   723                                  
   724                                  ;============================================================================
   725                                  ; FIND.INC (MSDOS 3.3, 1987)
   726                                  ;============================================================================
   727                                  ; 13/10/2018 - Retro DOS v3.0
   728                                  
   729                                  ;Break	<find first/next buffer>
   730                                  
   731                                  	; MSDOS 3.3 & MSDOS 6.0
   732                                  
   733                                  struc FIND_BUF
   734 00000000 ??                      .DRIVE:	    resb 1	; drive of search
   735 00000001 <res Bh>                .NAME:	    resb 11	; formatted name
   736 0000000C ??                      .SATTR:	    resb 1	; attribute of search
   737 0000000D ????                    .LASTENT:   resw 1	; LastEnt
   738 0000000F ????                    .DIRSTART:  resw 1	; DirStart
   739 00000011 ????????                .NETID:	    resb 4	; Reserved for NET
   740 00000015 ??                      .ATTR:	    resb 1	; attribute found
   741 00000016 ????                    .TIMR:	    resw 1	; time
   742 00000018 ????                    .DATE:	    resw 1	; date
   743 0000001A ????                    .SIZE_L:    resw 1	; low(size)
   744 0000001C ????                    .SIZE_H:    resw 1	; high(size)
   745 0000001E <res Dh>                .PNAME:	    resb 13	; packed name
   746                                  .size:
   747                                  endstruc
   748                                  
   749                                  ;=============================================================================
   750                                  ; PDB.INC, MSDOS 6.0, 1991
   751                                  ;=============================================================================
   752                                  ; 24/09/2018 - Retro DOS v3.0 (08/07/2018, 'msdos3.s')
   753                                  
   754                                  ;**	Process data block (otherwise known as program header)
   755                                  
   756                                  ;	These offset are documented in the MSDOS Encyclopedia, so nothing
   757                                  ;	can be rearranged here, ever. Reserved areas are probably safe
   758                                  ;	for use.
   759                                  
   760                                  FILPERPROC	EQU     20
   761                                  
   762                                  struc PDB	; Process_data_block
   763 00000000 ????                    .EXIT_CALL:	resw 1   	; INT int_abort system terminate
   764 00000002 ????                    .BLOCK_LEN:	resw 1		; size of execution block
   765 00000004 ??                                      resb 1
   766 00000005 ??????????              .CPM_CALL:	resb 5		; ancient call to system
   767 0000000A ????????                .EXIT:		resd 1		; pointer to exit routine
   768 0000000E ????????                .CTRL_C:	resd 1		; pointer to ^C routine
   769 00000012 ????????                .FATAL_ABORT:	resd 1		; pointer to fatal error
   770 00000016 ????                    .PARENT_PID:	resw 1		; PID of parent (terminate PID)
   771 00000018 <res 14h>               .JFN_TABLE:     resb FILPERPROC ; indices into system table
   772 0000002C ????                    .ENVIRON:	resw 1		; seg addr of environment
   773 0000002E ????????                .USER_STACK:	resd 1		; stack of self during system calls
   774 00000032 ????                    .JFN_Length:	resw 1		; number of handles allowed
   775 00000034 ????????                .JFN_Pointer:	resd 1		; pointer to JFN table
   776 00000038 ????????                .Next_PDB:	resd 1		; pointer to nested PDB's
   777 0000003C ??                      .InterCon:	resb 1	; MSDOS 6.0 ; *** jh-3/28/90 *** 
   778 0000003D ??                      .Append:	resb 1	; MSDOS 6.0 ; *** Not sure if still used ***
   779 0000003E ????                    .Novell_Used:	resb 2	; MSDOS 6.0 ; Novell shell (redir) uses these
   780 00000040 ????                    .Version:	resw 1	; MSDOS 6.0 ; DOS version reported to this app
   781 00000042 <res Eh>                .PAD1:		resb 14 ; 0Eh
   782 00000050 ??????????              .CALL_SYSTEM:	resb 5		; portable method of system call
   783 00000055 ??????????????          .PAD2:		resb 7		; reserved so FCB 1 can be used as
   784                                  				;  an extended FCB
   785                                  ;endstruc 	; MSDOS 3.3
   786                                  	  	; MSDOS 6.0
   787 0000005C <res 10h>               .FCB1:		resb 16 ; 10h	; default FCB 1
   788 0000006C <res 10h>               .FCB2:		resb 16 ; 10h	; default FCB 2
   789 0000007C ????????                .PAD3:		resb 4		; not sure if this is used by PDB_FCB2
   790 00000080 <res 80h>               .TAIL:		resb 128	; command tail and default DTA
   791                                  endstruc
   792                                  
   793                                  ;============================================================================
   794                                  ; SF.INC, MSDOS 6.0, 1991
   795                                  ;============================================================================
   796                                  ; 13/10/2018 - Retro DOS v3.0
   797                                  
   798                                  ; structure of devid field as returned by IOCTL is:
   799                                  ;
   800                                  ;	BIT	7   6	5   4	3   2	1   0
   801                                  ;	      |---|---|---|---|---|---|---|---|
   802                                  ;	      | I | E | R | S | I | I | I | I |
   803                                  ;	      | S | O | A | P | S | S | S | S |
   804                                  ;	      | D | F | W | E | C | N | C | C |
   805                                  ;	      | E |   |   | C | L | U | O | I |
   806                                  ;	      | V |   |   | L | K | L | T | N |
   807                                  ;	      |---|---|---|---|---|---|---|---|
   808                                  ;	ISDEV = 1 if this channel is a device
   809                                  ;	      = 0 if this channel is a disk file
   810                                  ;
   811                                  ;	If ISDEV = 1
   812                                  ;
   813                                  ;	      EOF = 0 if End Of File on input
   814                                  ;	      RAW = 1 if this device is in Raw mode
   815                                  ;		  = 0 if this device is cooked
   816                                  ;	      ISCLK = 1 if this device is the clock device
   817                                  ;	      ISNUL = 1 if this device is the null device
   818                                  ;	      ISCOT = 1 if this device is the console output
   819                                  ;	      ISCIN = 1 if this device is the console input
   820                                  ;
   821                                  ;	If ISDEV = 0
   822                                  ;	      EOF = 0 if channel has been written
   823                                  ;	      Bits 0-5	are  the  block  device  number  for
   824                                  ;		  the channel (0 = A, 1 = B, ...)
   825                                  
   826                                  devid_ISDEV	EQU	80h
   827                                  devid_EOF	EQU	40h
   828                                  devid_RAW	EQU	20h
   829                                  devid_SPECIAL	EQU	10H
   830                                  devid_ISCLK	EQU	08h
   831                                  devid_ISNUL	EQU	04h
   832                                  devid_ISCOT	EQU	02h
   833                                  devid_ISCIN	EQU	01h
   834                                  
   835                                  devid_block_dev EQU	1Fh		; mask for block device number
   836                                  
   837                                  ;============================================================================
   838                                  ; INTNAT.INC, MSDOS 3.3, 1987
   839                                  ;============================================================================
   840                                  ; 09/07/2018 - Retro DOS 3.0
   841                                  
   842                                  ; Current structure of the data returned by the international call
   843                                  
   844                                  struc	INTERNAT_BLOCK		; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
   845 00000000 ????                    .Date_tim_format: RESW 1	; 0-USA, 1-EUR, 2-JAP
   846 00000002 ??????????              .Currency_sym:	  RESB 5	; Currency Symbol 5 bytes
   847 00000007 ????                    .Thous_sep:	  RESB 2	; Thousands separator 2 bytes
   848 00000009 ????                    .Decimal_sep:	  RESB 2	; Decimal separator 2 bytes
   849 0000000B ????                    .Date_sep:	  RESB 2	; Date separator 2 bytes
   850 0000000D ????                    .Time_sep:	  RESB 2	; Time separator 2 bytes
   851 0000000F ??                      .Bit_field:	  RESB 1	; Bit values
   852                                                                  ;   Bit 0 = 0 if currency symbol first
   853                                                                  ;         = 1 if currency symbol last
   854                                                                  ;   Bit 1 = 0 if No space after currency symbol
   855                                                                  ;         = 1 if space after currency symbol
   856 00000010 ??                      .Currency_cents:  RESB 	1	; Number of places after currency dec point
   857 00000011 ??                      .Time_24:	  RESB 	1	; 1 if 24 hour time, 0 if 12 hour time
   858 00000012 ????                    .Map_call:	  RESW	1	; Address of case mapping call (DWORD)
   859 00000014 ????                                      RESW	1       ; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
   860                                  				;  in pieces.
   861 00000016 ????                    .Data_sep:	  RESB	2	; Data list separator character
   862                                  .size:		
   863                                  endstruc
   864                                  
   865                                  ;
   866                                  ; Max size of the block returned by the INTERNATIONAL call
   867                                  ;
   868                                  internat_block_max	EQU	32
   869                                  
   870                                  ;============================================================================
   871                                  ; VECTOR.INC, MSDOS 3.3, 1987
   872                                  ;============================================================================
   873                                  ; 13/10/2018 - Retro DOS 3.0
   874                                  
   875                                  ;BREAK <interrupt definitions>	
   876                                  
   877                                  ; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
   878                                  
   879                                  INTTAB		EQU	20H
   880                                  INTBASE 	EQU	4 * INTTAB
   881                                  ENTRYPOINT	EQU	INTBASE+40H
   882                                  
   883                                  ;
   884                                  ; interrupt assignments
   885                                  ;
   886                                  
   887                                  INT_ABORT	    EQU     INTTAB	; abort process
   888                                  INT_COMMAND	    EQU     INT_ABORT+1 ; call MSDOS
   889                                  INT_TERMINATE	    EQU     INT_ABORT+2 ; int to terminate address
   890                                  INT_CTRL_C	    EQU     INT_ABORT+3 ; ^c trapper
   891                                  INT_FATAL_ABORT	    EQU     INT_ABORT+4 ; hard disk error
   892                                  INT_DISK_READ	    EQU     INT_ABORT+5 ; logical sector disk read
   893                                  INT_DISK_WRITE	    EQU     INT_ABORT+6 ; logical sector disk write
   894                                  INT_KEEP_PROCESS    EQU     INT_ABORT+7 ; terminate program and stay
   895                                  					; resident
   896                                  INT_SPOOLER	    EQU     INT_ABORT+8 ; spooler call
   897                                  INT_FASTCON	    EQU     INT_ABORT+9 ; fast CON interrupt
   898                                  ; MSDOS 3.3 (& MSDOS 6.0)
   899                                  INT_IBM 	    EQU     INT_ABORT+10; critical section maintenance
   900                                  
   901                                  ;============================================================================
   902                                  ; ARENA.INC, MSDOS 3.3, 1987
   903                                  ;============================================================================
   904                                  ; 13/10/2018 - Retro DOS 3.0
   905                                  
   906                                  ;BREAK <Memory arena structure>
   907                                  
   908                                  ; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
   909                                  
   910                                  ;
   911                                  ; arena item
   912                                  ;
   913                                  
   914                                  struc ARENA
   915 00000000 ??                        .signature:	resb 1		; 4D for valid item, 5A for last item
   916 00000001 ????                      .owner:	resw 1		; owner of arena item
   917 00000003 ????                      .size:	resw 1		; size in paragraphs of item
   918                                  endstruc
   919                                  
   920                                  ; CAUTION: The routines in ALLOC.ASM rely on the fact that arena_signature
   921                                  ; and arena_owner_system are all equal to zero and are contained in DI.
   922                                  ; Change them and change ALLOC.ASM.
   923                                  
   924                                  arena_owner_system  EQU 0		; free block indication
   925                                  
   926                                  arena_signature_normal	EQU 4Dh 	; valid signature, not end of arena
   927                                  arena_signature_end	EQU 5Ah 	; valid signature, last block in arena
   928                                  
   929                                  ;============================================================================
   930                                  ; FILEMODE.INC, MSDOS 3.3, 1987
   931                                  ;============================================================================
   932                                  ; 21/09/2018 - Retro DOS v3.0
   933                                  
   934                                  ;BREAK <FILEMODE.INC - Misc. File API Values>
   935                                  
   936                                  ; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
   937                                  
   938                                  ;**	Standard I/O file handles
   939                                  ;
   940                                  
   941                                  STDIN	equ	0
   942                                  STDOUT	equ	1
   943                                  STDERR	equ	2
   944                                  STDAUX	equ	3
   945                                  STDPRN	equ	4
   946                                  
   947                                  ;**	File Modes
   948                                  
   949                                  ACCESS_MASK	    equ 0Fh
   950                                  OPEN_FOR_READ	    equ 00h
   951                                  OPEN_FOR_WRITE	    equ 01h
   952                                  OPEN_FOR_BOTH	    equ 02h
   953                                  EXEC_OPEN	    equ 03h	; access code of 3 indicates that open was 
   954                                  				; made from exec
   955                                  
   956                                  ;=============================================================================
   957                                  ; COMMAND.COM Resident Portion Addresses - 13/10/2018
   958                                  ;=============================================================================
   959                                  
   960                                  ; Transient portion loader code offset in resident code segment
   961                                  ;LODCOM1   equ	0318h	; 13/10/2018
   962                                  LODCOM1    equ	0319h	; 24/02/2023
   963                                  
   964                                  ; EXEC call addresses in resident portion for calling from transient portion
   965                                  EXEC_WAIT  equ 	0131h	; 13/10/2018
   966                                  
   967                                  ; Putbackmsg ("Insert disk ..." msg) disk drive letter in resident portion
   968                                  ;PUTBACKDRV equ 0A21h	; 14/10/2018
   969                                  PUTBACKDRV equ	0A1Dh	; 02/03/2023
   970                                  
   971                                  ; Note: Following offset addresses are in data section of 'command3.s' file.
   972                                  ; They must be verified by using assembly list (command3.lst) of COMMAND.COM.
   973                                  
   974                                  ; Resident portion stack address  
   975                                  ;RSTACK	   equ	083Ch
   976                                  RSTACK	   equ	0838h	; 02/03/2023 
   977                                  
   978                                  ;RETRABASE equ  0B86h	; 13/10/2018 (Base addr for following common params.)
   979                                  RETRABASE  equ  0B82h	; 02/03/2023	
   980                                  
   981                                  ; RESGROUP       [RESSEG]
   982                                  ; DATA		  offset
   983                                  ; --------     	------------
   984                                  PARENT	  equ	RETRABASE+6	; 0B88h	; 02/03/2023
   985                                  OLDTERM	  equ	RETRABASE+8	; 0B8Ah
   986                                  BATCH	  equ	RETRABASE+17	; 0B93h
   987                                  COMSPEC	  equ	RETRABASE+19	; 0B95h
   988                                  PUTBACKSUBSTPTR equ RETRABASE+83 ; 0BD5h
   989                                  COMSPEC_END equ	RETRABASE+85	; 0BD7h
   990                                  IN_BATCH  equ	RETRABASE+92	; 0BDEh
   991                                  BATCH_ABORT equ	RETRABASE+93	; 0BDFh
   992                                  COMDRV	  equ	RETRABASE+94	; 0BE0h
   993                                  EXTCOM	  equ	RETRABASE+99	; 0BE1h
   994                                  RETCODE	  equ	RETRABASE+100	; 0BE5h
   995                                  ECHOFLAG  equ	RETRABASE+103	; 0BE9h
   996                                  SUPPRESS  equ	RETRABASE+104	; 0BEAh
   997                                  IO_SAVE	  equ	RETRABASE+105	; 0BEBh
   998                                  RESTDIR	  equ	RETRABASE+107	; 0BEDh
   999                                  PERMCOM	  equ	RETRABASE+108	; 0BEEh
  1000                                  SINGLECOM equ	RETRABASE+109	; 0BEFh
  1001                                  VERVAL	  equ	RETRABASE+111	; 0BF1h
  1002                                  IFFLAG	  equ	RETRABASE+114	; 0BF4h	
  1003                                  FORFLAG	  equ	RETRABASE+115	; 0BF5h
  1004                                  FORPTR	  equ	RETRABASE+116	; 0BF6h 	
  1005                                  NEST	  equ	RETRABASE+118	; 0BF8h
  1006                                  CALL_FLAG equ	RETRABASE+120	; 0BFAh
  1007                                  CALL_BATCH_FLAG equ RETRABASE+121 ; 0BFBh
  1008                                  NEXT_BATCH equ	RETRABASE+122 	; 0BFCh
  1009                                  NULLFLAG  equ	RETRABASE+124	; 0BFEh
  1010                                  UPPERCASETBL equ RETRABASE+126	; 0C00h
  1011                                  RE_OUT_APP equ	RETRABASE+130	; 0C04h
  1012                                  RE_OUTSTR equ	RETRABASE+131	; 0C05h
  1013                                  INITFLAG  equ	RETRABASE+211	; 0C55h	
  1014                                  PIPEFLAG  equ	RETRABASE+212	; 0C56h
  1015                                  PIPEFILES equ	RETRABASE+213	; 0C57h
  1016                                  PIPE1	  equ	RETRABASE+214	; 0C58h	
  1017                                  PIPE2	  equ	RETRABASE+230	; 0C68h
  1018                                  PIPEPTR	  equ	RETRABASE+246	; 0C78h
  1019                                  PIPESTR	  equ	RETRABASE+248	; 0C7Ah
  1020                                  INPIPEPTR equ	RETRABASE+377	; 0CFBh
  1021                                  OUTPIPEPTR equ	RETRABASE+379	; 0CFDh
  1022                                  ENVIRSEG  equ	RETRABASE+381	; 0CFFh
  1023                                  EXEC_BLOCK equ	RETRABASE+381 	; 0CFFh  ; ENVIRSEG
  1024                                  LTPA	  equ	RETRABASE+399	; 0D11h
  1025                                  RES_TPA	  equ	RETRABASE+413	; 0D1Fh
  1026                                  
  1027                                  ;=============================================================================
  1028                                  					
  1029                                  ; (command3.s -> offset TRANGOUP)
  1030                                  
  1031                                  TRANGROUP:
  1032                                  
  1033                                  ; ----------------------------------------------------------------------------
  1034                                  ; START OF TRANSIENT PORTION
  1035                                  ; ----------------------------------------------------------------------------
  1036                                  ; SEGMENT - TRANSCODE
  1037                                  ; ----------------------------------------------------------------------------
  1038                                  ; 13/10/2018 - Retro DOS v3.0
  1039                                  
  1040                                  ;[BITS 16]
  1041                                  ;[ORG 0]
  1042 00000000 00<rep 100h>            		times 256 db 0
  1043                                  
  1044                                  ;============================================================================
  1045                                  ; TCODE.ASM, MSDOS 6.0, 1991
  1046                                  ;============================================================================
  1047                                  ; 12/10/2018 - Retro DOS v3.0
  1048                                  
  1049                                  ;[ORG 100h]
  1050                                  
  1051                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0100h
  1052                                  
  1053                                  ; ---------------------------------------------------------------------------
  1054                                  
  1055                                  SETDRV:					; Allow for 100H parameter area
  1056 00000100 B40E                    		mov	ah,SET_DEFAULT_DRIVE ; 0Eh
  1057 00000102 CD21                    		int	21h	; DOS -	SELECT DISK
  1058                                  				; DL = new default drive number	(0 = A,	1 = B,etc.)
  1059                                  				; Return: AL = number of logical drives
  1060                                  
  1061                                  ; ---------------------------------------------------------------------------
  1062                                  
  1063                                  ; TCOMMAND is the recycle point in COMMAND. Nothing is known here.
  1064                                  ; No registers (CS:IP) no flags, nothing.
  1065                                  
  1066                                  TCOMMAND:
  1067 00000104 2E8E1E[8141]            		mov	ds,[cs:RESSEG]
  1068 00000109 B8FFFF                  		mov	ax,-1
  1069 0000010C 8706F10B                		xchg	ax,[VERVAL]
  1070 00000110 83F8FF                  		cmp	ax,-1
  1071 00000113 7404                    		jz	short NOSETVER2
  1072 00000115 B42E                    		mov	ah,SET_VERIFY_ON_WRITE ; 2Eh
  1073 00000117 CD21                    		int	21h	; DOS -	SET VERIFY FLAG
  1074                                  				; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
  1075                                  NOSETVER2:
  1076 00000119 2EFF1E[7F41]            		call	far [cs:HEADCALL]   ; Make sure header fixed
  1077 0000011E 31ED                    		xor	bp,bp		    ; Flag transient not read
  1078 00000120 833EEF0BFF              		cmp	word [SINGLECOM],-1
  1079 00000125 7505                    		jnz	short COMMAND
  1080                                  _$EXITPREP:
  1081 00000127 0E                      		push	cs
  1082 00000128 1F                      		pop	ds
  1083 00000129 E9FA14                  		jmp	_$EXIT		; Have finished the single command
  1084                                  
  1085                                  ; ---------------------------------------------------------------------------
  1086                                  ;
  1087                                  ; Main entry point from resident portion.
  1088                                  ;
  1089                                  ;   If BP <> 0, then we have just loaded transient portion otherwise we are
  1090                                  ;   just beginning the processing of another command.
  1091                                  ;
  1092                                  ; ---------------------------------------------------------------------------
  1093                                  
  1094                                  ; We are not always sure of the state of the world at this time. We presume
  1095                                  ; worst case and initialize the relevant registers: segments and stack.
  1096                                  
  1097                                  COMMAND:
  1098 0000012C FC                      		cld
  1099 0000012D 8CC8                    		mov	ax,cs
  1100 0000012F FA                      		cli
  1101 00000130 8ED0                    		mov	ss,ax
  1102                                  		;MOV	SP,OFFSET TRANGROUP:STACK
  1103 00000132 BC[084C]                		mov	sp,STACK
  1104 00000135 FB                      		sti
  1105                                  		
  1106 00000136 8EC0                    		MOV	ES,AX
  1107                                  		
  1108                                  		; MSDOS 6.0
  1109                                  		;MOV	DS,AX		;AN000; set DS to transient
  1110                                  		;ASSUME	ES:TRANGROUP,DS:TRANGROUP ;AC000;
  1111                                  		;invoke	TSYSLOADMSG	;AN000; preload messages
  1112                                  		;mov	append_exec,0	;AN041; set internal append state off
  1113                                  
  1114                                  		; MSDOS 3.3 (& MSDOS 6.0)
  1115 00000138 368E1E[8141]            		mov	ds,[ss:RESSEG]
  1116 0000013D 36C606[5D3F]80          		mov	byte [ss:UCOMBUF],128 ; Init UCOMBUF	
  1117 00000143 36C606[E03F]80          		mov	byte [ss:COMBUF],128  ; Init COMBUF (Autoexec doing DATE)
  1118                                  
  1119                                  ; If we have just loaded the transient, then we do NOT need to initialize the
  1120                                  ; command buffer. ????  DO WE NEED TO RESTORE THE USERS DIRECTORY ????
  1121                                  ; I guess not:  the only circumstances in which we reload the command processor
  1122                                  ; is after a transient program execution. In this case, we let the current
  1123                                  ; directory lie where it may.
  1124                                  
  1125 00000149 09ED                    		or	bp,bp		; See if just read
  1126 0000014B 7409                    		jz	short TESTRDIR	; Not read, check user directory
  1127 0000014D 36C706[5E3F]010D        		mov	word [ss:UCOMBUF+1],0D01h ; Reset buffer
  1128 00000154 EB17                    		jmp	short NOSETBUF
  1129                                  TESTRDIR:
  1130 00000156 803EED0B00              		cmp	byte [RESTDIR],0
  1131 0000015B 7410                    		jz	short NOSETBUF	; User directory OK
  1132 0000015D 1E                      		push	ds
  1133                                  
  1134                                  ; We have an unusual situation to handle. The user *may* have changed his
  1135                                  ; directory as a result of an internal command that got aborted. Restoring it
  1136                                  ; twice may not help us: the problem may never go away. We just attempt it
  1137                                  ; once and give up.
  1138                                  
  1139 0000015E C606ED0B00              		mov	byte [RESTDIR],0 ; Flag users dirs OK
  1140                                  
  1141                                  		; Restore users directory
  1142 00000163 0E                      		push	cs
  1143 00000164 1F                      		pop	ds
  1144 00000165 BA[6340]                		mov	dx,USERDIR1
  1145 00000168 B43B                    		mov	ah,CHDIR ; 3Bh
  1146 0000016A CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  1147                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  1148 0000016C 1F                      		pop	ds
  1149                                  NOSETBUF:
  1150 0000016D 803E570C00              		cmp	byte [PIPEFILES],0
  1151 00000172 740A                    		jz	short NOPCLOSE	; Don't bother if they don't exist
  1152 00000174 803E560C00              		cmp	byte [PIPEFLAG],0
  1153 00000179 7503                    		jnz	short NOPCLOSE	; Don't del if still piping
  1154 0000017B E8471D                  		call	PIPEDEL
  1155                                  NOPCLOSE:
  1156                                  		;mov	byte [0BE9h],0	; MSDOS 3.3
  1157 0000017E C606E50B00              		mov	byte [EXTCOM],0 ; Flag internal command
  1158 00000183 8CC8                    		mov	ax,cs		; Get segment we're in
  1159 00000185 8ED8                    		mov	ds,ax
  1160 00000187 50                      		push	ax
  1161 00000188 BA[084C]                		mov	dx,INTERNATVARS
  1162 0000018B B80038                  		mov	ax,INTERNATIONAL*256 ; 3800h
  1163 0000018E CD21                    		int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
  1164                                  				; get current-country info
  1165                                  				; DS:DX	-> buffer for returned info
  1166 00000190 58                      		pop	ax
  1167 00000191 2B06[8341]              		sub	ax,[TPA]	; AX=size of TPA in paragraphs
  1168 00000195 53                      		push	bx
  1169 00000196 BB1000                  		mov	bx,16
  1170 00000199 F7E3                    		mul	bx		; DX:AX=size of TPA in bytes
  1171 0000019B 5B                      		pop	bx
  1172 0000019C 09D2                    		or	dx,dx		; See if over 64K
  1173 0000019E 7403                    		jz	short SAVSIZ	; OK if not
  1174 000001A0 B8FFFF                  		mov	ax,-1		; If so, limit to 65535 bytes
  1175                                  SAVSIZ:
  1176                                  
  1177                                  ; AX is the number of bytes free in the buffer between the resident and the
  1178                                  ; transient with a maximum of 64K-1. We round this down to a multiple of 512.
  1179                                  
  1180 000001A3 3D0002                  		cmp	ax,512
  1181 000001A6 7603                    		jbe	short GOTSIZE
  1182                                  		;and	ax,~1FFh
  1183 000001A8 2500FE                  		and	ax,0FE00h	; NOT 511 = NOT 1FF
  1184                                  GOTSIZE:
  1185 000001AB A3[A241]                		mov	[BYTCNT],ax	; Max no. of bytes that can be buffered
  1186 000001AE 8E1E[8141]              		mov	ds,[RESSEG]	; All batch work must use resident seg.
  1187                                  
  1188 000001B2 F606E90B01              		test	byte [ECHOFLAG],1 
  1189 000001B7 741E                    		jz	short GETCOM	; Don't do the CRLF
  1190 000001B9 E8E81C                  		call	SINGLETEST
  1191 000001BC 7219                    		jb	short GETCOM
  1192 000001BE F606560CFF              		test	byte [PIPEFLAG],0FFh ; -1
  1193 000001C3 7512                    		jnz	short GETCOM
  1194                                  					; G  Don't print prompt in FOR
  1195 000001C5 F606F50BFF              		test	byte [FORFLAG],0FFh ; -1
  1196 000001CA 750B                    		jnz	short GETCOM
  1197                                  					; G  Don't print prompt if in batch
  1198 000001CC F706930BFFFF            		test	word [BATCH],0FFFFh ; -1
  1199 000001D2 7503                    		jnz	short GETCOM
  1200 000001D4 E86217                  		call	CRLF2
  1201                                  GETCOM:
  1202 000001D7 C606FA0B00              		mov	byte [CALL_FLAG],0 ; G Reset call flags
  1203 000001DC C606FB0B00              		mov	byte [CALL_BATCH_FLAG],0
  1204 000001E1 B419                    		mov	ah,GET_DEFAULT_DRIVE ; 19h
  1205 000001E3 CD21                    		int	21h	; DOS -	GET DEFAULT DISK NUMBER
  1206 000001E5 36A2[9541]              		mov	[ss:CURDRV],al
  1207 000001E9 F606560CFF              		test	byte [PIPEFLAG],0FFh ; -1 ; Pipe has highest presedence
  1208 000001EE 7403                    		jz	short NOPIPE
  1209 000001F0 E9711D                  		jmp	PIPEPROC	; Continue the pipeline
  1210                                  NOPIPE:
  1211 000001F3 F606E90B01              		test	byte [ECHOFLAG],1
  1212 000001F8 7417                    		jz	short NOPDRV	; No prompt if echo off
  1213 000001FA E8A71C                  		call	SINGLETEST
  1214 000001FD 7212                    		jb	short NOPDRV
  1215 000001FF F606F50BFF              		test	byte [FORFLAG],0FFh ; G  Don't print prompt in FOR	
  1216 00000204 750B                    		jnz	short NOPDRV
  1217 00000206 F706930BFFFF            		test	word [BATCH],0FFFFh ; G  Don't print prompt if in batch
  1218 0000020C 750D                    		jnz	short TESTFORBAT
  1219 0000020E E85D11                  		call	PRINT_PROMPT	; Prompt the user
  1220                                  NOPDRV:
  1221 00000211 F606F50BFF              		test	byte [FORFLAG],0FFh ; FOR has next highest precedence
  1222 00000216 7403                    		jz	short TESTFORBAT
  1223 00000218 E9F909                  		jmp	FORPROC		; Continue the FOR
  1224                                  
  1225                                  TESTFORBAT:
  1226 0000021B 36C606[2C41]00          		mov	byte [ss:RE_INSTR],0 ; Turn redirection back off	
  1227 00000221 C606050C00              		mov	byte [RE_OUTSTR],0  ; [0C09h] for MSDOS 3.3 
  1228 00000226 C606040C00              		mov	byte [RE_OUT_APP],0 ; [0C08h] for MSDOS 3.3
  1229 0000022B C606F40B00              		mov	byte [IFFLAG],0	; no more ifs...
  1230 00000230 F706930BFFFF            		test	word [BATCH],0FFFFh ; Batch has lowest precedence
  1231 00000236 7429                    		jz	short ISNOBAT
  1232                                  
  1233                                  		; MSDOS 6.0
  1234                                  
  1235                                  ;	Bugbug:	MULT_SHELL_GET no longer used?
  1236                                  
  1237                                  		;push	es			;AN000; save ES
  1238                                  		;push	ds			;AN000; save DS
  1239                                  		;mov	ax,mult_shell_get	;AN000; check to see if SHELL has command
  1240                                  		;mov	es,[batch]		;AN000; get batch segment
  1241                                  		;mov	di,batfile		;AN000; get batch file name
  1242                                  		;push	cs			;AN000; get local segment to DS
  1243                                  		;pop	ds			;AN000;
  1244                                  		;mov	dx,offset trangroup:combuf ;AN000; pass communications buffer
  1245                                  		;int	2fh			;AN000; call the shell
  1246                                  		;cmp	al,shell_action 	;AN000; does shell have a commmand?
  1247                                  		;pop	ds			;AN000; restore DS
  1248                                  		;pop	es			;AN000; restore ES
  1249                                  		;jz	jdocom1 		;AN000; yes - go process command
  1250                                  
  1251                                  		; MSDOS 3.3 (& MSDOS 6.0)
  1252 00000238 1E                      		push	ds
  1253 00000239 E8BB02                  		call	READBAT			; Continue BATCH
  1254 0000023C 1F                      		pop	ds
  1255 0000023D C606FE0B00              		mov	byte [NULLFLAG],0	;G reset no command flag
  1256 00000242 F706930BFFFF            		test	word [BATCH],0FFFFh
  1257 00000248 7513                    		jnz	short JDOCOM1		;G if batch still in progress continue
  1258 0000024A 8B1EFC0B                		mov	bx,[NEXT_BATCH]
  1259 0000024E 83FB00                  		cmp	bx,0			;G see if there is a new batch file
  1260 00000251 740A                    		jz	short JDOCOM1		;G no - go do command
  1261 00000253 891E930B                		mov	[BATCH],bx		;G get segment of next batch file
  1262 00000257 C706FC0B0000            		mov	word [NEXT_BATCH],0	;G reset next batch
  1263                                  JDOCOM1:
  1264 0000025D 0E                      		push	cs
  1265 0000025E 1F                      		pop	ds
  1266 0000025F EB4C                    		jmp	short DOCOM1
  1267                                  
  1268 00000261 833EEF0B00              ISNOBAT:	cmp	word [SINGLECOM],0
  1269 00000266 741C                    		jz	short REGCOM
  1270                                  		;mov	si,[SEMIPERMCOM] ;  MSDOS 6.0
  1271 00000268 BEFFFF                  		mov	si,0FFFFh 	 ;  MSDOS 3.3
  1272 0000026B 8736EF0B                		xchg	si,[SINGLECOM]
  1273 0000026F BF[E23F]                		mov	di,COMBUF+2
  1274 00000272 31C9                    		xor	cx,cx
  1275                                  SINGLELOOP:
  1276 00000274 AC                      		lodsb
  1277 00000275 AA                      		stosb
  1278 00000276 41                      		inc	cx
  1279 00000277 3C0D                    		cmp	al,0Dh
  1280 00000279 75F9                    		jnz	short SINGLELOOP
  1281 0000027B 49                      		dec	cx
  1282 0000027C 0E                      		push	cs
  1283 0000027D 1F                      		pop	ds
  1284 0000027E 880E[E13F]              		mov	[COMBUF+1],cl
  1285                                  
  1286                                  ; do NOT issue a trailing CRLF...
  1287                                  
  1288 00000282 EB29                    		jmp	short DOCOM1
  1289                                  
  1290                                  		;nop
  1291                                  
  1292                                  ; We have a normal command.  
  1293                                  ; Printers are a bizarre quantity. Sometimes they are a stream and
  1294                                  ; sometimes they aren't. At this point, we automatically close all spool
  1295                                  ; files and turn on truncation mode.
  1296                                  
  1297                                  REGCOM:
  1298                                  		;MOV	AX,(ServerCall SHL 8) + 9
  1299                                  		;mov	ax,5D09h
  1300 00000284 B8095D                  		mov	ax,(SERVERCALL<<8)+9
  1301 00000287 CD21                    		int	21h	; DOS -	3.1+ internal -	FLUSH REDIRECTED PRINTER OUTPUT
  1302                                  		;MOV	AX,(ServerCall SHL 8) + 8
  1303                                  		;mov	ax,5D08h
  1304 00000289 B8085D                  		mov	ax,(SERVERCALL<<8)+8
  1305 0000028C B201                    		mov	dl,1
  1306 0000028E CD21                    		int	21h	; DOS -	3.1+ internal -	SET REDIRECTED PRINTER MODE
  1307                                  				; DL = 00h redirected output is	combined
  1308                                  				;      01h redirected output placed in separate	jobs
  1309                                  				; start	new print job now
  1310 00000290 0E                      		push	cs
  1311 00000291 1F                      		pop	ds	; Need local segment to point to buffer
  1312 00000292 BA[5D3F]                		mov	dx,UCOMBUF
  1313                                  
  1314                                  		; MSDOS 6.0
  1315                                  ;	Try to read interactive command line via DOSKey.
  1316                                  ;	If that fails, use DOS Buffered Keyboard Input.
  1317                                  
  1318                                  		;mov	ax,4810h	; AX = DOSKey Read Line function
  1319                                  		;int	2fh
  1320                                  		;or	ax,ax
  1321                                  		;jz	GOTCOM		; DOSKey gave us a command line
  1322                                  
  1323                                  		;mov	ah,0Ah
  1324 00000295 B40A                    		mov	ah,STD_CON_STRING_INPUT	; AH = DOS Buffered Keyboard Input
  1325 00000297 CD21                    		int	21h	; DOS -	BUFFERED KEYBOARD INPUT
  1326                                  				; DS:DX	-> buffer
  1327                                  ;GOTCOM:
  1328 00000299 8A0E[5D3F]              		mov	cl,[UCOMBUF]
  1329 0000029D 30ED                    		xor	ch,ch
  1330 0000029F 83C103                  		add	cx,3
  1331 000002A2 BE[5D3F]                		mov	si,UCOMBUF
  1332 000002A5 BF[E03F]                		mov	di,COMBUF
  1333 000002A8 F3A4                    		rep movsb		; Transfer it to the cooked buffer
  1334                                  DOCOM:
  1335 000002AA E88C16                  		call	CRLF2
  1336                                  DOCOM1:
  1337 000002AD E84019                  		call	PRESCAN		; Cook the input buffer
  1338 000002B0 7406                    		jz	short NOPIPEPROC
  1339 000002B2 E95A1C                  		jmp	PIPEPROCSTRT	; Fire up the pipe
  1340                                  NULLCOMJ:
  1341 000002B5 E9F900                  		jmp	NULLCOM
  1342                                  NOPIPEPROC:
  1343 000002B8 E87520                  		call	PARSELINE
  1344 000002BB 730B                    		jnb	short OKPARSE	; user error?  or maybe we goofed?
  1345                                  BADPARSE:
  1346 000002BD 0E                      		push	cs
  1347 000002BE 1F                      		pop	ds
  1348 000002BF BA[EB36]                		mov	dx,BADNAMPTR
  1349 000002C2 E85A31                  		call	STD_EPRINTF
  1350 000002C5 E93CFE                  		jmp	TCOMMAND
  1351                                  OKPARSE:
  1352                                  		;test	byte [ARGV0_ARG_FLAGS],2
  1353 000002C8 F606[BB44]02            		test	byte [ARG+ARGV_ELE.argflags],wildcard
  1354 000002CD 75EE                    		jnz	short BADPARSE	; ambiguous commands not allowed
  1355                                  		;cmp	word [ARG_ARGVCNT],0  ; there WAS a command, wasn't there?
  1356 000002CF 833E[7947]00            		cmp	word [ARG+ARG_UNIT.argvcnt],0
  1357 000002D4 74DF                    		jz	short NULLCOMJ
  1358                                  		;cmp	word [ARGV0_ARGLEN],0 ; probably an unnecessary check...
  1359 000002D6 833E[BE44]00            		cmp	word [ARG+ARGV_ELE.arglen],0
  1360 000002DB 74D8                    		jz	short NULLCOMJ	; guarantees argv[0] at least x<NULL>
  1361                                  
  1362 000002DD BE[E23F]                		mov	si,COMBUF+2
  1363 000002E0 BF[FB41]                		mov	di,IDLEN
  1364                                  		;MOV	AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR 01H
  1365                                  					; Make FCB with blank scan-off
  1366 000002E3 B80129                  		mov	ax,(PARSE_FILE_DESCRIPTOR<<8)|01h
  1367                                  		;mov	ax,2901h
  1368 000002E6 CD21                    		int	21h	; DOS -	PARSE FILENAME
  1369                                  				; DS:SI	-> string to parse
  1370                                  				; ES:DI	-> buffer to fill with unopened	FCB
  1371                                  				; AL = bit mask	to control parsing
  1372                                  		;mov	bx,[ARG_ARGV]
  1373 000002E8 8B1E[B944]              		mov	bx,[ARG+ARG_UNIT.argv] ; mov bx,[ARG]
  1374 000002EC 807F013A                		cmp	byte [bx+1],':'	; was a drive specified?
  1375 000002F0 751B                    		jne	short DRVGD	; no, use default of zero...
  1376 000002F2 8A17                    		mov	dl,[bx]		; pick-up drive letter
  1377                                  		;mov	dl,[bx+ARGV_ELE.argpointer] ; mov dl,[bx+0]
  1378                                  		;and	dl,~20h
  1379 000002F4 80E2DF                  		and	dl,0DFh		; uppercase the sucker
  1380                                  		;sub	dl,[CAPITAL_A]	; convert it to a drive number, A=0
  1381                                  		; 01/03/2023
  1382 000002F7 80EA41                  		sub	dl,capital_A  ; sub dl,'A'
  1383 000002FA 3CFF                    		cmp	al,-1		; See what PARSE said about our drive letter.
  1384 000002FC 740C                    		jz	short DRVBADJ	; It was invalid.
  1385                                  		;mov	di,[ARGV0_ARGSTARTEL]
  1386 000002FE 8B3E[BC44]              		mov	di,[ARG+ARGV_ELE.argstartel]
  1387 00000302 803D00                  		cmp	byte [di],0	; is there actually a command there?
  1388 00000305 7506                    		jne	short DRVGD	; if not, we have:  "d:", "d:\", "d:/"
  1389 00000307 E9F6FD                  		jmp	SETDRV		; and set drive to new drive spec
  1390                                  DRVBADJ:
  1391 0000030A E99617                  		jmp	DRVBAD
  1392                                  DRVGD:
  1393 0000030D 8A05                    		mov	al,[di]
  1394 0000030F A2[A141]                		mov	[SPECDRV],al
  1395 00000312 B020                    		mov	al,' '
  1396 00000314 B90900                  		mov	cx,9
  1397 00000317 47                      		inc	di
  1398 00000318 F2AE                    		repne scasb		; Count number of letters in command name
  1399 0000031A B008                    		mov	al,8
  1400 0000031C 28C8                    		sub	al,cl
  1401 0000031E A2[FB41]                		mov	[IDLEN],al	; IDLEN is truly the length
  1402 00000321 BF8100                  		mov	di,81h
  1403 00000324 56                      		push	si
  1404 00000325 BE[E23F]                		mov	si,COMBUF+2	; Skip over all leading delims
  1405 00000328 E81B16                  		call	SCANOFF
  1406                                  
  1407                                  		; MSDOS 6.0
  1408                                  ;SR;
  1409                                  ; We are going to skip over the first char always. The logic is that the
  1410                                  ;command tail can never start from the first character. The code below is 
  1411                                  ;trying to figure out the command tail and copy it to the command line 
  1412                                  ;buffer in the PSP. However, if the first character happens to be a switch
  1413                                  ;character and the user given command line is a full 128 bytes, we try to
  1414                                  ;copy 128 bytes to the PSP while it can take only 127 chars. This extra
  1415                                  ;char overwrites the code and leads to a crash on future commands.
  1416                                  ;
  1417                                  		;inc	si ;  MSDOS 6.0
  1418                                  DO_SKIPCOM:
  1419 0000032B AC                      		lodsb			; move command line pointer over
  1420 0000032C E81F16                  		call	DELIM		; pathname -- have to do it ourselves
  1421 0000032F 740A                    		jz	short DO_SKIPPED ; 'cause parse_file_descriptor is dumb
  1422 00000331 3C0D                    		cmp	al,0Dh		; can't always depend on argv[0].arglen
  1423 00000333 7406                    		jz	short DO_SKIPPED ; to be the same length as the user-
  1424 00000335 3A06[8541]              		cmp	al,[SWITCHAR]	; specified command string
  1425 00000339 75F0                    		jnz	short DO_SKIPCOM 
  1426                                  DO_SKIPPED:
  1427 0000033B 4E                      		dec	si
  1428 0000033C 31C9                    		xor	cx,cx
  1429                                  COMTAIL:
  1430 0000033E AC                      		lodsb
  1431 0000033F AA                      		stosb			; Move command tail to 80h
  1432 00000340 3C0D                    		cmp	al,0Dh
  1433 00000342 E0FA                    		loopne	COMTAIL
  1434 00000344 4F                      		dec	di
  1435 00000345 89FD                    		mov	bp,di
  1436 00000347 F6D1                    		not	cl
  1437 00000349 880E8000                		mov	[80h],cl
  1438 0000034D 5E                      		pop	si
  1439                                  ;-----
  1440                                  ; Some of these comments are sadly at odds with this brave new code.
  1441                                  ;-----
  1442                                  ; If the command has 0 parameters must check here for
  1443                                  ; any switches that might be present.
  1444                                  ; SI -> first character after the command.
  1445                                  
  1446                                  		;mov	di, arg.argv[0].argsw_word
  1447                                  		;mov	di,[ARGV0_ARGSW_WORD]
  1448 0000034E 8B3E[C044]              		mov	di,[ARG+ARGV_ELE.argsw_word]
  1449 00000352 893E[9841]              		mov	[COMSW],di	; ah yes, the old addressing mode problem...
  1450                                  		;mov	SI,arg.argv[1 * SIZE argv_ele].argpointer  
  1451                                  					; s = argv[1];
  1452                                  		;mov	si,[ARGV1_ARGPOINTER]
  1453 00000356 8B36[C444]              		mov	si,[ARG+ARGV_ELE.SIZE+ARGV_ELE.argpointer]
  1454 0000035A 09F6                    		or	si,si		;   if (s == NULL)
  1455 0000035C 7502                    		jnz	short DOPARSE	;	s = bp; (buffer end)
  1456 0000035E 89EE                    		mov	si,bp
  1457                                  DOPARSE:
  1458 00000360 BF5C00                  		mov	di,FCB ; 5Ch
  1459                                  		;MOV	AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR 01H
  1460                                  		;mov	ax,2901h
  1461 00000363 B80129                  		mov	ax,(PARSE_FILE_DESCRIPTOR<<8)|01h
  1462 00000366 CD21                    		int	21h	; DOS -	PARSE FILENAME
  1463                                  				; DS:SI	-> string to parse
  1464                                  				; ES:DI	-> buffer to fill with unopened	FCB
  1465                                  				; AL = bit mask	to control parsing
  1466 00000368 A2[9641]                		mov	[PARM1],al	; Save result of parse
  1467                                  		;mov	di,arg.argv[1*SIZE argv_ele].argsw_word
  1468                                  		;mov	di,[ARGV1_ARGSW_WORD]
  1469 0000036B 8B3E[CB44]              		mov	di,[ARG+ARGV_ELE.SIZE+ARGV_ELE.argsw_word]
  1470 0000036F 893E[9A41]              		mov	[ARG1S],di
  1471                                  		;mov	si,arg.argv[2*SIZE argv_ele].argpointer    
  1472                                  					; s = argv[2];
  1473                                  		;mov	si,[ARGV2_ARGPOINTER]
  1474 00000373 8B36[CF44]              		mov	si,[ARG+(2*ARGV_ELE.SIZE)+ARGV_ELE.argpointer]
  1475 00000377 09F6                    		or	si,si		;   if (s == NULL)
  1476 00000379 7502                    		jnz	short DOPARSE2
  1477 0000037B 89EE                    		mov	si,bp		;	s = bp; (buffer end)
  1478                                  DOPARSE2:			
  1479 0000037D BF6C00                  		mov	di,FCB+10H ; 6Ch
  1480                                  		;MOV	AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR 01H
  1481                                  		;mov	ax,2901h
  1482 00000380 B80129                  		mov	ax,(PARSE_FILE_DESCRIPTOR<<8)|01h
  1483 00000383 CD21                    		int	21h	; DOS -	PARSE FILENAME
  1484                                  				; DS:SI	-> string to parse
  1485                                  				; ES:DI	-> buffer to fill with unopened	FCB
  1486                                  				; AL = bit mask	to control parsing
  1487 00000385 A2[9741]                		mov	[PARM2],al	; Save result
  1488                                  		;mov	di,[ARGV2_ARGSW_WORD]
  1489                                  		;mov	di,arg.argv[2*SIZE argv_ele].argsw_word
  1490 00000388 8B3E[D644]              		mov	di,[ARG+(2*ARGV_ELE.SIZE)+ARGV_ELE.argsw_word]
  1491 0000038C 893E[9C41]              		mov	[ARG2S],di
  1492                                  		;mov	di,[ARGV0_ARGSW_WORD]
  1493                                  		;mov	di,arg.argv[0].argsw_word
  1494 00000390 8B3E[C044]              		mov	di,[ARG+ARGV_ELE.argsw_word]
  1495 00000394 F7D7                    		not	di		; ARGTS doesn't include the flags
  1496                                  		;and	di,[ARG_ARGSWINFO]	; from COMSW...
  1497                                  		;and	di,arg.argswinfo	
  1498 00000396 233E[7B47]              		and	di,[ARG+ARG_UNIT.argswinfo]
  1499 0000039A 893E[9E41]              		mov	[ARGTS],di
  1500                                  
  1501 0000039E A0[FB41]                		mov	al,[IDLEN]
  1502 000003A1 8A16[A141]              		mov	dl,[SPECDRV]
  1503 000003A5 08D2                    		or	dl,dl		; if a drive was specified...
  1504 000003A7 7505                    		jnz	short EXTERNALJ1 ; it MUST be external, by this time
  1505 000003A9 FEC8                    		dec	al		; (I don't know why -- old code did it)
  1506 000003AB E9FE16                  		jmp	FNDCOM		; otherwise, check internal com table
  1507                                  EXTERNALJ1:
  1508 000003AE E9A817                  		jmp	EXTERNAL
  1509                                  NULLCOM:
  1510 000003B1 8E1E[8141]              		mov	ds,[RESSEG]
  1511 000003B5 F706930BFFFF            		test	word [BATCH],0FFFFh ; -1 ;G Are we in a batch file?
  1512 000003BB 7405                    		jz	short NOSETFLAG	  ;G only set flag if in batch
  1513                                  		;mov	byte [NULLFLAG],1 ;G set flag to indicate no command
  1514 000003BD C606FE0B01              		mov	byte [NULLFLAG],nullcommand ; 1
  1515                                  NOSETFLAG:
  1516 000003C2 833EEF0BFF              		cmp	word [SINGLECOM],0FFFFh ; -1
  1517 000003C7 7403                    		jz	short EXITJ
  1518 000003C9 E90BFE                  		jmp	GETCOM
  1519                                  EXITJ:
  1520 000003CC E958FD                  		jmp	_$EXITPREP
  1521                                  
  1522                                  ;============================================================================
  1523                                  ; MSHALO.ASM, MSDOS 6.0, 1991
  1524                                  ;============================================================================
  1525                                  ; 12/10/2018 - Retro DOS v3.0
  1526                                  
  1527                                  ;	SCCSID = @(#)ibmhalo.asm	1.1 85/04/10
  1528                                  ;   On 2K (800h) boundaries beginning at address C0000h and ending at EF800h
  1529                                  ;   there is a header that describes a block of rom program.  This header
  1530                                  ;   contains information needed to initialize a module and to provide PCDOS
  1531                                  ;   with a set of reserved names for execution.
  1532                                  ;
  1533                                  ;   This header has the following format:
  1534                                  ;
  1535                                  ;   rom_header	STRUC
  1536                                  ;	Signature1  DB	55h
  1537                                  ;	Signature2  DB	AAh
  1538                                  ;	rom_length  DB	?		; number of 512 byte pieces
  1539                                  ;	init_jmp    DB	3 dup (?)
  1540                                  ;	name_list   name_struc <>
  1541                                  ;   rom_header	ENDS
  1542                                  ;
  1543                                  ;   name_struc	STRUC
  1544                                  ;	name_len    DB	?
  1545                                  ;	name_text   DB	? DUP (?)
  1546                                  ;	name_jmp    DB	3 DUP (?)
  1547                                  ;   name_struc	ENDS
  1548                                  ;
  1549                                  ;   The name list is a list of names that are reserved by a particular section
  1550                                  ;   of a module.  This list of names is terminated by a null name (length
  1551                                  ;   is zero).
  1552                                  ;
  1553                                  ;   Consider now, the PCDOS action when a user enters a command:
  1554                                  ;
  1555                                  ;	COMMAND.COM has control.
  1556                                  ;	o   If location FFFFEh has FDh then
  1557                                  ;	o	Start scanning at C0000h, every 800h for a byte 55h followed
  1558                                  ;		    by AAh, stop scan if we get above or = F0000H
  1559                                  ;	o	When we've found one, compare the name entered by the user
  1560                                  ;		    with the one found in the rom.  If we have a match, then
  1561                                  ;		    set up the environment for execution and do a long jump
  1562                                  ;		    to the near jump after the found name.
  1563                                  ;	o	If no more names in the list, then continue scanning the module
  1564                                  ;		    for more 55h followed by AAh.
  1565                                  ;	o   We get to this point only if there is no matching name in the
  1566                                  ;		rom.  We now look on disk for the command.
  1567                                  ;
  1568                                  ;   This gives us the flexibility to execute any rom cartridge without having
  1569                                  ;   to 'hard-code' the name of the cartridge into PCDOS.  Rom modules that
  1570                                  ;   want to be invisible to the DOS should not have any names in their lists
  1571                                  ;   (i.e. they have a single null name).
  1572                                  ;
  1573                                  ;   Consider a new release of BASIC, say, that patches bugs in the ROM version.
  1574                                  ;   Clearly this version will be available on disk.  How does a user actually
  1575                                  ;   invoke this new BASIC??  He cannot call it BASIC on the disk because the
  1576                                  ;   EXEC loader will execute the ROM before it even looks at the disk!	Only
  1577                                  ;   solution:
  1578                                  ;
  1579                                  ;   o	Keep things consistent and force the user to have his software named
  1580                                  ;	differently from the ROM names (BASIC1, BASIC2, etc).
  1581                                  
  1582                                  struc ROM_HEADER
  1583 00000000 ??                          .signature1: resb 1
  1584 00000001 ??                          .signature2: resb 1
  1585 00000002 ??                          .rom_length: resb 1
  1586 00000003 ??????                      .init_jmp:	 resb 3
  1587 00000006 ??                          .name_list:	 resb 1
  1588                                      .size:
  1589                                  endstruc
  1590                                  
  1591                                  struc NAME_STRUC
  1592 00000000 ??                          .name_len:	resb 1
  1593 00000001 ??                          .name_text:	resb 1
  1594 00000002 ??????                      .name_jmp:	resb 3
  1595                                      .size:	
  1596                                  endstruc
  1597                                  
  1598                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 03D1h
  1599                                  
  1600                                  ; =============== S U B	R O U T	I N E =======================================
  1601                                  
  1602                                  ;ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING
  1603                                  
  1604                                  ; Check for IBM PC Jr rom cartrides. DS:DX is a pointer to name
  1605                                  
  1606                                  ROM_SCAN:
  1607 000003CF 06                      		push	es
  1608 000003D0 56                      		push	si
  1609 000003D1 57                      		push	di
  1610 000003D2 51                      		push	cx
  1611 000003D3 50                      		push	ax
  1612 000003D4 53                      		push	bx
  1613                                  
  1614                                  		; check for PC Jr signature in rom
  1615                                  
  1616 000003D5 B800F0                  		mov	ax,0F000h
  1617 000003D8 8EC0                    		mov	es,ax
  1618 000003DA 26803EFEFFFD            		cmp	byte [es:0FFFEh],0FDh
  1619 000003E0 7408                    		je	short SCAN_IT
  1620                                  NO_ROM:
  1621 000003E2 F8                      		clc
  1622                                  ROM_RET:
  1623 000003E3 5B                      		pop	bx
  1624 000003E4 58                      		pop	ax
  1625 000003E5 59                      		pop	cx
  1626 000003E6 5F                      		pop	di
  1627 000003E7 5E                      		pop	si
  1628 000003E8 07                      		pop	es
  1629 000003E9 C3                      		retn
  1630                                  
  1631                                  SCAN_IT:	; start scanning at C000h
  1632                                  
  1633 000003EA B800C0                  		mov	ax,0C000h
  1634                                  SCAN_ONE:
  1635 000003ED 8EC0                    		mov	es,ax
  1636 000003EF 31FF                    		xor	di,di
  1637                                  
  1638                                  SCAN_MODULE:	; check for a valid header
  1639                                  
  1640 000003F1 26813D55AA              		cmp	word [es:di],0AA55h
  1641 000003F6 740A                    		jz	short SCAN_LIST
  1642 000003F8 058000                  		add	ax,80h
  1643                                  SCAN_END:
  1644 000003FB 3D00F0                  		cmp	ax,0F000h
  1645 000003FE 72ED                    		jb	short SCAN_ONE
  1646 00000400 EBE0                    		jmp	short NO_ROM
  1647                                  
  1648                                  		; trundle down list of names
  1649                                  SCAN_LIST:
  1650                                  		;mov	bl,[es:di+2]
  1651                                  					; number of 512-byte jobbers
  1652 00000402 268A5D02                		mov	bl,[es:di+ROM_HEADER.rom_length]
  1653 00000406 30FF                    		xor	bh,bh		; nothing in the high byte
  1654 00000408 D1E3                    		shl	bx,1
  1655 0000040A D1E3                    		shl	bx,1		; number of paragraphs
  1656 0000040C 83C37F                  		add	bx,7Fh
  1657 0000040F 83E380                  		and	bx,0FF80h	; round to 2k	
  1658                                  		;mov	di,6
  1659 00000412 BF0200                  		mov	di,ROM_HEADER.rom_length
  1660                                  
  1661                                  		;nop
  1662                                  SCAN_NAME:
  1663 00000415 268A0D                  		mov	cl,[es:di]	; length of name
  1664 00000418 47                      		inc	di		; point to name
  1665 00000419 30ED                    		xor	ch,ch
  1666 0000041B 09C9                    		or	cx,cx		; zero length name
  1667 0000041D 7504                    		jnz	short SCAN_TEST	; nope... compare
  1668 0000041F 01D8                    		add	ax,bx		; yep, skip to next block
  1669 00000421 EBD8                    		jmp	short SCAN_END
  1670                                  
  1671                                  SCAN_TEST:	; compare a single name
  1672                                  
  1673 00000423 89D6                    		mov	si,dx
  1674 00000425 46                      		inc	si
  1675 00000426 F3A6                    		repe cmpsb		 ; compare name
  1676 00000428 7407                    		jz	short SCAN_FOUND ; success!
  1677                                  SCAN_NEXT:
  1678 0000042A 01CF                    		add	di,cx		; failure, next name piece
  1679 0000042C 83C703                  		add	di,3
  1680 0000042F EBE4                    		jmp	short SCAN_NAME
  1681                                  
  1682                                  SCAN_FOUND:	; found a name. save entry location
  1683                                  
  1684 00000431 803C3F                  		cmp	byte [si],'?'
  1685 00000434 7405                    		jz	short SCAN_SAVE
  1686 00000436 803C20                  		cmp	byte [si],' '
  1687 00000439 75EF                    		jnz	short SCAN_NEXT
  1688                                  SCAN_SAVE:
  1689 0000043B 2E8C06[7A43]            		mov	[cs:ROM_CS],es
  1690 00000440 2E893E[7843]            		mov	[cs:ROM_IP],di
  1691 00000445 F9                      		stc
  1692 00000446 EB9B                    		jmp	short ROM_RET
  1693                                  
  1694                                  ; ---------------------------------------------------------------------------
  1695                                  
  1696                                  ; execute a rom-placed body of code. allocate largest block
  1697                                  
  1698                                  ROM_EXEC:
  1699 00000448 BBFFFF                  		mov	bx,0FFFFh
  1700 0000044B B448                    		mov	ah,ALLOC ; 48h
  1701 0000044D CD21                    		int	21h	; DOS -	2+ - ALLOCATE MEMORY
  1702                                  				; BX = number of 16-byte paragraphs desired
  1703 0000044F B448                    		mov	ah,ALLOC ; 48h
  1704 00000451 CD21                    		int	21h	; DOS -	2+ - ALLOCATE MEMORY
  1705                                  				; BX = number of 16-byte paragraphs desired
  1706 00000453 53                      		push	bx
  1707 00000454 50                      		push	ax
  1708                                  
  1709                                  		; set terminate addresses
  1710                                  
  1711                                  		;mov	ax,2522h
  1712                                  		;mov	ax,(set_interrupt_vector SHL 8) + int_terminate
  1713 00000455 B82225                  		mov	ax,(SET_INTERRUPT_VECTOR<<8)+INT_TERMINATE
  1714 00000458 1E                      		push	ds
  1715 00000459 2E8E1E[8141]            		mov	ds,[cs:RESSEG]
  1716                                  		;mov	dx,offset RESGROUP:EXEC_WAIT
  1717                                  		;mov	dx,131h ; MSDOS 3.3
  1718 0000045E BA3101                  		mov	dx,EXEC_WAIT
  1719 00000461 CD21                    		int	21h	; DOS -	SET INTERRUPT VECTOR
  1720                                  				; AL = interrupt number
  1721                                  				; DS:DX	= new vector to	be used	for specified interrupt
  1722 00000463 8CDA                    		mov	dx,ds
  1723 00000465 8EC2                    		mov	es,dx
  1724 00000467 1F                      		pop	ds
  1725                                  		
  1726                                  		; and create program header and dup all jfn's
  1727                                  
  1728 00000468 5A                      		pop	dx
  1729 00000469 B455                    		mov	ah,DUP_PDB ; 55h
  1730 0000046B CD21                    		int	21h	; DOS -	2+ internal - CREATE PSP
  1731                                  				; DX = segment number at which to set up PSP
  1732                                  				; SI = (DOS 3+)	value to place in memory size field at DX:[0002h]
  1733                                  		
  1734                                  		; set up dma address
  1735                                  
  1736 0000046D 8EDA                    		mov	ds,dx
  1737 0000046F BA8000                  		mov	dx,80h
  1738 00000472 B41A                    		mov	ah,SET_DMA ; 1Ah
  1739 00000474 CD21                    		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
  1740                                  				; DS:DX	-> disk	transfer buffer
  1741                                  
  1742                                  		; copy in environment info
  1743                                  
  1744 00000476 26A1FF0C                		mov	ax,[es:ENVIRSEG]
  1745 0000047A A32C00                  		mov	[PDB.ENVIRON],	ax
  1746                                  
  1747                                  		; set up correct size of block
  1748                                  
  1749 0000047D 5B                      		pop	bx		; BX has size, DS has segment
  1750 0000047E 8CDA                    		mov	dx,ds
  1751 00000480 01DA                    		add	dx,bx
  1752                                  		;mov	[2],dx
  1753 00000482 89160200                		mov	[PDB.BLOCK_LEN],dx
  1754                                  
  1755                                  		; change ownership of block
  1756                                  
  1757 00000486 8CDA                    		mov	dx,ds
  1758 00000488 4A                      		dec	dx
  1759 00000489 8EDA                    		mov	ds,dx
  1760 0000048B 42                      		inc	dx	
  1761                                  		;mov	[1],dx
  1762 0000048C 89160100                		mov	[ARENA.owner],dx
  1763 00000490 8EDA                    		mov	ds,dx
  1764                                  
  1765                                  		; set up correct stack
  1766                                  
  1767 00000492 81FB0010                		cmp	bx,1000h
  1768 00000496 7202                    		jb	short GOT_STACK
  1769 00000498 31DB                    		xor	bx,bx
  1770                                  GOT_STACK:
  1771 0000049A B104                    		mov	cl,4
  1772 0000049C D3E3                    		shl	bx,cl
  1773 0000049E 8CDA                    		mov	dx,ds
  1774 000004A0 8ED2                    		mov	ss,dx
  1775 000004A2 89DC                    		mov	sp,bx
  1776 000004A4 31C0                    		xor	ax,ax
  1777 000004A6 50                      		push	ax
  1778                                  
  1779                                  		; set up initial registers and go to the guy
  1780                                  
  1781 000004A7 F7D0                    		not	ax
  1782 000004A9 2EFF36[7A43]            		push	word [cs:ROM_CS]
  1783 000004AE 2EFF36[7843]            		push	word [cs:ROM_IP]
  1784 000004B3 8EC2                    		mov	es,dx
  1785 000004B5 CB                      		retf	; far return
  1786                                  
  1787                                  ;============================================================================
  1788                                  ; TBATCH.ASM, MSDOS 6.0, 1991
  1789                                  ;============================================================================
  1790                                  ; 12/10/2018 - Retro DOS v3.0
  1791                                  
  1792                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 04B9h
  1793                                  
  1794                                  ; =============== S U B	R O U T	I N E =======================================
  1795                                  
  1796                                  ;Break	<PromptBat - Open or wait for batch file>
  1797                                  
  1798                                  ; Open the batch file. If we cannot find the batch file. If the media is
  1799                                  ; changeable, we prompt for the change. Otherwise, we terminate the batch
  1800                                  ; file. Leave segment registers alone.
  1801                                  
  1802                                  PROMPTBAT:
  1803 000004B6 E8EB06                  		call	BATOPEN
  1804 000004B9 7201                    		jc	short PROMPTBAT1
  1805 000004BB C3                      		retn
  1806                                  PROMPTBAT1:
  1807                                  		; MSDOS 6.0 COMMAND.COM
  1808                                  		;cmp	dx,error_file_not_found ;AN022; Ask for diskette if file not found
  1809                                  		;jz	Bat_Remcheck		;AN022;
  1810                                  		;cmp	dx,error_path_not_found ;AN022; Ask for diskette if path not found
  1811                                  		;jz	Bat_Remcheck		;AN022;    Otherwise, issue message and exit
  1812                                  		;invoke	output_batch_name	;AN022; set up batch name in bwdbuf
  1813                                  		;jmp	short BatDie		;AN022;
  1814                                  ;Bat_Remcheck:					;AN022; Go see if media is removable
  1815                                  		;call	[RCH_ADDR]		; DX has error number
  1816                                  		;jz	AskForBat		; Media is removable
  1817                                  
  1818                                  		; MSDOS 3.3 COMMAND.COM
  1819 000004BC 81FA[4D37]              		cmp	dx,ACCDENPTR
  1820 000004C0 7413                    		jz	short BATDIE
  1821                                  
  1822                                  		; MSDOS 3.3 (& MSDOS 6.0)
  1823                                  BAT_REMCHECK:				; Go see if media is removable
  1824 000004C2 2EFF1E[8B41]            		call	far [cs:RCH_ADDR] ; DX has error number
  1825 000004C7 7417                    		jz	short ASKFORBAT	; Media is removable
  1826                                  
  1827                                  ; The media is not changeable. Turn everything off.
  1828                                  
  1829 000004C9 E8B909                  		call	FOROFF
  1830 000004CC E8411E                  		call	PIPEOFF
  1831 000004CF A2F40B                  		mov	[IFFLAG],al	; No If in progress.	
  1832 000004D2 BA[8E36]                		mov	dx,BADPATHPTR
  1833                                  BATDIE:
  1834 000004D5 E84B03                  		call	BATCHOFF
  1835 000004D8 0E                      		push	cs
  1836 000004D9 1F                      		pop	ds
  1837                                  		;invoke	std_eprintf	;AC022; display message ;  MSDOS 6.0
  1838 000004DA E84B2F                  		call	STD_PRINTF	; MSDOS 3.3
  1839                                  
  1840                                  ; TCOMMAND resets the stack. This is the equivalent of a non-local goto.
  1841                                  
  1842 000004DD E924FC                  		jmp	TCOMMAND
  1843                                  
  1844                                  ; Ask the user to reinsert the batch file
  1845                                  
  1846                                  ASKFORBAT:
  1847 000004E0 1E                      		push	ds
  1848 000004E1 0E                      		push	cs
  1849 000004E2 1F                      		pop	ds
  1850                                  
  1851                                  		; MSDOS 6.0
  1852                                  		;MOV	DX,OFFSET TRANGROUP:NEEDBAT_ptr  ;AN022;
  1853                                  		;invoke	std_eprintf	 	;Prompt for batch file on stderr
  1854                                  		;mov	dx,offset trangroup:pausemes_ptr 
  1855                                  		;;invoke std_eprintf		;AN000; get second part of message
  1856                                  						;AN000; print it to stderr
  1857                                  		; MSDOS 3.3 (& MSDOS 6.0)
  1858 000004E3 E8392F                  		call	STD_EPRINTF
  1859 000004E6 E80300                  		call	GETKEYSTROKE
  1860 000004E9 1F                      		pop	ds
  1861 000004EA EBCA                    		jmp	short PROMPTBAT
  1862                                  
  1863                                  ; MSDOS 6.0
  1864                                  ;****************************************************************
  1865                                  ;*
  1866                                  ;* ROUTINE:	Output_batch_name
  1867                                  ;*
  1868                                  ;* FUNCTION:	Sets up batch name to be printed on extended error
  1869                                  ;*
  1870                                  ;* INPUT:	DX - extended error number
  1871                                  ;*
  1872                                  ;* OUTPUT:	Ready to call print routine
  1873                                  ;*
  1874                                  ;****************************************************************
  1875                                  ;
  1876                                  ;public	output_batch_name			;AN022;
  1877                                  ;
  1878                                  ;Output_batch_name    proc near			;AN022;
  1879                                  ;
  1880                                  ;		push	ds			;AN022; save resident segment
  1881                                  ;		mov	ds,[batch]		;AN022; get batch file segment
  1882                                  ;	assume	DS:nothing			;AN022;
  1883                                  ;		mov	SI,BatFile		;AN022; get offset of batch file
  1884                                  ;		invoke	dstrlen 		;AN022; get length of string
  1885                                  ;		mov	di,offset Trangroup:bwdbuf ;AN022; target for batch name
  1886                                  ;		rep	movsb			;AN022; move the name
  1887                                  ;
  1888                                  ;		push	cs			;AN022; get local segment
  1889                                  ;		pop	ds			;AN022;
  1890                                  ;	assume	DS:trangroup			;AN022;
  1891                                  ;		mov	extend_buf_ptr,dx	;AN022; put message number in block
  1892                                  ;		mov	msg_disp_class,ext_msg_class
  1893                                  ;						;AN022; set up extended error msg class
  1894                                  ;		mov	dx,offset TranGroup:Extend_Buf_ptr
  1895                                  ;						;AN022; get extended message pointer
  1896                                  ;		mov	string_ptr_2,offset trangroup:bwdbuf 
  1897                                  ;						;AN022; point to substitution
  1898                                  ;		mov	extend_buf_sub,one_subst ;AN022; set up for one subst
  1899                                  ;		pop	ds			;AN022; restore data segment
  1900                                  ;
  1901                                  ;		ret				;AN022; return
  1902                                  ;
  1903                                  ;Output_batch_name    endp			;AN022;
  1904                                  
  1905                                  
  1906                                  ; =============== S U B	R O U T	I N E =======================================
  1907                                  
  1908                                  ;Break	<GetKeystroke - get a keystroke and flush queue>
  1909                                  
  1910                                  ; Read the next keystroke. Since there may be several characters in the queue
  1911                                  ; after the one we ask for (function keys/Kanji), we need to flush the queue
  1912                                  ; AFTER waiting.
  1913                                  
  1914                                  GETKEYSTROKE:
  1915                                  		; MSDOS 3.3
  1916                                  		;MOV	AX,(STD_CON_INPUT_FLUSH SHL 8) OR STD_CON_INPUT_NO_ECHO
  1917                                  		;mov	ax,0C08h
  1918 000004EC B8080C                  		mov	ax,(STD_CON_INPUT_FLUSH<<8)|STD_CON_INPUT_NO_ECHO
  1919 000004EF CD21                    		int	21h	; DOS -	CLEAR KEYBOARD BUFFER
  1920                                  				; AL must be 01h,06h,07h,08h,or 0Ah.
  1921                                  		;MOV	AX,(STD_CON_INPUT_FLUSH SHL 8) + 0
  1922                                  		;mov	ax,0C00h
  1923 000004F1 B8000C                  		mov	ax,(STD_CON_INPUT_FLUSH<<8)+0
  1924 000004F4 CD21                    		int	21h	; DOS -	CLEAR KEYBOARD BUFFER
  1925                                  				; AL must be 01h,06h,07h,08h,or 0Ah.
  1926 000004F6 C3                      		retn
  1927                                  
  1928                                  		; MSDOS 6.0
  1929                                  		;PUSH	DX				;AN000;  3/3/KK
  1930                                  		;MOV	AX,(ECS_call SHL 8) OR GetInterimMode ;AN000;  3/3/KK
  1931                                  		;INT	21h				;AN000;  3/3/KK
  1932                                  		;PUSH	DX				;AN000;  save interim state 3/3/KK
  1933                                  		;MOV	AX,(ECS_call SHL 8) OR SetInterimMode ;AN000;  3/3/KK
  1934                                  		;MOV	DL,InterimMode			;AN000;  3/3/KK
  1935                                  		;INT	21h				;AN000;  3/3/KK
  1936                                  		;
  1937                                  		;MOV	AX,(STD_CON_INPUT_FLUSH SHL 8) OR STD_CON_INPUT_no_echo
  1938                                  		;INT	21h		; Get character with KB buffer flush
  1939                                  		;MOV	AX,(STD_CON_INPUT_FLUSH SHL 8) + 0
  1940                                  		;INT	21h
  1941                                  		;
  1942                                  		;MOV	AX,(ECS_call SHL 8) OR SetInterimMode ;AN000;  3/3/KK
  1943                                  		;POP	DX				;AN000;  restore interim state 3/3/KK
  1944                                  		;INT	21h				;AN000;  3/3/KK
  1945                                  		;POP	DX				;AN000;  3/3/KK
  1946                                  		;
  1947                                  		;return
  1948                                  
  1949                                  ; =============== S U B	R O U T	I N E =======================================
  1950                                  
  1951                                  ; Break	<ReadBat - read 1 line from batch file>
  1952                                  
  1953                                  ; ReadBat - read a single line from the batch file. 
  1954                                  ; Perform all substitutions as appropriate.
  1955                                  
  1956                                  READBAT:
  1957                                  		;ASSUME	DS:ResGroup,ES:TranGroup
  1958                                  		
  1959                                  		;mov	byte [SUPPRESS],1
  1960                                  					; initialize line suppress status
  1961 000004F7 C606EA0B01              		mov	byte [SUPPRESS],YES_ECHO 
  1962 000004FC F606DF0BFF              		test	byte [BATCH_ABORT],-1 ; 0FFh
  1963 00000501 7508                    		jnz	short TRYING_TO_ABORT
  1964 00000503 C606DE0B01              		mov	byte [IN_BATCH],1 ; set flag to indicate batch job
  1965                                  
  1966                                  		; MSDOS 6.0
  1967                                  ;
  1968                                  ;M037; Start of changes
  1969                                  ; We check here if we have set the flag indicating that the batchfile is at
  1970                                  ;EOF. In this case, we do not want to continue with the normal processing.
  1971                                  ;We call GetBatByt once more so that the batch segment gets freed up, the
  1972                                  ;batch file gets closed etc. and then return as if everything is done.
  1973                                  ;
  1974                                  		;push	ds
  1975                                  		;mov	ds,Batch
  1976                                  		;cmp	ds:BatchEOF,0	; are we at EOF in batchfile
  1977                                  		;pop	ds
  1978                                  		;jz	contbat		; no, continue normal processing
  1979                                  		;invoke	GetBatByt	; frees up batchseg
  1980                                  		;mov	es:ComBuf+2,al	; stuff CR into command buffer
  1981                                  		;			; as a dummy command
  1982                                  		;invoke CrLf2		; print a CR-LF
  1983                                  		;return			; done batch processing
  1984                                  
  1985                                  ;M037; End of changes
  1986                                  		
  1987                                  		; MSDOS 3.3 (& MSDOS 6.0)
  1988                                  CONTBAT:
  1989 00000508 E8ABFF                  		call	PROMPTBAT
  1990                                  TRYING_TO_ABORT:
  1991 0000050B BF[E23F]                		mov	di,COMBUF+2
  1992                                  
  1993                                  ; Save position and try to scan for first non delimiter.
  1994                                  
  1995                                  TESTNOP:
  1996 0000050E 8CD8                    		mov	ax,ds
  1997 00000510 8E1E930B                		mov	ds,[BATCH]
  1998 00000514 FF360700                		push	word [BATCHSEGMENT.BatSeek]
  1999 00000518 FF360900                		push	word [BATCHSEGMENT.BatSeek+2] ; save current location.
  2000 0000051C 8ED8                    		mov	ds,ax
  2001 0000051E E87D05                  		call	SKIPDELIM	; skip to first non-delim
  2002                                  
  2003                                  ; If the first non-delimiter is not a : (label), we reseek back to the
  2004                                  ; beginning and read the line.
  2005                                  
  2006 00000521 3C3A                    		cmp	al,':'		; is it a label?
  2007 00000523 59                      		pop	cx
  2008 00000524 5A                      		pop	dx		; restore position in bat file
  2009 00000525 7413                    		jz	short NOPLINE	; yes, resync everything.
  2010 00000527 F706930BFFFF            		test	word [BATCH],-1 ; are we done with the batch file?
  2011 0000052D 7436                    		jz	short RDBAT	; no, go read batch file
  2012                                  
  2013                                  		;cmp	al,'@'
  2014 0000052F 3C40                    		cmp	al,NO_ECHO_CHAR	; see if user wants to suppress line
  2015 00000531 7516                    		jnz	short SET_BAT_POS ; no - go and set batch file position
  2016                                  		;mov	byte [SUPPRESS],0
  2017 00000533 C606EA0B00              		mov	byte [SUPPRESS],NO_ECHO ; yes set flag to indicate
  2018 00000538 EB2B                    		jmp	short RDBAT	; go read batch file
  2019                                  
  2020                                  		;nop
  2021                                  ; 02/03/2023
  2022                                  ;SET_BAT_POS:
  2023                                  ;		push	ds
  2024                                  ;		mov	ds,[BATCH]
  2025                                  ;		mov	[BATCHSEGMENT.BatSeek],dx ; reseek back to beginning
  2026                                  ;		mov	[BATCHSEGMENT.BatSeek+2],cx
  2027                                  ;		pop	ds
  2028                                  ;		;MOV	AX,(LSEEK SHL 8) + 0
  2029                                  ;		mov	ax,(LSEEK*256) ; 4200h ; ; seek back
  2030                                  ;		int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
  2031                                  ;				; AL = method: offset from beginning of	file
  2032                                  ;		;mov	word [cs:BATBUFPOS],0FFFFh
  2033                                  ;		mov	word [cs:BATBUFPOS],-1 ; nuke batch buffer position
  2034                                  ;		xor	cx,cx		; Initialize line length to zero
  2035                                  ;		jmp	short RDBAT
  2036                                  
  2037                                  		;nop
  2038                                  
  2039                                  ; The first non-delimiter is a :. This line is not echoed and is ignored.
  2040                                  ; We eat characters until a CR is seen.
  2041                                  
  2042                                  NOPLINE:
  2043 0000053A E81001                  		call	SKIPTOEOL
  2044 0000053D E84803                  		call	GETBATBYT	; eat trailing LF
  2045                                  		;test	word [BATCH],0FFFFh
  2046 00000540 F706930BFFFF            		test	word [BATCH],-1 ; are we done with the batch file?
  2047 00000546 75C6                    		jnz	short TESTNOP	; no, go get another line
  2048                                  READBAT_RETN:				; Hit EOF			
  2049 00000548 C3                      		retn
  2050                                  
  2051                                  ; 02/03/2023
  2052                                  SET_BAT_POS:
  2053 00000549 1E                      		push	ds
  2054 0000054A 8E1E930B                		mov	ds,[BATCH]
  2055 0000054E 89160700                		mov	[BATCHSEGMENT.BatSeek],dx ; reseek back to beginning
  2056 00000552 890E0900                		mov	[BATCHSEGMENT.BatSeek+2],cx
  2057 00000556 1F                      		pop	ds
  2058                                  		;mov	ax,(LSEEK SHL 8) + 0
  2059 00000557 B80042                  		mov	ax,(LSEEK*256) ; 4200h ; ; seek back
  2060 0000055A CD21                    		int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
  2061                                  				; AL = method: offset from beginning of	file
  2062                                  		;mov	word [cs:BATBUFPOS],0FFFFh
  2063 0000055C 2EC706[284C]FFFF        		mov	word [cs:BATBUFPOS],-1 ; nuke batch buffer position
  2064 00000563 31C9                    		xor	cx,cx		; Initialize line length to zero
  2065                                  		; 02/03/2023
  2066                                  		;jmp	short RDBAT
  2067                                  
  2068                                  ; ---------------------------------------------------------------------------
  2069                                  
  2070                                  ; Read a line into the buffer pointed to by ES:DI. If any %s are seen in the
  2071                                  ; input, we are to consider two special cases:
  2072                                  ;
  2073                                  ;   %0 to %9	These represent replaceable parameters from the batch segment
  2074                                  ;   %sym%	This is a symbol from the environment
  2075                                  
  2076                                  RDBAT:
  2077 00000565 E82003                  		call	GETBATBYT
  2078 00000568 41                      		inc	cx		; Inc the line length
  2079                                  RDBAT1:
  2080 00000569 81F98000                		cmp	cx,COMBUFLEN ; 128 ; Is it too long?
  2081 0000056D 7344                    		jnb	short TOOLONG	   ; Yes - handle it, handle it
  2082                                  
  2083                                  ; See if we have a parameter character.
  2084                                  
  2085 0000056F 3C25                    		cmp	al,'%'		; Check for parameter
  2086 00000571 744A                    		jz	short NEEDPARM
  2087                                  
  2088                                  ; no parameter character. Store it as usual and see if we are done.
  2089                                  
  2090                                  SAVBATBYT:
  2091 00000573 AA                      		stosb			; End of line found?
  2092 00000574 3C0D                    		cmp	al,0Dh
  2093 00000576 75ED                    		jnz	short RDBAT	; no, go for more
  2094                                  
  2095                                  ; We have read in an entire line. 
  2096                                  ; Decide whether we should echo the command line or not.
  2097                                  
  2098                                  FOUND_EOL:
  2099 00000578 81EF[E33F]              		sub	di,COMBUF+3
  2100 0000057C 89F8                    		mov	ax,di		; remember that we've not counted the CR
  2101 0000057E 26A2[E13F]              		mov	[es:COMBUF+1],al ; Set length of line
  2102 00000582 E80303                  		call	GETBATBYT	; Eat linefeed
  2103 00000585 E80806                  		call	BATCLOSE
  2104 00000588 803EEA0B00              		cmp	byte [SUPPRESS],NO_ECHO ; 0
  2105 0000058D 7407                    		jz	short RESET
  2106 0000058F F606E90B01              		test	byte [ECHOFLAG],1  ; To echo or not to echo, that is the
  2107 00000594 7504                    		jnz	short TRY_NEXTFLAG ; question. (Profound, huh?)
  2108                                  RESET:
  2109 00000596 0E                      		push	cs
  2110 00000597 1F                      		pop	ds		; Go back to local segment
  2111 00000598 74AE                    		jz	short READBAT_RETN ; no echoing here...
  2112                                  TRY_NEXTFLAG:
  2113 0000059A 803EFE0B01              		cmp	byte [NULLFLAG],nullcommand ; 1
  2114                                  					;G was there a command last time?
  2115 0000059F 7403                    		jz	short NO_CRLF_PRINT ;G no - don't print crlf
  2116 000005A1 E89513                  		call	CRLF2		;G  Print out prompt
  2117                                  NO_CRLF_PRINT:
  2118 000005A4 E8C70D                  		call	PRINT_PROMPT
  2119 000005A7 0E                      		push	cs		;G change data segment
  2120 000005A8 1F                      		pop	ds
  2121 000005A9 BA[E23F]                		mov	dx,COMBUF+2	; get command line for echoing
  2122 000005AC E8E713                  		call	CRPRINT
  2123 000005AF E88713                  		call	CRLF2
  2124 000005B2 C3                      		retn
  2125                                  
  2126                                  ; The line was too long. Eat remainder of input text up until the CR
  2127                                  
  2128                                  TOOLONG:
  2129 000005B3 3C0D                    		cmp	al,0Dh		; Has the end of the line been reached?
  2130 000005B5 7403                    		jz	short LTLCONT	; Yes, continue
  2131 000005B7 E89300                  		call	SKIPTOEOL	; Eat remainder of line	
  2132                                  LTLCONT:
  2133 000005BA AA                      		stosb			; Terminate the command
  2134 000005BB EBBB                    		jmp	short FOUND_EOL	; Go process the valid part of the line
  2135                                  
  2136                                  ; We have found a parameter lead-in character. Check for the 0-9 case first
  2137                                  
  2138                                  NEEDPARM:
  2139 000005BD E8C802                  		call	GETBATBYT	; get next character
  2140 000005C0 3C25                    		cmp	al,'%'		; Check for two consecutive %
  2141 000005C2 74AF                    		jz	short SAVBATBYT	; if so, replace with a single %
  2142 000005C4 3C0D                    		cmp	al,0Dh		; Check for end-of-line
  2143 000005C6 74AB                    		jz	short SAVBATBYT	; yes, treat it normally
  2144                                  
  2145                                  ; We have found %<something>. If the <something> is in the range 0-9, we
  2146                                  ; retrieve the appropriate parameter from the batch segment. Otherwise we
  2147                                  ; see if the <something> has a terminating % and then look up the contents
  2148                                  ; in the environment.
  2149                                  
  2150                                  PAROK:
  2151 000005C8 2C30                    		sub	al,'0'
  2152 000005CA 7239                    		jb	short NEEDENV	; look for parameter in the environment
  2153 000005CC 3C09                    		cmp	al,9
  2154 000005CE 7735                    		ja	short NEEDENV
  2155                                  
  2156                                  ; We have found %<number>. This is taken from the parameters in the
  2157                                  ; allocated batch area.
  2158                                  
  2159 000005D0 98                      		cbw
  2160 000005D1 89C3                    		mov	bx,ax		; move index into AX
  2161 000005D3 D1E3                    		shl	bx,1		; convert word index into byte ptr
  2162 000005D5 06                      		push	es
  2163 000005D6 8E06930B                		mov	es,[BATCH]
  2164                                  ;
  2165                                  ; The structure of the batch area is:
  2166                                  ;
  2167                                  ;   BYTE    type of segment
  2168                                  ;   DWORD   offset for next line
  2169                                  ;   10 WORD pointers to parameters. -1 is empty parameter
  2170                                  ;   ASCIZ   file name (with . and ..)
  2171                                  ;   BYTES   CR-terminated parameters
  2172                                  ;   BYTE    0 flag to indicate end of parameters
  2173                                  ;
  2174                                  ; Get pointer to BX'th argument
  2175                                  ;
  2176                                  		;mov	si,[es:bx+0Bh]
  2177 000005DA 268B770B                		mov	si,[es:bx+BATCHSEGMENT.BatParm]
  2178 000005DE 07                      		pop	es
  2179                                  
  2180                                  ; Is there a parameter here?
  2181                                  
  2182 000005DF 83FEFF                  		cmp	si,-1		; Check if parameter exists
  2183 000005E2 7503                    		jnz	short YES_THERE_IS ; Yes go get it
  2184 000005E4 E97EFF                  		jmp	RDBAT		; Ignore if it doesn't
  2185                                  
  2186                                  ; Copy in the found parameter from batch segment
  2187                                  
  2188                                  YES_THERE_IS:
  2189 000005E7 1E                      		push	ds
  2190 000005E8 8E1E930B                		mov	ds,[BATCH]
  2191 000005EC 49                      		dec	cx		; Don't count '%' in line length
  2192                                  COPYPARM:
  2193 000005ED AC                      		lodsb			; From resident segment
  2194 000005EE 3C0D                    		cmp	al,0Dh		; Check for end of parameter
  2195 000005F0 740F                    		jz	short ENDPARAM
  2196 000005F2 41                      		inc	cx		; Inc the line length
  2197 000005F3 81F98000                		cmp	cx,COMBUFLEN ; 128 ; Is it too long?
  2198 000005F7 7303                    		jnb	short LINETOOL	; Yes - handle it, handle it
  2199 000005F9 AA                      		stosb
  2200 000005FA EBF1                    		jmp	short COPYPARM
  2201                                  
  2202                                  ; We have copied up to the limit. Stop copying and eat remainder of batch
  2203                                  ; line. We need to make sure that the tooLong code isn't fooled into
  2204                                  ; believing that we are at EOL. Clobber AL too.
  2205                                  
  2206                                  LINETOOL:
  2207 000005FC 30C0                    		xor	al,al
  2208 000005FE 1F                      		pop	ds
  2209 000005FF EBB2                    		jmp	short TOOLONG
  2210                                  
  2211                                  ; We have copied in an entire parameter. Go back for more
  2212                                  
  2213                                  ENDPARAM:
  2214 00000601 1F                      		pop	ds
  2215 00000602 E960FF                  		jmp	RDBAT
  2216                                  
  2217                                  ; We have found % followed by something other than 0-9. We presume that there
  2218                                  ; will be a following % character. In between is an environment variable that
  2219                                  ; we will fetch and replace in the batch line with its value.
  2220                                  
  2221                                  NEEDENV:
  2222                                  		; MSDOS 6.0 COMMAND.COM 
  2223                                  		;dec     cx 		;AN070; Don't count "%"
  2224                                  
  2225                                  		; MSDOS 3.3 (& MSDOS 6.0)
  2226 00000605 1E                      		push	ds
  2227 00000606 57                      		push	di
  2228                                  					; temp spot for name
  2229 00000607 BF[FC41]                		mov	di,ID
  2230 0000060A 0430                    		add	al,'0'		; reconvert character
  2231 0000060C AA                      		stosb			; store it in appropriate place
  2232                                  
  2233                                  ; loop getting characters until the next % is found or until EOL
  2234                                  
  2235                                  GETENV1:
  2236 0000060D E87802                  		call	GETBATBYT	; get the byte
  2237 00000610 AA                      		stosb			; store it
  2238 00000611 3C0D                    		cmp	al,0Dh		; EOL?
  2239 00000613 7513                    		jnz	short GETENV15	; no, see if it the term char
  2240                                  
  2241                                  ; The user entered a string with a % but no trailing %. We copy the string.
  2242                                  
  2243 00000615 26C645FF00              		mov	byte [es:di-1],0 ; nul terminate the string
  2244 0000061A BE[FC41]                		mov	si,ID 		; point to buffer
  2245 0000061D 5F                      		pop	di		; point to line buffer
  2246 0000061E 0E                      		push	cs
  2247 0000061F 1F                      		pop	ds
  2248 00000620 E85C02                  		call	STRCPY
  2249                                  		;jc	short LineTooL	;  MSDOS 6.0 COMMAND.COM
  2250 00000623 4F                      		dec	di  		;  MSDOS 3.3 COMMAND.COM	
  2251 00000624 1F                      		pop	ds
  2252 00000625 E94BFF                  		jmp	SAVBATBYT
  2253                                  GETENV15:
  2254 00000628 3C25                    		cmp	al,'%'		; terminating %?
  2255 0000062A 75E1                    		jnz	short GETENV1	; no, go suck out more characters
  2256                                  
  2257                                  ; M017 - following DEC is wrong, because we replace the % with a = here.
  2258                                  ; This was the source of bug #1.
  2259                                  ;		dec	cx		;AN070; Don't count "%"
  2260                                  
  2261 0000062C B03D                    		mov	al,'='		; terminate  with =
  2262 0000062E 268845FF                		mov	[es:di-1],al
  2263                                  
  2264                                  ; ID now either has a =-terminated string which we are to find in the
  2265                                  ; environment or a non =-terminated string which will not be found in the
  2266                                  ; environment.
  2267                                  
  2268                                  GETENV2:
  2269 00000632 BE[FC41]                		mov	si,ID
  2270 00000635 0E                      		push	cs
  2271 00000636 1F                      		pop	ds		; DS:SI points to name
  2272 00000637 51                      		push	cx
  2273 00000638 E83211                  		call	FIND_NAME_IN_ENVIRONMENT
  2274 0000063B 59                      		pop	cx
  2275 0000063C 06                      		push	es
  2276 0000063D 1F                      		pop	ds
  2277 0000063E 0E                      		push	cs
  2278 0000063F 07                      		pop	es
  2279 00000640 89FE                    		mov	si,di
  2280 00000642 5F                      		pop	di		; get back pointer to command line
  2281                                  
  2282                                  ; If the parameter was not found, there is no need to perform any replacement.
  2283                                  ; We merely pretend that we've copied the parameter.
  2284                                  
  2285 00000643 7204                    		jc	short GETENV6
  2286                                  
  2287                                  ; ES:DI points to command line being built
  2288                                  ; DS:SI points either to nul-terminated environment object AFTER =
  2289                                  
  2290 00000645 E83702                  		call	STRCPY		; (let RdBat handle overflow)
  2291 00000648 4F                      		dec	di 	; MSDOS 3.3 COMMAND.COM
  2292                                  GETENV6:
  2293 00000649 1F                      		pop	ds
  2294 0000064A E918FF                  		jmp	RDBAT		; go back to batch file
  2295                                  
  2296                                  ; =============== S U B	R O U T	I N E =======================================
  2297                                  
  2298                                  ;   SkipToEOL - read from batch file until end of line
  2299                                  
  2300                                  SKIPTOEOL:
  2301 0000064D F706930BFFFF            		test	word [BATCH],-1 ; 0FFFFh
  2302                                  		
  2303                                  		;jnz	short SKIPTOEOL1  	
  2304                                  		;retn			; no batch file in effect
  2305                                  		
  2306 00000653 7407                    		jz	short SKIPTOEOL2 ; Retro DOS v3.0 COMMAND.COM
  2307                                  SKIPTOEOL1:
  2308 00000655 E83002                  		call	GETBATBYT
  2309 00000658 3C0D                    		cmp	al,0Dh		; eol character?
  2310 0000065A 75F1                    		jnz	short SKIPTOEOL	; no, go eat another
  2311                                  SKIPTOEOL2:
  2312 0000065C C3                      		retn
  2313                                  
  2314                                  ; =============== S U B	R O U T	I N E =======================================
  2315                                  
  2316                                  ;Break	<Allocate and deallocate the transient portion>
  2317                                  
  2318                                  ; Free Transient. Modify ES,AX,flags
  2319                                  
  2320                                  FREE_TPA:
  2321 0000065D 06                      		push	es
  2322 0000065E 8E06[8141]              		mov	es,[RESSEG]
  2323 00000662 268E061F0D              		mov	es,[es:RES_TPA]
  2324 00000667 B449                    		mov	ah,DEALLOC ; 49h
  2325 00000669 CD21                    		int	21h	; DOS -	2+ - FREE MEMORY
  2326                                  				; ES = segment address of area to be freed
  2327 0000066B 07                      		pop	es
  2328 0000066C C3                      		retn
  2329                                  
  2330                                  ; =============== S U B	R O U T	I N E =======================================
  2331                                  
  2332                                  ; Allocate transient.  Modify AX,BX,DX,flags
  2333                                  
  2334                                  ALLOC_TPA:
  2335 0000066D 06                      		push	es
  2336 0000066E 8E06[8141]              		mov	es,[RESSEG]
  2337 00000672 BBFFFF                  		mov	bx,0FFFFh 	; Re-allocate the transient	
  2338 00000675 B448                    		mov	ah,ALLOC ; 48h
  2339 00000677 CD21                    		int	21h	; DOS -	2+ - ALLOCATE MEMORY
  2340                                  				; BX = number of 16-byte paragraphs desired
  2341 00000679 53                      		push	bx	  	; Save size of block
  2342 0000067A B448                    		mov	ah,ALLOC ; 48h
  2343 0000067C CD21                    		int	21h	; DOS -	2+ - ALLOCATE MEMORY
  2344                                  				; BX = number of 16-byte paragraphs desired
  2345                                  
  2346                                  ; Attempt to align TPA on 64K boundary
  2347                                  
  2348 0000067E 5B                      		pop	bx		; Restore size of block
  2349 0000067F 26A31F0D                		mov	[es:RES_TPA],ax ; Save segment to beginning of block
  2350 00000683 A3[9141]                		mov	[TRAN_TPA],ax
  2351                                  
  2352                                  ; Is the segment already aligned on a 64K boundary
  2353                                  
  2354 00000686 89C2                    		mov	dx,ax		; Save segment
  2355 00000688 25FF0F                  		and	ax,0FFFh	; Test if above boundary
  2356 0000068B 7507                    		jnz	short CALC_TPA
  2357 0000068D 89D0                    		mov	ax,dx
  2358 0000068F 2500F0                  		and	ax,0F000h	; Test if multiple of 64K
  2359 00000692 7523                    		jnz	short NOROUND
  2360                                  CALC_TPA:
  2361 00000694 89D0                    		mov	ax,dx
  2362 00000696 2500F0                  		and	ax,0F000h
  2363 00000699 050010                  		add	ax,1000h	; Round up to next 64K boundary
  2364 0000069C 7219                    		jc	short NOROUND	; Memory wrap if carry set
  2365                                  
  2366                                  ; Make sure that new boundary is within allocated range
  2367                                  
  2368 0000069E 268B161F0D              		mov	dx,[es:RES_TPA]
  2369 000006A3 01DA                    		add	dx,bx		; Compute maximum address
  2370 000006A5 39C2                    		cmp	dx,ax		; Is 64K address out of range?
  2371 000006A7 720E                    		jb	short NOROUND
  2372                                  
  2373                                  ; Make sure that we won't overwrite the transient
  2374                                  
  2375 000006A9 8CCB                    		mov	bx,cs		; CS is beginning of transient
  2376 000006AB 39C3                    		cmp	bx,ax
  2377 000006AD 7208                    		jb	short NOROUND
  2378                                  
  2379                                  ; The area from the 64K boundary to the beginning of the transient must
  2380                                  ; be at least 64K.
  2381                                  
  2382 000006AF 29C3                    		sub	bx,ax
  2383                                  		;cmp	bx,4096
  2384 000006B1 81FB0010                		cmp	bx,1000h	; Size greater than 64K?	
  2385 000006B5 7304                    		jnb	short ROUNDDONE
  2386                                  NOROUND:
  2387 000006B7 26A11F0D                		mov	ax,[es:RES_TPA]
  2388                                  ROUNDDONE:
  2389 000006BB 26A3110D                		mov	[es:LTPA],ax ; Re-compute everything
  2390 000006BF A3[8341]                		mov	[TPA],ax
  2391 000006C2 89C3                    		mov	bx,ax
  2392 000006C4 8CC8                    		mov	ax,cs
  2393 000006C6 29D8                    		sub	ax,bx
  2394 000006C8 53                      		push	bx
  2395 000006C9 BB1000                  		mov	bx,16
  2396 000006CC F7E3                    		mul	bx
  2397 000006CE 5B                      		pop	bx
  2398 000006CF 09D2                    		or	dx,dx
  2399 000006D1 7403                    		jz	short SAVSIZ2
  2400 000006D3 B8FFFF                  		mov	ax,-1
  2401                                  SAVSIZ2:
  2402                                  
  2403                                  ; AX is the number of bytes free in the buffer between the resident and the
  2404                                  ; transient with a maximum of 64K-1. We round this down to a multiple of 512.
  2405                                  
  2406 000006D6 3D0002                  		cmp	ax,512
  2407 000006D9 7603                    		jbe	short GOTSIZE2
  2408                                  		;and	ax,~1FFh
  2409 000006DB 2500FE                  		and	ax,0FE00h	; NOT 511 = NOT 1FFh
  2410                                  GOTSIZE2:
  2411 000006DE A3[A241]                		mov	[BYTCNT],ax
  2412 000006E1 07                      		pop	es
  2413 000006E2 C3                      		retn
  2414                                  
  2415                                  ; =============== S U B	R O U T	I N E =======================================
  2416                                  
  2417                                  ;Break	<BatCom - enter a batch file>
  2418                                  
  2419                                  ; The exec search has determined that the user has requested a batch file for
  2420                                  ; execution. We parse the arguments, create the batch segment, and signal
  2421                                  ; batch processing.
  2422                                  
  2423                                  BATCOM:	
  2424                                  
  2425                                  ;ASSUME	DS:TRANGROUP, ES:NOTHING
  2426                                  
  2427                                  ; Batch parameters are read with ES set to segment of resident part
  2428                                  
  2429                                  		; MSDOS 6.0
  2430                                  		;mov	es,[RESSEG]
  2431                                  		;ASSUME	ES:RESGROUP
  2432                                  		;cmp	es:[call_batch_flag],call_in_progress
  2433                                  		;				;AN043; If in CALL,
  2434                                  		;jz	skip_ioset		;AN043; redirection was already set up
  2435                                  		;invoke	IOSET			; Set up any redirection
  2436                                  ;skip_ioset:					;AN043;
  2437                                  		;call	FREE_TPA		; G
  2438                                  		;cmp	es:[call_batch_flag],call_in_progress ;G
  2439                                  		;jz	getecho 		; G if we're in a call, don't execute
  2440                                  
  2441                                  		; MSDOS 3.3
  2442 000006E3 E8CE16                  		call	IOSET
  2443 000006E6 8E06[8141]              		mov	es,[RESSEG]
  2444 000006EA E870FF                  		call	FREE_TPA
  2445                                  		;cmp	byte [es:CALL_BATCH_FLAG],1
  2446 000006ED 26803EFB0B01            		cmp	byte [es:CALL_BATCH_FLAG],call_in_progress
  2447 000006F3 7403                    		jz	short GETECHO		; G if we're in a call, don't execute
  2448                                  
  2449                                  		; MSDOS 3.3 (& MSDOS 6.0)
  2450                                  
  2451                                  ; Since BATCH has lower precedence than PIPE or FOR. If a new BATCH file is
  2452                                  ; being started it MUST be true that no FOR or PIPE is currently in progress.
  2453                                  ; Don't execute if in call
  2454                                  
  2455 000006F5 E88D07                  		call	FOROFF
  2456                                  GETECHO:
  2457 000006F8 E8151C                  		call	PIPEOFF
  2458 000006FB 26A0E90B                		mov	al,[es:ECHOFLAG]	; preserve echo state for chaining
  2459 000006FF 2401                    		and	al,1		; Save current echo state
  2460                                  
  2461 00000701 50                      		push	ax
  2462 00000702 31C0                    		xor	ax,ax
  2463 00000704 26F706930BFFFF          		test	word [es:BATCH],-1 ; Are we in a batch file?
  2464 0000070B 7414                    		jz	short LEAVEBAT	   ; No, nothing to save
  2465 0000070D 26A1930B                		mov	ax,[es:BATCH]	; Get current batch segment
  2466                                  		;cmp	byte [es:CALL_BATCH_FLAG],1
  2467 00000711 26803EFB0B01            		cmp	byte [es:CALL_BATCH_FLAG],call_in_progress
  2468 00000717 7408                    		jz	short LEAVEBAT
  2469                                  
  2470                                  ;  We are in a chained batch file, save batlast from previous batch segment
  2471                                  ;  so that if we're in a CALL, we will return to the correct batch file.
  2472                                  
  2473 00000719 06                      		push	es
  2474 0000071A 8EC0                    		mov	es,ax		; Get current batch segment
  2475                                  		;mov	ax,[es:02h] ; MSDOS 3.3 COMMAND.COM
  2476                                  					; Get previous batch segment
  2477 0000071C 26A10200                		mov	ax,[es:BATCHSEGMENT.BatLast]
  2478 00000720 07                      		pop	es
  2479                                  LEAVEBAT:
  2480 00000721 50                      		push	ax		; Keep segment until new one created
  2481 00000722 26803EFB0B01            		cmp	byte [es:CALL_BATCH_FLAG],1
  2482 00000728 7403                    		jz	short STARTBAT
  2483 0000072A E8F600                  		call	BATCHOFF
  2484                                  
  2485                                  ; Find length of batch file
  2486                                  
  2487                                  STARTBAT:
  2488 0000072D 26C606FB0B00            		mov	byte [es:CALL_BATCH_FLAG],0 ; Reset call flag
  2489 00000733 BE[A940]                		mov	si,EXECPATH
  2490                                  
  2491                                  		; MSDOS 6.0
  2492                                  		;mov	ax,AppendTruename ;AN042; Get the real path where the batch file
  2493                                  		;int	2fh		;AN042;    was found with APPEND
  2494                                  		;mov	ah,Find_First	;AN042; The find_first will return it
  2495                                  		;mov	dx,si		;AN042; Get the string
  2496                                  		;mov	cx,search_attr	;AN042; filetypes to search for
  2497                                  		;int	21h		;AN042;
  2498                                  
  2499                                  		; MSDOS 3.3 (& MSDOS 6.0)
  2500 00000736 E83217                  		call	DSTRLEN
  2501                                  ;
  2502                                  ; Allocate batch area:
  2503                                  ;   BYTE    type of segment
  2504                                  ;   WORD    segment of last batch file
  2505                                  ;   WORD    segment for FOR command
  2506                                  ;   BYTE    FOR flag state on entry to batch file
  2507                                  ;   DWORD   offset for next line
  2508                                  ;   10 WORD pointers to parameters.  -1 is empty parameter
  2509                                  ;   ASCIZ   file name (with . and ..)
  2510                                  ;   BYTES   CR-terminated parameters
  2511                                  ;   BYTE    0 flag to indicate end of parameters
  2512                                  ;
  2513                                  ; We allocate the maximum size for the command line and use setblock to shrink
  2514                                  ; later when we've squeezed out the extra
  2515                                  ;
  2516 00000739 89CB                    		mov	bx,cx		; length of file name.
  2517                                  		;add	bx,190	; MSDOS 3.3 (BATCHSEGMENT struc size = 32)
  2518 0000073B 81C3BE00                		add	bx,15+BATCHSEGMENT.SIZE+COMBUFLEN+15
  2519                                  					; structure + max len + round up
  2520 0000073F 51                      		push	cx
  2521 00000740 B104                    		mov	cl,4
  2522 00000742 D3EB                    		shr	bx,cl		; convert to paragraphs
  2523 00000744 53                      		push	bx		; Save size of batch segment
  2524 00000745 B448                    		mov	ah,ALLOC ; 48h ; Allocate batch segment
  2525 00000747 CD21                    		int	21h	; DOS -	2+ - ALLOCATE MEMORY
  2526                                  				; BX = number of 16-byte paragraphs desired
  2527 00000749 5B                      		pop	bx		; Get size of batch segment
  2528                                  
  2529                                  ; This should *NEVER* return an error. The transient is MUCH bigger than
  2530                                  ; the batch segment. This may not be true, however, in a multitasking system.
  2531                                  ; G This error will occur with nesting of batch files. We also need to
  2532                                  ; G make sure that we don't overlay the transient.
  2533                                  
  2534 0000074A 7216                    		jc	short MEM_ERROR	;G not enough memory - exit
  2535                                  
  2536 0000074C 50                      		push	ax		;G save batch segment
  2537 0000074D 01D8                    		add	ax,bx		;G get end of batch segment
  2538 0000074F 83C020                  		add	ax,20h		;G add some tpa work area
  2539 00000752 8CCB                    		mov	bx,cs		;G get the transient segment
  2540                                  
  2541                                  		; MSDOS 6.0
  2542                                  ; M006; We cant check just for above. If the batchseg goes into a UMB, the
  2543                                  ; M006; batchseg is always above the transient. We need to change this code
  2544                                  ; M006; to only check for an overlap
  2545                                  ;
  2546                                  		;mov	dx,offset TRANGROUP:TranSpaceEnd ; M006
  2547                                  		;add	dx,15		;round up para; M006
  2548                                  		;shr	dx,cl		;para size of transient; M006
  2549                                  		;add	dx,bx		;dx = top of transient; M006
  2550                                  
  2551                                  		;cmp	ax,bx		; M006
  2552                                  		;jb	enough_mem	; Batchseg below transient
  2553                                  					; enough memory ; M006
  2554                                  		;cmp	ax,dx		; M006
  2555                                  		;ja	enough_mem	; Batchseg above transient
  2556                                  					; enough memory ; M006
  2557                                  ;
  2558                                  ; M006; Batchseg overlaps transient -- insufficient memory
  2559                                  ;
  2560                                  		;pop	ax		; restore ax; M006
  2561                                  
  2562                                  ;M006;		cmp	ax,bx		;G do we end before the transient
  2563                                  ;M006;		pop	ax		;G get batch segment back
  2564                                  ;M006;		jb	enough_mem	;G we have enough memory - continue
  2565                                  
  2566                                  		; MSDOS 3.3
  2567 00000754 39D8                    		cmp	ax,bx		; do we end before the transient ?
  2568 00000756 58                      		pop	ax		; get batch segment back
  2569 00000757 720C                    		jb	short ENOUGH_MEM ; we have enough memory - continue
  2570                                  
  2571                                  		; MSDOS 3.3 (& MSDOS 6.0)
  2572 00000759 06                      		push	es		;G no we're hitting the transient
  2573 0000075A 8EC0                    		mov	es,ax
  2574 0000075C B80049                  		mov	ax,DEALLOC*256 ; 4900h ;G deallocate the batch segment
  2575 0000075F CD21                    		int	21h	; DOS -	2+ - FREE MEMORY
  2576                                  				; ES = segment address of area to be freed
  2577 00000761 07                      		pop	es
  2578                                  MEM_ERROR:
  2579 00000762 E9B200                  		jmp	NO_MEMORY	;G Set up for message and exit
  2580                                  
  2581                                  ENOUGH_MEM:
  2582                                  		; MSDOS 6.0
  2583                                  		;pop	ax		; restore ax; M006
  2584                                  
  2585                                  		; MSDOS 3.3 (& MSDOS 6.0)
  2586 00000765 26A3930B                		mov	[es:BATCH],ax
  2587 00000769 E801FF                  		call	ALLOC_TPA
  2588                                  
  2589                                  ; Initialize batch segment
  2590                                  
  2591 0000076C 5A                      		pop	dx		; length of name
  2592 0000076D 58                      		pop	ax		;G get saved batch segment back
  2593 0000076E 26FF06F80B              		inc	word [es:NEST]	;G increment # batch files in progress
  2594 00000773 06                      		push	es
  2595 00000774 268E06930B              		mov	es,[es:BATCH]
  2596                                  		;mov	byte [es:0],0
  2597                                  					; signal batch file type
  2598 00000779 26C606000000            		mov	byte [es:BATCHSEGMENT.BatType],BATCHTYPE ; 0
  2599                                  		;mov	[es:2],ax ; MSDOS 3.3
  2600                                  					;G save segment of last batch file
  2601 0000077F 26A30200                		mov	[es:BATCHSEGMENT.BatLast],ax
  2602 00000783 1E                      		push	ds
  2603 00000784 8E1E[8141]              		mov	ds,[RESSEG]	;G set to resident data
  2604                                  
  2605 00000788 31C0                    		xor	ax,ax
  2606 0000078A 8A1EF50B                		mov	bl,[FORFLAG]	;G get the current FOR state
  2607                                  		;mov	[es:6],bl ; MSDOS 3.3
  2608                                  					;G save it in the batch segment
  2609 0000078E 26881E0600              		mov	[es:BATCHSEGMENT.BatForFlag],bl
  2610 00000793 F6C3FF                  		test	bl,-1		;G are we in a FOR?
  2611 00000796 7408                    		jz	short FOR_NOT_ON ;G no, for segment set to 0	
  2612 00000798 A1F60B                  		mov	ax,[FORPTR]	;G yes, get current FOR segment	
  2613 0000079B C606F50B00              		mov	byte [FORFLAG],0 ;G reset forflag
  2614                                  FOR_NOT_ON:
  2615                                  		;mov	[es:4],ax ; MSDOS 3.3
  2616                                  					;G save FOR segment in batch segment
  2617 000007A0 26A30400                		mov	[es:BATCHSEGMENT.BatForPtr],ax	
  2618 000007A4 31C0                    		xor	ax,ax
  2619 000007A6 A3F60B                  		mov	[FORPTR],ax	;G make sure for segment is not active
  2620 000007A9 8A1EE90B                		mov	bl,[ECHOFLAG]
  2621 000007AD 1F                      		pop	ds
  2622                                  		;mov	[es:1],bl 
  2623                                  					 ;G save echo state of parent
  2624 000007AE 26881E0100              		mov	[es:BATCHSEGMENT.BatEchoFlag],bl
  2625                                  ;SR;
  2626                                  ; Initialize the new BatchEOF flag we have added to 0
  2627                                  ;
  2628                                  		;mov	es:BatchEOF,0  ; MSDOS 6.0
  2629                                  
  2630 000007B3 26A30700                		mov	[es:BATCHSEGMENT.BatSeek],ax ; point to beginning of file
  2631 000007B7 26A30900                		mov	[es:BATCHSEGMENT.BatSeek+2],ax
  2632                                  
  2633                                  ; Initialize pointers
  2634                                  
  2635 000007BB 48                      		dec	ax		; put -1 into AX
  2636                                  		;mov	di,0Bh  ; MSDOS 3.3
  2637                                  					; point to parm area
  2638 000007BC BF0B00                  		mov	di,BATCHSEGMENT.BatParm
  2639 000007BF 89FB                    		mov	bx,di
  2640 000007C1 B90A00                  		mov	cx,10
  2641 000007C4 F3AB                    		rep stosw		; Init to no parms
  2642                                  
  2643                                  ; Move in batch file name
  2644                                  
  2645 000007C6 89D1                    		mov	cx,dx
  2646 000007C8 F3A4                    		rep movsb
  2647                                  
  2648                                  ; Now copy the command line into batch segment, parsing the arguments along
  2649                                  ; the way. Segment will look like this:
  2650                                  ;
  2651                                  ;   <arg0>CR<arg1>CR...<arg9>CR<arg10>CR...<ARGn>CR 0
  2652                                  ;
  2653                                  ; or, in the case of fewer arguments:
  2654                                  ;
  2655                                  ;   <arg0>CR<arg1>CR...<arg6>CR CR CR ... CR 0
  2656                                  ;
  2657 000007CA BE[E23F]                		mov	si,COMBUF+2
  2658 000007CD B90A00                  		mov	cx,10		; at most 10 arguments
  2659                                  EACHPARM:
  2660 000007D0 E87311                  		call	SCANOFF		; skip to argument
  2661                                  
  2662                                  ; AL is first non-delimiter. DS:SI points to char = AL
  2663                                  
  2664 000007D3 3C0D                    		cmp	al,0Dh		; end of road?
  2665 000007D5 7413                    		jz	short HAVPARM	; yes, no more arguments
  2666                                  
  2667                                  ; If CX = 0 then we have stored the most parm we can. Skip store
  2668                                  
  2669 000007D7 E306                    		jcxz	MOVPARM		; Only first 10 parms get pointers
  2670                                  
  2671                                  ; Go into allocated piece and stick in new argument pointer.
  2672                                  
  2673 000007D9 26893F                  		mov	[es:bx],di	; store batch pointer
  2674 000007DC 83C302                  		add	bx,2		; advance arg counter
  2675                                  
  2676                                  ; Move the parameter into batch segment
  2677                                  
  2678                                  MOVPARM:
  2679 000007DF AC                      		lodsb			; get byte
  2680 000007E0 E86B11                  		call	DELIM		; if delimiter
  2681 000007E3 742A                    		jz	short ENDPARM	; then done with parm
  2682 000007E5 AA                      		stosb			; store byte
  2683 000007E6 3C0D                    		cmp	al,0Dh		; if CR then not delimiter
  2684                                  		;jz	short HAVPARM	; but end of parm list, finish
  2685                                  		;jmp	short MOVPARM
  2686                                  		; 02/03/2023
  2687 000007E8 75F5                    		jnz	short MOVPARM
  2688                                  
  2689                                  ; 02/03/2023
  2690                                  ;; We have copied a parameter up until the first separator.
  2691                                  ;; Terminate it with CR.
  2692                                  ;
  2693                                  ;ENDPARM:
  2694                                  ;		mov	al,0Dh
  2695                                  ;		stosb
  2696                                  ;		jcxz	EACHPARM	; if no parameters, don't dec
  2697                                  ;		dec	cx		; remember that we've seen one.	
  2698                                  ;		jmp	short EACHPARM
  2699                                  
  2700                                  ; We have parsed the entire line. Terminate the arg list
  2701                                  
  2702                                  HAVPARM:
  2703 000007EA 30C0                    		xor	al,al		; Nul terminate the parms
  2704 000007EC AA                      		stosb
  2705                                  
  2706                                  ; Now we know EXACTLY how big the BATCH segment is. Round up size (from DI)
  2707                                  ; into paragraphs and setblock to the appropriate size
  2708                                  
  2709 000007ED 8D5D0F                  		lea	bx,[di+15]
  2710 000007F0 B104                    		mov	cl,4
  2711 000007F2 D3EB                    		shr	bx,cl
  2712 000007F4 B44A                    		mov	ah,SETBLOCK ; 4Ah
  2713 000007F6 CD21                    		int	21h	; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
  2714                                  				; ES = segment address of block	to change
  2715                                  				; BX = new size	in paragraphs
  2716 000007F8 07                      		pop	es
  2717 000007F9 06                      		push	es
  2718 000007FA 1F                      		pop	ds		; Simply batch FCB setup
  2719 000007FB 833EEF0BFF              		cmp	word [SINGLECOM],-1 ; 0FFFFh
  2720 00000800 7506                    		jnz	short NOBATSING
  2721 00000802 C706EF0BF0FF            		mov	word [SINGLECOM],0FFF0h ; Flag single command BATCH job
  2722                                  NOBATSING:
  2723                                  
  2724                                  ; Enter the batch file with the current echo state
  2725                                  
  2726 00000808 58                      		pop	ax		; Get original echo state
  2727 00000809 A2E90B                  		mov	[ECHOFLAG],al	; restore it
  2728 0000080C E9F5F8                  		jmp	TCOMMAND
  2729                                  
  2730                                  ; 02/03/2023
  2731                                  ; We have copied a parameter up until the first separator.
  2732                                  ; Terminate it with CR.
  2733                                  
  2734                                  ENDPARM:
  2735 0000080F B00D                    		mov	al,0Dh
  2736 00000811 AA                      		stosb
  2737 00000812 E3BC                    		jcxz	EACHPARM	; if no parameters, don't dec
  2738 00000814 49                      		dec	cx		; remember that we've seen one.	
  2739 00000815 EBB9                    		jmp	short EACHPARM
  2740                                  
  2741                                  ; The following is executed if there isn't enough memory for batch segment
  2742                                  
  2743                                  NO_MEMORY:
  2744 00000817 5A                      		pop	dx		; even up our stack 
  2745 00000818 58                      		pop	ax
  2746 00000819 58                      		pop	ax
  2747 0000081A E850FE                  		call	ALLOC_TPA	; reallocate memory
  2748                                  
  2749                                  		; MSDOS 3.3
  2750 0000081D BA[DA3B]                		mov	dx,INSFMEMMESPTR
  2751 00000820 E9C713                  		jmp	CERROR
  2752                                  
  2753                                  		; MSDOS 6.0
  2754                                  		;mov	msg_disp_class,ext_msg_class
  2755                                  		;			;AN000; set up extended error msg class
  2756                                  		;mov	dx,offset TranGroup:Extend_Buf_ptr
  2757                                  		;			;AC000; get extended message pointer
  2758                                  		;mov	Extend_Buf_ptr,error_not_enough_memory
  2759                                  		;			;AN000; get message number in control block
  2760                                  		;jmp	cerror		;g print error message and go...
  2761                                  
  2762                                  ; =============== S U B	R O U T	I N E =======================================
  2763                                  
  2764                                  BATCHOFF:
  2765 00000823 50                      		push	ax
  2766 00000824 06                      		push	es
  2767 00000825 1E                      		push	ds
  2768 00000826 53                      		push	bx
  2769                                  
  2770 00000827 2E8E06[8141]            		mov	es,[cs:RESSEG]
  2771 0000082C 2E8E1E[8141]            		mov	ds,[cs:RESSEG]
  2772 00000831 A1930B                  		mov	ax,[BATCH]	; Free the batch segment
  2773 00000834 09C0                    		or	ax,ax
  2774 00000836 7442                    		jz	short NOTFREE
  2775                                  
  2776 00000838 06                      		push	es
  2777 00000839 8EC0                    		mov	es,ax
  2778 0000083B F606E90B01              		test	byte [ECHOFLAG],1 ;G Is echo on?
  2779 00000840 7505                    		jnz	short ECHO_LAST_LINE ;G Yes - echo last line in file
  2780                                  		;mov	byte [SUPPRESS],0
  2781 00000842 C606EA0B00              		mov	byte [SUPPRESS],NO_ECHO ;G no - don't echo last line in file	
  2782                                  ECHO_LAST_LINE:
  2783                                  		;mov	bl,[es:1]
  2784 00000847 268A1E0100              		mov	bl,[es:BATCHSEGMENT.BatEchoFlag] ; G get echo state
  2785 0000084C 881EE90B                		mov	[ECHOFLAG],bl	; G and restore it
  2786                                  		;mov	bx,[es:4] ;  MSDOS 3.3
  2787 00000850 268B1E0400              		mov	bx,[es:BATCHSEGMENT.BatForPtr]	;G  Get FOR segment
  2788 00000855 891EF60B                		mov	[FORPTR],bx	;G  and restore it
  2789                                  		;mov	bl,[es:6]
  2790 00000859 268A1E0600              		mov	bl,[es:BATCHSEGMENT.BatForFlag] ;G  Get FOR flag
  2791 0000085E 881EF50B                		mov	[FORFLAG],bl	;G  and restore it
  2792                                  		;mov	bx,[es:2] ; MSDOS 3.3
  2793 00000862 268B1E0200              		mov	bx,[es:BATCHSEGMENT.BatLast]	;G  Get old batch segment
  2794                                  
  2795 00000867 B449                    		mov	ah,DEALLOC ; 49h
  2796 00000869 CD21                    		int	21h	; DOS -	2+ - FREE MEMORY
  2797                                  				; ES = segment address of area to be freed
  2798 0000086B 07                      		pop	es
  2799 0000086C 891EFC0B                		mov	[NEXT_BATCH],bx	;G  reset batch segment	
  2800 00000870 26FF0EF80B              		dec	word [es:NEST]
  2801 00000875 31C0                    		xor	ax,ax
  2802 00000877 A3930B                  		mov	[BATCH],ax	; No batch in progress
  2803                                  NOTFREE:
  2804 0000087A 5B                      		pop	bx
  2805 0000087B 1F                      		pop	ds
  2806 0000087C 07                      		pop	es
  2807 0000087D 58                      		pop	ax
  2808 0000087E C3                      		retn
  2809                                  
  2810                                  ; =============== S U B	R O U T	I N E =======================================
  2811                                  
  2812                                  ; StrCpy - copy string, checking count in CX against COMBUFLEN
  2813                                  ;	Entry : DS:SI ==> source string
  2814                                  ;		ES:DI ==> destination string
  2815                                  ;		CX = current length of destination string
  2816                                  ;	Exit  : string copied, CX updated, Carry set if length limit exceeded
  2817                                  
  2818                                  		; MSDOS 3.3
  2819                                  STRCPY:
  2820 0000087F 50                      		push	ax
  2821                                  CCYCLE:
  2822 00000880 AC                      		lodsb
  2823 00000881 AA                      		stosb
  2824 00000882 08C0                    		or	al,al
  2825 00000884 75FA                    		jnz	short CCYCLE
  2826 00000886 58                      		pop	ax
  2827 00000887 C3                      		retn
  2828                                  
  2829                                  		; MSDOS 6.0
  2830                                  ;Procedure StrCpy,NEAR
  2831                                  		;push	ax
  2832                                  ;ccycle:
  2833                                  		;lodsb
  2834                                  		;inc	cx
  2835                                  		;cmp	cx,COMBUFLEN
  2836                                  		;jb	ccopy
  2837                                  		;stc			; set carry to signal error
  2838                                  		;jmp	short ccend
  2839                                  ;ccopy:
  2840                                  		;stosb
  2841                                  		;or	al,al
  2842                                  		;jnz	ccycle
  2843                                  ;ccend:
  2844                                  		;dec	cx		; discount extra byte
  2845                                  		;dec	di		; back up pointer
  2846                                  		;pop	ax
  2847                                  		;return			; return carry clear
  2848                                  ;EndProc StrCpy
  2849                                  
  2850                                  ;============================================================================
  2851                                  ; TBATCH2.ASM, MSDOS 6.0, 1991
  2852                                  ;============================================================================
  2853                                  ; 12/10/2018 - Retro DOS v3.0
  2854                                  
  2855                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0892h
  2856                                  
  2857                                  ; =============== S U B	R O U T	I N E =======================================
  2858                                  
  2859                                  ;Break	<GetBatByt - retrieve a byte from the batch file>
  2860                                  
  2861                                  ; Get one byte from the batch file and return it in AL. End-of-file returns
  2862                                  ; <CR> and ends batch mode. DS must be set to resident segment.
  2863                                  ; AH, DX destroyed.
  2864                                  
  2865                                  GETBATBYT:
  2866 00000888 53                      		push	bx
  2867 00000889 51                      		push	cx
  2868 0000088A 1E                      		push	ds
  2869 0000088B F606DF0BFF              		test	byte [BATCH_ABORT],-1
  2870 00000890 755E                    		jnz	short BATEOF
  2871 00000892 F706930BFFFF            		test	word [BATCH],-1
  2872 00000898 7456                    		jz	short BATEOF
  2873 0000089A 06                      		push	es
  2874 0000089B 8E06930B                		mov	es,[BATCH]
  2875                                  
  2876                                  		; MSDOS 6.0
  2877                                  ;M020;
  2878                                  ;Check if we have already reached EOF (BatchEOF flag set. Then, we do not
  2879                                  ;try to read from the batchfile again.
  2880                                  ;
  2881                                  		;cmp	es:BatchEOF,0	;already reached EOF?	;M020
  2882                                  		;jz	not_eof		;no, read batch file	;M020
  2883                                  		;jmp	At_EOF		;yes, no more reads	;M020
  2884                                  ;not_eof:							;M020
  2885                                  		; MSDOS 3.3 (& MSDOS 6.0)
  2886 0000089F 268306070001            		add	word [es:BATCHSEGMENT.BatSeek],1
  2887 000008A5 268316090000            		adc	word [es:BATCHSEGMENT.BatSeek+2],0
  2888 000008AB 07                      		pop	es
  2889                                  
  2890                                  ; See if we have bytes buffered...
  2891                                  
  2892 000008AC 8CC8                    		mov	ax,cs
  2893 000008AE 8ED8                    		mov	ds,ax
  2894 000008B0 8B1E[284C]              		mov	bx,[BATBUFPOS]
  2895 000008B4 83FBFF                  		cmp	bx,-1
  2896 000008B7 751D                    		jnz	short UNBUF
  2897                                  
  2898                                  ; There are no bytes in the buffer. Let's try to fill it up.
  2899                                  
  2900 000008B9 BA[2A4C]                		mov	dx,BATBUF
  2901 000008BC 8B0E[333E]              		mov	cx,[BATBUFLEN] ; max to read.
  2902 000008C0 8B1E[A544]              		mov	bx,[BATHAND]
  2903 000008C4 B43F                    		mov	ah,READ ; 3Fh	; Get one more byte from batch file
  2904 000008C6 CD21                    		int	21h	; DOS -	2+ - READ FROM FILE WITH HANDLE
  2905                                  				; BX = file handle,CX = number	of bytes to read
  2906                                  				; DS:DX	-> buffer
  2907                                  		; MSDOS 6.0
  2908                                  		;jnc	bat_read_ok		;AN022; if no error - continue
  2909                                  		;invoke	get_ext_error_number	;AN022; get the error
  2910                                  		;push	ds			;AN022; save local segment
  2911                                  		;mov	ds,[resseg]		;AN022; get resident segment
  2912                                  		;assume ds:resgroup		;AN022;
  2913                                  		;mov	dx,ax			;AN022; put error in DX
  2914                                  		;invoke	output_batch_name	;AN022; set up to print the error
  2915                                  		;pop	ds			;AN022;
  2916                                  		;assume	ds:trangroup		;AN022;
  2917                                  		;invoke	std_eprintf		;AN022; print out the error
  2918                                  		;mov	byte ptr combuf+2,end_of_line_in
  2919                                  		;				;AN022; terminate the batch line for parsing
  2920                                  		;mov	byte ptr combuf+3,end_of_line_out 
  2921                                  		;				;AN022; terminate the batch line for output
  2922                                  ;M020;
  2923                                  ;Old bug! We jump to BatEof from here without ds=RESGROUP. Probably, this
  2924                                  ;error is never hit (and it shouldn't be)
  2925                                  ;
  2926                                  		;mov	ds,ResSeg		; ds = RESGROUP ; M020
  2927                                  		;
  2928                                  		;jmp	short bateof		;AN022; terminate the batch file
  2929                                  ;bat_read_ok:					;AN022;
  2930                                  
  2931                                  		; MSDOS 3.3 (& MSDOS 6.0)
  2932 000008C8 89C1                    		mov	cx,ax
  2933 000008CA E320                    		jcxz	TURN_OFF ; MSDOS 3.3
  2934                                  		;jcxz	BATEOFDS ; MSDOS 6.0
  2935 000008CC 890E[4A4C]              		mov	[BATBUFEND],cx
  2936 000008D0 31DB                    		xor	bx,bx
  2937 000008D2 891E[284C]              		mov	[BATBUFPOS],bx
  2938                                  
  2939                                  ; Buffered bytes!
  2940                                  
  2941                                  UNBUF:
  2942 000008D6 8A87[2A4C]              		mov	al,[BATBUF+bx]		; get next byte
  2943 000008DA 43                      		inc	bx
  2944 000008DB 3B1E[4A4C]              		cmp	bx,[BATBUFEND]		; beyond end of buffer?
  2945 000008DF 7203                    		jb	short SETBUFPOS
  2946 000008E1 BBFFFF                  		mov	bx,-1
  2947                                  SETBUFPOS:
  2948 000008E4 891E[284C]              		mov	[BATBUFPOS],bx
  2949 000008E8 3C1A                    		cmp	al,1Ah			; ^Z for termination?
  2950 000008EA 7533                    		jnz	short GETBYTEDONE
  2951                                  
  2952                                  ;We get here only when we hit an EOF
  2953                                  		
  2954                                  		; MSDOS 6.0
  2955                                  ;BatEOFDS:
  2956                                  ;SR;
  2957                                  ; HACK!!! A massive hack being put in here to get batch processing to work
  2958                                  ;properly on EOF. Previously, a CR was returned and batch processing turned
  2959                                  ;off the moment we hit an EOF. Unfortunately, if the last line had no CR-LF,
  2960                                  ;batch processing is turned off before the last line is processed and so 
  2961                                  ;this line would never be executed. 
  2962                                  ;   	To fix this, a new flag BatchEOF has been introduced. This flag is
  2963                                  ;set to 4 if there is no CR-LF before the EOF -- this is determined by looking
  2964                                  ;at the buffer contents. If there is no LF ( we assume that presence of LF
  2965                                  ;indicated a CR-LF combination), then we set BatchEOF to 4 and return a 
  2966                                  ;fake CR to the caller. This decrements BatchEOF. On the next call to this
  2967                                  ;routine, BatchEOF is decremented to 2 and a fake lF is returned. On the 
  2968                                  ;third call, BatchEOF becomes zero and batch processing is turned off,
  2969                                  ;now that the last line has been processed. If the EOF is the first char read into the buffer 
  2970                                  ;during this call, and there was a CR-LF previously, we are going to fake
  2971                                  ;another redundant CR-LF. There is no work-around I can think of.
  2972                                  ; 	I would love to restructure this entire routine and its caller to
  2973                                  ;make the flow really easy to understand but I guess this will have to wait.
  2974                                  ;
  2975                                  		;push	es
  2976                                  		;mov	es,ResSeg
  2977                                  ;SR;
  2978                                  ; If we had already set the BatchEOF flag on a previous call (BatchEOF == 2
  2979                                  ;or BatchEOF == 1 now), then do not do the LF check.
  2980                                  ;
  2981                                  		;mov	es,es:Batch
  2982                                  		;cmp	es:BatchEOF,0
  2983                                  		;jnz	crpresent
  2984                                  
  2985                                  		;inc	es:BatchEOF		;match the dec following
  2986                                  		;mov	bx,BatBufEnd
  2987                                  		;cmp	BatBuf[bx-1],0ah	;was a LF present?
  2988                                  		;je	crpresent		;yes, no need to fake it
  2989                                  
  2990                                  		;add	es:BatchEOF,3		;BatchEOF == 4 to fake CR-LF
  2991                                  
  2992                                  ;crpresent:
  2993                                  ;;;		;pop	es
  2994                                  
  2995                                  		;ASSUME	DS:TranGroup
  2996                                  		;MOV	DS,ResSeg
  2997                                  		;ASSUME	DS:ResGroup
  2998                                  
  2999                                  ;SR;
  3000                                  ; The shift operation is done here to replace the decrement. This is because
  3001                                  ;we can jump to this label directly from above when bogus calls are made to
  3002                                  ;this routine even after batch processing is turned off. The shift ensures
  3003                                  ;maintains the following invariance : 4 -> 2; 2 -> 1 ; 1 -> 0; 0 -> 0. Thus,
  3004                                  ;it is used as a decrement and also as a NOP to just fall through on bogus 
  3005                                  ;calls.
  3006                                  ;	We turn batch processing off if BatchEOF == 1 or BatchEOF == 0.
  3007                                  ;BatchEOF == 1 when we fall through from BatEOFDS and BatchEOF == 0 on a 
  3008                                  ;direct jump to BATEOF. If BatchEOF == 4, we return a fake CR-LF without 
  3009                                  ;turning batch processing off.
  3010                                  
  3011                                  ;At_EOF:						;new label added ;M020
  3012                                  		;shr	es:BatchEOF,1		;decrement the flag
  3013                                  		;jz	turn_off		;zero,turn batch off
  3014                                  		;cmp	es:BatchEOF,1				
  3015                                  		;jz	ret_lf			;BatchEOF was 2, return LF
  3016                                  ;
  3017                                  ;BatchEOF == 4, indicates return fake CR now and fake LF next.
  3018                                  ;
  3019                                  		;mov	al,0dh			;return fake CR.
  3020                                  		;pop	es
  3021                                  		;jmp	short GetByteDone
  3022                                  ;ret_lf:
  3023                                  		;mov	al,0ah			;return fake LF
  3024                                  		;pop	es
  3025                                  		;jmp	short GetByteDone			
  3026                                  ;turn_off:
  3027                                  		;pop	es
  3028                                  
  3029                                  ;BATEOF:
  3030                                  
  3031                                  		; MSDOS 3.3
  3032                                  TURN_OFF:
  3033 000008EC 8E1E[8141]              		mov	ds,[RESSEG]
  3034                                  
  3035                                  		; MSDOS 3.3 (& MSDOS 6.0)
  3036                                  BATEOF:
  3037 000008F0 E830FF                  		call	BATCHOFF
  3038 000008F3 E89A02                  		call	BATCLOSE
  3039                                  ;;;		mov	BatchEOF,0	;make sure BatchEOF = 0
  3040                                  
  3041                                  ;SR; BugBug
  3042                                  ; There is a good reason why this carriage return is being returned here. 
  3043                                  ;This was part of the old code, thanks to some brain-damaged coding. Because,
  3044                                  ;of the way the caller is structured, a fake CR has to be returned again on
  3045                                  ;EOF to ensure the termination of the caller's loop. If echo is on, this
  3046                                  ;results in an extra linefeed after the batchfile is run if the last line of
  3047                                  ;the batchfile already had a CR-LF. 
  3048                                  ;NB: Do not confuse this with the faked CR. The fake CR-LF was to mark
  3049                                  ;the end-of-line. This CR is to mark the end-of-file.
  3050                                  
  3051 000008F6 B00D                    		mov	al,0Dh		; If end-of-file, then end of line
  3052 000008F8 F606DF0BFF              		test	byte [BATCH_ABORT],-1
  3053 000008FD C606DF0B00              		mov	byte [BATCH_ABORT],0
  3054 00000902 7407                    		jz	short CONT_GET_BYT
  3055 00000904 BF[E23F]                		mov	di,COMBUF+2	; reset pointer to beginning of buffer
  3056 00000907 31C9                    		xor	cx,cx		; zero line length
  3057 00000909 EB14                    		jmp	short GETBYTEDONE
  3058                                  CONT_GET_BYT:
  3059 0000090B 833EEF0BF0              		cmp	word [SINGLECOM],0FFF0h ; See if we need to set SINGLECOM
  3060 00000910 750D                    		jnz	short GETBYTEDONE
  3061 00000912 833EF80B00              		cmp	word [NEST],0	;G See if we have nested batch files
  3062 00000917 7506                    		jnz	short GETBYTEDONE ;G Yes - don't exit just yet
  3063 00000919 C706EF0BFFFF            		mov	word [SINGLECOM],0FFFFh ; -1 ; Cause termination
  3064                                  GETBYTEDONE:
  3065 0000091F 1F                      		pop	ds
  3066 00000920 59                      		pop	cx
  3067 00000921 5B                      		pop	bx
  3068 00000922 C3                      		retn
  3069                                  
  3070                                  ; ---------------------------------------------------------------------------
  3071                                  
  3072                                  ;break	<$If - conditional execution>
  3073                                  
  3074                                  IFERRORP:
  3075 00000923 58                      		pop	ax
  3076                                  IFERROR:
  3077                                  FORERROR:
  3078 00000924 BA[A83B]                		mov	dx,SYNTMESPTR
  3079 00000927 E9C012                  		jmp	CERROR
  3080                                  
  3081                                  ; ---------------------------------------------------------------------------
  3082                                  
  3083                                  _$IF:
  3084                                  		; MSDOS 6.0
  3085                                  ; Turn off any pipes in progress.
  3086                                  		;push	ds			;AN004; save local DS
  3087                                  		;mov	ds,[resseg]		;AN004; get resident segment
  3088                                  		;assume	ds:resgroup		;AN004;
  3089                                  		;cmp	[PIPEFILES],0		;AN004; Only turn off if present.
  3090                                  		;jz	IFNoPipe		;AN004; no pipe - continue
  3091                                  		;invoke	PipeDel 		;AN004; turn off piping
  3092                                  ;IFNoPipe:					;AN004;
  3093                                  		;pop	ds			;AN004; get local DS back
  3094                                  		;assume	ds:trangroup		;AN004;
  3095                                  
  3096                                  		; MSDOS 3.3 (&MSDOS 6.0)
  3097 0000092A C606[9441]00            		mov	byte [IFNOTFLAG],0
  3098 0000092F C706[054B]0000          		mov	word [IF_NOT_COUNT],0
  3099 00000935 BE8100                  		mov	si,81h
  3100                                  IFREENT:
  3101 00000938 E80B10                  		call	SCANOFF
  3102 0000093B 3C0D                    		cmp	al,0Dh
  3103 0000093D 74E5                    		jz	short IFERROR
  3104 0000093F 89F5                    		mov	bp,si
  3105 00000941 BF[F73C]                		mov	di,IFTAB	; Prepare to search if table	
  3106 00000944 B500                    		mov	ch,0
  3107                                  IFINDCOM:
  3108 00000946 89EE                    		mov	si,bp
  3109 00000948 8A0D                    		mov	cl,[di]
  3110 0000094A 47                      		inc	di
  3111 0000094B E337                    		jcxz	IFSTRING
  3112 0000094D EB02                    		jmp	short FIRSTCOMP
  3113                                  IFCOMP:
  3114 0000094F 7510                    		jnz	short IF_DIF
  3115                                  FIRSTCOMP:
  3116 00000951 AC                      		lodsb
  3117 00000952 268A25                  		mov	ah,[es:di]
  3118 00000955 47                      		inc	di
  3119 00000956 38E0                    		cmp	al,ah
  3120 00000958 7405                    		jz	short IFLP
  3121 0000095A 80CC20                  		or	ah,20h		; Try lower case
  3122 0000095D 38E0                    		cmp	al,ah
  3123                                  IFLP:
  3124 0000095F E2EE                    		loop	IFCOMP
  3125                                  IF_DIF:
  3126 00000961 9F                      		lahf
  3127 00000962 01CF                    		add	di,cx		; Bump to next position without affecting flags
  3128 00000964 8B1D                    		mov	bx,[di]		; Get handler address
  3129 00000966 47                      		inc	di
  3130 00000967 47                      		inc	di
  3131 00000968 9E                      		sahf
  3132 00000969 75DB                    		jnz	short IFINDCOM
  3133 0000096B AC                      		lodsb
  3134 0000096C 3C0D                    		cmp	al,0Dh
  3135                                  IFERRJ:
  3136 0000096E 74B4                    		jz	short IFERROR
  3137 00000970 E8DB0F                  		call	DELIM
  3138 00000973 75D1                    		jnz	short IFINDCOM
  3139 00000975 E8CE0F                  		call	SCANOFF
  3140 00000978 FFE3                    		jmp	bx
  3141                                  IFNOT:
  3142 0000097A F616[9441]              		not	byte [IFNOTFLAG]
  3143 0000097E FF06[054B]              		inc	word [IF_NOT_COUNT]
  3144 00000982 EBB4                    		jmp	short IFREENT
  3145                                  
  3146                                  ; We are comparing two strings for equality. First, find the end of the
  3147                                  ; first string.
  3148                                  
  3149                                  IFSTRING:
  3150 00000984 56                      		push	si		; save away pointer for later compare
  3151 00000985 31C9                    		xor	cx,cx		; count of chars in first string
  3152                                  FIRST_STRING:
  3153 00000987 AC                      		lodsb			; get character
  3154 00000988 3C0D                    		cmp	al,0Dh		; end of line?
  3155 0000098A 7497                    		jz	short IFERRORP	; yes => error
  3156 0000098C E8BF0F                  		call	DELIM		; is it a delimiter?
  3157 0000098F 7403                    		jz	short EQUAL_CHECK ; yes, go find equal sign
  3158 00000991 41                      		inc	cx		; remember 1 byte for the length
  3159 00000992 EBF3                    		jmp	short FIRST_STRING ; go back for more
  3160                                  EQUAL_CHECK:
  3161 00000994 3C3D                    		cmp	al,'='		; is char we have an = sign?
  3162 00000996 7407                    		jz	short EQUAL_CHECK2 ; yes, go find second one.
  3163 00000998 3C0D                    		cmp	al,0Dh		; end of line?
  3164 0000099A 7487                    		jz	short IFERRORP	; yes, syntax error
  3165 0000099C AC                      		lodsb			; get next char
  3166 0000099D EBF5                    		jmp	short EQUAL_CHECK
  3167                                  
  3168                                  ; The first = has been found. The next char had better be an = too.
  3169                                  
  3170                                  EQUAL_CHECK2:
  3171 0000099F AC                      		lodsb			; get potential = char
  3172 000009A0 3C3D                    		cmp	al,'='		; is it good?	
  3173 000009A2 7520                    		jnz	short IFERRPJ	; no, error
  3174                                  
  3175                                  ; Find beginning of second string.
  3176                                  
  3177 000009A4 E89F0F                  		call	SCANOFF
  3178 000009A7 3C0D                    		cmp	al,0Dh
  3179 000009A9 7419                    		jz	short IFERRPJ
  3180 000009AB 5F                      		pop	di
  3181                                  
  3182                                  ; DS:SI points to second string
  3183                                  ; CX has number of chars in first string
  3184                                  ; ES:DI points to first string
  3185                                  
  3186 000009AC F3A6                    		repe cmpsb
  3187 000009AE 7417                    		jz	short MATCH	; match found!
  3188                                  
  3189                                  ; No match.  Let's find out what was wrong. The character that did not match
  3190                                  ; has been advanced over. Let's back up to it.
  3191                                  
  3192 000009B0 4E                      		dec	si
  3193                                  
  3194                                  ; If it is EOL, then syntax error
  3195                                  
  3196 000009B1 803C0D                  		cmp	byte [si],0Dh
  3197 000009B4 74B8                    		jz	short IFERRJ
  3198                                  
  3199                                  ; Advance pointer over remainder of unmatched text to next delimiter
  3200                                  
  3201                                  SKIPSTRINGEND:
  3202 000009B6 AC                      		lodsb
  3203                                  NOTMATCH:
  3204 000009B7 3C0D                    		cmp	al,0Dh
  3205                                  IFERRORJ2:
  3206 000009B9 74B3                    		jz	short IFERRJ
  3207 000009BB E8900F                  		call	DELIM
  3208 000009BE 75F6                    		jnz	short SKIPSTRINGEND
  3209                                  
  3210                                  ; Signal that we did NOT have a match
  3211                                  
  3212 000009C0 B0FF                    		mov	al,-1
  3213 000009C2 EB3A                    		jmp	short IFRET
  3214                                  IFERRPJ:
  3215 000009C4 E95CFF                  		jmp	IFERRORP
  3216                                  
  3217                                  ; The compare succeeded. Was the second string longer than the first?
  3218                                  ; We do this by seeing if the next char is a delimiter.
  3219                                  
  3220                                  MATCH:
  3221 000009C7 AC                      		lodsb
  3222 000009C8 E8830F                  		call	DELIM
  3223 000009CB 75EA                    		jnz	short NOTMATCH ; not same.
  3224 000009CD 30C0                    		xor	al,al
  3225 000009CF EB2D                    		jmp	short IFRET
  3226                                  
  3227                                  ; ---------------------------------------------------------------------------
  3228                                  
  3229                                  IFEXISTS:
  3230                                  
  3231                                  IFEXIST_ATTR	EQU	ATTR_HIDDEN+ATTR_SYSTEM  ; 2+4 = 6
  3232                                  
  3233                                  ;MOREDELIM:
  3234 000009D1 AC                      		lodsb
  3235 000009D2 E8790F                  		call	DELIM
  3236 000009D5 75FA                    		jnz	short IFEXISTS
  3237                                  		;jnz	short MOREDELIM
  3238                                  
  3239 000009D7 BA[7A42]                		mov	dx,DIRBUF
  3240 000009DA B8001A                  		mov	ax,SET_DMA*256 ; 1A00h
  3241 000009DD CD21                    		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
  3242                                  				; DS:DX	-> disk	transfer buffer
  3243 000009DF BB0200                  		mov	bx,2		; if(0) [|not](|1) exist[1|2] file(2|3)
  3244 000009E2 031E[054B]              		add	bx,[IF_NOT_COUNT]
  3245                                  		;mov	ax,ARG_ARGV
  3246                                  		;mov	ax,ARG+ARG_UNIT.argv
  3247 000009E6 B8[B944]                		mov	ax,ARG
  3248 000009E9 E86A1A                  		call	ARGV_CALC	; convert arg index to pointer
  3249 000009EC 8B17                    		mov	dx,[bx]
  3250                                  		;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
  3251                                  		;mov	cx,6
  3252 000009EE B90600                  		mov	cx,IFEXIST_ATTR ; filetypes to search for
  3253 000009F1 B8004E                  		mov	ax,FIND_FIRST*256 ; 4E00h ; request first match, if any
  3254 000009F4 CD21                    		int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
  3255                                  				; CX = search attributes
  3256                                  				; DS:DX	-> ASCIZ filespec
  3257                                  				; (drive,path, and wildcards allowed)
  3258 000009F6 7204                    		jc	short IF_EX_C ; carry is how to determine error
  3259 000009F8 30C0                    		xor	al,al
  3260 000009FA EB02                    		jmp	short IFRET
  3261                                  
  3262                                  		;nop
  3263                                  IF_EX_C:
  3264 000009FC B0FF                    		mov	al,-1		; false 'n' fall through...
  3265                                  IFRET:
  3266 000009FE F606[9441]FF            		test	byte [IFNOTFLAG],-1 ; 0FFh
  3267 00000A03 7402                    		jz	short REALTEST
  3268 00000A05 F6D0                    		not	al
  3269                                  REALTEST:
  3270 00000A07 08C0                    		or	al,al
  3271 00000A09 7403                    		jz	short IFTRUE
  3272 00000A0B E9F6F6                  		jmp	TCOMMAND
  3273                                  
  3274                                  IFTRUE:
  3275 00000A0E E8350F                  		call	SCANOFF
  3276 00000A11 89F1                    		mov	cx,si
  3277 00000A13 81E98100                		sub	cx,81h
  3278 00000A17 280E8000                		sub	[80h],cl
  3279 00000A1B 8A0E8000                		mov	cl,[80h]
  3280 00000A1F 880E[E13F]              		mov	[COMBUF+1],cl
  3281 00000A23 BF[E23F]                		mov	di,COMBUF+2
  3282 00000A26 FC                      		cld
  3283 00000A27 F3A4                    		rep movsb
  3284 00000A29 B00D                    		mov	al,0Dh
  3285 00000A2B AA                      		stosb
  3286                                  
  3287                                  ; Signal that an IF was done. 
  3288                                  ; This prevents the redirections from getting lost.
  3289                                  
  3290 00000A2C 1E                      		push	ds
  3291 00000A2D 8E1E[8141]              		mov	ds,[RESSEG]
  3292 00000A31 C606F40BFF              		mov	byte [IFFLAG],-1
  3293 00000A36 1F                      		pop	ds
  3294                                  
  3295                                  ; Go do the command
  3296                                  
  3297 00000A37 E973F8                  		jmp	DOCOM1
  3298                                  
  3299                                  ; ---------------------------------------------------------------------------
  3300                                  
  3301                                  IFERRORJ3:
  3302 00000A3A E97CFF                  		jmp	IFERRORJ2
  3303                                  
  3304                                  IFERLEV:
  3305 00000A3D B70A                    		mov	bh,10
  3306 00000A3F 30DB                    		xor	bl,bl
  3307                                  GETNUMLP:
  3308 00000A41 AC                      		lodsb
  3309 00000A42 3C0D                    		cmp	al,0Dh
  3310 00000A44 74F4                    		jz	short IFERRORJ3
  3311 00000A46 E8050F                  		call	DELIM
  3312 00000A49 740C                    		jz	short GOTNUM
  3313 00000A4B 2C30                    		sub	al,'0'
  3314 00000A4D 86C3                    		xchg	al,bl
  3315 00000A4F F6E7                    		mul	bh
  3316 00000A51 00D8                    		add	al,bl
  3317 00000A53 86C3                    		xchg	al,bl
  3318 00000A55 EBEA                    		jmp	short GETNUMLP
  3319                                  GOTNUM:
  3320 00000A57 1E                      		push	ds
  3321 00000A58 8E1E[8141]              		mov	ds,[RESSEG]
  3322 00000A5C 8A26E60B                		mov	ah,[RETCODE]	; [0BEAh] in MSDOS 3.3 COMMAND.COM 
  3323 00000A60 1F                      		pop	ds
  3324 00000A61 30C0                    		xor	al,al
  3325 00000A63 38DC                    		cmp	ah,bl
  3326 00000A65 7397                    		jnb	short IFRET
  3327 00000A67 FEC8                    		dec	al
  3328 00000A69 EB93                    		jmp	short IFRET
  3329                                  
  3330                                  ; ---------------------------------------------------------------------------
  3331                                  
  3332                                  ; Shift the parameters in the batch structure by 1 and set up the new argument.
  3333                                  ; This is a NOP if no batch in progress.
  3334                                  
  3335                                  SHIFT:
  3336 00000A6B 8E1E[8141]              		mov	ds,[RESSEG]
  3337 00000A6F A1930B                  		mov	ax,[BATCH]	; get batch pointer
  3338 00000A72 09C0                    		or	ax,ax		; in batch mode?
  3339 00000A74 7501                    		jnz	short SHIFT1	; yes, operate in batch segment	
  3340                                  SHIFT_RETN:				; no, done.
  3341 00000A76 C3                      		retn
  3342                                  SHIFT1:
  3343 00000A77 8EC0                    		mov	es,ax
  3344 00000A79 8ED8                    		mov	ds,ax
  3345                                  
  3346                                  ; Now move the batch args down by 1 word
  3347                                  
  3348                                  		;mov	di,0Bh ; MSDOS 3.3 COMMAND.COM
  3349 00000A7B BF0B00                  		mov	di,BATCHSEGMENT.BatParm ; point to parm table
  3350 00000A7E 8D7502                  		lea	si,[di+2]	; make source = dest + 2
  3351 00000A81 B90900                  		mov	cx,9		; move 9 parameters
  3352 00000A84 F3A5                    		rep movsw		; SHIFT down
  3353                                  
  3354                                  ; If the last parameter (the one not moved) is empty (= -1) then we are done.
  3355                                  ; We have copied it into the previous position.
  3356                                  
  3357 00000A86 833DFF                  		cmp	word [di],-1	; if last one was not in use then
  3358 00000A89 74EB                    		jz	short SHIFT_RETN ; No new parm
  3359                                  
  3360                                  ; This last pointer is NOT nul. Get it and scan to find the next argument.
  3361                                  ; Assume, first, that there is no next argument.
  3362                                   
  3363 00000A8B 8B35                    		mov	si,[di]
  3364 00000A8D C705FFFF                		mov	word [di],-1	; Assume no parm
  3365                                  
  3366                                  ; The parameters are CR separated. Scan for end of this parm.
  3367                                  
  3368                                  SKIPCRLP:
  3369 00000A91 AC                      		lodsb
  3370 00000A92 3C0D                    		cmp	al,0Dh
  3371 00000A94 75FB                    		jnz	short SKIPCRLP
  3372                                  
  3373                                  ; We are now pointing at next arg. If it is 0 (end of original line) then we
  3374                                  ; are finished. There are no more parms and the pointer has been previously
  3375                                  ; initialized to indicate it.
  3376                                  
  3377 00000A96 803C00                  		cmp	byte [si],0
  3378 00000A99 74DB                    		jz	short SHIFT_RETN ; End of parms
  3379 00000A9B 8935                    		mov	[di],si		; Pointer to next parm as %9
  3380 00000A9D C3                      		retn
  3381                                  
  3382                                  ; =============== S U B	R O U T	I N E =======================================
  3383                                  
  3384                                  ; Skip delim reads bytes from the batch file until a non-delimiter is seen.
  3385                                  ; returns char in AL, carry set -> eof
  3386                                  
  3387                                  SKIPDELIM:
  3388 00000A9E F706930BFFFF            		test	word [BATCH],-1	; batch file empty.  OOPS!
  3389 00000AA4 740A                    		jz	short SKIPERR
  3390 00000AA6 E8DFFD                  		call	GETBATBYT	; get a char
  3391 00000AA9 E8A20E                  		call	DELIM		; check for ignoreable chars
  3392 00000AAC 74F0                    		jz	short SKIPDELIM	; ignore this char.
  3393 00000AAE F8                      		clc
  3394 00000AAF C3                      		retn
  3395                                  SKIPERR:
  3396 00000AB0 F9                      		stc
  3397                                  GOTO_RETN:
  3398 00000AB1 C3                      		retn
  3399                                  
  3400                                  ; ---------------------------------------------------------------------------
  3401                                  
  3402                                  ;  CALL is an internal command that transfers control to a .bat, .exe, or
  3403                                  ;  .com file. This routine strips the CALL off the command line, sets
  3404                                  ;  the CALL_FLAG to indicate a call in progress, and returns control to
  3405                                  ;  DOCOM1 in TCODE to reprocess the command line and execute the file
  3406                                  ;  being CALLed.
  3407                                  
  3408                                  _$CALL:
  3409                                  
  3410                                  ;  strip off CALL from command line
  3411                                  
  3412                                  		;ASSUME DS:trangroup,ES:trangroup
  3413                                  
  3414 00000AB2 56                      		push	si
  3415 00000AB3 57                      		push	di
  3416 00000AB4 50                      		push	ax
  3417 00000AB5 51                      		push	cx
  3418 00000AB6 BE[E23F]                		mov	si,COMBUF+2
  3419 00000AB9 E88A0E                  		call	SCANOFF		;get to first non-delimeter
  3420                                  		;add	si,4
  3421 00000ABC 83C604                  		add	si,length_call	;point to char past CALL
  3422 00000ABF BF[E23F]                		mov	di,COMBUF+2
  3423                                  		;mov	cx,124		
  3424 00000AC2 B97C00                  		mov	cx,COMBUFLEN-length_call ;get length of buffer
  3425 00000AC5 F3A4                    		rep movsb		;move it
  3426 00000AC7 59                      		pop	cx
  3427 00000AC8 58                      		pop	ax
  3428 00000AC9 5F                      		pop	di
  3429 00000ACA 5E                      		pop	si
  3430                                  
  3431                                  ;  set call flag to indicate call in progress
  3432                                  
  3433 00000ACB 1E                      		push	ds
  3434 00000ACC 8E1E[8141]              		mov	ds,[RESSEG]
  3435 00000AD0 C606FA0B01              		mov	byte [CALL_FLAG],call_in_progress ; 1
  3436 00000AD5 C606FB0B01              		mov	byte [CALL_BATCH_FLAG],call_in_progress ; 1
  3437                                  
  3438                                  ; Turn off any pipes in progress.
  3439                                  
  3440 00000ADA 803E570C00              		cmp	byte [PIPEFILES],0 ; Only turn off if present.
  3441 00000ADF 7403                    		jz	short _NOPIPE
  3442 00000AE1 E8E113                  		call	PIPEDEL
  3443                                  _NOPIPE:
  3444 00000AE4 1F                      		pop	ds
  3445 00000AE5 C3                      		retn
  3446                                  
  3447                                  ; ---------------------------------------------------------------------------
  3448                                  
  3449                                  GOTO:
  3450 00000AE6 8E1E[8141]              		mov	ds,[RESSEG]
  3451 00000AEA F706930BFFFF            		test	word [BATCH],-1	; If not in batch mode, a nop
  3452 00000AF0 74BF                    		jz	short GOTO_RETN
  3453 00000AF2 31D2                    		xor	dx,dx
  3454 00000AF4 1E                      		push	ds
  3455 00000AF5 8E1E930B                		mov	ds,[BATCH]
  3456 00000AF9 89160700                		mov	[BATCHSEGMENT.BatSeek],dx ; Back to start
  3457 00000AFD 89160900                		mov	[BATCHSEGMENT.BatSeek+2],dx ; Back to start
  3458                                  
  3459                                  		; MSDOS 6.0
  3460                                  ;M037
  3461                                  ; Clear EOF indicator because we have reseeked to the beginning of the file.
  3462                                  ;
  3463                                  		;mov	ds:BatchEOF,0	; clear eof indicator ;M037
  3464                                  
  3465                                  		; MSDOS 3.3 (& MSDOS 6.0)
  3466                                  
  3467 00000B01 1F                      		pop	ds
  3468                                  GOTOOPEN:
  3469 00000B02 E8B1F9                  		call	PROMPTBAT
  3470                                  		;mov	di,5Dh
  3471 00000B05 BF5D00                  		mov	di,FCB+1	; Get the label
  3472 00000B08 B90B00                  		mov	cx,11
  3473 00000B0B B020                    		mov	al,' '
  3474 00000B0D F2AE                    		repne scasb
  3475 00000B0F 7501                    		jnz	short NOINC
  3476 00000B11 41                      		inc	cx
  3477                                  NOINC:
  3478 00000B12 83E90B                  		sub	cx,11
  3479 00000B15 F7D9                    		neg	cx
  3480 00000B17 2E890E[7A42]            		mov	[cs:GOTOLEN],cx
  3481                                  
  3482                                  ; At beginning of file. Skip to first non-delimiter char
  3483                                  
  3484 00000B1C E87FFF                  		call	SKIPDELIM
  3485 00000B1F 721C                    		jb	short BADGOTO
  3486 00000B21 3C3A                    		cmp	al,':'
  3487 00000B23 7423                    		jz	short CHKLABEL
  3488                                  LABLKLP:				; Look for the label
  3489 00000B25 E860FD                  		call	GETBATBYT
  3490 00000B28 3C0A                    		cmp	al,0Ah
  3491 00000B2A 7509                    		jnz	short LABLKTST
  3492                                  
  3493                                  ; At beginning of line.  Skip to first non-delimiter char
  3494                                  
  3495 00000B2C E86FFF                  		call	SKIPDELIM
  3496 00000B2F 720C                    		jb	short BADGOTO
  3497 00000B31 3C3A                    		cmp	al,':'
  3498 00000B33 7413                    		jz	short CHKLABEL
  3499                                  LABLKTST:
  3500 00000B35 F706930BFFFF            		test	word [BATCH],0FFFFh ; -1
  3501 00000B3B 75E8                    		jnz	short LABLKLP
  3502                                  BADGOTO:
  3503 00000B3D E85000                  		call	BATCLOSE
  3504                                  
  3505                                  		; MSDOS 6.0
  3506                                  ;SR;
  3507                                  ; At this point we are terminating without freeing up any nested batch 
  3508                                  ;segments i.e if the error occurred within a called batch file. This routine
  3509                                  ;will traverse the linked list of batch segments and free all of them.
  3510                                  ;
  3511                                  		;call	free_batch	;free up nested batch segments
  3512                                  
  3513                                  		; MSDOS 3.3 (& MSDOS 6.0)
  3514 00000B40 0E                      		push	cs
  3515 00000B41 1F                      		pop	ds
  3516 00000B42 BA[973B]                		mov	dx,BADLABPTR
  3517 00000B45 E9A210                  		jmp	CERROR
  3518                                  
  3519                                  ; Found the :.	Skip to first non-delimiter char
  3520                                  
  3521                                  CHKLABEL:
  3522 00000B48 E853FF                  		call	SKIPDELIM
  3523 00000B4B 72F0                    		jb	short BADGOTO
  3524 00000B4D BF5D00                  		mov	di,FCB+1 ; 5Dh
  3525 00000B50 2E8B0E[7A42]            		mov	cx,[cs:GOTOLEN]
  3526 00000B55 EB05                    		jmp	short GOTBYTE
  3527                                  NEXTCHRLP:
  3528 00000B57 51                      		push	cx
  3529 00000B58 E82DFD                  		call	GETBATBYT
  3530 00000B5B 59                      		pop	cx
  3531                                  GOTBYTE:
  3532 00000B5C 0C20                    		or	al,20h
  3533 00000B5E 263A05                  		cmp	al,[es:di]
  3534 00000B61 7502                    		jnz	short TRYUPPER
  3535 00000B63 EB07                    		jmp	short NEXTLABCHR
  3536                                  TRYUPPER:
  3537 00000B65 2C20                    		sub	al,20h
  3538 00000B67 263A05                  		cmp	al,[es:di]
  3539 00000B6A 75C9                    		jnz	short LABLKTST
  3540                                  NEXTLABCHR:
  3541 00000B6C 47                      		inc	di
  3542 00000B6D E2E8                    		loop	NEXTCHRLP
  3543 00000B6F E816FD                  		call	GETBATBYT
  3544 00000B72 2E833E[7A42]08          		cmp	word [cs:GOTOLEN],8 ; Is the label atleast 8 chars long?
  3545 00000B78 7D04                    		jge	short GOTOCONT	; Yes, then the next char doesn't matter
  3546 00000B7A 3C20                    		cmp	al,' '
  3547 00000B7C 77B7                    		ja	short LABLKTST
  3548                                  GOTOCONT:
  3549 00000B7E 3C0D                    		cmp	al,0Dh
  3550 00000B80 7407                    		jz	short SKIPLFEED
  3551                                  TONEXTBATLIN:
  3552 00000B82 E803FD                  		call	GETBATBYT
  3553 00000B85 3C0D                    		cmp	al,0Dh
  3554 00000B87 75F9                    		jnz	short TONEXTBATLIN
  3555                                  SKIPLFEED:
  3556 00000B89 E8FCFC                  		call	GETBATBYT
  3557                                  
  3558                                  		; MSDOS 6.0
  3559                                  ;SR;
  3560                                  ; The BatchEOF flag is set in GetBatByt to indicate that we are faking a 
  3561                                  ;CR-LF for the last line. On a goto, this flag has to be cleared, because
  3562                                  ;BatchEOF == 1 now, after returning a CR-LF. The next call to GetBatByt
  3563                                  ;to get the EOF has not been made yet because we encountered the Goto. On
  3564                                  ;all other cases, EOF will be hit while trying to read the next line and
  3565                                  ;we are fine. I know, I know, what a massive hack from hell!! God help us!!
  3566                                  ;
  3567                                  		;push	es
  3568                                  		;mov	es,Batch
  3569                                  		;mov	es:BatchEOF,0	;invalidate fake CR-LF flag
  3570                                  		;pop	es
  3571                                  
  3572                                  		; MSDOS 3.3 (& MSDOS 6.0)
  3573 00000B8C E80100                  		call	BATCLOSE
  3574 00000B8F C3                      		retn
  3575                                  
  3576                                  ; =============== S U B	R O U T	I N E =======================================
  3577                                  
  3578                                  BATCLOSE:
  3579 00000B90 2E8B1E[A544]            		mov	bx,[cs:BATHAND]
  3580 00000B95 83FB05                  		cmp	bx,5
  3581 00000B98 7204                    		jb	short CLOSERETURN
  3582 00000B9A B43E                    		mov	ah,CLOSE ; 3Eh
  3583 00000B9C CD21                    		int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
  3584                                  				; BX = file handle
  3585                                  CLOSERETURN:
  3586 00000B9E C606DE0B00              		mov	byte [IN_BATCH],0 ; reset flag	
  3587 00000BA3 C3                      		retn
  3588                                  
  3589                                  ; =============== S U B	R O U T	I N E =======================================
  3590                                  
  3591                                  ; Open the BATCH file, If open fails, AL is drive of batch file (A=1)
  3592                                  ; Also, fills internal batch buffer. If access denied, then AX = -1
  3593                                  
  3594                                  BATOPEN:
  3595 00000BA4 1E                      		push	ds
  3596 00000BA5 8E1E930B                		mov	ds,[BATCH]
  3597                                  		;mov	dx,1Fh	; MSDOS 3.3 COMMAND.COM
  3598 00000BA9 BA1F00                  		mov	dx,BATCHSEGMENT.BatFile
  3599 00000BAC B8003D                  		mov	ax,(OPEN<<8) ; 3D00h ; Open the batch file
  3600 00000BAF CD21                    		int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
  3601                                  				; DS:DX	-> ASCIZ filename
  3602                                  				; AL = access mode
  3603                                  				; 0 - read
  3604 00000BB1 721C                    		jb	short SETERRDL
  3605 00000BB3 8B160700                		mov	dx,[BATCHSEGMENT.BatSeek]
  3606 00000BB7 8B0E0900                		mov	cx,[BATCHSEGMENT.BatSeek+2]
  3607 00000BBB 1F                      		pop	ds
  3608 00000BBC 2EA3[A544]              		mov	[cs:BATHAND],ax
  3609 00000BC0 89C3                    		mov	bx,ax
  3610 00000BC2 B80042                  		mov	ax,(LSEEK<<8) ; 4200h ; Go to the right spot
  3611 00000BC5 CD21                    		int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
  3612                                  				; AL = method: offset from beginning of	file
  3613                                  
  3614 00000BC7 2EC706[284C]FFFF        		mov	word [cs:BATBUFPOS],-1 ; 0FFFFh ; nuke batch buffer position
  3615                                  BATOPEN_RETN:
  3616 00000BCE C3                      		retn
  3617                                  
  3618                                  SETERRDL:
  3619 00000BCF 89D3                    		mov	bx,dx
  3620                                  		; MSDOS 6.0
  3621                                  		;invoke	get_ext_error_number ;AN022; get the extended error
  3622                                  		;mov	dx,ax		     ;AN022; save extended error in DX
  3623                                  
  3624                                  		; MSDOS 3.3
  3625 00000BD1 BA[CE36]                		mov	dx,INSERTDSKPTR
  3626 00000BD4 E8A212                  		call	GET_EXT_ERR_NUMBER
  3627                                  
  3628                                  		; MSDOS 3.3 (& MSDOS 6.0)
  3629 00000BD7 8A07                    		mov	al,[bx]		; Get drive spec
  3630 00000BD9 2C40                    		sub	al,'@'		; A = 1
  3631 00000BDB 1F                      		pop	ds
  3632 00000BDC F9                      		stc			; SUB mucked over carry
  3633 00000BDD C3                      		retn
  3634                                  
  3635                                  ;============================================================================
  3636                                  ; TFOR.ASM, MSDOS 6.0, 1991
  3637                                  ;============================================================================
  3638                                  ; 10/10/2018 - Retro DOS v3.0
  3639                                  
  3640                                  ; All batch proccessing has DS set to segment of resident portion
  3641                                  ;ASSUME DS:RESGROUP,ES:TRANGROUP
  3642                                  
  3643                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0BE9h
  3644                                  
  3645                                  ; ---------------------------------------------------------------------------
  3646                                  
  3647                                  FORTERM:
  3648                                  		; MSDOS 6.0
  3649                                  		;push	cs		;AN037; Get local segment into
  3650                                  		;pop	ds		;AN037;    DS, ES
  3651                                  		;push	cs		;AN037;
  3652                                  		;pop	es		;AN037;
  3653                                  
  3654                                  		; MSDOS 3.3 (& MSDOS 6.0)
  3655 00000BDE E8A402                  		call	FOROFF
  3656 00000BE1 2E8E1E[8141]            		mov	ds,[cs:RESSEG]
  3657 00000BE6 813EEF0B00FF            		cmp	word [SINGLECOM],0FF00h
  3658 00000BEC 750F                    		jne	short BAT_CRLF
  3659 00000BEE 833EF80B00              		cmp	word [NEST],0	;See if we have nested batch files
  3660 00000BF3 7508                    		jne	short BAT_CRLF	;Yes - don't exit just yet
  3661 00000BF5 C706EF0BFFFF            		mov	word [SINGLECOM],-1 ; 0FFFFh ; Cause a terminate
  3662 00000BFB EB12                    		jmp	short NOFORP2
  3663                                  BAT_CRLF:
  3664 00000BFD F606E90B01              		test	byte [ECHOFLAG],1 ; Is echo on?
  3665 00000C02 740B                    		jz	short NOFORP2	; no - exit
  3666 00000C04 F706930BFFFF            		test	word [BATCH],-1 ; 0FFFFh ; ; print CRLF if in batch
  3667 00000C0A 7403                    		jz	short NOFORP2
  3668 00000C0C E82A0D                  		call	CRLF2
  3669                                  NOFORP2:
  3670 00000C0F E9F2F4                  		jmp	TCOMMAND
  3671                                  
  3672                                  ; ---------------------------------------------------------------------------
  3673                                  
  3674                                  ;------
  3675                                  ;   For-loop processing.  For loops are of the form:
  3676                                  ;	    for %<loop-variable> in (<list>) do <command>
  3677                                  ; where <command> may contain references of the form %<variable>, which are
  3678                                  ; later substituted with the items in <list>. The for-loop structure is
  3679                                  ; set-up by the procedure '$for'; successive calls to 'forproc' execute
  3680                                  ; <command> once for each item in <list>. All of the information needed for
  3681                                  ; loop processing is stored on a piece of memory gotten from 'alloc'. This
  3682                                  ; structure is actually fairly large, on the order of 700 bytes, and includes
  3683                                  ; a complete copy of the original command-line structure as parsed by
  3684                                  ; 'parseline', loop control variables, and a dma buffer for the
  3685                                  ; 'FindFirst/FindNext' expansion of wildcard filenames in <list>. When loop
  3686                                  ; processing has completed, this chunk of memory is returned to the system.
  3687                                  ;
  3688                                  ;   All of the previously defined variables, in 'datares', used for loop
  3689                                  ; processing may be erased.  Only one, (DW) ForPtr, need be allocated.
  3690                                  ;
  3691                                  ;   The error message, 'for_alloc_mes', should be moved into the file
  3692                                  ; containing all of the other error messages.
  3693                                  ;
  3694                                  ;   Referencing the allocated for-loop structure is a little tricky.
  3695                                  ; At the moment, a byte is defined as part of a new segment, 'for_segment'.
  3696                                  ; When 'forproc' actually runs, ES and DS are set to point to the base of the
  3697                                  ; new chunk of memory.	References to this byte, 'f', thus assemble correctly
  3698                                  ; as offsets of ES or DS. 'f' would not be necessary, except that the
  3699                                  ; assembler translates an instruction such as 'mov AX, [for_minarg]' as an
  3700                                  ; immediate move of the offset of 'for_minarg' into AX. In other words, in
  3701                                  ; terms of PDP-11 mnemonics, the assembler ACTUALLY assembles
  3702                                  ;	mov  AX, #for_minarg 	; AX := 02CA (for example)
  3703                                  ; instead of
  3704                                  ;	mov  AX, for_minarg	; AX := [02CA] (contents of 02CA)
  3705                                  ; By using 'f', we pretend that we are actually referencing an allocated
  3706                                  ; structure, and the assembler coughs up the code we want. Notice that it
  3707                                  ; doesn't matter whether we put brackets around the location or not -- the
  3708                                  ; assembler is "smart" enough to know that we want an address instead of the
  3709                                  ; contents of that location.
  3710                                  ;
  3711                                  ;   Finally, there now exists the potential to easily implement nested loops.
  3712                                  ; One method would be to have a link field in each for-structure pointing to
  3713                                  ; its parent.  Variable references that couldn't be resolved in the local
  3714                                  ; frame would cause a search of prior frames. For-structures would still be
  3715                                  ; allocated and released in exactly the same fashion. The only limit on the
  3716                                  ; number of nested loops would be memory size (although at 700 bytes a pop,
  3717                                  ; memory wouldn't last THAT long). Alternately, a small structure could be
  3718                                  ; maintained in the resident data area. This structure would be an array of
  3719                                  ; control-variable names and pointers to for-structure blocks. This would
  3720                                  ; greatly speed up the resolution of non-local variable references. However,
  3721                                  ; since space in the resident is precious, we would have to compromise on a
  3722                                  ; "reasonable" level of nesting -- 10, 16, 32 levels, whatever. For-structure
  3723                                  ; allocation and de-allocation would have to be modified slightly to take this
  3724                                  ; new structure into account.
  3725                                  ;
  3726                                  ;   Oops, just one more thing. Forbuf need not be a part of the for-structure.
  3727                                  ; It could just as well be one structure allocated in 'transpace'. Actually,
  3728                                  ; it may be easier to allocate it as part of 'for_segment'.
  3729                                  ;------
  3730                                  
  3731                                  		; include fordata.asm
  3732                                  
  3733                                  ; Data structure definitions included by tfor.asm
  3734                                  
  3735                                  struc FOR_INFO
  3736 00000000 <res 544h>                .FOR_ARGS:	  resb  ARG_UNIT.SIZE	; argv[] structure 
  3737 00000544 ??                        .FOR_COM_START: resb  1		; beginning of <command>
  3738 00000545 ????                      .FOR_EXPAND:	  resw  1		; * or ? item in <list>?
  3739 00000547 ????                      .FOR_MINARG:	  resw  1		; beginning of <list>
  3740 00000549 ????                      .FOR_MAXARG:	  resw  1		; end of <list>
  3741 0000054B <res 80h>                 .FORBUF:	  resw  64		; temporary buffer
  3742 000005CB <res 80h>                 .FORDMA:	  resw  64		; FindFirst/Next buffer
  3743 0000064B ??                        .FOR_VAR:	  resb  1		; loop control variable
  3744                                    .size:
  3745                                  endstruc
  3746                                  					; ARG_UNIT.SIZE = 1348 (544h)
  3747                                  
  3748                                  _$FOR_EXIT:
  3749 00000C12 EBCA                    		jmp	short FORTERM	; exceeding maxarg means all done
  3750                                  
  3751                                  ; ---------------------------------------------------------------------------
  3752                                  
  3753                                  FORPROC:
  3754 00000C14 A1F60B                  		mov	ax,[FORPTR]
  3755 00000C17 8ED8                    		mov	ds,ax
  3756 00000C19 8EC0                    		mov	es,ax		; operate in for-info area
  3757 00000C1B BACB05                  		mov	dx,FOR_INFO.FORDMA
  3758 00000C1E B8001A                  		mov	ax,SET_DMA*256 ; 1A00h
  3759 00000C21 CD21                    		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
  3760                                  				; DS:DX	-> disk	transfer buffer
  3761                                  FOR_BEGIN:
  3762 00000C23 833E450500              		cmp	word [FOR_INFO.FOR_EXPAND],0	; [545h]
  3763 00000C28 7404                    		jz	short FOR_BEGIN1
  3764                                  					; non-zero for_expand equals FALSE
  3765 00000C2A FF064705                		inc	word [FOR_INFO.FOR_MINARG]	; [547h]
  3766                                  
  3767                                  FOR_BEGIN1:
  3768 00000C2E 8B1E4705                		mov	bx,[FOR_INFO.FOR_MINARG]
  3769                                  					; current item in <list> to examine
  3770 00000C32 3B1E4905                		cmp	bx,[FOR_INFO.FOR_MAXARG]	; [549h]
  3771 00000C36 7FDA                    		jg	short _$FOR_EXIT ; exceeding maxarg means all done	
  3772                                  		;mov	ax,0
  3773 00000C38 B80000                  		mov	ax,FOR_INFO.FOR_ARGS
  3774 00000C3B E81818                  		call	ARGV_CALC	; compute argv[x] address
  3775                                  		;mov	cx,[bx+3]
  3776 00000C3E 8B4F03                  		mov	cx,[bx+ARGV_ELE.argstartel]
  3777 00000C41 8B17                    		mov	dx,[bx]
  3778                                  		;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
  3779                                  		;test	byte [bx+2],4	; Is there a path separator in this arg?
  3780 00000C43 F6470204                		test	byte [bx+ARGV_ELE.argflags],path_sep ; 4
  3781 00000C47 7514                    		jnz	short FORSUB	; Yes, argstartel should be correct
  3782 00000C49 8B37                    		mov	si,[bx]
  3783                                  		;mov	si,[bx+ARGV_ELE.argpointer]
  3784                                  
  3785                                  		;mov	al,[cs:LPAREN]
  3786                                  		; 01/03/2023
  3787 00000C4B B028                    		mov	al,lparen ; '('
  3788 00000C4D 3844FF                  		cmp	[si-1],	al	; If the current token is the first
  3789 00000C50 750B                    		jnz	short FORSUB	;  one in the list and originally had
  3790 00000C52 41                      		inc	cx		;  the opening paren as its first char,
  3791                                  					;  the argstartel ptr needs to be
  3792                                  					;  advanced passed it before the prefix
  3793                                  					;  length is computed.
  3794 00000C53 B03A                    		mov	al,':'
  3795 00000C55 384401                  		cmp	[si+1],	al	; If the token begins with "(d:",
  3796 00000C58 7503                    		jnz	short FORSUB	;  argstartel has to be moved over the
  3797 00000C5A 83C102                  		add	cx,2		;  rest of the prefix as well.
  3798                                  FORSUB:
  3799 00000C5D 29D1                    		sub	cx,dx		; compute length of pathname prefix
  3800 00000C5F 833E450500              		cmp	word [FOR_INFO.FOR_EXPAND],0 ; are we still expanding a name?
  3801 00000C64 7416                    		jz	short FOR_FIND_NEXT ; if so, get next matching filename
  3802                                  		;test	byte [bx+2],2
  3803 00000C66 F6470202                		test	byte [bx+ARGV_ELE.argflags],wildcard ; 2
  3804 00000C6A 7505                    		jnz	short FOR_FIND_FIRST ; should we expand THIS (new) arg?
  3805                                  		;mov	cx,[bx+5]	     ; else, just copy all of it directly	
  3806 00000C6C 8B4F05                  		mov	cx,[bx+ARGV_ELE.arglen]
  3807 00000C6F EB1F                    		jmp	short FOR_SMOOSH
  3808                                  
  3809                                  		;nop
  3810                                  FOR_FIND_FIRST:
  3811 00000C71 51                      		push	cx
  3812 00000C72 31C9                    		xor	cx,cx
  3813 00000C74 B8004E                  		mov	ax,FIND_FIRST*256 ; 4E00h
  3814 00000C77 CD21                    		int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
  3815                                  				; CX = search attributes
  3816                                  				; DS:DX	-> ASCIZ filespec
  3817                                  				; (drive,path, and wildcards allowed)
  3818 00000C79 59                      		pop	cx
  3819 00000C7A EB05                    		jmp	short FOR_RESULT
  3820                                  
  3821                                  		;nop
  3822                                  FOR_FIND_NEXT:
  3823 00000C7C B8004F                  		mov	ax,FIND_NEXT*256 ;4F00h
  3824 00000C7F CD21                    		int	21h	; DOS -	2+ - FIND NEXT ASCIZ (FINDNEXT)
  3825                                  				; [DTA]	= data block from
  3826                                  				; last AH = 4Eh/4Fh call
  3827                                  FOR_RESULT:
  3828 00000C81 B8FFFF                  		mov	ax,-1 ; 0FFFFh	; assume worst case
  3829 00000C84 7203                    		jc	short FOR_CHECK
  3830 00000C86 B80000                  		mov	ax,0		; Find* returns 0 for SUCCESS
  3831                                  FOR_CHECK:				; record success of findfirst/next
  3832 00000C89 A34505                  		mov	[FOR_INFO.FOR_EXPAND],ax
  3833 00000C8C 09C0                    		or	ax,ax	; anything out there?
  3834 00000C8E 7593                    		jnz	short FOR_BEGIN	; if not, try next arg
  3835                                  FOR_SMOOSH:
  3836                                  		;mov	si,[bx+ARGV_ELE.argpointer] ; mov si,[bx+0]
  3837 00000C90 8B37                    		mov	si,[bx] 	; copy argv[arg][0,CX] into destbuf
  3838 00000C92 BF4B05                  		mov	di,FOR_INFO.FORBUF ; some days this will be the entire
  3839 00000C95 F3A4                    		rep movsb		; arg, some days just the path prefix
  3840                                  					
  3841 00000C97 833E450500              		cmp	word [FOR_INFO.FOR_EXPAND],0
  3842                                  					; if we're not expanding, we can
  3843 00000C9C 750B                    		jnz	short FOR_MAKE_COM ; skip the following	
  3844                                  
  3845                                  		;mov	si,05E9h ; MSDOS 3.3 COMMAND.COM
  3846 00000C9E BEE905                  		mov	si,FOR_INFO.FORDMA+FIND_BUF.PNAME ; 14/10/2018
  3847                                  FOR_MORE:
  3848 00000CA1 803C00                  		cmp	byte [si],0	; tack on matching filename
  3849 00000CA4 7403                    		jz	short FOR_MAKE_COM
  3850 00000CA6 A4                      		movsb
  3851 00000CA7 75F8                    		jnz	short FOR_MORE
  3852                                  FOR_MAKE_COM:
  3853 00000CA9 30C0                    		xor	al,al		; tack a null byte onto the end
  3854 00000CAB AA                      		stosb			; of the substitute string
  3855 00000CAC 31C9                    		xor	cx,cx		; character count for command line
  3856 00000CAE F7D1                    		not	cx		; negate it -- take advantage of loopnz
  3857 00000CB0 31DB                    		xor	bx,bx		; argpointer
  3858 00000CB2 BF[E23F]                		mov	di,COMBUF+2
  3859 00000CB5 8A1E4405                		mov	bl,[FOR_INFO.FOR_COM_START] ; argindex
  3860 00000CB9 8A364B06                		mov	dh,[FOR_INFO.FOR_VAR] 
  3861                                  					; %<for-var> is replaced by [forbuf]
  3862 00000CBD 0E                      		push	cs		; time to form the <command> string
  3863 00000CBE 07                      		pop	es
  3864                                  		;assume ES:trangroup
  3865                                  		;mov	ax,FOR_INFO.FOR_ARGS
  3866 00000CBF B80000                  		mov	ax,0		; translate offset to pointer
  3867 00000CC2 E89117                  		call	ARGV_CALC
  3868                                  		;mov	si,[bx+9]
  3869 00000CC5 8B7709                  		mov	si,[bx+ARGV_ELE.arg_ocomptr] 
  3870                                  					; mov ptr passed beginning space
  3871 00000CC8 46                      		inc	si
  3872                                  FOR_MAKE_LOOP:
  3873 00000CC9 8A04                    		mov	al,[si]		; the <command> arg, byte by byte
  3874 00000CCB 46                      		inc	si
  3875 00000CCC 3C25                    		cmp	al,'%'		; looking for %<control-variable>
  3876 00000CCE 7514                    		jnz	short FOR_STOSB ; no % ... add byte to string
  3877 00000CD0 3834                    		cmp	[si],dh		; got the right <variable>?
  3878 00000CD2 7510                    		jnz	short FOR_STOSB	; got a %, but wrong <variable>
  3879 00000CD4 46                      		inc	si		; skip over <for-variable>
  3880                                  
  3881 00000CD5 56                      		push	si
  3882 00000CD6 BE4B05                  		mov	si,FOR_INFO.FORBUF ; substitute the <item> for <variable>
  3883                                  					; to make a final <command> to execute
  3884                                  SLOOP:					
  3885 00000CD9 AC                      		lodsb			; grab all those <item> bytes, and
  3886 00000CDA AA                      		stosb			; add 'em to the <command> string,
  3887 00000CDB 08C0                    		or	al,al		; until we run into a null
  3888 00000CDD E0FA                    		loopne	SLOOP
  3889 00000CDF 4F                      		dec	di		; adjust length and <command> pointer
  3890 00000CE0 41                      		inc	cx		; so we can overwrite the null
  3891 00000CE1 5E                      		pop	si
  3892 00000CE2 EBE5                    		jmp	short FOR_MAKE_LOOP ; got back for more <command> bytes
  3893                                  FOR_STOSB:
  3894 00000CE4 AA                      		stosb			; take a byte from the <command> arg
  3895 00000CE5 49                      		dec	cx		; and put it into the <command> to be
  3896                                  					; executed (and note length, too)
  3897 00000CE6 3C0D                    		cmp	al,0Dh		
  3898 00000CE8 75DF                    		jnz	short FOR_MAKE_LOOP ; If not done, loop.
  3899                                  FOR_MADE_COM:
  3900 00000CEA F6D1                    		not	cl
  3901 00000CEC 2E880E[E13F]            		mov	[cs:COMBUF+1],cl
  3902                                  
  3903 00000CF1 2E8E1E[8141]            		mov	ds,[cs:RESSEG]
  3904                                  		;assume DS:resgroup
  3905 00000CF6 F606E90B01              		test	byte [ECHOFLAG],1 ; shall we echo this <command>, dearie?
  3906 00000CFB 742F                    		jz	short NOECHO3
  3907                                  		;cmp	byte [NULLFLAG],nullcommand
  3908 00000CFD 803EFE0B01              		cmp	byte [NULLFLAG],1 ;G was there a command last time?
  3909 00000D02 7403                    		jz	short NO_CRLF_PR  ;G no - don't print crlf	 	
  3910                                  
  3911 00000D04 E8320C                  		call	CRLF2		  ;G  Print out prompt
  3912                                  NO_CRLF_PR:
  3913 00000D07 C606FE0B00              		mov	byte [NULLFLAG],0 ;G reset no command flag
  3914 00000D0C 0E                      		push	cs
  3915 00000D0D 1F                      		pop	ds
  3916 00000D0E 57                      		push	di
  3917 00000D0F E85C06                  		call	PRINT_PROMPT	  ;G Prompt the user
  3918 00000D12 5F                      		pop	di
  3919                                  
  3920 00000D13 26C645FF00              		mov	byte [es:di-1],0  ; yeah, PRINT it out...	
  3921 00000D18 C706[5E43][E23F]        		mov	word [STRING_PTR_2],COMBUF+2
  3922 00000D1E BA[6F36]                		mov	dx,STRINGBUF2PTR
  3923 00000D21 E80427                  		call	STD_PRINTF
  3924 00000D24 26C645FF0D              		mov	byte [es:di-1],0Dh
  3925 00000D29 E97EF5                  		jmp	DOCOM		  ; run silent, run deep...
  3926                                  NOECHO3:
  3927 00000D2C C606FE0B00              		mov	byte [NULLFLAG],0
  3928 00000D31 0E                      		push	cs
  3929 00000D32 1F                      		pop	ds
  3930 00000D33 E977F5                  		jmp	DOCOM1
  3931                                  
  3932                                  FORNESTERRJ:				; no multi-loop processing... yet!		
  3933 00000D36 E84C01                  		call	FOROFF
  3934 00000D39 E92F01                  		jmp	FORNESTERR
  3935                                  
  3936                                  ; ---------------------------------------------------------------------------
  3937                                  
  3938                                  FORERRORJ:
  3939 00000D3C E9E5FB                  		jmp	FORERROR
  3940                                  
  3941                                  ; ---------------------------------------------------------------------------
  3942                                  
  3943                                  _$FOR:
  3944 00000D3F 8E06[8141]              		mov	es,[RESSEG]
  3945 00000D43 26803EF50B00            		cmp	byte [es:FORFLAG],0 ; is another one already running?
  3946 00000D49 75EB                    		jnz	short FORNESTERRJ   ; if flag is set.... boom!
  3947                                  
  3948                                  ; Turn off any pipes in progress.
  3949                                  
  3950 00000D4B 26803E570C00            		cmp	byte [es:PIPEFILES],0 ; Only turn off if present.
  3951 00000D51 7403                    		jz	short NO_PIPE
  3952 00000D53 E86F11                  		call	PIPEDEL
  3953                                  NO_PIPE:
  3954 00000D56 31D2                    		xor	dx,dx		; counter (0 <= DX < argvcnt)
  3955 00000D58 E8FA00                  		call	NEXTARG		; move to next argv[n]
  3956 00000D5B 72DF                    		jc	short FORERRORJ	; no more args -- bad forloop
  3957 00000D5D 3C25                    		cmp	al,'%'		; next arg MUST start with '%'...
  3958 00000D5F 75DB                    		jnz	short FORERRORJ
  3959 00000D61 89C5                    		mov	bp,ax		; save forloop variable
  3960 00000D63 AC                      		lodsb
  3961 00000D64 08C0                    		or	al,al		; and MUST end immediately...
  3962 00000D66 75D4                    		jnz	short FORERRORJ
  3963 00000D68 E8EA00                  		call	NEXTARG		; let's make sure the next arg is 'in'
  3964 00000D6B 72CF                    		jb	short FORERRORJ
  3965                                  		;and	ax,0DFDFh
  3966 00000D6D 25DFDF                  		and	ax,~2020h	; uppercase the letters
  3967                                  		;cmp	ax,[IN_WORD]
  3968                                  		; 01/03/2023
  3969 00000D70 3D494E                  		cmp	ax,in_word ; cmp ax,'IN'
  3970 00000D73 75C7                    		jnz	short FORERRORJ
  3971 00000D75 AC                      		lodsb
  3972                                  
  3973                                  		; MSDOS 3.3
  3974 00000D76 08C0                    		or	al,al		; it, too, must end right away
  3975 00000D78 7414                    		jz	short CHECKLPAREN
  3976                                  		;cmp	al,[LPAREN]
  3977                                  		; 01/03/2023
  3978 00000D7A 3C28                    		cmp	al,lparen ; '('
  3979 00000D7C 75BE                    		jnz	short FORERRORJ
  3980                                  		;add	word [bx+ARGV_ELE.argpointer],2 ; add word [bx+0],2
  3981 00000D7E 830702                  		add	word [bx],2
  3982                                  		;add	word [bx+9],2
  3983 00000D81 83470902                		add	word [bx+ARGV_ELE.arg_ocomptr],2
  3984                                  		;sub	word [bx+5],2
  3985 00000D85 836F0502                		sub	word [bx+ARGV_ELE.arglen],2
  3986 00000D89 8B44FF                  		mov	ax,[si-1]
  3987 00000D8C EB05                    		jmp	short LPCHECK
  3988                                  
  3989                                  		; MSDOS 6.0
  3990                                  ;; Compaq bug fix -- exit from this loop on error
  3991                                  ;
  3992                                  ;		or	al,al
  3993                                  ;		jne	forerrorj	; jump on error
  3994                                  ;
  3995                                  ;;;		je	CheckLParen
  3996                                  ;;
  3997                                  ;; Not null.  Perhaps there are no spaces between this and the (:
  3998                                  ;;   FOR %i in(foo bar...
  3999                                  ;; Check for the Lparen here
  4000                                  ;;
  4001                                  ;;;		CMP	AL,lparen
  4002                                  ;;;		JNZ	forerrorj
  4003                                  ;;
  4004                                  ;; The token was in(...	We strip off the "in" part to simulate a separator
  4005                                  ;; being there in the first place.
  4006                                  ;;
  4007                                  ;;;		ADD	[BX].argpointer,2  ; advance source pointer
  4008                                  ;;;		ADD	[BX].arg_ocomptr,2 ; advance original string
  4009                                  ;;;		SUB	[BX].arglen,2	   ; decrement the appropriate length
  4010                                  ;;
  4011                                  ;; SI now points past the in(.  Simulate a nextarg call that results in the
  4012                                  ;; current value.
  4013                                  ;;
  4014                                  ;;;		MOV	ax,[si-1]	; get lparen and next char
  4015                                  ;;;		jmp	short lpcheck
  4016                                  ;;
  4017                                  ;; end of Compaq bug fix
  4018                                  
  4019                                  ; ---------------------------------------------------------------------------
  4020                                  
  4021                                  		; MSDOS 3.3 (& MSDOS 6.0)
  4022                                  CHECKLPAREN:
  4023 00000D8E E8C400                  		call	NEXTARG		; lparen delimits beginning of <list>
  4024 00000D91 72A9                    		jc	short FORERRORJ
  4025                                  LPCHECK:
  4026                                  		;cmp	al,[LPAREN]
  4027                                  		; 01/03/2023
  4028 00000D93 3C28                    		cmp	al,lparen ; '('
  4029 00000D95 75A5                    		jne	short FORERRORJ
  4030                                  		;cmp	ah,0
  4031                                  		;je	short FOR_PAREN_TOKEN
  4032 00000D97 08E4                    		or	ah,ah ; 0 ?
  4033 00000D99 7408                    		jz	short FOR_PAREN_TOKEN
  4034                                  		;cmp	ah,[RPAREN]	; special case:  null list	
  4035 00000D9B 80FC29                  		cmp	ah,rparen ; ')'
  4036 00000D9E 7510                    		jne	short FOR_LIST_NOT_EMPTY
  4037 00000DA0 E93BFE                  		jmp	FORTERM
  4038                                  
  4039                                  		; 01/03/2023
  4040                                  FOR_PAREN_TOKEN:
  4041 00000DA3 E8AF00                  		call	NEXTARG		; what have we in our <list>?
  4042 00000DA6 7294                    		jc	short FORERRORJ
  4043                                  		;
  4044                                  		;;cmp	ax,[RPAREN+1]	
  4045                                  		;cmp	ax,[NULLRPAREN]	; special case: null list
  4046                                  		; 01/03/2023
  4047 00000DA8 83F829                  		cmp	ax,nullrparen ; 0029h  ; db ')',0
  4048 00000DAB 7509                    		jne	short FOR_LIST
  4049 00000DAD E92EFE                  		jmp	FORTERM
  4050                                  
  4051                                  FOR_LIST_NOT_EMPTY:
  4052                                  		;inc	word [bx+ARGV_ELE.argpointer] ; inc word [bx+0]
  4053 00000DB0 FF07                    		inc	word [bx]	; Advance ptr past "("
  4054                                  		;dec	word [bx+5]	; Adjust the rest of this argv entry	
  4055 00000DB2 FF4F05                  		dec	word [bx+ARGV_ELE.arglen] ; to agree.
  4056 00000DB5 46                      		inc	si		; Inc si so check for ")" works
  4057                                  		; 01/03/2023
  4058                                  		;jmp	short FOR_LIST ;-->
  4059                                  
  4060                                  		;nop
  4061                                  
  4062                                  		; 01/03/2023
  4063                                  ;FOR_PAREN_TOKEN:
  4064                                  		;call	NEXTARG		; what have we in our <list>?
  4065                                  		;jc	short FORERRORJ
  4066                                  		;;;cmp	ax,[RPAREN+1]	
  4067                                  		;;cmp	ax,[NULLRPAREN]	; special case: null list
  4068                                  		;cmp	ax,nullrparen ; 0029h  ; db ')',0
  4069                                  		;jne	short FOR_LIST
  4070                                  		;jmp	FORTERM
  4071                                  		; 01/03/2023
  4072                                  ;FORERORJJ:
  4073                                  		;jmp	FORERROR
  4074                                  ; -->
  4075                                  FOR_LIST:				; skip over rest of <list>
  4076 00000DB6 89D1                    		mov	cx,dx		; first arg of <list>
  4077                                  
  4078                                  SKIP_LIST:
  4079                                  		;add	si,[bx+5]
  4080 00000DB8 037705                  		add	si,[bx+ARGV_ELE.arglen]
  4081 00000DBB 83EE03                  		sub	si,3		; si = ptr to last char of token
  4082                                  		;mov	al,[RPAREN]
  4083                                  		; 01/03/2023
  4084 00000DBE B029                    		mov	al,rparen ; ')'
  4085 00000DC0 3804                    		cmp	[si],al		; Is this the last element in <list>
  4086 00000DC2 7408                    		je	short FOR_END_LIST ; Yes, exit loop.
  4087 00000DC4 E88E00                  		call	NEXTARG		; No, get next arg <list>
  4088                                  		;jc	short FORERORJJ	; If no more and no rparen, error.
  4089                                  		;jmp	short SKIP_LIST
  4090                                  		; 01/03/2023
  4091 00000DC7 73EF                    		jnc	short SKIP_LIST
  4092                                  FORERORJJ:
  4093 00000DC9 E958FB                  		jmp	FORERROR
  4094                                  FOR_END_LIST:
  4095 00000DCC 89D7                    		mov	di,dx		; record position of last arg in <list>
  4096 00000DCE C60400                  		mov	byte [si],0	; Zap the rparen
  4097                                  		;;cmp	ax,[RPAREN+1]	
  4098                                  		;cmp	ax,[NULLRPAREN] ; Was this token only a rparen
  4099 00000DD1 83F829                  		cmp	ax,nullrparen ; 0029h  ; db ')',0
  4100 00000DD4 7401                    		je	short FOR_DO	; Yes, continue
  4101 00000DD6 47                      		inc	di		; No, inc position of last arg
  4102                                  FOR_DO:
  4103 00000DD7 E87B00                  		call	NEXTARG		; now we had BETTER find a 'do'...
  4104 00000DDA 72ED                    		jc	short FORERORJJ
  4105                                  		;and	ax,0DFDFh	
  4106 00000DDC 25DFDF                  		and	ax,~2020h	; uppercase the letters
  4107                                  		;cmp	ax,[DO_WORD]
  4108                                  		; 01/03/2023
  4109 00000DDF 3D444F                  		cmp	ax,do_word ; cmp ax,'DO'
  4110 00000DE2 75E5                    		jne	short FORERORJJ
  4111 00000DE4 AC                      		lodsb
  4112 00000DE5 08C0                    		or	al,al		; and it had BETTER be ONLY a 'do'...
  4113 00000DE7 75E0                    		jnz	short FORERORJJ
  4114                                  		
  4115 00000DE9 E86900                  		call	NEXTARG		; on to the beginning of <command>
  4116 00000DEC 72DB                    		jc	short FORERORJJ	; null <command> not legal
  4117                                  
  4118 00000DEE 50                      		push	ax
  4119 00000DEF 53                      		push	bx
  4120 00000DF0 51                      		push	cx
  4121 00000DF1 52                      		push	dx		; preserve registers against disaster
  4122 00000DF2 57                      		push	di
  4123 00000DF3 56                      		push	si
  4124 00000DF4 55                      		push	bp
  4125 00000DF5 E865F8                  		call	FREE_TPA	; need to make free memory, first
  4126 00000DF8 E88A00                  		call	FOROFF
  4127                                  		;mov	bx,264
  4128 00000DFB BB0801                  		mov	bx,FOR_INFO.size-ARG_UNIT.SIZE
  4129 00000DFE E83619                  		call	SAVE_ARGS	; extra bytes needed for for-info
  4130 00000E01 9C                      		pushf
  4131 00000E02 26A3F60B                		mov	[es:FORPTR],ax
  4132 00000E06 E864F8                  		call	ALLOC_TPA	; ALLOC_TPA clobbers registers...
  4133 00000E09 9D                      		popf
  4134 00000E0A 5D                      		pop	bp
  4135 00000E0B 5E                      		pop	si
  4136 00000E0C 5F                      		pop	di
  4137 00000E0D 5A                      		pop	dx
  4138 00000E0E 59                      		pop	cx
  4139 00000E0F 5B                      		pop	bx
  4140 00000E10 58                      		pop	ax
  4141 00000E11 723C                    		jc	short FOR_ALLOC_ERR
  4142                                  
  4143 00000E13 06                      		push	es		; save resgroup seg...
  4144 00000E14 26FF36F60B              		push	word [es:FORPTR]
  4145 00000E19 07                      		pop	es
  4146                                  		;assume ES:for_segment	
  4147 00000E1A 49                      		dec	cx		; forproc wants min pointing before
  4148 00000E1B 4F                      		dec	di		; first arg, max right at last one
  4149 00000E1C 26890E4705              		mov	[es:FOR_INFO.FOR_MINARG],cx
  4150 00000E21 26893E4905              		mov	[es:FOR_INFO.FOR_MAXARG],di
  4151 00000E26 2688164405              		mov	[es:FOR_INFO.FOR_COM_START],dl
  4152 00000E2B 26C7064505FFFF          		mov	word [es:FOR_INFO.FOR_EXPAND],-1 ; non-zero means FALSE
  4153 00000E32 89E8                    		mov	ax,bp
  4154 00000E34 2688264B06              		mov	[es:FOR_INFO.FOR_VAR],ah
  4155 00000E39 07                      		pop	es
  4156                                  		;assume ES:resgroup	
  4157 00000E3A 26FE06F50B              		inc	byte [es:FORFLAG]
  4158 00000E3F 26833EEF0BFF            		cmp	word [es:SINGLECOM],-1
  4159 00000E45 7507                    		jne	short FOR_RET
  4160 00000E47 26C706EF0B00FF          		mov	word [es:SINGLECOM],0FF00h
  4161                                  FOR_RET:
  4162 00000E4E C3                      		retn
  4163                                  
  4164                                  FOR_ALLOC_ERR:
  4165                                  		; MSDOS 3.3
  4166 00000E4F BA[DA3B]                		mov	dx,INSFMEMMESPTR
  4167 00000E52 E9950D                  		jmp	CERROR
  4168                                  
  4169                                  		; MSDOS 6.0
  4170                                  		;mov	msg_disp_class,ext_msg_class	
  4171                                  		;			;AN000; set up extended error msg class
  4172                                  		;mov	dx,offset TranGroup:Extend_Buf_ptr     
  4173                                  		;			;AC000; get extended message pointer
  4174                                  		;mov	Extend_Buf_ptr,error_not_enough_memory 
  4175                                  		;			;AN000; get message number in control block
  4176                                  		;jmp	cerror
  4177                                  
  4178                                  
  4179                                  ; =============== S U B	R O U T	I N E =======================================
  4180                                  
  4181                                  NEXTARG:
  4182 00000E55 42                      		inc	dx		; next argv[n]
  4183                                  		;cmp	dx,[ARG_ARGVCNT]
  4184 00000E56 3B16[7947]              		cmp	dx,[ARG+ARG_UNIT.argvcnt] ; make sure we don't run off end
  4185 00000E5A 7D0D                    		jge	short NEXTARG_ERR ; of argv[]...	
  4186 00000E5C 89D3                    		mov	bx,dx
  4187                                  		;mov	ax,ARG_ARGV
  4188                                  		;mov	ax,ARG+ARG_UNIT.argv
  4189 00000E5E B8[B944]                		mov	ax,ARG
  4190 00000E61 E8F215                  		call	ARGV_CALC	; convert array index to pointer
  4191 00000E64 8B37                    		mov	si,[bx]		; load pointer to argstring
  4192                                  		;mov	si,[bx+ARGV_ELE.argpointer] ; mov si,[bx+0]
  4193 00000E66 AD                      		lodsw			; and load first two chars
  4194 00000E67 F8                      		clc
  4195 00000E68 C3                      		retn
  4196                                  NEXTARG_ERR:
  4197 00000E69 F9                      		stc
  4198 00000E6A C3                      		retn
  4199                                  
  4200                                  ; ---------------------------------------------------------------------------
  4201                                  
  4202                                  FORNESTERR:
  4203 00000E6B 1E                      		push	ds
  4204 00000E6C 8E1E[8141]              		mov	ds,[RESSEG]
  4205                                  		;ASSUME DS:RESGROUP
  4206 00000E70 BA[C23B]                		mov	dx,FORNESTMESTR
  4207 00000E73 813EEF0B00FF            		cmp	word [SINGLECOM],0FF00h
  4208 00000E79 7506                    		jnz	short NOFORP3
  4209 00000E7B C706EF0BFFFF            		mov	word [SINGLECOM],-1 ; 0FFFFh ; Cause termination
  4210                                  NOFORP3:
  4211 00000E81 1F                      		pop	ds
  4212 00000E82 E9650D                  		jmp	CERROR
  4213                                  
  4214                                  ; =============== S U B	R O U T	I N E =======================================
  4215                                  
  4216                                  ; General routine called to free the for segment. We also clear the forflag
  4217                                  ; too. Change no registers.
  4218                                  
  4219                                  FOROFF:
  4220 00000E85 50                      		push	ax
  4221 00000E86 06                      		push	es
  4222 00000E87 2E8E06[8141]            		mov	es,[cs:RESSEG]
  4223 00000E8C 26A1F60B                		mov	ax,[es:FORPTR]
  4224 00000E90 09C0                    		or	ax,ax
  4225 00000E92 7408                    		jz	short FREEDONE
  4226 00000E94 06                      		push	es
  4227 00000E95 8EC0                    		mov	es,ax
  4228 00000E97 B449                    		mov	ah,DEALLOC ; 49h
  4229 00000E99 CD21                    		int	21h	; DOS -	2+ - FREE MEMORY
  4230                                  				; ES = segment address of area to be freed
  4231 00000E9B 07                      		pop	es
  4232                                  FREEDONE:
  4233 00000E9C 26C706F60B0000          		mov	word [es:FORPTR],0
  4234 00000EA3 26C606F50B00            		mov	byte [es:FORFLAG],0
  4235 00000EA9 07                      		pop	es
  4236 00000EAA 58                      		pop	ax
  4237 00000EAB C3                      		retn
  4238                                  
  4239                                  ;============================================================================
  4240                                  ; TCMD1A.ASM, MSDOS 6.0, 1991
  4241                                  ;============================================================================
  4242                                  ; 09/10/2018 - Retro DOS v3.0
  4243                                  
  4244                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0ECBh
  4245                                  
  4246                                  ; ---------------------------------------------------------------------------
  4247                                  
  4248                                  ; The DIR command displays the contents of a directory.
  4249                                  ;
  4250                                  ; ****************************************************************
  4251                                  ; *
  4252                                  ; * ROUTINE:	 CATALOG - display file(s) in directory
  4253                                  ; *
  4254                                  ; * FUNCTION:	 PARSE command line for drive, file, or path name.
  4255                                  ; *		 DIR allows two switches, /P (pause) and /W (wide).
  4256                                  ; *		 If an error occurs issue and error message and
  4257                                  ; *		 transfer control to CERROR.
  4258                                  ; *
  4259                                  ; * INPUT:	 command line at offset 81H
  4260                                  ; *
  4261                                  ; * OUTPUT:	 none
  4262                                  ; *
  4263                                  ; ****************************************************************
  4264                                  
  4265                                  CATALOG:
  4266                                  		; MSDOS 3.3
  4267                                  
  4268                                  		;mov	ax,ARG_ARGV
  4269                                  		;mov	ax,ARG+ARG_UNIT.argv
  4270 00000EAC B8[B944]                		mov	ax,ARG
  4271 00000EAF BAFFFF                  		mov	dx,0FFFFh
  4272 00000EB2 31C9                    		xor	cx,cx
  4273 00000EB4 31F6                    		xor	si,si
  4274                                  DIR1:
  4275                                  		;cmp	cx,[ARG_ARGVCNT]
  4276 00000EB6 3B0E[7947]              		cmp	cx,[ARG+ARG_UNIT.argvcnt]
  4277 00000EBA 733D                    		jnb	short DIR6 ; No more arguments
  4278 00000EBC 89CB                    		mov	bx,cx
  4279 00000EBE E89515                  		call	ARGV_CALC
  4280                                  		;or	si,[bx+7]
  4281 00000EC1 0B7707                  		or	si,[bx+ARGV_ELE.argsw_word]
  4282 00000EC4 F7C6FC7F                		test	si,7FFCh  ; test si,~8003
  4283 00000EC8 7529                    		jnz	short DIR2  ; /A,/B,/V switches (are invalid)
  4284                                  		;test	byte [bx+2],1
  4285 00000ECA F6470201                		test	byte [bx+ARGV_ELE.argflags],sw_flag ; 1
  4286                                  		;jz	short DIR3
  4287                                  		;jmp	short DIR5
  4288                                  		; 02/03/2023
  4289 00000ECE 7520                    		jnz	short DIR5
  4290                                  ; 02/03/2023
  4291                                  ;DIR2:
  4292                                  ;		mov	dx,BADPARMPTR
  4293                                  ;		jmp	CERROR
  4294                                  DIR3:
  4295 00000ED0 09C9                    		or	cx,cx
  4296 00000ED2 7515                    		jnz	short DIR4	
  4297                                  		;cmp	word [bx+5],3
  4298 00000ED4 837F0503                		cmp	word [bx+ARGV_ELE.arglen],3
  4299 00000ED8 7416                    		jz	short DIR5
  4300                                  		;add	word [bx+ARGV_ELE.argpointer],3 ; add word [bx+0],3
  4301 00000EDA 830703                  		add	word [bx],3
  4302                                  		;add	word [bx+9],3
  4303 00000EDD 83470903                		add	word [bx+ARGV_ELE.arg_ocomptr],3
  4304                                  		;add	word [bx+3],3
  4305 00000EE1 83470303                		add	word [bx+ARGV_ELE.argstartel],3
  4306                                  		;sub	word [bx+5],3
  4307 00000EE5 836F0503                		sub	word [bx+ARGV_ELE.arglen],3
  4308                                  DIR4:
  4309 00000EE9 83FAFF                  		cmp	dx,0FFFFh
  4310 00000EEC 7505                    		jnz	short DIR2
  4311 00000EEE 89DA                    		mov	dx,bx
  4312                                  DIR5:		
  4313 00000EF0 41                      		inc	cx
  4314 00000EF1 EBC3                    		jmp	short DIR1
  4315                                  
  4316                                  		; 02/03/2023
  4317                                  DIR2:
  4318 00000EF3 BA[5239]                		mov	dx,BADPARMPTR
  4319 00000EF6 E9F10C                  		jmp	CERROR
  4320                                  DIR6:
  4321 00000EF9 8936[9841]              		mov	[COMSW],si
  4322 00000EFD 52                      		push	dx
  4323 00000EFE 30C0                    		xor	al,al
  4324 00000F00 83FAFF                  		cmp	dx,0FFFFh
  4325 00000F03 7410                    		jz	short DIR7
  4326 00000F05 89D3                    		mov	bx,dx
  4327                                  		;mov	di,[bx+ARGV_ELE.argpointer]  ;mov di,[bx+0]
  4328 00000F07 8B3F                    		mov	di,[bx]
  4329 00000F09 807D013A                		cmp	byte [di+1],':'
  4330 00000F0D 7506                    		jnz	short DIR7
  4331 00000F0F 8A05                    		mov	al,[di]
  4332 00000F11 0C20                    		or	al,20h		; Lowercase drive name	
  4333 00000F13 2C60                    		sub	al,'a'-1 ; 60h  ; Convert to drive number (0,1..)
  4334                                  DIR7:
  4335                                  		;mov	[5CH],al
  4336 00000F15 A25C00                  		mov	[FCB],al
  4337 00000F18 E80604                  		call	OKVOLARG
  4338 00000F1B B03F                    		mov	al,'?'		; *.* is default file spec.
  4339                                  		;mov	di,5Dh
  4340 00000F1D BF5D00                  		mov	di,FCB+1
  4341 00000F20 B90B00                  		mov	cx,11
  4342 00000F23 F3AA                    		rep stosb
  4343                                  
  4344                                  ; Begin by processing any switches that may have been specified.
  4345                                  ; BITS will contain any information about switches that was
  4346                                  ; found when the command line was parsed.
  4347                                  
  4348 00000F25 A1[9841]                		mov	ax,[COMSW]	; Get switches from command
  4349 00000F28 A3[CC42]                		mov	[_BITS],ax	; initialize switches
  4350 00000F2B C706[9841]0000          		mov	word [COMSW],0	; initialize flags
  4351 00000F31 C606[D442]17            		mov	byte [LINPERPAG],23 ; Set default for lines per page
  4352                                  		;test	al,1
  4353 00000F36 A801                    		test	al,SWITCHW	; /W ?
  4354                                  		;mov	al,1
  4355 00000F38 B001                    		mov	al,NORMPERLIN
  4356 00000F3A 7402                    		jz	short DIR8
  4357                                  		;mov	al,5
  4358 00000F3C B005                    		mov	al,WIDEPERLIN
  4359                                  DIR8:
  4360 00000F3E A2[A841]                		mov	[LINLEN],al	; Set number of entries per line
  4361 00000F41 A2[A741]                		mov	[LINCNT],al
  4362 00000F44 C706[A941]0000          		mov	word [FILECNT],0 ; Keep track of how many files found
  4363 00000F4A BA[7A42]                		mov	dx,DIRBUF
  4364 00000F4D B41A                    		mov	ah,SET_DMA ; 1Ah
  4365 00000F4F CD21                    		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
  4366                                  				; DS:DX	-> disk	transfer buffer
  4367                                  		;mov	dl,[5Ch]
  4368 00000F51 8A165C00                		mov	dl,[FCB]
  4369 00000F55 E8BB09                  		call	SAVUDIR
  4370 00000F58 5B                      		pop	bx
  4371 00000F59 83FBFF                  		cmp	bx,0FFFFh
  4372 00000F5C 7415                    		jz	short DIR9
  4373                                  		;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
  4374 00000F5E 8B17                    		mov	dx,[bx]
  4375                                  
  4376                                  ; The user may have specified a device. Search for the path and see if the
  4377                                  ; attributes indicate a device.
  4378                                  
  4379 00000F60 B44E                    		mov	ah,FIND_FIRST ; 4Eh
  4380 00000F62 CD21                    		int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
  4381                                  				; CX = search attributes
  4382                                  				; DS:DX	-> ASCIZ filespec
  4383                                  				; (drive,path, and wildcards allowed)
  4384 00000F64 720F                    		jc	short DIR10
  4385                                  				; Check device atrribute..
  4386                                  		;test	byte [DIRBUF_ATTRIB2],40h
  4387                                  		;test	byte [DIRBUF_ATTRIB2],ATTR_DEVICE
  4388                                  		; 14/10/2018
  4389                                  		;test	byte [DIRBUF+21],40h
  4390 00000F66 F606[8F42]40            		test	byte [DIRBUF+FIND_BUF.ATTR],ATTR_DEVICE
  4391 00000F6B 7408                    		jz	short DIR10	; no, go do normal operation
  4392 00000F6D C706[9841]FEFF          		mov	word [COMSW],-2 ; 0FFFEh  ; Signal device
  4393                                  DIR9:
  4394 00000F73 EB7B                    		jmp	short DOHEADER
  4395                                  DIR10:
  4396                                  		;mov	dx,[bx+ARGV_ELE.argpointer]
  4397 00000F75 8B17                    		mov	dx,[bx]
  4398 00000F77 B43B                    		mov	ah,CHDIR ; 3Bh
  4399 00000F79 CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  4400                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  4401 00000F7B 7373                    		jnc	short DOHEADER
  4402                                  		;mov	si,[bx+3]
  4403 00000F7D 8B7703                  		mov	si,[bx+ARGV_ELE.argstartel]
  4404 00000F80 39F2                    		cmp	dx,si
  4405 00000F82 7449                    		jz	short DIR_NO_DRIVE
  4406 00000F84 30C9                    		xor	cl,cl
  4407 00000F86 860C                    		xchg	cl,[si]
  4408 00000F88 B43B                    		mov	ah,CHDIR ; 3Bh
  4409 00000F8A CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  4410                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  4411 00000F8C 860C                    		xchg	cl,[si]
  4412 00000F8E 733D                    		jnc	short DIR_NO_DRIVE
  4413 00000F90 8A44FF                  		mov	al,[si-1]
  4414 00000F93 E8420A                  		call	PATHCHRCMP
  4415 00000F96 7514                    		jnz	short DIR11
  4416 00000F98 8A44FE                  		mov	al,[si-2]
  4417 00000F9B E83A0A                  		call	PATHCHRCMP
  4418 00000F9E 741E                    		jz	short DIR12
  4419 00000FA0 864CFF                  		xchg	cl,[si-1]
  4420 00000FA3 B43B                    		mov	ah,CHDIR ; 3Bh
  4421 00000FA5 CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  4422                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  4423 00000FA7 864CFF                  		xchg	cl,[si-1]
  4424 00000FAA 7321                    		jnc	short DIR_NO_DRIVE
  4425                                  DIR11:
  4426 00000FAC B53A                    		mov	ch,':'
  4427 00000FAE 3A6CFF                  		cmp	ch,[si-1]
  4428 00000FB1 750B                    		jnz	short DIR12
  4429                                  		;mov	cx,[bx+ARGV_ELE.argpointer] ; mov cx,[bx+0]
  4430 00000FB3 8B0F                    		mov	cx,[bx]
  4431 00000FB5 87CE                    		xchg	cx,si
  4432 00000FB7 29F1                    		sub	cx,si
  4433 00000FB9 83F902                  		cmp	cx,2
  4434 00000FBC 740F                    		jz	short DIR_NO_DRIVE
  4435                                  DIR12:
  4436 00000FBE BA[A63A]                		mov	dx,BADCDPTR
  4437                                  		;test	byte [bx+2],4
  4438 00000FC1 F6470204                		test	byte [bx+ARGV_ELE.argflags],path_sep ; 4
  4439 00000FC5 7503                    		jnz	short DIRERROR
  4440                                  DIRNF:
  4441 00000FC7 BA[2837]                		mov	dx,FNOTFOUNDPTR
  4442                                  DIRERROR:
  4443 00000FCA E91D0C                  		jmp	CERROR
  4444                                  DIR_NO_DRIVE:
  4445 00000FCD 813C2E2E                		cmp	word [si],'..'
  4446 00000FD1 750C                    		jnz	short DOREALPARSE
  4447 00000FD3 807C0200                		cmp	byte [si+2],0
  4448 00000FD7 7506                    		jnz	short DOREALPARSE
  4449 00000FD9 FF06[9841]              		inc	word [COMSW]
  4450 00000FDD EB11                    		jmp	short DOHEADER
  4451                                  DOREALPARSE:
  4452 00000FDF BF5C00                  		mov	di,FCB ; 5Ch	
  4453                                  		;mov	ax,290Eh
  4454 00000FE2 B80E29                  		mov	ax,(PARSE_FILE_DESCRIPTOR<<8)|0Eh
  4455 00000FE5 CD21                    		int	21h	; DOS -	PARSE FILENAME
  4456                                  				; DS:SI	-> string to parse
  4457                                  				; ES:DI	-> buffer to fill with unopened	FCB
  4458                                  				; AL = bit mask	to control parsing
  4459 00000FE7 803C00                  		cmp	byte [si],0
  4460 00000FEA 7404                    		jz	short DOHEADER
  4461 00000FEC FF0E[9841]              		dec	word [COMSW]
  4462                                  DOHEADER:
  4463                                  
  4464                                  ; Display the header
  4465                                  
  4466 00000FF0 53                      		push	bx
  4467 00000FF1 E83904                  		call	BUILD_DIR_STRING
  4468 00000FF4 BA[7A42]                		mov	dx,DIRBUF
  4469 00000FF7 8916[7543]              		mov	[VOL_DIR],dx
  4470 00000FFB BA[2F3B]                		mov	dx,DIRHEADPTR
  4471 00000FFE E81824                  		call	PRINTF_CRLF
  4472 00001001 5B                      		pop	bx
  4473 00001002 83FBFF                  		cmp	bx,0FFFFh
  4474 00001005 7417                    		jz	short DOSEARCH
  4475                                  
  4476                                  ; If there were chars left after parse or device, then invalid file name
  4477                                  
  4478 00001007 833E[9841]00            		cmp	word [COMSW],0
  4479 0000100C 7410                    		jz	short DOSEARCH	; nothing left; good parse
  4480 0000100E 7C09                    		jl	short DIRNFFIX	; not .. => error file not found
  4481 00001010 E85A08                  		call	RESTUDIR
  4482 00001013 BA[A63A]                		mov	dx,BADCDPTR
  4483 00001016 E9D10B                  		jmp	CERROR		; was .. => error directory not found
  4484                                  DIRNFFIX:
  4485 00001019 E85108                  		call	RESTUDIR
  4486 0000101C EBA9                    		jmp	short DIRNF
  4487                                  
  4488                                  ; We are assured that everything is correct. Let's go and search. Use
  4489                                  ; attributes that will include finding directories. Perform the first search
  4490                                  ; and reset our directory afterward.
  4491                                  
  4492                                  DOSEARCH:
  4493                                  		;mov	byte [55h],0FFh
  4494 0000101E C6065500FF              		mov	byte [FCB-7],0FFh
  4495                                  		;mov	byte [5Bh],10h
  4496 00001023 C6065B0010              		mov	byte [FCB-1],10h
  4497                                  
  4498                                  ; Caution! Since we are using an extended FCB, we will *also* be returning
  4499                                  ; the directory information as an extended FCB. We must bias all fetches into
  4500                                  ; DIRBUF by 8 (Extended FCB part + drive)
  4501                                  
  4502 00001028 B411                    		mov	ah,DIR_SEARCH_FIRST ; 11h
  4503 0000102A BA5500                  		mov	dx,FCB-7 ; 55h
  4504 0000102D CD21                    		int	21h	; DOS -	SEARCH FIRST USING FCB
  4505                                  				; DS:DX	-> FCB
  4506                                  
  4507                                  ; Restore the user's directory. We preserve, though, the return from the
  4508                                  ; previous system call for later checking.
  4509                                  
  4510                                  FOUND_FIRST_FILE:
  4511 0000102F 50                      		push	ax		; save return state
  4512 00001030 E83A08                  		call	RESTUDIR	; restore user's dir	
  4513 00001033 58                      		pop	ax		; get return state back
  4514                                  
  4515                                  ; Main scanning loop. Entry has AL = Search first/next error code. Test for
  4516                                  ; no more.
  4517                                  
  4518                                  DIRSTART:
  4519 00001034 FEC0                    		inc	al		; 0FFh = file not found
  4520 00001036 7503                    		jnz	short DISPLAY	; Either an error or we are finished
  4521 00001038 E9D200                  		jmp	CHKCNT
  4522                                  DISPLAY:
  4523 0000103B FF06[A941]              		inc	word [FILECNT]	; Keep track of how many we find
  4524 0000103F BE[8242]                		mov	si,DIRBUF+8	; SI -> information returned by sys call
  4525                                  		;call	SHONAME
  4526 00001042 E80C01                  		call	DISPLAYNAME
  4527                                  		;test	byte [_BITS],1
  4528 00001045 F606[CC42]01            		test	byte [_BITS],SWITCHW ; W switch set?
  4529 0000104A 7403                    		jz	short DIRTEST	; If so, no size, date, or time
  4530 0000104C E98800                  		jmp	NEXENT
  4531                                  DIRTEST:
  4532                                  		;test	byte [DIRBUF_ATTRIB1],10h
  4533                                  		; 14/10/2018
  4534                                  		;test	byte [DIRBUF_ATTRIB1],ATTR_DIRECTORY
  4535                                  		;test	byte [DIRBUF+19],10h
  4536 0000104F F606[8D42]10            		test	byte [DIRBUF+8+DIR_ENTRY.DIR_ATTR],ATTR_DIRECTORY
  4537 00001054 7408                    		jz	short FILEENT
  4538 00001056 BA[283A]                		mov	dx,DMESPTR
  4539 00001059 E8CC23                  		call	STD_PRINTF
  4540 0000105C EB16                    		jmp	short NOFSIZ
  4541                                  FILEENT:
  4542                                  		;mov	dx,[DIRBUF_FSIZ_L]
  4543                                  		;mov	dx,[DIRBUF+36]
  4544 0000105E 8B16[9E42]              		mov	dx,[DIRBUF+8+DIR_ENTRY.DIR_SIZE_L]
  4545 00001062 8916[5A43]              		mov	[FILESIZE_L],dx
  4546                                  		;mov	dx,[DIRBUF_FSIZ_H]
  4547                                  		;mov	dx,[DIRBUF+38]
  4548 00001066 8B16[A042]              		mov	dx,[DIRBUF+8+DIR_ENTRY.DIR_SIZE_H]
  4549 0000106A 8916[5C43]              		mov	[FILESIZE_H],dx
  4550 0000106E BA[6636]                		mov	dx,FSIZEMESPTR
  4551 00001071 E8B423                  		call	STD_PRINTF	; Print size of file
  4552                                  NOFSIZ:
  4553                                  		;mov	ax,[DIRBUF_FDATE]  ; Get date
  4554                                  		;mov	ax,[DIRBUF+32]
  4555 00001074 A1[9A42]                		mov	ax,[DIRBUF+8+DIR_ENTRY.DIR_DATE]
  4556 00001077 09C0                    		or	ax,ax
  4557 00001079 745C                    		jz	short NEXENT	; Skip if no date
  4558 0000107B BF[AB41]                		mov	di,CHARBUF
  4559 0000107E 50                      		push	ax
  4560 0000107F B82020                  		mov	ax,'  '
  4561 00001082 AB                      		stosw
  4562 00001083 58                      		pop	ax
  4563 00001084 89C3                    		mov	bx,ax
  4564 00001086 83E01F                  		and	ax,1Fh		; Get day
  4565 00001089 88C2                    		mov	dl,al
  4566 0000108B 89D8                    		mov	ax,bx
  4567 0000108D B105                    		mov	cl,5
  4568 0000108F D3E8                    		shr	ax,cl		; Align month
  4569 00001091 240F                    		and	al,0Fh		; Get month
  4570 00001093 88C6                    		mov	dh,al
  4571 00001095 88F9                    		mov	cl,bh
  4572 00001097 D0E9                    		shr	cl,1		; Align year
  4573 00001099 30ED                    		xor	ch,ch
  4574 0000109B 83C150                  		add	cx,80		; Relative 1980
  4575 0000109E 80F964                  		cmp	cl,100
  4576 000010A1 7203                    		jb	short MILLENIUM
  4577 000010A3 80E964                  		sub	cl,100
  4578                                  MILLENIUM:
  4579 000010A6 E8860F                  		call	DATE_CXDX
  4580                                  		;mov	cx,[DIRBUF_FTIME]
  4581                                  		;mov	cx,[DIRBUF+30]
  4582 000010A9 8B0E[9842]              		mov	cx,[DIRBUF+8+DIR_ENTRY.DIR_TIME]
  4583 000010AD E318                    		jcxz	PRBUF		; Time field present?
  4584 000010AF B82020                  		mov	ax,2020h
  4585 000010B2 AB                      		stosw
  4586 000010B3 D1E9                    		shr	cx,1
  4587 000010B5 D1E9                    		shr	cx,1
  4588 000010B7 D1E9                    		shr	cx,1
  4589 000010B9 D0E9                    		shr	cl,1
  4590 000010BB D0E9                    		shr	cl,1		; Hours in CH, minutes in CL
  4591 000010BD 8A1E[194C]              		mov	bl,[TIME_24]
  4592 000010C1 80CB80                  		or	bl,80h		; Tell P_TIME called from DIR
  4593 000010C4 E80E11                  		call	P_TIME		; Don't care about DX, never used with DIR
  4594                                  PRBUF:
  4595 000010C7 31C0                    		xor	ax,ax
  4596 000010C9 AA                      		stosb
  4597 000010CA BA[AB41]                		mov	dx,CHARBUF
  4598 000010CD 8916[5E43]              		mov	[STRING_PTR_2],dx
  4599 000010D1 BA[6F36]                		mov	dx,STRINGBUF2PTR
  4600 000010D4 E85123                  		call	STD_PRINTF
  4601                                  NEXENT:
  4602 000010D7 FE0E[A741]              		dec	byte [LINCNT]
  4603 000010DB 7520                    		jnz	short SAMLIN
  4604                                  NEXLIN:
  4605 000010DD A0[A841]                		mov	al,[LINLEN]
  4606 000010E0 A2[A741]                		mov	[LINCNT],al
  4607 000010E3 E85308                  		call	CRLF2
  4608 000010E6 FE0E[D442]              		dec	byte [LINPERPAG]
  4609 000010EA 7517                    		jnz	short SCROLL
  4610                                  		;test	byte [_BITS],2
  4611 000010EC F606[CC42]02            		test	byte [_BITS],SWITCHP ; P switch present?
  4612 000010F1 7410                    		jz	short SCROLL	; If not, just continue
  4613 000010F3 C606[D442]17            		mov	byte [LINPERPAG],23
  4614 000010F8 E87800                  		call	PAUSE
  4615 000010FB EB06                    		jmp	short SCROLL
  4616                                  SAMLIN:
  4617 000010FD BA[7536]                		mov	dx,TABPTR	; Output a tab
  4618 00001100 E82523                  		call	STD_PRINTF
  4619                                  SCROLL:
  4620 00001103 B412                    		mov	ah,DIR_SEARCH_NEXT ; 12h
  4621                                  		;mov	dx,55h
  4622 00001105 BA5500                  		mov	dx,FCB-7	; DX -> Unopened FCB
  4623 00001108 CD21                    		int	21h	; DOS -	SEARCH NEXT USING FCB
  4624                                  				; DS:DX	-> FCB
  4625                                  				; Return: AL = status
  4626 0000110A E927FF                  		jmp	DIRSTART
  4627                                  CHKCNT:
  4628 0000110D F706[A941]FFFF          		test	word [FILECNT],0FFFFh ; -1
  4629 00001113 7503                    		jnz	short TRAILER
  4630 00001115 E9AFFE                  		jmp	DIRNF
  4631                                  TRAILER:
  4632 00001118 A0[A841]                		mov	al,[LINLEN]
  4633 0000111B 3A06[A741]              		cmp	al,[LINCNT]
  4634 0000111F 7403                    		jz	short MMESSAGE
  4635 00001121 E81508                  		call	CRLF2
  4636                                  MMESSAGE:
  4637 00001124 BA[3F38]                		mov	dx,DIRMESPTR
  4638 00001127 8B36[A941]              		mov	si,[FILECNT]
  4639 0000112B 8936[6743]              		mov	[DIR_NUM],si
  4640 0000112F E8F622                  		call	STD_PRINTF
  4641                                  DTFREE:
  4642 00001132 B436                    		mov	ah,GET_DRIVE_FREESPACE ; 36h
  4643                                  		;mov	dl,[5Ch]
  4644 00001134 8A165C00                		mov	dl,[FCB]
  4645 00001138 CD21                    		int	21h	; DOS -	2+ - GET DISK SPACE
  4646                                  				; DL = drive code (0 = default,	1 = A,2 = B,etc.)
  4647 0000113A 83F8FF                  		cmp	ax,-1
  4648 0000113D 7501                    		jnz	short DTFREE1
  4649                                  DTRET:
  4650 0000113F C3                      		retn
  4651                                  DTFREE1:
  4652 00001140 F7E1                    		mul	cx
  4653 00001142 F7E3                    		mul	bx
  4654 00001144 A3[6943]                		mov	[BYTES_FREE],ax
  4655 00001147 8916[6B43]              		mov	[BYTES_FREE+2],dx
  4656 0000114B BA[5538]                		mov	dx,BYTEMESPTR
  4657 0000114E E9D722                  		jmp	STD_PRINTF
  4658                                  
  4659                                  	; MSDOS 6.0
  4660                                  ;CATALOG:
  4661                                  
  4662                                  ;;
  4663                                  ;; Set up DTA for dir search firsts
  4664                                  ;;
  4665                                  ;	mov	dx,offset trangroup:Dirbuf	;AC000; Set Disk transfer address
  4666                                  ;	mov	ah,Set_DMA			;AC000;
  4667                                  ;	int	int_command			;AC000;
  4668                                  ;;
  4669                                  ;; Set up defaults for switches and parse the command line.
  4670                                  ;;
  4671                                  ;	mov	msg_numb,0			;AN022; initialize message flag
  4672                                  ;	mov	di,offset trangroup:srcbuf	;AN000; get address of srcbuf
  4673                                  ;	mov	[pathpos],di			;AN000; this is start of path
  4674                                  ;	mov	[pathcnt],1			;AN000; initialize length to 1 char
  4675                                  ;	mov	al,star 			;AN000; initialize srcbuf to *,0d
  4676                                  ;	stosb					;AN000;
  4677                                  ;	mov	al,end_of_line_in		;AN000;
  4678                                  ;	stosb					;AN000;
  4679                                  ;	mov	si,81H				;AN000; Get command line
  4680                                  ;	mov	di,offset trangroup:parse_dir	;AN000; Get address of PARSE_DIR
  4681                                  ;	xor	cx,cx				;AC000; clear counter for positionals
  4682                                  ;	mov	ComSw,cx			;AC000; initialize flags
  4683                                  ;	mov	bits,cx 			;AC000; initialize switches
  4684                                  ;	mov	linperpag,linesperpage		;AC000; Set default for lines per page
  4685                                  ;	mov	linlen,normperlin		;AC000; Set number of entries per line
  4686                                  ;	mov	lincnt,normperlin		;AC000;
  4687                                  ;
  4688                                  ;dirscan:
  4689                                  ;	xor	dx,dx				;AN000;
  4690                                  ;	invoke	parse_with_msg			;AC018; call parser
  4691                                  ;	cmp	ax,end_of_line			;AN000; are we at end of line?
  4692                                  ;	jne	dirscan_cont			;AN000; No - continue parsing
  4693                                  ;	jmp	scandone			;AN000; yes - go process
  4694                                  ;
  4695                                  ;dirscan_cont:
  4696                                  ;	cmp	ax,result_no_error		;AN000; did we have an error?
  4697                                  ;	jz	dirscan_cont2			;AN000; No - continue parsing
  4698                                  ;	jmp	badparm 			;AN000; yes - exit
  4699                                  ;
  4700                                  ;dirscan_cont2:
  4701                                  ;	cmp	parse1_syn,offset trangroup:dir_w_syn ;AN000; was /W entered?
  4702                                  ;	je	set_dir_width			;AN000; yes - go set wide lines
  4703                                  ;	cmp	parse1_syn,offset trangroup:slash_p_syn ;AN000; was /P entered?
  4704                                  ;	je	set_dir_pause			;AN000; yes - go set pause at end of screen
  4705                                  ;;
  4706                                  ;; Must be filespec since no other matches occurred. Move filename to srcbuf
  4707                                  ;;
  4708                                  ;	push	si				;AC000; save position in line
  4709                                  ;	lds	si,parse1_addr			;AC000; get address of filespec
  4710                                  ;	push	si				;AN000; save address
  4711                                  ;	invoke	move_to_srcbuf			;AC000; move to srcbuf
  4712                                  ;	pop	dx				;AC000; get address in DX
  4713                                  ;
  4714                                  ;;
  4715                                  ;; The user may have specified a device. Search for the path and see if the
  4716                                  ;; attributes indicate a device.
  4717                                  ;;
  4718                                  ;	mov	ah,Find_First			;AC000; find the file
  4719                                  ;	int	int_command			;AC000;
  4720                                  ;	jnc	Dir_check_device		;AN022; if no error - check device
  4721                                  ;	invoke	get_ext_error_number		;AN022; get the extended error
  4722                                  ;	cmp	ax,error_no_more_files		;AN022; was error no file found
  4723                                  ;	jz	Dir_fspec_end			;AC022; yes -> obviously not a device
  4724                                  ;	cmp	ax,error_path_not_found 	;AN022; was error no file found
  4725                                  ;	jz	Dir_fspec_end			;AC022; yes -> obviously not a device
  4726                                  ;	jmp	dir_err_setup			;AN022; otherwise - go issue error message
  4727                                  ;
  4728                                  ;dir_check_device:				;AN022;
  4729                                  ;	test	byte ptr (DirBuf+find_buf_attr),ATTR_DEVICE ;AC000;
  4730                                  ;	jz	Dir_fspec_end			;AC000; no, go do normal operation
  4731                                  ;	mov	ComSw,-2			;AC000; signal device
  4732                                  ;
  4733                                  ;dir_fspec_end:
  4734                                  ;	pop	si				;AC000; restore position in line
  4735                                  ;	jmp	short dirscan			;AC000; keep parsing
  4736                                  ;
  4737                                  ;set_dir_width:
  4738                                  ;	test	byte ptr[bits],SwitchW		;AN018; /W already set?
  4739                                  ;	jz	ok_set_width			;AN018; no - okay to set width
  4740                                  ;	mov	ax,moreargs_ptr 		;AN018; set up too many arguments
  4741                                  ;	invoke	setup_parse_error_msg		;AN018; set up an error message
  4742                                  ;	jmp	badparm 			;AN018; exit
  4743                                  ;
  4744                                  ;ok_set_width:
  4745                                  ;	or	bits,switchw			;AC000; indicate /w was selected
  4746                                  ;	mov	linlen,wideperlin		;AC000; Set number of entries per line
  4747                                  ;	mov	lincnt,wideperlin		;AC000;
  4748                                  ;	jmp	short dirscan			;AC000; keep parsing
  4749                                  ;
  4750                                  ;set_dir_pause:
  4751                                  ;	test	byte ptr[bits],SwitchP		;AN018; /p already set?
  4752                                  ;	jz	ok_set_pause			;AN018; no - okay to set width
  4753                                  ;	mov	ax,moreargs_ptr 		;AN018; set up too many arguments
  4754                                  ;	invoke	setup_parse_error_msg		;AN018; set up an error message
  4755                                  ;	jmp	badparm 			;AN018; exit
  4756                                  ;
  4757                                  ;ok_set_pause:
  4758                                  ;	or	bits,switchp			;AC000; indicate /p was selected
  4759                                  ;	push	cx				;AN000; save necessary registers
  4760                                  ;	push	si				;AN000;
  4761                                  ;	mov	ax,(IOCTL SHL 8) + generic_ioctl_handle ;AN000; get lines per page on display
  4762                                  ;	mov	bx,stdout			;AN000; lines for stdout
  4763                                  ;	mov	ch,ioc_sc			;AN000; type is display
  4764                                  ;	mov	cl,get_generic			;AN000; get information
  4765                                  ;	mov	dx,offset trangroup:display_ioctl ;AN000;
  4766                                  ;	int	int_command			;AN000;
  4767                                  ;
  4768                                  ;lines_set:
  4769                                  ;	dec	linperpag			;AN000; lines per actual page should
  4770                                  ;	dec	linperpag			;AN000;     two less than the max
  4771                                  ;	mov	ax,linperpag			;AN000; get number of lines into
  4772                                  ;	mov	[fullscr],ax			;AC000;    screen line counter
  4773                                  ;	pop	si				;AN000; restore registers
  4774                                  ;	pop	cx				;AN000;
  4775                                  ;	jmp	dirscan 			;AC000; keep parsing
  4776                                  ;
  4777                                  ;;
  4778                                  ;; The syntax is incorrect. Report only message we can.
  4779                                  ;;
  4780                                  ;BadParm:
  4781                                  ;	jmp	cerror				;AC000; invalid switches get displayed
  4782                                  ;
  4783                                  ;ScanDone:
  4784                                  ;
  4785                                  ;;
  4786                                  ;; Find and display the volume ID on the drive.
  4787                                  ;;
  4788                                  ;
  4789                                  ;	invoke	okvolarg			;AC000;
  4790                                  ;;
  4791                                  ;; OkVolArg also disables APPEND, which will be re-enabled
  4792                                  ;; in the HeadFix routine, after we're done.
  4793                                  ;;
  4794                                  ;	mov	[filecnt],0			;AC000; Keep track of how many files found
  4795                                  ;	cmp	comsw,0 			;AC000; did an error occur?
  4796                                  ;	jnz	doheader			;AC000; yes - don't bother to fix path
  4797                                  ;
  4798                                  ;	mov	dirflag,-1			;AN015; set pathcrunch called from DIR
  4799                                  ;	invoke	pathcrunch			;AC000; set up FCB for dir
  4800                                  ;	mov	dirflag,0			;AN015; reset dirflag
  4801                                  ;	jc	DirCheckPath			;AC015; no CHDIRs worked.
  4802                                  ;	jz	doheader			;AC015; chdirs worked - path\*.*
  4803                                  ;	mov	si,[desttail]			;AN015; get filename back
  4804                                  ;	jmp	short DoRealParse		;AN015; go parse it
  4805                                  ;
  4806                                  ;DirCheckPath:
  4807                                  ;	mov	ax,[msg_numb]			;AN022; get message number
  4808                                  ;	cmp	ax,0				;AN022; Is there a message?
  4809                                  ;	jnz	dir_err_setup			;AN022; yes - there's an error
  4810                                  ;	cmp	[destisdir],0			;AC000; Were pathchars found?
  4811                                  ;	jz	doparse 			;AC000; no - no problem
  4812                                  ;	inc	comsw				;AC000; indicate error
  4813                                  ;	jmp	short doheader			;AC000; go print header
  4814                                  ;
  4815                                  ;DirNF:
  4816                                  ;	mov	ax,error_file_not_found 	;AN022; get message number in control block
  4817                                  ;
  4818                                  ;dir_err_setup:
  4819                                  ;	mov	msg_disp_class,ext_msg_class	;AN000; set up extended error msg class
  4820                                  ;	mov	dx,offset TranGroup:Extend_Buf_ptr  ;AC000; get extended message pointer
  4821                                  ;	mov	extend_buf_ptr,ax		;AN022;
  4822                                  ;
  4823                                  ;DirError:
  4824                                  ;	jmp	Cerror
  4825                                  ;
  4826                                  ;;
  4827                                  ;; We have changed to something. We also have a file. Parse it into a
  4828                                  ;; reasonable form, leaving drive alone, leaving extention alone and leaving
  4829                                  ;; filename alone. We need to special case ... If we are at the root, the
  4830                                  ;; parse will fail and it will give us a file not found instead of file not
  4831                                  ;; found.
  4832                                  ;;
  4833                                  ;DoParse:
  4834                                  ;	mov	si,offset trangroup:srcbuf	;AN000; Get address of source
  4835                                  ;	cmp	byte ptr [si+1],colon_char	;AN000; Is there a drive?
  4836                                  ;	jnz	dir_no_drive			;AN000; no - keep going
  4837                                  ;	lodsw					;AN000; bypass drive
  4838                                  ;
  4839                                  ;dir_no_drive:
  4840                                  ;	cmp	[si],".."
  4841                                  ;	jnz	DoRealParse
  4842                                  ;	cmp	byte ptr [si+2],0
  4843                                  ;	jnz	DoRealParse
  4844                                  ;	inc	ComSw
  4845                                  ;	jmp	short DoHeader
  4846                                  ;
  4847                                  ;DoRealParse:
  4848                                  ;	mov	di,FCB			; where to put the file name
  4849                                  ;	mov	ax,(Parse_File_Descriptor SHL 8) OR 0EH
  4850                                  ;	int	int_command
  4851                                  ;
  4852                                  ;;
  4853                                  ;; Check to see if APPEND installed. If it is installed, set all flags
  4854                                  ;; off.	This will be reset in the HEADFIX routine
  4855                                  ;;
  4856                                  ;
  4857                                  ;DoHeader:
  4858                                  ;; ORIGINAL APPEND CHECK CODE LOCATION ******************************
  4859                                  ;
  4860                                  ;;
  4861                                  ;; Display the header
  4862                                  ;;
  4863                                  ;
  4864                                  ;DoHeaderCont:
  4865                                  ;	mov	al,blank			;AN051; Print out a blank
  4866                                  ;	invoke	print_char			;AN051;   before DIR header
  4867                                  ;	invoke	build_dir_string		; get current dir string
  4868                                  ;	mov	dx,offset trangroup:Dirhead_ptr
  4869                                  ;	invoke	printf_crlf			; bang!
  4870                                  ;
  4871                                  ;;
  4872                                  ;; If there were chars left after parse or device, then invalid file name
  4873                                  ;;
  4874                                  ;	cmp	ComSw,0
  4875                                  ;	jz	DoSearch			; nothing left; good parse
  4876                                  ;	jl	DirNFFix			; not .. => error file not found
  4877                                  ;	invoke	RestUDir
  4878                                  ;	mov	dx,offset TranGroup:BadCD_ptr
  4879                                  ;	jmp	Cerror				; was .. => error directory not found
  4880                                  ;DirNFFix:
  4881                                  ;	invoke	RestUDir
  4882                                  ;	jmp	DirNF
  4883                                  ;;
  4884                                  ;; We are assured that everything is correct.  Let's go and search.  Use
  4885                                  ;; attributes that will include finding directories.  perform the first search
  4886                                  ;; and reset our directory afterward.
  4887                                  ;;
  4888                                  ;DoSearch:
  4889                                  ;	mov	byte ptr DS:[FCB-7],0FFH
  4890                                  ;	mov	byte ptr DS:[FCB-1],010H
  4891                                  ;;
  4892                                  ;; Caution!  Since we are using an extended FCB, we will *also* be returning
  4893                                  ;; the directory information as an extended FCB. We must bias all fetches into
  4894                                  ;; DIRBUF by 8 (Extended FCB part + drive)
  4895                                  ;;
  4896                                  ;	mov	ah,Dir_Search_First
  4897                                  ;	mov	dx,FCB-7
  4898                                  ;	int	int_command
  4899                                  ;
  4900                                  ;	push	ax				;AN022; save return state
  4901                                  ;	inc	al				;AN022; did an error occur?
  4902                                  ;	pop	ax				;AN022; get return state back
  4903                                  ;	jnz	found_first_file		;AN022; no error - start dir
  4904                                  ;	invoke	set_ext_error_msg		;AN022; yes - set up error message
  4905                                  ;	push	dx				;AN022; save message
  4906                                  ;	invoke	restudir			;AN022; restore user's dir
  4907                                  ;	pop	dx				;AN022; restore message
  4908                                  ;	cmp	word ptr Extend_Buf_Ptr,Error_No_More_Files ;AN022; convert no more files to
  4909                                  ;	jnz	DirCerrorJ			;AN022; 	file not found
  4910                                  ;	mov	Extend_Buf_Ptr,Error_File_Not_Found  ;AN022;
  4911                                  ;
  4912                                  ;DirCerrorJ:					;AN022;
  4913                                  ;	jmp	Cerror				;AN022; exit
  4914                                  ;
  4915                                  ;;
  4916                                  ;; Restore the user's directory.  We preserve, though, the return from the
  4917                                  ;; previous system call for later checking.
  4918                                  ;;
  4919                                  ;
  4920                                  ;found_first_file:
  4921                                  ;	push	ax
  4922                                  ;	invoke	restudir
  4923                                  ;	pop	ax
  4924                                  ;;
  4925                                  ;; Main scanning loop. Entry has AL = Search first/next error code. Test for
  4926                                  ;; no more.
  4927                                  ;;
  4928                                  ;DIRSTART:
  4929                                  ;	inc	al				; FF = file not found
  4930                                  ;	jnz	Display
  4931                                  ;	jmp	DirDone 			; Either an error or we are finished
  4932                                  ;;
  4933                                  ;; Note that we've seen a file and display the found file.
  4934                                  ;;
  4935                                  ;
  4936                                  ;Display:
  4937                                  ;	inc	[filecnt]			; Keep track of how many we find
  4938                                  ;	mov	si,offset trangroup:dirbuf+8	; SI -> information returned by sys call
  4939                                  ;	call	shoname
  4940                                  ;;
  4941                                  ;; If we are displaying in wide mode, do not output the file info
  4942                                  ;;
  4943                                  ;	test	byte ptr[bits],SwitchW		; W switch set?
  4944                                  ;	jz	DirTest
  4945                                  ;	jmp	nexent				; If so, no size, date, or time
  4946                                  ;
  4947                                  ;;
  4948                                  ;; Test for directory.
  4949                                  ;;
  4950                                  ;DirTest:
  4951                                  ;	test	[dirbuf+8].dir_attr,attr_directory
  4952                                  ;	jz	fileent
  4953                                  ;;
  4954                                  ;; We have a directory.	Display the <DIR> field in place of the file size
  4955                                  ;;
  4956                                  ;	mov	dx,offset trangroup:Dmes_ptr
  4957                                  ;	call	std_printf
  4958                                  ;	jmp	short nofsiz
  4959                                  ;;
  4960                                  ;; We have a file.  Display the file size
  4961                                  ;;
  4962                                  ;fileent:
  4963                                  ;	mov	dx,[DirBuf+8].dir_size_l
  4964                                  ;	mov	file_size_low,dx
  4965                                  ;	mov	dx,[DirBuf+8].dir_size_h
  4966                                  ;	mov	file_size_high,dx
  4967                                  ;	mov	dx,offset trangroup:disp_file_size_ptr
  4968                                  ;	call	std_printf
  4969                                  ;;
  4970                                  ;; Display time and date of last modification
  4971                                  ;;
  4972                                  ;nofsiz:
  4973                                  ;	mov	ax,[DirBuf+8].dir_date		; Get date
  4974                                  ;;
  4975                                  ;; If the date is 0, then we have found a 1.x level diskette.  We skip the
  4976                                  ;; date/time fields as 1.x did not have them.
  4977                                  ;;
  4978                                  ;	or	ax,ax
  4979                                  ;	jz	nexent				; Skip if no date
  4980                                  ;	mov	bx,ax
  4981                                  ;	and	ax,1FH				; get day
  4982                                  ;	mov	dl,al
  4983                                  ;	mov	ax,bx
  4984                                  ;	mov	cl,5
  4985                                  ;	shr	ax,cl				; Align month
  4986                                  ;	and	al,0FH				; Get month
  4987                                  ;	mov	dh,al
  4988                                  ;	mov	cl,bh
  4989                                  ;	shr	cl,1				; Align year
  4990                                  ;	xor	ch,ch
  4991                                  ;	add	cx,80				; Relative 1980
  4992                                  ;	cmp	cl,100
  4993                                  ;	jb	millenium
  4994                                  ;	sub	cl,100
  4995                                  ;
  4996                                  ;millenium:
  4997                                  ;	xchg	dh,dl				;AN000; switch month & day
  4998                                  ;	mov	DirDat_yr,cx			;AC000; put year into message control block
  4999                                  ;	mov	DirDat_mo_day,dx		;AC000; put month and day into message control block
  5000                                  ;	mov	cx,[DirBuf+8].dir_time		; Get time
  5001                                  ;	jcxz	prbuf				; Time field present?
  5002                                  ;	shr	cx,1
  5003                                  ;	shr	cx,1
  5004                                  ;	shr	cx,1
  5005                                  ;	shr	cl,1
  5006                                  ;	shr	cl,1				; Hours in CH, minutes in CL
  5007                                  ;	xchg	ch,cl				;AN000; switch hours & minutes
  5008                                  ;	mov	DirTim_hr_min,cx		;AC000; put hours and minutes into message subst block
  5009                                  ;
  5010                                  ;prbuf:
  5011                                  ;	mov	dx,offset trangroup:DirDatTim_ptr
  5012                                  ;	call	std_printf
  5013                                  ;	invoke	crlf2				;AC066;end the line
  5014                                  ;	dec	byte ptr [fullscr]		;AC066;count the line
  5015                                  ;	jnz	endif04 			;AN066;IF the last on the screen THEN
  5016                                  ;	   call    check_for_P			;AN066;   pause if /P requested
  5017                                  ;	endif04:				;AN066;
  5018                                  ;	jmp	scroll				; If not, just continue
  5019                                  ;;AD061; mov	DirDat_yr,0			;AC000; reset year, month and day
  5020                                  ;;AD061; mov	DirDat_mo_day,0 		;AC000;     in control block
  5021                                  ;;AD061; mov	DirTim_hr_min,0 		;AC000; reset hour & minute in control block
  5022                                  ;;
  5023                                  ;; We are done displaying an entry.  The code between "noexent:" and "scroll:"
  5024                                  ;; is only for /W case.
  5025                                  ;;
  5026                                  ;nexent:
  5027                                  ;	mov	bl,[lincnt]			;AN066;save for check for first entry on line
  5028                                  ;	dec	[lincnt]			      ;count this entry on the line
  5029                                  ;	jnz	else01				;AX066;IF last entry on line THEN
  5030                                  ;	   mov	   al,[linlen]
  5031                                  ;	   mov	   [lincnt],al
  5032                                  ;	   invoke  crlf2
  5033                                  ;	   cmp	   [fullscr],0			;AC066;IF have filled the screen THEN
  5034                                  ;	   jnz	   endif02			;AN066;
  5035                                  ;	      call    check_for_P		;AN066;   reinitialize fullscr,
  5036                                  ;	   endif02:				;AN066;   IF P requested THEN pause
  5037                                  ;	   jmp	   short endif01		;AN066;
  5038                                  ;	else01: 				;AN066;ELSE since screen not full
  5039                                  ;	   cmp	   bl,[linlen]			;AN066;   IF starting new line THEN
  5040                                  ;	   jne	   endif03			;	     count the line
  5041                                  ;	      dec     byte ptr [fullscr]	;AN066;   ENDIF
  5042                                  ;	   endif03:				;AC066;We are outputting on the same line, between fields, we tab.
  5043                                  ;	   mov	   dx,offset trangroup:tab_ptr	;Output a tab
  5044                                  ;	   call    std_printf
  5045                                  ;	endif01:				;AX066;
  5046                                  ;;
  5047                                  ;; All we need to do now is to get the next directory entry.
  5048                                  ;;
  5049                                  ;scroll:
  5050                                  ;	mov	ah,Dir_Search_Next
  5051                                  ;	mov	dx,FCB-7			; DX -> Unopened FCB
  5052                                  ;	int	int_command			; Search for a file to match FCB
  5053                                  ;	jmp	DirStart
  5054                                  ;;
  5055                                  ;; If no files have been found, display a not-found message
  5056                                  ;;
  5057                                  ;DirDone:
  5058                                  ;	invoke	get_ext_error_number		;AN022; get the extended error number
  5059                                  ;	cmp	ax,error_no_more_files		;AN022; was error file not found?
  5060                                  ;	jnz	dir_err_setup_jmp		;AN022; no - setup error message
  5061                                  ;	test	[filecnt],-1
  5062                                  ;	jnz	Trailer
  5063                                  ;	mov	ax,error_file_not_found 	;AN022;
  5064                                  ;
  5065                                  ;dir_err_setup_jmp:				;AN022;
  5066                                  ;	jmp	dir_err_setup			;AN022; go setup error msg & print it
  5067                                  ;;
  5068                                  ;; If we have printed the maximum number of files per line, terminate it with
  5069                                  ;; CRLF.
  5070                                  ;;
  5071                                  ;Trailer:
  5072                                  ;	mov	al,[linlen]
  5073                                  ;	cmp	al,[lincnt]			; Will be equal if just had CR/LF
  5074                                  ;	jz	mmessage
  5075                                  ;	invoke	crlf2
  5076                                  ;	cmp	[fullscr],0			;AN066;IF on last line of screen THEN
  5077                                  ;	jnz	endif06 			;AN066;   pause before going on
  5078                                  ;	   call    check_for_P			;AN066;   to number and freespace
  5079                                  ;	endif06:				;AN066;   displays
  5080                                  ;
  5081                                  ;mmessage:
  5082                                  ;	mov	dx,offset trangroup:Dirmes_ptr
  5083                                  ;	mov	si,[filecnt]
  5084                                  ;	mov	dir_num,si
  5085                                  ;	call	std_printf
  5086                                  ;	mov	ah,Get_Drive_Freespace
  5087                                  ;	mov	dl,byte ptr DS:[FCB]
  5088                                  ;	int	int_command
  5089                                  ;	cmp	ax,-1
  5090                                  ;	retz
  5091                                  ;	mul	cx				; AX is bytes per cluster
  5092                                  ;	mul	bx
  5093                                  ;	mov	bytes_free,ax			;AC000;
  5094                                  ;	mov	bytes_free+2,dx 		;AC000;
  5095                                  ;	MOV	DX,OFFSET TRANGROUP:BYTMES_ptr
  5096                                  ;	jmp	std_printf
  5097                                  ;
  5098                                  ;shoname:
  5099                                  ;	mov	di,offset trangroup:charbuf
  5100                                  ;	mov	cx,8
  5101                                  ;	rep	movsb
  5102                                  ;	mov	al,' '
  5103                                  ;	stosb
  5104                                  ;	mov	cx,3
  5105                                  ;	rep	movsb
  5106                                  ;	xor	ax,ax
  5107                                  ;	stosb
  5108                                  ;	push	dx
  5109                                  ;	mov	dx,offset trangroup:charbuf
  5110                                  ;	mov	string_ptr_2,dx
  5111                                  ;	mov	dx,offset trangroup:string_buf_ptr
  5112                                  ;	call	std_printf
  5113                                  ;	pop	DX
  5114                                  ;	return
  5115                                  ;
  5116                                  ;check_for_P    PROC  NEAR		;AN066;
  5117                                  ;
  5118                                  ;	test	byte ptr[bits],SwitchP	;P switch present?
  5119                                  ;	jz	endif05 		;AN066;
  5120                                  ; 	 mov	   ax,linperpag 	;AN000;  transfer lines per page
  5121                                  ; 	 mov	   [fullscr],ax 	;AC000;	to fullscr
  5122                                  ;   	invoke  Pause
  5123                                  ;endif05:
  5124                                  ;	ret				;AN066;
  5125                                  ;
  5126                                  ;check_for_P    ENDP			;AN066;
  5127                                  
  5128                                  ; =============== S U B	R O U T	I N E =======================================
  5129                                  
  5130                                  SHONAME:
  5131                                  DISPLAYNAME:
  5132                                  		; MSDOS 3.3
  5133 00001151 BF[AB41]                		mov	di,CHARBUF
  5134 00001154 B90800                  		mov	cx,8
  5135 00001157 F3A4                    		rep movsb
  5136 00001159 B020                    		mov	al,' '
  5137 0000115B AA                      		stosb
  5138                                  		;mov	cx,3
  5139                                  		; 02/03/2023
  5140 0000115C B103                    		mov	cl,3
  5141 0000115E F3A4                    		rep movsb
  5142 00001160 31C0                    		xor	ax,ax
  5143 00001162 AA                      		stosb
  5144 00001163 52                      		push	dx
  5145 00001164 BA[AB41]                		mov	dx,CHARBUF
  5146 00001167 8916[5E43]              		mov	[STRING_PTR_2],dx
  5147 0000116B BA[6F36]                		mov	dx,STRINGBUF2PTR
  5148 0000116E E8B722                  		call	STD_PRINTF
  5149 00001171 5A                      		pop	dx
  5150 00001172 C3                      		retn
  5151                                  
  5152                                  ;============================================================================
  5153                                  ; TCMD1B.ASM, MSDOS 6.0, 1991
  5154                                  ;============================================================================
  5155                                  ; 09/10/2018 - Retro DOS v3.0
  5156                                  
  5157                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1195h
  5158                                  
  5159                                  
  5160                                  ; =============== S U B	R O U T	I N E =======================================
  5161                                  
  5162                                  PAUSE:
  5163 00001173 BA[3C39]                		mov	dx,PAUSEMESPTR
  5164 00001176 E8AF22                  		call	STD_PRINTF
  5165 00001179 E870F3                  		call	GETKEYSTROKE
  5166                                  		;call	CRLF2
  5167                                  		;retn
  5168                                  		; 02/03/2023
  5169 0000117C E9BA07                  		jmp	CRLF2
  5170                                  
  5171                                  ; ---------------------------------------------------------------------------
  5172                                  
  5173                                  ;****************************************************************
  5174                                  ;*
  5175                                  ;* ROUTINE:	DEL/ERASE - erase file(s)
  5176                                  ;*
  5177                                  ;* FUNCTION:	PARSE command line for file or path name and /P
  5178                                  ;*		and invoke PATHCRUNCH.	If an error occurs, set
  5179                                  ;*		up an error message and transfer control to CERROR.
  5180                                  ;*		Otherwise, transfer control to NOTEST2 if /P not
  5181                                  ;*		entered or SLASHP_ERASE if /P entered.
  5182                                  ;*
  5183                                  ;* INPUT:	command line at offset 81H
  5184                                  ;*
  5185                                  ;* OUTPUT:	if no error:
  5186                                  ;*		FCB at 5ch set up with filename(s) entered
  5187                                  ;*		Current directory set to entered directory
  5188                                  ;*
  5189                                  ;****************************************************************
  5190                                  
  5191                                  ERASE:
  5192                                  		; MSDOS 6.0
  5193                                  
  5194                                  ;assume	ds:trangroup,es:trangroup
  5195                                  
  5196                                  ;		mov	si,81H		;AC000; get command line
  5197                                  ;		mov	comsw,0 	;AN000; clear switch indicator
  5198                                  ;		mov	di,offset trangroup:parse_erase
  5199                                  ;					;AN000; Get address of PARSE_erase
  5200                                  ;		xor	cx,cx		;AN000; clear cx,dx
  5201                                  ;erase_scan:
  5202                                  ;		xor	dx,dx		;AN000;
  5203                                  ;		invoke	parse_with_msg	;AC018; call parser
  5204                                  ;		cmp	ax,end_of_line	;AN000; are we at end of line?
  5205                                  ;		jz	good_line	;AN000; yes - done parsing
  5206                                  ;		cmp	ax,result_no_error ;AC000; did we have an error?
  5207                                  ;		jnz	errj2		;AC000; yes exit
  5208                                  ;
  5209                                  ;		cmp	parse1_syn,offset trangroup:slash_p_syn 
  5210                                  ;					;AN000; was /P entered?
  5211                                  ;		je	set_erase_prompt ;AN000; yes - go set prompt
  5212                                  ;;
  5213                                  ;; Must be filespec since no other matches occurred. move filename to srcbuf
  5214                                  ;;
  5215                                  ;		push	si		;AC000; save position in line
  5216                                  ;		lds	si,parse1_addr	;AC000; get address of filespec
  5217                                  ;		cmp	byte ptr[si+1],colon_char ;AC000; drive specified?
  5218                                  ;		jnz	Erase_drive_ok	;AC000; no - continue
  5219                                  ;		cmp	byte ptr[si+2],end_of_line_out	
  5220                                  ;					;AC000; was only drive entered?
  5221                                  ;		jnz	erase_drive_ok	;AC000; no - continue
  5222                                  ;		mov	ax,error_file_not_found 
  5223                                  ;					;AN022; get message number in control block
  5224                                  ;		jmp	short extend_setup ;AC000; exit
  5225                                  ;
  5226                                  ;erase_drive_ok:
  5227                                  ;		invoke	move_to_srcbuf	;AC000; move to srcbuf
  5228                                  ;		pop	si		;AC000; get position back
  5229                                  ;		jmp	short erase_scan ;AN000; continue parsing
  5230                                  ;
  5231                                  ;set_erase_prompt:
  5232                                  ;		cmp	comsw,0 	;AN018; was /P already entered?
  5233                                  ;		jz	ok_to_set_erase_prompt ;AN018; no go set switch
  5234                                  ;		mov	ax,moreargs_ptr ;AN018; set up too many arguments
  5235                                  ;		invoke	setup_parse_error_msg ;AN018; set up an error message
  5236                                  ;		jmp	short errj2	;AN018; exit
  5237                                  ;
  5238                                  ;ok_to_set_erase_prompt: 		;AN018;
  5239                                  ;		inc	comsw		;AN000; indicate /p specified
  5240                                  ;		jmp	short erase_scan ;AN000; continue parsing
  5241                                  ;
  5242                                  ;good_line:				;G  We know line is good
  5243                                  ;		invoke	pathcrunch
  5244                                  ;		jnc	checkdr
  5245                                  ;		mov	ax,[msg_numb]	;AN022; get message number
  5246                                  ;		cmp	ax,0		;AN022; was message flag set?
  5247                                  ;		jnz	extend_setup	;AN022; yes - print out message
  5248                                  ;		cmp	[destisdir],0	; No CHDIRs worked
  5249                                  ;		jnz	badpath_err	;AC022; see if they should have
  5250                                  ;
  5251                                  ;checkdr:
  5252                                  ;		cmp	comsw,0 	;AN000; was /p specified
  5253                                  ;		jz	notest2j	;AN000; no - go to notest2
  5254                                  ;		jmp	slashp_erase	;AN000; yes - go to slashp_erase
  5255                                  ;
  5256                                  ;notest2j:
  5257                                  ;		jmp	notest2
  5258                                  ;
  5259                                  ;badpath_err:				;AN022; "Path not found" message
  5260                                  ;		mov	ax,error_path_not_found ;AN022; set up error number
  5261                                  ;
  5262                                  ;extend_setup:				;AN022;
  5263                                  ;		mov	msg_disp_class,ext_msg_class
  5264                                  ;					;AN022; set up extended error msg class
  5265                                  ;		mov	dx,offset TranGroup:Extend_Buf_ptr
  5266                                  ;					;AC022; get extended message pointer
  5267                                  ;		mov	Extend_Buf_ptr,ax
  5268                                  ;					;AN022; get message number in control block
  5269                                  ;errj2:					;AC022; exit jump
  5270                                  ;		jmp	Cerror		;AN022;
  5271                                  
  5272                                  		; MSDOS 3.3
  5273 0000117F BA[9D3C]                		mov	dx,BADARGSPTR
  5274 00001182 BE8000                  		mov	si,80h
  5275 00001185 AC                      		lodsb
  5276 00001186 08C0                    		or	al,al
  5277 00001188 743E                    		jz	short ERRJ2
  5278 0000118A E8B907                  		call	SCANOFF
  5279 0000118D 3C0D                    		cmp	al,0Dh		; Return key
  5280 0000118F 7437                    		jz	short ERRJ2	; If so no parameters specified
  5281 00001191 52                      		push	dx
  5282 00001192 56                      		push	si
  5283 00001193 BA[2837]                		mov	dx,FNOTFOUNDPTR
  5284                                  ERASE_SCAN:
  5285 00001196 AC                      		lodsb
  5286 00001197 E8B407                  		call	DELIM
  5287 0000119A 7406                    		jz	short ERASE_CHKDELIMCHR
  5288 0000119C 3C0D                    		cmp	al,0Dh
  5289 0000119E 7415                    		jz	short GOOD_LINE
  5290 000011A0 EBF4                    		jmp	short ERASE_SCAN
  5291                                  ERASE_CHKDELIMCHR:
  5292 000011A2 3C20                    		cmp	al,20h
  5293 000011A4 7F22                    		jg	short ERRJ2
  5294 000011A6 AC                      		lodsb
  5295 000011A7 E8A407                  		call	DELIM
  5296 000011AA 74F6                    		jz	short ERASE_CHKDELIMCHR
  5297 000011AC 3C0D                    		cmp	al,0Dh
  5298 000011AE 7405                    		jz	short GOOD_LINE
  5299 000011B0 BA[9D3C]                		mov	dx,BADARGSPTR
  5300 000011B3 EB13                    		jmp	short ERRJ2
  5301                                  GOOD_LINE:
  5302 000011B5 5E                      		pop	si
  5303 000011B6 5A                      		pop	dx
  5304 000011B7 56                      		push	si
  5305 000011B8 E82E08                  		call	PATHCRUNCH
  5306 000011BB 730E                    		jnc	short CHECKDR
  5307 000011BD 803E[7C43]00            		cmp	byte [DESTISDIR],0 ; No CHDIRs worked	
  5308 000011C2 7407                    		jz	short CHECKDR	   ; see if they should have
  5309                                  BADCDERR:
  5310 000011C4 5E                      		pop	si
  5311 000011C5 BA[A63A]                		mov	dx,BADCDPTR
  5312                                  ERRJ2:
  5313 000011C8 E91F0A                  		jmp	CERROR
  5314                                  CHECKDR:
  5315 000011CB BA[2837]                		mov	dx,FNOTFOUNDPTR
  5316 000011CE 59                      		pop	cx
  5317 000011CF B020                    		mov	al,' '
  5318                                  		;cmp	[5Dh],al
  5319 000011D1 38065D00                		cmp	[FCB+1],al
  5320 000011D5 74F1                    		jz	short ERRJ2
  5321 000011D7 83C103                  		add	cx,3
  5322 000011DA 39CE                    		cmp	si,cx
  5323 000011DC 7507                    		jnz	short NOTEST2J
  5324 000011DE B03A                    		mov	al,':'
  5325 000011E0 3844FE                  		cmp	[si-2],al
  5326 000011E3 74E3                    		jz	short ERRJ2
  5327                                  NOTEST2J:
  5328 000011E5 E9B615                  		jmp	NOTEST2
  5329                                  
  5330                                  ; ---------------------------------------------------------------------------
  5331                                  
  5332                                  ; ****************************************************************
  5333                                  ; *
  5334                                  ; * ROUTINE:	 CRENAME - rename file(s)
  5335                                  ; *
  5336                                  ; * FUNCTION:	 PARSE command line for one full filespec and one
  5337                                  ; *		 filename.  Invoke PATHCRUNCH on the full filespec.
  5338                                  ; *		 Make sure the second filespec only contains a
  5339                                  ; *		 filename.  If both openands are valid, attempt
  5340                                  ; *		 to rename the file.
  5341                                  ; *
  5342                                  ; * INPUT:	 command line at offset 81H
  5343                                  ; *
  5344                                  ; * OUTPUT:	 none
  5345                                  ; *
  5346                                  ; ****************************************************************
  5347                                  
  5348                                  CRENAME:
  5349                                  		; MSDOS 6.0
  5350                                  		;assume	ds:trangroup,es:trangroup
  5351                                  ;
  5352                                  ;		mov	si,81H		;AC000; Point to command line
  5353                                  ;		mov	di,offset trangroup:parse_rename
  5354                                  ;					;AN000; Get address of PARSE_RENAME
  5355                                  ;		xor	cx,cx		;AN000; clear cx,dx
  5356                                  ;		xor	dx,dx		;AN000;
  5357                                  ;		invoke	parse_with_msg	;AC018; call parser
  5358                                  ;		cmp	ax,result_no_error ;AC000; did we have an error?
  5359                                  ;;		jz	crename_no_parse_error ;AC000; no - continue
  5360                                  ;		jnz	crename_parse_error ;AC000; Yes, fail. (need long jump)
  5361                                  ;;
  5362                                  ;;  Get first file name returned from parse into our buffer
  5363                                  ;;
  5364                                  ;crename_no_parse_error:
  5365                                  ;		push	si		;AN000; save position in line
  5366                                  ;		lds	si,parse1_addr	;AN000; get address of filespec
  5367                                  ;		invoke	move_to_srcbuf	;AN000; move to srcbuf
  5368                                  ;		pop	si		;AN000; restore position in line
  5369                                  ;
  5370                                  ;		xor	dx,dx		;AN000; clear dx
  5371                                  ;		invoke	parse_with_msg	;AC018; call parser
  5372                                  ;		cmp	ax,result_no_error ;AN000; did we have an error?
  5373                                  ;		JNZ	crename_parse_error ;AN000; Yes, fail.
  5374                                  ;;
  5375                                  ;;  Check the second file name for drive letter colon
  5376                                  ;;
  5377                                  ;		push	si		;AN000; save position in line
  5378                                  ;		lds	si,parse1_addr	;AC000; get address of path
  5379                                  ;
  5380                                  ;		mov	al,':'		;AC000;
  5381                                  ;		cmp	[si+1],al	;AC000; Does the 2nd parm have a drive spec?
  5382                                  ;		jnz	ren_no_drive	;AN000; Yes, error
  5383                                  ;		mov	msg_disp_class,parse_msg_class
  5384                                  ;					;AN000; set up parse error msg class
  5385                                  ;		mov	dx,offset TranGroup:Extend_Buf_ptr
  5386                                  ;					;AC000; get extended message pointer
  5387                                  ;		mov	Extend_Buf_ptr,BadParm_ptr
  5388                                  ;					;AN000; get "Invalid parameter" message number
  5389                                  ;		pop	si		;AN000;
  5390                                  ;crename_parse_error:			;AC022;
  5391                                  ;		jmp	short errj	;AC000;
  5392                                  ;
  5393                                  ;;  Get second file name returned from parse into the fCB. Save
  5394                                  ;;  character after file name so we can later check to make sure it
  5395                                  ;;  isn't a path character.
  5396                                  ;
  5397                                  ;
  5398                                  ;ren_no_drive:
  5399                                  ;		mov	di,FCB+10H	;AC000; set up to parse second file name
  5400                                  ;		mov	ax,(Parse_File_Descriptor SHL 8) OR 01H ;AC000;
  5401                                  ;		int	21h		;AC000; do the function
  5402                                  ;		lodsb			;AC000; Load char after filename
  5403                                  ;		mov	one_char_val,al ;AN000; save char after filename
  5404                                  ;		pop	si		;AN000; get line position back
  5405                                  ;
  5406                                  ;;
  5407                                  ;; We have source and target.  See if any args beyond.
  5408                                  ;;
  5409                                  ;
  5410                                  ;		mov	di,offset trangroup:parse_rename
  5411                                  ;					;AC000; get address of parse_rename
  5412                                  ;		invoke	parse_check_eol ;AC000; are we at end of line?
  5413                                  ;		jnz	crename_parse_error ;AN000; no, fail.
  5414                                  ;
  5415                                  ;		invoke	pathcrunch
  5416                                  ;		mov	dx,offset trangroup:badcpmes_ptr
  5417                                  ;		jz	errj2		; If 1st parm a dir, print error msg
  5418                                  ;		jnc	notest3
  5419                                  ;		mov	ax,[msg_numb]	;AN022; get message number
  5420                                  ;		cmp	ax,0		;AN022; was message flag set?
  5421                                  ;		jnz	extend_setup	;AN022; yes - print out message
  5422                                  ;		cmp	[destisdir],0	; No CHDIRs worked
  5423                                  ;		jz	notest3 	; see if they should have
  5424                                  ;		Jmp	badpath_err	;AC022; set up error
  5425                                  ;
  5426                                  ;notest3:
  5427                                  ;		mov	al,one_char_val ;AN000; move char into AX
  5428                                  ;		mov	dx,offset trangroup:inornot_ptr 
  5429                                  ;					; Load invalid fname error ptr
  5430                                  ;		invoke	pathchrcmp	; Is the char in al a path sep?
  5431                                  ;		jz	errj		; Yes, error - 2nd arg must be
  5432                                  ;					;  filename only.
  5433                                  ;		mov	ah,FCB_Rename
  5434                                  ;		mov	dx,FCB
  5435                                  ;		int	21h
  5436                                  ;		cmp	al, 0FFH	; Did an error occur??
  5437                                  ;		jnz	renameok
  5438                                  ;
  5439                                  ;		invoke	get_ext_error_number ;AN022; get extended error
  5440                                  ;		SaveReg <AX>		;AC022; Save results
  5441                                  ;		mov	al, 0FFH	; Restore original error state
  5442                                  ;
  5443                                  ;renameok:
  5444                                  ;		push	ax
  5445                                  ;		invoke	restudir
  5446                                  ;		pop	ax
  5447                                  ;		inc	al
  5448                                  ;		retnz
  5449                                  ;
  5450                                  ;		RestoreReg  <AX>	;AC022; get the error number back
  5451                                  ;		cmp	ax,error_file_not_found 
  5452                                  ;					;AN022; error file not found?
  5453                                  ;		jz	use_renerr	;AN022; yes - use generic error message
  5454                                  ;		cmp	ax,error_access_denied
  5455                                  ;					;AN022; error file not found?
  5456                                  ;		jz	use_renerr	;AN022; yes - use generic error message
  5457                                  ;		jmp	extend_setup	;AN022; need long jump - use extended error
  5458                                  ;
  5459                                  ;use_renerr:
  5460                                  ;		mov	dx,offset trangroup:RenErr_ptr	;AC022;
  5461                                  ;ERRJ:
  5462                                  ;		jmp	Cerror
  5463                                  ;
  5464                                  ;ret56:		ret
  5465                                  
  5466                                  		; MSDOS 3.3
  5467 000011E8 BA[9D3C]                		mov	dx,BADARGSPTR
  5468 000011EB E85807                  		call	SCANOFF
  5469 000011EE 3C0D                    		cmp	al,0Dh
  5470 000011F0 74D6                    		jz	short ERRJ2
  5471 000011F2 E8F407                  		call	PATHCRUNCH
  5472 000011F5 BA[7C3C]                		mov	dx,BADCPMESPTR
  5473 000011F8 74CE                    		jz	short ERRJ2
  5474 000011FA 7307                    		jnb	short CRENAME_NO_PARSE_ERROR
  5475 000011FC 803E[7C43]00            		cmp	byte [DESTISDIR],0 ; No CHDIRs worked	
  5476                                  		;jz	short CRENAME_NO_PARSE_ERROR ; see if they should have
  5477                                  		;jmp	short BADCDERR
  5478                                  		; 02/03/2023
  5479 00001201 75C1                    		jnz	short BADCDERR
  5480                                  
  5481                                  ;  Get first file name returned from parse into our buffer
  5482                                  
  5483                                  CRENAME_NO_PARSE_ERROR:
  5484 00001203 8B36[D042]              		mov	si,[PATHPOS]
  5485 00001207 E83C07                  		call	SCANOFF
  5486 0000120A 3C0D                    		cmp	al,0Dh
  5487 0000120C BA[9D3C]                		mov	dx,BADARGSPTR
  5488 0000120F 7443                    		jz	short ERRJ
  5489 00001211 B03A                    		mov	al,':'
  5490 00001213 BA[5239]                		mov	dx,BADPARMPTR
  5491 00001216 384401                  		cmp	[si+1],al
  5492 00001219 7439                    		jz	short ERRJ
  5493                                  
  5494                                  ;  Get second file name returned from parse into the FCB. Save
  5495                                  ;  character after file name so we can later check to make sure it
  5496                                  ;  isn't a path character.
  5497                                  
  5498                                  REN_NO_DRIVE:
  5499                                  		;mov	di,6Ch
  5500 0000121B BF6C00                  		mov	di,FCB+10h
  5501 0000121E B80129                  		mov	ax,(PARSE_FILE_DESCRIPTOR<<8)|01h ; 2901h
  5502 00001221 CD21                    		int	21h	; DOS -	PARSE FILENAME
  5503                                  				; DS:SI	-> string to parse
  5504                                  				; ES:DI	-> buffer to fill with unopened	FCB
  5505                                  				; AL = bit mask	to control parsing
  5506 00001223 B020                    		mov	al,' '
  5507                                  		;cmp	[6Dh],al
  5508 00001225 38066D00                		cmp	[FCB+10h+1],al	; Check if parameter exists
  5509 00001229 7429                    		jz	short ERRJ	; Error if missing parameter
  5510 0000122B AC                      		lodsb
  5511 0000122C BA[1738]                		mov	dx,INORNOTPTR
  5512 0000122F E8A607                  		call	PATHCHRCMP
  5513 00001232 7420                    		jz	short ERRJ
  5514 00001234 B417                    		mov	ah,FCB_RENAME ; 17h
  5515 00001236 BA5C00                  		mov	dx,FCB ; 5Ch
  5516 00001239 CD21                    		int	21h	; DOS -	RENAME FILE via	FCB
  5517                                  				; DS:DX	-> FCB
  5518                                  				; FCB contains new name	starting at byte 17h.
  5519 0000123B 3CFF                    		cmp	al,0FFh		; Did an error occur??	
  5520 0000123D 750A                    		jnz	short RENAMEOK
  5521 0000123F F9                      		stc
  5522 00001240 BA[1537]                		mov	dx,RENERRPTR
  5523 00001243 E8330C                  		call	GET_EXT_ERR_NUMBER ; get extended error
  5524 00001246 52                      		push	dx
  5525 00001247 B0FF                    		mov	al,0FFh		; Restore original error state
  5526                                  RENAMEOK:
  5527 00001249 50                      		push	ax
  5528 0000124A E82006                  		call	RESTUDIR
  5529 0000124D 58                      		pop	ax
  5530 0000124E FEC0                    		inc	al
  5531 00001250 7401                    		jz	short RENAME_ERR
  5532                                  RENAME_RETN:
  5533                                  TYPELP_RET:
  5534 00001252 C3                      		retn
  5535                                  RENAME_ERR:
  5536 00001253 5A                      		pop	dx
  5537                                  ERRJ:					; Retro DOS v3.0
  5538 00001254 E8C821                  		call	STD_EPRINTF
  5539 00001257 E9AAEE                  		jmp	TCOMMAND
  5540                                  
  5541                                  ; ---------------------------------------------------------------------------
  5542                                  
  5543                                  ;ERRJ:
  5544                                  ;		jmp	CERROR
  5545                                  
  5546                                  ; ---------------------------------------------------------------------------
  5547                                  
  5548                                  ;TYPELP_RET:
  5549                                  ;		retn
  5550                                  
  5551                                  ; ---------------------------------------------------------------------------
  5552                                  
  5553                                  ;****************************************************************
  5554                                  ;*
  5555                                  ;* ROUTINE:	TYPEFIL - Display the contents of a file to the
  5556                                  ;*		standard output device
  5557                                  ;*
  5558                                  ;* SYNTAX:	TYPE filespec
  5559                                  ;*
  5560                                  ;* FUNCTION:	If a valid filespec is found, read the file until
  5561                                  ;*		1Ah and display the contents to STDOUT.
  5562                                  ;*
  5563                                  ;* INPUT:	command line at offset 81H
  5564                                  ;*
  5565                                  ;* OUTPUT:	none
  5566                                  ;*
  5567                                  ;****************************************************************
  5568                                  
  5569                                  TYPEFIL:
  5570                                  		; MSDOS 6.0	
  5571                                  		;assume	ds:trangroup,es:trangroup
  5572                                  
  5573                                  ;		mov	si,81H
  5574                                  ;		mov	di,offset trangroup:parse_mrdir 
  5575                                  ;					;AN000; Get address of PARSE_MRDIR
  5576                                  ;		xor	cx,cx		;AN000; clear cx,dx
  5577                                  ;		xor	dx,dx		;AN000;
  5578                                  ;		invoke	parse_with_msg	;AC018; call parser
  5579                                  ;		cmp	ax,result_no_error ;AC000; did we have an error?
  5580                                  ;		jnz	typefil_parse_error ;AN000; yes - issue error message
  5581                                  ;
  5582                                  ;		push	si		;AC000; save position in line
  5583                                  ;		lds	si,parse1_addr	;AC000; get address of filespec
  5584                                  ;		invoke	move_to_srcbuf	;AC000; move to srcbuf
  5585                                  ;		pop	si		;AC000; get position back
  5586                                  ;		mov	di,offset trangroup:parse_mrdir 
  5587                                  ;					;AC000; get address of parse_mrdir
  5588                                  ;		invoke	parse_check_eol ;AC000; are we at end of line?
  5589                                  ;		jz	gottarg 	;AC000; yes - continue
  5590                                  ;
  5591                                  ;typefil_parse_error:			;AN000; no - set up error message and exit
  5592                                  ;		jmp	Cerror
  5593                                  ;
  5594                                  ;gottarg:
  5595                                  ;		invoke	setpath
  5596                                  ;		test	[destinfo],00000010b ; Does the filespec contain wildcards
  5597                                  ;		jz	nowilds 	; No, continue processing
  5598                                  ;		mov	dx,offset trangroup:inornot_ptr ; Yes, report error
  5599                                  ;		jmp	Cerror
  5600                                  ;nowilds:
  5601                                  ;		mov	ax,ExtOpen SHL 8 ;AC000; open the file
  5602                                  ;		mov	bx,read_open_mode ;AN000; get open mode for TYPE
  5603                                  ;		xor	cx,cx		;AN000; no special files
  5604                                  ;		mov	dx,read_open_flag ;AN000; set up open flags
  5605                                  ;		mov	si,offset trangroup:srcbuf ;AN030; get file name
  5606                                  ;		int	21h
  5607                                  ;		jnc	typecont	; If open worked, continue. Otherwise load
  5608                                  ;
  5609                                  ;Typerr: 				;AN022;
  5610                                  ;		push	cs		;AN022; make sure we have local segment
  5611                                  ;		pop	ds		;AN022;
  5612                                  ;		invoke	set_ext_error_msg ;AN022;
  5613                                  ;		mov	string_ptr_2,offset trangroup:srcbuf 
  5614                                  ;					;AC022; get address of failed string
  5615                                  ;		mov	Extend_buf_sub,one_subst
  5616                                  ;					;AC022; put number of subst in control block
  5617                                  ;		jmp	cerror		;AC022; exit
  5618                                  ;
  5619                                  ;typecont:
  5620                                  ;		mov	bx,ax		;AC000; get  Handle
  5621                                  ;;M043
  5622                                  ;; We should do the LSEEK for filesize only if this handle belongs to a file
  5623                                  ;;and not if it belongs to a device. If device, set TypeFilSiz+2 to -1 to
  5624                                  ;;indicate it is a device.
  5625                                  ;;
  5626                                  ;		mov	ax,(IOCTL shl 8) or 0
  5627                                  ;		int	21h
  5628                                  ;
  5629                                  ;		test	dl,80h		;is it a device?
  5630                                  ;		jz	not_device	;no, a file
  5631                                  ;
  5632                                  ;		mov	word ptr TypeFilSiz+2,-1 ;indicate it is a device
  5633                                  ;		jmp	short dotype
  5634                                  ;not_device:
  5635                                  ;
  5636                                  ;;SR;
  5637                                  ;; Find the filesize by seeking to the end and then reset file pointer to
  5638                                  ;;start of file
  5639                                  ;;
  5640                                  ;		mov	ax,(LSEEK shl 8) or 2
  5641                                  ;		xor	dx,dx
  5642                                  ;		mov	cx,dx		;seek  to end of file
  5643                                  ;		int	21h
  5644                                  ;
  5645                                  ;		mov	word ptr TypeFilSiz,ax
  5646                                  ;		mov	word ptr TypeFilSiz+2,dx ;store filesize
  5647                                  ;
  5648                                  ;		mov	ax,(LSEEK shl 8) or 0
  5649                                  ;		xor	dx,dx
  5650                                  ;		int	21h	        ;reset file pointer to start
  5651                                  ;dotype:					;M043
  5652                                  ;		mov	zflag,0 	; Reset ^Z flag
  5653                                  ;		mov	ds,[TPA]
  5654                                  ;		xor	dx,dx
  5655                                  ;		;ASSUME	DS:NOTHING
  5656                                  ;
  5657                                  ;typelp:
  5658                                  ;		cmp	cs:[zflag],0	;AC050; Is the ^Z flag set?
  5659                                  ;		retnz			; Yes, return
  5660                                  ;		mov	cx,cs:[bytcnt]	;AC056; No, continue
  5661                                  ;;
  5662                                  ;;Update the filesize left to read
  5663                                  ;;
  5664                                  ;		cmp	word ptr cs:TypeFilSiz+2,-1 ;is it a device? M043
  5665                                  ;		je	typ_read	;yes, just read from it; M043
  5666                                  ;
  5667                                  ;		cmp	word ptr cs:TypeFilSiz+2,0 ;more than 64K left?
  5668                                  ;		jz	lt64k		;no, do word subtraction
  5669                                  ;		sub	word ptr cs:TypeFilSiz,cx
  5670                                  ;		sbb	word ptr cs:TypeFilSiz+2,0 ;update filesize
  5671                                  ;      		jmp	short typ_read	;do the read
  5672                                  ;lt64k:
  5673                                  ;		cmp	cx,word ptr cs:TypeFilSiz ;readsize <= buffer?
  5674                                  ;		jbe	gtbuf		; yes, just update readsize
  5675                                  ;;
  5676                                  ;;Buffer size is larger than bytes to read
  5677                                  ;;
  5678                                  ;		mov	cx,word ptr cs:TypeFilSiz
  5679                                  ;		jcxz	typelp_ret
  5680                                  ;		mov	word ptr cs:TypeFilSiz,0
  5681                                  ;		jmp	short typ_read
  5682                                  ;gtbuf:
  5683                                  ;		sub	word ptr cs:TypeFilSiz,cx ;update filesize remaining
  5684                                  ;typ_read:
  5685                                  ;		mov	ah,read
  5686                                  ;		int	21h		
  5687                                  ;		jnc	@f		;M043
  5688                                  ;		jmp	typerr		;M043
  5689                                  ;@@:					;M043
  5690                                  ;;M043;		jc	typerr		;AN022; Exit if error
  5691                                  ;
  5692                                  ;		mov	cx,ax
  5693                                  ;		jcxz	typelp_ret	;AC000; exit if nothing read
  5694                                  ;		push	ds
  5695                                  ;		pop	es		; Check to see if a ^Z was read.
  5696                                  ;		;assume es:nothing
  5697                                  ;		xor	di,di
  5698                                  ;		push	ax
  5699                                  ;		mov	al,1ah
  5700                                  ;		repnz	scasb
  5701                                  ;		pop	ax
  5702                                  ;		xchg	ax,cx
  5703                                  ;		cmp	ax,0
  5704                                  ;		jnz	foundz		; Yes, handle it
  5705                                  ;		cmp	byte ptr [di-1],1ah ; No, double check
  5706                                  ;		jnz	typecont2	; No ^Z, continue
  5707                                  ;
  5708                                  ;foundz:
  5709                                  ;		sub	cx,ax		; Otherwise change cx so that only those
  5710                                  ;		dec	cx		;  bytes up to but NOT including the ^Z
  5711                                  ;		push	cs		;  will be typed.
  5712                                  ;		pop	es
  5713                                  ;		;assume es:trangroup
  5714                                  ;		not	zflag		; Turn on ^Z flag so that the routine
  5715                                  ;typecont2:				;  will quit after this write.
  5716                                  ;		push	bx
  5717                                  ;		mov	bx,1
  5718                                  ;		mov	ah,write
  5719                                  ;		int	21h
  5720                                  ;		pop	bx
  5721                                  ;		jc	Error_outputj
  5722                                  ;		cmp	ax,cx
  5723                                  ;		jnz	@f		;M043
  5724                                  ;		jmp	typelp		;M043
  5725                                  ;@@:					;M043
  5726                                  ;;M043;		jz	typelp
  5727                                  ;		dec	cx
  5728                                  ;		cmp	ax,cx
  5729                                  ;		retz			; One less byte OK (^Z)
  5730                                  ;Error_outputj:
  5731                                  ;		mov	bx,1
  5732                                  ;		mov	ax,IOCTL SHL 8
  5733                                  ;		int	21h
  5734                                  ;		test	dl,devid_ISDEV
  5735                                  ;		retnz			; If device, no error message
  5736                                  ;		jmp	error_output
  5737                                  ;typelp_ret:
  5738                                  ;		ret
  5739                                  
  5740                                  		; MSDOS 3.3
  5741 0000125A BE8100                  		mov	si,81h
  5742 0000125D E8E606                  		call	SCANOFF		; Skip to first non-delim
  5743 00001260 3C0D                    		cmp	al,0Dh
  5744 00001262 7505                    		jnz	short GOTTARG
  5745 00001264 BA[9D3C]                		mov	dx,BADARGSPTR
  5746                                  
  5747                                  		;jmp	CERROR
  5748 00001267 EBEB                    		jmp	short ERRJ	; No args
  5749                                  GOTTARG:
  5750 00001269 E8BC0A                  		call	SETPATH
  5751 0000126C F606[8043]02            		test	byte [DESTINFO],2
  5752 00001271 7405                    		jz	short NOWILDS
  5753 00001273 BA[1738]                		mov	dx,INORNOTPTR
  5754                                  
  5755                                  		;jmp	CERROR
  5756 00001276 EBDC                    		jmp	short ERRJ
  5757                                  NOWILDS:
  5758 00001278 B8003D                  		mov	ax,OPEN*256 ; 3D00h
  5759 0000127B CD21                    		int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
  5760                                  				; DS:DX	-> ASCIZ filename
  5761                                  				; AL = access mode
  5762                                  				; 0 - read
  5763 0000127D 7311                    		jnc	short TYPECONT
  5764 0000127F BA[2837]                		mov	dx,FNOTFOUNDPTR
  5765 00001282 83F802                  		cmp	ax,2
  5766 00001285 74CD                    		jz	short ERRJ
  5767 00001287 BA[7C3C]                		mov	dx,BADCPMESPTR
  5768 0000128A F9                      		stc
  5769 0000128B E8EB0B                  		call	GET_EXT_ERR_NUMBER
  5770                                  
  5771                                  		;jmp	CERROR
  5772 0000128E EBC4                    		jmp	short ERRJ
  5773                                  TYPECONT:
  5774 00001290 C606[074B]00            		mov	byte [ZFLAG],0	; Reset ^Z flag
  5775 00001295 89C3                    		mov	bx,ax		; Handle
  5776 00001297 8E1E[8341]              		mov	ds,[TPA]
  5777 0000129B 31D2                    		xor	dx,dx
  5778                                  TYPELP:
  5779 0000129D 2E803E[074B]00          		cmp	byte [cs:ZFLAG],0 ; Is the ^Z flag set?		
  5780 000012A3 75AD                    		jnz	short RENAME_RETN ; Yes, return	
  5781 000012A5 2E8B0E[A241]            		mov	cx,[cs:BYTCNT]	; No, continue
  5782 000012AA B43F                    		mov	ah,READ ; 3Fh
  5783 000012AC CD21                    		int	21h	; DOS -	2+ - READ FROM FILE WITH HANDLE
  5784                                  				; BX = file handle,CX = number	of bytes to read
  5785                                  				; DS:DX	-> buffer
  5786 000012AE 89C1                    		mov	cx,ax
  5787 000012B0 E3A0                    		jcxz	TYPELP_RET	; exit if nothing read
  5788                                  					; Check to see if a ^Z was read.
  5789 000012B2 1E                      		push	ds
  5790 000012B3 07                      		pop	es		
  5791 000012B4 31FF                    		xor	di,di
  5792 000012B6 50                      		push	ax
  5793 000012B7 B01A                    		mov	al,1Ah
  5794 000012B9 F2AE                    		repne scasb
  5795 000012BB 58                      		pop	ax
  5796 000012BC 91                      		xchg	ax,cx
  5797 000012BD 83F800                  		cmp	ax,0
  5798 000012C0 7506                    		jnz	short FOUNDZ	; Yes, handle it
  5799 000012C2 807DFF1A                		cmp	byte [di-1],1Ah	; No, double check
  5800 000012C6 750A                    		jnz	short TYPECONT2	; No ^Z, continue
  5801                                  FOUNDZ:
  5802 000012C8 29C1                    		sub	cx,ax		; Otherwise change cx so that only those
  5803 000012CA 49                      		dec	cx		;  bytes up to but NOT including the ^Z
  5804 000012CB 0E                      		push	cs		;  will be typed.
  5805 000012CC 07                      		pop	es
  5806 000012CD 2EF616[074B]            		not	byte [cs:ZFLAG]	; Turn on ^Z flag so that the routine
  5807                                  					;  will quit after this write.
  5808                                  TYPECONT2:
  5809 000012D2 53                      		push	bx
  5810 000012D3 BB0100                  		mov	bx,1
  5811 000012D6 B440                    		mov	ah,WRITE ; 40h
  5812 000012D8 CD21                    		int	21h	; DOS -	2+ - WRITE TO FILE WITH	HANDLE
  5813                                  				; BX = file handle, CX = number of bytes to write,
  5814                                  				; DS:DX -> buffer
  5815 000012DA 5B                      		pop	bx
  5816 000012DB 720A                    		jc	short ERROR_OUTPUTJ
  5817 000012DD 39C8                    		cmp	ax,cx
  5818 000012DF 74BC                    		jz	short TYPELP
  5819 000012E1 49                      		dec	cx
  5820 000012E2 39C8                    		cmp	ax,cx		; One less byte OK (^Z)
  5821 000012E4 7501                    		jnz	short ERROR_OUTPUTJ
  5822                                  TYPEFIL_RETN:
  5823 000012E6 C3                      		retn
  5824                                  ERROR_OUTPUTJ:
  5825 000012E7 BB0100                  		mov	bx,1
  5826 000012EA B80044                  		mov	ax,IOCTL*256 ; 4400h
  5827 000012ED CD21                    		int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
  5828                                  				; BX = file or device handle
  5829                                  		;test	dl,devid_ISDEV
  5830 000012EF F6C280                  		test	dl,80h
  5831 000012F2 75F2                    		jnz	short TYPEFIL_RETN ; If device, no error message
  5832 000012F4 E9C706                  		jmp	ERROR_OUTPUT
  5833                                  
  5834                                  ; ---------------------------------------------------------------------------
  5835                                  
  5836                                  ; VOLUME command displays the volume ID on the specified drive
  5837                                  
  5838                                  VOLUME:
  5839                                  		; MSDOS 6.0
  5840                                  		;mov	si,81H
  5841                                  		;mov	di,offset trangroup:parse_vol
  5842                                  		;			;AN000; Get address of PARSE_VOL
  5843                                  		;xor	cx,cx		;AN000; clear cx,dx
  5844                                  		;xor	dx,dx		;AN000;
  5845                                  		;invoke	parse_with_msg	;AC018; call parser
  5846                                  		;cmp	ax,end_of_line	;AC000; are we at end of line?
  5847                                  		;jz	OkVolArg	;AC000; Yes, display default volume ID
  5848                                  		;cmp	ax,result_no_error ;AC000; did we have an error?
  5849                                  		;jnz	BadVolArg	;AC000; Yes, fail.
  5850                                  
  5851                                  ; We have parsed off the drive. See if there are any more chars left
  5852                                  
  5853                                  		;mov	di,offset trangroup:parse_vol	
  5854                                  					;AC000; get address of parse_vol
  5855                                  		;xor	dx,dx		;AC000;
  5856                                  		;invoke	parse_check_eol ;AC000; call parser
  5857                                  		;jz	OkVolArg	;AC000; yes, end of road
  5858                                  
  5859                                  ; The line was not interpretable. Report an error.
  5860                                  
  5861                                  ;badvolarg:
  5862                                  		;jmp	Cerror
  5863                                  
  5864                                  		; MSDOS 3.3
  5865 000012F7 BE8100                  		mov	si,81h
  5866 000012FA E84906                  		call	SCANOFF		; Skip to first non-delim
  5867                                  		;mov	ah,[5Ch]
  5868 000012FD 8A265C00                		mov	ah,[FCB]
  5869                                  		;mov	byte [5Ch],0
  5870 00001301 C6065C0000              		mov	byte [FCB],0
  5871 00001306 3C0D                    		cmp	al,0Dh		; are we at end of line?
  5872 00001308 7417                    		jz	short OKVOLARG	; Yes, display default volume ID
  5873                                  		;mov	[5Ch],ah
  5874 0000130A 88265C00                		mov	[FCB],ah
  5875 0000130E AC                      		lodsb
  5876 0000130F AC                      		lodsb
  5877 00001310 3C3A                    		cmp	al,':'
  5878 00001312 7507                    		jnz	short VOLUME_ERR
  5879 00001314 E82F06                  		call	SCANOFF
  5880 00001317 3C0D                    		cmp	al,0Dh
  5881 00001319 7406                    		jz	short OKVOLARG
  5882                                  VOLUME_ERR:
  5883 0000131B BA[7938]                		mov	dx,BADDRVPTR
  5884 0000131E E9C908                  		jmp	CERROR
  5885                                  
  5886                                  ; ---------------------------------------------------------------------------
  5887                                  
  5888                                  OKVOLARG:
  5889 00001321 E81506                  		call	CRLF2
  5890 00001324 1E                      		push	ds
  5891 00001325 07                      		pop	es
  5892                                  		;mov	di,55h
  5893 00001326 BF5500                  		mov	di,FCB-7	; Set up extended FCB
  5894 00001329 B0FF                    		mov	al,-1
  5895 0000132B AA                      		stosb
  5896 0000132C 31C0                    		xor	ax,ax
  5897 0000132E AB                      		stosw
  5898 0000132F AB                      		stosw
  5899 00001330 AA                      		stosb
  5900 00001331 B008                    		mov	al,8		; Look for volume label
  5901 00001333 AA                      		stosb
  5902 00001334 47                      		inc	di		; Skip drive byte
  5903 00001335 B90B00                  		mov	cx,11
  5904 00001338 B03F                    		mov	al,'?'
  5905 0000133A F3AA                    		rep stosb
  5906 0000133C BA[7A42]                		mov	dx,DIRBUF
  5907 0000133F B41A                    		mov	ah,SET_DMA ; 1Ah
  5908 00001341 CD21                    		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
  5909                                  				; DS:DX	-> disk	transfer buffer
  5910                                  		;mov	dx,55h
  5911 00001343 BA5500                  		mov	dx,FCB-7
  5912 00001346 B411                    		mov	ah,DIR_SEARCH_FIRST ; 11h
  5913 00001348 CD21                    		int	21h	; DOS -	SEARCH FIRST USING FCB
  5914                                  				; DS:DX	-> FCB
  5915 0000134A E98E15                  		jmp	PRINTVOL
  5916                                  
  5917                                  ;============================================================================
  5918                                  ; TCMD2A.ASM, MSDOS 6.0, 1991
  5919                                  ;============================================================================
  5920                                  ; 08/10/2018 - Retro DOS v3.0
  5921                                  
  5922                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1379h
  5923                                  
  5924                                  ; ---------------------------------------------------------------------------
  5925                                  
  5926                                  ; MSDOS 6.0
  5927                                  ;***	Version - display DOS version
  5928                                  ;
  5929                                  ;	SYNTAX	ver [/debug]
  5930                                  ;
  5931                                  ;		/debug - display additional DOS configuration info
  5932                                  ;
  5933                                  ;	ENTRY	command-line tail is in PSP
  5934                                  ;
  5935                                  ;	EXIT	if successful, nothing
  5936                                  ;		if parse fails,
  5937                                  ;		  parse error message is set up (for Std_EPrintf)
  5938                                  ;		    AX = system parser error code
  5939                                  ;		    DX = ptr to message block
  5940                                  ;		  we jump to CError
  5941                                  ;
  5942                                  ;	EFFECTS
  5943                                  ;	  If parse fails, a parse error message is displayed.
  5944                                  ;	  Otherwise, version message is displayed.
  5945                                  ;	  If /debug is specified, additional DOS info is displayed.
  5946                                  
  5947                                  ;	assume	ds:TRANGROUP,es:TRANGROUP
  5948                                  ;
  5949                                  ;;	Parse command line for /debug switch.
  5950                                  ;
  5951                                  ;	mov	si,81h				; DS:SI = ptr to command tail
  5952                                  ;	mov	di,offset TRANGROUP:Parse_Ver	; ES:DI = ptr to parse block
  5953                                  ;	xor	cx,cx				; CX = # positional param's found
  5954                                  ;	invoke	Parse_With_Msg
  5955                                  ;
  5956                                  ;	mov	bl,1			; BL = flag = /debug present
  5957                                  ;	cmp	ax,RESULT_NO_ERROR
  5958                                  ;	je	verPrintVer		; something parsed - must be /debug
  5959                                  ;	dec	bl			; BL = flag = no /debug present
  5960                                  ;	cmp	ax,END_OF_LINE
  5961                                  ;	je	verPrintVer		; reached end of line - ok
  5962                                  ;
  5963                                  ;;	The parse failed.  Error message has been set up.
  5964                                  ;
  5965                                  ;	jmp	CError
  5966                                  ;
  5967                                  ;verPrintVer:
  5968                                  ;	push	bx			; save /debug flag
  5969                                  ;	call	Crlf2
  5970                                  ;	call	Print_Version
  5971                                  ;	call	Crlf2
  5972                                  ;	pop	bx   			; BL = /debug flag
  5973                                  ;	or	bl,bl
  5974                                  ;	jz	verDone			; /debug is false - we're done
  5975                                  ;
  5976                                  ;;*	For /debug, display DOS internal revision and DOS location
  5977                                  ;;	(low memory, HMA, or ROM).
  5978                                  ;
  5979                                  ;;	Bugbug:	use symbols for bitmasks below.
  5980                                  ;
  5981                                  ;	mov	ax,(SET_CTRL_C_TRAPPING shl 8) + 6 ; M013
  5982                                  ;	int	21h
  5983                                  ;	mov	al,dl			;revision number in dl; M013
  5984                                  ;	mov	bh,dh			;flags in dh now; M013
  5985                                  ;;M032	and	al,7			; AL = DOS internal revision
  5986                                  ;	cmp	al,'Z'-'A'	;M032	; revision in A-to-Z range?
  5987                                  ;	jbe	@f		;M032	; A-to-Z revision ok
  5988                                  ;	mov	al,'*'-'A'	;M032	; beyond Z, just say revision *
  5989                                  ;@@:	add	al,'A'			; AL = DOS internal rev letter
  5990                                  ;	mov	One_Char_Val,al
  5991                                  ;	mov	dx,offset TRANGROUP:DosRev_Ptr
  5992                                  ;	invoke	Std_Printf		; print DOS internal revision
  5993                                  ;
  5994                                  ;	mov	cl,4
  5995                                  ;	shr	bh,cl			; CY = DOS in ROM
  5996                                  ;	jc	verRom
  5997                                  ;	shr	bh,1			; CY = DOS in HMA
  5998                                  ;	jc	verHma
  5999                                  ;
  6000                                  ;;	DOS isn't in ROM or HMA, so it must be in lower memory.
  6001                                  ;
  6002                                  ;	mov	dx,offset TRANGROUP:DosLow_Ptr
  6003                                  ;	jmp	short verPrintLoc
  6004                                  ;verRom: mov	dx,offset TRANGROUP:DosRom_Ptr
  6005                                  ;	jmp	short verPrintLoc
  6006                                  ;verHma: mov	dx,offset TRANGROUP:DosHma_Ptr
  6007                                  ;verPrintLoc:
  6008                                  ;	invoke	Std_Printf
  6009                                  ;verDone:
  6010                                  ;	jmp	Crlf2
  6011                                  
  6012                                  		; MSDOS 3.3
  6013                                  VERSION:
  6014 0000134D E8E905                  		call	CRLF2
  6015 00001350 E80300                  		call	PRINT_VERSION
  6016 00001353 E9E305                  		jmp	CRLF2
  6017                                  
  6018                                  ; =============== S U B	R O U T	I N E =======================================
  6019                                  
  6020                                  PRINT_VERSION:
  6021 00001356 B430                    		mov	ah,GET_VERSION ; 30h
  6022 00001358 CD21                    		int	21h	; DOS -	GET DOS	VERSION
  6023                                  				; Return: AL = major version number (00h for DOS 1.x)
  6024 0000135A 50                      		push	ax
  6025 0000135B 30E4                    		xor	ah,ah
  6026 0000135D A3[6D43]                		mov	[MAJOR_VER_NUM],ax
  6027 00001360 58                      		pop	ax
  6028 00001361 86E0                    		xchg	ah,al
  6029 00001363 30E4                    		xor	ah,ah
  6030 00001365 A3[6F43]                		mov	[MINOR_VER_NUM],ax
  6031 00001368 BA[573A]                		mov	dx,VERMESPTR
  6032 0000136B E9BA20                  		jmp	STD_PRINTF
  6033                                  
  6034                                  ; =============== S U B	R O U T	I N E =======================================
  6035                                  
  6036                                  PRINT_PROMPT:
  6037 0000136E 1E                      		push	ds
  6038 0000136F 0E                      		push	cs
  6039 00001370 1F                      		pop	ds		; Make sure Ds is in TRANGROUP
  6040 00001371 06                      		push	es
  6041 00001372 E8F503                  		call	FIND_PROMPT	; Look for prompt string
  6042 00001375 7206                    		jc	short PP0	; Can't find one	
  6043 00001377 26803D00                		cmp	byte [es:di],0
  6044 0000137B 750A                    		jnz	short PP1
  6045                                  PP0:					; Use default prompt
  6046 0000137D E86D00                  		call	PRINT_DRIVE
  6047                                  		;mov	al,'>'
  6048 00001380 B03E                    		mov	al,SYM
  6049 00001382 E85500                  		call	PRINT_CHAR
  6050 00001385 EB38                    		jmp	short PP5
  6051                                  PP1:
  6052 00001387 268A05                  		mov	al,[es:di]	; Get a char
  6053 0000138A 47                      		inc	di
  6054 0000138B 08C0                    		or	al,al
  6055 0000138D 7430                    		jz	short PP5	; Nul terminated
  6056                                  		;cmp	al,[DOLLAR]	; Meta character
  6057                                  		; 01/03/2023
  6058 0000138F 3C24                    		cmp	al,dollar ; '$'
  6059 00001391 7405                    		jz	short PP2	; Nope
  6060 00001393 E84400                  		call	PRINT_CHAR
  6061 00001396 EBEF                    		jmp	short PP1
  6062                                  PP2:
  6063 00001398 268A05                  		mov	al,[es:di]
  6064 0000139B 47                      		inc	di
  6065                                  		;mov	bx,CLSSTRING+2	; "[2J"
  6066 0000139C BB[CC3C]                		mov	bx,PROMPT_TABLE-3
  6067 0000139F 08C0                    		or	al,al
  6068 000013A1 741C                    		jz	short PP5
  6069                                  PP3:
  6070 000013A3 83C303                  		add	bx,3
  6071                                  		;call	UPCONV
  6072 000013A6 E84B04                  		call	UPCONV_MAPCALL
  6073 000013A9 3A07                    		cmp	al,[bx]
  6074 000013AB 7407                    		jz	short PP4
  6075 000013AD 803F00                  		cmp	byte [bx],0
  6076 000013B0 75F1                    		jnz	short PP3
  6077 000013B2 EBD3                    		jmp	short PP1
  6078                                  PP4:
  6079 000013B4 06                      		push	es
  6080 000013B5 57                      		push	di
  6081 000013B6 0E                      		push	cs
  6082 000013B7 07                      		pop	es
  6083 000013B8 FF5701                  		call	word [bx+1]
  6084 000013BB 5F                      		pop	di
  6085 000013BC 07                      		pop	es
  6086 000013BD EBC8                    		jmp	short PP1
  6087                                  PP5:
  6088 000013BF 07                      		pop	es		; Restore segments
  6089 000013C0 1F                      		pop	ds
  6090 000013C1 C3                      		retn
  6091                                  
  6092                                  ; ---------------------------------------------------------------------------
  6093                                  
  6094                                  PRINT_BACK:
  6095 000013C2 BA[C43C]                		mov	dx,DBACKPTR
  6096 000013C5 E96020                  		jmp	STD_PRINTF
  6097                                  
  6098                                  ; ---------------------------------------------------------------------------
  6099                                  
  6100                                  PRINT_EQ:
  6101 000013C8 B03D                    		mov	al,'='
  6102 000013CA EB0E                    		jmp	short PRINT_CHAR
  6103                                  
  6104                                  ; ---------------------------------------------------------------------------
  6105                                  
  6106                                  PRINT_ESC:
  6107 000013CC B01B                    		mov	al,1Bh
  6108 000013CE EB0A                    		jmp	short PRINT_CHAR
  6109                                  
  6110                                  ; ---------------------------------------------------------------------------
  6111                                  
  6112                                  PRINT_G:
  6113                                  		;mov	al,[RABRACKET]
  6114                                  		; 01/03/2023
  6115 000013D0 B03E                    		mov	al,rabracket  ; '>'
  6116 000013D2 EB06                    		jmp	short PRINT_CHAR
  6117                                  
  6118                                  ; ---------------------------------------------------------------------------
  6119                                  
  6120                                  PRINT_L:
  6121                                  		;mov	al,[LABRACKET]
  6122                                  		; 01/03/2023
  6123 000013D4 B03C                    		mov	al,labracket ; '<'
  6124 000013D6 EB02                    		jmp	short PRINT_CHAR
  6125                                  
  6126                                  ; ---------------------------------------------------------------------------
  6127                                  
  6128                                  PRINT_B:
  6129                                  		;mov	al,[VBAR]
  6130                                  		; 01/03/2023
  6131                                  		;mov	al,vbar
  6132                                  		;mov	al,'|'
  6133 000013D8 B07C                    		mov	al,ALTPIPECHR ; '|'
  6134                                  
  6135                                  ; =============== S U B	R O U T	I N E =======================================
  6136                                  
  6137                                  PRINT_CHAR:
  6138                                  		; MSDOS 6.0
  6139                                  
  6140                                  ;	Bugbug:	Why bother with ds,es here?
  6141                                  		
  6142                                  		;push	es
  6143                                  		;push	ds
  6144                                  		;pop	es
  6145                                  		;push	di
  6146                                  		;push	dx
  6147                                  		;mov	dl,al		;AC000; Get char into al
  6148                                  		;mov	ah,STD_CON_OUTPUT ;AC000; print the char to stdout
  6149                                  		;int	21h		;AC000;
  6150                                  		;pop	dx
  6151                                  		;pop	di
  6152                                  		;pop	es
  6153                                  		;retn
  6154                                  
  6155                                  		; MSDOS 3.3
  6156 000013DA 06                      		push	es
  6157 000013DB 1E                      		push	ds
  6158 000013DC 07                      		pop	es
  6159 000013DD 57                      		push	di
  6160 000013DE 52                      		push	dx
  6161 000013DF BF[7143]                		mov	di,ONE_CHAR_VAL	
  6162 000013E2 AA                      		stosb
  6163 000013E3 BA[603A]                		mov	dx,ONECHRVALPTR
  6164 000013E6 E83F20                  		call	STD_PRINTF
  6165 000013E9 5A                      		pop	dx
  6166 000013EA 5F                      		pop	di
  6167 000013EB 07                      		pop	es
  6168 000013EC C3                      		retn
  6169                                  
  6170                                  ; ---------------------------------------------------------------------------
  6171                                  
  6172                                  PRINT_DRIVE:
  6173 000013ED B419                    		mov	ah,GET_DEFAULT_DRIVE ; 19h
  6174 000013EF CD21                    		int	21h	; DOS -	GET DEFAULT DISK NUMBER
  6175                                  		;add	al,'A'
  6176                                  		;add	al,[CAPITAL_A]
  6177                                  		; 01/03/2023
  6178 000013F1 0441                    		add	al,capital_A  ; add al,'A'
  6179                                  		;call	PRINT_CHAR
  6180                                  		;retn
  6181                                  		; 01/03/2023
  6182 000013F3 EBE5                    		jmp	PRINT_CHAR	
  6183                                  
  6184                                  ; ---------------------------------------------------------------------------
  6185                                  
  6186                                  BUILD_DIR_FOR_PROMPT:
  6187 000013F5 30D2                    		xor	dl,dl
  6188 000013F7 BE[7A42]                		mov	si,BWDBUF
  6189 000013FA 89F7                    		mov	di,si
  6190 000013FC A0[9541]                		mov	al,[CURDRV]
  6191 000013FF 0441                    		add	al,'A'
  6192 00001401 B43A                    		mov	ah,':'
  6193 00001403 AB                      		stosw
  6194 00001404 A0[8641]                		mov	al,[DIRCHAR]
  6195 00001407 AA                      		stosb
  6196 00001408 87F7                    		xchg	si,di
  6197 0000140A 893E[5E43]              		mov	[STRING_PTR_2],di
  6198 0000140E B447                    		mov	ah,CURRENT_DIR ; 47h
  6199 00001410 CD21                    		int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
  6200                                  				; DL = drive (0=default,1=A,etc.)
  6201                                  				; DS:SI	points to 64-byte buffer area
  6202 00001412 BA[6F36]                		mov	dx,STRINGBUF2PTR
  6203 00001415 7303                    		jnc	short DOPRINT
  6204 00001417 BA[1B39]                		mov	dx,BADCURDRVPTR
  6205                                  DOPRINT:
  6206                                  		;call	STD_PRINTF
  6207                                  		;retn
  6208                                  		; 01/03/2023
  6209 0000141A E90B20                  		jmp	STD_PRINTF
  6210                                  
  6211                                  ; =============== S U B	R O U T	I N E =======================================
  6212                                  
  6213                                  BUILD_DIR_FOR_CHDIR:
  6214 0000141D E80D00                  		call	BUILD_DIR_STRING
  6215 00001420 BA[7A42]                		mov	dx,DIRBUF
  6216 00001423 8916[5E43]              		mov	[STRING_PTR_2],dx
  6217                                  		;mov	dx,offset trangroup:string_buf_ptr  ; MSDOS 6.0
  6218 00001427 BA[6F36]                		mov	dx,STRINGBUF2PTR
  6219                                  		;call	STD_PRINTF
  6220                                  		;retn
  6221                                  		; 01/03/2023
  6222 0000142A E9FB1F                  		jmp	STD_PRINTF
  6223                                  
  6224                                  
  6225                                  ; =============== S U B	R O U T	I N E =======================================
  6226                                  
  6227                                  BUILD_DIR_STRING:
  6228 0000142D 8A165C00                		mov	dl,[FCB] ; mov dl,[5Ch]
  6229 00001431 88D0                    		mov	al,dl
  6230 00001433 0440                    		add	al,'@'
  6231 00001435 3C40                    		cmp	al,'@'
  6232 00001437 7506                    		jnz	short GOTDRIVE
  6233 00001439 0206[9541]              		add	al,[CURDRV]
  6234 0000143D FEC0                    		inc	al
  6235                                  GOTDRIVE:
  6236 0000143F 50                      		push	ax
  6237 00001440 BE[7D42]                		mov	si,BWDBUF+3
  6238 00001443 B447                    		mov	ah,CURRENT_DIR ; 47h
  6239 00001445 CD21                    		int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
  6240                                  				; DL = drive (0=default,1=A,etc.)
  6241                                  				; DS:SI	points to 64-byte buffer area
  6242 00001447 7305                    		jnc	short DPBISOK
  6243 00001449 0E                      		push	cs
  6244 0000144A 1F                      		pop	ds
  6245 0000144B E95506                  		jmp	DRVBAD
  6246                                  DPBISOK:
  6247 0000144E BF[7A42]                		mov	di,BWDBUF
  6248 00001451 89FA                    		mov	dx,di
  6249 00001453 58                      		pop	ax
  6250 00001454 B43A                    		mov	ah,':'
  6251 00001456 AB                      		stosw
  6252 00001457 A0[8641]                		mov	al,[DIRCHAR]
  6253 0000145A AA                      		stosb
  6254 0000145B C3                      		retn
  6255                                  
  6256                                  ; ---------------------------------------------------------------------------
  6257                                  
  6258                                  PATH:
  6259                                  		; MSDOS 6.0
  6260                                  		;xor	al,al		;AN049; Set up holding buffer
  6261                                  		;mov	di,offset Trangroup:srcxname
  6262                                  					;AN049;   for PATH while parsing
  6263                                  		;stosb				;AN049; Initialize PATH to null
  6264                                  		;dec	di			;AN049; point to the start of buffer
  6265                                  		;invoke	PGetarg 		; Pre scan for arguments
  6266                                  		;jz	disppath		; Print the current path
  6267                                  		;cmp	al,semicolon		;AC049; NUL path argument?
  6268                                  		;jnz	pathslp 		;AC049;
  6269                                  		;inc	si			;AN049; point past semicolon
  6270                                  		;jmp	short scan_white	;AC049; Yes - make sure nothing else on line
  6271                                  ;pathslp:					; Get the user specified path
  6272                                  		;lodsb				; Get a character
  6273                                  		;cmp	al,end_of_line_in	;AC049; Is it end of line?
  6274                                  		;jz	path_eol		;AC049; yes - end of command
  6275                                  		;invoke	testkanj		;See if DBCS
  6276                                  		;jz	notkanj2		;No - continue
  6277                                  		;stosb				;AC049; Yes - store the first byte
  6278                                  		;lodsb				;skip second byte of DBCS
  6279                                  ;path_hold:					;AN049;
  6280                                  		;stosb				;AC049; Store a byte in the PATH buffer
  6281                                  		;jmp	short pathslp		;continue parsing
  6282                                  ;notkanj2:
  6283                                  		;invoke	upconv			;upper case the character
  6284                                  		;cmp	al,semicolon		;AC049; ';' not a delimiter on PATH
  6285                                  		;jz	path_hold		;AC049; go store it
  6286                                  		;invoke	delim			;delimiter?
  6287                                  		;jnz	path_hold		;AC049; no - go store character
  6288                                  ;scan_white:					;AN049; make sure were at EOL
  6289                                  		;lodsb				;AN049; get a character
  6290                                  		;cmp	al,end_of_line_in	;AN049; end of line?
  6291                                  		;jz	path_eol		;AN049; yes - go set path
  6292                                  		;cmp	al,blank		;AN049; whitespace?
  6293                                  		;jz	scan_white		;AN049; yes - continue scanning
  6294                                  		;cmp	al,tab_chr		;AN049; whitespace?
  6295                                  		;jz	scan_white		;AN049; yes - continue scanning
  6296                                  
  6297                                  		;mov	dx,offset TranGroup:Extend_Buf_ptr 
  6298                                  						;AN049; no - set up error message
  6299                                  		;mov	Extend_Buf_ptr,MoreArgs_ptr
  6300                                  						;AN049; get "Too many parameters" message number
  6301                                  		;mov	msg_disp_class,parse_msg_class
  6302                                  						;AN049; set up parse error msg class
  6303                                  		;jmp	cerror			;AN049;
  6304                                  ;path_eol:					;AN049; Parsing was clean
  6305                                  		;xor	al,al			;AN049; null terminate the PATH
  6306                                  		;stosb				;AN049;    buffer
  6307                                  		;invoke	find_path		;AN049; Find PATH in environment
  6308                                  		;invoke	delete_path		;AC049; Delete any offending name
  6309                                  		;invoke	scan_double_null	;AC049; Scan to end of environment
  6310                                  		;invoke	move_name		;AC049; move in PATH=
  6311                                  		;mov	si,offset Trangroup:srcxname	
  6312                                  						;AN049; Set up source as PATH buffer
  6313                                  ;store_path:					;AN049; Store the PATH in the environment
  6314                                  		;lodsb				;AN049; Get a character
  6315                                  		;cmp	al,end_of_line_out	;AN049; null character?
  6316                                  		;jz	got_paths		;AN049; yes - exit
  6317                                  		;invoke	store_char		;AN049; no - store character
  6318                                  		;jmp	short store_path	;AN049; continue
  6319                                  ;got_paths:					;AN049; we're finished
  6320                                  		;xor	ax,ax			;	null terminate the PATH in
  6321                                  		;stosw				;    	the environment
  6322                                  		;return
  6323                                  ;disppath:
  6324                                  		;invoke	find_path		;AN049;
  6325                                  		;call	print_path
  6326                                  		;call	crlf2
  6327                                  		;retn
  6328                                  
  6329                                  		; MSDOS 3.3
  6330 0000145C E80603                  		call	FIND_PATH		; Find PATH in environment
  6331 0000145F E83809                  		call	PGETARG			; Pre scan for arguments
  6332 00001462 742A                    		jz	short DISPPATH		; Print the current path
  6333 00001464 E8DC02                  		call	DELETE_PATH		; Delete any offending name
  6334 00001467 E86803                  		call	SCAN_DOUBLE_NULL	; Scan to end of environment	
  6335 0000146A E84603                  		call	MOVE_NAME		; Move in PATH=
  6336 0000146D E82A09                  		call	PGETARG
  6337 00001470 3C3B                    		cmp	al,';'
  6338 00001472 7416                    		jz	short GOTPATHS
  6339                                  PATHSLP:
  6340 00001474 AC                      		lodsb
  6341 00001475 3C0D                    		cmp	al,0Dh			; End of line (CR) ?		
  6342 00001477 7411                    		jz	short GOTPATHS		; yes - exit
  6343                                  		;call	UPCONV
  6344 00001479 E87803                  		call	UPCONV_MAPCALL		; convert to uppercase
  6345 0000147C 3C3B                    		cmp	al,';'			; ';' not a delimiter on PATH
  6346 0000147E 7405                    		jz	short NOTDELIM		; go set path
  6347 00001480 E8CB04                  		call	DELIM			; is it delim/null char ?
  6348 00001483 7405                    		jz	short GOTPATHS		; yes - exit
  6349                                  NOTDELIM:
  6350 00001485 E87C03                  		call	STORE_CHAR		; no - store character
  6351 00001488 EBEA                    		jmp	short PATHSLP
  6352                                  GOTPATHS:
  6353 0000148A 31C0                    		xor	ax,ax			; null terminate the PATH
  6354 0000148C AB                      		stosw				; in the environment
  6355 0000148D C3                      		retn
  6356                                  DISPPATH:
  6357 0000148E E80300                  		call	PRINT_PATH
  6358                                  		;call	CRLF2
  6359                                  		;retn
  6360                                  		; 02/03/2023
  6361 00001491 E9A504                  		jmp	CRLF2
  6362                                  
  6363                                  ; =============== S U B	R O U T	I N E =======================================
  6364                                  
  6365                                  PRINT_PATH:
  6366 00001494 26803D00                		cmp	byte [es:di],0
  6367 00001498 750A                    		jnz	short PATH1
  6368                                  PATH0:
  6369 0000149A BA[3B3B]                		mov	dx,NULLPATHPTR
  6370 0000149D 0E                      		push	cs
  6371 0000149E 07                      		pop	es
  6372 0000149F 0E                      		push	cs
  6373 000014A0 1F                      		pop	ds
  6374 000014A1 E9841F                  		jmp	STD_PRINTF
  6375                                  PATH1:
  6376 000014A4 06                      		push	es
  6377 000014A5 1F                      		pop	ds
  6378 000014A6 83EF05                  		sub	di,5
  6379 000014A9 89FE                    		mov	si,di
  6380 000014AB E83E03                  		call	SCASB2		; Look for null
  6381 000014AE 81F9FF00                		cmp	cx,0FFh
  6382 000014B2 74E6                    		jz	short PATH0
  6383 000014B4 0E                      		push	cs
  6384 000014B5 07                      		pop	es
  6385 000014B6 BF[D842]                		mov	di,ARG_BUF
  6386 000014B9 BA0001                  		mov	dx,100h
  6387 000014BC 29CA                    		sub	dx,cx
  6388 000014BE 87D1                    		xchg	dx,cx
  6389 000014C0 F3A4                    		rep movsb
  6390 000014C2 BA[5336]                		mov	dx,ARG_BUF_PTR
  6391 000014C5 0E                      		push	cs
  6392 000014C6 1F                      		pop	ds
  6393 000014C7 E95E1F                  		jmp	STD_PRINTF
  6394                                  
  6395                                  ; ---------------------------------------------------------------------------
  6396                                  
  6397                                  ; ****************************************************************
  6398                                  ; *
  6399                                  ; * ROUTINE:	 CLS
  6400                                  ; *
  6401                                  ; * FUNCTION:	 Clear the screen using INT 10h. If ANSI.SYS is
  6402                                  ; *		 installed, send a control string to clear the
  6403                                  ; *		 screen.
  6404                                  ; *
  6405                                  ; * INPUT:	 command line at offset 81H
  6406                                  ; *
  6407                                  ; * OUTPUT:	 none
  6408                                  ; *
  6409                                  ; ****************************************************************
  6410                                  
  6411                                  ; MSDOS 3.3
  6412                                  
  6413                                  CLS:
  6414 000014CA BB0100                  		mov	bx,STDOUT ; 1
  6415 000014CD B80044                  		mov	ax,IOCTL*256 ; 4400h
  6416 000014D0 CD21                    		int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
  6417                                  				; BX = file or device handle
  6418 000014D2 F6C280                  		test	dl,80h	; devid_ISDEV
  6419 000014D5 744C                    		jz	short ANSICLS	; If a file put out ANSI
  6420 000014D7 F6C210                  		test	dl,10h  ; devid_SPECIAL
  6421 000014DA 7447                    		jz	short ANSICLS	; If not special CON, do ANSI
  6422                                  
  6423 000014DC B82935                  		mov	ax,(GET_INTERRUPT_VECTOR<<8)|29h ; 3529h
  6424 000014DF CD21                    		int	21h	; DOS -	2+ - GET INTERRUPT VECTOR
  6425                                  				; AL = interrupt number
  6426                                  				; Return: ES:BX	= value	of interrupt vector
  6427 000014E1 8CC2                    		mov	dx,es
  6428 000014E3 B82035                  		mov	ax,(GET_INTERRUPT_VECTOR<<8)|20h ; 3520h
  6429 000014E6 CD21                    		int	21h	; DOS -	2+ - GET INTERRUPT VECTOR
  6430                                  				; AL = interrupt number
  6431                                  				; Return: ES:BX	= value	of interrupt vector
  6432 000014E8 8CC0                    		mov	ax,es
  6433 000014EA 39C2                    		cmp	dx,ax	; If not default driver, do ANSI
  6434 000014EC 7735                    		ja	short ANSICLS
  6435                                  
  6436 000014EE B40F                    		mov	ah,0Fh
  6437 000014F0 CD10                    		int	10h	; - VIDEO - GET	CURRENT	VIDEO MODE
  6438                                  				; Return: AH = number of columns on screen
  6439                                  				; AL = current video mode
  6440                                  				; BH = current active display page
  6441 000014F2 3C03                    		cmp	al,3
  6442 000014F4 7609                    		jbe	short DOALPHA
  6443 000014F6 3C07                    		cmp	al,7
  6444 000014F8 7405                    		jz	short DOALPHA
  6445 000014FA B400                    		mov	ah,0
  6446 000014FC CD10                    		int	10h	; - VIDEO - SET	VIDEO MODE
  6447                                  				; AL = mode
  6448 000014FE C3                      		retn
  6449                                  
  6450                                  DOALPHA:
  6451 000014FF B40B                    		mov	ah,0Bh	; Set overscan to black
  6452 00001501 31DB                    		xor	bx,bx
  6453 00001503 CD10                    		int	10h	; - VIDEO - SET	COLOR PALETTE
  6454                                  				; BH = 00h, BL = border color
  6455                                  				; BH = 01h, BL = palette (0-3)
  6456 00001505 B40F                    		mov	ah,0Fh
  6457 00001507 CD10                    		int	10h	; - VIDEO - GET	CURRENT	VIDEO MODE
  6458                                  				; Return: AH = number of columns on screen
  6459                                  				; AL = current video mode
  6460                                  				; BH = current active display page
  6461 00001509 88E2                    		mov	dl,ah
  6462 0000150B FECA                    		dec	dl
  6463 0000150D B618                    		mov	dh,24
  6464 0000150F 31C0                    		xor	ax,ax
  6465 00001511 89C1                    		mov	cx,ax
  6466 00001513 BB0007                  		mov	bx,700h
  6467 00001516 B406                    		mov	ah,6
  6468 00001518 CD10                    		int	10h	; - VIDEO - SCROLL PAGE	UP
  6469                                  				; AL = number of lines to scroll window	
  6470                                  				;	(0 = blank whole window)
  6471                                  				; BH = attributes to be	used on	blanked	lines
  6472                                  				; CH,CL	= row,column of	upper left corner of window 
  6473                                  				;	  to scroll
  6474                                  				; DH,DL	= row,column of	lower right corner of window
  6475 0000151A 31D2                    		xor	dx,dx
  6476 0000151C B700                    		mov	bh,0
  6477 0000151E B402                    		mov	ah,2
  6478 00001520 CD10                    		int	10h	; - VIDEO - SET	CURSOR POSITION
  6479                                  				; DH,DL	= row,column (0,0 = upper left)
  6480                                  				; BH = page number
  6481 00001522 C3                      		retn
  6482                                  
  6483                                  ANSICLS:
  6484 00001523 BE[CA3C]                		mov	si,CLSSTRING
  6485 00001526 AC                      		lodsb
  6486 00001527 88C1                    		mov	cl,al
  6487 00001529 30ED                    		xor	ch,ch
  6488 0000152B B406                    		mov	ah,RAW_CON_IO ; 6
  6489                                  CLRLOOP:
  6490 0000152D AC                      		lodsb
  6491 0000152E 88C2                    		mov	dl,al
  6492 00001530 CD21                    		int	21h	; DOS -	DIRECT CONSOLE I/O CHARACTER OUTPUT
  6493                                  				; DL = character <> FFh
  6494                                  				;  Return: ZF set = no character
  6495                                  				;   ZF clear = character recieved, AL = character
  6496 00001532 E2F9                    		loop	CLRLOOP
  6497 00001534 C3                      		retn
  6498                                  
  6499                                  ; ---------------------------------------------------------------------------
  6500                                  
  6501                                  ; MSDOS 6.0
  6502                                  
  6503                                  ;ANSI_installed		equ    0ffh
  6504                                  ;
  6505                                  ;CLS:
  6506                                  ;	mov	ah,Mult_ANSI		;AN000; see if ANSI.SYS installed
  6507                                  ;	mov	al,0			;AN000;
  6508                                  ;	int	2fh			;AN000;
  6509                                  ;	cmp	al,ANSI_installed	;AN000;
  6510                                  ;	jz	ansicls 		;AN000; installed - go do ANSI CLS
  6511                                  ;
  6512                                  ;check_lines:
  6513                                  ;	mov	ax,(IOCTL SHL 8) + generic_ioctl_handle 
  6514                                  ;					;AN000; get lines per page on display
  6515                                  ;	mov	bx,stdout		;AN000; lines for stdout
  6516                                  ;	mov	ch,ioc_sc		;AN000; type is display
  6517                                  ;	mov	cl,get_generic		;AN000; get information
  6518                                  ;	mov	dx,offset trangroup:display_ioctl ;AN000;
  6519                                  ;	int	21h			;AN000;
  6520                                  ;	jc	no_variable		;AN000; function had error, use default
  6521                                  ;	mov	ax,linperpag		;AN000; get number of rows returned
  6522                                  ;	mov	dh,al			;AN000; set number of rows
  6523                                  ;	mov	ax,display_width	;AN000; get number of columns returned
  6524                                  ;	mov	dl,al			;AN000; set number of columns
  6525                                  ;	jmp	short regcls		;AN000; go do cls
  6526                                  ;
  6527                                  ;no_variable:
  6528                                  ;	mov	bx,stdout		;AC000; set handle as stdout
  6529                                  ;	mov	ax,IOCTL SHL 8		;AC000; do ioctl - get device info
  6530                                  ;	int	21h			;AC000;
  6531                                  ;	test	dl,devid_ISDEV		;AC000; is handle a device
  6532                                  ;	jz	ANSICLS 		;AC000; If a file put out ANSI
  6533                                  ;	test	dl,devid_SPECIAL	;AC000;
  6534                                  ;	jnz	cls_normal		;AC000; If not special CON, do ANSI
  6535                                  ;
  6536                                  ;ansicls:
  6537                                  ;	call	ansi_cls		;AN000; clear the screen
  6538                                  ;	jmp	short cls_ret		;AN000; exit
  6539                                  ;
  6540                                  ;;
  6541                                  ;; Get video mode
  6542                                  ;;
  6543                                  ;
  6544                                  ;cls_normal:				;AC000;
  6545                                  ;
  6546                                  ;	mov	ah,get_video_state	;AC000; set up to get video state
  6547                                  ;	int	video_io_int		;AC000; do int 10h - BIOS video IO
  6548                                  ;	cmp	al,video_alpha		;AC000; see if in text mode
  6549                                  ;	jbe	DoAlpha
  6550                                  ;	cmp	al,video_bw		;AC000; see if black & white card
  6551                                  ;	jz	DoAlpha
  6552                                  ;;
  6553                                  ;; We are in graphics mode. Bogus IBM ROM does not scroll correctly. We will
  6554                                  ;; be just as bogus and set the mode that we just got. This will blank the
  6555                                  ;; screen too.
  6556                                  ;;
  6557                                  ;	mov	ah,set_video_mode	;AC000; set video mode call
  6558                                  ;	int	video_io_int		;AC000; do int 10h - BIOS video IO
  6559                                  ;	jmp	short cls_ret		;AC000; exit
  6560                                  ;
  6561                                  ;DoAlpha:
  6562                                  ;;
  6563                                  ;; Get video mode and number of columns to scroll
  6564                                  ;;
  6565                                  ;
  6566                                  ;;M01 - INT 10 Function 0F doesn't reliably return the number of rows on some
  6567                                  ;;M01   adaptors. We circumvent this by reaching directly into the BIOS data
  6568                                  ;;M01   area
  6569                                  ;;M01   Commented out code here is the original
  6570                                  ;;M01	mov	ah,get_video_state		;AC000; set up to get current video state
  6571                                  ;;M01	int	video_io_int			;AC000; do int 10h - BIOS video IO
  6572                                  ;;M01	mov	dl,ah
  6573                                  ;;M01	mov	dh,linesperpage 		;AC000; have 25 rows on the screen
  6574                                  ;
  6575                                  ;;M01   Following code lifted from a fix Compaq applied to ANSI
  6576                                  ;
  6577                                  ;	push	ds
  6578                                  ;	MOV	AX,ROMBIOS_DATA 	; GET ROM Data segment	M01
  6579                                  ;	MOV	DS,AX			;  *			M01
  6580                                  ;	Assume	DS:ROMBIOS_DATA
  6581                                  ;
  6582                                  ;	mov	dx,CRT_Cols		; Get Columns - assume < 256 M01
  6583                                  ;	MOV	dh,CRT_Rows		; GET MAX NUM OF ROWS	M01
  6584                                  ;	pop	ds			;			M01
  6585                                  ;	Assume	DS:Trangroup
  6586                                  ;
  6587                                  ;	or	dh,dh			; Q:ZERO		M01
  6588                                  ;	jnz	regcls			;  *JMP IF NO		M01
  6589                                  ;
  6590                                  ;	MOV	dh,LINESPERPAGE 	; SET TO 24 ROWS	M01
  6591                                  ;
  6592                                  ;regcls:
  6593                                  ;	inc	dh			; height+1		M018
  6594                                  ;	call	reg_cls 		; go clear the screen
  6595                                  ;
  6596                                  ;cls_ret:
  6597                                  ;	ret				; exit
  6598                                  
  6599                                  ; ---------------------------------------------------------------------------
  6600                                  
  6601                                  ; MSDOS 6.0
  6602                                  
  6603                                  ; ****************************************************************
  6604                                  ; *
  6605                                  ; * ROUTINE:	 REG_CLS
  6606                                  ; *
  6607                                  ; * FUNCTION:	 Clear the screen using INT 10H.
  6608                                  ; *
  6609                                  ; * INPUT:	 DL = NUMBER OF COLUMNS
  6610                                  ; *		 DH = NUMBER OF ROWS
  6611                                  ; *
  6612                                  ; * OUTPUT:	 none
  6613                                  ; *
  6614                                  ; ****************************************************************
  6615                                  
  6616                                  ;reg_cls proc	near
  6617                                  ;
  6618                                  ;;
  6619                                  ;; Set overscan to black.
  6620                                  ;;
  6621                                  ;	dec	dh			;  decrement rows and columns
  6622                                  ;	dec	dl			;     to zero base
  6623                                  ;	push	dx			;  save rows,columns
  6624                                  ;	mov	ah,set_color_palette	;  set up to set the color to blank
  6625                                  ;	xor	bx,bx
  6626                                  ;	int	video_io_int		; do int 10h - BIOS video IO
  6627                                  ;	pop	dx			;  retore rows,colums
  6628                                  ;
  6629                                  ;	xor	ax,ax			;  zero out ax
  6630                                  ;	mov	CX,ax			;     an cx
  6631                                  ;;
  6632                                  ;; Scroll active page
  6633                                  ;;
  6634                                  ;	mov	ah,scroll_video_page	; set up to scroll page up
  6635                                  ;	mov	bh,video_attribute	; attribute for blank line
  6636                                  ;	xor	bl,bl			; set BL to 0
  6637                                  ;	int	video_io_int		; do int 10h - BIOS video IO
  6638                                  ;;
  6639                                  ;; Seek to cursor to 0,0
  6640                                  ;;
  6641                                  ;;M022 following two lines added
  6642                                  ;	mov	ah,get_video_state	; get current video page in BH
  6643                                  ;	int	video_io_int
  6644                                  ;	mov	ah,set_cursor_position	; set up to set cursor position
  6645                                  ;	xor	dx,dx			; row and column 0
  6646                                  ;;M022	mov	bh.0
  6647                                  ;	int	video_io_int		; do into 10h - BIOS video IO
  6648                                  ;
  6649                                  ;	ret
  6650                                  ;
  6651                                  ;reg_cls endp
  6652                                  
  6653                                  ; ---------------------------------------------------------------------------
  6654                                  
  6655                                  ; MSDOS 6.0
  6656                                  
  6657                                  ; ****************************************************************
  6658                                  ; *
  6659                                  ; * ROUTINE:	 ANSI_CLS
  6660                                  ; *
  6661                                  ; * FUNCTION:	 Clear the screen using by writing a control code
  6662                                  ; *		 to STDOUT.
  6663                                  ; *
  6664                                  ; * INPUT:	 none
  6665                                  ; *
  6666                                  ; * OUTPUT:	 none
  6667                                  ; *
  6668                                  ; ****************************************************************
  6669                                  
  6670                                  ;ansi_cls proc	near			;AC000;
  6671                                  ;
  6672                                  ;	mov	si,offset trangroup:clsstring
  6673                                  ;	lodsb
  6674                                  ;	mov	cl,al
  6675                                  ;	xor	ch,ch
  6676                                  ;	mov	ah,Raw_CON_IO
  6677                                  ;clrloop:
  6678                                  ;	lodsb
  6679                                  ;	mov	DL,al
  6680                                  ;	int	21h
  6681                                  ;	loop	clrloop
  6682                                  ;	return
  6683                                  ;
  6684                                  ;ansi_cls	endp			;AC000;
  6685                                  
  6686                                  ;============================================================================
  6687                                  ; TCMD2B.ASM, MSDOS 6.0, 1991
  6688                                  ;============================================================================
  6689                                  ; 08/10/2018 - Retro DOS v3.0
  6690                                  
  6691                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 156Dh
  6692                                  
  6693                                  ; ---------------------------------------------------------------------------
  6694                                  
  6695                                  ; ****************************************************************
  6696                                  ; *
  6697                                  ; * ROUTINE:	 CTTY - Change console
  6698                                  ; *
  6699                                  ; * SYNTAX:	 CTTY device
  6700                                  ; *
  6701                                  ; * FUNCTION:	 If a valid console device is specified, CTTY will
  6702                                  ; *		 duplicate the device handle to STDIN, STDOUT and
  6703                                  ; *		 STDERR.  This routine returns to LODCOM1.
  6704                                  ; *
  6705                                  ; * INPUT:	 command line at offset 81H
  6706                                  ; *
  6707                                  ; * OUTPUT:	 none
  6708                                  ; *
  6709                                  ; ****************************************************************
  6710                                  
  6711                                  CTTY:
  6712                                  		; MSDOS 6.0
  6713                                  		;push	ds			;AN000; Get local ES
  6714                                  		;pop	es			;AN000;
  6715                                  		;mov	si,81H			;AC000; Get command argument for CTTY
  6716                                  
  6717                                  		;mov	di,offset trangroup:parse_ctty	
  6718                                  						;AC000; Get address of PARSE_CTTY
  6719                                  		;xor	cx,cx			;AC000; clear cx,dx
  6720                                  		;xor	dx,dx			;AC000;
  6721                                  		;invoke	cmd_parse		;AC000; call parser
  6722                                  		;cmp	ax,end_of_line		;AN000; are we at end of line?
  6723                                  		;jz	ctty_error		;AN000; yes - error
  6724                                  		;cmp	ax,result_no_error	;AN000; did an error occur
  6725                                  		;jnz	ctty_error		;AN000; YES -ERROR
  6726                                  
  6727                                  		;push	si			;AN000; save position in line
  6728                                  		;lds	si,parse1_addr		;AN000; get address of filespec
  6729                                  		;mov	di,offset trangroup:srcbuf ;AN000; get address of srcbuf
  6730                                  
  6731                                  ;ctty_move_filename:				;AN000; put filespec in srcbuf
  6732                                  		;lodsb				;AN000; get a char from buffer
  6733                                  		;stosb				;AN000; store in srcbuf
  6734                                  		;cmp	al,end_of_line_out	;AN000; it char a terminator?
  6735                                  		;jnz	ctty_move_filename	;AN000; no - keep moving
  6736                                  		;pop	si			;AN000; get line position back
  6737                                  		;mov	di,offset trangroup:parse_ctty	
  6738                                  						;AC000; Get address of PARSE_CTTY
  6739                                  		;call	parse_check_eol 	;AN000; are we at end of line?
  6740                                  		;jz	nocolon 		;AN000; yes - continue
  6741                                  ;ctty_error:
  6742                                  		;jmp	short isbaddev		;AC000; yes - exit
  6743                                  
  6744                                  		; MSDOS 3.3
  6745 00001535 E8F007                  		call	SETPATH
  6746 00001538 4E                      		dec	si
  6747 00001539 4E                      		dec	si
  6748 0000153A 803C3A                  		cmp	byte [si],':'
  6749 0000153D 7503                    		jnz	short NOCOLON
  6750 0000153F C60400                  		mov	byte [si],0
  6751                                  NOCOLON:
  6752                                  		; MSDOS 3.3 (& MSDOS 6.0)
  6753                                  		;MOV	AX,(OPEN SHL 8) OR 2 ; Read and write
  6754 00001542 B8023D                  		mov	ax,(OPEN<<8)|2 ; 3D02h
  6755 00001545 CD21                    		int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
  6756                                  				; DS:DX	-> ASCIZ filename
  6757                                  				; AL = access mode
  6758                                  				; 2 - read & write
  6759 00001547 7210                    		jc	short ISBADDEV
  6760 00001549 89C3                    			mov	bx,ax
  6761 0000154B B80044                  		mov	ax,IOCTL*256 ; 4400h
  6762 0000154E CD21                    		int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
  6763                                  				; BX = file or device handle
  6764 00001550 F6C280                  		test	dl,80h
  6765 00001553 750C                    		jnz	short DEVISOK
  6766                                  CLOSEDEV:
  6767 00001555 B43E                    		mov	ah,CLOSE ; 3Eh ; Close initial handle
  6768 00001557 CD21                    		int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
  6769                                  				; BX = file handle
  6770                                  ISBADDEV:
  6771 00001559 BA[833B]                		mov	dx,BADDEVPTR
  6772 0000155C E8C91E                  		call	STD_PRINTF
  6773 0000155F EB28                    		jmp	short RESRET
  6774                                  
  6775                                  		;nop
  6776                                  DEVISOK:
  6777                                  		; MSDOS 6.0
  6778                                  		;push	dx		;AN007; save device info
  6779                                  		;mov	ax,acrlf_ptr	;AN021; get message number for 0d, 0a
  6780                                  		;mov	dh,util_msg_class ;AN021; this is a utility message
  6781                                  		;push	bx		;AN021; save handle
  6782                                  		;invoke	Tsysgetmsg	;AN021; get the address of the message
  6783                                  		;mov	dx,si		;AN021; get address into dx
  6784                                  		;mov	ax,(write shl 8) ;AN007; write to device
  6785                                  		;mov	cx,2		;AN007; write two bytes
  6786                                  		;int	21h		;AN007;
  6787                                  		;pop	bx		;AN021; get back handle
  6788                                  		;pop	dx		;AN007; get back device info
  6789                                  		;jc	closedev	;AN007; if error, quit
  6790                                  
  6791                                  		; MSDOS 3.3 (& MSDOS 6.0)
  6792 00001561 30F6                    		xor	dh,dh
  6793 00001563 80CA03                  		or	dl,3
  6794                                  		;MOV	AX,(IOCTL SHL 8) OR 1
  6795 00001566 B80144                  		mov	ax,(IOCTL<<8)|1 ; 4401h
  6796 00001569 CD21                    		int	21h	; DOS -	2+ - IOCTL - SET DEVICE	INFORMATION
  6797                                  				; BX = device handle,DH = 0
  6798                                  				; DL = device information to set 
  6799                                  				;		(bits 0-7 from	function 0)
  6800 0000156B 53                      		push	bx
  6801 0000156C B90300                  		mov	cx,3
  6802 0000156F 31DB                    		xor	bx,bx
  6803                                  
  6804                                  ICLLOOP:				; Close basic handles
  6805 00001571 B43E                    		mov	ah,CLOSE ; 3Eh
  6806 00001573 CD21                    		int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
  6807                                  				; BX = file handle
  6808 00001575 43                      		inc	bx
  6809 00001576 E2F9                    		loop	ICLLOOP
  6810 00001578 5B                      		pop	bx		; Get handle
  6811 00001579 B445                    		mov	ah,XDUP ; 45h
  6812 0000157B CD21                    		int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
  6813                                  				; BX = file handle to duplicate
  6814 0000157D B445                    		mov	ah,XDUP ; 45h
  6815 0000157F CD21                    		int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
  6816                                  				; BX = file handle to duplicate
  6817 00001581 B445                    		mov	ah,XDUP ;45h
  6818 00001583 CD21                    		int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
  6819                                  				; BX = file handle to duplicate
  6820 00001585 B43E                    		mov	ah,CLOSE ; 3Eh
  6821 00001587 CD21                    		int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
  6822                                  				; BX = file handle
  6823                                  RESRET:
  6824 00001589 8E1E[8141]              		mov	ds,[RESSEG]
  6825 0000158D 1E                      		push	ds
  6826 0000158E A11800                  		mov	ax,[PDB.JFN_TABLE] ; Get new 0 and 1
  6827 00001591 A3EB0B                  		mov	[IO_SAVE],ax
  6828                                  		;MOV	AX,OFFSET DATARES:TrnLodCom1_Trap  ; MSDOS 6.0
  6829                                  		;mov	ax,31Eh ; MSDOS 3.3
  6830 00001594 B81903                  		mov	ax,LODCOM1
  6831 00001597 50                      		push	ax
  6832                                  
  6833 00001598 CB                      		retf		; Far return
  6834                                  
  6835                                  ; ---------------------------------------------------------------------------
  6836                                  
  6837                                  ;****************************************************************
  6838                                  ;*
  6839                                  ;* ROUTINE:	CHCP - Change code page internal command
  6840                                  ;*		(added DOS 3.30 07/21/86)
  6841                                  ;*
  6842                                  ;* SYNTAX:	CHCP [xxx]
  6843                                  ;*		where xxx is a valid code page
  6844                                  ;*
  6845                                  ;* FUNCTION:	If xxx is specified, CHCP will use INT 21H function
  6846                                  ;*		6402H to set the code page to xxxx. If no parameters
  6847                                  ;*		are specified, CHCP will use INT 21H function 6401H
  6848                                  ;*		to get global code page and display it to the user.
  6849                                  ;*
  6850                                  ;* INPUT:	command line at offset 81H
  6851                                  ;*
  6852                                  ;* OUTPUT:	none
  6853                                  ;*
  6854                                  ;****************************************************************
  6855                                  
  6856                                  ;NLSFUNC_installed equ  0FFh
  6857                                  set_global_cp	equ   2
  6858                                  get_global_cp	equ   1
  6859                                  
  6860                                  CHCP:
  6861                                  		; MSDOS 6.0
  6862                                  		;push	ds		;AN000; Get local ES
  6863                                  		;pop	es		;AN000;
  6864                                  		;mov	si,81H		;AC000; Get command argument for CHCP
  6865                                  
  6866                                  		;mov	di,offset trangroup:parse_chcp	
  6867                                  					;AN000; Get address of PARSE_CHCP
  6868                                  		;xor	cx,cx		;AC000; clear cx,dx
  6869                                  		;xor	dx,dx		;AC000;
  6870                                  		;call	parse_with_msg	;AC018; call parser
  6871                                  		;cmp	ax,end_of_line	;AN000; are we at end of line?
  6872                                  
  6873                                  		;;jnz	setcp		;AC000; no go get number & set code page
  6874                                  		;jz	getcp		;AC000; yes - no parm - get code page
  6875                                  ;setcp:
  6876                                  		;cmp	ax,result_no_error ;AN000; did we have an error?
  6877                                  		;jne	cp_error	;AC018; yes - go issue message
  6878                                  
  6879                                  		;push	cx		;AN000; save positional count
  6880                                  		;mov	bx,offset trangroup:parse1_addr 
  6881                                  					;AN000; get number returned
  6882                                  		;mov	cx,word ptr [bx] ;AN000;     into cx
  6883                                  		;mov	system_cpage,cx ;AN000; save user input number
  6884                                  		;pop	cx		;AC000; restore positional count
  6885                                  		;mov	di,offset trangroup:parse_chcp	
  6886                                  					;AN000; Get address of PARSE_CHCP
  6887                                  		;call	parse_check_eol ;AN000; are we at end of line?
  6888                                  		;jnz	cp_error	;AC000; no - exit
  6889                                  ;okset:
  6890                                  		;mov	ah,NLSFUNC	;AN000; see if NLSFUNC installed
  6891                                  		;mov	al,0		;AN000;
  6892                                  		;int	2fh		;AN000;
  6893                                  		;cmp	al,NLSFUNC_installed ;AN000;
  6894                                  		;jz	got_NLS 	;AN000; Yes - continue
  6895                                  		;mov	dx,offset trangroup:NLSFUNC_ptr
  6896                                  					;AN000; no - set up error message
  6897                                  		;jmp	short cp_error	;AN000; error exit
  6898                                  ;got_NLS:
  6899                                  
  6900                                  		; MSDOS 3.3
  6901 00001599 BE8100                  		mov	si,81h
  6902 0000159C E8A703                  		call	SCANOFF
  6903 0000159F 3C0D                    		cmp	al,0Dh ; CR
  6904                                  		;jnz	short SETCP
  6905                                  		;jmp	short GETCP
  6906                                  		; 02/03/2023
  6907 000015A1 7472                    		jz	short GETCP
  6908                                  
  6909                                  		;nop
  6910                                  SETCP:
  6911 000015A3 31DB                    		xor	bx,bx
  6912 000015A5 89D9                    		mov	cx,bx
  6913 000015A7 89D8                    		mov	ax,bx
  6914                                  GET_CP_DIGIT:
  6915 000015A9 AC                      		lodsb
  6916 000015AA 3C30                    		cmp	al,'0'
  6917 000015AC 721C                    		jb	short CHRNOTNUMBER
  6918 000015AE 3C39                    		cmp	al,'9'
  6919 000015B0 7718                    		ja	short CHRNOTNUMBER
  6920 000015B2 2C30                    		sub	al,'0'
  6921 000015B4 FEC1                    		inc	cl
  6922 000015B6 80F904                  		cmp	cl,4
  6923 000015B9 771B                    		ja	short CHCP_BADPARM
  6924 000015BB 89DA                    		mov	dx,bx
  6925 000015BD D1E2                    		shl	dx,1
  6926 000015BF D1E2                    		shl	dx,1
  6927 000015C1 01D3                    		add	bx,dx
  6928 000015C3 D1E3                    		shl	bx,1
  6929 000015C5 01C3                    		add	bx,ax
  6930 000015C7 EBE0                    		jmp	short GET_CP_DIGIT
  6931                                  CP_NEXTCHR:
  6932 000015C9 AC                      		lodsb
  6933                                  CHRNOTNUMBER:
  6934 000015CA 3C20                    		cmp	al,' '		; SPACE
  6935 000015CC 74FB                    		jz	short CP_NEXTCHR
  6936 000015CE 3C09                    		cmp	al,9		; TAB
  6937 000015D0 74F7                    		jz	short CP_NEXTCHR
  6938 000015D2 3C0D                    		cmp	al,0Dh		; CR
  6939 000015D4 7406                    		jz	short SET_CP_TBL_NUM
  6940                                  CHCP_BADPARM:
  6941 000015D6 BA[5239]                		mov	dx,BADPARMPTR
  6942 000015D9 E90E06                  		jmp	CERROR
  6943                                  ;GOT_NLS:
  6944                                  SET_CP_TBL_NUM:
  6945                                  		; MSDOS 3.3 (& MSDOS 6.0)
  6946 000015DC 891E[203E]              		mov	[SYSTEM_CPAGE],bx
  6947 000015E0 B466                    		mov	ah,GETSETCDPG  ; 66h
  6948 000015E2 B002                    		mov	al,set_global_cp ; 2
  6949 000015E4 CD21                    		int	21h	; DOS -	3.3+ - SET GLOBAL CODE PAGE TABLE
  6950                                  				; BX = active code page
  6951                                  				; DX = system code page	(active	page at	boot time)
  6952 000015E6 733D                    		jnc	short CHCP_RETURN
  6953                                  
  6954 000015E8 83F802                  		cmp	ax,ERROR_FILE_NOT_FOUND ; 2
  6955 000015EB 7511                    		jnz	short CHCP_OTHER_ERROR
  6956                                  
  6957 000015ED B459                    		mov	ah,GETEXTENDEDERROR ; 59h
  6958 000015EF 31DB                    		xor	bx,bx
  6959 000015F1 CD21                    		int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
  6960                                  				; BX = version code (0000h for DOS 3.x)
  6961 000015F3 83F80D                  		cmp	ax,ERROR_INVALID_DATA ; 0Dh ; invalid code page
  6962 000015F6 7417                    		jz	short NONE_SET
  6963 000015F8 BA[2837]                		mov	dx,FNOTFOUNDPTR
  6964 000015FB E9EC05                  		jmp	CERROR
  6965                                  CHCP_OTHER_ERROR:			; end of p716
  6966 000015FE B459                    		mov	ah,GETEXTENDEDERROR ; 59h ;error - see what it is
  6967 00001600 31DB                    		xor	bx,bx
  6968 00001602 CD21                    		int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
  6969                                  				; BX = version code (0000h for DOS 3.x)
  6970 00001604 83F841                  		cmp	ax,65		;was it access denied?
  6971 00001607 7506                    		jnz	short NONE_SET	;no - assume all failed
  6972 00001609 BA[D838]                		mov	dx,CPNOTALLPTR	;set up message
  6973 0000160C E9DB05                  		jmp	CERROR		;AC000; error exit
  6974                                  NONE_SET:
  6975 0000160F BA[A538]                		mov	dx,CPNOTSETPTR	;set up message
  6976                                  CP_ERROR:
  6977 00001612 E9D505                  		jmp	CERROR		;exit
  6978                                  GETCP:
  6979 00001615 B466                    		mov	ah,GETSETCDPG ; 66h  ;get/set global code page function	
  6980 00001617 B001                    		mov	al,get_global_cp ; 1 ;minor - get
  6981 00001619 CD21                    		int	21h	; DOS -	3.3+ - GET GLOBAL CODE PAGE TABLE
  6982 0000161B 891E[203E]              		mov	[SYSTEM_CPAGE],bx ;get active cp for output
  6983 0000161F BA[F638]                		mov	dx,CPACTIVEPTR
  6984 00001622 E8031E                  		call	STD_PRINTF	;print it out
  6985                                  CHCP_RETURN:
  6986 00001625 C3                      		retn
  6987                                  
  6988                                  ; ---------------------------------------------------------------------------
  6989                                  
  6990                                  ; ****************************************************************
  6991                                  ; *
  6992                                  ; * ROUTINE:	 TRUENAME
  6993                                  ; *
  6994                                  ; * FUNCTION:	 Entry point for the internal TRUENAME command.
  6995                                  ; *		 Parses the command line. If a path is found, set
  6996                                  ; *		 SRCXNAME to path.  If only a drive letter is
  6997                                  ; *		 found, set SRCXNAME to the drive letter.  If
  6998                                  ; *		 no path is found, set the path of SRCXNAME to
  6999                                  ; *		 dot (.) for current directory.  Use the NAME
  7000                                  ; *		 TRANSLATE system call to get the real name and
  7001                                  ; *		 then display the real name.  If an error occurs
  7002                                  ; *		 issue an error message and transfer control to
  7003                                  ; *		 CERROR.
  7004                                  ; *
  7005                                  ; * INPUT:	 command line at offset 81H
  7006                                  ; *
  7007                                  ; * OUTPUT:	 none
  7008                                  ; *
  7009                                  ; ****************************************************************
  7010                                  
  7011                                  ;assume	ds:trangroup,es:trangroup		;AN000;
  7012                                  ;
  7013                                  ;TRUENAME:					;AN000; TRUENAME entry point
  7014                                  ;	push	ds				;AN000; Get local ES
  7015                                  ;	pop	es				;AN000;
  7016                                  ;	mov	si,81H				;AN000; Get command line
  7017                                  ;	mov	di,offset trangroup:parse_chdir ;AN000; Get address of PARSE_CHDIR
  7018                                  ;	xor	cx,cx				;AN000; clear cx,dx
  7019                                  ;	xor	dx,dx				;AN000;
  7020                                  ;	call	parse_with_msg			;AC018; call parser
  7021                                  ;
  7022                                  ;	mov	di,offset trangroup:srcxname	;AN000; get address of srcxname
  7023                                  ;	cmp	ax,end_of_line			;AN000; are we at end of line?
  7024                                  ;	je	tn_eol				;AN000; yes - go process
  7025                                  ;	cmp	ax,result_no_error		;AN000; did we have an error?
  7026                                  ;	jne	tn_parse_error			;AN000; yes - go issue message
  7027                                  ;	cmp	parse1_type,result_drive	;AN000; was a drive entered?
  7028                                  ;	je	tn_drive			;AN000; yes - go process
  7029                                  ;	jmp	short tn_filespec		;AN000; nothing else - must be filespec
  7030                                  ;
  7031                                  ;tn_eol: 					;AN000; no parameters on line
  7032                                  ;	mov	ah,end_of_line_out		;AN000; set buffer to .
  7033                                  ;	mov	al,dot_chr			;AN000;     for current dir
  7034                                  ;	stosw					;AN000; store in srcxname
  7035                                  ;	jmp	short tn_doit			;AN000; go do command
  7036                                  ;
  7037                                  ;tn_drive:					;AN000; a drive was entered
  7038                                  ;	push	si				;AN000; save position in line
  7039                                  ;	mov	si,offset trangroup:parse1_addr ;AN000; get address of drive
  7040                                  ;	lodsb					;AN000; get the drive number
  7041                                  ;	add	al,"A"-1                        ;AN000; convert it to char
  7042                                  ;	stosb					;AN000; store it in srcxname
  7043                                  ;	mov	ax,dot_colon			;AN000; get colon and . and
  7044                                  ;	stosw					;AN000;    store in srcxname
  7045                                  ;	mov	al,end_of_line_out		;AN000; put a terminator char
  7046                                  ;	stosb					;AN000;
  7047                                  ;	pop	si				;AN000; get line position back
  7048                                  ;	jmp	short tn_check_eol		;AN000; check to make sure eol
  7049                                  ;
  7050                                  ;tn_filespec:					;AN000; a filespec was entered
  7051                                  ;	push	si				;AN000; save position in line
  7052                                  ;	lds	si,parse1_addr			;AN000; get address of filespec
  7053                                  ;
  7054                                  ;tn_move_filename:				;AN000; put filespec in srcxname
  7055                                  ;	lodsb					;AN000; get a char from buffer
  7056                                  ;	stosb					;AN000; store in srcxname
  7057                                  ;	cmp	al,end_of_line_out		;AN000; it char a terminator?
  7058                                  ;	jnz	tn_move_filename		;AN000; no - keep moving
  7059                                  ;	pop	si				;AN000; get line position back
  7060                                  ;
  7061                                  ;tn_check_eol:					;AN000; make sure no extra parms
  7062                                  ;	mov	di,offset trangroup:parse_chdir ;AN000; get address of parse_chdir
  7063                                  ;	call	parse_check_eol 		;AN000; are we at end of line?
  7064                                  ;	je	tn_doit 			;AN000; Yes - do the command
  7065                                  ;
  7066                                  ;tn_parse_error: 				;AN000; A parse error occurred
  7067                                  ;	jmp	cerror				;AN000; Go to error routine
  7068                                  ;
  7069                                  ;tn_doit:					;AN000;
  7070                                  ;	mov	si,offset trangroup:srcxname	;AN000; set up srcxname as source
  7071                                  ;	mov	di,offset trangroup:combuf	;AN000; set up combuf as target (need big target)
  7072                                  ;	mov	ah,xnametrans			;AN000; do name translate call
  7073                                  ;	int	21h			;AN000;
  7074                                  ;	jnc	tn_print_xname			;AN000; If no error - print result
  7075                                  ;
  7076                                  ;	invoke	Set_ext_error_msg		;AN000; get extended message
  7077                                  ;	mov	string_ptr_2,offset trangroup:srcxname ;AN000; get address of failed string
  7078                                  ;	mov	Extend_buf_sub,one_subst	;AN000; put number of subst in control block
  7079                                  ;	jmp	cerror				;AN000; Go to error routine
  7080                                  ;
  7081                                  ;tn_print_xname: 				;AN000;
  7082                                  ;	mov	string_ptr_2,offset Trangroup:combuf ;AN000; Set up address of combuf
  7083                                  ;	mov	dx,offset trangroup:string_buf_ptr   ;AN000; Set up address of print control block
  7084                                  ;	invoke	crlf2				;AN000; print a crlf
  7085                                  ;	invoke	printf_crlf			;AN000; print it out
  7086                                  ;
  7087                                  ;	ret					;AN000;
  7088                                  ;
  7089                                  
  7090                                  ; ---------------------------------------------------------------------------
  7091                                  
  7092                                  _$EXIT:
  7093                                  		; MSDOS 3.3
  7094 00001626 8E06[8141]              		mov	es,[RESSEG]
  7095 0000162A 26A1880B                		mov	ax,[es:PARENT]
  7096                                  		;mov	[es:16h],ax
  7097 0000162E 26A31600                		mov	[es:PDB.PARENT_PID],ax
  7098 00001632 26A18A0B                		mov	ax,[es:OLDTERM]
  7099                                  		;mov	[es:0Ah],ax
  7100 00001636 26A30A00                		mov	[es:PDB.EXIT],ax
  7101 0000163A 26A18C0B                		mov	ax,[es:OLDTERM+2]
  7102                                  		;mov	[es:0Ch],ax
  7103 0000163E 26A30C00                		mov	[es:PDB.EXIT+2],ax
  7104 00001642 06                      		push	es
  7105 00001643 8E06[9141]              		mov	es,[TRAN_TPA]
  7106 00001647 B449                    		mov	ah,DEALLOC ; 49h
  7107 00001649 CD21                    		int	21h	; DOS -	2+ - FREE MEMORY
  7108                                  				; ES = segment address of area to be freed
  7109 0000164B 07                      		pop	es
  7110 0000164C B44C                    		mov	ah,EXIT ; 4Ch
  7111                                  		;mov	al,[0BEAh] ; MSDOS 3.3 COMMAND.cOm offset 168Ah
  7112 0000164E 26A0E60B                		mov	al,[es:RETCODE]
  7113 00001652 CD21                    		int	21h		; DOS -	2+ - QUIT WITH EXIT CODE (EXIT)
  7114                                  
  7115                                  ;;here:
  7116                                  ;;		jmp	short here
  7117                                  
  7118                                  		; MSDOS 6.0
  7119                                  		;push	ds			;AN000; save data segment
  7120                                  		;mov	ds,[resseg]		;AN000; get resident data segment
  7121                                  
  7122                                  		;assume	ds:resgroup		;AN000;
  7123                                  
  7124                                  		;cmp	[permcom],0		;AN045; is this a permanent COMMAND?
  7125                                  		;jz	free_com		;AN045; no - free everything
  7126                                  
  7127                                  ;	We're a permanent command.
  7128                                  ;	Unless this is a singlecom (int 2Eh), don't deallocate transient.
  7129                                  
  7130                                  		;cmp	[singlecom],-1		;M034
  7131                                  		;je	no_reset		;M034	;exit singlecom
  7132                                  
  7133                                  		;jmp	TCommand		;permanent command, recycle
  7134                                  
  7135                                  ;free_com:
  7136                                  		;mov	ax,(multdos shl 8 or message_2f)
  7137                                  						;AN060; reset parse message pointers
  7138                                  		;mov	dl,set_critical_msg	;AN000; set up critical error message address
  7139                                  		;mov	di,crit_msg_off 	;AN000; old offset of critical messages
  7140                                  		;mov	es,crit_msg_seg 	;AN000; old segment of critical messages
  7141                                  		;int	2fh			;AN000; go set it
  7142                                  ;no_reset:					;AN045;
  7143                                  		;pop	ds			;AN000; restore local data segment
  7144                                  
  7145                                  		;assume	ds:trangroup		;AN000;
  7146                                  ;
  7147                                  ;M040
  7148                                  ; Restore user directory if the restore flag is set. RestUDir1 checks for
  7149                                  ;this, restores user dir if flag is set and resets the flag.
  7150                                  ;
  7151                                  		;invoke	RestUDir1		;restore user dir if needed ;M040
  7152                                  		;MOV	ES,[RESSEG]
  7153                                  
  7154                                  		;assume	es:resgroup
  7155                                  
  7156                                  		;MOV	AX,[PARENT]
  7157                                  		;MOV	WORD PTR ES:[PDB_Parent_PID],AX
  7158                                  		;MOV	AX,WORD PTR OldTerm
  7159                                  		;MOV	WORD PTR ES:[PDB_Exit],AX
  7160                                  		;MOV	AX,WORD PTR OldTerm+2
  7161                                  		;MOV	WORD PTR ES:[PDB_Exit+2],AX
  7162                                  
  7163                                  		;PUSH	ES
  7164                                  		;MOV	ES,[TRAN_TPA]
  7165                                  		;MOV	AH,DEALLOC
  7166                                  		;INT	21h			; Now running in "free" space
  7167                                  		;POP	ES
  7168                                  
  7169                                  		;MOV	AH,Exit
  7170                                  		;MOV	AL,BYTE PTR RetCode
  7171                                  		;INT	21h
  7172                                  
  7173                                  ; ---------------------------------------------------------------------------
  7174                                  
  7175                                  ; MSDOS 6.0
  7176                                  ; ****************************************************************
  7177                                  ; *
  7178                                  ; * ROUTINE:	 PARSE_CHECK_EOL
  7179                                  ; *
  7180                                  ; * FUNCTION:	 Calls parser to see if end of line occurred.
  7181                                  ; *		 If not end of line, set up to print parse
  7182                                  ; *		 error message.  ASSUMES NO MORE PARAMETERS ARE
  7183                                  ; *		 EXPECTED!
  7184                                  ; *
  7185                                  ; * INPUT:	 DS:SI	  last output from parser
  7186                                  ; *		 ES:DI	  points to parse block
  7187                                  ; *		 CX	  last output from parser
  7188                                  ; *
  7189                                  ; * OUTPUT:	 AX	  parser return code
  7190                                  ; *
  7191                                  ; *		 if end of line found
  7192                                  ; *		     zero flag set
  7193                                  ; *		 else
  7194                                  ; *		     MSG_DISPLAY_CLASS set to parse error
  7195                                  ; *
  7196                                  ; ****************************************************************
  7197                                  
  7198                                  ;ASSUME	CS:TRANGROUP,DS:TRANGROUP,ES:NOTHING	;AN000;
  7199                                  ;
  7200                                  ;parse_check_eol Proc near			;AN000;
  7201                                  ;
  7202                                  ;	xor	dx,dx				;AN000;
  7203                                  ;	mov	[parse_last],si 		;AN018; save start of parameter
  7204                                  ;	invoke	cmd_parse			;AN000; call parser
  7205                                  ;	cmp	al,end_of_line			;AN000; Are we at end of line?
  7206                                  ;	jz	parse_good_eol			;AN000; yes - no problem
  7207                                  ;
  7208                                  ;	cmp	ax,result_no_error		;AN018; was any error found?
  7209                                  ;	jnz	ok_to_setup_pmsg		;AN018; yes - continue
  7210                                  ;	inc	ax				;AN018; set AX to 1 and turn off zero flag
  7211                                  ;
  7212                                  ;ok_to_setup_pmsg:
  7213                                  ;	call	setup_parse_error_msg		;AN018; go set up error message
  7214                                  ;
  7215                                  ;parse_good_eol:
  7216                                  ;	ret					;AN000;
  7217                                  ;
  7218                                  ;parse_check_eol endp				;AN000;
  7219                                  
  7220                                  ; ---------------------------------------------------------------------------
  7221                                  
  7222                                  ; MSDOS 6.0
  7223                                  ; ****************************************************************
  7224                                  ; *
  7225                                  ; * ROUTINE:	 PARSE_WITH_MSG
  7226                                  ; *
  7227                                  ; * FUNCTION:	 Calls parser.	If an error occurred, the error
  7228                                  ; *		 message is set up.
  7229                                  ; *
  7230                                  ; * INPUT:	 DS:SI	  last output from parser
  7231                                  ; *		 ES:DI	  points to parse block
  7232                                  ; *		 CX	  last output from parser
  7233                                  ; *
  7234                                  ; * OUTPUT:	 AX	  parser return code
  7235                                  ; *
  7236                                  ; *		 if no error
  7237                                  ; *		     outputs from parser
  7238                                  ; *		 else
  7239                                  ; *		     MSG_DISPLAY_CLASS set to parse error
  7240                                  ; *		     error message set up for STD_PRINTF
  7241                                  ; *
  7242                                  ; ****************************************************************
  7243                                  
  7244                                  ;ASSUME	CS:TRANGROUP,DS:TRANGROUP,ES:NOTHING	;AN018;
  7245                                  ;
  7246                                  ;parse_with_msg	Proc near			;AN018;
  7247                                  ;
  7248                                  ;	mov	[parse_last],si 		;AN018; save start of parameter
  7249                                  ;	invoke	cmd_parse			;AN018; call parser
  7250                                  ;	cmp	al,end_of_line			;AN018; Are we at end of line?
  7251                                  ;	jz	parse_msg_good			;AN018; yes - no problem
  7252                                  ;	cmp	ax,result_no_error		;AN018; did an error occur
  7253                                  ;	jz	parse_msg_good			;AN018; yes - no problem
  7254                                  ;
  7255                                  ;	call	setup_parse_error_msg		;AN018; go set up error message
  7256                                  ;
  7257                                  ;parse_msg_good:
  7258                                  ;	ret					;AN018;
  7259                                  ;
  7260                                  ;parse_with_msg endp				;AN018;
  7261                                  
  7262                                  ; ---------------------------------------------------------------------------
  7263                                  
  7264                                  ; MSDOS 6.0
  7265                                  ; ****************************************************************
  7266                                  ; *
  7267                                  ; * ROUTINE:	 SETUP_PARSE_ERROR_MSG
  7268                                  ; *
  7269                                  ; * FUNCTION:	 Calls parser.	If an error occurred, the error
  7270                                  ; *		 message is set up.
  7271                                  ; *
  7272                                  ; * INPUT:	 AX	     Parse error number
  7273                                  ; *		 SI	     Set to past last parameter
  7274                                  ; *		 Parse_last  Set to start of last parameter
  7275                                  ; *
  7276                                  ; * OUTPUT:	 MSG_DISPLAY_CLASS set to parse error
  7277                                  ; *		 error message set up for STD_PRINTF
  7278                                  ; *
  7279                                  ; ****************************************************************
  7280                                  
  7281                                  ;ASSUME	CS:TRANGROUP,DS:TRANGROUP,ES:NOTHING	;AN018;
  7282                                  ;
  7283                                  ;SETUP_PARSE_ERROR_MSG	Proc near		;AN018;
  7284                                  ;
  7285                                  ;	mov	msg_disp_class,parse_msg_class	;AC018; Set up parse message class
  7286                                  ;	mov	dx,offset TranGroup:Extend_Buf_ptr  ;AC018; get extended message pointer
  7287                                  ;	mov	byte ptr [si],end_of_line_out	;AC018; terminate the parameter string
  7288                                  ;	mov	Extend_Buf_ptr,ax		;AC018; get message number in control block
  7289                                  ;	cmp	ax,lessargs_ptr 		;AC018; if required parameter missing
  7290                                  ;	jz	Setup_parse_msg_ret		;AN018;    no subst
  7291                                  ;	mov	si,[parse_last] 		;AC018; get start of parameter
  7292                                  ;	mov	string_ptr_2,si 		;AC018; get address of failed string
  7293                                  ;	mov	Extend_buf_sub,one_subst	;AC018; put number of subst in control block
  7294                                  ;
  7295                                  ;setup_parse_msg_ret:
  7296                                  ;	inc	si				;AN018; make sure zero flag not set
  7297                                  ;
  7298                                  ;	ret					;AC018;
  7299                                  ;
  7300                                  ;SETUP_PARSE_ERROR_MSG	Endp			;AN018;
  7301                                  
  7302                                  ;============================================================================
  7303                                  ; TENV.ASM, MSDOS 6.0, 1991
  7304                                  ;============================================================================
  7305                                  ; 08/10/2018 - Retro DOS v3.0
  7306                                  
  7307                                  ; TITLE	Part6 COMMAND Transient routines.
  7308                                  
  7309                                  ;	Environment utilities and misc. routines
  7310                                  
  7311                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1690h
  7312                                  
  7313                                  ; ---------------------------------------------------------------------------
  7314                                  
  7315                                  ADD_PROMPT:
  7316 00001654 E8F100                  		call	DELETE_PROMPT	; Delete any existing prompt
  7317 00001657 E87801                  		call	SCAN_DOUBLE_NULL
  7318                                  ADD_PROMPT2:
  7319 0000165A 56                      		push	si
  7320 0000165B E86601                  		call	GETARG
  7321 0000165E 5E                      		pop	si
  7322 0000165F 7501                    		jnz	short ADD_PROMPT3
  7323                                  ADD_PROMPT_RETN:
  7324 00001661 C3                      		retn
  7325                                  ADD_PROMPT3:				; Pre scan for arguments
  7326 00001662 E84E01                  		call	MOVE_NAME	 ;Move in name
  7327 00001665 E85C01                  		call	GETARG
  7328 00001668 56                      		push	si
  7329 00001669 EB4F                    		jmp	short ADD_NAME
  7330                                  
  7331                                  ;break	The SET command
  7332                                  
  7333                                  ; Input: DS:SI points to a CR terminated string
  7334                                  ; Output: carry flag is set if no room
  7335                                  ;	  otherwise name is added to environment
  7336                                  
  7337                                  DISP_ENVJ:
  7338 0000166B E9B100                  		jmp	DISP_ENV
  7339                                  
  7340                                  ADD_NAME_TO_ENVIRONMENT:
  7341 0000166E E85301                  		call	GETARG
  7342 00001671 74F8                    		jz	short DISP_ENVJ
  7343                                  
  7344                                  ; check if line contains exactly one equals sign
  7345                                  
  7346 00001673 31DB                    		xor	bx,bx		; = count is 0
  7347 00001675 56                      		push	si		; Save pointer to beginning of line
  7348                                  EQLP:
  7349 00001676 AC                      		lodsb			; Get a char
  7350 00001677 3C0D                    		cmp	al,13		; IF CR we're all done
  7351 00001679 740F                    		jz	short QUEQ	
  7352 0000167B 3C3D                    		cmp	al,'='		; Look for = sign	
  7353 0000167D 75F7                    		jnz	short EQLP	; not there, get next char
  7354 0000167F FEC3                    		inc	bl		; Otherwise increment EQ count
  7355 00001681 803C0D                  		cmp	byte [si],13	; Look for CR following = sign
  7356 00001684 75F0                    		jnz	short EQLP
  7357 00001686 FEC7                    		inc	bh		; Set BH=1 means no parameters
  7358 00001688 EBEC                    		jmp	short EQLP	; And look for more
  7359                                  QUEQ:
  7360 0000168A 5E                      		pop	si		; Restore beginning of line
  7361 0000168B FECB                    		dec	bl		; Zero flag means only one EQ
  7362 0000168D 7406                    		jz	short ONEQ	; Good line
  7363 0000168F BA[A83B]                		mov	dx,SYNTMESPTR
  7364 00001692 E95505                  		jmp	CERROR
  7365                                  ONEQ:
  7366 00001695 53                      		push	bx
  7367 00001696 E8B200                  		call	DELETE_NAME_IN_ENVIRONMENT
  7368 00001699 5B                      		pop	bx
  7369 0000169A FECF                    		dec	bh
  7370 0000169C 74C3                    		jz	short ADD_PROMPT_RETN
  7371 0000169E E83101                  		call	SCAN_DOUBLE_NULL
  7372 000016A1 89FB                    		mov	bx,di		; Save ptr to beginning of env var name
  7373 000016A3 E80D01                  		call	MOVE_NAME
  7374 000016A6 56                      		push	si
  7375 000016A7 87DF                    		xchg	bx,di		; Switch ptrs to beginning and end of
  7376                                  					;  env var name
  7377                                  		
  7378                                  ; We want to special-case COMSPEC. This is to reduce the amount of code
  7379                                  ; necessary in the resident for re-reading the transient. Let's look for
  7380                                  ; COMSPEC=
  7381                                  
  7382                                  		;mov	byte [COMSPEC_FLAG],0 ; MSDOS 6.0 ; clear flag ; M024
  7383 000016A9 BE[493B]                		mov	si,COMSPEC_TEXT	; "COMSPEC="
  7384 000016AC B90400                  		mov	cx,4
  7385 000016AF F3A7                    		repe cmpsw
  7386 000016B1 7505                    		jnz	short NOT_COMSPEC
  7387                                  					; Zero set => exact match
  7388                                  		;inc byte [COMPREC_FLAG] ; MSDOS 6.0 ; comspec is changing ; M024
  7389 000016B3 C606[B844]01            		mov	byte [COMSPEC_FLAG],1
  7390                                  NOT_COMSPEC:
  7391 000016B8 89DF                    		mov	di,bx		; Load ptr to end of env var name
  7392                                  ADD_NAME:
  7393 000016BA 5E                      		pop	si		; Add the value of the new env var
  7394 000016BB 56                      		push	si		;  to the environment.
  7395                                  ADD_NAME1:
  7396 000016BC AC                      		lodsb
  7397 000016BD 3C0D                    		cmp	al,13
  7398 000016BF 7405                    		jz	short ADD_NAME_RET
  7399 000016C1 E84001                  		call	STORE_CHAR
  7400 000016C4 EBF6                    		jmp	short ADD_NAME1
  7401                                  ADD_NAME_RET:
  7402 000016C6 5E                      		pop	si
  7403 000016C7 803E[B844]00            		cmp	byte [COMSPEC_FLAG],0 ; If the new env var is comspec,	
  7404                                  ADD_NAME_JZ_RET:
  7405 000016CC 7493                    		jz	short ADD_PROMPT_RETN 
  7406                                  					;  copy the value into the
  7407                                  					;  comspec var in the resident
  7408                                  
  7409                                  ; We have changed the COMSPEC variable. We need to update the resident
  7410                                  ; pieces necessary to reread in the info. First, skip all delimiters
  7411                                  
  7412 000016CE E87502                  		call	SCANOFF
  7413 000016D1 8E06[8141]              		mov	es,[RESSEG]	;  comspec var in the resident
  7414                                  
  7415                                  ; Make sure that the printer knows where the beginning of the string is
  7416                                  
  7417 000016D5 BF950B                  		mov	di,COMSPEC
  7418 000016D8 89FB                    		mov	bx,di
  7419                                  
  7420                                  ; Generate drive letter for display
  7421                                  
  7422 000016DA 31C0                    		xor	ax,ax		;g assume no drive first
  7423 000016DC 26A2E00B                		mov	[es:COMDRV],al ;g
  7424 000016E0 807C013A                		cmp	byte [si+1],':'	 ; drive specified?
  7425 000016E4 7512                    		jnz	short _GOTDRIVE
  7426 000016E6 8A04                    		mov	al,[si]		; get his specified drive
  7427                                  		;call	UPCONV
  7428 000016E8 E80901                  		call	UPCONV_MAPCALL	; convert to uppercase
  7429 000016EB 2C41                    		sub	al,'A'		; convert to 0-based
  7430 000016ED 83C702                  		add	di,2
  7431 000016F0 FEC0                    		inc	al		; convert to 1-based number
  7432 000016F2 26A2E00B                		mov	[es:COMDRV],al
  7433                                  
  7434                                  ; Stick the drive letter in the prompt message. Nothing special needs to be
  7435                                  ; done here..
  7436                                  		;add	al,40h
  7437 000016F6 0440                    		add	al,'A'-1
  7438                                  _GOTDRIVE:
  7439                                  		;mov	[es:0BD9h],di ; MSDOS 3.3 COMMAND.COM offset 1734h
  7440 000016F8 26893ED50B              		mov	[es:PUTBACKSUBSTPTR],di
  7441                                  					;g point to beginning of name after drive
  7442                                  		;mov	[es:0A21h],al ; MSDOS 3.3 COMMAND.COM offset 1739h
  7443 000016FD 26A21D0A                		mov	[es:PUTBACKDRV],al ; MSDOS 3.3 COMMAND
  7444                                  
  7445                                  ; Copy chars until delim      	
  7446                                  
  7447 00001701 89DF                    		mov	di,bx
  7448                                  COPY_COMSPEC:
  7449 00001703 AC                      		lodsb
  7450 00001704 E84702                  		call	DELIM
  7451 00001707 7407                    		jz	short COPYDONE
  7452 00001709 3C0D                    		cmp	al,13
  7453 0000170B 7403                    		jz	short COPYDONE
  7454 0000170D AA                      		stosb
  7455 0000170E EBF3                    		jmp	short COPY_COMSPEC
  7456                                  COPYDONE:
  7457 00001710 30C0                    		xor	al,al		; Null terminate the string and quit
  7458 00001712 AA                      		stosb
  7459 00001713 C606[B844]00            		mov	byte [COMSPEC_FLAG],0
  7460 00001718 4F                      		dec	di
  7461 00001719 26893ED70B              		mov	[es:COMSPEC_END],di
  7462 0000171E C3                      		retn
  7463                                  DISP_ENV:
  7464 0000171F 8E1E[8141]              		mov	ds,[RESSEG]
  7465 00001723 8E1EFF0C                		mov	ds,[ENVIRSEG]
  7466                                  		; assume ds:nothing
  7467 00001727 31F6                    		xor	si,si
  7468                                  PENVLP:
  7469 00001729 803C00                  		cmp	byte [si],0
  7470 0000172C 749E                    		jz	short ADD_NAME_JZ_RET
  7471 0000172E BF[D842]                		mov	di,ARG_BUF
  7472                                  PENVLP2:
  7473 00001731 AC                      		lodsb
  7474 00001732 AA                      		stosb
  7475 00001733 08C0                    		or	al,al
  7476 00001735 75FA                    		jnz	short PENVLP2
  7477 00001737 BA[5336]                		mov	dx,ARG_BUF_PTR
  7478 0000173A 1E                      		push	ds
  7479 0000173B 06                      		push	es
  7480 0000173C 1F                      		pop	ds
  7481                                  		; assume ds:nothing
  7482 0000173D E8D91C                  		call	PRINTF_CRLF
  7483 00001740 1F                      		pop	ds
  7484 00001741 EBE6                    		jmp	short PENVLP
  7485                                  
  7486                                  ; =============== S U B	R O U T	I N E =======================================
  7487                                  
  7488                                  DELETE_PATH:
  7489 00001743 BE[3D3B]                		mov	si,PATH_TEXT ; "PATH="
  7490 00001746 EB03                    		jmp	short DELETE_NAME_IN_ENVIRONMENT
  7491                                  
  7492                                  ; =============== S U B	R O U T	I N E =======================================
  7493                                  
  7494                                  DELETE_PROMPT:
  7495 00001748 BE[423B]                		mov	si,PROMPT_TEXT ; "PROMPT="
  7496                                  
  7497                                  ; ---------------------------------------------------------------------------
  7498                                  
  7499                                  DELETE_NAME_IN_ENVIRONMENT:
  7500                                  
  7501                                  ; Input: DS:SI points to a "=" terminated string
  7502                                  ; Output: carry flag is set if name not found
  7503                                  ;	  otherwise name is deleted
  7504                                  
  7505 0000174B 56                      		push	si
  7506 0000174C 1E                      		push	ds
  7507 0000174D E82400                  		call	FIND		; ES:DI points to name
  7508 00001750 7210                    		jc	short DEL1
  7509 00001752 89FE                    		mov	si,di		; Save it
  7510 00001754 E89500                  		call	SCASB2		; Scan for the nul
  7511 00001757 87F7                    		xchg	si,di
  7512                                  ;SR;
  7513                                  ; If we have only one env string, then the double null is lost when the last
  7514                                  ;string is deleted and we have an invalid empty environment with only a 
  7515                                  ;single null. To avoid this, we will look for the double null case and then
  7516                                  ;move an extra null char.
  7517                                  ; Bugbug: The only possible problem is that the last pathstring 
  7518                                  ;will be followed by a triple null. Is this really a problem?
  7519                                  
  7520                                  		; MSDOS 6.0
  7521                                  		;cmp	byte ptr es:[si],0 ;null char?
  7522                                  		;jnz	not_dnull	   ;no, we are at a double null
  7523                                  		;dec	si		   ;point at the double null
  7524                                  ;not_dnull:
  7525                                  		; MSDOS 3.3 (& MSDOS 6.0)
  7526 00001759 E8F000                  		call	GETENVSIZ
  7527 0000175C 29F1                    		sub	cx,si
  7528 0000175E 06                      		push	es
  7529 0000175F 1F                      		pop	ds		; ES:DI points to name
  7530                                  					; DS:SI points to next name
  7531 00001760 F3A4                    		rep movsb
  7532                                  DEL1:
  7533 00001762 1F                      		pop	ds
  7534 00001763 5E                      		pop	si
  7535                                  FIND_RETN:
  7536 00001764 C3                      		retn
  7537                                  
  7538                                  ; =============== S U B	R O U T	I N E =======================================
  7539                                  
  7540                                  FIND_PATH:
  7541 00001765 BE[3D3B]                		mov	si,PATH_TEXT ; "PATH="
  7542 00001768 EB03                    		jmp	short FIND_NAME_IN_ENVIRONMENT
  7543                                  
  7544                                  
  7545                                  ; =============== S U B	R O U T	I N E =======================================
  7546                                  
  7547                                  FIND_PROMPT:
  7548 0000176A BE[423B]                		mov	si,PROMPT_TEXT ; "PROMPT="
  7549                                  
  7550                                  ; ---------------------------------------------------------------------------
  7551                                  
  7552                                  FIND_NAME_IN_ENVIRONMENT:
  7553                                  
  7554                                  ; Input: DS:SI points to a "=" terminated string
  7555                                  ; Output: ES:DI points to the arguments in the environment
  7556                                  ;	  zero is set if name not found
  7557                                  ;	  carry flag is set if name not valid format
  7558                                  
  7559 0000176D E80400                  		call	FIND		; Find the name
  7560 00001770 72F2                    		jc	short FIND_RETN	; Carry means not found	
  7561 00001772 EB74                    		jmp	short SCASB1	; Scan for = sign
  7562                                  
  7563                                  ; ---------------------------------------------------------------------------
  7564                                  		;nop
  7565                                  
  7566                                  ; =============== S U B	R O U T	I N E =======================================
  7567                                  
  7568                                  ; On return of FIND1, ES:DI points to beginning of name
  7569                                  
  7570                                  FIND:
  7571 00001774 FC                      		cld
  7572 00001775 E82D00                  		call	COUNT0		; CX = Length of name
  7573 00001778 8E06[8141]              		mov	es,[RESSEG]
  7574                                  		; assume es:RESGROUP
  7575 0000177C 268E06FF0C              		mov	es,[es:ENVIRSEG]
  7576                                  		; assume es:NOTHING
  7577 00001781 31FF                    		xor	di,di
  7578                                  FIND1:	
  7579 00001783 51                      		push	cx
  7580 00001784 56                      		push	si
  7581 00001785 57                      		push	di
  7582                                  FIND11:
  7583 00001786 AC                      		lodsb
  7584                                  		;call	UPCONV
  7585 00001787 E86A00                  		call	UPCONV_MAPCALL
  7586 0000178A 47                      		inc	di
  7587 0000178B 263A45FF                		cmp	al,[es:di-1]
  7588 0000178F 7502                    		jnz	short FIND12
  7589 00001791 E2F3                    		loop	FIND11
  7590                                  FIND12:
  7591 00001793 5F                      		pop	di
  7592 00001794 5E                      		pop	si
  7593 00001795 59                      		pop	cx
  7594 00001796 74CC                    		jz	short FIND_RETN
  7595 00001798 51                      		push	cx
  7596 00001799 E85000                  		call	SCASB2		; Scan for a nul
  7597 0000179C 59                      		pop	cx
  7598 0000179D 26803D00                		cmp	byte [es:di],0
  7599 000017A1 75E0                    		jnz	short FIND1
  7600 000017A3 F9                      		stc			; Indicate not found
  7601 000017A4 C3                      		retn
  7602                                  
  7603                                  ; =============== S U B	R O U T	I N E =======================================
  7604                                  
  7605                                  COUNT0:
  7606 000017A5 1E                      		push	ds
  7607 000017A6 07                      		pop	es
  7608                                  		; assume es:nothing
  7609 000017A7 89F7                    		mov	di,si
  7610                                  ;COUNT1:
  7611 000017A9 57                      		push	di		; Count number of chars until "="
  7612 000017AA E83B00                  		call	SCASB1
  7613                                  		; 24/02/2023
  7614                                  		;jmp	short COUNTX
  7615                                  ;COUNT2:
  7616                                  ;		push	di		; Count number of chars until nul
  7617                                  ;		call	SCASB2
  7618                                  ;COUNTX:
  7619 000017AD 59                      		pop	cx
  7620 000017AE 29CF                    		sub	di,cx
  7621 000017B0 87F9                    		xchg	di,cx
  7622                                  MOVE_NAME_RETN:
  7623 000017B2 C3                      		retn
  7624                                  
  7625                                  ; =============== S U B	R O U T	I N E =======================================
  7626                                  
  7627                                  MOVE_NAME:
  7628 000017B3 803C0D                  		cmp	byte [si],13
  7629 000017B6 74FA                    		jz	short MOVE_NAME_RETN
  7630 000017B8 AC                      		lodsb
  7631                                  		;call	UPCONV
  7632 000017B9 E83800                  		call	UPCONV_MAPCALL
  7633 000017BC E84500                  		call	STORE_CHAR
  7634 000017BF 3C3D                    		cmp	al,'='
  7635 000017C1 75F0                    		jnz	short MOVE_NAME
  7636                                  GETARG_RETN:
  7637 000017C3 C3                      		retn
  7638                                  
  7639                                  ; =============== S U B	R O U T	I N E =======================================
  7640                                  
  7641                                  GETARG:
  7642 000017C4 BE8000                  		mov	si,80h
  7643 000017C7 AC                      		lodsb
  7644 000017C8 08C0                    		or	al,al
  7645 000017CA 74F7                    		jz	short GETARG_RETN
  7646 000017CC E87701                  		call	SCANOFF
  7647 000017CF 3C0D                    		cmp	al,13
  7648                                  SDN_RETN:
  7649 000017D1 C3                      		retn
  7650                                  
  7651                                  ; =============== S U B	R O U T	I N E =======================================
  7652                                  
  7653                                  ; Point ES:DI to the final NULL string. Note that in an empty environment,
  7654                                  ; there is NO double NULL, merely a string that is empty.
  7655                                  
  7656                                  SCAN_DOUBLE_NULL:
  7657 000017D2 8E06[8141]              		mov	es,[RESSEG]
  7658                                  		; ASSUME ES:RESGROUP
  7659 000017D6 268E06FF0C              		mov	es,[es:ENVIRSEG]
  7660                                  		; ASSUME ES:NOTHING
  7661 000017DB 31FF                    		xor	di,di
  7662                                  
  7663                                  ; Top cycle-point. If the string here is empty, then we are done
  7664                                  
  7665                                  SDN1:
  7666 000017DD 26803D00                		cmp	byte [es:di],0	; nul string?
  7667 000017E1 74EE                    		jz	short SDN_RETN	; yep, all done
  7668 000017E3 E80600                  		call	SCASB2
  7669 000017E6 EBF5                    		jmp	short SDN1
  7670                                  
  7671                                  ; =============== S U B	R O U T	I N E =======================================
  7672                                  
  7673                                  SCASB1:
  7674 000017E8 B03D                    		mov	al,'='		; Scan for an =
  7675 000017EA EB02                    		jmp	short SCASBX
  7676                                  
  7677                                  ; =============== S U B	R O U T	I N E =======================================
  7678                                  
  7679                                  SCASB2:
  7680 000017EC 30C0                    		xor	al,al		; Scan for a nul
  7681                                  
  7682                                  ; ---------------------------------------------------------------------------
  7683                                  
  7684                                  SCASBX:
  7685 000017EE B90001                  		mov	cx,256
  7686 000017F1 F2AE                    		repne scasb
  7687 000017F3 C3                      		retn
  7688                                  
  7689                                  ; =============== S U B	R O U T	I N E =======================================
  7690                                  
  7691                                  ; MSDOS 6.0
  7692                                  
  7693                                  ; ****************************************************************
  7694                                  ; *
  7695                                  ; * ROUTINE:	 UPCONV     (ADDED BY EMG 4.00)
  7696                                  ; *
  7697                                  ; * FUNCTION:	 This routine returns the upper case equivalent of
  7698                                  ; *		 the character in AL from the file upper case table
  7699                                  ; *		 in DOS if character if above  ascii 128, else
  7700                                  ; *		 subtracts 20H if between "a" and "z".
  7701                                  ; *
  7702                                  ; * INPUT:	 AL	      char to be upper cased
  7703                                  ; *		 FUCASE_ADDR  set to the file upper case table
  7704                                  ; *
  7705                                  ; * OUTPUT:	 AL	      upper cased character
  7706                                  ; *
  7707                                  ; ****************************************************************
  7708                                  
  7709                                  ;assume	ds:trangroup			;AN000;
  7710                                  ;
  7711                                  ;upconv	proc	near			;AN000;
  7712                                  ;
  7713                                  ;	cmp	al,80h			;AN000;  see if char is > ascii 128
  7714                                  ;	jb	oth_fucase		;AN000;  no - upper case math
  7715                                  ;	sub	al,80h			;AN000;  only upper 128 chars in table
  7716                                  ;	push	ds			;AN000;
  7717                                  ;	push	bx			;AN000;
  7718                                  ;	mov	ds,[resseg]		;AN000;  get resident data segment
  7719                                  ;assume	ds:resgroup			;AN000;
  7720                                  ;	lds	bx,dword ptr fucase_addr+1 ;AN000;  get table address
  7721                                  ;	add	bx,2			;AN000;  skip over first word
  7722                                  ;	xlat	ds:byte ptr [bx]	;AN000;  convert to upper case
  7723                                  ;	pop	bx			;AN000;
  7724                                  ;	pop	ds			;AN000;
  7725                                  ;assume	ds:trangroup			;AN000;
  7726                                  ;	jmp	short upconv_end	;AN000;  we finished - exit
  7727                                  ;
  7728                                  ;oth_fucase:				;AN000;
  7729                                  ;	cmp	al,small_a		;AC000; if between "a" and "z",
  7730                                  ;	jb	upconv_end		;AC000;     subtract 20h to get
  7731                                  ;	cmp	al,small_z		;AC000;    upper case equivalent.
  7732                                  ;	ja	upconv_end		;AC000;
  7733                                  ;	sub	al,20h			;AC000; Change lower-case to upper
  7734                                  ;
  7735                                  ;upconv_end:				;AN000;
  7736                                  ;	ret
  7737                                  ;
  7738                                  ;upconv	endp				;AN000;
  7739                                  
  7740                                  ; ---------------------------------------------------------------------------
  7741                                  
  7742                                  ; MSDOS 3.3
  7743                                  
  7744                                  UPCONV_MAPCALL:
  7745                                  					; If between "a" and "z"
  7746                                  		;cmp	al,[small_a]
  7747                                  		; 01/03/2023
  7748 000017F4 3C61                    		cmp	al,'a' ; small_a
  7749 000017F6 7206                    		jb	short UPCONV_END
  7750                                  		;cmp	al,[small_z]
  7751 000017F8 3C7A                    		cmp	al,'z' ; small_z
  7752 000017FA 7702                    		ja	short UPCONV_END
  7753 000017FC 2C20                    		sub	al,20h		; Change lower-case to upper
  7754                                  UPCONV_END:
  7755 000017FE 2EFF1E[1A4C]            		call	far [cs:MAP_CALL] ; (far) call to char mapping routine 
  7756                                  					  ; 	  for (current) country
  7757 00001803 C3                      		retn
  7758                                  
  7759                                  ; =============== S U B	R O U T	I N E =======================================
  7760                                  
  7761                                  ; STORE A CHAR IN environment, GROWING IT IF NECESSARY
  7762                                  
  7763                                  STORE_CHAR:
  7764 00001804 51                      		push	cx
  7765 00001805 53                      		push	bx
  7766                                  
  7767                                  		; 16/10/2018
  7768                                  		; MSDOS 6.0
  7769                                  		;PUSH	ES		;AN056;*
  7770                                  		;PUSH	DS		;AN056; Save local DS
  7771                                  		;MOV	DS,[RESSEG]	;AN056; Get resident segment
  7772                                  		;;ASSUME DS:RESGROUP	;AN056;
  7773                                  		;MOV	ES,[ENVIRSEG]	;AN056; Get environment segment
  7774                                  		;; ASSUME ES:NOTHING	;AN056;
  7775                                  		;POP	DS		;AN056; Get local segment back
  7776                                  		;; ASSUME DS:TRANGROUP	;AN056;
  7777                                  
  7778                                  		; MSDOS 3.3 (& MSDOS 6.0)
  7779 00001806 E84300                  		call	GETENVSIZ
  7780 00001809 89CB                    		mov	bx,cx		; Save room for double nul	
  7781 0000180B 83EB02                  		sub	bx,2
  7782 0000180E 39DF                    		cmp	di,bx
  7783 00001810 7231                    		jb	short STORE1
  7784                                  
  7785 00001812 50                      		push	ax
  7786 00001813 51                      		push	cx
  7787 00001814 53                      		push	bx		; Save Size of environment
  7788 00001815 E845EE                  		call	FREE_TPA
  7789 00001818 5B                      		pop	bx
  7790 00001819 83C302                  		add	bx,2		; Recover true environment size
  7791                                  
  7792 0000181C 81FB0080                		cmp	bx,8000h	; Don't let environment grow > 32K	
  7793 00001820 7203                    		jb	short ENVSIZ_OK
  7794                                  BAD_ENV_SIZE:				;AN056;
  7795 00001822 F9                      		stc
  7796 00001823 EB09                    		jmp	short ENVNOSET
  7797                                  
  7798                                  		;nop
  7799                                  ENVSIZ_OK:
  7800 00001825 B104                    		mov	cl,4
  7801 00001827 D3EB                    		shr	bx,cl		; Convert back to paragraphs
  7802 00001829 43                      		inc	bx
  7803                                  
  7804                                  		; MSDOS 6.0
  7805                                  		;MOV	CX,ES		;AN056; Get environment segment
  7806                                  		;ADD	CX,BX		;AN056; Add in size of environment
  7807                                  		;ADD	CX,020H 	;AN056; Add in some TPA
  7808                                  		;MOV	AX,CS		;AN056; Get the transient segment
  7809                                  		;CMP	CX,AX		;AN056; Are we hitting the transient?
  7810                                  		;JNB	BAD_ENV_SIZE	;AN056; Yes - don't do it!!!
  7811                                  
  7812                                  		; MSDOS 3.3 (& MSDOS 6.0)
  7813 0000182A B44A                    		mov	ah,SETBLOCK ; 4Ah
  7814 0000182C CD21                    		int	21h	; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
  7815                                  				; ES = segment address of block	to change
  7816                                  				; BX = new size	in paragraphs
  7817                                  ENVNOSET:
  7818 0000182E 9C                      		pushf
  7819 0000182F 06                      		push	es
  7820 00001830 8E06[8141]              		mov	es,[RESSEG]
  7821                                  		;ASSUME ES:RESGROUP
  7822 00001834 E836EE                  		call	ALLOC_TPA
  7823 00001837 07                      		pop	es
  7824 00001838 9D                      		popf
  7825 00001839 59                      		pop	cx
  7826 0000183A 58                      		pop	ax
  7827                                  		;POP	ES	; MSDOS 6.0 ;AN056;*	
  7828 0000183B 7306                    		jnc	short STORE1
  7829 0000183D BA[8637]                		mov	dx,ENVERRPTR
  7830 00001840 E9A703                  		jmp	CERROR
  7831                                  
  7832                                  STORE1:	
  7833 00001843 AA                      		stosb
  7834 00001844 26C7050000              		mov	word [es:di],0	; NULL IS AT END
  7835                                  		;POP	ES	; MSDOS 6.0 ;AN056;*
  7836 00001849 5B                      		pop	bx
  7837 0000184A 59                      		pop	cx
  7838 0000184B C3                      		retn
  7839                                  
  7840                                  ; =============== S U B	R O U T	I N E =======================================
  7841                                  
  7842                                  GETENVSIZ:
  7843                                  
  7844                                  ;Get size of environment in bytes, rounded up to paragraph boundry
  7845                                  ;ES has environment segment
  7846                                  ;Size returned in CX, all other registers preserved
  7847                                  
  7848 0000184C 06                      		push	es
  7849 0000184D 50                      		push	ax
  7850 0000184E 8CC0                    		mov	ax,es
  7851 00001850 48                      		dec	ax	;Point at arena	
  7852 00001851 8EC0                    		mov	es,ax
  7853 00001853 26A10300                		mov	ax,[es:ARENA.size]
  7854 00001857 B104                    		mov	cl,4
  7855 00001859 D3E0                    		shl	ax,cl	;Convert to bytes
  7856 0000185B 89C1                    		mov	cx,ax
  7857 0000185D 58                      		pop	ax
  7858 0000185E 07                      		pop	es
  7859                                  GETENVSIZ_RETN:
  7860 0000185F C3                      		retn
  7861                                  
  7862                                  ; =============== S U B	R O U T	I N E =======================================
  7863                                  
  7864                                  RESTUDIR1:
  7865 00001860 1E                      		push	ds
  7866 00001861 8E1E[8141]              		mov	ds,[RESSEG]
  7867                                  		;ASSUME	DS:RESGROUP
  7868 00001865 803EED0B00              		cmp	byte [RESTDIR],0
  7869 0000186A 1F                      		pop	ds
  7870                                  		;ASSUME	DS:TRANGROUP
  7871 0000186B 74F2                    		jz	short GETENVSIZ_RETN
  7872                                  
  7873                                  ; =============== S U B	R O U T	I N E =======================================
  7874                                  
  7875                                  RESTUDIR:
  7876 0000186D BA[6340]                		mov	dx,USERDIR1
  7877 00001870 B43B                    		mov	ah,CHDIR ; 3Bh
  7878 00001872 CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  7879                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  7880 00001874 30C0                    		xor	al,al
  7881                                  		;call	SETREST
  7882                                  		;retn
  7883                                  		; 02/03/2023
  7884 00001876 E94206                  		jmp	SETREST
  7885                                  
  7886                                  ;============================================================================
  7887                                  ; TENV2.ASM, MSDOS 6.0, 1991
  7888                                  ;============================================================================
  7889                                  ; 07/10/2018 - Retro DOS v3.0
  7890                                  
  7891                                  ; TITLE	Part6 COMMAND Transient routines.
  7892                                  
  7893                                  ;	Environment utilities and misc. routines
  7894                                  
  7895                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 18C2h
  7896                                  
  7897                                  ; ---------------------------------------------------------------------------
  7898                                  
  7899                                  ; ****************************************************************
  7900                                  ; *
  7901                                  ; * ROUTINE:	 $CHDIR
  7902                                  ; *
  7903                                  ; * FUNCTION:	 Entry point for CHDIR command. Parse the command
  7904                                  ; *		 line. If path is found, CHDIR to path. If a drive
  7905                                  ; *		 letter is found, get and display the current dir
  7906                                  ; *		 of the specified drive. If nothing is found, get
  7907                                  ; *		 and display the current dir of the default drive.
  7908                                  ; *
  7909                                  ; * INPUT:	 command line at offset 81H
  7910                                  ; *
  7911                                  ; * OUTPUT:	 none
  7912                                  ; *
  7913                                  ; ****************************************************************
  7914                                  
  7915                                  _$CHDIR:
  7916                                  		; MSDOS 6.0
  7917                                  		;mov	si,81H
  7918                                  		;mov	di,offset trangroup:parse_chdir 
  7919                                  		;			;AN000; Get address of PARSE_CHDIR
  7920                                  		;xor	cx,cx		;AN000; clear cx,dx
  7921                                  		;xor	dx,dx		;AN000;
  7922                                  		;invoke	parse_with_msg	;AC018; call parser
  7923                                  
  7924                                  		;cmp	ax,end_of_line	;AC000; are we at end of line?
  7925                                  		;jz	bwdJ		; No args
  7926                                  		;cmp	ax,result_no_error ;AC000; did we have an error?
  7927                                  		;jnz	ChDirErr	;AC018; yes - exit
  7928                                  
  7929                                  		;cmp	parse1_type,result_drive ;AC000; was a drive entered?
  7930                                  		;jnz	REALCD		; no
  7931                                  ;;
  7932                                  ;; D: was found. See if there is anything more.
  7933                                  ;;
  7934                                  		;mov	di,offset trangroup:parse_chdir 
  7935                                  					;AC000; get address of parse_chdir
  7936                                  		;xor	dx,dx		;AC000;
  7937                                  		;invoke	parse_check_eol ;AC000; call parser
  7938                                  		;jnz	ChDirErr	;AC000;
  7939                                  	;bwdJ:
  7940                                  		;invoke	build_dir_for_chdir ; Drive only specified
  7941                                  		;call	crlf2
  7942                                  		;return
  7943                                  
  7944                                  		; MSDOS 3.3
  7945 00001879 A1[9841]                		mov	ax,[COMSW]
  7946 0000187C 0B06[9E41]              		or	ax,[ALLSWITCH]
  7947 00001880 BA[5239]                		mov	dx,BADPARMPTR
  7948 00001883 7532                    		jnz	short CHDIRERR
  7949 00001885 BE8100                  		mov	si,81h
  7950 00001888 E8BB00                  		call	SCANOFF
  7951 0000188B 3C0D                    		cmp	al,0Dh		; are we at end of line?
  7952 0000188D 740F                    		je	short BWDJ	; No args
  7953 0000188F 46                      		inc	si
  7954 00001890 AC                      		lodsb
  7955 00001891 3C3A                    		cmp	al,':'
  7956 00001893 750F                    		jne	short REALCD
  7957 00001895 56                      		push	si
  7958 00001896 E8AD00                  		call	SCANOFF
  7959 00001899 5E                      		pop	si
  7960 0000189A 3C0D                    		cmp	al,0Dh		; was a drive entered?
  7961 0000189C 7506                    		jne	short REALCD	; no
  7962                                  BWDJ:
  7963 0000189E E87CFB                  		call	BUILD_DIR_FOR_CHDIR ; Drive only specified
  7964                                  		;call	CRLF2
  7965                                  ;CHDIR_RETN:
  7966                                  		;retn
  7967                                  		; 02/03/2023
  7968 000018A1 E99500                  		jmp	CRLF2
  7969                                  
  7970                                  
  7971                                  		; MSDOS 6.0
  7972                                  ;REALCD:
  7973                                  		;push	si		;AN000; save position in line
  7974                                  		;lds	si,parse1_addr	;AN000; get address of filespec
  7975                                  		;invoke	move_to_srcbuf	;AN000; move to srcbuf
  7976                                  		;pop	si		;AN000; restore position in line
  7977                                  		;mov	di,offset trangroup:parse_chdir 
  7978                                  		;			;AC000; get address of parse_chdir
  7979                                  		;xor	dx,dx		;AC000;
  7980                                  		;invoke	parse_check_eol ;AC000; call parser
  7981                                  		;jnz	ChDirErr	;AC000;
  7982                                  		;
  7983                                  		;invoke	SETPATH
  7984                                  		;TEST	[DESTINFO],2
  7985                                  		;JNZ	BadChdir
  7986                                  		;MOV	AH,CHDIR
  7987                                  		;INT	21h
  7988                                  		;retnc
  7989                                  		;
  7990                                  		;invoke	get_ext_error_number
  7991                                  		;			;AN022; get the extended error
  7992                                  		;cmp	ax,error_path_not_found
  7993                                  		;			;AN022; see if path not found
  7994                                  		;jz	BadChDir	;AN022; yes - issue old message
  7995                                  ;;SR;
  7996                                  ;; We want to issue "Invalid Directory" message even if the path is valid
  7997                                  ;;but is not a directory. The extended error returns "Access denied" which
  7998                                  ;;is kind of confusing. Issue the old message if access denied error is 
  7999                                  ;;returned
  8000                                  ;;
  8001                                  		;cmp	ax,error_access_denied
  8002                                  		;jz	BadChDir
  8003                                  		;
  8004                                  		;call	Set_Ext_Error_Subst ;AN022;
  8005                                  		;jmp	short  chdirerr ;AN022;
  8006                                  ;BadChDir:
  8007                                  		;MOV	DX,OFFSET TRANGROUP:BADCD_ptr
  8008                                  ;ChDirErr:
  8009                                  		;invoke	Std_Eprintf
  8010                                  		;return
  8011                                  
  8012                                  		; MSDOS 3.3
  8013                                  REALCD:
  8014 000018A4 E88104                  		call	SETPATH
  8015 000018A7 F606[8043]02            		test	byte [DESTINFO],2
  8016 000018AC 7506                    		jnz	short BADCHDIR
  8017 000018AE B43B                    		mov	ah,CHDIR ; 3Bh
  8018 000018B0 CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  8019                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  8020 000018B2 7306                    		jnc	short CHDIR_RETN
  8021                                  BADCHDIR:
  8022 000018B4 BA[A63A]                		mov	dx,BADCDPTR
  8023                                  CHDIRERR:
  8024                                  MKDIRERR:	; 02/03/2023
  8025 000018B7 E8651B                  		call	STD_EPRINTF
  8026                                  MKDIR_RETN:
  8027                                  CHDIR_RETN:	; 02/03/2023
  8028 000018BA C3                      		retn
  8029                                  
  8030                                  ; ---------------------------------------------------------------------------
  8031                                  
  8032                                  _$MKDIR:
  8033                                  		; MSDOS 6.0
  8034                                  		;CALL	SETRMMK
  8035                                  		;JC	MkDirErr
  8036                                  		;MOV	AH,MKDIR
  8037                                  		;INT	21h
  8038                                  		;retnc
  8039                                  
  8040                                  		;invoke	get_ext_error_number	
  8041                                  		;			;AN022; get the extended error
  8042                                  		;cmp	ax,error_path_not_found 
  8043                                  		;			;AN022; see if path not found
  8044                                  		;jz	MD_other_err	;AN022; yes - issue old message
  8045                                  		;cmp	ax,error_access_denied
  8046                                  		;			;AN022; access denied?
  8047                                  		;jz	badmderr	;AN022; yes - see if file exists
  8048                                  		
  8049                                  		;call	Set_Ext_Error_Subst ;AN022;
  8050                                  		;jmp	short MkDirerr	;AC022; yes - go print it
  8051                                  ;BADMDERR:
  8052                                  		;mov	dx,offset trangroup:srcxname	
  8053                                  		;			;AN006; Set Disk transfer address
  8054                                  		;mov	ah,Set_DMA	;AN006;
  8055                                  		;int	21h		;AN006;
  8056                                  		;MOV	AH,Find_First	;AN006; see if file/dir exists
  8057                                  		;mov	cx,attr_directory ;AN006;   search for directory
  8058                                  		;INT	21h		;AN006;
  8059                                  		;jc	MD_other_err	;AN006; doesn't exist - must be something else
  8060                                  		;mov	dl,srcxname.find_buf_attr ;AN006; we found a file/dir
  8061                                  		;test	dl,attr_directory ;AN006; was it a directory?
  8062                                  		;jz	MD_other_err	;AN006; no - must have been a file
  8063                                  		;mov	dx,offset trangroup:MD_exists_ptr 
  8064                                  		;			;AN006; set up already exists error
  8065                                  		;jmp	short MkDirErr	;AN006; make sure we didn't have network error
  8066                                  ;MD_other_err:				;AN006;
  8067                                  		;MOV	DX,OFFSET TRANGROUP:BADMKD_ptr
  8068                                  ;MkDirErr:
  8069                                  		;invoke	Std_Eprintf
  8070                                  		;return
  8071                                  
  8072                                  		; MSDOS 3.3
  8073 000018BB E81000                  		call	SETRMMK
  8074 000018BE 72F7                    		jb	short MKDIRERR
  8075 000018C0 B439                    		mov	ah,MKDIR ; 39h
  8076 000018C2 CD21                    		int	21h	; DOS -	2+ - CREATE A SUBDIRECTORY (MKDIR)
  8077                                  				; DS:DX	-> ASCIZ pathname (may include drive)
  8078 000018C4 73F4                    		jnc	short MKDIR_RETN
  8079 000018C6 BA[C53A]                		mov	dx,BADMKDPTR
  8080 000018C9 E8AD05                  		call	GET_EXT_ERR_NUMBER
  8081                                  		; 02/03/2023
  8082 000018CC EBE9                    		jmp	short MKDIRERR
  8083                                  ;MKDIRERR:
  8084                                  		;call	STD_EPRINTF
  8085                                  		;retn
  8086                                  		
  8087                                  
  8088                                  ; =============== S U B	R O U T	I N E =======================================
  8089                                  
  8090                                  ; 	<Common MkDir/RmDir set up code>
  8091                                  ;****************************************************************
  8092                                  ;*
  8093                                  ;* ROUTINE:	SETRMMK
  8094                                  ;*
  8095                                  ;* FUNCTION:	Parse routine for the internal MKDIR and RMDIR
  8096                                  ;*		commands. Parses the command line for a required
  8097                                  ;*		filespec.
  8098                                  ;*
  8099                                  ;* INPUT:	command line at offset 81H
  8100                                  ;*
  8101                                  ;* OUTPUT:	carry clear
  8102                                  ;*		    DS:DX points to ASCIIZ argument
  8103                                  ;*		carry set
  8104                                  ;*		    DS:DX has error message pointer
  8105                                  ;*
  8106                                  ;****************************************************************
  8107                                  
  8108                                  		; MSDOS 6.0
  8109                                  		;mov	si,81H
  8110                                  		;mov	di,offset trangroup:parse_mrdir 
  8111                                  					;AN000; Get address of PARSE_MRDIR
  8112                                  		;xor	cx,cx		;AN000; clear cx,dx
  8113                                  		;xor	dx,dx		;AN000;
  8114                                  		;invoke	parse_with_msg	;AC000; call parser
  8115                                  		;cmp	ax,result_no_error ;AC000; did we have an error?
  8116                                  		;jnz	 NOARGERR	;AC000; yes - exit
  8117                                  
  8118                                  		;mov	di,offset trangroup:srcxname
  8119                                  		;			;AN000; get address of srcxname
  8120                                  		;push	di		;AN000; save address
  8121                                  		;push	si		;AN000; save position in line
  8122                                  		;lds	si,parse1_addr	;AN000; get address of path
  8123                                  
  8124                                  ;mrdir_move_filename:			;AN000; put filespec in srcxname
  8125                                  		;lodsb			;get a char from buffer
  8126                                  		;stosb			;AN000; store in srcxname
  8127                                  		;cmp	al,end_of_line_out ;AC000; it char a terminator?
  8128                                  		;jnz	mrdir_move_filename ;AC000; no - keep moving
  8129                                  		;pop	si		;AN000; get line position back
  8130                                  ;;
  8131                                  ;; we have scanned an argument.	See if any args beyond.
  8132                                  ;;
  8133                                  		;mov	di,offset trangroup:parse_mrdir 
  8134                                  		;			;AC000; get address of parse_mrdir
  8135                                  		;invoke	parse_check_eol ;AC000; are we at end of line?
  8136                                  		;pop	dx		;AC000; get address of SRCXNAME
  8137                                  		;retz			;yes - return no error
  8138                                  ;NOARGERR:
  8139                                  		;mov	dx,offset TranGroup:Extend_Buf_ptr
  8140                                  		;			;AC000; get extended message pointer
  8141                                  		;XOR	AX,AX
  8142                                  		;STC
  8143                                  		;return
  8144                                  
  8145                                  		; MSDOS 3.3
  8146                                  SETRMMK:
  8147 000018CE BE8100                  		mov	si,81h
  8148 000018D1 E87200                  		call	SCANOFF
  8149 000018D4 3C0D                    		cmp	al,0Dh
  8150 000018D6 741E                    		je	short NOARGERR
  8151 000018D8 89F2                    		mov	dx,si
  8152                                  SETRMMK1:
  8153 000018DA AC                      		lodsb
  8154 000018DB E87000                  		call	DELIM
  8155 000018DE 7409                    		jz	short SETRMMK3
  8156 000018E0 3C0D                    		cmp	al,0Dh
  8157 000018E2 75F6                    		jne	short SETRMMK1
  8158 000018E4 C644FF00                		mov	byte [si-1],0
  8159                                  SETRMMK2:
  8160 000018E8 C3                      		retn
  8161                                  SETRMMK3:
  8162 000018E9 C644FF00                		mov	byte [si-1],0
  8163 000018ED 56                      		push	si
  8164 000018EE E85500                  		call	SCANOFF
  8165 000018F1 5E                      		pop	si
  8166 000018F2 3C0D                    		cmp	al,0Dh
  8167 000018F4 74F2                    		je	short SETRMMK2
  8168                                  NOARGERR:
  8169 000018F6 BA[9D3C]                		mov	dx,BADARGSPTR
  8170 000018F9 31C0                    		xor	ax,ax
  8171 000018FB F9                      		stc
  8172                                  SETRMMK_RETN:
  8173                                  RMDIR_RETN:	; 02/03/2023
  8174 000018FC C3                      		retn
  8175                                  
  8176                                  ; ---------------------------------------------------------------------------
  8177                                  
  8178                                  _$RMDIR:
  8179 000018FD E8CEFF                  		call	SETRMMK
  8180 00001900 720E                    		jb	short RMDIRERR
  8181 00001902 7506                    		jnz	short BADRDERR
  8182 00001904 B43A                    		mov	ah,RMDIR ; 3Ah
  8183 00001906 CD21                    		int	21h	; DOS -	2+ - REMOVE A DIRECTORY	ENTRY (RMDIR)
  8184                                  				; DS:DX	-> ASCIZ pathname (may include drive)
  8185 00001908 73F2                    		jnc	short SETRMMK_RETN
  8186                                  
  8187                                  		; MSDOS 6.0
  8188                                  		;invoke	get_ext_error_number ;AN022; get the extended error
  8189                                  		;cmp	ax,error_path_not_found ;AN022; see if path not found
  8190                                  		;jz	badrderr	;AN022; yes - issue old message
  8191                                  		;cmp	ax,error_access_denied 	;AN022; access denied?
  8192                                  		;jz	badrderr	;AN022; yes - issue old message
  8193                                  
  8194                                  		;call	Set_Ext_Error_Subst ;AN022;
  8195                                  		;jmp	short RmDirerr	;AC022; yes - go print it
  8196                                  
  8197                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8198                                  BADRDERR:
  8199 0000190A BA[FE3A]                		mov	dx,BADRMDPTR
  8200 0000190D E86905                  		call	GET_EXT_ERR_NUMBER
  8201                                  RMDIRERR:
  8202                                  		;call	STD_EPRINTF
  8203                                  		; 02/03/2023
  8204 00001910 E90C1B                  		jmp	STD_EPRINTF
  8205                                  ;RMDIR_RETN:
  8206                                  		;retn
  8207                                  
  8208                                  ; =============== S U B	R O U T	I N E =======================================
  8209                                  
  8210                                  ; MSDOS 6.0
  8211                                  
  8212                                  ;****************************************************************
  8213                                  ;*
  8214                                  ;* ROUTINE:	Set_ext_error_subst
  8215                                  ;*
  8216                                  ;* FUNCTION:	Sets up substitution for extended error
  8217                                  ;*
  8218                                  ;* INPUT:	AX - extended error number
  8219                                  ;*		DX - offset of string
  8220                                  ;*
  8221                                  ;* OUTPUT:	Extend_Buf_Ptr set up for STD_EPRINTF
  8222                                  ;*
  8223                                  ;****************************************************************
  8224                                  
  8225                                  ;Set_ext_error_subst  proc near		;AN022;
  8226                                  ;
  8227                                  ;	mov	msg_disp_class,ext_msg_class
  8228                                  ;					;AN022; set up extended error msg class
  8229                                  ;	mov	string_ptr_2,dx 	;AN022; get address of failed string
  8230                                  ;	mov	Extend_buf_sub,one_subst 
  8231                                  ;					;AN022; put number of subst in control block
  8232                                  ;	mov	dx,offset TranGroup:Extend_Buf_ptr 
  8233                                  ;					;AN022; get extended message pointer
  8234                                  ;	mov	Extend_Buf_ptr,ax	;AN022; get message number in control block
  8235                                  ;
  8236                                  ;	ret				;AN022; return
  8237                                  ;
  8238                                  ;Set_ext_error_subst  endp		;AN022;
  8239                                  
  8240                                  ; =============== S U B	R O U T	I N E =======================================
  8241                                  
  8242                                  ; <SavUDir - preserve the users current directory on a particular drive>
  8243                                  
  8244                                  ; SavUDir - move the user's current directory on a drive into UserDir1
  8245                                  ; SavUDir1 - move the user's current directory on a drive into a specified
  8246                                  ;   buffer
  8247                                  ;
  8248                                  ;   Inputs:	DL has 1-based drive number
  8249                                  ;		ES:DI has destination buffer (SavUDir1 only)
  8250                                  ;   Outputs:	Carry Clear
  8251                                  ;		    DS = TranGroup
  8252                                  ;		Carry Set
  8253                                  ;		    AX has error code
  8254                                  ;   Registers Modified: AX, SI
  8255                                  
  8256                                  SAVUDIR:
  8257 00001913 BF[6340]                		mov	di,USERDIR1
  8258                                  
  8259                                  ; ---------------------------------------------------------------------------
  8260                                  
  8261                                  SAVUDIR1:
  8262 00001916 88D0                    		mov	al,dl
  8263 00001918 0440                    		add	al,'@'
  8264 0000191A 3C40                    		cmp	al,'@'
  8265 0000191C 7506                    		jnz	short GOTUDRV
  8266 0000191E 0206[9541]              		add	al,[CURDRV]
  8267 00001922 FEC0                    		inc	al		; A = 1
  8268                                  GOTUDRV:
  8269 00001924 AA                      		stosb
  8270 00001925 8A26[8641]              		mov	ah,[DIRCHAR]
  8271 00001929 B03A                    		mov	al,':'
  8272 0000192B AB                      		stosw
  8273 0000192C 06                      		push	es
  8274 0000192D 1F                      		pop	ds
  8275 0000192E 89FE                    		mov	si,di
  8276 00001930 B447                    		mov	ah,CURRENT_DIR	; 47h
  8277 00001932 CD21                    		int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
  8278                                  				; DL = drive (0=default,1=A,etc.)
  8279                                  				; DS:SI	points to 64-byte buffer area
  8280 00001934 72C6                    		jc	short RMDIR_RETN
  8281 00001936 0E                      		push	cs
  8282 00001937 1F                      		pop	ds
  8283 00001938 C3                      		retn
  8284                                  
  8285                                  ; =============== S U B	R O U T	I N E =======================================
  8286                                  
  8287                                  CRLF2:
  8288 00001939 52                      		push	dx
  8289 0000193A BA[BE3C]                		mov	dx,ACRLFPTR
  8290 0000193D 1E                      		push	ds
  8291 0000193E 0E                      		push	cs
  8292 0000193F 1F                      		pop	ds
  8293 00001940 E8E51A                  		call	STD_PRINTF
  8294 00001943 1F                      		pop	ds
  8295 00001944 5A                      		pop	dx
  8296 00001945 C3                      		retn
  8297                                  
  8298                                  ; =============== S U B	R O U T	I N E =======================================
  8299                                  
  8300                                  ; These routines (SCANOFF, DELIM) are called in batch processing when DS
  8301                                  ; may NOT be TRANGROUP
  8302                                  
  8303                                  SCANOFF:
  8304 00001946 AC                      		lodsb
  8305 00001947 E80400                  		call	DELIM
  8306 0000194A 74FA                    		jz	short SCANOFF
  8307 0000194C 4E                      		dec	si		; Point to first non-delimiter
  8308                                  SCANOFF_RETN:
  8309 0000194D C3                      		retn
  8310                                  
  8311                                  ; ---------------------------------------------------------------------------
  8312                                  
  8313                                  ; Input:    AL is character to classify
  8314                                  ; Output:   Z set if delimiter
  8315                                  ;	    NZ set otherwise
  8316                                  ; Registers modified: none
  8317                                  
  8318                                  DELIM:
  8319 0000194E 3C20                    		cmp	al,' '
  8320 00001950 74FB                    		jz	short SCANOFF_RETN
  8321 00001952 3C3D                    		cmp	al,'='
  8322 00001954 74F7                    		jz	short SCANOFF_RETN
  8323 00001956 3C2C                    		cmp	al,','
  8324 00001958 74F3                    		jz	short SCANOFF_RETN
  8325 0000195A 3C3B                    		cmp	al,';'
  8326 0000195C 74EF                    		jz	short SCANOFF_RETN
  8327 0000195E 3C09                    		cmp	al,9		; Check for TAB character
  8328 00001960 74EB                    		jz	short SCANOFF_RETN
  8329 00001962 3C0A                    		cmp	al,0Ah		; Check for line feed character - BAS
  8330 00001964 C3                      		retn
  8331                                  
  8332                                  
  8333                                  ; =============== S U B	R O U T	I N E =======================================
  8334                                  
  8335                                  FCB_TO_ASCZ:				; Convert DS:SI to ASCIZ ES:DI
  8336 00001965 B90800                  		mov	cx,8
  8337                                  MAINNAME:
  8338 00001968 AC                      		lodsb
  8339 00001969 3C20                    		cmp	al,' '
  8340 0000196B 7401                    		jz	short SKIPSPC
  8341 0000196D AA                      		stosb
  8342                                  SKIPSPC:
  8343 0000196E E2F8                    		loop	MAINNAME
  8344 00001970 AC                      		lodsb
  8345 00001971 3C20                    		cmp	al,' '
  8346 00001973 7412                    		jz	short GOTNAME
  8347 00001975 88C4                    		mov	ah,al
  8348                                  		;mov	al,'.'
  8349                                  		;mov	al,[DOT_CHR]
  8350                                  		; 01/03/2023
  8351 00001977 B02E                    		mov	al,dot_chr ; mov al,'.'
  8352 00001979 AA                      		stosb
  8353 0000197A 86C4                    		xchg	al,ah
  8354 0000197C AA                      		stosb
  8355 0000197D B102                    		mov	cl,2
  8356                                  EXTNAME:
  8357 0000197F AC                      		lodsb
  8358 00001980 3C20                    		cmp	al,' '
  8359 00001982 7403                    		jz	short GOTNAME
  8360 00001984 AA                      		stosb
  8361 00001985 E2F8                    		loop	EXTNAME
  8362                                  GOTNAME:
  8363 00001987 30C0                    		xor	al,al
  8364 00001989 AA                      		stosb
  8365                                  STRCOMP_RETN:
  8366 0000198A C3                      		retn
  8367                                  
  8368                                  ; =============== S U B	R O U T	I N E =======================================
  8369                                  
  8370                                  ; Compare ASCIZ DS:SI with ES:DI.
  8371                                  ; SI,DI destroyed.
  8372                                  
  8373                                  STRCOMP:	
  8374 0000198B A6                      		cmpsb
  8375 0000198C 75FC                    		jnz	short STRCOMP_RETN ; Strings not equal
  8376 0000198E 807CFF00                		cmp	byte [si-1],0	; Hit NUL terminator?	
  8377 00001992 74F6                    		jz	short STRCOMP_RETN ; Yes, strings equal
  8378 00001994 EBF5                    		jmp	short STRCOMP	; Equal so far, keep going
  8379                                  
  8380                                  ; =============== S U B	R O U T	I N E =======================================
  8381                                  
  8382                                  CRPRINT:
  8383 00001996 50                      		push	ax
  8384                                  		;mov	al,13
  8385 00001997 B00D                    		mov	al,0Dh
  8386 00001999 51                      		push	cx
  8387 0000199A 57                      		push	di
  8388 0000199B 89D7                    		mov	di,dx
  8389 0000199D B9FFFF                  		mov	cx,65535
  8390 000019A0 06                      		push	es
  8391 000019A1 1E                      		push	ds
  8392 000019A2 07                      		pop	es
  8393 000019A3 F2AE                    		repne scasb		; LOOK FOR TERMINATOR
  8394 000019A5 C645FF00                		mov	byte [di-1],0	; nul terminate the string
  8395 000019A9 07                      		pop	es
  8396 000019AA 8916[5E43]              		mov	[STRING_PTR_2],dx
  8397 000019AE BA[6F36]                		mov	dx,STRINGBUF2PTR
  8398 000019B1 E8741A                  		call	STD_PRINTF
  8399                                  		;mov	byte [di-1],13
  8400 000019B4 C645FF0D                		mov	byte [di-1],0Dh	; now put the CR back
  8401 000019B8 7204                    		jb	short ERROR_OUTPUT
  8402 000019BA 5F                      		pop	di
  8403 000019BB 59                      		pop	cx
  8404 000019BC 58                      		pop	ax
  8405 000019BD C3                      		retn
  8406                                  
  8407                                  ; ---------------------------------------------------------------------------
  8408                                  
  8409                                  ERROR_OUTPUT:
  8410 000019BE 0E                      		push	cs
  8411 000019BF 1F                      		pop	ds
  8412 000019C0 8E06[8141]              		mov	es,[RESSEG]
  8413 000019C4 BA[6937]                		mov	dx,NOSPACEPTR
  8414 000019C7 26803E560C00            		cmp	byte [es:PIPEFLAG],0
  8415 000019CD 7406                    		jz	short GO_TO_ERROR
  8416 000019CF E83E09                  		call	PIPEOFF
  8417 000019D2 BA[023C]                		mov	dx,PIPEEMESPTR
  8418                                  GO_TO_ERROR:
  8419 000019D5 E91202                  		jmp	CERROR
  8420                                  
  8421                                  ; =============== S U B	R O U T	I N E =======================================
  8422                                  
  8423                                  ;---- Mod for path invocation ----
  8424                                  
  8425                                  PATHCHRCMP:
  8426 000019D8 50                      		push	ax
  8427 000019D9 B42F                    		mov	ah,'/'
  8428 000019DB 3826[8541]              		cmp	[SWITCHAR],ah
  8429 000019DF 7404                    		jz	short NOSLASHT
  8430 000019E1 3C2F                    		cmp	al,'/'
  8431 000019E3 7402                    		jz	short PCCONT
  8432                                  NOSLASHT:
  8433 000019E5 3C5C                    		cmp	al,'\'
  8434                                  PCCONT:	
  8435 000019E7 58                      		pop	ax
  8436 000019E8 C3                      		retn
  8437                                  
  8438                                  ; =============== S U B	R O U T	I N E =======================================
  8439                                  
  8440                                  ; PATHCRUNCH -
  8441                                  ;
  8442                                  ; ENTRY FCB (in PSP) contains drive # to crunch on
  8443                                  ;       PathPos = ptr to string with pathname in it
  8444                                  ;       PathCnt = length of string
  8445                                  ;
  8446                                  ; EXIT  PathPos = ptr after pathname (w/ NULL) in string
  8447                                  ;       PathCnt = length left in string
  8448                                  ;       DestIsDir = nonzero if pathname delimiter char's found in pathname
  8449                                  ;       DestInfo<bit1> = set if wildcard char's found in pathname
  8450                                  ;       If path crunched successfully,
  8451                                  ;         CY = clear
  8452                                  ;         Current directory is changed to directory in pathname
  8453                                  ;         UserDir1 contains previous directory for use by RestUDir
  8454                                  ;         RestDir = nonzero to flag later restoration of user's dir
  8455                                  ;         DestTail = ptr to beginning of filename
  8456                                  ;         If filename found in pathname,
  8457                                  ;           ZR = clear
  8458                                  ;           FCB filename fields contain filename
  8459                                  ;         If filename not found (pure directory path),
  8460                                  ;           ZR = set
  8461                                  ;           FCB filename fields are wildcarded with ?'s
  8462                                  ;       If pathcrunch failed (no ChDir's worked),
  8463                                  ;         CY = set
  8464                                  ;         Msg_Numb = extended error code
  8465                                  ;
  8466                                  ; NOTE  DIR asks PathCrunch to forego parsing the filename into the
  8467                                  ;       FCB by setting DirFlag.  In this case, the FCB is returned
  8468                                  ;       with the filename wildcarded.
  8469                                  
  8470                                  PATHCRUNCH:
  8471                                  		; MSDOS 6.0
  8472                                  		;mov     [msg_numb],0	;AN022; Set up message flag
  8473                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8474                                  		;mov	dl,[5CH]
  8475 000019E9 8A165C00                		mov	dl,[FCB]	; DL = drive # (1 = A)
  8476 000019ED E823FF                  		call	SAVUDIR		; save current directory in UserDir1
  8477 000019F0 E83503                  		call	SETPATH
  8478                                  		; MSDOS 6.0
  8479                                   		;jc	pcrunch_cderrJ	;AN022; if error on current dir - report
  8480                                  
  8481                                  ;       DX = ptr to pathname, NULL-terminated
  8482                                  ;       PathPos = ptr to byte after NULL at end of pathname
  8483                                  
  8484                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8485 000019F3 F606[8043]02            		test	byte [DESTINFO],2 ; test if wildcards (? or *) seen
  8486 000019F8 7516                    		jnz	short TRYPEEL	; wildcard seen, peel filename
  8487                                  
  8488 000019FA B43B                    		mov	ah,CHDIR ; 3Bh
  8489 000019FC CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  8490                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  8491                                  		; MSDOS 6.0
  8492                                  		;jnc	chdir_worked            ;AN022; no error - continue
  8493                                  		;
  8494                                  		;invoke	get_ext_error_number    ;AN022; get the extended error
  8495                                  		;cmp	ax,error_path_not_found ;AN022; if path not found
  8496                                  		;jz	trypeel                 ;AC022;     keep trying
  8497                                  		;cmp	ax,error_access_denied  ;AN022; if access denied
  8498                                  		;jz	trypeel                 ;AC022;     keep trying
  8499                                  		;mov	[msg_numb],ax           ;AN022; set up message flag
  8500                                  		;jmp	peelfail                ;AN022; exit with other error
  8501                                  
  8502                                  		; MSDOS 3.3
  8503 000019FE 7210                    		jc	short TRYPEEL
  8504                                  ;chdir_worked:
  8505                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8506 00001A00 E8B604                  		call	SETREST1	; set 'Restore Directory' flag true
  8507 00001A03 B03F                    		mov	al,'?'		; if pure dir, wildcard filename in FCB
  8508 00001A05 BF5D00                  		mov	di,5Dh
  8509 00001A08 B90B00                  		mov	cx,11
  8510 00001A0B F3AA                    		rep stosb
  8511 00001A0D 30C0                    		xor	al,al		; return carry clear, zero set
  8512 00001A0F C3                      		retn
  8513                                  ;pcrunch_cderrj: 			;AN022; need this for long jmp
  8514                                  		;jmp	pcrunch_cderr	;AN022;
  8515                                  TRYPEEL:
  8516 00001A10 8B36[D042]              		mov	si,[PATHPOS]
  8517 00001A14 4E                      		dec	si		; SI = ptr to NULL at end of pathname
  8518 00001A15 8A44FF                  		mov	al,[si-1]	; AL = last char of pathname	
  8519 00001A18 E8BDFF                  		call	PATHCHRCMP
  8520 00001A1B 7423                    		jz	short PEELFAIL
  8521                                  DELLOOP:
  8522 00001A1D 39D6                    		cmp	si,dx
  8523 00001A1F 742B                    		jz	short BADRET
  8524 00001A21 8A04                    		mov	al,[si]
  8525 00001A23 E8B2FF                  		call	PATHCHRCMP
  8526 00001A26 7403                    		jz	short TRYCD
  8527 00001A28 4E                      		dec	si
  8528 00001A29 EBF2                    		jmp	short DELLOOP
  8529                                  TRYCD:
  8530 00001A2B 50                      		push	ax
  8531                                  		;mov	al,'.'
  8532                                  		;mov	al,[DOT_CHR]	; AL = '.'
  8533                                  		; 01/03/2023
  8534 00001A2C B02E                    		mov	al,dot_chr ; mov al,'.'
  8535                                  		
  8536                                  		; MSDOS 6.0
  8537                                  		;cmp	byte ptr [SI+1],al ; check for '.' after path delim
  8538                                  					;M019; allow continuation if '. ' or 
  8539                                  					;M019; '..' is not found.
  8540                                  		;jnz	@f		;M019; '.' not found
  8541                                  		;cmp	byte ptr [SI+2],al ;M019; check for '..'
  8542                                  		;jz	@f		;M019; found '..'
  8543                                  		;cmp	byte ptr [SI+2],0 ;M019; check for '. ' (null terminated)
  8544                                  ;@@:		;pop     ax
  8545                                  		;jz      PEELFAIL	; if . or .., pure cd should have worked
  8546                                  
  8547                                  		; MSDOS 3.3
  8548 00001A2E 384401                  		cmp	[si+1],	al	; check for '.' after path delim
  8549 00001A31 58                      		pop	ax
  8550 00001A32 740C                    		jz	short PEELFAIL	; if . or .., pure cd should have worked
  8551                                  
  8552                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8553 00001A34 8A44FF                  		mov	al,[si-1]	; Special case d:\file	
  8554 00001A37 3C3A                    		cmp	al,':'
  8555 00001A39 7411                    		jz	short BADRET
  8556 00001A3B E89AFF                  		call	PATHCHRCMP
  8557 00001A3E 7502                    		jnz	short NODOUBLESL
  8558                                  PEELFAIL:
  8559 00001A40 F9                      		stc
  8560 00001A41 C3                      		retn
  8561                                  NODOUBLESL:
  8562 00001A42 C60400                  		mov	byte [si],0
  8563 00001A45 B43B                    		mov	ah,CHDIR ; 3Bh
  8564 00001A47 CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  8565                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  8566 00001A49 7317                    		jnc	short CDSUCC
  8567                                  
  8568                                  		; MSDOS 6.0
  8569                                  ;pcrunch_cderr:
  8570                                  		;invoke	get_ext_error_number ;AN022; get the extended error
  8571                                  		;mov	[msg_numb],ax	;AN022; set up message flag
  8572                                  		;or	si,si		;AN022; set up zero flag to not zero
  8573                                  		;stc			;AN022; set up carry flag
  8574                                  		;return
  8575                                  		
  8576                                  		; MSDOS 3.3
  8577                                  PATHCRUNCH_RETN:
  8578 00001A4B C3                      		retn
  8579                                  
  8580                                  BADRET:
  8581 00001A4C 8A04                    		mov	al,[si]
  8582 00001A4E E887FF                  		call	PATHCHRCMP
  8583 00001A51 F9                      		stc
  8584 00001A52 75F7                    		jnz	short PATHCRUNCH_RETN
  8585 00001A54 30DB                    		xor	bl,bl
  8586 00001A56 865C01                  		xchg	bl,[si+1]
  8587 00001A59 B43B                    		mov	ah,CHDIR ; 3Bh
  8588 00001A5B CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  8589                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  8590 00001A5D 72EC                    		jb	short PATHCRUNCH_RETN
  8591 00001A5F 885C01                  		mov	[si+1],	bl
  8592                                  CDSUCC:
  8593 00001A62 E85404                  		call	SETREST1
  8594 00001A65 46                      		inc	si
  8595 00001A66 8936[7E43]              		mov	[DESTTAIL],si
  8596                                  		; MSDOS 6.0
  8597                                  		;pushf			;AN015; save flags
  8598                                  		;cmp	dirflag,-1	;AN015; don't do parse if in DIR
  8599                                  		;jz	pcrunch_end	;AN015;
  8600                                  		;MOV	DI,FCB
  8601                                  		;MOV	AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR 02H 
  8602                                  					; Parse with default drive
  8603                                  		;INT	21h
  8604                                  ;pcrunch_end:
  8605                                  		;popf			;AN015; get flags back
  8606                                  		;return
  8607                                  
  8608                                  		; MSDOS 3.3
  8609 00001A6A BF5C00                  		mov	di,FCB ; 5Ch
  8610 00001A6D B80229                  		mov	ax,(PARSE_FILE_DESCRIPTOR<<8)|2 ; 2902h
  8611 00001A70 CD21                    		int	21h	; DOS -	PARSE FILENAME
  8612                                  				; DS:SI	-> string to parse
  8613                                  				; ES:DI	-> buffer to fill with unopened	FCB
  8614                                  				; AL = bit mask	to control parsing
  8615 00001A72 C3                      		retn
  8616                                  
  8617                                  ;============================================================================
  8618                                  ; TMISC1.ASM, MSDOS 6.0, 1991
  8619                                  ;============================================================================
  8620                                  ; 05/10/2018 - Retro DOS v3.0
  8621                                  
  8622                                  ;TITLE	Part7 COMMAND Transient Routines
  8623                                  
  8624                                  ;	More misc routines
  8625                                  
  8626                                  ;---------------------------
  8627                                  ; We can get rid of this switch processing code if we can take
  8628                                  ; care of the remaining two calls to switch, later in the file.
  8629                                  ; However, I have not checked whether or not any other files use
  8630                                  ; switch -- after all, it IS public!
  8631                                  ;---------------------------
  8632                                  
  8633                                  ;SWCOUNT EQU  6  ; MSDOS 6.0		; Length of switch_list
  8634                                  SWCOUNT	 EQU  5  ; MSDOS 3.3	
  8635                                  
  8636                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1AC2h
  8637                                  
  8638                                  ; ---------------------------------------------------------------------------
  8639                                  
  8640 00001A73 93                      RETSW:		xchg	ax,bx		; Put switches in AX
  8641 00001A74 C3                      		retn
  8642                                  
  8643                                  ; =============== S U B	R O U T	I N E =======================================
  8644                                  
  8645                                  SWITCH:
  8646 00001A75 31DB                    		xor	bx,bx		; Initialize - no switches set
  8647                                  SWLOOP:
  8648 00001A77 E8CCFE                  		call	SCANOFF		; Skip any delimiters
  8649 00001A7A 3A06[8541]              		cmp	al,[SWITCHAR]	; Is it a switch specifier?
  8650 00001A7E 75F3                    		jnz	short RETSW	; No -- we're finished
  8651                                  		;or	bx,8000h
  8652 00001A80 81CB0080                		or	bx,FSWITCH	; Indicate there is a switch specified
  8653 00001A84 46                      		inc	si		; Skip over the switch character
  8654 00001A85 E8BEFE                  		call	SCANOFF
  8655 00001A88 3C0D                    		cmp	al,0Dh
  8656 00001A8A 74E7                    		je	short RETSW	; Oops
  8657 00001A8C 46                      		inc	si
  8658                                  
  8659                                  		; Convert lower case input to upper case
  8660                                  
  8661                                  		;call	UPCONV
  8662 00001A8D E864FD                  		call	UPCONV_MAPCALL
  8663                                  
  8664 00001A90 BF[2E3E]                		mov	di,SWITCH_LIST	; "VBAPW" (for MSDOS 3.3)
  8665                                  					; ("?VBAPW" (for MSDOS 6.0))				
  8666                                  		;mov	cx,5  ; MSDOS 3.3
  8667 00001A93 B90500                  		mov	cx,SWCOUNT ; 5 (for MSDOS 3.3), (6 (for MSDOS 6.0))
  8668                                  		
  8669                                  		;nop
  8670                                  		
  8671 00001A96 F2AE                    		repne scasb		; Look for matching switch
  8672 00001A98 7507                    		jnz	short BADSW
  8673 00001A9A B80100                  		mov	ax,1
  8674 00001A9D D3E0                    		shl	ax,cl		; Set a bit for the switch
  8675 00001A9F 09C3                    		or	bx,ax
  8676                                  BADSW: 				; Retro DOS v3.0 COMMAND.COM modificiation
  8677 00001AA1 EBD4                    		jmp	short SWLOOP
  8678                                  ;BADSW:
  8679                                  		;jmp	short SWLOOP
  8680                                  DRVBAD:
  8681 00001AA3 BA[7938]                		mov	dx,BADDRVPTR
  8682 00001AA6 E94101                  		jmp	CERROR
  8683                                  EXTERNALJ:
  8684 00001AA9 E9AD00                  		jmp	EXTERNAL
  8685                                  
  8686                                  FNDCOM:					; search the internal command table
  8687 00001AAC 08C0                    		or	al,al		; Get real length of first arg
  8688 00001AAE 74F9                    		jz	short EXTERNALJ	; If 0, it must begin with "\" so has
  8689                                  					;  to be external.
  8690                                  ; barryf code starts here
  8691                                  
  8692 00001AB0 E86402                  		call	TEST_APPEND	; see if APPEND installed
  8693 00001AB3 741F                    		jz	short CONTCOM	; not loaded
  8694                                  
  8695                                  APPEND_INTERNAL:			; CODE XREF: PROMPTBAT+16FCj
  8696 00001AB5 8A0E[FB41]              		mov	cl,[IDLEN]
  8697 00001AB9 B500                    		mov	ch,0
  8698 00001ABB 890E[D042]              		mov	[PATHPOS],cx
  8699                                  		
  8700                                  		; MSDOS 6.0
  8701                                  		;inc 	append_exec	;AN041; set APPEND to ON
  8702                                  
  8703 00001ABF E8F202                  		call	IOSET		; re-direct the o'l io
  8704                                  
  8705 00001AC2 BE[FB41]                		mov	si,IDLEN	; address command name, DS already set	
  8706 00001AC5 BAFFFF                  		mov	dx,-1 ; 0FFFFh	; set invoke function
  8707                                  		
  8708                                  		; MSDOS 6.0
  8709                                  		;mov	di,offset TRANGROUP:APPEND_PARSE
  8710                                  					;AN010; Get the entry point for PARSE for APPEND
  8711                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8712 00001AC8 B801AE                  		mov	ax,0AE01h
  8713 00001ACB CD2F                    		int	2Fh	; - Multiplex -	DOS 3.3+ internal
  8714                                  				; - INSTALLABLE	COMMAND	- EXECUTE
  8715                                  				; DX = FFFFh,[SI -> buffer
  8716                                  				; Return: buffer at DS:SI filled with a	length byte
  8717                                  				;		 followed by the uppercase
  8718                                  				; internal command to execute (if length not 0)
  8719 00001ACD 803E[FB41]00            		cmp	byte [IDLEN],0 ; execute requested
  8720                                  		;jne	short CONTCOM
  8721                                  		;jmp	short CMD_DONE
  8722                                  		; 02/03/2023
  8723 00001AD2 7455                    		je	short CMD_DONE
  8724                                  		
  8725                                  		;nop
  8726                                  CONTCOM:				; continue with internal scan
  8727 00001AD4 BF[133D]                		mov	di,COMTAB
  8728 00001AD7 31C9                    		xor	cx,cx
  8729                                  FINDCOM:
  8730 00001AD9 BE[FC41]                		mov	si,ID		; pointer to command argument
  8731 00001ADC 8A0D                    		mov	cl,[di]		; load length of internal command
  8732 00001ADE 47                      		inc	di		; advance past length
  8733 00001ADF E3C8                    		jcxz	EXTERNALJ 	; if it's zero, we're out of internals
  8734 00001AE1 3A0E[FB41]              		cmp	cl,[IDLEN]	; that of the command argument
  8735 00001AE5 7506                    		jne	short ABCD	; lengths not equal ==> strings not eq
  8736 00001AE7 890E[D042]              		mov	[PATHPOS],cx	; store length of command
  8737 00001AEB F3A6                    		repe cmpsb
  8738                                  ABCD:					
  8739 00001AED 9F                      		lahf			; save the good ol' flags
  8740 00001AEE 01CF                    		add	di,cx		; skip over remaining internal, if any
  8741 00001AF0 8A05                    		mov	al,[di]		; load drive-check indicator byte (DCIB)
  8742 00001AF2 A2[9341]                		mov	[CHKDRV],al	; save command flag byte in chkdrv
  8743 00001AF5 47                      		inc	di		; increment DI (OK, OK, I'll stop)
  8744 00001AF6 8B1D                    		mov	bx,[di]		; load internal command address
  8745 00001AF8 47                      		inc	di		; skip over the puppy
  8746 00001AF9 47                      		inc	di
  8747                                  		
  8748                                  		; MSDOS 6.0
  8749                                  		;mov     DX, WORD PTR [DI] ; load ptr to help msg #s
  8750                                  		;inc     DI
  8751                                  		;inc     DI
  8752                                  		;sahf			; remember those flags?
  8753                                  		;jnz     findcom	; well, if all the cmps worked...
  8754                                  ;;
  8755                                  ;; All messages get redirected.
  8756                                  ;;
  8757                                  		;cmp     append_exec,0	;AN041; APPEND just executed?
  8758                                  		;jnz     dont_set_io 	;AN041; Yes - this junk is already set
  8759                                  		;invoke  ioset		; re-direct the ol' i/o
  8760                                  
  8761                                  ;dont_set_io:					;AN041;
  8762                                  ;;
  8763                                  ;; Check for /?.  Certain commands, flagged fLimitHelp,
  8764                                  ;; respond to /? only if it is the only command-line argument.
  8765                                  ;;
  8766                                  		;mov     ax,[COMSW]	; AX = switches after command
  8767                                  		;or      ax,[ALLSWITCH]	; AX = all switches
  8768                                  		;and     ax,SwitchQues	
  8769                                  		;jz      drive_check	; /? not in command line
  8770                                  		;	
  8771                                  		;test    [CHKDRV],fLimitHelp
  8772                                  		;jz      do_help	; /? allowed in combination
  8773                                  ;;
  8774                                  ;; Make sure /? is the only argument on the command line.
  8775                                  ;;
  8776                                  		;cmp     [arg.argvcnt],2
  8777                                  		;jne     drive_check	; /? not only arg - ignore
  8778                                  ;;
  8779                                  ;; Note:  this is all the check we need, even against things like /??.
  8780                                  ;; Our argv parser breaks /?? into two args, /? and ?.
  8781                                  ;;
  8782                                  
  8783                                  ;do_help:
  8784                                  ;
  8785                                  ; DX = ptr to word list of msg #s, terminated by zero word
  8786                                  
  8787                                  		;mov     si,dx		; SI = ptr to list of msg #s
  8788                                      		;mov     ax,NO_SUBST	; AL = no subst's code
  8789                                  		;push    ax		; build subst block on stack
  8790                                  
  8791                                  ;next_help_msg:
  8792                                  		;lodsw			; AX = help msg # or zero
  8793                                  		;or      ax,ax
  8794                                  		;jz      help_done
  8795                                  		;push    ax		; SS:SP = ptr to subst block
  8796                                  					;  (msg # and no_subst byte)
  8797                                  ;; We assume DS = SS.
  8798                                  
  8799                                      		;mov     dx,sp		; DS:DX = ptr to subst block
  8800                                      		;invoke  Std_PrintF	; display help message
  8801                                      		;pop     ax		; remove msg # from stack
  8802                                     		;jmp     next_help_msg
  8803                                  
  8804                                  ;help_done:
  8805                                  		;pop     ax		; clean up stack
  8806                                  		;jmp     TCommand	
  8807                                  
  8808                                  		; MSDOS 3.3
  8809 00001AFA 9E                      		sahf			; remember those flags?
  8810 00001AFB 75DC                    		jnz	short FINDCOM	; well, if all the cmps worked...
  8811 00001AFD E8B402                  		call	IOSET		; re-direct the ol' i/o
  8812                                  DRIVE_CHECK:
  8813                                  		;test	byte [CHKDRV],1
  8814 00001B00 F606[9341]01            		test	byte [CHKDRV],FCHECKDRIVE 
  8815                                  					; did we wanna check those drives?
  8816 00001B05 740B                    		jz	short NOCHECK
  8817 00001B07 A0[9641]                		mov	al,[PARM1]	; parse_file_descriptor results tell
  8818 00001B0A 0A06[9741]              		or	al,[PARM2]	; us whether those drives were OK
  8819 00001B0E 3CFF                    		cmp	al,-1
  8820                                  		;jnz	short NOCHECK
  8821                                  		;jmp	short DRVBAD
  8822                                  		; 02/03/2023
  8823 00001B10 7491                    		jz	short DRVBAD
  8824                                  
  8825                                  ; The user may have omitted the space between the command and its arguments.
  8826                                  ; We need to copy the remainder of the user's command line into the buffer.
  8827                                  ; Note that thisdoes not screw up the arg structure; it points into COMBUF not
  8828                                  ; into the command line at 80.
  8829                                  
  8830                                  NOCHECK:
  8831 00001B12 E8E501                  		call	CMD_COPY
  8832                                  SWITCHECK:
  8833                                  		;test	byte [CHKDRV],2
  8834 00001B15 F606[9341]02            		test	byte [CHKDRV],FSWITCHALLOWED 
  8835                                  					; Does the command take switches
  8836 00001B1A 750B                    		jnz	short REALWORK	; Yes, process the command
  8837 00001B1C E82400                  		call	NOSWIT		; No, check to see if any switches
  8838 00001B1F 7506                    		jnz	short REALWORK	; None, process the command
  8839                                  
  8840                                  		; MSDOS 6.0
  8841                                  		;mov	msg_disp_class,parse_msg_class	
  8842                                  		;			;AN000; set up parse error msg class
  8843                                  		;MOV	DX,OFFSET TranGroup:Extend_Buf_ptr	
  8844                                  		;			;AC000; get extended message pointer
  8845                                  		;mov	Extend_Buf_ptr,BadSwt_ptr		
  8846                                  		;			;AN000; get "Invalid switch" message number
  8847                                  		;jmp	CERROR		; Print error and chill out...
  8848                                  
  8849                                  		; MSDOS 3.0
  8850 00001B21 BA[5239]                		mov	dx,BADPARMPTR
  8851 00001B24 E9C300                  		jmp	CERROR
  8852                                  
  8853                                  REALWORK:
  8854 00001B27 FFD3                    		call	bx		; do some real work, at last
  8855                                  
  8856                                  ; See if we're in a batch CALL command. If we are, reprocess the command line,
  8857                                  ; otherwise, go get another command.
  8858                                  
  8859                                  CMD_DONE:
  8860 00001B29 0E                      		push	cs		; g  restore data segment
  8861 00001B2A 1F                      		pop	ds		; g
  8862 00001B2B 1E                      		push	ds
  8863 00001B2C 8E1E[8141]              		mov	ds,[RESSEG]	; g  save data segment
  8864                                  		;cmp	byte [CALL_FLAG],1 ; G  Is a call in progress?
  8865 00001B30 803EFA0B01              		cmp	byte [CALL_FLAG],call_in_progress
  8866 00001B35 C606FA0B00              		mov	byte [CALL_FLAG],0 ; G  Either way, reset flag
  8867 00001B3A 1F                      		pop	ds		; g  get data segment back
  8868 00001B3B 7403                    		jz	short INCALL	; G
  8869 00001B3D E9C4E5                  		jmp	TCOMMAND	; chill out...
  8870                                  INCALL:
  8871 00001B40 E96AE7                  		jmp	DOCOM1
  8872                                  
  8873                                  ; =============== S U B	R O U T	I N E =======================================
  8874                                  
  8875                                  NOSWIT:
  8876 00001B43 57                      		push	di		; Save di
  8877 00001B44 BF8100                  		mov	di,81h		; di = ptr to command args
  8878 00001B47 BE8000                  		mov	si,80h		; Get address of length of command args
  8879 00001B4A AC                      		lodsb			; Load length
  8880 00001B4B 88C1                    		mov	cl,al		; Move length to cl
  8881 00001B4D 30ED                    		xor	ch,ch		; Zero ch
  8882 00001B4F 2EA0[8541]              		mov	al,[cs:SWITCHAR] ; al = switch character
  8883 00001B53 3C00                    		cmp	al,0		; Turn off ZF
  8884 00001B55 F2AE                    		repne scasb		; Scan for a switch character and return
  8885 00001B57 5F                      		pop	di		;  with ZF set if one was found
  8886 00001B58 C3                      		retn
  8887                                  
  8888                                  ; ---------------------------------------------------------------------------
  8889                                  
  8890                                  EXTERNAL:
  8891 00001B59 E8BB01                  		call	TEST_APPEND	; check to see if append installed
  8892 00001B5C 7406                    		jz	short NOT_BARRYF ; no - truly external command
  8893 00001B5E E954FF                  		jmp	APPEND_INTERNAL	; yes - go to Barryf code
  8894                                  
  8895                                  		; 25/02/2023
  8896                                  BATCOMJ:
  8897 00001B61 E97FEB                  		jmp	BATCOM
  8898                                  
  8899                                  NOT_BARRYF:
  8900 00001B64 2EC606[9441]00          		mov	byte [cs:FILTYP],0
  8901 00001B6A 2E8A16[A141]            		mov	dl,[cs:SPECDRV]
  8902 00001B6F 2E8816[FB41]            		mov	[cs:IDLEN],dl
  8903 00001B74 2EC606[7743]00          		mov	byte [cs:ROM_CALL],0
  8904 00001B7A 52                      		push	dx
  8905 00001B7B BA[FB41]                		mov	dx,IDLEN
  8906 00001B7E E84EE8                  		call	ROM_SCAN
  8907 00001B81 5A                      		pop	dx
  8908                                  		;jnc	short POSTSAVE
  8909 00001B82 7305                    		jnc	short DO_SCAN
  8910 00001B84 2EFE06[7743]            		inc	byte [cs:ROM_CALL]
  8911                                  		;jmp	short POSTSAVE
  8912                                  
  8913                                  		;nop
  8914                                  DO_SCAN:
  8915                                  POSTSAVE:
  8916 00001B89 BF[A940]                		mov	di,EXECPATH
  8917 00001B8C C60500                  		mov	byte [di],0	; Initialize to current directory
  8918                                  	
  8919 00001B8F 2E803E[7743]00          		cmp	byte [cs:ROM_CALL],0
  8920                                  		;jz	short RESEARCH
  8921                                  		;jmp	short NEOEXECUTE
  8922                                  		; 25/02/2023
  8923 00001B95 750C                    		jnz	short NEOEXECUTE		
  8924                                  
  8925                                  		;nop
  8926                                  RESEARCH:
  8927 00001B97 E8D608                  		call	PATH_SEARCH	; find the mother (result in execpath)
  8928 00001B9A 09C0                    		or	ax,ax		; did we find anything?
  8929                                  		;jz	short BADCOMJ45	; null means no (sob)
  8930                                  		; 25/02/2023
  8931 00001B9C 7447                    		jz	short BADCOM
  8932 00001B9E 83F804                  		cmp	ax,4		; 04H and 08H are .exe and .com
  8933                                  					; fuckin' sixteen-bit machine ought
  8934 00001BA1 7CBE                    		jl	short BATCOMJ	; to be able to handle a SIXTEEN-BIT
  8935                                  					; DISPLACEMENT!!
  8936                                  		; 25/02/2023
  8937                                  		;;jmp	short NEOEXECUTE
  8938                                  		;jmp	short EXECUTE	
  8939                                  
  8940                                  		; 02H is .bat
  8941                                  
  8942                                  		;nop
  8943                                  
  8944                                  		; 25/02/2023
  8945                                  ;BATCOMJ:
  8946                                  ;		jmp	BATCOM
  8947                                  ;
  8948                                  ;BADCOMJ45:
  8949                                  ;		jmp	short BADCOM
  8950                                  
  8951                                  		;nop
  8952                                  EXECUTE:
  8953                                  NEOEXECUTE:
  8954 00001BA3 E80E02                  		call	IOSET
  8955                                  
  8956                                  ; MSDOS 6.0
  8957                                  ;M051
  8958                                  ; Previously LoadHigh was jumping to the execute label above. This was wrong
  8959                                  ;because IOSET was getting invoked twice resulting in 2 sets of redirections.
  8960                                  ;After a close, this would still leave one open active resulting in sharing
  8961                                  ;errors on subsequent opens of the redirected file.
  8962                                  ;
  8963                                  ;LH_EXECUTE:				;M051	
  8964 00001BA6 8E06[9141]              		mov	es,[TRAN_TPA]
  8965 00001BAA B449                    		mov	ah,DEALLOC ; 49h
  8966 00001BAC CD21                    		int	21h	; DOS -	2+ - FREE MEMORY
  8967                                  				; ES = segment address of area to be freed
  8968                                  					; Now running in "free" space
  8969 00001BAE 8E06[8141]              		mov	es,[RESSEG]
  8970 00001BB2 26FE06E50B              		inc	byte [es:EXTCOM] ; Indicate external command
  8971 00001BB7 26C606ED0B00            		mov	byte [es:RESTDIR],0 
  8972                                  					; Since USERDIR1 is in transient, insure
  8973                                  					; this flag value for re-entry to COMMAND
  8974                                  		; MSDOS 6.0
  8975                                  		;MOV	SI,OFFSET TRANGROUP:EXECPATH
  8976                                  		;MOV	DI,OFFSET RESGROUP:SAFEPATHBUFFER
  8977                                  		;MOV	CX,LenMsgOrPathBuf
  8978                                  		;CLD
  8979                                  		;REP	MOVSB		; copy program pathname to resident
  8980                                  
  8981                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8982 00001BBD BF5C00                  		mov	di,FCB ; 5Ch
  8983 00001BC0 89FE                    		mov	si,di
  8984 00001BC2 B95200                  		mov	cx,82 ; 52h	; moving (100h-5Ch)/2 = 80h-2Eh
  8985 00001BC5 F3A5                    		rep movsw		; Transfer parameters to resident header
  8986 00001BC7 BA[A940]                		mov	dx,EXECPATH
  8987                                  		;MOV	BX,OFFSET RESGROUP:EXEC_BLOCK
  8988 00001BCA BBFF0C                  		mov	bx,EXEC_BLOCK
  8989 00001BCD B8004B                  		mov	ax,EXEC*256 ; 4B00h
  8990 00001BD0 F606[7743]FF            		test	byte [ROM_CALL],-1 ; 0FFh
  8991 00001BD5 7403                    		jz	short OK_EXEC
  8992 00001BD7 E96EE8                  		jmp	ROM_EXEC
  8993                                  OK_EXEC:
  8994                                  ;
  8995                                  ; we are now running in free space. Anything we do from here on may get
  8996                                  ; trashed. Move the stack (also in free space) to allocated space because
  8997                                  ; since EXEC restores the stack, somebody may trash what is on the stack.
  8998                                  ;
  8999 00001BDA 8CC1                    		mov	cx,es
  9000 00001BDC 8ED1                    		mov	ss,cx
  9001 00001BDE BC3808                  		mov	sp,RSTACK
  9002 00001BE1 FF2E[8741]              		jmp	far [EXEC_ADDR]	; Jmp to the EXEC in the resident
  9003                                  
  9004                                  ; ---------------------------------------------------------------------------
  9005                                  
  9006                                  BADCOM:
  9007 00001BE5 0E                      		push	cs
  9008 00001BE6 1F                      		pop	ds
  9009 00001BE7 BA[EB36]                		mov	dx,BADNAMPTR
  9010                                  CERROR:		
  9011 00001BEA E83218                  		call	STD_EPRINTF
  9012 00001BED E914E5                  		jmp	TCOMMAND
  9013                                  
  9014                                  
  9015                                  ; =============== S U B	R O U T	I N E =======================================
  9016                                  
  9017                                  ; Prescan converts the input buffer into a canonicalized form.
  9018                                  ; All redirections and pipes are removed.
  9019                                  
  9020                                  PRESCAN:
  9021 00001BF0 31C9                    		xor	cx,cx
  9022 00001BF2 8E06[8141]              		mov	es,[RESSEG]
  9023 00001BF6 BE[E23F]                		mov	si,COMBUF+2
  9024 00001BF9 89F7                    		mov	di,si
  9025                                  COUNTQUOTES:
  9026 00001BFB AC                      		lodsb			; get a byte
  9027 00001BFC 3C22                    		cmp	al,22h		; is it a quote?
  9028 00001BFE 7504                    		jne	short COUNTEND	; no, try for end of road
  9029 00001C00 FEC5                    		inc	ch		; bump count
  9030 00001C02 EBF7                    		jmp	short COUNTQUOTES ; go get next char
  9031                                  COUNTEND:
  9032 00001C04 3C0D                    		cmp	al,0Dh		; end of road?
  9033 00001C06 75F3                    		jne	short COUNTQUOTES ; no, go back for next char
  9034 00001C08 89FE                    		mov	si,di		; restore pointer to begining
  9035                                  PRESCANLP:
  9036 00001C0A AC                      		lodsb
  9037 00001C0B 3C22                    		cmp	al,'"'		; " character
  9038 00001C0D 7510                    		jne	short TRYGREATER
  9039 00001C0F FECD                    		dec	ch
  9040 00001C11 740C                    		jz	short TRYGREATER
  9041                                  QLOOP:
  9042 00001C13 8805                    		mov	[di],al
  9043 00001C15 47                      		inc	di
  9044 00001C16 FEC1                    		inc	cl
  9045 00001C18 AC                      		lodsb
  9046 00001C19 3C22                    		cmp	al,'"'		; " character
  9047 00001C1B 75F6                    		jne	short QLOOP
  9048 00001C1D FECD                    		dec	ch
  9049                                  TRYGREATER:
  9050                                  		;cmp	al,[RABRACKET]
  9051                                  		; 01/03/2023
  9052 00001C1F 3C3E                    		cmp	al,rabracket  ; '>'
  9053 00001C21 753E                    		jne	short NOOUT
  9054                                  
  9055                                  ; We have found a ">" char. We need to see if there is another ">"
  9056                                  ; following it.
  9057                                  
  9058 00001C23 3804                    		cmp	[si],al
  9059 00001C25 7506                    		jnz	short NOAPPND
  9060 00001C27 AC                      		lodsb
  9061 00001C28 26FE06040C              		inc	byte [es:RE_OUT_APP] ; Flag >>
  9062                                  NOAPPND:
  9063                                  ; Now we attempt to find the file name. First, scan off all whitespace
  9064                                  
  9065 00001C2D E816FD                  		call	SCANOFF
  9066                                  
  9067                                  		; MSDOS 6.0
  9068                                  		;;cmp	al,[LABRACKET]	   ;AN040; was there no filename?
  9069                                  		;cmp	al,labracket ; '<'
  9070                                  		;je	short REOUT_ERRSET ;AN040; yes - set up error
  9071                                  
  9072                                  		; MSDOS 3.3 (& MSDOS 6.0)
  9073 00001C30 3C0D                    		cmp	al,0Dh
  9074 00001C32 750D                    		jnz	short GOTREOFIL
  9075                                  
  9076                                  ; There was no file present. Set us up at end-of-line.
  9077                                  
  9078                                  REOUT_ERRSET:				;AN040; set up for an error
  9079 00001C34 C6050D                  		mov	byte [di],0Dh	; Clobber first ">"
  9080 00001C37 26C706050C0900          		mov	word [es:RE_OUTSTR],9 ; Cause an error later
  9081 00001C3E E99000                  		jmp	PRESCANEND
  9082                                  
  9083                                  GOTREOFIL:
  9084 00001C41 57                      		push	di
  9085                                  		;MOV	DI,OFFSET RESGROUP:RE_OUTSTR
  9086 00001C42 BF050C                  		mov	di,RE_OUTSTR
  9087 00001C45 89FB                    		mov	bx,di
  9088 00001C47 06                      		push	es
  9089                                  
  9090                                  		; MSDOS 6.0
  9091                                  SETREOUTSTR:				; Get the output redirection name
  9092                                  					; MSKK06 07/14/89
  9093                                  		;push	cx		; save cx
  9094                                  		;mov	cx,64+13	; CX = max string length
  9095                                  ;SETREOUTSTR_LOOP:
  9096                                  		;LODSB
  9097                                  		;CMP	AL,0DH
  9098                                  		;JZ	GOTRESTR_J
  9099                                  		;INVOKE	DELIM
  9100                                  		;JZ	GOTRESTR_J
  9101                                  		;CMP	AL,[SWITCHAR]
  9102                                  		;JZ	GOTRESTR_J
  9103                                  		;CMP	AL,'"'		;AN033; Is the character a quote?
  9104                                  		;JZ	PIPEERRSYNJ5_J	;AN033; Yes - get out quick - or system crashes
  9105                                  		;CMP	AL,labracket	;AN002; Is char for input redirection
  9106                                  		;JZ	ABRACKET_TERM	;AN002; yes - end of string
  9107                                  		;CMP	AL,rabracket	;AN002; Is char for output redirection
  9108                                  		;JNZ	NO_ABRACKET	;AN002; no - not end of string
  9109                                  ;ABRACKET_TERM:				;AN002; have end of string by < or >
  9110                                  		;DEC	SI		;AN002; back up over symbol
  9111                                  		;MOV	AL,BLANK	;AN002; show delimiter as char
  9112                                  ;GOTRESTR_J:
  9113                                  		;pop	cx		; MSKK06 07/14/89
  9114                                  		;JMP	SHORT GOTRESTR	;AN002; go process it
  9115                                  ;NO_ABRACKET:				;AN002; NOT AT END OF STRING
  9116                                  		;STOSB			; store it into resgroup
  9117                                  		;LOOP	SETREOUTSTR_LOOP ; MSKK06 07/14/89
  9118                                  		;jmp	GOTRESTR_j
  9119                                  ;PIPEERRSYNJ5_J:
  9120                                  		;pop	cx		; recover CX
  9121                                  		;jmp	short PIPEERRSYNJ5
  9122                                  
  9123                                  		; MSDOS 3.3
  9124                                  SETREOUTSTR_LOOP:			; Get the output redirection name
  9125 00001C48 AC                      		lodsb
  9126 00001C49 3C0D                    		cmp	al,0Dh
  9127 00001C4B 7460                    		jz	short GOTRESTR
  9128 00001C4D E8FEFC                  		call	DELIM
  9129 00001C50 745B                    		jz	short GOTRESTR
  9130 00001C52 3A06[8541]              		cmp	al,[SWITCHAR]
  9131 00001C56 7455                    		je	short GOTRESTR
  9132 00001C58 3C22                    		cmp	al,'"'
  9133 00001C5A 7502                    		jne	short NO_ABRACKET
  9134 00001C5C FECD                    		dec	ch
  9135                                  NO_ABRACKET:
  9136 00001C5E AA                      		stosb
  9137 00001C5F EBE7                    		jmp	short SETREOUTSTR_LOOP
  9138                                  NOOUT:
  9139                                  		; MSDOS 3.3 (& MSDOS 6.0)
  9140                                  		;cmp	al,[LABRACKET]
  9141                                  		; 01/03/2023
  9142 00001C61 3C3C                    		cmp	al,labracket ; '<'
  9143 00001C63 751F                    		jnz	short CHKPIPE
  9144 00001C65 89F3                    		mov	bx,si		; Save loc of "<"
  9145 00001C67 E8DCFC                  		call	SCANOFF
  9146                                  		; MSDOS 6.0
  9147                                  		;;cmp	al,[RABRACKET]	;AN040; was there no filename?
  9148                                  		;cmp	al,rabracket ; '>'
  9149                                  		;jz	short REIN_ERRSET ;AN040; yes - set up error
  9150                                  		; MSDOS 3.3 (& MSDOS 6.0)
  9151 00001C6A 3C0D                    		cmp	al,0Dh
  9152 00001C6C 750B                    		jnz	short GOTREIFIL
  9153                                  REIN_ERRSET:				;AN040; set up for error
  9154 00001C6E C6050D                  		mov	byte [di],0Dh		; Clobber "<"
  9155 00001C71 C706[2C41]0900          		mov	word [RE_INSTR],9	; Cause an error later
  9156 00001C77 EB58                    		jmp	short PRESCANEND
  9157                                  GOTREIFIL:
  9158 00001C79 57                      		push	di
  9159 00001C7A BF[2C41]                		mov	di,RE_INSTR
  9160 00001C7D 89FB                    		mov	bx,di
  9161 00001C7F 06                      		push	es
  9162 00001C80 0E                      		push	cs
  9163 00001C81 07                      		pop	es		; store in TRANGROUP
  9164 00001C82 EBC4                    		jmp	short SETREOUTSTR_LOOP 
  9165                                  					; Get the input redirection name
  9166                                  CHKPIPE:
  9167 00001C84 88C4                    		mov	ah,al
  9168                                  		;cmp	ah,'|'
  9169 00001C86 80FC7C                  		cmp	ah,ALTPIPECHR
  9170                                  		; 01/03/2023
  9171                                  		;je	short ISPIPE3
  9172                                  		;;cmp	ah,[VBAR]
  9173                                  		;cmp	ah,vbar	; '|'
  9174 00001C89 7539                    		jne	short CONTPRESCAN
  9175                                  ISPIPE3:
  9176                                  ; Only push the echo flag if we are entering the pipe for the first time.
  9177                                  
  9178 00001C8B 26803E560C00            		cmp	byte [es:PIPEFLAG],0
  9179 00001C91 7505                    		jne	short NOECHOPUSH
  9180 00001C93 26D026E90B              		shl	byte [es:ECHOFLAG],1 ; push echo state and turn it off
  9181                                  NOECHOPUSH:
  9182 00001C98 26FE06560C              		inc	byte [es:PIPEFLAG]
  9183 00001C9D E8A6FC                  		call	SCANOFF
  9184 00001CA0 3C0D                    		cmp	al,0Dh
  9185 00001CA2 7404                    		jz	short PIPEERRSYNJ5
  9186                                  		;cmp	al,'|'
  9187 00001CA4 3C7C                    		cmp	al,ALTPIPECHR
  9188                                  		; 01/03/2023
  9189                                  		;jz	short PIPEERRSYNJ5
  9190                                  		;;cmp	al,[VBAR]	; '|'
  9191                                  		;cmp	al,vbar
  9192 00001CA6 751C                    		jnz	short CONTPRESCAN
  9193                                  PIPEERRSYNJ5:
  9194 00001CA8 06                      		push	es
  9195 00001CA9 1F                      		pop	ds
  9196 00001CAA E93802                  		jmp	PIPEERRSYN
  9197                                  
  9198                                  ; Trailing :s are allowed on devices. Check to be sure that there is more
  9199                                  ; than just a : in the redir string.
  9200                                  
  9201                                  GOTRESTR:
  9202 00001CAD 86E0                    		xchg	ah,al
  9203 00001CAF B03A                    		mov	al,':'
  9204 00001CB1 29FB                    		sub	bx,di		; compute negative of number of chars
  9205 00001CB3 83FBFF                  		cmp	bx,-1		; is there just a :?
  9206 00001CB6 7407                    		je	short NOTRAILCOL ; yep, don't change
  9207 00001CB8 263845FF                		cmp	[es:di-1],al	; Trailing ':' OK on devices
  9208 00001CBC 7501                    		jne	short NOTRAILCOL
  9209 00001CBE 4F                      		dec	di		; Back up over trailing ':'
  9210                                  NOTRAILCOL:
  9211 00001CBF 30C0                    		xor	al,al
  9212 00001CC1 AA                      		stosb			; NUL terminate the string
  9213 00001CC2 07                      		pop	es
  9214 00001CC3 5F                      		pop	di		; Remember the start
  9215                                  CONTPRESCAN:
  9216 00001CC4 8825                    		mov	[di],ah		; "delete" the redirection string
  9217 00001CC6 47                      		inc	di
  9218 00001CC7 80FC0D                  		cmp	ah,0Dh
  9219 00001CCA 7405                    		je	short PRESCANEND
  9220 00001CCC FEC1                    		inc	cl
  9221 00001CCE E939FF                  		jmp	PRESCANLP
  9222                                  PRESCANEND:
  9223 00001CD1 26803E560C00            		cmp	byte [es:PIPEFLAG],0
  9224 00001CD7 7414                    		je	short ISNOPIPE
  9225                                  		;MOV	DI,OFFSET RESGROUP:PIPESTR
  9226 00001CD9 BF7A0C                  		mov	di,PIPESTR
  9227 00001CDC 26893E780C              		mov	[es:PIPEPTR],di
  9228 00001CE1 BE[E23F]                		mov	si,COMBUF+2
  9229 00001CE4 E85FFC                  		call	SCANOFF
  9230                                  PIPESETLP:				; Transfer the pipe into the resident
  9231 00001CE7 AC                      		lodsb			; pipe buffer
  9232 00001CE8 AA                      		stosb
  9233 00001CE9 3C0D                    		cmp	al,0Dh
  9234 00001CEB 75FA                    		jnz	short PIPESETLP
  9235                                  ISNOPIPE:
  9236 00001CED 880E[E13F]              		mov	[COMBUF+1],cl
  9237 00001CF1 26803E560C00            		cmp	byte [es:PIPEFLAG],0
  9238 00001CF7 0E                      		push	cs
  9239 00001CF8 07                      		pop	es
  9240 00001CF9 C3                      		retn
  9241                                  
  9242                                  ; =============== S U B	R O U T	I N E =======================================
  9243                                  
  9244                                  CMD_COPY:
  9245 00001CFA BE[E23F]                		mov	si,COMBUF+2
  9246 00001CFD E846FC                  		call	SCANOFF		; advance past separators...
  9247 00001D00 0336[D042]              		add	si,[PATHPOS]
  9248 00001D04 BF8100                  		mov	di,81h
  9249 00001D07 31C9                    		xor	cx,cx
  9250                                  CMDCOPY:
  9251 00001D09 AC                      		lodsb
  9252 00001D0A AA                      		stosb
  9253 00001D0B 3C0D                    		cmp	al,0Dh
  9254 00001D0D 7403                    		je	short COPY_DONE
  9255 00001D0F 41                      		inc	cx
  9256 00001D10 EBF7                    		jmp	short CMDCOPY
  9257                                  COPY_DONE:
  9258 00001D12 880E8000                		mov	[80h],cl
  9259 00001D16 C3                      		retn
  9260                                  
  9261                                  ; =============== S U B	R O U T	I N E =======================================
  9262                                  
  9263                                  TEST_APPEND:
  9264 00001D17 BB[E03F]                		mov	bx,COMBUF	; barry can address
  9265 00001D1A BE[FB41]                		mov	si,IDLEN	; address command name, DS already set 	
  9266 00001D1D BAFFFF                  		mov	dx,-1
  9267 00001D20 B800AE                  		mov	ax,0AE00h
  9268 00001D23 CD2F                    		int	2Fh	; - Multiplex -	DOS 3.3+ internal 
  9269                                  				; - INSTALLABLE	COMMAND	- INSTALL CHECK
  9270                                  				; DX = FFFFh,[BX -> command line
  9271                                  				; Return: AL = FFh if this command is a TSR extension 
  9272                                  				;		   to COMMAND.COM
  9273                                  				; AL = 00h if the command should be executed as	usual
  9274 00001D25 3C00                    		cmp	al,0
  9275 00001D27 C3                      		retn
  9276                                  
  9277                                  ;============================================================================
  9278                                  ; TMISC2.ASM, MSDOS 6.0, 1991
  9279                                  ;============================================================================
  9280                                  ; 05/10/2018 - Retro DOS v3.0
  9281                                  
  9282                                  ;	More misc routines
  9283                                  
  9284                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1D9Bh
  9285                                  
  9286                                  ; =============== S U B	R O U T	I N E =======================================
  9287                                  
  9288                                  SETPATH:
  9289                                  
  9290                                  ; ENTRY PathPos = ptr to string
  9291                                  ;       PathCnt = length of string
  9292                                  ;
  9293                                  ; EXIT  PathPos = ptr to string after pathname
  9294                                  ;       PathCnt = length of rest of string
  9295                                  ;       DX = ptr to pathname in string, made ASCIIZ
  9296                                  ;       DestIsDir = 1 if pathname delimiters appeared in pathname, 0 otherwise
  9297                                  ;       DestInfo = 2 if wildcards (?, *) appeared in pathname, 0 otherwise
  9298                                  ;
  9299                                  ;       A null character is dropped at the end of the pathname. If the
  9300                                  ;       character in that spot previously was CR, it is copied into the
  9301                                  ;       following byte. So there must be at least two two character 
  9302                                  ;       positions in the buffer following the pathname.
  9303                                  
  9304                                  		; MSDOS 6.0
  9305                                  		;mov	ax,[PATHCNT]	;AC000; get length of string
  9306                                  		;mov	si,[PATHPOS]	;AC000; get start of source buffer
  9307                                  
  9308                                  		; MSDOS 3.3
  9309 00001D28 BE8000                  		mov	si,80h
  9310 00001D2B AC                      		lodsb
  9311 00001D2C 30E4                    		xor	ah,ah
  9312 00001D2E A3[CE42]                		mov	[PATHCNT],ax
  9313 00001D31 8936[D042]              		mov	[PATHPOS],si
  9314                                  GETPATH:
  9315                                  		; MSDOS 3.3 (& MSDOS 6.0)
  9316 00001D35 C606[8043]00            		mov	byte [DESTINFO],0
  9317 00001D3A C606[7C43]00            		mov	byte [DESTVARS],0
  9318 00001D3F 8B36[D042]              		mov	si,[PATHPOS]	; SI = ptr to string
  9319 00001D43 8B0E[CE42]              		mov	cx,[PATHCNT]	; CX = string length
  9320 00001D47 89F2                    		mov	dx,si		; DX = ptr to string
  9321 00001D49 E33B                    		jcxz	PATHDONE	; string length is zero, we're done
  9322 00001D4B 51                      		push	cx		; save string length
  9323 00001D4C 56                      		push	si		; save ptr to string
  9324 00001D4D E825FD                  		call	SWITCH
  9325                                  
  9326                                  ;       After Switch, SI has been scanned past any switches, and
  9327                                  ;       switches that COMMAND intrinsically recognizes are recorded in AX.
  9328                                  
  9329 00001D50 A3[D242]                		mov	[PATHSW],ax	; PathSw = switch occurrence mask
  9330 00001D53 5B                      		pop	bx		; BX = ptr to original string
  9331 00001D54 29F3                    		sub	bx,si		; BX = -(# chars scanned by Switch)
  9332 00001D56 59                      		pop	cx		; CX = string length
  9333 00001D57 01D9                    		add	cx,bx		; CX = string length from current SI
  9334 00001D59 89F2                    		mov	dx,si		; DX = ptr to current string
  9335                                  SKIPPATH:
  9336 00001D5B E329                    		jcxz	PATHDONE	; string length is zero, we're done
  9337 00001D5D 49                      		dec	cx		; CX = length left after next char
  9338 00001D5E AC                      		lodsb			; AL = next char of string
  9339                                  					; SI = ptr to char after this one
  9340 00001D5F E876FC                  		call	PATHCHRCMP	; compare AL to path delimiter char
  9341 00001D62 7504                    		jnz	short TESTPMETA	; it's not a path delim
  9342 00001D64 FE06[7C43]              		inc	byte [DESTVARS]	; DestIsDir = 1, signalling path char
  9343                                  TESTPMETA:
  9344 00001D68 3C3F                    		cmp	al,'?'
  9345 00001D6A 7505                    		jne	short TESTPSTAR	; char is not '?'
  9346 00001D6C 800E[8043]02            		or	byte [DESTINFO],2 ; DestInfo = 2, signalling wildcard
  9347                                  TESTPSTAR:
  9348                                  		;cmp	al,'*'
  9349                                  		;cmp	al,[STAR]
  9350                                  		; 01/03/2023
  9351 00001D71 3C2A                    		cmp	al,star ; cmp al,'*'
  9352 00001D73 7505                    		jne	short TESTPDELIM ; char is not '*'
  9353 00001D75 800E[8043]02            		or	byte [DESTINFO],2 ; DestInfo = 2, signalling wildcard
  9354                                  TESTPDELIM:
  9355 00001D7A E8D1FB                  		call	DELIM		; compare AL to all delimiters
  9356 00001D7D 7406                    		jz	short PATHDONEDEC ; delimiter found, back up & leave
  9357 00001D7F 3A06[8541]              		cmp	al,[SWITCHAR]
  9358 00001D83 75D6                    		jne	short SKIPPATH	; char isn't switch, go get next char
  9359                                  PATHDONEDEC:
  9360 00001D85 4E                      		dec	si		; SI = ptr to char after pathname
  9361                                  PATHDONE:
  9362 00001D86 30C0                    		xor	al,al		; AL = NULL
  9363 00001D88 8604                    		xchg	al,[si]		; place NULL after pathname
  9364 00001D8A 46                      		inc	si		; SI = ptr to byte after NULL
  9365 00001D8B 3C0D                    		cmp	al,0Dh		; were we at end of line?
  9366 00001D8D 7502                    		jne	short NOPSTORE	; not EOL, finish up
  9367 00001D8F 8804                    		mov	[si],al		; save EOL after NULL
  9368                                  NOPSTORE:
  9369 00001D91 8936[D042]              		mov	[PATHPOS],si	; PathPos = ptr to char after NULL
  9370 00001D95 890E[CE42]              		mov	[PATHCNT],cx	; PathCnt = length of string left
  9371                                  SETPATH_RETN:
  9372 00001D99 C3                      		retn
  9373                                  
  9374                                  ; ---------------------------------------------------------------------------
  9375                                  
  9376                                  PGETARG:
  9377 00001D9A BE8000                  		mov	si,80h
  9378 00001D9D AC                      		lodsb
  9379 00001D9E 08C0                    		or	al,al
  9380 00001DA0 74F7                    		jz	short SETPATH_RETN
  9381 00001DA2 E80300                  		call	PSCANOFF
  9382 00001DA5 3C0D                    		cmp	al,0Dh
  9383 00001DA7 C3                      		retn
  9384                                  
  9385                                  ; ---------------------------------------------------------------------------
  9386                                  
  9387                                  PSCANOFF:
  9388 00001DA8 AC                      		lodsb
  9389 00001DA9 E8A2FB                  		call	DELIM
  9390 00001DAC 7504                    		jnz	short PSCANOFFD
  9391 00001DAE 3C3B                    		cmp	al,';'
  9392 00001DB0 75F6                    		jne	short PSCANOFF	; ';' is not a delimiter
  9393                                  PSCANOFFD:
  9394 00001DB2 4E                      		dec	si		; Point to first non-delimiter
  9395 00001DB3 C3                      		retn
  9396                                  
  9397                                  ; =============== S U B	R O U T	I N E =======================================
  9398                                  
  9399                                  IOSET:
  9400                                  		; ALL REGISTERS PRESERVED
  9401 00001DB4 1E                      		push	ds
  9402 00001DB5 52                      		push	dx
  9403 00001DB6 50                      		push	ax
  9404 00001DB7 53                      		push	bx
  9405 00001DB8 51                      		push	cx
  9406 00001DB9 2E8E1E[8141]            		mov	ds,[cs:RESSEG]
  9407 00001DBE 803E560C00              		cmp	byte [PIPEFLAG],0
  9408 00001DC3 750D                    		jne	short NOREDIR
  9409 00001DC5 F606F40BFF              		test	byte [IFFLAG],0FFh
  9410 00001DCA 7506                    		jnz	short NOREDIR
  9411 00001DCC E80900                  		call	TESTDOREIN
  9412 00001DCF E85400                  		call	TESTDOREOUT
  9413                                  NOREDIR:
  9414 00001DD2 59                      		pop	cx
  9415 00001DD3 5B                      		pop	bx
  9416 00001DD4 58                      		pop	ax
  9417 00001DD5 5A                      		pop	dx
  9418 00001DD6 1F                      		pop	ds
  9419                                  IOSET_RETN:
  9420 00001DD7 C3                      		retn
  9421                                  
  9422                                  ; =============== S U B	R O U T	I N E =======================================
  9423                                  
  9424                                  TESTDOREIN:
  9425 00001DD8 2E803E[2C41]00          		cmp	byte [cs:RE_INSTR],0
  9426 00001DDE 74F7                    		jz	short IOSET_RETN
  9427 00001DE0 1E                      		push	ds
  9428 00001DE1 0E                      		push	cs
  9429 00001DE2 1F                      		pop	ds
  9430 00001DE3 BA[2C41]                		mov	dx,RE_INSTR
  9431 00001DE6 B8003D                  		mov	ax,OPEN*256 ; 3D00h
  9432 00001DE9 89C3                    		mov	bx,ax
  9433 00001DEB CD21                    		int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
  9434                                  				; DS:DX	-> ASCIZ filename
  9435                                  				; AL = access mode
  9436                                  				; 0 - read
  9437 00001DED 1F                      		pop	ds
  9438 00001DEE 720B                    		jb	short REDIRERR
  9439 00001DF0 89C3                    		mov	bx,ax
  9440 00001DF2 B0FF                    		mov	al,0FFh
  9441                                  
  9442                                  ; Mega sleaze!! We move the SFN from the new handle spot into the old stdin
  9443                                  ; spot. We invalidate the new JFN we got.
  9444                                  
  9445                                  		;xchg	al,[bx+18h]
  9446 00001DF4 864718                  		xchg	al,[bx+PDB.JFN_TABLE]
  9447 00001DF7 A21800                  		mov	[PDB.JFN_TABLE],al
  9448 00001DFA C3                      		retn
  9449                                  
  9450                                  ; ---------------------------------------------------------------------------
  9451                                  
  9452                                  ; We had some kind of error on the redirection. Figure out what the
  9453                                  ; appropriate message should be; BX has the system call that failed
  9454                                  
  9455                                  REDIRERR:
  9456 00001DFB 0E                      		push	cs
  9457 00001DFC 1F                      		pop	ds
  9458                                  		;call	TriageError
  9459 00001DFD E87900                  		call	GET_EXT_ERR_NUMBER
  9460                                  
  9461                                  ; At this point, we have recognized the network-generated access denied error.
  9462                                  ; The correct message is in DX
  9463                                  
  9464 00001E00 83F841                  		cmp	ax,65
  9465 00001E03 7408                    		jz	short _CERRORJ	;AC000; just issue message returned
  9466 00001E05 80FF3D                  		cmp	bh,OPEN ; 3Dh
  9467 00001E08 7406                    		jz	short OPENERR
  9468 00001E0A BA[9E37]                		mov	dx,FULDIRPTR
  9469                                  _CERRORJ:
  9470 00001E0D E9DAFD                  		jmp	CERROR
  9471                                  
  9472                                  OPENERR:
  9473                                  ; The system call was an OPEN. Report either file not found or path not found.
  9474                                  
  9475                                  		; MSDOS 6.0
  9476                                  		;mov	msg_disp_class,ext_msg_class 
  9477                                  		;			;AN000; set up extended error msg class
  9478                                  		;mov	dx,offset TranGroup:Extend_Buf_ptr 
  9479                                  		;			;AC000; get extended message pointer
  9480                                  		;mov	Extend_Buf_ptr,ax	
  9481                                  		;			;AN000; get message number in control block
  9482                                  		;JMP	CERROR
  9483                                  
  9484                                  		; MSDOS 3.3
  9485 00001E10 BA[2837]                		mov	dx,FNOTFOUNDPTR
  9486                                  		;cmp	ax,2
  9487 00001E13 83F802                  		cmp	ax,ERROR_FILE_NOT_FOUND
  9488 00001E16 74F5                    		je	short _CERRORJ
  9489 00001E18 BA[4D37]                		mov	dx,ACCDENPTR
  9490                                  		;cmp	ax,5 ; Access denied error
  9491 00001E1B 83F805                  		cmp	ax,ERROR_ACCESS_DENIED
  9492 00001E1E 74ED                    		je	short _CERRORJ
  9493                                  			; ERROR_PATH_NOT_FOUND
  9494 00001E20 BA[3B37]                		mov	dx,PNOTFOUNDPTR
  9495 00001E23 E9C4FD                  		jmp	CERROR
  9496                                  
  9497                                  ; =============== S U B	R O U T	I N E =======================================
  9498                                  
  9499                                  TESTDOREOUT:
  9500 00001E26 803E050C00              		cmp	byte [RE_OUTSTR],0
  9501 00001E2B 743D                    		je	short NOREOUT
  9502                                  
  9503                                  REOUTEXISTS:
  9504 00001E2D 803E040C00              		cmp	byte [RE_OUT_APP],0
  9505 00001E32 741F                    		je	short REOUTCRT
  9506                                  
  9507 00001E34 BA050C                  		mov	dx,RE_OUTSTR
  9508                                  
  9509                                  		; MSDOS 6.0
  9510                                  		;mov	ax,(OPEN SHL 8) OR 2 ;AC011; Open for read/write
  9511                                  		;mov	ax,3D02h
  9512                                  
  9513                                  		; MSDOS 3.3
  9514 00001E37 B8013D                  		mov	ax,(OPEN<<8)|1  ; 3D01h ; Open for write
  9515                                  	
  9516                                  		; MSDOS 3.3 (& MSDOS 6.0)
  9517 00001E3A 50                      		push	ax
  9518 00001E3B CD21                    		int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
  9519                                  				; DS:DX	-> ASCIZ filename
  9520                                  				; AL = access mode
  9521                                  				; 1 - write
  9522 00001E3D 5B                      		pop	bx
  9523 00001E3E 720D                    		jc	short OPENWRITEERROR
  9524                                  
  9525                                  		; MSDOS 6.0
  9526                                  		;MOV	BX,AX
  9527                                  		;MOV	AX,IOCTL SHL 8		;AN035; Get attributes of handle
  9528                                  		;INT	21h			;AN035;
  9529                                  		;TEST	DL,devid_ISDEV		;AN035; Is it a device?
  9530                                  		;JNZ	SET_REOUT		;AN035; Yes, don't read from it
  9531                                  		;
  9532                                  		;MOV	AX,(LSEEK SHL 8) OR 2
  9533                                  		;MOV	CX,-1			;AC011; MOVE TO EOF -1
  9534                                  		;MOV	DX,CX			;AC011;
  9535                                  		;INT	21h
  9536                                  		;PUSH	CS			;AN011; Get transient seg to DS
  9537                                  		;POP	DS			;AN011;
  9538                                  		;assume	DS:Trangroup		;AN011;
  9539                                  		;MOV	AX,(READ SHL 8) 	;AN011; Read one byte from the
  9540                                  		;MOV	CX,1			;AN011;   file into one_char_val
  9541                                  		;MOV	DX,OFFSET Trangroup:ONE_CHAR_VAL;AN011;
  9542                                  		;INT	21h			;AN011;
  9543                                  		;JC	OpenWriteError		;AN011; If error, exit
  9544                                  		;cmp	ax,cx			;AN017; Did we read 1 byte?
  9545                                  		;jnz	reout_0_length		;AN017; No - file must be 0 length
  9546                                  		;
  9547                                  		;cmp	one_char_val,01ah	;AN011; Was char an eof mark?
  9548                                  		;mov	DS,[resseg]		;AN011; Get resident segment back
  9549                                  		;assume	DS:Resgroup		;AN011;
  9550                                  		;JNZ	SET_REOUT		;AN011; No, just continue
  9551                                  		;MOV	AX,(LSEEK SHL 8) OR 1	;AN011; EOF mark found
  9552                                  		;MOV	CX,-1			;AN011; LSEEK back one byte
  9553                                  		;MOV	DX,CX			;AN011;
  9554                                  		;INT	21h			;AN011;
  9555                                  		;JMP	SHORT SET_REOUT
  9556                                  ;reout_0_length: 				;AN017; We have a 0 length file
  9557                                  		;mov	DS,[resseg]		;AN017; Get resident segment back
  9558                                  		;assume	DS:Resgroup		;AN017;
  9559                                  		;MOV	AX,(LSEEK SHL 8)	;AN017; Move to beginning of file
  9560                                  		;XOR	CX,CX			;AN017; Offset is 0
  9561                                  		;MOV	DX,CX			;AN017;
  9562                                  		;INT	21h			;AN017;
  9563                                  		;JMP	SHORT SET_REOUT 	;AN017; now finish setting up redirection
  9564                                  
  9565                                  		; MSDOS 3.3
  9566 00001E40 31D2                    		xor	dx,dx
  9567 00001E42 31C9                    		xor	cx,cx
  9568 00001E44 89C3                    		mov	bx,ax
  9569 00001E46 B80242                  		mov	ax,(LSEEK<<8)|2 ; 4202h
  9570 00001E49 CD21                    		int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
  9571                                  				; AL = method: offset from end of file
  9572 00001E4B EB15                    		jmp	short SET_REOUT
  9573                                  		
  9574                                  		; MSDOS 3.3 (& MSDOS 6.0)
  9575                                  OPENWRITEERROR:	
  9576                                  		;cmp	ax,5
  9577 00001E4D 83F805                  		cmp	ax,ERROR_ACCESS_DENIED
  9578 00001E50 F9                      		stc
  9579 00001E51 74A8                    		je	short REDIRERR
  9580                                  REOUTCRT:	
  9581 00001E53 BA050C                  		mov	dx,RE_OUTSTR
  9582 00001E56 31C9                    		xor	cx,cx
  9583 00001E58 B43C                    		mov	ah,CREAT ; 3Ch
  9584 00001E5A 50                      		push	ax
  9585 00001E5B CD21                    		int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
  9586                                  				; CX = attributes for file
  9587                                  				; DS:DX	-> ASCIZ filename (may include drive and path)
  9588 00001E5D 5B                      		pop	bx
  9589 00001E5E 729B                    		jc	short REDIRERR
  9590                                  NOREDIRERR:
  9591 00001E60 89C3                    		mov	bx,ax
  9592                                  SET_REOUT:
  9593                                  
  9594                                  ; Mega sleaze!! We move the SFN from the new handle spot into the old stdout
  9595                                  ; spot. We invalidate the new JFN we got.
  9596                                  
  9597 00001E62 B0FF                    		mov	al,0FFh
  9598                                  		;xchg	al,[bx+18h]
  9599 00001E64 864718                  		xchg	al,[bx+PDB.JFN_TABLE]
  9600 00001E67 A21900                  		mov	[PDB.JFN_TABLE+1],al
  9601                                  NOREOUT:
  9602 00001E6A C3                      		retn
  9603                                  
  9604                                  ; =============== S U B	R O U T	I N E =======================================
  9605                                  
  9606                                  ; Compute length of string (including NUL) in DS:SI into CX.  Change no other
  9607                                  ; registers
  9608                                  
  9609                                  DSTRLEN:
  9610 00001E6B 50                      		push	ax
  9611 00001E6C 31C9                    		xor	cx,cx
  9612 00001E6E FC                      		cld
  9613                                  DLOOP:
  9614 00001E6F AC                      		lodsb
  9615 00001E70 41                      		inc	cx
  9616 00001E71 08C0                    		or	al,al
  9617 00001E73 75FA                    		jnz	short DLOOP
  9618 00001E75 29CE                    		sub	si,cx
  9619 00001E77 58                      		pop	ax
  9620                                  TRIAGEERR_RETN:
  9621 00001E78 C3                      		retn
  9622                                  
  9623                                  ; =============== S U B	R O U T	I N E =======================================
  9624                                  
  9625                                  ;Break	<Extended error support>
  9626                                  
  9627                                  TriageError:  ; MSDOS 6.0
  9628                                  
  9629                                  ;
  9630                                  ; TriageError will examine the return from a carry-set system call and
  9631                                  ; return the correct error if applicable.
  9632                                  ;
  9633                                  ;   Inputs:	outputs from a carry-settable system call
  9634                                  ;		No system calls may be done in the interrim
  9635                                  ;   Outputs:	If carry was set on input
  9636                                  ;		    carry set on output
  9637                                  ;		    DX contains trangroup offset to printf message
  9638                                  ;		else
  9639                                  ;		    No registers changed
  9640                                  ;
  9641                                  
  9642                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1EEEh
  9643                                  
  9644                                  GET_EXT_ERR_NUMBER:
  9645 00001E79 73FD                    		jnc	short TRIAGEERR_RETN ; no carry => do nothing...
  9646 00001E7B 9C                      		pushf
  9647 00001E7C 53                      		push	bx
  9648 00001E7D 51                      		push	cx
  9649 00001E7E 56                      		push	si
  9650 00001E7F 57                      		push	di
  9651 00001E80 55                      		push	bp
  9652 00001E81 06                      		push	es
  9653 00001E82 1E                      		push	ds
  9654 00001E83 50                      		push	ax
  9655 00001E84 52                      		push	dx
  9656                                  		;mov	ah,59h
  9657 00001E85 B459                    		mov	ah,GETEXTENDEDERROR
  9658 00001E87 CD21                    		int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
  9659                                  				; BX = version code (0000h for DOS 3.x)
  9660 00001E89 59                      		pop	cx
  9661 00001E8A 5B                      		pop	bx		; restore original AX
  9662 00001E8B BA[4D37]                		mov	dx,ACCDENPTR
  9663 00001E8E 83F841                  		cmp	ax,65		; network access denied?
  9664 00001E91 7404                    		je	short NOMOVE	; Yes, return it.
  9665 00001E93 89D8                    		mov	ax,bx
  9666 00001E95 89CA                    		mov	dx,cx
  9667                                  NOMOVE:
  9668 00001E97 1F                      		pop	ds
  9669 00001E98 07                      		pop	es
  9670 00001E99 5D                      		pop	bp
  9671 00001E9A 5F                      		pop	di
  9672 00001E9B 5E                      		pop	si
  9673 00001E9C 59                      		pop	cx
  9674 00001E9D 5B                      		pop	bx
  9675 00001E9E 9D                      		popf
  9676 00001E9F C3                      		retn
  9677                                  
  9678                                  ; =============== S U B	R O U T	I N E =======================================
  9679                                  
  9680                                  		; Far call from resident portion/segment of COMMAND.COM
  9681                                  
  9682                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1F15h
  9683                                  
  9684                                  TRIAGE_INIT:
  9685                                  		;call	TriageError
  9686 00001EA0 E8D6FF                  		call	GET_EXT_ERR_NUMBER
  9687 00001EA3 CB                      		retf
  9688                                  
  9689                                  ;============================================================================
  9690                                  ; TPIPE.ASM, MSDOS 6.0, 1991 (1)
  9691                                  ;============================================================================
  9692                                  ; 03/10/2018 - Retro DOS v3.0
  9693                                  
  9694                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1F19h
  9695                                  
  9696                                  ; =============== S U B	R O U T	I N E =======================================
  9697                                  
  9698                                  SINGLETEST:
  9699 00001EA4 1E                      		push	ds
  9700 00001EA5 2E8E1E[8141]            		mov	ds,[cs:RESSEG]
  9701 00001EAA 833EEF0B00              		cmp	word [SINGLECOM],0
  9702 00001EAF 7406                    		jz	short TESTDONE
  9703 00001EB1 813EEF0BFFEF            		cmp	word [SINGLECOM],0EFFFh
  9704                                  TESTDONE:
  9705 00001EB7 1F                      		pop	ds
  9706 00001EB8 C3                      		retn
  9707                                  
  9708                                  ; =============== S U B	R O U T	I N E =======================================
  9709                                  
  9710                                  SETREST1:
  9711 00001EB9 B001                    		mov	al,1
  9712                                  
  9713                                  ; ---------------------------------------------------------------------------
  9714                                  
  9715                                  SETREST:
  9716 00001EBB 1E                      		push	ds
  9717 00001EBC 8E1E[8141]              		mov	ds,[RESSEG]
  9718 00001EC0 A2ED0B                  		mov	[RESTDIR],al
  9719 00001EC3 1F                      		pop	ds
  9720 00001EC4 C3                      		retn
  9721                                  
  9722                                  ; =============== S U B	R O U T	I N E =======================================
  9723                                  
  9724                                  ; Note that we need to handle the same thing that RestDir handles: the
  9725                                  ; requirement that we try only once to restore the user's environment after
  9726                                  ; and INT 24 or the like. If the condition that causes the INT 24 does not
  9727                                  ; disappear, we just give up.
  9728                                  
  9729                                  PIPEDEL:
  9730 00001EC5 1E                      		push	ds
  9731 00001EC6 52                      		push	dx
  9732 00001EC7 2E8E1E[8141]            		mov	ds,[cs:RESSEG]
  9733 00001ECC BA580C                  		mov	dx,PIPE1	; Clean up in case ^C
  9734 00001ECF B441                    		mov	ah,UNLINK ; 41h 
  9735 00001ED1 CD21                    		int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
  9736                                  				; DS:DX	-> ASCIZ pathname of file to delete 
  9737                                  				;		(no wildcards allowed)
  9738 00001ED3 BA680C                  		mov	dx,PIPE2
  9739 00001ED6 B441                    		mov	ah,UNLINK ; 41h
  9740 00001ED8 CD21                    		int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
  9741                                  				; DS:DX	-> ASCIZ pathname of file to delete 
  9742                                  				;		(no wildcards allowed)
  9743 00001EDA 5A                      		pop	dx
  9744 00001EDB E83204                  		call	PIPEOFF
  9745 00001EDE C606570C00              		mov	byte [PIPEFILES],0
  9746 00001EE3 1F                      		pop	ds
  9747 00001EE4 C3                      		retn
  9748                                  
  9749                                  ; ---------------------------------------------------------------------------
  9750                                  
  9751                                  PIPEERRSYN:
  9752 00001EE5 BA[A83B]                		mov	dx,SYNTMESPTR
  9753 00001EE8 E8DAFF                  		call	PIPEDEL
  9754 00001EEB 0E                      		push	cs
  9755 00001EEC 1F                      		pop	ds
  9756 00001EED E9FAFC                  		jmp	CERROR
  9757                                  
  9758                                  ; ---------------------------------------------------------------------------
  9759                                  
  9760                                  PIPERR:
  9761 00001EF0 9C                      		pushf
  9762                                  		;invoke	TRIAGEERROR
  9763 00001EF1 E885FF                  		call	GET_EXT_ERR_NUMBER
  9764 00001EF4 50                      		push	ax		; Save results from TriageError
  9765 00001EF5 52                      		push	dx
  9766 00001EF6 BA[023C]                		mov	dx,PIPEEMESPTR
  9767 00001EF9 E8C9FF                  		call	PIPEDEL
  9768 00001EFC 0E                      		push	cs
  9769 00001EFD 1F                      		pop	ds
  9770 00001EFE E81E15                  		call	STD_EPRINTF
  9771 00001F01 5A                      		pop	dx		; Restore results from TriageError
  9772 00001F02 58                      		pop	ax
  9773 00001F03 9D                      		popf
  9774 00001F04 83F841                  		cmp	ax,65
  9775 00001F07 7503                    		jnz	short TCOMMANDJ
  9776 00001F09 E9DEFC                  		jmp	CERROR
  9777                                  
  9778                                  TCOMMANDJ:
  9779 00001F0C E9F5E1                  		jmp	TCOMMAND
  9780                                  
  9781                                  PIPEPROCSTRT:
  9782 00001F0F 8E1E[8141]              		mov	ds,[RESSEG]
  9783 00001F13 FE06570C                		inc	byte [PIPEFILES] ; Flag that the pipe files exist
  9784                                  
  9785                                  		; MSDOS 6.0
  9786                                  		;push	es
  9787                                  		;push	di
  9788                                  		;push	ds
  9789                                  		;push	si
  9790                                  		;
  9791                                  		;push	ds
  9792                                  		;push	es
  9793                                  		;pop	ds				;ds = TRANGROUP
  9794                                  		;mov	si,offset TRANGROUP:TempVarName	;ds:si = "TEMP="
  9795                                  ;
  9796                                  ;Some hideous code in Find_Name_In_Environment. Expects ds = TRANGROUP and
  9797                                  ;so the routine is not really general
  9798                                  ;
  9799                                  		;call	Find_Name_In_Environment	;es:di points at path
  9800                                  		;pop	ds				;ds = DATARES again
  9801                                  		;jc	no_temp_path
  9802                                  		;
  9803                                  		;push	ds
  9804                                  		;push	es
  9805                                  		;pop	ds
  9806                                  		;pop	es				;swap ds and es
  9807                                  		;mov	si,di				;ds:si points at path
  9808                                  		;
  9809                                  		;call	skip_white			;skip white space chars
  9810                                  ;
  9811                                  ;This copies the path into both buffers -- Pipe1 & Pipe2
  9812                                  ;
  9813                                  		;call	copy_pipe_path			;copy the pipe path
  9814                                  		;
  9815                                  ;
  9816                                  ;Check if the TEMP path is valid
  9817                                  ;
  9818                                  		;push	es
  9819                                  		;pop	ds				;ds = DATARES
  9820                                  		;mov	dx,offset DATARES:Pipe1		;ds:dx = path to look for
  9821                                  		;mov	ax, (CHMOD shl 8) or 0
  9822                                  		;int	21h
  9823                                  		;jc	no_temp_path
  9824                                  		;
  9825                                  		;test	cx,10h				;is it a directory?
  9826                                  		;jnz	no_temp_path			;yes, continue (carry clear)
  9827                                  		;
  9828                                  		;stc					;no, indicate fail
  9829                                  no_temp_path:
  9830                                  		;pop	si
  9831                                  		;pop	ds
  9832                                  		;pop	di
  9833                                  		;pop	es
  9834                                  		;jnc	crt_temp			;path found, create tempfiles
  9835                                  
  9836                                  		; MSDOS 3.3
  9837 00001F17 B419                    		mov	ah,GET_DEFAULT_DRIVE ; 19h	; Get current drive
  9838 00001F19 CD21                    		int	21h ; DOS - GET DEFAULT DISK NUMBER
  9839                                  		;add	al,[cs:CAPITAL_A]
  9840                                  		; 01/03/2023
  9841 00001F1B 0441                    		add	al,capital_A  ; add al,'A'
  9842 00001F1D A2680C                  		mov	[PIPE2],al		; Make pipe files in root of def drv
  9843 00001F20 BB580C                  		mov	bx,PIPE1
  9844 00001F23 8807                    		mov	[bx],al
  9845 00001F25 30E4                    		xor	ah,ah			; nul terminate path names
  9846 00001F27 88265B0C                		mov	[PIPE1+3],ah
  9847 00001F2B 88266B0C                		mov	[PIPE2+3],ah
  9848                                  
  9849                                  		; MSDOS 6.0
  9850                                  ;SR;
  9851                                  ; We want to create temp files in the current directory rather than in the 
  9852                                  ;root of the drive. This is because the number of files that can be present
  9853                                  ;in the root directory is fixed, whereas it is not so in subdirectories.
  9854                                  ;
  9855                                  		;mov	ah,'.'
  9856                                  		;mov	Pipe1,ah
  9857                                  		;mov	Pipe2,ah
  9858                                  		;xor	ah,ah
  9859                                  		;mov	Pipe1+1,ah
  9860                                  		;mov	Pipe2+1,ah		;create files in current dir
  9861                                  
  9862                                  ;crt_temp:
  9863                                  		; MSDOS 6.0
  9864                                  		;mov	dx,offset DATARES:Pipe1
  9865                                  		;mov	dx,PIPE1
  9866                                  	
  9867                                  		; MSDOS 3.3 (& MSDOS 6.0)
  9868 00001F2F 89DA                    		mov	dx,bx
  9869 00001F31 31C9                    		xor	cx,cx
  9870 00001F33 B45A                    		mov	ah,CREATETEMPFILE ; 5Ah ; the CreateTemp call
  9871 00001F35 CD21                    		int	21h	; DOS -	3+ - CREATE UNIQUE FILE
  9872                                  			; DS:DX	-> ASCIZ directory path	name ending with a '' + 13 bytes to
  9873                                  			; receive generated filename
  9874                                  			; CX = file attributes (only bits 0,1,2,5 may be set)
  9875 00001F37 72B7                    		jc	short PIPERR	; Couldn't create
  9876 00001F39 89C3                    		mov	bx,ax
  9877 00001F3B B43E                    		mov	ah,CLOSE ; 3Eh	; Don't proliferate handles
  9878 00001F3D CD21                    		int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
  9879                                  				; BX = file handle
  9880 00001F3F BA680C                  		mov	dx,PIPE2
  9881 00001F42 B45A                    		mov	ah,CREATETEMPFILE ; 5Ah ; the CreateTemp call
  9882 00001F44 CD21                    		int	21h		; DOS -	3+ - CREATE UNIQUE FILE
  9883                                  			; DS:DX	-> ASCIZ directory path	name ending with a '' + 13 bytes to
  9884                                  			; receive generated filename
  9885                                  			; CX = file attributes (only bits 0,1,2,5 may be set)
  9886 00001F46 72A8                    		jc	short PIPERR
  9887 00001F48 89C3                    		mov	bx,ax
  9888 00001F4A B43E                    		mov	ah,CLOSE ; 3Eh	; Don't proliferate handles
  9889 00001F4C CD21                    		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
  9890                                  					; BX = file handle
  9891                                  		;call	near ptr TESTDOREIN ; Set up a redirection if specified
  9892 00001F4E E887FE                  		call	TESTDOREIN
  9893 00001F51 8B36780C                		mov	si,[PIPEPTR]
  9894 00001F55 833EEF0BFF              		cmp	word [SINGLECOM],-1
  9895 00001F5A 7506                    		jne	short NOSINGP
  9896 00001F5C C706EF0B00F0            		mov	word [SINGLECOM],0F000h ; Flag single command pipe
  9897                                  NOSINGP:
  9898 00001F62 EB26                    		jmp	short FIRSTPIPE
  9899                                  
  9900                                  ; ---------------------------------------------------------------------------
  9901                                  
  9902                                  PIPEPROC:
  9903 00001F64 8026E90BFE              		and	byte [ECHOFLAG],0FEh  ; force current echo to be off
  9904 00001F69 8B36780C                		mov	si,[PIPEPTR]
  9905 00001F6D AC                      		lodsb
  9906                                  		;cmp	al,'|'		
  9907 00001F6E 3C7C                    		cmp	al,ALTPIPECHR	; Alternate pipe char? 	
  9908                                  		; 01/03/2023
  9909                                  		;je	short ISPIPE1	; Yes
  9910                                  		;;cmp	al,[cs:VBAR]
  9911                                  		;cmp	al,vbar  ; '|'
  9912                                  		; 01/03/2023
  9913                                  		;je	short ISPIPE1
  9914                                  		;jmp	PIPEEND		; Pipe done
  9915 00001F70 757A                    		jne	short PIPEEND
  9916                                  ISPIPE1:
  9917 00001F72 8B16FB0C                		mov	dx,[INPIPEPTR] ; Get the input file name
  9918 00001F76 B8003D                  		mov	ax,OPEN*256 ; 3D00h
  9919 00001F79 CD21                    		int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
  9920                                  				; DS:DX	-> ASCIZ filename
  9921                                  				; AL = access mode
  9922                                  				; 0 - read
  9923                                  PIPEERRJ:
  9924 00001F7B 7303                    		jnc	short NO_PIPEERR
  9925 00001F7D E970FF                  		jmp	PIPERR		; Lost the pipe file
  9926                                  NO_PIPEERR:
  9927 00001F80 89C3                    		mov	bx,ax
  9928 00001F82 B0FF                    		mov	al,0FFh
  9929                                  		;xchg	al,[bx+18h]
  9930 00001F84 864718                  		xchg	al,[bx+PDB.JFN_TABLE]
  9931 00001F87 A21800                  		mov	[PDB.JFN_TABLE],al ; Redirect
  9932                                  FIRSTPIPE:
  9933 00001F8A BF[E23F]                		mov	di,COMBUF+2
  9934 00001F8D 31C9                    		xor	cx,cx
  9935 00001F8F 803C0D                  		cmp	byte [si],0Dh	; '|<CR>'
  9936 00001F92 7503                    		jne	short PIPEOK1
  9937                                  PIPEERRSYNJ:
  9938 00001F94 E94EFF                  		jmp	PIPEERRSYN
  9939                                  PIPEOK1:
  9940                                  		; 01/03/2023
  9941                                  		;;mov	al,[cs:VBAR]
  9942                                  		;mov	al,vbar ; '|'
  9943                                  		;cmp	[si],al		; '||'
  9944                                  		;je	short PIPEERRSYNJ
  9945                                  		;cmp	byte [si],'|'
  9946 00001F97 803C7C                  		cmp	byte [si],ALTPIPECHR ; '##' or '|#'?
  9947 00001F9A 74F8                    		je	short PIPEERRSYNJ
  9948                                  PIPECOMLP:
  9949 00001F9C AC                      		lodsb
  9950 00001F9D AA                      		stosb
  9951 00001F9E 3C0D                    		cmp	al,0Dh
  9952 00001FA0 7438                    		je	short LASTPIPE
  9953 00001FA2 41                      		inc	cx
  9954                                  		;cmp	al,'|'
  9955 00001FA3 3C7C                    		cmp	al,ALTPIPECHR
  9956                                  		; 01/03/2023
  9957                                  		;je	short ISPIPE2
  9958                                  		;;cmp	al,[cs:VBAR]
  9959                                  		;cmp	al,vbar ; '|'
  9960 00001FA5 75F5                    		jne	short PIPECOMLP
  9961                                  ISPIPE2:
  9962 00001FA7 26C645FF0D              		mov	byte [es:di-1],0Dh
  9963 00001FAC 49                      		dec	cx
  9964 00001FAD 2E880E[E13F]            		mov	[cs:COMBUF+1],cl
  9965 00001FB2 4E                      		dec	si
  9966 00001FB3 8936780C                		mov	[PIPEPTR],si	; On to next pipe element
  9967 00001FB7 8B16FD0C                		mov	dx,[OUTPIPEPTR]
  9968 00001FBB 51                      		push	cx
  9969 00001FBC 31C9                    		xor	cx,cx
  9970 00001FBE B8003C                  		mov	ax,CREAT*256 ; 3C00h
  9971 00001FC1 CD21                    		int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
  9972                                  				; CX = attributes for file
  9973                                  				; DS:DX	-> ASCIZ filename (may include drive and path)
  9974 00001FC3 59                      		pop	cx
  9975 00001FC4 72B5                    		jc	short PIPEERRJ		; Lost the file
  9976 00001FC6 89C3                    		mov	bx,ax
  9977 00001FC8 B0FF                    		mov	al,0FFh
  9978                                  		;xchg	al,[bx+18h]
  9979 00001FCA 864718                  		xchg	al,[bx+PDB.JFN_TABLE]
  9980 00001FCD A21900                  		mov	[PDB.JFN_TABLE+1],al
  9981 00001FD0 8716FB0C                		xchg	dx,[INPIPEPTR]	; Swap for next element of pipe
  9982 00001FD4 8916FD0C                		mov	[OUTPIPEPTR],dx
  9983 00001FD8 EB0D                    		jmp	short PIPECOM
  9984                                  LASTPIPE:
  9985 00001FDA 2E880E[E13F]            		mov	[cs:COMBUF+1],cl 
  9986 00001FDF 4E                      		dec	si
  9987 00001FE0 8936780C                		mov	[PIPEPTR],si ; Point at the CR (anything not '|' will do)
  9988 00001FE4 E83FFE                  		call	TESTDOREOUT	; Set up the redirection if specified
  9989                                  PIPECOM:
  9990 00001FE7 0E                      		push	cs
  9991 00001FE8 1F                      		pop	ds
  9992 00001FE9 E9CCE2                  		jmp	NOPIPEPROC	; Process the pipe element
  9993                                  PIPEEND:
  9994 00001FEC E8D6FE                  		call	PIPEDEL
  9995 00001FEF 813EEF0B00F0            		cmp	word [SINGLECOM],0F000h
  9996 00001FF5 7506                    		jnz	short NOSINGP2
  9997 00001FF7 C706EF0BFFFF            		mov	word [SINGLECOM],-1 ; 0FFFFh ; Make it return
  9998                                  NOSINGP2:
  9999 00001FFD E904E1                  		jmp	TCOMMAND
 10000                                  
 10001                                  ; =============== S U B	R O U T	I N E =======================================
 10002                                  
 10003                                  ; Date and time are set during initialization and use
 10004                                  ; this routines since they need to do a long return
 10005                                  
 10006                                  DATINIT:
 10007 00002000 2E8C1E[8141]            		mov	[cs:RESSEG],ds	; SetInitFlag needs resseg initialized
 10008 00002005 06                      		push	es
 10009 00002006 1E                      		push	ds		; Going to use the previous stack
 10010 00002007 8CC8                    		mov	ax,cs		; Set up the appropriate segment registers
 10011 00002009 8EC0                    		mov	es,ax
 10012 0000200B 8ED8                    		mov	ds,ax
 10013                                  		;invoke TSYSLOADMSG ; MSDOS 6.0 ; AN000; preload messages
 10014 0000200D BA[084C]                		mov	dx,INTERNATVARS
 10015 00002010 B80038                  		mov	ax,INTERNATIONAL*256 ; 3800h
 10016 00002013 CD21                    		int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
 10017                                  				; get current-country info
 10018                                  				; DS:DX	-> buffer for returned info
 10019                                  		; 20/10/2018
 10020 00002015 C70681000D00            		mov	word [81H],0Dh ; Want to prompt for date during initialization
 10021 0000201B C606[E03F]80            		mov	byte [COMBUF],128 ; Init COMBUF
 10022 00002020 C706[E13F]010D          		mov	word [COMBUF+1],0D01h
 10023 00002026 E86500                  		call	DATE
 10024 00002029 E87301                  		call	CTIME
 10025 0000202C 1F                      		pop	ds
 10026 0000202D 07                      		pop	es
 10027 0000202E CB                      		retf
 10028                                  
 10029                                  ; =============== S U B	R O U T	I N E =======================================
 10030                                  
 10031                                  ; MSDOS 6.0
 10032                                  
 10033                                  ; ****************************************************************
 10034                                  ; *
 10035                                  ; * ROUTINE:	 DATE - Set system date
 10036                                  ; *
 10037                                  ; * FUNCTION:	 If a date is specified, set the system date,
 10038                                  ; *		 otherwise display the current system date and
 10039                                  ; *		 prompt the user for a new date.  If an invalid
 10040                                  ; *		 date is specified, issue an error message and
 10041                                  ; *		 prompt for a new date.  If the user enters
 10042                                  ; *		 nothing when prompted for a date, terminate.
 10043                                  ; *
 10044                                  ; * INPUT:	 command line at offset 81H
 10045                                  ; *
 10046                                  ; * OUTPUT:	 none
 10047                                  ; *
 10048                                  ; ****************************************************************
 10049                                  
 10050                                  ;assume	ds:trangroup,es:trangroup
 10051                                  ;
 10052                                  ;DATE:
 10053                                  ;	MOV	SI,81H				; Accepting argument for date inline
 10054                                  ;	mov	di,offset trangroup:parse_date	;AN000; Get address of PARSE_DATE
 10055                                  ;	xor	cx,cx				;AN000; clear counter for positionals
 10056                                  ;	xor	dx,dx				;AN000;
 10057                                  ;	invoke	cmd_parse			;AC000; call parser
 10058                                  ;	cmp	ax,end_of_line			;AC000; are we at end of line?
 10059                                  ;	JZ	PRMTDAT 			;AC000; yes - go ask for date
 10060                                  ;	cmp	ax,result_no_error		;AN000; did we have an error?
 10061                                  ;	jne	daterr				;AN000; yes - go issue message
 10062                                  ;	JMP	short COMDAT			;AC000; we have a date
 10063                                  ;
 10064                                  ;PRMTDAT:
 10065                                  ;	; Print "Current date is
 10066                                  ;
 10067                                  ;	invoke	GetDate 			;AN000; get date  for output
 10068                                  ;	xchg	dh,dl				;AN000; switch month & day
 10069                                  ;	mov	CurDat_yr,cx			;AC000; put year into message control block
 10070                                  ;	mov	CurDat_mo_day,dx		;AC000; put month and day into message control block
 10071                                  ;	mov	dx,offset trangroup:CurDat_ptr	;AC000; set up message for output
 10072                                  ;	invoke	std_printf
 10073                                  ;;AD061; mov	CurDat_yr,0			;AC000; reset year, month and day
 10074                                  ;;AD061; mov	CurDat_mo_day,0 		;AC000;     pointers in control block
 10075                                  ;
 10076                                  ;GET_NEW_DATE:					;AN000;
 10077                                  ;	call	getdat				;AC000; prompt user for date
 10078                                  ;	cmp	ax,end_of_line			;AC000; are we at end of line?
 10079                                  ;	jz	date_end			;AC000; yes - exit
 10080                                  ;	cmp	ax,result_no_error		;AN000; did we have an error?
 10081                                  ;	jne	daterr				;AN000; yes - go issue message
 10082                                  ;COMDAT:
 10083                                  ;	mov	cx,date_year			;AC000; get parts of date in
 10084                                  ;	mov	dh,date_month			;AC000;    cx and dx for set
 10085                                  ;	mov	dl,date_day			;AC000;    date function call.
 10086                                  ;	push	cx				;AC000; save date
 10087                                  ;	push	dx				;AC000;
 10088                                  ;	mov	cx,1				;AC000; set 1 positional entered
 10089                                  ;	xor	dx,dx				;AN029;
 10090                                  ;	invoke	cmd_parse			;AN029; call parser
 10091                                  ;	cmp	al,end_of_line			;AN029; Are we at end of line?
 10092                                  ;	pop	dx				;AC000; retrieve date
 10093                                  ;	pop	cx				;AC000;
 10094                                  ;	jnz	daterr				;AC000; extra stuff on line - try again
 10095                                  ;	MOV	AH,SET_DATE			;yes - set date
 10096                                  ;	INT	21h
 10097                                  ;	OR	AL,AL
 10098                                  ;	JNZ	DATERR
 10099                                  ;date_end:
 10100                                  ;	ret
 10101                                  ;
 10102                                  ;DATERR:
 10103                                  ;	invoke	crlf2				;AN028; print out a blank line
 10104                                  ;	MOV	DX,OFFSET TRANGROUP:BADDAT_ptr
 10105                                  ;	invoke	std_printf
 10106                                  ;	JMP	GET_NEW_DATE			;AC000; get date again
 10107                                  
 10108                                  ; =============== S U B	R O U T	I N E =======================================
 10109                                  
 10110                                  ; MSDOS 6.0
 10111                                  
 10112                                  ; TIME gets and sets the time
 10113                                  
 10114                                  ; ****************************************************************
 10115                                  ; *
 10116                                  ; * ROUTINE:	 TIME - Set system time
 10117                                  ; *
 10118                                  ; * FUNCTION:	 If a time is specified, set the system time,
 10119                                  ; *		 otherwise display the current system time and
 10120                                  ; *		 prompt the user for a new time.  If an invalid
 10121                                  ; *		 time is specified, issue an error message and
 10122                                  ; *		 prompt for a new time.  If the user enters
 10123                                  ; *		 nothing when prompted for a time, terminate.
 10124                                  ; *
 10125                                  ; * INPUT:	 command line at offset 81H
 10126                                  ; *
 10127                                  ; * OUTPUT:	 none
 10128                                  ; *
 10129                                  ; ****************************************************************
 10130                                  
 10131                                  ;assume	ds:trangroup,es:trangroup
 10132                                  ;
 10133                                  ;CTIME:
 10134                                  ;	MOV	SI,81H				; Accepting argument for time inline
 10135                                  ;	mov	di,offset trangroup:parse_time	;AN000; Get address of PARSE_time
 10136                                  ;	xor	cx,cx				;AN000; clear counter for positionals
 10137                                  ;	xor	dx,dx				;AN000;
 10138                                  ;	invoke	cmd_parse			;AC000; call parser
 10139                                  ;	cmp	ax,end_of_line			;AC000; are we at end of line?
 10140                                  ;	JZ	PRMTTIM 			;AC000; yes - prompt for time
 10141                                  ;	cmp	ax,result_no_error		;AN000; did we have an error?
 10142                                  ;	jne	timerr				;AN000; yes - go issue message
 10143                                  ;	JMP	short COMTIM			;AC000; we have a time
 10144                                  ;
 10145                                  ;PRMTTIM:
 10146                                  ;	;Printf "Current time is ... "
 10147                                  ;
 10148                                  ;	MOV	AH,GET_TIME			;AC000; get the current time
 10149                                  ;	INT	21h				;AC000;    Get time in CX:DX
 10150                                  ;	xchg	ch,cl				;AN000; switch hours & minutes
 10151                                  ;	xchg	dh,dl				;AN000; switch seconds & hundredths
 10152                                  ;	mov	CurTim_hr_min,cx	;AC000; put hours and minutes into message subst block
 10153                                  ;	mov	CurTim_sec_hn,dx	;AC000; put seconds and hundredths into message subst block
 10154                                  ;	mov	dx,offset trangroup:CurTim_ptr	;AC000; set up message for output
 10155                                  ;	invoke	std_printf
 10156                                  ;;AD061; mov	CurTim_hr_min,0 		;AC000; reset hour, minutes, seconds, and hundredths
 10157                                  ;;AD061; mov	CurTim_sec_hn,0 		;AC000;     pointers in control block
 10158                                  ;
 10159                                  ;GET_NEW_TIME:
 10160                                  ;	call	gettim				;AC000;
 10161                                  ;	cmp	ax,end_of_line			;AC000; are we at end of line?
 10162                                  ;	jz	time_end			;AC000;
 10163                                  ;	cmp	ax,result_no_error		;AN000; did we have an error?
 10164                                  ;	jne	timerr				;AN000; yes - go issue message
 10165                                  ;
 10166                                  ;COMTIM:
 10167                                  ;	mov	ch,time_hour			;AC000; get parts of time in
 10168                                  ;	mov	cl,time_minutes 		;AC000;    cx and dx for set
 10169                                  ;	mov	dh,time_seconds 		;AC000;    time function call
 10170                                  ;	mov	dl,time_fraction		;AC000;
 10171                                  ;	push	cx				;AC000; save time
 10172                                  ;	push	dx				;AC000;
 10173                                  ;	mov	cx,1				;AC000; set 1 positional parm entered
 10174                                  ;	xor	dx,dx				;AN029;
 10175                                  ;	invoke	cmd_parse			;AN029; call parser
 10176                                  ;	cmp	al,end_of_line			;AN029; Are we at end of line?
 10177                                  ;	pop	dx				;AC000; retieve time
 10178                                  ;	pop	cx				;AC000;
 10179                                  ;	jnz	timerr				;AC000; extra stuff on line - try again
 10180                                  ;
 10181                                  ;SAVTIM:
 10182                                  ;	MOV	AH,SET_TIME
 10183                                  ;	INT	21h
 10184                                  ;	OR	AL,AL
 10185                                  ;	JNZ	TIMERR				;AC000; if an error occured, try again
 10186                                  ;
 10187                                  ;TIME_END:
 10188                                  ;
 10189                                  ;	ret
 10190                                  ;
 10191                                  ;TIMERR:
 10192                                  ;	invoke	crlf2				;AN028; print out a blank line
 10193                                  ;	MOV	DX,OFFSET TRANGROUP:BADTIM_ptr
 10194                                  ;	invoke	std_printf			; Print error message
 10195                                  ;	JMP	GET_NEW_TIME			;AC000; Try again
 10196                                  
 10197                                  ; =============== S U B	R O U T	I N E =======================================
 10198                                  
 10199                                  ; MSDOS 6.0
 10200                                  
 10201                                  ;
 10202                                  ; Set the special flag in the INIT flag to the value in CX.
 10203                                  ;
 10204                                  
 10205                                  ;SetInitFlag:
 10206                                  ;	mov	ds,[RESSEG]
 10207                                  ;assume ds:resgroup
 10208                                  ;	and	InitFlag,NOT initSpecial
 10209                                  ;	or	InitFlag,cL
 10210                                  ;	push	cs
 10211                                  ;	pop	ds
 10212                                  ;	return
 10213                                  ;
 10214                                  ;Public	PipeOff
 10215                                  ;PipeOff:
 10216                                  ;	ASSUME	DS:NOTHING,ES:NOTHING
 10217                                  ;	SaveReg <DS,AX>
 10218                                  ;	MOV	DS,ResSeg
 10219                                  ;	ASSUME	DS:RESGroup
 10220                                  ;	XOR	AL,AL
 10221                                  ;	XCHG	PipeFlag,AL
 10222                                  ;	OR	AL,AL
 10223                                  ;	JZ	PipeOffDone
 10224                                  ;	SHR	EchoFlag,1
 10225                                  ;PipeOffDone:
 10226                                  ;	RestoreReg  <AX,DS>
 10227                                  ;	return
 10228                                  
 10229                                  ; =============== S U B	R O U T	I N E =======================================
 10230                                  
 10231                                  ; MSDOS 6.0
 10232                                  
 10233                                  ;PRINT_TIME:
 10234                                  ;
 10235                                  ;	MOV	AH,GET_TIME
 10236                                  ;	INT	21h			; Get time in CX:DX
 10237                                  ;
 10238                                  ;	PUSH	ES
 10239                                  ;	PUSH	CS
 10240                                  ;	POP	ES
 10241                                  ;	xchg	ch,cl			;AN000; switch hours & minutes
 10242                                  ;	xchg	dh,dl			;AN000; switch seconds & hundredths
 10243                                  ;	mov	promTim_hr_min,cx	;AC000; put hours and minutes into message subst block
 10244                                  ;	mov	promTim_sec_hn,dx	;AC000; put seconds and hundredths into message subst block
 10245                                  ;	mov	dx,offset trangroup:promTim_ptr ;AC000; set up message for output
 10246                                  ;	invoke	std_printf
 10247                                  ;;AD061; mov	promTim_hr_min,0	;AC000; reset hour, minutes, seconds, and hundredths
 10248                                  ;;AD061; mov	promTim_sec_hn,0	;AC000;     pointers in control block
 10249                                  ;
 10250                                  ;	POP	ES
 10251                                  ;	return
 10252                                  
 10253                                  ; =============== S U B	R O U T	I N E =======================================
 10254                                  
 10255                                  ; MSDOS 6.0
 10256                                  
 10257                                  ; ****************************************************************
 10258                                  ; *
 10259                                  ; * ROUTINE:	 GETDAT - Prompt user for date
 10260                                  ; *
 10261                                  ; * FUNCTION:	 Gets the date format from the COUNTRY DEPENDENT
 10262                                  ; *		 INFORMATION and issues the "Enter new date"
 10263                                  ; *		 message with the proper date format.  COMBUF
 10264                                  ; *		 is reset to get a date from the command line.
 10265                                  ; *		 The PARSE_DATE blocks are then reset and the
 10266                                  ; *		 PARSE function call is issued.
 10267                                  ; *
 10268                                  ; * INPUT:	 NONE
 10269                                  ; *
 10270                                  ; * OUTPUT:	 COMBUF
 10271                                  ; *		 PARSER RETURN CODES
 10272                                  ; *
 10273                                  ; ****************************************************************
 10274                                  
 10275                                  ;GETDAT	proc	near				;AC000;
 10276                                  ;
 10277                                  ;	mov	ax,(International SHL 8)	; Determine what format the date
 10278                                  ;	mov	dx,5ch				;  should be entered in and
 10279                                  ;	int	21h			;  print a message describing it
 10280                                  ;	mov	si,dx
 10281                                  ;	lodsw
 10282                                  ;	mov	dx,usadat_ptr			;AC000; get mm-dd-yy
 10283                                  ;	dec	ax
 10284                                  ;	js	printformat
 10285                                  ;	mov	dx,eurdat_ptr			;AC000; get dd-mm-yy
 10286                                  ;	jz	printformat
 10287                                  ;	mov	dx,japdat_ptr			;AC000; get yy-mm-dd
 10288                                  ;printformat:
 10289                                  ;	mov	ax,dx				;AN000; get message number of format
 10290                                  ;	mov	dh,util_msg_class		;AN000; this is a utility message
 10291                                  ;	call	Tsysgetmsg			;AN000; get the address of the message
 10292                                  ;	mov	newdat_format,si		;AN000; put the address in subst block
 10293                                  ;	MOV	DX,OFFSET TRANGROUP:NEWDAT_ptr	;AC000; get address of message to print
 10294                                  ;	invoke	std_printf
 10295                                  ;	mov	newdat_format,no_subst		;AN000; reset subst block
 10296                                  ;
 10297                                  ;	MOV	AH,STD_CON_STRING_INPUT
 10298                                  ;	MOV	DX,OFFSET TRANGROUP:COMBUF
 10299                                  ;	mov	cx,initSpecial			; Set bit in InitFlag that indicates
 10300                                  ;	call	SetInitFlag			;  prompting for date.
 10301                                  ;	INT	21h			; Get input line
 10302                                  ;	xor	cx,cx				; Reset bit in InitFlag that indicates
 10303                                  ;	call	SetInitFlag			;  prompting for date.
 10304                                  ;	invoke	CRLF2
 10305                                  ;	MOV	SI,OFFSET TRANGROUP:COMBUF+2
 10306                                  ;	mov	di,offset trangroup:parse_date	;AN000; Get address of PARSE_DATE
 10307                                  ;	xor	cx,cx				;AN000; clear counter for positionals
 10308                                  ;	xor	dx,dx				;AN000;
 10309                                  ;	invoke	cmd_parse			;AC000; call parser
 10310                                  ;
 10311                                  ;	ret
 10312                                  ;
 10313                                  ;GETDAT	endp					;AC000;
 10314                                  
 10315                                  ; =============== S U B	R O U T	I N E =======================================
 10316                                  
 10317                                  ; MSDOS 6.0
 10318                                  
 10319                                  ; ****************************************************************
 10320                                  ; *
 10321                                  ; * ROUTINE:	 GETTIME - Prompt user for time
 10322                                  ; *
 10323                                  ; * FUNCTION:	 Gets the time format from the COUNTRY DEPENDENT
 10324                                  ; *		 INFORMATION and issues the "Enter new time"
 10325                                  ; *		 message. COMBUF is reset to get a time from the
 10326                                  ; *		 command line.	The PARSE_TIME blocks are then
 10327                                  ; *		 reset and the PARSE function call is issued.
 10328                                  ; *
 10329                                  ; * INPUT:	 NONE
 10330                                  ; *
 10331                                  ; * OUTPUT:	 COMBUF
 10332                                  ; *		 PARSER RETURN CODES
 10333                                  ; *
 10334                                  ; ****************************************************************
 10335                                  
 10336                                  ;GETTIM	proc	near				;AC000;
 10337                                  ;
 10338                                  ;	XOR	CX,CX				; Initialize hours and minutes to zero
 10339                                  ;	MOV	DX,OFFSET TRANGROUP:NEWTIM_ptr
 10340                                  ;	invoke	std_printf
 10341                                  ;	MOV	AH,STD_CON_STRING_INPUT
 10342                                  ;	MOV	DX,OFFSET TRANGROUP:COMBUF
 10343                                  ;	mov	cx,initSpecial			; Set bit in InitFlag that indicates
 10344                                  ;	call	SetInitFlag			;  prompting for time.
 10345                                  ;	INT	21h			; Get input line
 10346                                  ;	xor	cx,cx				; Reset bit in InitFlag that indicates
 10347                                  ;	call	SetInitFlag			;  prompting for time.
 10348                                  ;	invoke	CRLF2
 10349                                  ;	MOV	SI,OFFSET TRANGROUP:COMBUF+2
 10350                                  ;	mov	di,offset trangroup:parse_time	;AN000; Get address of PARSE_TIME
 10351                                  ;	xor	cx,cx				;AN000; clear counter for positionals
 10352                                  ;	xor	dx,dx				;AN000;
 10353                                  ;	invoke	cmd_parse			;AC000; call parser
 10354                                  ;
 10355                                  ;	ret
 10356                                  ;
 10357                                  ;GETTIM	endp					;AC000;
 10358                                  
 10359                                  ; =============== S U B	R O U T	I N E =======================================
 10360                                  
 10361                                  ; MSDOS 6.0
 10362                                  
 10363                                  ;Skip_white: Skips over the whitespace chars that could be present after
 10364                                  ;the '=' sign in the environment variable before the actual path.
 10365                                  ;
 10366                                  ;	ENTRY:	ds:si = arguments of the environment variable
 10367                                  ;
 10368                                  ;	EXIT:	ds:si = start of the path
 10369                                  ;
 10370                                  ;	REGISTERS AFFECTED: ax
 10371                                  ;
 10372                                  
 10373                                  ;Skip_white	proc	near
 10374                                  ;
 10375                                  ;	cld
 10376                                  ;skw_lp:
 10377                                  ;	lodsb
 10378                                  ;	cmp	al,' '				;blank char?
 10379                                  ;	jz	skw_lp				;yes, skip it
 10380                                  ;	cmp	al,09				;tab char?
 10381                                  ;	jz	skw_lp				;yes, skip it
 10382                                  ;
 10383                                  ;	dec	si				;point at first non-white
 10384                                  ;
 10385                                  ;	ret
 10386                                  ;
 10387                                  ;Skip_white	endp
 10388                                  
 10389                                  ; =============== S U B	R O U T	I N E =======================================
 10390                                  
 10391                                  ; MSDOS 6.0
 10392                                  
 10393                                  ;Copy_pipe_path:	This routine copies the path from the TEMP environment
 10394                                  ;variable into the path buffers Pipe1 & Pipe2.
 10395                                  ;
 10396                                  ;	ENTRY:	ds:si = path to be copied
 10397                                  ;		es = RESGROUP
 10398                                  ;
 10399                                  ;	EXIT:	Path copied into Pipe1 and Pipe2.
 10400                                  ;
 10401                                  ;	REGISTERS AFFECTED: si, di, cx, ax
 10402                                  ;
 10403                                  
 10404                                  ;Copy_pipe_path	proc	near
 10405                                  ;
 10406                                  ;	mov	cx,0ffffh
 10407                                  ;	xor	al,al
 10408                                  ;
 10409                                  ;	mov	di,si
 10410                                  ;	push	es			;save es
 10411                                  ;	push	ds
 10412                                  ;	pop	es			;es:di = path to be copied
 10413                                  ;	
 10414                                  ;	cld
 10415                                  ;	push	di
 10416                                  ;	repnz	scasb			;look for the null char
 10417                                  ;	pop	di
 10418                                  ;
 10419                                  ;	pop	es			;es = RESGROUP again
 10420                                  ;
 10421                                  ;	not	cx			;length including the null
 10422                                  ;
 10423                                  ;	mov	di,offset DATARES:Pipe1	
 10424                                  ;	push	di
 10425                                  ;	push	cx			
 10426                                  ;	rep	movsb			;copy path into Pipe1
 10427                                  ;	pop	cx
 10428                                  ;	pop	di
 10429                                  ;
 10430                                  ;	push	ds
 10431                                  ;	push	es
 10432                                  ;	pop	ds			;ds:si = Pipe1
 10433                                  ;	mov	si,di
 10434                                  ;	mov	di,offset DATARES:Pipe2	;es:di = Pipe2
 10435                                  ;	rep	movsb			;copy path into Pipe2
 10436                                  ;	pop	ds
 10437                                  ;
 10438                                  ;	ret				;
 10439                                  ;
 10440                                  ;Copy_pipe_path	endp
 10441                                  
 10442                                  ;============================================================================
 10443                                  ; TCODE4.ASM, MSDOS 2.11 (& MSDOS 3.3), 1983 (& 1987)
 10444                                  ;============================================================================
 10445                                  ; 05/10/2018 - Retro DOS v3.0
 10446                                  
 10447                                  ; DATE - Gets and sets the time
 10448                                  
 10449                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 20C0h
 10450                                  
 10451                                  ; =============== S U B	R O U T	I N E =======================================
 10452                                  
 10453                                  DATE_CXDX:
 10454 0000202F 89CB                    		mov	bx,cx
 10455                                  
 10456                                  ; =============== S U B	R O U T	I N E =======================================
 10457                                  
 10458                                  P_DATE:
 10459 00002031 89D8                    		mov	ax,bx
 10460 00002033 89D1                    		mov	cx,dx
 10461 00002035 B264                    		mov	dl,100
 10462 00002037 F6F2                    		div	dl
 10463 00002039 86C4                    		xchg	al,ah
 10464 0000203B 92                      		xchg	ax,dx
 10465 0000203C B710                    		mov	bh,'0'-' ' ; 10h  ; Enable leading zero suppression
 10466                                  		;mov	ax,[INTERNATVARS]
 10467 0000203E A1[084C]                		mov	ax,[INTERNATVARS+INTERNAT_BLOCK.Date_tim_format]
 10468 00002041 09C0                    		or	ax,ax
 10469 00002043 7413                    		jz	short USPDAT
 10470 00002045 48                      		dec	ax
 10471 00002046 741E                    		jz	short EUPDAT
 10472 00002048 B700                    		mov	bh,0	 ; Disable leading zero suppression	
 10473 0000204A E83300                  		call	P_YR
 10474 0000204D E82600                  		call	P_DSEP
 10475 00002050 E81E00                  		call	P_MON
 10476 00002053 E82000                  		call	P_DSEP
 10477                                  		;call	P_DAY
 10478                                  		;retn
 10479                                  		; 02/03/2023
 10480 00002056 EB23                    		jmp	short P_DAY
 10481                                  USPDAT:
 10482 00002058 E81600                  		call	P_MON
 10483 0000205B E81800                  		call	P_DSEP
 10484 0000205E E81A00                  		call	P_DAY
 10485                                  PLST:
 10486 00002061 E81200                  		call	P_DSEP
 10487                                  		;call	P_YR
 10488                                  		;retn
 10489                                  		; 02/03/2023
 10490 00002064 EB1A                    		jmp	short P_YR
 10491                                  EUPDAT:
 10492 00002066 E81200                  		call	P_DAY
 10493 00002069 E80A00                  		call	P_DSEP
 10494 0000206C E80200                  		call	P_MON
 10495 0000206F EBF0                    		jmp	short PLST
 10496                                  
 10497                                  ; ---------------------------------------------------------------------------
 10498                                  
 10499                                  P_MON:
 10500 00002071 88E8                    		mov	al,ch
 10501                                  		;call	OUT2
 10502                                  		;retn
 10503                                  		; 02/03/2023
 10504 00002073 E97902                  		jmp	OUT2
 10505                                  
 10506                                  ; ---------------------------------------------------------------------------
 10507                                  
 10508                                  P_DSEP:
 10509                                  		;mov	al,[DATE_SEP] ; INTERNATVARS+11
 10510 00002076 A0[134C]                		mov	al,[INTERNATVARS+INTERNAT_BLOCK.Date_sep]
 10511 00002079 AA                      		stosb
 10512                                  DATE_RETN:	; 02/03/2023
 10513 0000207A C3                      		retn
 10514                                  
 10515                                  ; ---------------------------------------------------------------------------
 10516                                  
 10517                                  P_DAY:
 10518 0000207B 88C8                    		mov	al,cl
 10519                                  		;call	OUT2
 10520                                  		;retn
 10521                                  		; 02/03/2023
 10522 0000207D E96F02                  		jmp	OUT2
 10523                                  
 10524                                  ; ---------------------------------------------------------------------------
 10525                                  
 10526                                  P_YR:
 10527 00002080 88F0                    		mov	al,dh
 10528 00002082 08C0                    		or	al,al
 10529 00002084 7403                    		jz	short TWODIGYR	; Two instead of 4 digit year
 10530 00002086 E86602                  		call	OUT2
 10531                                  TWODIGYR:
 10532 00002089 88D0                    		mov	al,dl
 10533                                  		;call	OUT2
 10534                                  		; 02/03/2023
 10535 0000208B E96102                  		jmp	OUT2
 10536                                  ;DATE_RETN:
 10537                                  		;retn
 10538                                  
 10539                                  ; =============== S U B	R O U T	I N E =======================================
 10540                                  
 10541                                  DATE:				 	; Accepting argument for date inline
 10542 0000208E BE8100                  		mov	si,81h
 10543 00002091 E8B2F8                  		call	SCANOFF
 10544 00002094 3C0D                    		cmp	al,0Dh
 10545                                  		;jz	short PRMTDAT
 10546                                  		;jmp	short COMDAT
 10547                                  		; 02/03/2023
 10548 00002096 7548                    		jnz	short COMDAT
 10549                                  
 10550                                  		;nop
 10551                                  PRMTDAT:
 10552                                  		; MSDOS 3.3
 10553 00002098 BA[8B39]                		mov	dx,CURDATPTR
 10554 0000209B E88A13                  		call	STD_PRINTF	; Print "Current date is "	
 10555 0000209E E87508                  		call	PRINT_DATE
 10556                                  GETDAT:	
 10557 000020A1 BA[9F39]                		mov	dx,NEWDATPTR
 10558 000020A4 E88113                  		call	STD_PRINTF	 ; Print "Enter new date: "
 10559                                  
 10560 000020A7 B80038                  		mov	ax,INTERNATIONAL*256 ; 3800h 
 10561                                  					; Determine what format the date
 10562 000020AA BA5C00                  		mov	dx,5Ch		;  should be entered in and
 10563 000020AD CD21                    		int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
 10564                                  				; get current-country info
 10565                                  				; DS:DX	-> buffer for returned info
 10566 000020AF 89D6                    		mov	si,dx		;  print a message describing it
 10567 000020B1 AD                      		lodsw
 10568 000020B2 BA[AE39]                		mov	dx,USADATPTR	; get mm-dd-yy
 10569 000020B5 48                      		dec	ax
 10570 000020B6 7808                    		js	short PRINTFORMAT
 10571 000020B8 BA[BD39]                		mov	dx,EURDATPTR	; get dd-mm-yy
 10572 000020BB 7403                    		jz	short PRINTFORMAT
 10573 000020BD BA[CC39]                		mov	dx,JAPDATPTR	; get yy-mm-dd
 10574                                  PRINTFORMAT:
 10575 000020C0 E86513                  		call	STD_PRINTF
 10576 000020C3 B40A                    		mov	ah,STD_CON_STRING_INPUT	; 0Ah
 10577 000020C5 BA[E03F]                		mov	dx,COMBUF
 10578 000020C8 B90200                  		mov	cx,INITSPECIAL ;2 ; Set bit in InitFlag that indicate
 10579 000020CB E83202                  		call	SETINITFLAG	;  prompting for date.
 10580 000020CE CD21                    		int	21h		; Get input line
 10581 000020D0 31C9                    		xor	cx,cx		; Reset bit in InitFlag that indicates
 10582 000020D2 E82B02                  		call	SETINITFLAG	;  prompting for date.
 10583 000020D5 E861F8                  		call	CRLF2
 10584 000020D8 BE[E23F]                		mov	si,COMBUF+2
 10585 000020DB 803C0D                  		cmp	byte [si],0Dh
 10586 000020DE 749A                    		jz	short DATE_RETN
 10587                                  COMDAT:
 10588                                  		;mov	ax,[INTERNATVARS]
 10589 000020E0 A1[084C]                		mov	ax,[INTERNATVARS+INTERNAT_BLOCK.Date_tim_format]
 10590 000020E3 09C0                    		or	ax,ax
 10591 000020E5 7435                    		jz	short USSDAT
 10592 000020E7 48                      		dec	ax
 10593 000020E8 744B                    		jz	short EUSDAT
 10594 000020EA E86500                  		call	GET_YR
 10595 000020ED 7235                    		jc	short DATERRJ
 10596 000020EF E89E00                  		call	GET_DSEP
 10597 000020F2 7230                    		jc	short DATERRJ
 10598 000020F4 E84D00                  		call	GET_MON
 10599 000020F7 722B                    		jc	short DATERRJ
 10600 000020F9 E89400                  		call	GET_DSEP
 10601 000020FC 7226                    		jc	short DATERRJ
 10602 000020FE E84B00                  		call	GET_DAY
 10603                                  DAT_SET:
 10604 00002101 7303                    		jnc	short DATSET
 10605 00002103 E98100                  		jmp	DATERR
 10606                                  
 10607                                  ; ---------------------------------------------------------------------------
 10608                                  
 10609                                  DATSET:
 10610 00002106 AC                      		lodsb
 10611 00002107 3C20                    		cmp	al,' '
 10612 00002109 74FB                    		jz	short DATSET
 10613 0000210B 3C09                    		cmp	al,9
 10614 0000210D 74F7                    		jz	short DATSET
 10615 0000210F 3C0D                    		cmp	al,0Dh
 10616 00002111 7574                    		jnz	short DATERR
 10617 00002113 B42B                    		mov	ah,SET_DATE ; 2Bh
 10618 00002115 CD21                    		int	21h	; DOS -	SET CURRENT DATE
 10619                                  				; DL = day,DH = month,	CX = year
 10620                                  				; Return: AL = 00h if no error 
 10621                                  				; 	     = FFh if bad value sent to routine
 10622 00002117 08C0                    		or	al,al
 10623 00002119 756C                    		jnz	short DATERR
 10624                                  DAT_SET_RETN:
 10625 0000211B C3                      		retn
 10626                                  
 10627                                  ; ---------------------------------------------------------------------------
 10628                                  
 10629                                  USSDAT:
 10630 0000211C E82500                  		call	GET_MON
 10631 0000211F 7266                    		jb	short DATERR
 10632 00002121 E86C00                  		call	GET_DSEP
 10633                                  DATERRJ:
 10634 00002124 7261                    		jc	short DATERR
 10635 00002126 E82300                  		call	GET_DAY
 10636                                  TGET:
 10637 00002129 725C                    		jc	short DATERR
 10638 0000212B E86200                  		call	GET_DSEP
 10639 0000212E 7257                    		jc	short DATERR
 10640 00002130 E81F00                  		call	GET_YR
 10641 00002133 EBCC                    		jmp	short DAT_SET
 10642                                  
 10643                                  ; ---------------------------------------------------------------------------
 10644                                  
 10645                                  EUSDAT:
 10646 00002135 E81400                  		call	GET_DAY
 10647 00002138 724D                    		jc	short DATERR
 10648 0000213A E85300                  		call	GET_DSEP
 10649 0000213D 7248                    		jc	short DATERR
 10650 0000213F E80200                  		call	GET_MON
 10651 00002142 EBE5                    		jmp	short TGET
 10652                                  
 10653                                  ; =============== S U B	R O U T	I N E =======================================
 10654                                  
 10655                                  GET_MON:
 10656 00002144 E88801                  		call	GETNUM		; Get one or two digit number
 10657 00002147 72D2                    		jc	short DAT_SET_RETN
 10658 00002149 88E6                    		mov	dh,ah		; Put in position
 10659 0000214B C3                      		retn
 10660                                  
 10661                                  
 10662                                  ; =============== S U B	R O U T	I N E =======================================
 10663                                  
 10664                                  GET_DAY:
 10665 0000214C E88001                  		call	GETNUM
 10666 0000214F 88E2                    		mov	dl,ah		; Put in position
 10667                                  GET_DAY_RETN:
 10668 00002151 C3                      		retn
 10669                                  
 10670                                  ; =============== S U B	R O U T	I N E =======================================
 10671                                  
 10672                                  GET_YR:
 10673 00002152 E87A01                  		call	GETNUM
 10674 00002155 72FA                    		jc	short GET_DAY_RETN
 10675 00002157 B96C07                  		mov	cx,1900
 10676 0000215A E83300                  		call	GET_DSEP
 10677 0000215D 9C                      		pushf
 10678 0000215E 4E                      		dec	si
 10679 0000215F 9D                      		popf
 10680 00002160 741E                    		jz	short BIAS
 10681 00002162 803C0D                  		cmp	byte [si],0Dh
 10682 00002165 7419                    		je	short BIAS
 10683 00002167 803C20                  		cmp	byte [si],' '
 10684 0000216A 7414                    		je	short BIAS
 10685 0000216C 803C09                  		cmp	byte [si],9
 10686 0000216F 740F                    		je	short BIAS
 10687 00002171 53                      		push	bx
 10688 00002172 B364                    		mov	bl,100
 10689 00002174 88E0                    		mov	al,ah
 10690 00002176 F6E3                    		mul	bl
 10691 00002178 5B                      		pop	bx
 10692 00002179 89C1                    		mov	cx,ax
 10693 0000217B E85101                  		call	GETNUM
 10694 0000217E 72D1                    		jc	short GET_DAY_RETN
 10695                                  BIAS:
 10696 00002180 88E0                    		mov	al,ah
 10697 00002182 B400                    		mov	ah,0
 10698 00002184 01C1                    		add	cx,ax
 10699                                  BIAS_RETN:
 10700 00002186 C3                      		retn
 10701                                  
 10702                                  ; ---------------------------------------------------------------------------
 10703                                  
 10704                                  DATERR:
 10705 00002187 BA[7839]                		mov	dx,BADDATPTR
 10706 0000218A E89B12                  		call	STD_PRINTF
 10707 0000218D E911FF                  		jmp	GETDAT
 10708                                  
 10709                                  ; =============== S U B	R O U T	I N E =======================================
 10710                                  
 10711                                  GET_DSEP:
 10712 00002190 AC                      		lodsb
 10713 00002191 3C2F                    		cmp	al,'/'
 10714 00002193 74F1                    		je	short BIAS_RETN
 10715                                  		;cmp	al,'.'
 10716                                  		;cmp	al,[DOT_CHR]
 10717                                  		; 01/03/2023
 10718 00002195 3C2E                    		cmp	al,dot_chr ; cmp al,'.'
 10719 00002197 74ED                    		je	short BIAS_RETN
 10720                                  		; 01/03/2023
 10721 00002199 3C2D                    		cmp	al,'-'
 10722                                  		;cmp	al,[CHAR_SUB]
 10723 0000219B 74E9                    		je	short BIAS_RETN
 10724 0000219D F9                      		stc
 10725 0000219E C3                      		retn
 10726                                  
 10727                                  ; =============== S U B	R O U T	I N E =======================================
 10728                                  
 10729                                  ; TIME gets and sets the time
 10730                                  
 10731                                  CTIME:
 10732 0000219F BE8100                  		mov	si,81h		; Accepting argument for time inline
 10733 000021A2 E8A1F7                  		call	SCANOFF
 10734 000021A5 3C0D                    		cmp	al,0Dh
 10735 000021A7 747C                    		je	short PRMTTIM
 10736 000021A9 BB3A2E                  		mov	bx,2E3Ah ; ":."
 10737 000021AC E80501                  		call	INLINE
 10738 000021AF E98A00                  		jmp	COMTIM
 10739                                  
 10740                                  ; =============== S U B	R O U T	I N E =======================================
 10741                                  
 10742                                  PRINT_TIME:
 10743 000021B2 B42C                    		mov	ah,GET_TIME ; 2Ch ; Get time in CX:DX
 10744 000021B4 CD21                    		int	21h	; DOS -	GET CURRENT TIME
 10745                                  				; Return: CH = hours,CL = minutes,DH = seconds
 10746                                  				; DL = hundredths of seconds
 10747 000021B6 57                      		push	di
 10748 000021B7 06                      		push	es
 10749 000021B8 0E                      		push	cs
 10750 000021B9 07                      		pop	es
 10751 000021BA BF[AB41]                		mov	di,CHARBUF
 10752 000021BD B301                    		mov	bl,1	; Always 24 hour time
 10753 000021BF E81300                  		call	P_TIME
 10754 000021C2 31C0                    		xor	ax,ax
 10755 000021C4 AA                      		stosb
 10756 000021C5 BA[AB41]                		mov	dx,CHARBUF
 10757 000021C8 8916[5E43]              		mov	[STRING_PTR_2],dx
 10758 000021CC BA[6F36]                		mov	dx,STRINGBUF2PTR
 10759 000021CF E85612                  		call	STD_PRINTF
 10760 000021D2 07                      		pop	es
 10761 000021D3 5F                      		pop	di
 10762                                  P_TIME_RETN:
 10763 000021D4 C3                      		retn
 10764                                  
 10765                                  ; =============== S U B	R O U T	I N E =======================================
 10766                                  
 10767                                  P_TIME:
 10768 000021D5 88E8                    		mov	al,ch	
 10769 000021D7 F6C37F                  		test	bl,7Fh		; Ignore high bit
 10770 000021DA 7512                    		jnz	short T24	; 24 hr time?
 10771 000021DC B761                    		mov	bh,'a'		; Assume A.M.
 10772 000021DE 3C0C                    		cmp	al,12		; In the afternoon?
 10773 000021E0 7206                    		jb	short MORN
 10774 000021E2 B770                    		mov	bh,'p'
 10775 000021E4 7402                    		jz	short MORN
 10776 000021E6 2C0C                    		sub	al,12		; Keep it to 12 hours or less
 10777                                  MORN:
 10778 000021E8 08C0                    		or	al,al		; Before 1 am?
 10779 000021EA 7502                    		jnz	short T24
 10780 000021EC B00C                    		mov	al,12
 10781                                  T24:
 10782 000021EE 53                      		push	bx
 10783 000021EF B710                    		mov	bh,'0'-' ' ; 10h ; Enable leading zero suppression
 10784 000021F1 E8FB00                  		call	OUT2
 10785 000021F4 E82900                  		call	P_TSEP
 10786 000021F7 88C8                    		mov	al,cl
 10787 000021F9 E8F300                  		call	OUT2
 10788 000021FC 5B                      		pop	bx
 10789 000021FD 53                      		push	bx
 10790 000021FE F6C380                  		test	bl,80h
 10791 00002201 7513                    		jnz	short PAP	; If from DIR, go directly to am pm
 10792 00002203 B700                    		mov	bh,0		; Disable leading zero suppression
 10793 00002205 E81800                  		call	P_TSEP
 10794 00002208 88F0                    		mov	al,dh
 10795 0000220A E8E200                  		call	OUT2
 10796                                  		;mov	al,'.'
 10797 0000220D A0[114C]                		mov	al,[DECIMAL_SEP]
 10798 00002210 AA                      		stosb
 10799 00002211 88D0                    		mov	al,dl
 10800 00002213 E8D900                  		call	OUT2
 10801                                  PAP:
 10802 00002216 5B                      		pop	bx
 10803 00002217 F6C37F                  		test	bl,7Fh		; Ignore high bit
 10804 0000221A 75B8                    		jnz	short P_TIME_RETN
 10805 0000221C 88F8                    		mov	al,bh
 10806 0000221E AA                      		stosb
 10807 0000221F C3                      		retn
 10808                                  
 10809                                  ; =============== S U B	R O U T	I N E =======================================
 10810                                  
 10811                                  P_TSEP:
 10812                                  		;mov	al,[TIME_SEP]
 10813 00002220 A0[154C]                		mov	al,[INTERNATVARS+INTERNAT_BLOCK.Time_sep]
 10814 00002223 AA                      		stosb
 10815                                  P_TSEP_RETN:
 10816 00002224 C3                      		retn
 10817                                  
 10818                                  ; ---------------------------------------------------------------------------
 10819                                  
 10820                                  PRMTTIM:
 10821 00002225 BA[F139]                		mov	dx,CURTIMPTR
 10822 00002228 E8FD11                  		call	STD_PRINTF	; Print "Current time is "
 10823 0000222B E884FF                  		call	PRINT_TIME
 10824                                  GETTIM:
 10825 0000222E 31C9                    		xor	cx,cx		; Initialize hours and minutes to zero
 10826 00002230 BA[063A]                		mov	dx,NEWTIMPTR
 10827 00002233 E8F211                  		call	STD_PRINTF
 10828                                  		;mov	bx,':.'
 10829                                  		;mov	bx,[TIMECHARS] 
 10830                                  		; 01/03/2023
 10831 00002236 BB3A2E                  		mov	bx,dot_colon ; mov bx,2E3Ah ; mov bx,':.'
 10832 00002239 E85B00                  		call	GETBUF
 10833                                  COMTIM:
 10834 0000223C 74E6                    		jz	short P_TSEP_RETN ; If no time present, don't change it	
 10835 0000223E 724F                    		jc	short TIMEERR
 10836 00002240 89D1                    		mov	cx,dx
 10837 00002242 31D2                    		xor	dx,dx
 10838 00002244 AC                      		lodsb
 10839 00002245 3C0D                    		cmp	al,0Dh
 10840 00002247 743E                    		je	short SAVTIM
 10841 00002249 3C20                    		cmp	al,' '
 10842 0000224B 742D                    		je	short GOTSEC2
 10843 0000224D 3C09                    		cmp	al,9
 10844 0000224F 7429                    		je	short GOTSEC2
 10845 00002251 38D8                    		cmp	al,bl
 10846 00002253 7404                    		je	short GOTSEC
 10847 00002255 38F8                    		cmp	al,bh
 10848 00002257 7536                    		jne	short TIMEERR
 10849                                  GOTSEC:
 10850 00002259 E87300                  		call	GETNUM
 10851 0000225C 7231                    		jc	short TIMEERR
 10852 0000225E 88E6                    		mov	dh,ah		; Position seconds
 10853 00002260 AC                      		lodsb
 10854 00002261 3C0D                    		cmp	al,0Dh
 10855 00002263 7422                    		je	short SAVTIM
 10856 00002265 3C20                    		cmp	al,' '
 10857 00002267 7411                    		je	short GOTSEC2
 10858 00002269 3C09                    		cmp	al,9
 10859 0000226B 740D                    		je	short GOTSEC2
 10860                                  		;cmp	al,'.'
 10861 0000226D 3A06[114C]              		cmp	al,[DECIMAL_SEP]
 10862 00002271 751C                    		jne	short TIMEERR
 10863 00002273 E85900                  		call	GETNUM
 10864 00002276 7217                    		jc	short TIMEERR
 10865 00002278 88E2                    		mov	dl,ah
 10866                                  GOTSEC2:
 10867 0000227A AC                      		lodsb
 10868 0000227B 3C20                    		cmp	al,' '
 10869 0000227D 74FB                    		je	short GOTSEC2
 10870 0000227F 3C09                    		cmp	al,9
 10871 00002281 74F7                    		je	short GOTSEC2
 10872 00002283 3C0D                    		cmp	al,0Dh
 10873 00002285 7508                    		jne	short TIMEERR
 10874                                  SAVTIM:
 10875 00002287 B42D                    		mov	ah,SET_TIME ; 2Dh
 10876 00002289 CD21                    		int	21h	; DOS -	SET CURRENT TIME
 10877                                  				; CH = hours,CL = minutes,DH = seconds,
 10878                                  				;		DL = hundredths of seconds
 10879                                  				; Return: AL = 00h if no error 
 10880                                  				;	     = FFh if bad value sent to routine
 10881 0000228B 08C0                    		or	al,al
 10882                                  P_TSEP_JRETN:
 10883 0000228D 7495                    		jz	short P_TSEP_RETN ; Error in time?
 10884                                  TIMEERR:
 10885 0000228F BA[DE39]                		mov	dx,BADTIMPTR
 10886 00002292 E89311                  		call	STD_PRINTF	; Print "Enter new time: "
 10887 00002295 EB97                    		jmp	short GETTIM
 10888                                  
 10889                                  ; =============== S U B	R O U T	I N E =======================================
 10890                                  
 10891                                  GETBUF:
 10892 00002297 B40A                    		mov	ah,STD_CON_STRING_INPUT ; 0Ah
 10893 00002299 BA[E03F]                		mov	dx,COMBUF
 10894 0000229C B90200                  		mov	cx,2
 10895 0000229F E85E00                  		call	SETINITFLAG
 10896 000022A2 CD21                    		int	21h		; Get input line
 10897 000022A4 31C9                    		xor	cx,cx
 10898 000022A6 E85700                  		call	SETINITFLAG
 10899 000022A9 E88DF6                  		call	CRLF2
 10900 000022AC BE[E23F]                		mov	si,COMBUF+2
 10901 000022AF 803C0D                  		cmp	byte [si],0Dh	; Check if new time entered
 10902 000022B2 74D9                    		jz	short P_TSEP_JRETN
 10903                                  
 10904                                  ; =============== S U B	R O U T	I N E =======================================
 10905                                  
 10906                                  INLINE:
 10907 000022B4 E81800                  		call	GETNUM		; Get one or two digit number
 10908                                  		;jnb	short INLINE1
 10909                                  		;retn
 10910                                  		; 02/03/2023
 10911 000022B7 7215                    		jb	short INLINE_RETN 
 10912                                  INLINE1:
 10913 000022B9 88E6                    		mov	dh,ah		; Put in position
 10914 000022BB AC                      		lodsb
 10915 000022BC 38D8                    		cmp	al,bl
 10916 000022BE 7409                    		jz	short NEXT
 10917 000022C0 38F8                    		cmp	al,bh
 10918 000022C2 7405                    		jz	short NEXT
 10919 000022C4 4E                      		dec	si		; Clears zero flag
 10920 000022C5 F8                      		clc
 10921 000022C6 B200                    		mov	dl,0
 10922 000022C8 C3                      		retn			; Time may have only an hour specified
 10923                                  NEXT:
 10924 000022C9 E80300                  		call	GETNUM
 10925 000022CC 88E2                    		mov	dl,ah		; Put in position
 10926                                  INLINE_RETN:
 10927 000022CE C3                      		retn
 10928                                  
 10929                                  ;============================================================================
 10930                                  ; TCODE5.ASM, MSDOS 2.11 (& MSDOS 3.3), 1983 (& 1987)
 10931                                  ;============================================================================
 10932                                  ; 05/10/2018 - Retro DOS v3.0
 10933                                  
 10934                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2370h
 10935                                  
 10936                                  ; =============== S U B	R O U T	I N E =======================================
 10937                                  
 10938                                  GETNUM:
 10939 000022CF E81000                  		call	INDIG
 10940 000022D2 72FA                    		jb	short INLINE_RETN
 10941 000022D4 88C4                    		mov	ah,al		; Save first digit
 10942 000022D6 E80900                  		call	INDIG		; Another digit?
 10943 000022D9 7204                    		jb	short OKRET
 10944 000022DB D50A                    		aad			; Convert unpacked BCD to decimal
 10945 000022DD 88C4                    		mov	ah,al
 10946                                  OKRET:
 10947 000022DF 0C01                    		or	al,1
 10948                                  GETNUM_RETN:
 10949 000022E1 C3                      		retn
 10950                                  
 10951                                  ; =============== S U B	R O U T	I N E =======================================
 10952                                  
 10953                                  INDIG:
 10954 000022E2 8A04                    		mov	al,[si]
 10955 000022E4 2C30                    		sub	al,'0'
 10956 000022E6 72F9                    		jc	short GETNUM_RETN
 10957 000022E8 3C0A                    		cmp	al,10
 10958 000022EA F5                      		cmc
 10959 000022EB 72F4                    		jc	short GETNUM_RETN
 10960 000022ED 46                      		inc	si
 10961 000022EE C3                      		retn
 10962                                  
 10963                                  ; =============== S U B	R O U T	I N E =======================================
 10964                                  
 10965                                  OUT2:					; Output binary number as two ASCII digits
 10966 000022EF D40A                    		aam			; Convert binary to unpacked BCD
 10967 000022F1 86C4                    		xchg	al,ah
 10968 000022F3 0D3030                  		or	ax,3030h	; Add "0" bias to both digits
 10969 000022F6 3C30                    		cmp	al,'0'		; Is MSD zero?
 10970 000022F8 7502                    		jnz	short NOSUP
 10971 000022FA 28F8                    		sub	al,bh		; Suppress leading zero if enabled
 10972                                  NOSUP:
 10973 000022FC B700                    		mov	bh,0		; Disable zero suppression
 10974 000022FE AB                      		stosw
 10975 000022FF C3                      		retn
 10976                                  
 10977                                  ; ---------------------------------------------------------------------------
 10978                                  		;stosb
 10979                                  		;retn
 10980                                  
 10981                                  ;============================================================================
 10982                                  ; TPIPE.ASM, MSDOS 6.0, 1991 (2)
 10983                                  ;============================================================================
 10984                                  ; 03/10/2018 - Retro DOS v3.0
 10985                                  
 10986                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 23A3h
 10987                                  
 10988                                  ; =============== S U B	R O U T	I N E =======================================
 10989                                  
 10990                                  ; Set the special flag in the INIT flag to the value in CX.
 10991                                  
 10992                                  SETINITFLAG:
 10993 00002300 8E1E[8141]              		mov	ds,[RESSEG]
 10994                                  		;and	byte [INITFLAG],0FDh
 10995 00002304 8026550CFD              		and	byte [INITFLAG],~INITSPECIAL
 10996 00002309 080E550C                		or	byte [INITFLAG],cl
 10997 0000230D 0E                      		push	cs
 10998 0000230E 1F                      		pop	ds
 10999 0000230F C3                      		retn
 11000                                  
 11001                                  ; =============== S U B	R O U T	I N E =======================================
 11002                                  
 11003                                  PIPEOFF:
 11004 00002310 1E                      		push	ds
 11005 00002311 50                      		push	ax
 11006 00002312 2E8E1E[8141]            		mov	ds,[cs:RESSEG]
 11007 00002317 30C0                    		xor	al,al
 11008 00002319 8606560C                		xchg	al,[PIPEFLAG]
 11009 0000231D 08C0                    		or	al,al
 11010 0000231F 7404                    		jz	short PIPEOFFDONE
 11011 00002321 D02EE90B                		shr	byte [ECHOFLAG],1
 11012                                  PIPEOFFDONE:
 11013 00002325 58                      		pop	ax
 11014 00002326 1F                      		pop	ds
 11015 00002327 C3                      		retn
 11016                                  
 11017                                  ; ---------------------------------------------------------------------------
 11018                                  		;db    0,0,0,0,0
 11019                                  		;times 5 db 0
 11020 00002328 90<rep 8h>              align 16
 11021                                  
 11022                                  ;============================================================================
 11023                                  ; PARSE2.ASM, MSDOS 6.0, 1991
 11024                                  ;============================================================================
 11025                                  ; 03/10/2018 - Retro DOS v3.0
 11026                                  
 11027                                  ;----------------------------------------------------------------------------
 11028                                  ; PARSELINE takes an MSDOS command line and maps it into a UNIX-style
 11029                                  ; argv[argvcnt] array. The most important difference between this array and
 11030                                  ; the tradition UNIX format is the extra cparse information included with
 11031                                  ; each argument element.
 11032                                  ;---------------
 11033                                  ; ENTRY:
 11034                                  ;	BL	     special delimiter for cparse -- not implemented)
 11035                                  ;---------------
 11036                                  ; EXIT:
 11037                                  ;	CF	    set if error
 11038                                  ;	AL	    error code (carry set). Note AH clobbered in any event.
 11039                                  ;	argv[]	    array of cparse flags and pointers to arguments
 11040                                  ;	argvcnt     argument count
 11041                                  ;---------------
 11042                                  ; NOTE(S):
 11043                                  ;	*   BL (special delimiter) is ignored, for now (set to space).
 11044                                  ;	*   Parseflags record contains cparse flags, as follows:
 11045                                  ;		sw_flag 	--	was this arg a switch?
 11046                                  ;		wildcard	--	whether or not it contained a * or ?
 11047                                  ;		path_sep	--	maybe it was a pathname
 11048                                  ;		unused		--	for future expansion
 11049                                  ;		special_delim	--	was there an initial special delimiter?
 11050                                  ;	*   argv[] and argvcnt are undefined if CF/AL indicates an error.
 11051                                  ;	*   Relationship between input, cparse output, and comtail can be
 11052                                  ;	    found in the following chart.  Despite the claim of the cparse
 11053                                  ;	    documentation that, "Token buffer always starts d:  for non switch
 11054                                  ;	    tokens", such is not the case (see column two, row two).
 11055                                  ;	    Similarly, [STARTEL] is not null when the command line is one of
 11056                                  ;	    the forms, "d:", "d:\", or "d:/". In fact, *STARTEL (i.e., what
 11057                                  ;	    STARTEL addresses) will be null. This is clearly just a
 11058                                  ;	    documentation error.
 11059                                  ;	*   cparse also returns a switch code in BP for each switch it
 11060                                  ;	    recognizes on the command line.
 11061                                  ;	*   arglen for each token does NOT include the terminating null.
 11062                                  ;	*   Finally, note that interesting constructions like 'foodir/*.exe'
 11063                                  ;	    parse as three separate tokens, and the asterisk is NOT a wildcard.
 11064                                  ;	    For example, 'for %i in (foodir/*.exe) do echo %i' will first
 11065                                  ;	    echo 'foodir', then '*', then '.exe'. Using cparse for command-
 11066                                  ;	    line parsing may result in slightly different behavior than
 11067                                  ;	    previously observed with the old COMMAND.COM command-line parser.
 11068                                  ;
 11069                                  ;	    Input		    Cparse		Command Line (80H)
 11070                                  ;	\alan\foo.bat		c:\alan\foo.bat 	\alan\foo.bat
 11071                                  ;	alan\foo.bat		alan\foo.bat		alan\foo.bat
 11072                                  ;	foo.bat 		foo.bat 		foo.bat
 11073                                  ;	c:\alan\foo.bat 	c:\alan\foo.bat 	c:\alan\foo.bat
 11074                                  ;	c:alan\foo.bat		c:alan\foo.bat		c:alan\foo.bat
 11075                                  ;	c:foo.bat		c:foo.bat		c:foo.bat
 11076                                  
 11077                                  ; =============== S U B	R O U T	I N E =======================================
 11078                                  
 11079                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 23D0h
 11080                                  
 11081                                  PARSELINE:
 11082 00002330 50                      		push	ax			; most of these are clobbered
 11083 00002331 53                      		push	bx			; by cparse...
 11084 00002332 51                      		push	cx
 11085 00002333 52                      		push	dx
 11086 00002334 57                      		push	di
 11087 00002335 56                      		push	si
 11088 00002336 9C                      		pushf
 11089 00002337 C606[6643]00            		mov	byte [CPYFLAG],0  ; Turn "CPARSE called from COPY flag" off
 11090 0000233C C706[7F4A]FFFF          		mov	word [LASTARG],-1 ; last argument at which to accumulate
 11091 00002342 31C0                    		xor	ax,ax
 11092                                  		;mov	cx,1348
 11093 00002344 B94405                  		mov	cx,ARG_UNIT.SIZE
 11094 00002347 BF[B944]                		mov	di,ARG
 11095 0000234A F3AA                    		rep stosb
 11096                                  		;mov	word [ARGBUFPTR],ARG_ARGBUF
 11097 0000234C C706[FD49][7D47]        		mov	word [ARGBUFPTR],ARG+ARG_UNIT.argbuf
 11098                                  		;mov	word [ARG_ARGSWINFO],0 ; switch information, and info to date
 11099 00002352 C706[7B47]0000          		mov	word [ARG+ARG_UNIT.argswinfo],0
 11100                                  		;mov	word [ARG_ARGVCNT],0 ; initialize argvcnt/argv[]
 11101 00002358 C706[7947]0000          		mov	word [ARG+ARG_UNIT.argvcnt],0
 11102 0000235E BE[E23F]                		mov	si,COMBUF+2	; prescan leaves cooked input in combuf
 11103                                  
 11104                                  ; This next section of code (up to pcont:)  makes sure that si is set up for
 11105                                  ; parsing. It should point at COMBUF if FORFLAG is set and arg.argforcombuf
 11106                                  ; otherwise. This is done so that commands can get arg pointers into their
 11107                                  ; original command line (or an exact copy of it) in arg_ocomptr.
 11108                                  ; Arg.argforcombuf is used so that the for loop processor will always be able
 11109                                  ; to get a hold of its original command line; even after COMBUF is blasted by
 11110                                  ; the command to be repeated or the transient part of command has been
 11111                                  ; reloaded.
 11112                                  
 11113 00002361 1E                      		push	ds
 11114 00002362 8E1E[8141]              		mov	ds,[RESSEG]
 11115 00002366 803EF50B00              		cmp	byte [FORFLAG],0
 11116 0000236B 1F                      		pop	ds
 11117 0000236C 7510                    		jnz	short PCONT
 11118                                  		;mov	di,ARG_ARGFORCOMBUF
 11119 0000236E BF[7D49]                		mov	di,ARG+ARG_UNIT.argforcombuf 
 11120 00002371 30ED                    		xor	ch,ch
 11121 00002373 8A0E[E13F]              		mov	cl,[COMBUF+1]
 11122 00002377 FEC1                    		inc	cl
 11123 00002379 F3A4                    		rep movsb
 11124                                  		;mov	si,ARG_ARGFORCOMBUF
 11125 0000237B BE[7D49]                		mov	si,ARG+ARG_UNIT.argforcombuf 
 11126                                  PCONT:
 11127 0000237E BF[FF49]                		mov	di,TPBUF	; destination is temporary token buffer	
 11128 00002381 B320                    		mov	bl,' '		; no special delimiter, for now
 11129                                  PARSELOOP:
 11130 00002383 8936[814A]              		mov	[COMPTR],si	; save ptr into original command buffer
 11131 00002387 31ED                    		xor	bp,bp		; switch information put here by cparse
 11132 00002389 C606[B744]00            		mov	byte [EXPAND_STAR],0 ; don't expand *'s to ?'s
 11133 0000238E E8B5F5                  		call	SCANOFF		; skip leading blanks...
 11134 00002391 E8E00E                  		call	CPARSE		; byte off a token (args in SI, DI, BL)
 11135 00002394 730B                    		jnb	short MORE_PRSE
 11136 00002396 09ED                    		or	bp,bp		; Check for trailing switch character
 11137 00002398 7403                    		jz	short PARSEDONE
 11138 0000239A E81700                  		call	NEWARG		; We hit CR but BP is non-zero. The
 11139                                  					;   typical cause of this is that a
 11140                                  					;   switch char IMMEDIATELY preceeds
 11141                                  					;   the CR. We have an argument, but it
 11142                                  					;   is sort of an error.
 11143                                  		;jmp	short PARSEDONE	; We're done (found the CR).
 11144                                  		; 01/03/2023
 11145                                  PARSEDONE:
 11146 0000239D 9D                      		popf
 11147 0000239E F8                      		clc
 11148 0000239F EB0C                    		jmp	short PARSE_EXIT
 11149                                  
 11150                                  MORE_PRSE:
 11151 000023A1 C606[6643]02            		mov	byte [CPYFLAG],2 ; tell CPARSE that 1st token is done
 11152 000023A6 E80B00                  		call	NEWARG		; add to argv array (CX has char count)
 11153 000023A9 73D8                    		jnb	short PARSELOOP	; was everything OK?
 11154                                  		;jmp	short PARSE_ERROR ; NO, it wasn't -- bug out (CF set)
 11155                                  		; 01/03/2023
 11156                                  ;PARSEDONE:
 11157                                  		;popf
 11158                                  		;clc
 11159                                  		;jmp	short PARSE_EXIT
 11160                                  
 11161                                  PARSE_ERROR:				; error entry (er, exit) point
 11162 000023AB 9D                      		popf
 11163 000023AC F9                      		stc
 11164                                  PARSE_EXIT:				; depend on not changing CF
 11165 000023AD 5E                      		pop	si
 11166 000023AE 5F                      		pop	di
 11167 000023AF 5A                      		pop	dx
 11168 000023B0 59                      		pop	cx
 11169 000023B1 5B                      		pop	bx
 11170 000023B2 58                      		pop	ax
 11171 000023B3 C3                      		retn
 11172                                  
 11173                                  ; =============== S U B	R O U T	I N E =======================================
 11174                                  
 11175                                  ; NEWARG adds the supplied argstring and cparse data to arg.argv[].
 11176                                  ;
 11177                                  ; ENTRY:
 11178                                  ;   BH			argflags
 11179                                  ;   CX			character count in argstring
 11180                                  ;   DI			pointer to argstring
 11181                                  ;   comptr		ptr to starting loc of current token in original command
 11182                                  ;   [STARTEL]		cparse's answer to where the last element starts
 11183                                  ; EXIT:
 11184                                  ;   argbufptr		points to next free section of argbuffer
 11185                                  ;   arg.argbuf		contains null-terminated argument strings
 11186                                  ;   arg.argvcnt 	argument count
 11187                                  ;   arg.argv[]		array of flags and pointers
 11188                                  ;   arg.arg_ocomptr	ptr to starting loc of current token in original command
 11189                                  ;   CF			set if error
 11190                                  ;   AL			carry set:  error code; otherwise, zero
 11191                                  
 11192                                  NEWARG:
 11193 000023B4 53                      		push	bx
 11194 000023B5 51                      		push	cx
 11195 000023B6 52                      		push	dx
 11196 000023B7 57                      		push	di
 11197 000023B8 56                      		push	si
 11198 000023B9 9C                      		pushf
 11199 000023BA E86600                  		call	ARG_SWITCH	; if it's a switch, record switch info
 11200                                  					; LEAVE SWITCH ON COMMAND LINE!!
 11201                                  		;;;jc	short newarg_done ; previous arg's switches -- and leave
 11202                                  
 11203                                  		;cmp	word [ARG_ARGVCNT],64	; check to ensure we've not
 11204 000023BD 833E[7947]40            		cmp	word [ARG+ARG_UNIT.argvcnt],ARGMAX ; 64
 11205 000023C2 7D4F                    		jge	short TO_MANY_ARGS	; exceeded array limits
 11206 000023C4 88FE                    		mov	dh,bh			
 11207                                  		;mov	bx,[ARG_ARGVCNT]	; save argflags	
 11208 000023C6 8B1E[7947]              		mov	bx,[ARG+ARG_UNIT.argvcnt] ; argv[argvcnt++] = arg data
 11209                                  		;inc	word [ARG_ARGVCNT]
 11210 000023CA FF06[7947]              		inc	word [ARG+ARG_UNIT.argvcnt]
 11211                                  		;mov	ax,ARG_ARGV
 11212 000023CE B8[B944]                		mov	ax,ARG+ARG_UNIT.argv
 11213 000023D1 E88200                  		call	ARGV_CALC	; convert offset to pointer
 11214                                  		;mov	[BX].argsw_word,0 ; no switch information, yet...
 11215                                  		;mov	word [bx+7],0
 11216 000023D4 C747070000              		mov	word [bx+ARGV_ELE.argsw_word],0
 11217                                  		;mov	[BX].arglen,CX	; argv[argvcnt].arglen = arg length
 11218                                  		;mov	[bx+5],cx
 11219 000023D9 894F05                  		mov	[bx+ARGV_ELE.arglen],cx 
 11220                                  		;mov	[BX].argflags,DH ; argv[argvcnt].argflags = cparse flags
 11221                                  		;mov	[bx+2],dh
 11222 000023DC 887702                  		mov	[bx+ARGV_ELE.argflags],dh
 11223 000023DF 8B36[FD49]              		mov	si,[ARGBUFPTR]
 11224                                  		;mov	[BX].argpointer,SI ; argv[argvcnt].argpointer = [argbufptr]
 11225                                  		;mov	[bx+ARGV_ELE.argpointer],si
 11226 000023E3 8937                    		mov	[bx],si			
 11227 000023E5 0336[A744]              		add	si,[STARTEL]		; save startel from new location
 11228 000023E9 29FE                    		sub	si,di			; form pointer into argbuf
 11229                                  		;mov	[BX].argstartel,SI ; argv[argvcnt].argstartel = new [STARTEL]
 11230                                  		;mov	[bx+3],si
 11231 000023EB 897703                  		mov	[bx+ARGV_ELE.argstartel],si
 11232 000023EE 8B36[814A]              		mov	si,[COMPTR]
 11233                                  		;mov	[BX].arg_ocomptr,si ; arg_ocomptr = ptr into original com line
 11234                                  		;mov	[bx+9],si
 11235 000023F2 897709                  		mov	[bx+ARGV_ELE.arg_ocomptr],si
 11236                                  
 11237 000023F5 89FE                    		mov	si,di			; now save argstring in argbuffer
 11238 000023F7 8B3E[FD49]              		mov	di,[ARGBUFPTR]		; load the argbuf pointer and make
 11239 000023FB 01CF                    		add	di,cx			; sure we're not about to run off
 11240                                  		;cmp	DI, OFFSET TRANGROUP:arg.argbuf+ARGBLEN-1
 11241                                  		;cmp	di,ARG_ARGBUF+255
 11242 000023FD 81FF[7C48]              		cmp	di,ARG+ARG_UNIT.argbuf+ARGBLEN-1
 11243 00002401 7D15                    		jge	short BUF_OVFLOW     ; the end of the buffer (plus null byte)	
 11244 00002403 29CF                    		sub	di,cx
 11245 00002405 FC                      		cld
 11246 00002406 F3A4                    		rep movsb
 11247 00002408 B000                    		mov	al,ANULL ; 0		; tack a null byte on the end
 11248 0000240A AA                      		stosb
 11249 0000240B 893E[FD49]              		mov	[ARGBUFPTR],di		; update argbufptr after copy
 11250                                  
 11251                                  NEWARG_DONE:
 11252 0000240F 9D                      		popf
 11253 00002410 F8                      		clc
 11254 00002411 EB0A                    		jmp	short NEWARG_EXIT
 11255                                  
 11256                                  TO_MANY_ARGS:
 11257 00002413 B80100                  		mov	ax,1
 11258 00002416 EB03                    		jmp	short NEWARG_ERROR
 11259                                  
 11260                                  BUF_OVFLOW:
 11261 00002418 B80200                  		mov	ax,2
 11262                                  NEWARG_ERROR:
 11263 0000241B 9D                      		popf
 11264 0000241C F9                      		stc
 11265                                  NEWARG_EXIT:
 11266 0000241D 5E                      		pop	si
 11267 0000241E 5F                      		pop	di
 11268 0000241F 5A                      		pop	dx
 11269 00002420 59                      		pop	cx
 11270 00002421 5B                      		pop	bx
 11271 00002422 C3                      		retn
 11272                                  
 11273                                  ; =============== S U B	R O U T	I N E =======================================
 11274                                  
 11275                                  ; ARG_SWITCH decides if an argument might really be a switch. In the
 11276                                  ; event that it is, and we can recognize
 11277                                  ;
 11278                                  ; ENTRY:
 11279                                  ;   As in <newarg>.
 11280                                  ; EXIT:
 11281                                  ;   CF	    --	    clear (wasn't a switch); set (was a switch)
 11282                                  ; NOTE(S):
 11283                                  ;   *	The mechanism mapping a switch into a bit-value depends entirely
 11284                                  ;	on the order of definition in the <switch_list> variable and the
 11285                                  ;	values chosen to define the bits in CMDT:COMEQU.ASM. Change either
 11286                                  ;	<switch_list> or the definitions in CMDT:COMEQU.ASM -- and rewrite
 11287                                  ;	this mechanism. This code taken from CMDT:TCODE.ASM.
 11288                                  ;   *	The <switch_list> declared below is redundant to one declared in
 11289                                  ;	TDATA.ASM, and used in TCODE.ASM.
 11290                                  ;   *	An ugly routine.
 11291                                  
 11292                                  ARG_SWITCH:
 11293 00002423 50                      		push	ax
 11294 00002424 53                      		push	bx
 11295 00002425 51                      		push	cx
 11296 00002426 57                      		push	di
 11297 00002427 9C                      		pushf
 11298 00002428 F6C701                  		test	bh,sw_flag ; 1	; is it a switch? (preserve flag word)
 11299 0000242B 741C                    		jz	short ARG_NO_SWITCH0
 11300 0000242D 833E[7F4A]FF            		cmp	word [LASTARG],-1 ; have we encountered any REAL args yet?
 11301 00002432 741B                    		je	short ARG_NO_SWITCH1 ; no, so leading switches don't matter
 11302 00002434 8B1E[7F4A]              		mov	bx,[LASTARG]	; yes, add switch info to last REAL arg
 11303                                  		;mov	ax,offset TRANGROUP:arg.argv
 11304                                  		;mov	ax,ARG_ARGV
 11305 00002438 B8[B944]                		mov	ax,ARG+ARG_UNIT.argv  ; ARG+0
 11306 0000243B E81800                  		call	ARGV_CALC
 11307                                  		;or	[BX].argsw_word,BP
 11308                                  		;or	[bx+7],bp
 11309 0000243E 096F07                  		or	[bx+ARGV_ELE.argsw_word],bp
 11310                                  		;or	arg.argswinfo,BP
 11311                                  		;or	[ARG_ARGSWINFO],bp
 11312 00002441 092E[7B47]              		or	[ARG+ARG_UNIT.argswinfo],bp
 11313                                  ARG_YES_SWITCH:
 11314 00002445 9D                      		popf
 11315 00002446 F9                      		stc
 11316 00002447 EB08                    		jmp	short ARG_SWITCH_EXIT
 11317                                  
 11318                                  ARG_NO_SWITCH0:
 11319                                  		;mov	ax,[ARG_ARGVCNT]
 11320 00002449 A1[7947]                		mov	ax,[ARG+ARG_UNIT.argvcnt]
 11321 0000244C A3[7F4A]                		mov	[LASTARG],ax
 11322                                  ARG_NO_SWITCH1:
 11323 0000244F 9D                      		popf
 11324 00002450 F8                      		clc
 11325                                  ARG_SWITCH_EXIT:
 11326 00002451 5F                      		pop	di
 11327 00002452 59                      		pop	cx
 11328 00002453 5B                      		pop	bx
 11329 00002454 58                      		pop	ax
 11330 00002455 C3                      		retn
 11331                                  
 11332                                  ; =============== S U B	R O U T	I N E =======================================
 11333                                  
 11334                                  ; ARGV_CALC maps an array index into a byte-offset from the base of
 11335                                  ; the supplied array.  Method used for computing the address is:
 11336                                  ;	Array Index * Array Elt Size + Base Addr = Elt Addr
 11337                                  ; ENTRY:
 11338                                  ;   AX	    --	    base of array
 11339                                  ;   BX	    --	    array index
 11340                                  ; EXIT:
 11341                                  ;   BX	    --	    byte offset
 11342                                  
 11343                                  ARGV_CALC:
 11344 00002456 50                      		push	ax		; Save base
 11345 00002457 88D8                    		mov	al,bl		; al = array index
 11346                                  		;mov	bl,11
 11347 00002459 B30B                    		mov	bl,ARGV_ELE.SIZE ; bl = size of an argv element
 11348 0000245B F6E3                    		mul	bl		; ax = base offset
 11349 0000245D 5B                      		pop	bx		; Get base
 11350 0000245E 01D8                    		add	ax,bx		; Add in base offset
 11351 00002460 93                      		xchg	ax,bx		; Restore ax and put byte offset in bx
 11352 00002461 C3                      		retn
 11353                                  
 11354                                  ; ---------------------------------------------------------------------------
 11355                                  	
 11356                                  		;db 0Ah dup(0)
 11357                                  		;times 10 db 0
 11358 00002462 90<rep Eh>              align 16
 11359                                  
 11360                                  ;============================================================================
 11361                                  ; PATH1.ASM, MSDOS 6.0, 1991
 11362                                  ;============================================================================
 11363                                  ; 03/10/2018 - Retro DOS v3.0
 11364                                  
 11365                                  ;----------------------------------------------------------------------------
 11366                                  ;    PATH.ASM contains the routines to perform pathname incovation. Path and
 11367                                  ;    Parse share a temporary buffer and argv[] definitions. <Path_Search>,
 11368                                  ;    given a pathname, attempts to find a corresponding executable or batch
 11369                                  ;    file on disk. Directories specified in the user's search path will be
 11370                                  ;    searched for a matching file, if a match is not found in the current
 11371                                  ;    directory and if the pathname is actually only an MSDOS filename.
 11372                                  ;    <Path_Search> assumes that the parsed command name can be found in
 11373                                  ;    argv[0] -- in other words, <Parseline> should be executed prior to
 11374                                  ;    <Path_Search>. Alternatively, the command name and appropriate
 11375                                  ;    information could be placed in argv[0], or <Path_Search> could be
 11376                                  ;    (easily) modified to make no assumptions about where its input is found.
 11377                                  ;    Please find enclosed yet another important routine, <Save_Args>, which
 11378                                  ;    places the entire arg/argv[]/argbuf structure on a piece of newly
 11379                                  ;    allocated memory. This is handy for for-loop processing, and anything
 11380                                  ;    else that wants to save the whole shebang and then process other command
 11381                                  ;    lines.
 11382                                  ;
 11383                                  ; Alan L, OS/MSDOS				    August 15, 1983
 11384                                  ;
 11385                                  ; ENTRY:
 11386                                  ;   <Path_Search>:	    argv[0].
 11387                                  ;   <Save_Args>:	    bytes to allocate in addition to arg structure
 11388                                  ; EXIT:
 11389                                  ;   <Path_Search>:	    success flag, best pathname match in EXECPATH.
 11390                                  ;   <Save_Args>:	    success flag, segment address of new memory
 11391                                  ; NOTE(S):
 11392                                  ;   *	<Argv_calc> handily turns an array index into an absolute pointer.
 11393                                  ;	The computation depends on the size of an argv[] element (arg_ele).
 11394                                  ;   *	<Parseline> calls <cparse> for chunks of the command line. <Cparse>
 11395                                  ;	does not function as specified; see <Parseline> for more details.
 11396                                  ;   *	<Parseline> now knows about the flags the internals of COMMAND.COM
 11397                                  ;	need to know about. This extra information is stored in a switch_flag
 11398                                  ;	word with each command-line argument; the switches themselves will not
 11399                                  ;	appear in the resulting arg structure.
 11400                                  ;   *	With the exception of CARRY, flags are generally preserved across calls.
 11401                                  ;----------------------------------------------------------------------------
 11402                                  
 11403                                  ; =============== S U B	R O U T	I N E =======================================
 11404                                  
 11405                                  ; PATH_SEARCH tries to find the file it's given, somewhere. An initial value
 11406                                  ; of *argv[0].argstartel == 0 implies that there is no command (empty line
 11407                                  ; or 'd:' or 'd:/'). This check is done in strip; otherwise, strip formats
 11408                                  ; the filename/pathname into tpbuf. Search(tpbuf) is executed to see if we
 11409                                  ; have a match, either in the current working directory if we were handed
 11410                                  ; a filename, or in the specified directory, given a pathname. If this call
 11411                                  ; fails, and we were given a pathname, then Path_Search fails. Otherwise,
 11412                                  ; Path_Crunch is repeatedly invoked on tpbuf[STARTEL] (if there's a drive
 11413                                  ; prefix, we want to skip it) for each pathstring in userpath. Success on
 11414                                  ; either the first invocation of search or on one of the succeeding calls
 11415                                  ; sets up the appropriate information for copying the successful pathname
 11416                                  ; prefix (if any) into the result buffer, followed by the successful filename
 11417                                  ; match (from [search_best_buf]). The result is returned in in EXECPATH.
 11418                                  ;
 11419                                  ; ENTRY:
 11420                                  ;   argv[0]		--	command name and associated information
 11421                                  ; EXIT:
 11422                                  ;   AX			--	non-zero indicates type of file found
 11423                                  ;   EXECPATH		--	successful pathname (AX non-zero)
 11424                                  ; NOTE(S):
 11425                                  ;   1)	Uses the temporary buffer, tpbuf, from the parse routines.
 11426                                  ;   2)	Some files are more equal than others.	See search: for rankings.
 11427                                  ;   3)	Path_Search terminates as soon as a call to search succeeds, even
 11428                                  ;	if search returns an .exe or .bat.
 11429                                  ;   5)	Clobbers dma address.
 11430                                  
 11431                                  PBUFLEN 	EQU	128		; length of EXECPATH
 11432                                  PATH_SEP_CHAR	EQU	';'
 11433                                  
 11434                                  ;parseflags RECORD special_delim:1, unused:4, path_sep:1, wildcard:1, sw_flag:1
 11435                                  
 11436                                  		;special_delim equ 128
 11437                                  		;path_sep equ 4
 11438                                  		;wildcard equ 2
 11439                                  		;sw_flag  equ 1
 11440                                  
 11441                                  ;----------------------------------------------------------------------------
 11442                                  
 11443                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2510h
 11444                                  
 11445                                  PATH_SEARCH:
 11446 00002470 53                      		push	bx
 11447 00002471 51                      		push	cx
 11448 00002472 52                      		push	dx		; could use a "stack 'em" instruction
 11449 00002473 56                      		push	si
 11450 00002474 57                      		push	di
 11451 00002475 55                      		push	bp
 11452 00002476 9C                      		pushf
 11453                                  
 11454                                  		;test	ds:arg.argv[0].argflags, (MASK wildcard) + (MASK sw_flag)
 11455                                  		;test	byte [ARGV0_ARG_FLAGS],3
 11456 00002477 F606[BB44]03            		test	byte [ARG+ARGV_ELE.argflags],wildcard+sw_flag ; 3
 11457 0000247C 7403                    		jz	short PATH_SEARCH_OK
 11458                                  
 11459                                  PATH_FAILURE_JMP:
 11460 0000247E E9C300                  		jmp	PATH_FAILURE	; ambiguous commands not allowed
 11461                                  
 11462                                  PATH_SEARCH_OK:
 11463 00002481 E83C01                  		call	STORE_PCHAR	; figure out the pathname separator
 11464 00002484 BA[834A]                		mov	dx,FBUF		; clobber old dma value with
 11465 00002487 B8001A                  		mov	ax,SET_DMA*256 ; 1A00h ; a pointer to our dma buffer
 11466 0000248A CD21                    		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 11467                                  				; DS:DX	-> disk	transfer buffer
 11468 0000248C 06                      		push	es
 11469 0000248D E8D5F2                  		call	FIND_PATH	; get a handle (ES:DI) on user path
 11470 00002490 8C06[AE4A]              		mov	[PATHINFO+0],es	; and squirrel it away
 11471 00002494 893E[B04A]              		mov	[PATHINFO+2],di	; "old" pathstring pointer
 11472 00002498 893E[B24A]              		mov	[PATHINFO+4],di	; "new" pathstring pointer
 11473 0000249C 07                      		pop	es
 11474                                  		
 11475 0000249D BB8000                  		mov	bx,PBUFLEN ; 128 ; copy/format argv[0] into temp buffer
 11476 000024A0 BE[A940]                		mov	si,EXECPATH
 11477 000024A3 E84602                  		call	STRIP
 11478 000024A6 72D6                    		jc	short PATH_FAILURE_JMP ; if possible, of course
 11479                                  		
 11480 000024A8 89F2                    		mov	dx,si		; search (EXECPATH, error_message)
 11481 000024AA C706[034B][7938]        		mov	word [SEARCH_ERROR],BADDRVPTR
 11482 000024B0 E87E01                  		call	PSEARCH		; must do at least one search
 11483 000024B3 09C0                    		or	ax,ax		; find anything?
 11484 000024B5 746B                    		jz	short PATH_NOINIT ; failure ... search farther	
 11485                                  		
 11486 000024B7 89C5                    		mov	bp,ax		; success... save filetype code	
 11487 000024B9 BF[A940]                		mov	di,EXECPATH
 11488                                  		;mov	si,ds:arg.argv[0].argpointer
 11489                                  		;mov	si,[ARG_ARGV]
 11490 000024BC 8B36[B944]              		mov	si,[ARG+ARGV_ELE.argpointer]
 11491                                  		;mov	cx,ds:arg.argv[0].argstartel
 11492                                  		;mov	cx,[ARGV0_ARGSTARTEL]
 11493 000024C0 8B0E[BC44]              		mov	cx,[ARG+ARGV_ELE.argstartel]
 11494 000024C4 29F1                    		sub	cx,si		; compute prefix bytes to copy
 11495                                  
 11496                                  ; We have the number of bytes in the prefix (up to the final component).
 11497                                  ; We need to form the complete pathname including leading drive and current
 11498                                  ; directory.
 11499                                  ;
 11500                                  ; Is there a drive letter present?
 11501                                  
 11502 000024C6 B43A                    		mov	ah,':'
 11503 000024C8 83F902                  		cmp	cx,2		; room for drive letter?
 11504 000024CB 7205                    		jb	short ADDDRIVE	; no, stick it in
 11505 000024CD 386401                  		cmp	[si+1],	ah	; colon present?
 11506 000024D0 7408                    		jz	short MOVEDRIVE	; yes, just move it
 11507                                  ADDDRIVE:
 11508 000024D2 A0[9541]                		mov	al,[CURDRV]	; get current drive
 11509 000024D5 0441                    		add	al,'A'		; convert to uppercase letter
 11510 000024D7 AB                      		stosw			; store d:
 11511 000024D8 EB05                    		jmp	short CHECKPATH
 11512                                  MOVEDRIVE:
 11513 000024DA AD                      		lodsw			; move d:
 11514 000024DB AB                      		stosw
 11515 000024DC 83E902                  		sub	cx,2		; 2 bytes less to move
 11516                                  CHECKPATH:
 11517 000024DF 0C20                    		or	al,20h
 11518 000024E1 88C2                    		mov	dl,al		
 11519                                  		;sub	dl,60h
 11520 000024E3 80EA60                  		sub	dl,'a'-1	; convert to 1-based for current dir
 11521                                  
 11522                                  ; Stick in beginning path char
 11523                                  
 11524 000024E6 A0[B44A]                		mov	al,[PSEP_CHAR]
 11525 000024E9 AA                      		stosb
 11526                                  
 11527                                  ; Is there a leading /? If so, then no current dir copy is necessary.
 11528                                  ; Otherwise, get current dir for DL.
 11529                                  
 11530 000024EA 83F901                  		cmp	cx,1		; is there room for path char?
 11531 000024ED 720A                    		jb	short ADDPATH	; no, go add path
 11532 000024EF AC                      		lodsb
 11533 000024F0 49                      		dec	cx
 11534 000024F1 3A06[B44A]              		cmp	al,[PSEP_CHAR]	; is there a path separator?
 11535 000024F5 741E                    		jz	short MOVEPATH	; yes, go move remainder of path
 11536 000024F7 41                      		inc	cx
 11537 000024F8 4E                      		dec	si		; undo the lodsb
 11538                                  ADDPATH:
 11539 000024F9 56                      		push	si
 11540 000024FA 89FE                    		mov	si,di		; remainder of buffer
 11541 000024FC B80047                  		mov	ax,CURRENT_DIR*256 ; 4700h
 11542 000024FF CD21                    		int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 11543                                  				; DL = drive (0=default,1=A,etc.)
 11544                                  				; DS:SI	points to 64-byte buffer area
 11545                                  
 11546                                  ; The previous current dir will succeed a previous find_first already worked.
 11547                                  ;
 11548                                  ; Find end of string.
 11549                                  
 11550 00002501 89F7                    		mov	di,si
 11551 00002503 5E                      		pop	si
 11552 00002504 A0[B44A]                		mov	al,[PSEP_CHAR]
 11553 00002507 803D00                  		cmp	byte [di],0	; root (empty dir string)?
 11554 0000250A 7409                    		jz	short MOVEPATH	; yes, no need for path char
 11555                                  SCANEND:
 11556 0000250C 803D00                  		cmp	byte [di],0	; end of string?
 11557 0000250F 7403                    		jz	short FOUNDEND
 11558 00002511 47                      		inc	di
 11559 00002512 EBF8                    		jmp	short SCANEND
 11560                                  
 11561                                  ; Stick in a trailing path char.
 11562                                  
 11563                                  FOUNDEND:
 11564 00002514 AA                      		stosb
 11565                                  
 11566                                  ; Move remaining part of path.	Skip leading path char if present.
 11567                                  
 11568                                  MOVEPATH:
 11569 00002515 3804                    		cmp	[si],al		; first char a path char?
 11570 00002517 7502                    		jnz	short COPYPATH
 11571 00002519 46                      		inc	si		; move past leading char
 11572 0000251A 49                      		dec	cx		; drop from count
 11573                                  COPYPATH:
 11574 0000251B E302                    		jcxz	_COPYDONE	; no chars to move!	
 11575 0000251D F3A4                    		rep movsb
 11576                                  _COPYDONE:
 11577 0000251F E98900                  		jmp	PATH_SUCCESS	; run off and form complete pathname
 11578                                  
 11579                                  PATH_NOINIT:
 11580                                  		;test	ds:arg.argv[0].argflags, MASK path_sep
 11581                                  		;test	byte [ARGV0_ARG_FLAGS],4
 11582 00002522 F606[BB44]04            		test	byte [ARG+ARGV_ELE.argflags],path_sep
 11583 00002527 751B                    		jnz	short PATH_FAILURE ; complete pathname specified ==> fail
 11584                                  		;mov	bh,';'
 11585 00002529 B73B                    		mov	bh,PATH_SEP_CHAR ; semicolon terminates pathstring
 11586                                  		;mov	dx,ds:arg.argv[0].argstartel
 11587                                  					; this is where the last element starts
 11588                                  		;mov	dx,[ARGV0_ARGSTARTEL]
 11589 0000252B 8B16[BC44]              		mov	dx,[ARG+ARGV_ELE.argstartel]
 11590                                  		;sub	dx,ds:arg.argv[0].argpointer
 11591                                  					; form pointer into EXECPATH,
 11592                                  		;sub	dx,[ARG_ARGV]
 11593 0000252F 2B16[B944]              		sub	dx,[ARG+ARGV_ELE.argpointer]
 11594 00002533 81C2[A940]              		add	dx,EXECPATH	; skipping over drive spec, if any
 11595                                  PATH_LOOP:
 11596 00002537 E89500                  		call	PATH_CRUNCH	; pcrunch (EXECPATH, pathinfo)
 11597 0000253A 89C5                    		mov	bp,ax		; save filetype code
 11598 0000253C 9F                      		lahf			; save flags, just in case
 11599 0000253D 09ED                    		or	bp,bp		; did path_crunch find anything?		
 11600 0000253F 7507                    		jnz	short PATH_FOUND 
 11601 00002541 9E                      		sahf			; see?	needed those flags, after all!
 11602 00002542 73F3                    		jnb	short PATH_LOOP	; is there anything left to the path?
 11603                                  PATH_FAILURE:
 11604 00002544 31C0                    		xor	ax,ax
 11605 00002546 EB70                    		jmp	short PATH_EXIT
 11606                                  
 11607                                  PATH_FOUND:				; pathinfo[] points to winner
 11608 00002548 BF[A940]                		mov	di,EXECPATH
 11609                                  		;mov	cx,pathinfo[4] 
 11610 0000254B 8B0E[B24A]              		mov	cx,[PATHINFO+4]	; "new" pointer -- end of string
 11611                                  		;mov	SI,pathinfo[2]
 11612 0000254F 8B36[B04A]              		mov	si,[PATHINFO+2]	; "old" pointer -- beginning of string
 11613                                  
 11614                                  ;	BAS Nov 20/84
 11615                                  ;   Look at the pathname and expand . and .. if they are the first element
 11616                                  ;   in the pathname (after the drive letter)
 11617                                  
 11618 00002553 06                      		push	es
 11619                                  		;push	pathinfo[0]
 11620 00002554 FF36[AE4A]              		push	word [PATHINFO+0]
 11621 00002558 07                      		pop	es
 11622                                  ;SR;
 11623                                  ; Oops! Gets fooled if path= \;..
 11624                                  ; We should also check if a drive letter is really present
 11625                                  ;
 11626 00002559 26807C022E              		cmp	byte [es:si+2],'.' ; Look for Current dir at start of path
 11627 0000255E 7534                    		jnz	short PATH_CPY
 11628                                  
 11629                                  		; MSDOS 6.0
 11630                                  		;cmp	byte ptr es:[si+1],':' ;does path have drive letter?
 11631                                  		;jnz	path_cpy	       ;no, copy the path string
 11632                                  
 11633 00002560 51                      		push	cx		; Save pointer to end of string
 11634 00002561 268A04                  		mov	al,[es:si]
 11635 00002564 8805                    		mov	[di],al		; Copy drive letter, :, and root char
 11636 00002566 268A4401                		mov	al,[es:si+1]	; to EXECPATH
 11637 0000256A 884501                  		mov	[di+1],al
 11638 0000256D A0[B44A]                		mov	al,[PSEP_CHAR]
 11639 00002570 884502                  		mov	[di+2],	al
 11640 00002573 56                      		push	si		; Save pointer to begining of string
 11641 00002574 268A14                  		mov	dl,[es:si]	; Convert device letter for cur dir
 11642 00002577 80CA20                  		or	dl,20h
 11643                                  		;sub	dl,60h
 11644 0000257A 80EA60                  		sub	dl,'a'-1
 11645 0000257D 89FE                    		mov	si,di		; pointer to EXECPATH
 11646 0000257F 83C603                  		add	si,3		; Don't wipe out drive and root info
 11647 00002582 B80047                  		mov	ax,CURRENT_DIR*256 ; 4700h
 11648 00002585 CD21                    		int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 11649                                  				; DL = drive (0=default,1=A,etc.)
 11650                                  				; DS:SI	points to 64-byte buffer area
 11651 00002587 E8E1F8                  		call	DSTRLEN		; Determine length of present info
 11652 0000258A 01CE                    		add	si,cx		; Don't copy over drive and root info
 11653 0000258C 4E                      		dec	si
 11654 0000258D 89F7                    		mov	di,si		; Point to end of target string
 11655 0000258F 5E                      		pop	si		; Restore pointer to begining of string
 11656 00002590 83C603                  		add	si,3		; Point past drive letter, :, .
 11657 00002593 59                      		pop	cx		; Restore pointer to end of string
 11658                                  PATH_CPY:
 11659 00002594 07                      		pop	es
 11660 00002595 29F1                    		sub	cx,si		; yields character count
 11661 00002597 1E                      		push	ds		; time to switch segments
 11662 00002598 FF36[AE4A]              		push	word [PATHINFO+0] ; string lives in this segment
 11663 0000259C 1F                      		pop	ds
 11664 0000259D FC                      		cld
 11665 0000259E F3A4                    		rep movsb
 11666 000025A0 1F                      		pop	ds		; return to our segment
 11667 000025A1 4F                      		dec	di		; overwrite terminator
 11668 000025A2 A0[B44A]                		mov	al,[PSEP_CHAR]	; with a pathname separator
 11669 000025A5 3A45FF                  		cmp	al,[di-1]
 11670 000025A8 7401                    		jz	short PATH_SUCCESS
 11671 000025AA AA                      		stosb
 11672                                  PATH_SUCCESS:
 11673 000025AB BE[B64A]                		mov	si,SEARCH_BEST_BUF
 11674 000025AE 31C9                    		xor	cx,cx
 11675                                  PATH_SUCC_LOOP:
 11676 000025B0 AC                      		lodsb			; append winning filename to path
 11677 000025B1 AA                      		stosb			; (including terminating null)	
 11678 000025B2 08C0                    		or	al,al
 11679 000025B4 75FA                    		jnz	short PATH_SUCC_LOOP
 11680 000025B6 89E8                    		mov	ax,bp		; retrieve filetype code
 11681                                  PATH_EXIT:
 11682 000025B8 9D                      		popf
 11683 000025B9 5D                      		pop	bp
 11684 000025BA 5F                      		pop	di
 11685 000025BB 5E                      		pop	si		; chill out...
 11686 000025BC 5A                      		pop	dx
 11687 000025BD 59                      		pop	cx
 11688 000025BE 5B                      		pop	bx
 11689 000025BF C3                      		retn
 11690                                  
 11691                                  
 11692                                  ; =============== S U B	R O U T	I N E =======================================
 11693                                  
 11694                                  ; STORE_PCHAR determines the pathname-element separator and squirrels
 11695                                  ; it away. In other words, must we say '/bin/ls' or '\bin\ls'?
 11696                                  ;
 11697                                  ; ENTRY:
 11698                                  ; EXIT:
 11699                                  ; NOTE(S):
 11700                                  ;   *	Uses <psep_char>, defined in <path_search>.
 11701                                  
 11702                                  STORE_PCHAR:
 11703 000025C0 50                      		push	ax
 11704 000025C1 B02F                    		mov	al,'/'		; is the pathname-element separator
 11705 000025C3 E812F4                  		call	PATHCHRCMP	; a regular slash?
 11706 000025C6 7402                    		jz	short STORE_SLASH ; if yes, remember slash
 11707 000025C8 B05C                    		mov	al,'\'
 11708                                  		; 02/03/2023
 11709                                  		;mov	[PSEP_CHAR],al	; otherwise, remember back-slash
 11710                                  		;pop	ax
 11711                                  		;retn
 11712                                  STORE_SLASH:
 11713 000025CA A2[B44A]                		mov	[PSEP_CHAR],al
 11714 000025CD 58                      		pop	ax
 11715 000025CE C3                      		retn
 11716                                  
 11717                                  ; =============== S U B	R O U T	I N E =======================================
 11718                                  
 11719                                  ; PATH_CRUNCH takes a prefix from a prefix string, and a suffix from
 11720                                  ; EXECPATH, and smooshes them into tpbuf. The caller may supply an
 11721                                  ; additional separator to use for breaking up the path-string. Null is the
 11722                                  ; default. Once the user-string has been formed, search is invoked to see
 11723                                  ; what's out there.
 11724                                  ;
 11725                                  ; ENTRY:
 11726                                  ;   BH			--	additional terminator character
 11727                                  ;   SI			--	pointer into pathstring to be dissected
 11728                                  ;   DX			--	pointer to stripped filename
 11729                                  ; EXIT:
 11730                                  ;   AX			--	non-zero (file type), zero (nothing found)
 11731                                  ;   SI			--	moves along pathstring from call to call
 11732                                  ;   [search_best_buf]	--	name of best file (AX non-zero)
 11733                                  ;   [tpbuf]		--	clobbered
 11734                                  ; NOTE(S):
 11735                                  ;   *	Implicit in this code is the ability to specify when to search
 11736                                  ;	the current directory (if at all) through the PATH defined by
 11737                                  ;	the user, a la UNIX (e.g., PATH=;c:\bin;c:\etc searches the
 11738                                  ;	current directory before the bin and etc directories of drive c).
 11739                                  
 11740                                  PATH_CRUNCH:
 11741 000025CF 53                      		push	bx
 11742 000025D0 51                      		push	cx
 11743 000025D1 52                      		push	dx
 11744 000025D2 57                      		push	di
 11745 000025D3 56                      		push	si
 11746 000025D4 9C                      		pushf
 11747 000025D5 E8E8FF                  		call	STORE_PCHAR	; figure out pathname separator
 11748 000025D8 BF[FF49]                		mov	di,TPBUF	; destination of concatenated string
 11749 000025DB 8B36[B24A]              		mov	si,[PATHINFO+4]	; "new" pointer to start with
 11750 000025DF 8936[B04A]              		mov	[PATHINFO+2],si	; becomes "old" pointer
 11751 000025E3 1E                      		push	ds		; save old segment pointer
 11752 000025E4 FF36[AE4A]              		push	word [PATHINFO+0] ; replace with pointer to userpath's
 11753 000025E8 1F                      		pop	ds		; segment		
 11754                                  PATH_CR_COPY:
 11755 000025E9 AC                      		lodsb			; get a pathname byte
 11756 000025EA 08C0                    		or	al,al		; check for terminator(s)
 11757 000025EC 7407                    		jz	short PATH_SEG	; null terminates segment & pathstring
 11758 000025EE 38F8                    		cmp	al,bh
 11759 000025F0 7403                    		jz	short PATH_SEG	; BH terminates a pathstring segment
 11760 000025F2 AA                      		stosb
 11761 000025F3 EBF4                    		jmp	short PATH_CR_COPY
 11762                                  PATH_SEG:
 11763 000025F5 1F                      		pop	ds		; restore old data segment
 11764 000025F6 8936[B24A]              		mov	[PATHINFO+4],si	; save "new" pointer for next time
 11765 000025FA 88C3                    		mov	bl,al		; remember if we saw null or not...
 11766                                  					;;; REMOVE NEXT 3 LINES FOR CURDIR SPEC
 11767 000025FC 31C0                    		xor	ax,ax		; in case nothing in pathstr...
 11768 000025FE 81FF[FF49]              		cmp	di,TPBUF	; was there really anything in pathstr?		
 11769 00002602 741D                    		jz	short PATH_CR_LEAVE 
 11770                                  					; if nothing was copied, pathstr empty
 11771                                  PATH_CR_LOOK:
 11772 00002604 A0[B44A]                		mov	al,[PSEP_CHAR]	; form complete pathname
 11773 00002607 3A45FF                  		cmp	al,[di-1]	; add pathname separator for suffix
 11774 0000260A 7401                    		jz	short PATH_CR_L1
 11775 0000260C AA                      		stosb
 11776                                  PATH_CR_L1:
 11777 0000260D 89D6                    		mov	si,dx
 11778                                  PATH_CR_L2:
 11779 0000260F AC                      		lodsb			; tack the stripped filename onto
 11780 00002610 AA                      		stosb			; the end of the path, up to and
 11781 00002611 08C0                    		or	al,al		; including the terminating null
 11782 00002613 75FA                    		jnz	short PATH_CR_L2
 11783 00002615 BA[FF49]                		mov	dx,TPBUF	; and look for an appropriate file...	
 11784 00002618 C706[034B][703B]        		mov	word [SEARCH_ERROR],BADPMESPTR
 11785                                  		;invoke search
 11786 0000261E E81000                  		call	PSEARCH		; results are in AX & search_best_buf
 11787                                  PATH_CR_LEAVE:
 11788 00002621 08DB                    		or	bl,bl		; did we finish off the pathstring?
 11789 00002623 7404                    		jz	short PATH_CR_EMPTY ; null in BL means all gone...
 11790 00002625 9D                      		popf			; otherwise, plenty left
 11791 00002626 F8                      		clc
 11792 00002627 EB02                    		jmp	short PATH_CR_EXIT
 11793                                  PATH_CR_EMPTY:
 11794 00002629 9D                      		popf
 11795 0000262A F9                      		stc
 11796                                  PATH_CR_EXIT:
 11797 0000262B 5E                      		pop	si
 11798 0000262C 5F                      		pop	di
 11799 0000262D 5A                      		pop	dx
 11800 0000262E 59                      		pop	cx
 11801 0000262F 5B                      		pop	bx
 11802 00002630 C3                      		retn
 11803                                  
 11804                                  ;============================================================================
 11805                                  ; PATH2.ASM, MSDOS 6.0, 1991
 11806                                  ;============================================================================
 11807                                  ; 02/10/2018 - Retro DOS v3.0
 11808                                  
 11809                                  ;----------------------------------------------------------------------------
 11810                                  ;   SEARCH, when given a pathname, attempts to find a file with
 11811                                  ; one of the following extensions: .com, .exe, .bat (highest to
 11812                                  ; lowest priority). Where conflicts arise, the extension with
 11813                                  ; the highest priority is favored.
 11814                                  ; ENTRY:
 11815                                  ;   DX		--	pointer to null-terminated pathname
 11816                                  ;   fbuf	--	dma buffer for findfirst/next
 11817                                  ; EXIT:
 11818                                  ;   AX		--	8)  file found with .com extension
 11819                                  ;			4)  file found with .exe extension
 11820                                  ;			2)  file found with .bat extension
 11821                                  ;			0)  no such file to be found
 11822                                  ;   (if AX is non-zero:)
 11823                                  ;   [search_best]	identical to AX
 11824                                  ;   [search_best_buf]	null-terminated filename
 11825                                  ; NOTES:
 11826                                  ;   1)	Requires caller to have allocated a dma buffer and executed a setdma.
 11827                                  ;---------------
 11828                                  ; CONSTANTS:
 11829                                  ;---------------
 11830                                  SEARCH_FILE_NOT_FOUND	EQU	0
 11831                                  SEARCH_COM		EQU	8
 11832                                  SEARCH_EXE		EQU	4
 11833                                  SEARCH_BAT		EQU	2
 11834                                  FNAME_LEN		EQU	8
 11835                                  FNAME_MAX_LEN		EQU	13
 11836                                  DOT			EQU	'.'
 11837                                  WILDCHAR		EQU	'?'
 11838                                  
 11839                                  
 11840                                  ; =============== S U B	R O U T	I N E =======================================
 11841                                  
 11842                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 26D6h
 11843                                  
 11844                                  PSEARCH:
 11845 00002631 51                      		push	cx
 11846 00002632 52                      		push	dx
 11847 00002633 57                      		push	di
 11848 00002634 56                      		push	si
 11849 00002635 9C                      		pushf
 11850 00002636 52                      		push	dx		; check drivespec (save pname ptr)
 11851 00002637 89D7                    		mov	di,dx		; working copy of pathname
 11852 00002639 BE[C34A]                		mov	si,SEARCH_CURDIR_BUF
 11853 0000263C 31D2                    		xor	dx,dx		; zero means current drive
 11854 0000263E 807D013A                		cmp	byte [di+1],':'	; is there a drive spec?
 11855 00002642 7508                    		jne	short SEARCH_DIR_CHECK
 11856 00002644 8A15                    		mov	dl,[di]		; get the drive byte
 11857 00002646 80E2DF                  		and	dl,0DFh ; ~20h	; uppercase the sucker
 11858 00002649 80EA40                  		sub	dl,'@'		; and convert to drive number
 11859                                  SEARCH_DIR_CHECK:
 11860 0000264C B80047                  		mov	ax,CURRENT_DIR*256 ; 4700h
 11861 0000264F CD21                    		int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 11862                                  				; DL = drive (0=default,1=A,etc.)
 11863                                  				; DS:SI	points to 64-byte buffer area
 11864 00002651 5A                      		pop	dx		; directory? If we can't we'll		
 11865 00002652 723F                    		jc	short SEARCH_INVALID_DRIVE ; assume it's a bad drive...
 11866 00002654 B91300                  		mov	cx,SEARCH_ATTR ; 13h 	; filetypes to search for
 11867 00002657 B8004E                  		mov	ax,FIND_FIRST*256 ; 4E00h ; request first match, if any
 11868 0000265A CD21                    		int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
 11869                                  				; CX = search attributes
 11870                                  				; DS:DX	-> ASCIZ filespec
 11871                                  				; (drive,path,	and wildcards allowed)
 11872 0000265C 723C                    		jc	short SEARCH_NO_FILE
 11873 0000265E C606[B54A]00            		mov	byte [SEARCH_BEST],SEARCH_FILE_NOT_FOUND ; 0
 11874 00002663 C606[B64A]00            		mov	byte [SEARCH_BEST_BUF],ANULL ; 0 ; nothing's been found, yet
 11875                                  SEARCH_LOOP:
 11876 00002668 E83800                  		call	SEARCH_FTYPE	; determine if .com, &c...
 11877 0000266B 3A06[B54A]              		cmp	al,[SEARCH_BEST] ; better than what we've found so far?
 11878 0000266F 7E13                    		jle	short SEARCH_NEXT ; no, look for another	
 11879 00002671 A2[B54A]                		mov	[SEARCH_BEST],al ; found something... save its code	
 11880                                  		;mov	si,offset TRANGROUP:fbuf.find_buf_pname
 11881                                  		;mov	si,FBUF_PNAME
 11882 00002674 BE[A14A]                		mov	si,FBUF+FIND_BUF.PNAME
 11883 00002677 BF[B64A]                		mov	di,SEARCH_BEST_BUF
 11884 0000267A B90D00                  		mov	cx,FNAME_MAX_LEN ; 13
 11885 0000267D FC                      		cld
 11886 0000267E F3A4                    		rep movsb		; save complete pathname representation
 11887 00002680 3C08                    		cmp	al,SEARCH_COM ; 8 ; have we found the best of all?	
 11888 00002682 740A                    		je	short SEARCH_DONE
 11889                                  SEARCH_NEXT:				; keep on looking
 11890 00002684 B91300                  		mov	cx,SEARCH_ATTR ; 13h
 11891 00002687 B8004F                  		mov	ax,FIND_NEXT*256 ; 4F00h ; next match
 11892 0000268A CD21                    		int	21h	; DOS -	2+ - FIND NEXT ASCIZ (FINDNEXT)
 11893                                  				; [DTA]	= data block from
 11894                                  				; last AH = 4Eh/4Fh call
 11895 0000268C 73DA                    		jnc	short SEARCH_LOOP
 11896                                  SEARCH_DONE:				; it's all over with...
 11897 0000268E A0[B54A]                		mov	al,[SEARCH_BEST] ; pick best to return with
 11898                                  		; MSDOS 6.0
 11899                                  		;cmp	ext_entered,1	;AN005; Did user request a specific ext?
 11900                                  		;jz	search_exit	;AN005; no - exit
 11901                                  		;mov	al,ext_entered	;AN005; yes - get the real file type back
 11902                                  		;mov	search_best,al	;AN005; save the real file type
 11903                                  		;
 11904 00002691 EB0A                    		jmp	short SEARCH_EXIT
 11905                                  
 11906                                  SEARCH_INVALID_DRIVE:			 ; Tell the user path/drive
 11907 00002693 8B16[034B]              		mov	dx,[SEARCH_ERROR] ; appropriate error message
 11908 00002697 E88E0D                  		call	STD_PRINTF	 ; and pretend no file found
 11909                                  
 11910                                  SEARCH_NO_FILE:				; couldn't find a match
 11911 0000269A B80000                  		mov	ax,SEARCH_FILE_NOT_FOUND ; 0
 11912                                  SEARCH_EXIT:
 11913 0000269D 9D                      		popf
 11914 0000269E 5E                      		pop	si
 11915 0000269F 5F                      		pop	di
 11916 000026A0 5A                      		pop	dx
 11917 000026A1 59                      		pop	cx
 11918 000026A2 C3                      		retn
 11919                                  
 11920                                  ; =============== S U B	R O U T	I N E =======================================
 11921                                  
 11922                                  ; SEARCH_FTYPE determines the type of a file by examining its extension.
 11923                                  ;
 11924                                  ; ENTRY:
 11925                                  ;   fbuf    --	    dma buffer containing filename
 11926                                  ; EXIT:
 11927                                  ;   AX	    --	    file code, as given in search header
 11928                                  ; NOTE(S):
 11929                                  ;   *	Implicit assumption that NULL == search_file_not_found
 11930                                  
 11931                                  SEARCH_FTYPE:
 11932 000026A3 57                      		push	di
 11933 000026A4 56                      		push	si
 11934 000026A5 B80000                  		mov	ax,ANULL ; 0	; find the end of the filename
 11935                                  		;mov	di,offset TRANGROUP:fbuf.find_buf_pname
 11936                                  		;mov	di,FBUF_PNAME
 11937 000026A8 BF[A14A]                		mov	di,FBUF+FIND_BUF.PNAME
 11938 000026AB B90D00                  		mov	cx,FNAME_MAX_LEN ; 13
 11939 000026AE FC                      		cld
 11940 000026AF F2AE                    		repnz scasb		; search for the terminating null
 11941 000026B1 7536                    		jnz	short FTYPE_EXIT ; weird... no null byte at end
 11942 000026B3 83EF05                  		sub	di,5		; . + E + X + T + NULL
 11943                                  
 11944                                  		; Compare .COM
 11945                                  
 11946 000026B6 BE[223E]                		mov	si,COMEXT ; ".COM"
 11947 000026B9 89F8                    		mov	ax,di
 11948 000026BB A7                      		cmpsw
 11949 000026BC 7508                    		jnz	short FTYPE_EXE
 11950 000026BE A7                      		cmpsw
 11951 000026BF 7505                    		jnz	short FTYPE_EXE
 11952                                  		;mov	ax,8
 11953 000026C1 B80800                  		mov	ax,SEARCH_COM	; success!
 11954 000026C4 EB23                    		jmp	short FTYPE_EXIT
 11955                                  
 11956                                  		; Compare .EXE
 11957                                  FTYPE_EXE:				; still looking... now for '.exe'
 11958 000026C6 89C7                    		mov	di,ax
 11959 000026C8 BE[263E]                		mov	si,EXEEXT ; ".EXE"
 11960 000026CB A7                      		cmpsw
 11961 000026CC 7508                    		jnz	short FTYPE_BAT
 11962 000026CE A7                      		cmpsw
 11963 000026CF 7505                    		jnz	short FTYPE_BAT
 11964                                  		;mov	ax,4
 11965 000026D1 B80400                  		mov	ax,SEARCH_EXE	; success!
 11966 000026D4 EB13                    		jmp	short FTYPE_EXIT
 11967                                  
 11968                                  		; Compare .BAT
 11969                                  FTYPE_BAT:				; still looking... now for '.bat'
 11970 000026D6 89C7                    		mov	di,ax
 11971 000026D8 BE[2A3E]                		mov	si,BATEXT ; ".BAT"
 11972 000026DB A7                      		cmpsw
 11973 000026DC 7508                    		jnz	short FTYPE_FAIL
 11974 000026DE A7                      		cmpsw
 11975 000026DF 7505                    		jnz	short FTYPE_FAIL
 11976                                  		;mov	ax,2
 11977 000026E1 B80200                  		mov	ax,SEARCH_BAT	; success!
 11978 000026E4 EB03                    		jmp	short FTYPE_EXIT
 11979                                  
 11980                                  FTYPE_FAIL:				; file doesn't match what we need
 11981 000026E6 B80000                  		mov	ax,ANULL ; 0
 11982                                  FTYPE_EXIT:
 11983                                  		; MSDOS 6.0
 11984                                  		;cmp	ext_entered,1	;AN005; was an extension entered?
 11985                                  		;jz	ftype_done	;AN005; no - exit
 11986                                  		;cmp	ax,ANULL	;AN005; was any match found
 11987                                  		;jz	ftype_done	;AN005; no - exit
 11988                                  		;mov	ext_entered,al	;AN005; save the match type found
 11989                                  		;mov	AX,search_com	;AN005; send back best was found to stop search
 11990                                  ;ftype_done:
 11991 000026E9 5E                      		pop	si
 11992 000026EA 5F                      		pop	di
 11993 000026EB C3                      		retn
 11994                                  
 11995                                  ; =============== S U B	R O U T	I N E =======================================
 11996                                  
 11997                                  ; STRIP copies the source string (argv[0]) into the destination buffer,
 11998                                  ; replacing any extension with wildcards.
 11999                                  ;
 12000                                  ; ENTRY:
 12001                                  ;	BX		--		maximum length of destination buffer
 12002                                  ;	DS:SI		--		address of destination buffer
 12003                                  ;	argv[0] 	--		command name to be stripped
 12004                                  ; EXIT:
 12005                                  ;	CF		--		set if failure, clear if successful
 12006                                  ; NOTE(S):
 12007                                  
 12008                                  
 12009                                  STRIP:
 12010 000026EC 50                      		push	ax
 12011 000026ED 53                      		push	bx
 12012 000026EE 51                      		push	cx
 12013 000026EF 52                      		push	dx
 12014 000026F0 57                      		push	di
 12015 000026F1 56                      		push	si
 12016 000026F2 9C                      		pushf
 12017                                  		
 12018                                  		; MSDOS 6.0
 12019                                  		;mov	ext_entered,1	;AN005; assume no extension on file name
 12020                                  
 12021                                  		; MSDOS 3.3 (& MSDOS 6.0)
 12022                                  		;mov	dx,[ARG_ARGV]
 12023                                  		;mov	dx,ds:arg.argv[0].argpointer
 12024                                  					; save pointer to beginning of argstring
 12025                                  		;mov	dx,[ARGV0_ARGPOINTER]
 12026 000026F3 8B16[B944]              		mov	dx,[ARG+ARGV_ELE.argpointer]
 12027                                  		;mov	di,ds:arg.argv[0].argstartel
 12028                                  					; beginning of last pathname element
 12029                                  		;mov	di,[ARGV0_ARGSTARTEL] ; beginning of last pathname element
 12030 000026F7 8B3E[BC44]              		mov	di,[ARG+ARGV_ELE.argstartel]
 12031 000026FB 803D00                  		cmp	byte [di],0	; *STARTEL == NULL means no command
 12032 000026FE 742E                    		je	short STRIP_ERROR
 12033 00002700 89D1                    		mov	cx,dx		; compute where end of argstring lies
 12034                                  		;add	cx,ds:arg.argv[0].arglen
 12035                                  		;add	cx,[ARGV0_ARGLEN]
 12036 00002702 030E[BE44]              		add	cx,[ARG+ARGV_ELE.arglen]
 12037 00002706 29F9                    		sub	cx,di		; and then find length of last element
 12038 00002708 41                      		inc	cx		; include null as well
 12039                                  		;mov	al,'.'
 12040 00002709 B02E                    		mov	al,DOT		; let's find the filetype extension
 12041 0000270B FC                      		cld
 12042 0000270C F2AE                    		repnz scasb		; wind up pointing to either null or dot
 12043                                  
 12044                                  		; MSDOS 6.0
 12045                                  		;jcxz	process_ext	;AN005; if no extension found, just continue
 12046                                  		;mov	ext_entered,0	;AN005; we found an extension
 12047                                  		;mov	al,ANULL	;AN005; continue scanning until the
 12048                                  		;repnz	scasb		;AN005;    end of line is reached.
 12049                                  PROCESS_EXT:
 12050                                  		; MSDOS 3.3 (& MSDOS 6.0)
 12051 0000270E 89F9                    		mov	cx,di		; pointer to end of argstring yields
 12052 00002710 29D1                    		sub	cx,dx		; number of bytes to be copied
 12053 00002712 83EB04                  		sub	bx,4		; can argstring fit into dest. buffer?
 12054 00002715 39D9                    		cmp	cx,bx
 12055 00002717 7F15                    		jg	short STRIP_ERROR ; if not, we must have a bad pathname
 12056 00002719 89F7                    		mov	di,si		; destination buffer
 12057 0000271B 89D6                    		mov	si,dx		; source is beginning of pathname
 12058 0000271D FC                      		cld
 12059 0000271E F3A4                    		rep movsb		; SI=arg,DI=buffer,CX=argend-argbeg
 12060                                  
 12061                                  		; MSDOS 6.0
 12062                                  		;cmp	ext_entered,1	;AN005; if an extension was entered
 12063                                  		;jne	skip_wilds	;AN005;    don't set up wildcard ext.
 12064                                  
 12065                                  		; MSDOS 3.3 (& MSDOS 6.0)
 12066 00002720 4F                      		dec	di		; overwrite null or dot
 12067 00002721 AA                      		stosb			; with a dot
 12068                                  		;mov	al,'?'
 12069 00002722 B03F                    		mov	al,WILDCHAR	; now add wildcards
 12070 00002724 AA                      		stosb
 12071 00002725 AA                      		stosb
 12072 00002726 AA                      		stosb
 12073                                  		;mov	al,0
 12074 00002727 B000                    		mov	al,ANULL	; and a terminating null	
 12075 00002729 AA                      		stosb
 12076                                  SKIP_WILDS:
 12077 0000272A 9D                      		popf
 12078 0000272B F8                      		clc
 12079 0000272C EB02                    		jmp	short STRIP_EXIT ; chill out...
 12080                                  STRIP_ERROR:
 12081 0000272E 9D                      		popf
 12082 0000272F F9                      		stc
 12083                                  STRIP_EXIT:
 12084 00002730 5E                      		pop	si
 12085 00002731 5F                      		pop	di
 12086 00002732 5A                      		pop	dx
 12087 00002733 59                      		pop	cx
 12088 00002734 5B                      		pop	bx
 12089 00002735 58                      		pop	ax
 12090 00002736 C3                      		retn
 12091                                  
 12092                                  ; =============== S U B	R O U T	I N E =======================================
 12093                                  
 12094                                  ; SAVE_ARGS attempts to preserve the existing argv[]/argvcnt/argbuffer
 12095                                  ;
 12096                                  ; structure in newly allocated memory. The argv[] structure is found at the
 12097                                  ; beginning of this area. The caller indicates how much extra space is
 12098                                  ; needed in the resulting structure; Save_Args returns a segment number and
 12099                                  ; an offset into that area, indicating where the caller may preserve its own
 12100                                  ; data. Note that <argvcnt> can be found at <offset-2>.
 12101                                  ; ENTRY:
 12102                                  ;   BX	    --	    size (in bytes) of extra area to allocate
 12103                                  ; EXIT:
 12104                                  ;   AX	    --	    segment of new area.
 12105                                  ;   CF	    --	    set if unable to save a copy.
 12106                                  ; NOTE(S):
 12107                                  ;   1)	The allocated area will be AT LEAST the size requested -- since
 12108                                  ;	the underlying MSDOS call, <alloc> returns an integral number of
 12109                                  ;	paragraphs.
 12110                                  ;   2)	It is an error if MSDOS can't allocate AT LEAST as much memory
 12111                                  ;	as the caller of Save_Args requests.
 12112                                  ;   3)	AX is undefined if CF indicates an error.
 12113                                  
 12114                                  SAVE_ARGS:
 12115 00002737 53                      		push	bx
 12116 00002738 51                      		push	cx
 12117 00002739 52                      		push	dx
 12118 0000273A 57                      		push	di
 12119 0000273B 56                      		push	si
 12120 0000273C 55                      		push	bp
 12121 0000273D 9C                      		pushf
 12122                                  		;add	bx,1363		; space for arg structure, round up
 12123 0000273E 81C35305                		add	bx,ARG_UNIT.SIZE+15 ; 1348+15
 12124 00002742 B104                    		mov	cl,4		; to paragraph size and convert
 12125 00002744 D3EB                    		shr	bx,cl		; size in bytes to size in paragraphs
 12126 00002746 B80048                  		mov	ax,ALLOC*256 ; 4800h
 12127 00002749 CD21                    		int	21h	; DOS -	2+ - ALLOCATE MEMORY
 12128                                  				; BX = number of 16-byte paragraphs desired
 12129 0000274B 7244                    		jc	short SAVE_ERROR
 12130 0000274D 89C5                    		mov	bp,ax		; save segment id
 12131 0000274F 06                      		push	es		; save TRANGROUP address
 12132 00002750 8EC0                    		mov	es,ax		; switch to new memory segment
 12133                                  		; assume es:nothing
 12134                                  		;mov	cx,1348		; get back structure size
 12135 00002752 B94405                  		mov	cx,ARG_UNIT.SIZE
 12136 00002755 31FF                    		xor	di,di		; destination is new memory area
 12137                                  		;mov	si,ARG_ARGV
 12138 00002757 BE[B944]                		mov	si,ARG		; source is arg structure
 12139 0000275A F3A4                    		rep movsb		; move that sucker!
 12140                                  		;mov	cx,arg.argvcnt 	; adjust argv pointers
 12141                                  		;mov	cx,[ARG_ARGVCNT]
 12142 0000275C 8B0E[7947]              		mov	cx,[ARG+ARG_UNIT.argvcnt]
 12143 00002760 31C0                    		xor	ax,ax		; base address for argv_calc
 12144                                  
 12145                                  	;	Bugbug:	What did they mean by this?
 12146                                  	;	Note that the replacement line produces exactly the same code.
 12147                                  	;;	mov	SI, OFFSET TRANGROUP:arg.argbuf - OFFSET arg_unit.argbuf
 12148                                  	;	mov	SI, OFFSET TRANGROUP:arg
 12149                                  
 12150                                  		;mov	si,ARG_ARGV
 12151 00002762 BE[B944]                		mov	si,ARG	
 12152                                  SAVE_PTR_LOOP:
 12153 00002765 49                      		dec	cx		; exhausted all args?
 12154 00002766 7C24                    		jl	short SAVE_DONE
 12155 00002768 89CB                    		mov	bx,cx		; get arg index and
 12156 0000276A E8E9FC                  		call	ARGV_CALC	; convert to a pointer
 12157                                  		;mov	dx,ds:arg.argv[bx].argpointer
 12158                                  		;mov	dx,[ARG_ARGV+bx]
 12159 0000276D 8B97[B944]              		mov	dx,[ARG+ARGV_ELE.argpointer+bx]
 12160 00002771 29F2                    		sub	dx,si		; adjust argpointer
 12161                                  		;mov	es:argv[BX].argpointer,dx
 12162                                  		;mov	[es:bx+ARGV_ELE.argpointer],dx ; mov [es:bx+0],dx
 12163 00002773 268917                  		mov	[es:bx],dx
 12164                                  		;mov	dx,ds:arg.argv[bx].argstartel
 12165                                  		;mov	dx,[ARGV0_ARGSTARTEL+bx]
 12166 00002776 8B97[BC44]              		mov	dx,[ARG+ARGV_ELE.argstartel+bx]
 12167 0000277A 29F2                    		sub	dx,si		; and adjust argstartel
 12168                                  		;mov	es:argv[bx].argstartel,dx
 12169                                  		;mov	[es:bx+3],dx
 12170 0000277C 26895703                		mov	[es:bx+ARGV_ELE.argstartel],dx
 12171                                  		;mov	dx,ds:arg.argv[bx].arg_ocomptr
 12172                                  		;mov	dx,[ARGV0_OCOMPTR+bx]
 12173 00002780 8B97[C244]              		mov	dx,[ARG+ARGV_ELE.arg_ocomptr+bx]
 12174 00002784 29F2                    		sub	dx,si		; and adjust arg_ocomptr
 12175                                  		;mov	es:argv[bx].arg_ocomptr,dx
 12176                                  		;mov	[es:bx+9],dx
 12177 00002786 26895709                		mov	[es:bx+ARGV_ELE.arg_ocomptr],dx
 12178 0000278A EBD9                    		jmp	short SAVE_PTR_LOOP
 12179                                  SAVE_DONE:
 12180 0000278C 07                      		pop	es		; back we go to TRANGROUP
 12181                                  		; assume es:nothing
 12182 0000278D 89E8                    		mov	ax,bp		; restore segment id
 12183 0000278F EB04                    		jmp	short SAVE_OK
 12184                                  SAVE_ERROR:
 12185 00002791 9D                      		popf
 12186 00002792 F9                      		stc
 12187 00002793 EB02                    		jmp	short SAVE_EXIT
 12188                                  SAVE_OK:
 12189 00002795 9D                      		popf
 12190 00002796 F8                      		clc
 12191                                  SAVE_EXIT:
 12192 00002797 5D                      		pop	bp
 12193 00002798 5E                      		pop	si
 12194 00002799 5F                      		pop	di
 12195 0000279A 5A                      		pop	dx
 12196 0000279B 59                      		pop	cx
 12197 0000279C 5B                      		pop	bx
 12198                                  NOTEST2_RETN:	; 02/03/2023
 12199 0000279D C3                      		retn
 12200                                  
 12201                                  ;============================================================================
 12202                                  ; TUCODE.ASM, MSDOS 6.0, 1991 (1)
 12203                                  ;============================================================================
 12204                                  ; 02/10/2018 - Retro DOS v3.0
 12205                                  
 12206                                  ; Title	COMMAND Language midifiable Code Transient
 12207                                  
 12208                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2843h
 12209                                  
 12210                                  ; =============== S U B	R O U T	I N E =======================================
 12211                                  
 12212                                  ; ****************************************************************
 12213                                  ; *
 12214                                  ; * ROUTINE:	 NOTEST2 - execution of DEL/ERASE command
 12215                                  ; *
 12216                                  ; * FUNCTION:	 Delete files based on user parsed input. Prompt
 12217                                  ; *		 user for Y/N if necessary. If an error occurs,
 12218                                  ; *		 set up an error message and go to CERROR.
 12219                                  ; *
 12220                                  ; * INPUT:	 FCB at 5ch set up with filename(s) entered
 12221                                  ; *		 Current directory set to entered directory
 12222                                  ; *
 12223                                  ; * OUTPUT:	 none
 12224                                  ; *
 12225                                  ; ****************************************************************
 12226                                  ;
 12227                                  ; ARE YOU SURE prompt when deleting *.*
 12228                                  
 12229                                  NOTEST2:
 12230 0000279E B90B00                  		mov	cx,11
 12231 000027A1 BE5D00                  		mov	si,FCB+1 ; 5Dh
 12232                                  AMBSPEC:
 12233 000027A4 AC                      		lodsb
 12234 000027A5 3C3F                    		cmp	al,'?'
 12235 000027A7 7502                    		jnz	short ALLFIL
 12236 000027A9 E2F9                    		loop	AMBSPEC
 12237                                  ALLFIL:
 12238 000027AB 83F900                  		cmp	cx,0
 12239 000027AE 7530                    		jnz	short NOPRMPT
 12240                                  ASKAGN:	
 12241 000027B0 BA[1C3A]                		mov	dx,SUREMESPTR	; "Are you sure (Y/N)?"
 12242 000027B3 E8720C                  		call	STD_PRINTF
 12243 000027B6 BE8000                  		mov	si,80h
 12244 000027B9 89F2                    		mov	dx,si
 12245 000027BB C7047800                		mov	word [si],120	; zero length
 12246                                  		;mov	ax,0C0Ah
 12247 000027BF B80A0C                  		mov	ax,(STD_CON_INPUT_FLUSH<<8)|STD_CON_STRING_INPUT
 12248 000027C2 CD21                    		int	21h	; DOS -	CLEAR KEYBOARD BUFFER
 12249                                  				; AL must be 01h,06h,07h,08h or 0Ah.
 12250 000027C4 AD                      		lodsw
 12251 000027C5 08E4                    		or	ah,ah
 12252 000027C7 74E7                    		jz	short ASKAGN
 12253 000027C9 E87AF1                  		call	SCANOFF
 12254                                  		; MSDOS 6.0
 12255                                  		;call	char_in_xlat	; Convert to upper case
 12256                                  		;retc			; return if function not supported
 12257                                  		; MSDOS 3.3
 12258 000027CC E87A01                  		call	UPCONV
 12259                                  		
 12260                                  		;; MSDOS 3.3 (& MSDOS 6.0)
 12261 000027CF 3A06[C93C]              		cmp	al,[CAPITAL_N]
 12262                                  		;jne	short CHECK_Y
 12263                                  		;retn
 12264                                  		; 02/03/2023
 12265 000027D3 74C8                    		je	short NOTEST2_RETN
 12266                                  CHECK_Y:
 12267 000027D5 3A06[C83C]              		cmp	al,[CAPITAL_Y]
 12268 000027D9 9C                      		pushf
 12269 000027DA E85CF1                  		call	CRLF2
 12270 000027DD 9D                      		popf
 12271 000027DE 75D0                    		jne	short ASKAGN
 12272                                  NOPRMPT:
 12273 000027E0 B413                    		mov	ah,FCB_DELETE ; 13h
 12274 000027E2 BA5C00                  		mov	dx,FCB ; 5Ch
 12275 000027E5 CD21                    		int	21h	; DOS -	DELETE FILE via	FCB
 12276                                  				; DS:DX	-> FCB with filename field filled with
 12277                                  				; template for	deletion ('?' wildcard allowed,but not '*')
 12278                                  				; Return: AL = 00h file	found,FFh file	not found
 12279 000027E7 FEC0                    		inc	al
 12280 000027E9 7403                    		jz	short ERAERR
 12281                                  		;call	RESTUDIR
 12282                                  		;retn
 12283                                  		; 02/03/2023
 12284 000027EB E97FF0                  		jmp	RESTUDIR
 12285                                  
 12286                                  		; MSDOS 6.0
 12287                                  ;eraerr:
 12288                                  		;invoke	set_ext_error_msg	;AN022; set up the extended error
 12289                                  		;push	dx			;AN022; save message
 12290                                  		;invoke	RESTUDIR
 12291                                  		;pop	dx			;AN022; restore message
 12292                                  		;
 12293                                  		;cmp	word ptr extend_buf_ptr,error_no_more_files 
 12294                                  		;				;AN022; convert no more files to
 12295                                  		;jnz	cerrorj2		;AN022; 	file not found
 12296                                  		;mov	Extend_Buf_ptr,error_file_not_found  
 12297                                  		;			;AN000; get message number in control block
 12298                                  ;cerrorj2:
 12299                                  		;jmp	cerror
 12300                                  	
 12301                                  		; MSDOS 3.3
 12302                                  ERAERR:	
 12303 000027EE B41A                    		mov	ah,SET_DMA ; 1Ah
 12304 000027F0 BA5C00                  		mov	dx,FCB ; 5Ch
 12305 000027F3 CD21                    		int	21h		; DOS -	SET DISK TRANSFER AREA ADDRESS
 12306                                  					; DS:DX	-> disk	transfer buffer
 12307 000027F5 B411                    		mov	ah,DIR_SEARCH_FIRST ; 11h
 12308 000027F7 CD21                    		int	21h		; DOS -	SEARCH FIRST USING FCB
 12309                                  					; DS:DX	-> FCB
 12310 000027F9 50                      		push	ax
 12311 000027FA E870F0                  		call	RESTUDIR
 12312 000027FD 58                      		pop	ax
 12313 000027FE BA[2837]                		mov	dx,FNOTFOUNDPTR
 12314 00002801 FEC0                    		inc	al
 12315 00002803 743D                    		jz	short CERRORJ
 12316 00002805 BA[4D37]                		mov	dx,ACCDENPTR
 12317 00002808 E9DFF3                  		jmp	CERROR
 12318                                  
 12319                                  ; =============== S U B	R O U T	I N E =======================================
 12320                                  
 12321                                  ; ECHO, BREAK, and VERIFY commands. Check for "ON" and "OFF"
 12322                                  
 12323                                  ECHO:
 12324 0000280B E89400                  		call	ON_OFF
 12325 0000280E 7212                    		jb	short DOEMES
 12326 00002810 8E1E[8141]              		mov	ds,[RESSEG]
 12327 00002814 7506                    		jnz	short ECH_OFF
 12328 00002816 800EE90B01              		or	byte [ECHOFLAG],1
 12329                                  ;NOTEST2_RETN:	; 02/03/2023
 12330 0000281B C3                      		retn
 12331                                  ECH_OFF:
 12332 0000281C 8026E90BFE              		and	byte [ECHOFLAG],0FEh
 12333 00002821 C3                      		retn
 12334                                  
 12335                                  ; There was no discrenable ON or OFF after the ECHO. If there is nothing but
 12336                                  ; delimiters on the command line, we issue the ECHO is ON/OFF message.
 12337                                  
 12338                                  DOEMES:
 12339                                  		; MSDOS 6.0
 12340                                  		;cmp	cl,0		;AC000; was anything on the line?
 12341                                  		;jz	PECHO		; just display current state.
 12342                                  		;MOV	DX,82H		; Skip one char after "ECHO"
 12343                                  		;invoke	CRPRINT
 12344                                  		;JMP	CRLF2
 12345                                  
 12346                                  		; MSDOS 3.3
 12347 00002822 E82000                  		call	MOVE_TO_FIRST_ARG
 12348 00002825 7409                    		jz	short PECHO
 12349 00002827 BA8200                  		mov	dx,82h
 12350 0000282A E869F1                  		call	CRPRINT
 12351 0000282D E909F1                  		jmp	CRLF2
 12352                                  
 12353                                  PECHO:
 12354                                  		; MSDOS 3.3 (& MSDOS 6.0)
 12355 00002830 8E1E[8141]              		mov	ds,[RESSEG]
 12356 00002834 8A1EE90B                		mov	bl,[ECHOFLAG]
 12357 00002838 0E                      		push	cs
 12358 00002839 1F                      		pop	ds
 12359 0000283A 80E301                  		and	bl,1
 12360 0000283D BA[4F3C]                		mov	dx,ECHOMESPTR
 12361 00002840 EB2E                    		jmp	short PYN
 12362                                  
 12363                                  ; ---------------------------------------------------------------------------
 12364                                  
 12365                                  		; MSDOS 3.3
 12366                                  CERRORJ:
 12367 00002842 E9A5F3                  		jmp	CERROR
 12368                                  
 12369                                  
 12370                                  ; =============== S U B	R O U T	I N E =======================================
 12371                                  
 12372                                  MOVE_TO_FIRST_ARG:
 12373 00002845 BE8100                  		mov	si,81h
 12374 00002848 E8FBF0                  		call	SCANOFF
 12375 0000284B 3C0D                    		cmp	al,0Dh
 12376 0000284D C3                      		retn
 12377                                  
 12378                                  ; =============== S U B	R O U T	I N E =======================================
 12379                                  
 12380                                  CNTRLC:
 12381 0000284E E85100                  		call	ON_OFF
 12382 00002851 B80133                  		mov	ax,(SET_CTRL_C_TRAPPING<<8)|1 ;3301h
 12383 00002854 720C                    		jc	short PCNTRLC
 12384 00002856 7505                    		jnz	short CNTRLC_OFF
 12385 00002858 B201                    		mov	dl,1
 12386 0000285A CD21                    		int	21h	; DOS -	EXTENDED CONTROL-BREAK CHECKING
 12387                                  				; AL = 00h get state / 01h set state / 02h set AND get
 12388                                  				; DL = 00h for OFF or 01h for ON
 12389 0000285C C3                      		retn
 12390                                  
 12391                                  ; ---------------------------------------------------------------------------
 12392                                  
 12393                                  CNTRLC_OFF:
 12394 0000285D 30D2                    		xor	dl,dl
 12395 0000285F CD21                    		int	21h		; Turn off ^C check
 12396 00002861 C3                      		retn
 12397                                  
 12398                                  ; ---------------------------------------------------------------------------
 12399                                  
 12400                                  PCNTRLC:
 12401                                  		; MSDOS 6.0
 12402                                  		;CMP	CL,0		;AC000; rest of line blank?
 12403                                  		;JNZ	CERRORJ 	; no, oops!
 12404                                  
 12405                                  		; MSDOS 3.3
 12406 00002862 E8E0FF                  		call	MOVE_TO_FIRST_ARG
 12407 00002865 75DB                    		jnz	short CERRORJ
 12408                                  ;pccont:
 12409                                  		; MSDOS 3.3 (& MSDOS 6.0)
 12410 00002867 30C0                    		xor	al,al
 12411 00002869 CD21                    		int	21h		; get Ctrl-Break state (ah=33h)
 12412 0000286B 88D3                    		mov	bl,dl
 12413 0000286D BA[373C]                		mov	dx,CTRLMESPTR
 12414                                  
 12415                                  ; ---------------------------------------------------------------------------
 12416                                  
 12417                                  PYN:		; write "ON" or "OFF" state 
 12418                                  
 12419 00002870 E8B50B                  		call	STD_PRINTF
 12420 00002873 BA[5E3C]                		mov	dx,ONMESPTR	;AC000; get ON pointer
 12421 00002876 08DB                    		or	bl,bl
 12422 00002878 7503                    		jnz	short PRINTVAL
 12423 0000287A BA[573C]                		mov	dx,OFFMESPTR	;AC000; get OFF pointer
 12424                                  
 12425                                  PRINTVAL:
 12426                                  		; MSDOS 3.3
 12427 0000287D E9A80B                  		jmp	STD_PRINTF
 12428                                  
 12429                                  		; MSDOS 6.0
 12430                                  		;push	dx		;AN000; save offset of message block
 12431                                  		;mov	bx,dx		;AN000; save offset value
 12432                                  		;lodsw			;AN000; get message number of on or off
 12433                                  		;mov	dh,util_msg_class ;AN000; this is a utility message
 12434                                  		;invoke	Tsysgetmsg	;AN000; get the address of the message
 12435                                  		;add	bx,ptr_off_pos	;AN000; point to offset of ON/OFF
 12436                                  		;mov	word ptr [bx],si ;AN000; put the offset in the message block
 12437                                  		;pop	dx		;AN000; get message back
 12438                                  		;invoke	std_printf	;AC000; go print message
 12439                                  		;mov	word ptr [bx],0 ;AN000; zero out message pointer
 12440                                  		;
 12441                                  		;ret			;AN000; exit
 12442                                  
 12443                                  ; =============== S U B	R O U T	I N E =======================================
 12444                                  
 12445                                  VERIFY:
 12446 00002880 E81F00                  		call	ON_OFF
 12447 00002883 B8012E                  		mov	ax,(SET_VERIFY_ON_WRITE<<8)|1 ; 2E01h
 12448 00002886 720A                    		jc	short PVERIFY
 12449 00002888 7503                    		jnz	short VER_OFF
 12450 0000288A CD21                    		int	21h	; DOS -	SET VERIFY FLAG
 12451                                  				; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
 12452 0000288C C3                      		retn
 12453                                  
 12454                                  ; ---------------------------------------------------------------------------
 12455                                  
 12456                                  VER_OFF:
 12457 0000288D FEC8                    		dec	al
 12458 0000288F CD21                    		int	21h		; Turn off verify after write
 12459 00002891 C3                      		retn
 12460                                  
 12461                                  ; ---------------------------------------------------------------------------
 12462                                  
 12463                                  PVERIFY:
 12464                                  		; MSDOS 6.0
 12465                                  		;CMP	CL,0		;AC000; is rest of line blank?
 12466                                  		;JNZ	CERRORJ 	; nope...
 12467                                  
 12468                                  		; MSDOS 3.3
 12469 00002892 E8B0FF                  		call	MOVE_TO_FIRST_ARG
 12470 00002895 75AB                    		jnz	short CERRORJ
 12471                                  
 12472 00002897 B454                    		mov	ah,GET_VERIFY_ON_WRITE ; 54h
 12473 00002899 CD21                    		int	21h		; DOS -	2+ - GET VERIFY	FLAG
 12474                                  					; Return: AL = 00h if flag OFF
 12475                                  					; AL = 01h if flag ON
 12476 0000289B 88C3                    		mov	bl,al
 12477 0000289D BA[443C]                		mov	dx,VERIMESPTR
 12478 000028A0 EBCE                    		jmp	short PYN
 12479                                  
 12480                                  ; =============== S U B	R O U T	I N E =======================================
 12481                                  
 12482                                  ; ****************************************************************
 12483                                  ; *
 12484                                  ; * ROUTINE:	 ON_OFF
 12485                                  ; *
 12486                                  ; * FUNCTION:	 Parse the command line for an optional ON or
 12487                                  ; *		 OFF string for the BREAK, VERIFY, and ECHO
 12488                                  ; *		 routines.
 12489                                  ; *
 12490                                  ; * INPUT:	 command line at offset 81H
 12491                                  ; *		 PARSE_BREAK control block
 12492                                  ; *
 12493                                  ; * OUTPUT:	 If carry is clear
 12494                                  ; *		    If ON is found
 12495                                  ; *		       Zero flag set
 12496                                  ; *		    If OFF is found
 12497                                  ; *		       Zero flag clear
 12498                                  ; *		 If carry set
 12499                                  ; *		    If nothing on command line
 12500                                  ; *		       CL set to zero
 12501                                  ; *		    If error
 12502                                  ; *		       CL contains error value from parse
 12503                                  ; *
 12504                                  ; ****************************************************************
 12505                                  
 12506                                  ON_OFF:
 12507 000028A2 BE8100                  		mov	si,81h
 12508                                  
 12509                                  		; MSDOS 3.3
 12510 000028A5 E89EF0                  		call	SCANOFF		; scan off leading blanks & equal
 12511 000028A8 3C0D                    		cmp	al,0Dh		; are we at end of line?
 12512 000028AA 742A                    		je	short BAD_ONF	; yes, return error
 12513 000028AC AD                      		lodsw
 12514 000028AD 0D2020                  		or	ax,2020h	; convert to lowercase
 12515 000028B0 3D6F6E                  		cmp	ax,6E6Fh ;'on'
 12516 000028B3 7410                    		je	short ON_CHECK
 12517 000028B5 3D6F66                  		cmp	ax,666Fh ;'of'
 12518 000028B8 751C                    		jne	short BAD_ONF
 12519 000028BA AC                      		lodsb
 12520 000028BB 0C20                    		or	al,20h		; convert to lowercase		
 12521 000028BD 3C66                    		cmp	al,66h	 ; 'f'
 12522 000028BF 7515                    		jne	short BAD_ONF	
 12523 000028C1 0C66                    		or	al,66h ; or al,'f'
 12524 000028C3 EB02                    		jmp	short OFF_CHECK
 12525                                  ON_CHECK:
 12526 000028C5 30C0                    		xor	al,al
 12527                                  OFF_CHECK:
 12528 000028C7 9F                      		lahf
 12529 000028C8 89C3                    		mov	bx,ax
 12530 000028CA E879F0                  		call	SCANOFF		; scan off leading blanks & equal
 12531 000028CD 3C0D                    		cmp	al,0Dh		; are we at end of line?	
 12532 000028CF 7505                    		jne	short BAD_ONF	; no, return error
 12533 000028D1 89D8                    		mov	ax,bx
 12534 000028D3 9E                      		sahf
 12535 000028D4 F8                      		clc
 12536 000028D5 C3                      		retn
 12537                                  
 12538                                  		; MSDOS 6.0
 12539                                  ;scan_on_off:				;AN032; scan off leading blanks & equal
 12540                                  ;		lodsb			;AN032; get a char
 12541                                  ;		cmp	al,blank	;AN032; if whitespace
 12542                                  ;		jz	scan_on_off	;AN032;    keep scanning
 12543                                  ;		cmp	al,tab_chr	;AN032; if tab
 12544                                  ;		jz	scan_on_off	;AN032;    keep scanning
 12545                                  ;		cmp	al,equal_chr	;AN032; if equal char
 12546                                  ;		jz	parse_on_off	;AN032;    start parsing
 12547                                  ;		dec	si		;AN032; if none of above - back up
 12548                                  ;
 12549                                  ;parse_on_off:				;AN032;    and start parsing
 12550                                  ;		mov	di,offset trangroup:parse_break ;AN000; Get address of PARSE_BREAK
 12551                                  ;		xor	cx,cx		;AN000; clear cx,dx
 12552                                  ;		xor	dx,dx		;AN000;
 12553                                  ;		invoke	cmd_parse	;AC000; call parser
 12554                                  ;		cmp	ax,end_of_line	;AC000; are we at end of line?
 12555                                  ;		jz	BADONF		;AC000; yes, return error
 12556                                  ;		cmp	ax,result_no_error ;AN000; did an error occur
 12557                                  ;		jz	on_off_there	;AN000; no - continue
 12558                                  ;		mov	cx,ax		;AN000; yes - set cl to error code
 12559                                  ;		jmp	short BADONF	;AN000; return error
 12560                                  ;
 12561                                  ;on_off_there:
 12562                                  ;		cmp	parse1_code,-1	;AN014; was a valid positional present?
 12563                                  ;		jnz	good_on_off	;AN014; yes - continue
 12564                                  ;		mov	cx,badparm_ptr	;AN014; something other than ON/OFF
 12565                                  ;		jmp	short BADONF	;AN014; return error
 12566                                  ;
 12567                                  ;good_on_off:				;AN014;
 12568                                  ;		xor	ax,ax		;AC000; set up return code for
 12569                                  ;		or	al,parse1_code	;AC000;    ON or OFF in AX
 12570                                  ;		pushf			;AN000; save flags
 12571                                  ;		mov	di,offset trangroup:parse_break
 12572                                  ;					;AN000; Get address of PARSE_BREAK
 12573                                  ;		xor	dx,dx		;AN000;
 12574                                  ;		invoke	cmd_parse	;AN000; call parser
 12575                                  ;		cmp	ax,end_of_line	;AN000; are we at end of line?
 12576                                  ;		jnz	BADONF_flags	;AN000; NO, return error
 12577                                  ;		popf			;AN000; restore flags
 12578                                  ;		clc			;AC000; no error
 12579                                  ;		jmp	short on_off_end ;AN000; return to caller
 12580                                  ;
 12581                                  ;BADONF_flags:
 12582                                  ;		mov	cx,ax
 12583                                  ;		popf
 12584                                  
 12585                                  ; ---------------------------------------------------------------------------
 12586                                  
 12587                                  ; No discernable ON or OFF has been found. Put an error message pointer in DX
 12588                                  ; and return the error
 12589                                  
 12590                                  BAD_ONF:
 12591 000028D6 BA[193B]                		mov	dx,BADONOFFPTR
 12592 000028D9 F9                      		stc
 12593                                  ;on_off_end:
 12594 000028DA C3                      		retn
 12595                                  
 12596                                  ;============================================================================
 12597                                  ; TCMD1B.ASM, MSDOS 6.0, 1991
 12598                                  ;============================================================================
 12599                                  ; 02/10/2018 - Retro DOS v3.0
 12600                                  
 12601                                  ; Print volume ID info
 12602                                  
 12603                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2982h
 12604                                  
 12605                                  ; ---------------------------------------------------------------------------
 12606                                  
 12607                                  PRINTVOL:
 12608 000028DB 50                      		push	ax		; AX return from SEARCH_FIRST for VOL ID
 12609 000028DC A05C00                  		mov	al,[FCB] ; 5Ch	; get drive letter
 12610 000028DF 0440                    		add	al,'@'
 12611 000028E1 3C40                    		cmp	al,'@'
 12612 000028E3 7505                    		jnz	short DRVOK
 12613 000028E5 A0[9541]                		mov	al,[CURDRV]
 12614                                  		;add	al,[CAPITAL_A]
 12615                                  		; 01/03/2023
 12616 000028E8 0441                    		add	al,capital_A  ; add al,'A'
 12617                                  DRVOK:
 12618 000028EA A2[7443]                		mov	[VOL_DRV],al	; get drive letter into argument
 12619 000028ED 58                      		pop	ax		; get return code back
 12620 000028EE BA[853A]                		mov	dx,NOVOL ; "has	no label" 
 12621 000028F1 08C0                    		or	al,al		; volume label found?
 12622 000028F3 7517                    		jnz	short PRINTVOL2	; print no volume message
 12623                                  GOODVOL:
 12624                                  		; MSDOS 3.3
 12625 000028F5 BF[AB41]                		mov	di,CHARBUF
 12626 000028F8 89FA                    		mov	dx,di
 12627 000028FA BE[813A]                		mov	si,IS	; "is "
 12628 000028FD E87FDF                  		call	STRCPY
 12629 00002900 4F                      		dec	di
 12630 00002901 BE[8242]                		mov	si,DIRBUF+8
 12631 00002904 B90B00                  		mov	cx,11
 12632 00002907 F3A4                    		rep movsb
 12633 00002909 31C0                    		xor	ax,ax
 12634                                  		;xor	al,al  ; MSDOS 6.0
 12635 0000290B AA                      		stosb			; store a zero to terminate the string
 12636                                  PRINTVOL2:
 12637 0000290C 8916[7243]              		mov	[VOLNAME_ADDR],dx
 12638 00002910 BA[7B3A]                		mov	dx,VOLMESPTR
 12639 00002913 E9030B                  		jmp	PRINTF_CRLF
 12640                                  
 12641                                  		; MSDOS 6.0
 12642                                  ;drvok:
 12643                                  ;		mov	vol_drv,al	;AC000; get drive letter into argument
 12644                                  ;		pop	ax		;AC000; get return code back
 12645                                  ;		or	al,al		;AC000; volume label found?
 12646                                  ;		jz	Get_vol_name	;AC000; volume label exists - go get it
 12647                                  ;		mov	dx,offset trangroup:VolMes_ptr_2 
 12648                                  ;					;AC000; set up no volume message
 12649                                  ;		jmp	short print_serial	;AC000; go print it
 12650                                  ;
 12651                                  ;Get_vol_name:
 12652                                  ;		mov	di,offset trangroup:charbuf
 12653                                  ;		mov	dx,di
 12654                                  ;		mov	si,offset trangroup:dirbuf + 8	;AN000;  3/3/KK
 12655                                  ;		mov	cx,11				;AN000;  3/3/KK
 12656                                  ;		rep	movsb				;AN000;  3/3/KK
 12657                                  ;
 12658                                  ;		xor	al,al		;AC000; store a zero to terminate the string
 12659                                  ;		stosb
 12660                                  ;		mov	dx,offset trangroup:VolMes_ptr	;AC000; set up message
 12661                                  ;
 12662                                  ;PRINT_SERIAL:
 12663                                  ;
 12664                                  ;; Attempt to get the volume serial number from the disk.  If an error
 12665                                  ;; occurs, do not print volume serial number.
 12666                                  ;
 12667                                  ;		push	dx		;AN000; save message offset
 12668                                  ;		mov	ax,(GetSetMediaID SHL 8) 
 12669                                  ;					;AC036; Get the volume serial info
 12670                                  ;		mov	bl,DS:[FCB]	;AN000; get drive number from FCB
 12671                                  ;		mov	dx,offset trangroup:vol_ioctl_buf ;AN000;target buffer
 12672                                  ;		int	21h		;AN000; do the call
 12673                                  ;		pop	dx		;AN000; get message offset back
 12674                                  ;		jc	printvol_end	;AN000; if error, just go print label
 12675                                  ;		call	std_printf	;AC000; go print volume message
 12676                                  ;		mov	al,blank	;AN051; Print out a blank
 12677                                  ;		invoke	print_char	;AN051;   before volume message
 12678                                  ;		mov	dx,offset trangroup:VolSerMes_ptr 
 12679                                  ;					;AN000; get serial number message
 12680                                  ;printvol_end:
 12681                                  ;		jmp	std_printf	;AC000; go print and exit
 12682                                  
 12683                                  ;============================================================================
 12684                                  ; TUCODE.ASM, MSDOS 6.0, 1991 (2)
 12685                                  ;============================================================================
 12686                                  ; 02/10/2018 - Retro DOS v3.0
 12687                                  
 12688                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 29BFh
 12689                                  
 12690                                  ; =============== S U B	R O U T	I N E =======================================
 12691                                  
 12692                                  PRINT_DATE:
 12693                                  		; MSDOS 3.3
 12694 00002916 06                      		push	es
 12695 00002917 57                      		push	di
 12696 00002918 0E                      		push	cs
 12697 00002919 07                      		pop	es
 12698 0000291A BF[D842]                		mov	di,ARG_BUF
 12699 0000291D B42A                    		mov	ah,GET_DATE ; 2Ah
 12700 0000291F CD21                    		int	21h	; DOS -	GET CURRENT DATE
 12701                                  				; Return: DL = day,DH = month,	CX = year
 12702                                  				; AL = day of the week (0=Sunday,1=Monday,etc.)
 12703 00002921 98                      		cbw
 12704 00002922 E80F00                  		call	GETDATE
 12705 00002925 E809F7                  		call	P_DATE
 12706 00002928 30C0                    		xor	al,al
 12707 0000292A AA                      		stosb
 12708 0000292B BA[5336]                		mov	dx,ARG_BUF_PTR
 12709 0000292E E8F70A                  		call	STD_PRINTF
 12710 00002931 07                      		pop	es
 12711 00002932 5F                      		pop	di
 12712 00002933 C3                      		retn
 12713                                  
 12714                                  		; MSDOS 6.0
 12715                                  		;PUSH	ES
 12716                                  		;PUSH	DI
 12717                                  		;PUSH	CS
 12718                                  		;POP	ES
 12719                                  		;CALL	GetDate 		; get date
 12720                                  		;xchg	dh,dl			;AN000; switch month & day
 12721                                  		;mov	promptDat_yr,cx 	;AC000; put year into message control block
 12722                                  		;mov	promptDat_moday,dx	;AC000; put month and day into message control block
 12723                                  		;mov	dx,offset trangroup:promptDat_ptr ;AC000; set up message for output
 12724                                  		;invoke	std_printf
 12725                                  	;;AD061; mov	promptDat_yr,0		;AC000; reset year, month and day
 12726                                  	;;AD061; mov	promptDat_moday,0	;AC000;     pointers in control block
 12727                                  		;POP	DI			;AC000; restore di,es
 12728                                  		;POP	ES			;AC000;
 12729                                  		;return
 12730                                  
 12731                                  ; ---------------------------------------------------------------------------
 12732                                  
 12733                                  GETDATE:
 12734                                  		; MSDOS 3.3
 12735 00002934 89C6                    		mov	si,ax
 12736 00002936 D1E6                    		shl	si,1
 12737 00002938 01C6                    		add	si,ax
 12738 0000293A 81C6[5439]              		add	si,WEEKTAB ; "SunMonTueWedThuFriSat"
 12739 0000293E 89CB                    		mov	bx,cx
 12740 00002940 B90300                  		mov	cx,3
 12741 00002943 F3A4                    		rep movsb
 12742 00002945 B020                    		mov	al,' '
 12743 00002947 AA                      		stosb
 12744 00002948 C3                      		retn
 12745                                  
 12746                                  		; MSDOS 6.0
 12747                                  
 12748                                  ; Do GET DATE system call and set up 3 character day of week in ARG_BUF
 12749                                  ; for output.  Date will be returned in CX,DX.
 12750                                  
 12751                                  ;GetDate:
 12752                                  		;mov	di,offset trangroup:arg_buf ;AC000; target for day of week
 12753                                  		;MOV	AH,GET_DATE		;AC000; get current date
 12754                                  		;INT	21h			;AC000; Get date in CX:DX
 12755                                  		;CBW				;AC000;
 12756                                  		;
 12757                                  		;push	cx			;AN000; save date returned in
 12758                                  		;push	dx			;AN000;      CX:DX
 12759                                  		;MOV	SI,AX
 12760                                  		;
 12761                                  		;SHL	SI,1
 12762                                  		;ADD	SI,AX			; SI=AX*3
 12763                                  		;
 12764                                  		;mov	cx,si			;AN000; save si
 12765                                  		;mov	ax,weektab		;AN000; get message number of weektab
 12766                                  		;mov	dh,util_msg_class	;AN000; this is a utility message
 12767                                  		;push	di			;AN000; save argument buffer
 12768                                  		;invoke	Tsysgetmsg		;AN000; get the address of the message
 12769                                  		;pop	di			;AN000; retrieve argument buffer
 12770                                  		;add	si,cx			;AC000; get day of week
 12771                                  		;
 12772                                  		;MOV	CX,3
 12773                                    		;REP	MOVSB
 12774                                  		;mov	al,end_of_line_out	;AC000; terminate the string
 12775                                  		;stosb
 12776                                  		;pop	dx			;AN000; get back date
 12777                                  		;pop	cx			;AN000;
 12778                                  		;
 12779                                  		;return
 12780                                  
 12781                                  ; =============== S U B	R O U T	I N E =======================================
 12782                                  
 12783                                  		; MSDOS 6.0
 12784                                  
 12785                                  ; This routine determines whether the character in AL is a
 12786                                  ; Yes or No character. On return, if AL=0, the character is
 12787                                  ; No, if AL=1, the character is Yes.
 12788                                  
 12789                                  ;		assume	ds:trangroup
 12790                                  
 12791                                  ;char_in_xlat	proc	near
 12792                                  ;
 12793                                  ;		mov	dl,al			;AC000; get character into DX
 12794                                  ;		xor	dh,dh			;AC000;
 12795                                  ;		mov	ax,(getextcntry SHL 8) + 35 ;AC000; Yes/No char call
 12796                                  ;		int	21h			;AC000;
 12797                                  ;
 12798                                  ;		ret
 12799                                  ;
 12800                                  ;char_in_xlat	endp
 12801                                  
 12802                                  ;============================================================================
 12803                                  ; TENV.ASM, MSDOS 6.0, 1991
 12804                                  ;============================================================================
 12805                                  ; 02/10/2018 - Retro DOS v3.0
 12806                                  
 12807                                  ;	Environment utilities and misc. routines
 12808                                  
 12809                                  ; MSDOS 6.0
 12810                                  ; ****************************************************************
 12811                                  ; *
 12812                                  ; * ROUTINE:	 UPCONV     (ADDED BY EMG 4.00)
 12813                                  ; *
 12814                                  ; * FUNCTION:	 This routine returns the upper case equivalent of
 12815                                  ; *		 the character in AL from the file upper case table
 12816                                  ; *		 in DOS if character if above  ascii 128, else
 12817                                  ; *		 subtracts 20H if between "a" and "z".
 12818                                  ; *
 12819                                  ; * INPUT:	 AL	      char to be upper cased
 12820                                  ; *		 FUCASE_ADDR  set to the file upper case table
 12821                                  ; *
 12822                                  ; * OUTPUT:	 AL	      upper cased character
 12823                                  ; *
 12824                                  ; ****************************************************************
 12825                                  ;
 12826                                  ;assume	ds:trangroup				;AN000;
 12827                                  ;
 12828                                  ;upconv	proc	near				;AN000;
 12829                                  ;
 12830                                  ;	cmp	al,80h				;AN000;  see if char is > ascii 128
 12831                                  ;	jb	oth_fucase			;AN000;  no - upper case math
 12832                                  ;	sub	al,80h				;AN000;  only upper 128 chars in table
 12833                                  ;	push	ds				;AN000;
 12834                                  ;	push	bx				;AN000;
 12835                                  ;	mov	ds,[resseg]			;AN000;  get resident data segment
 12836                                  ;assume	ds:resgroup				;AN000;
 12837                                  ;	lds	bx,dword ptr fucase_addr+1	;AN000;  get table address
 12838                                  ;	add	bx,2				;AN000;  skip over first word
 12839                                  ;	xlat	ds:byte ptr [bx]		;AN000;  convert to upper case
 12840                                  ;	pop	bx				;AN000;
 12841                                  ;	pop	ds				;AN000;
 12842                                  ;assume	ds:trangroup				;AN000;
 12843                                  ;	jmp	short upconv_end		;AN000;  we finished - exit
 12844                                  ;
 12845                                  ;oth_fucase:					;AN000;
 12846                                  ;	cmp	al,small_a			;AC000; if between "a" and "z",
 12847                                  ;	jb	upconv_end			;AC000;     subtract 20h to get
 12848                                  ;	cmp	al,small_z			;AC000;    upper case equivalent.
 12849                                  ;	ja	upconv_end			;AC000;
 12850                                  ;	sub	al,20h				;AC000; Change lower-case to upper
 12851                                  ;
 12852                                  ;upconv_end:					;AN000;
 12853                                  ;	ret
 12854                                  ;
 12855                                  ;upconv	endp					;AN000;
 12856                                  
 12857                                  
 12858                                  ; =============== S U B	R O U T	I N E =======================================
 12859                                  
 12860                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 29F2h
 12861                                  
 12862                                  UPCONV:
 12863 00002949 3C80                    		cmp	al,80h
 12864 0000294B 7214                    		jb	short OTH_UCASE
 12865 0000294D 2C80                    		sub	al,80h
 12866 0000294F 1E                      		push	ds
 12867 00002950 53                      		push	bx
 12868 00002951 8E1E[8141]              		mov	ds,[RESSEG]
 12869 00002955 C51E000C                		lds	bx,[UPPERCASETBL]
 12870 00002959 83C302                  		add	bx,2
 12871 0000295C D7                      		xlat
 12872 0000295D 5B                      		pop	bx
 12873 0000295E 1F                      		pop	ds
 12874 0000295F EB0A                    		jmp	short UPCONV_RETN
 12875                                  OTH_UCASE:
 12876 00002961 3C61                    		cmp	al,'a'
 12877 00002963 7206                    		jb	short UPCONV_RETN
 12878 00002965 3C7A                    		cmp	al,'z'
 12879 00002967 7702                    		ja	short UPCONV_RETN
 12880 00002969 2C20                    		sub	al,20h
 12881                                  UPCONV_RETN:
 12882 0000296B C3                      		retn
 12883                                  
 12884                                  ;============================================================================
 12885                                  ; COPY.ASM, MSDOS 6.0, 1991
 12886                                  ;============================================================================
 12887                                  ; 01/10/2018 - Retro DOS v3.0
 12888                                  
 12889                                  ;	title	COMMAND COPY routines.
 12890                                  
 12891                                  ;/*
 12892                                  ; *                      Microsoft Confidential
 12893                                  ; *                      Copyright (C) Microsoft Corporation 1991
 12894                                  ; *                      All Rights Reserved.
 12895                                  ; */
 12896                                  
 12897                                  ;***	COPY.ASM
 12898                                  
 12899                                  ;Source files:  copy.asm, copypr1.asm, copypr2.asm
 12900                                  
 12901                                  
 12902                                  ;***	MODIFICATION HISTORY
 12903                                  
 12904                                  ;11/01/83 EE  Added a few lines at the end of SCANSRC2 to get multiple
 12905                                  ;	     file concatenations (eg copy a.*+b.*+c.*) to work properly.
 12906                                  ;11/02/83 EE  Commented out the code in CPARSE which added drive designators
 12907                                  ;	     to tokens which begin with path characters so that PARSELINE
 12908                                  ;	     will work correctly.
 12909                                  ;11/04/83 EE  Commented out the code in CPARSE that considered paren's to be
 12910                                  ;	     individual tokens.  That distinction is no longer needed for
 12911                                  ;	     FOR loop processing.
 12912                                  ;11/17/83 EE  CPARSE upper case conversion is now flag dependent.  Flag is
 12913                                  ;	     1 when Cparse is called from COPY.
 12914                                  ;11/17/83 EE  Took out the comment chars around code described in 11/04/83
 12915                                  ;	     mod.  It now is conditional on flag like previous mod.
 12916                                  ;11/21/83 NP  Added printf
 12917                                  ;12/09/83 EE  CPARSE changed to use CPYFLAG to determine when a colon should
 12918                                  ;	     be added to a token.
 12919                                  ;05/30/84 MZ  Initialize all copy variables.  Fix confusion with destclosed
 12920                                  ;	     NOTE: DestHand is the destination handle.  There are two
 12921                                  ;	     special values:  -1 meaning destination was never opened and
 12922                                  ;	     0 which means that the destination has been openned and
 12923                                  ;	     closed.
 12924                                  ;06/01/84 MZ  Above reasoning totally specious.  Returned things to normal
 12925                                  ;06/06/86 EG  Change to fix problem of source switches /a and /b getting
 12926                                  ;	     lost on large and multiple file (wildcard) copies.
 12927                                  ;06/09/86 EG  Change to use xnametrans call to verify that source and
 12928                                  ;	     destination are not equal.
 12929                                  ;
 12930                                  ;06/24/90 DO  If the destination of a file concatenation is the same as
 12931                                  ;	     first source file AND we run out of disk space before
 12932                                  ;	     completing the concatenation, restore the first source
 12933                                  ;	     file as best we can.  See SeekEnd and CopErr.  Bug #859.
 12934                                  ;
 12935                                  ;M031 SR 10/11/90  Bug #3069. Use deny write sharing mode to open files
 12936                                  ;		instead of compatibility mode. This gives lesser sharing
 12937                                  ;		violations when files are opened for read on a copy.
 12938                                  
 12939                                  ; ---------------------------------------------------------------------------
 12940                                  ;***	COPY CODE
 12941                                  ; ---------------------------------------------------------------------------
 12942                                  
 12943                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2A15h
 12944                                  
 12945                                  COPY:
 12946                                  	; 	Initialize internal variables.
 12947                                  
 12948 0000296C 31C0                    		xor	ax,ax		; AX = 0
 12949 0000296E A3[6043]                		mov	[COPY_NUM],ax	; # files copied (destinations) = 0
 12950 00002971 A3[9544]                		mov	[SRCPT],ax	; cmd line ptr for source scan = 0
 12951 00002974 A3[E143]                		mov	[SRCTAIL],ax	; ptr to last element of source pathname = 0
 12952 00002977 A2[A041]                		mov	[CFLAG],al	; 'destination file created' = false
 12953 0000297A A3[A441]                		mov	[NXTADD],ax	; ptr into TPA buffer = 0
 12954 0000297D A3[9C41]                		mov	[DESTSWITCH],ax	; destination switches = none
 12955 00002980 A3[A744]                		mov	[STARTEL],ax	; CParse ptr to last pathname element = 0
 12956 00002983 A3[7E43]                		mov	[DESTTAIL],ax	; ptr to last element of dest pathname = 0
 12957 00002986 A2[A141]                		mov	[DESTCLOSED],al	; 'destination file closed' = false
 12958 00002989 A2[7D43]                		mov	[DESTSIZ],al	; length of destination pathname = 0
 12959 0000298C A2[E043]                		mov	[SRCSIZ],al	; length of source pathname = 0
 12960 0000298F A2[8043]                		mov	[DESTINFO],al	; destination pathname flags = none
 12961 00002992 A2[E343]                		mov	[SRCINFO],al	; source pathname flags = none
 12962 00002995 A2[9744]                		mov	[INEXACT],al	; 'inexact copy' = false
 12963 00002998 A2[7C43]                		mov	[DESTVARS],al	; 'dest pathname is directory' = false  ;*!*
 12964 0000299B A2[DF43]                		mov	[SRCVARS],al	; 'source pathname is directory' = false
 12965 0000299E A2[6340]                		mov	[USERDIR1],al	; saved working directory = null
 12966 000029A1 A2[9944]                		mov	[NOWRITE],al	; 'no write' (source = dest) = false
 12967 000029A4 A2[9441]                		mov	[RDEOF],al	; 'read end of file' = false
 12968 000029A7 A3[3B44]                		mov	[SRCHAND],ax	; source handle = 0
 12969 000029AA A3[A144]                		mov	[CPDATE],ax	; copy date = 0
 12970 000029AD A3[A344]                		mov	[CPTIME],ax	; copy time = 0
 12971 000029B0 A2[3D44]                		mov	[SRCISDEV],al	; 'source is device' = false
 12972                                  		;mov	[OCtrlZ],al	; 'Ctrl+Z removed from original' = false
 12973                                  		;mov	[OFilePtr_Lo],ax
 12974                                  		;mov	[OFilePtr_Hi],ax ; original destination file ptr = null
 12975 000029B3 A2[9D44]                		mov	[TERMREAD],al	; 'terminate read' = false
 12976 000029B6 A2[D642]                		mov	[COMMA],al	; '"+,," found' = false
 12977 000029B9 A2[D742]                		mov	[PLUS_COMMA],al ; '"+,," found last time' = false (?)
 12978 000029BC A3[9E41]                		mov	[ALLSWITCH],ax	; all switches = none
 12979 000029BF A2[9741]                		mov	[ARGC],al	; source/dest argument count = 0
 12980 000029C2 A2[9F44]                		mov	[PLUS],al	; '"+" in command line' = false
 12981 000029C5 A2[9A44]                		mov	[BINARY],al	; 'binary copy' = false
 12982 000029C8 A2[9E44]                		mov	[ASCII],al	; 'ascii copy' = false
 12983 000029CB A3[A941]                		mov	[FILECNT],ax	; # files copied (destinations) = 0
 12984 000029CE A3[9B44]                		mov	[WRITTEN],ax	; 'destination written to' = false
 12985 000029D1 A2[9641]                		mov	[CONCAT],al	; 'concatenating' = false
 12986 000029D4 A2[DC43]                		mov	[MELCOPY],al	; 'Mel Hallerman copy' = false
 12987 000029D7 A3[DD43]                		mov	[MELSTART],ax	; Mel Hallerman cmd line ptr = 0,
 12988                                  
 12989                                  	;	Initialize buffers with double-nulls.
 12990                                  
 12991 000029DA A3[3E44]                		mov	[SCANBUF],ax
 12992 000029DD A3[8143]                		mov	[DESTBUF],ax
 12993 000029E0 A3[E443]                		mov	[SRCBUF],ax
 12994 000029E3 A3[C042]                		mov	[SDIRBUF],ax
 12995 000029E6 A3[7A42]                		mov	[DIRBUF],ax
 12996 000029E9 A3[3742]                		mov	[DESTFCB],ax
 12997                                  
 12998 000029EC A2[A044]                		mov	[OBJCNT],al	; # CParse cmd-line objects found = 0
 12999                                  		
 13000 000029EF 48                      		dec	ax		; AX = 0FFFFh
 13001 000029F0 A3[D843]                		mov	[DESTHAND],ax	; destination handle = 'never opened'
 13002 000029F3 A2[A641]                		mov	[FRSTSRCH],al	; 'first search for source' = true
 13003 000029F6 A2[DB43]                		mov	[FIRSTDEST],al	; 'first time for dest' = true
 13004 000029F9 A2[7C43]                		mov	[DESTISDIR],al	; 'haven't analyzed destination' ; *!*
 13005                                  		
 13006 000029FC BE8100                  		mov	si,81h		; SI = ptr to command line
 13007                                  		;mov	bl,[PLUS_CHR]	; BL = special delimiter = "+"
 13008                                  		; 01/03/2023
 13009                                  		;mov	bl,'+'
 13010 000029FF B32B                    		mov	bl,plus_chr
 13011 00002A01 FE06[B744]              		inc	byte [EXPAND_STAR] ; CParse 'expand * to ?s' = true
 13012 00002A05 C606[6643]01            		mov	byte [CPYFLAG],1 ; CParse 'called from COPY' = true
 13013                                  
 13014                                  	;*	Scan the command line for destination information.
 13015                                  
 13016                                  DESTSCAN:
 13017 00002A0A 31ED                    		xor	bp,bp			; BP = switch flag accumulator
 13018 00002A0C BF[3E44]                		mov	di,SCANBUF		; ES:DI = ptr to pathname buf
 13019                                  		;mov	[Parse_Last],si		;AN018; save cmd line ptr
 13020 00002A0F E86208                  		call	CPARSE			; parse next object
 13021 00002A12 9C                      		pushf				; save CParse flags
 13022 00002A13 FE06[A044]              		inc	byte [OBJCNT]		; count object
 13023 00002A17 F6C780                  		test	bh,80h
 13024 00002A1A 7405                    		jz	short NOCOPY		; no "+" delimiter
 13025 00002A1C C606[9F44]01            		mov	byte [PLUS],1		; "+" delimiter occurred
 13026                                  NOCOPY:
 13027 00002A21 F6C701                  		test	bh,1
 13028 00002A24 740D                    		jz	short TESTP2		; not a switch
 13029                                  
 13030                                  	;	Found a switch.
 13031                                  
 13032                                  		; MSDOS 6.0
 13033                                  		;test	bp,SwitchV		;AN038; Verify requested?
 13034                                  		;jz	Not_SlashV		;AN038; No - set the switch
 13035                                  		;test	AllSwitch,SwitchV	;AN038; Verify already entered?
 13036                                  		;jz	Not_SlashV		;AN038; No - set the switch
 13037                                  ;AD018; 	;or	AllSwitch,FBadSwitch	;AN038; Set up bad switch
 13038                                  		;or	bp,FBadSwitch		;AN018; Set up bad switch
 13039                                  
 13040                                  NOT_SLASHV:
 13041 00002A26 092E[9C41]              		or	[DESTSWITCH],bp		; assume destination
 13042 00002A2A 092E[9E41]              		or	[ALLSWITCH],bp		; keep tabs on all switches
 13043                                  
 13044                                  		; MSDOS 6.0
 13045                                  		;test	bp,not SwitchCopy	;AN018; Bad switch?
 13046                                  		;jz	Not_Bad_Switch		;AN018; Switches are okay
 13047                                  		;popf				;AN018; fix up stack
 13048                                  		;mov	ax,BadSwt_ptr		;AN018; get "Invalid switch" message number
 13049                                  		;invoke	Setup_Parse_Error_Msg	;AN018; setup to print the message
 13050                                  		;jmp	CError			;AC018; exit
 13051                                  
 13052                                  NOT_BAD_SWITCH:
 13053 00002A2E 9D                      		popf				; restore CParse flags
 13054 00002A2F 7233                    		jc	short CHECKDONE		; found CR
 13055 00002A31 EBD7                    		jmp	short DESTSCAN		; continue scanning for destination
 13056                                  
 13057                                  TESTP2:
 13058 00002A33 9D                      		popf				; restore CParse flags
 13059 00002A34 722E                    		jc	short CHECKDONE		; found CR
 13060 00002A36 F6C780                  		test	bh,80h
 13061 00002A39 7504                    		jnz	short GOTPLUS		; found a "+pathname" argument
 13062 00002A3B FE06[9741]              		inc	byte [ARGC]		; count independent pathname args
 13063                                  GOTPLUS:
 13064 00002A3F 56                      		push	si			; save cmd line ptr
 13065 00002A40 A1[A744]                		mov	ax,[STARTEL]		; AX = ptr to last path element
 13066 00002A43 BE[3E44]                		mov	si,SCANBUF		; SI = ptr to path string
 13067 00002A46 29F0                    		sub	ax,si			; AX = offset of last element
 13068 00002A48 BF[8143]                		mov	di,DESTBUF		; DI = ptr to destination buf
 13069 00002A4B 01F8                    		add	ax,di			; AX = ptr to last element in
 13070                                  						;  destination path buffer
 13071 00002A4D A3[7E43]                		mov	[DESTTAIL],ax		; save ptr to last element
 13072 00002A50 880E[7D43]              		mov	[DESTSIZ],cl		; save path string length
 13073 00002A54 41                      		inc	cx			; CX = mov length (incl null)
 13074 00002A55 F3A4                    		rep movsb			; DestBuf = possible destination path
 13075 00002A57 883E[8043]              		mov	[DESTINFO],bh		; save CParse info flags
 13076 00002A5B C706[9C41]0000          		mov	word [DESTSWITCH],0	; clear destination switches
 13077 00002A61 5E                      		pop	si			; SI = ptr into cmd line again
 13078 00002A62 EBA6                    		jmp	short DESTSCAN		;AC018; continue scanning for dest
 13079                                  
 13080                                  CHECKDONE:
 13081                                  	;	We reached the CR. The destination scan is finished.
 13082                                  
 13083                                  	;	Disallow "copy file1+" as file overwriting itself.
 13084                                  	;
 13085                                  	;	(Note that "copy file1+file2+" will be accepted, and
 13086                                  	;	equivalent to "copy file1+file2".)
 13087                                  
 13088                                  	;	Bugbug: it looks like "copy /x file1+" would slip
 13089                                  	;	through this check, since the switch would count
 13090                                  	;	as another object in ObjCnt.
 13091                                  
 13092 00002A64 803E[9F44]01            		cmp	byte [PLUS],1		; "+" with
 13093 00002A69 7514                    		jnz	short CDCONT
 13094 00002A6B 803E[9741]01            		cmp	byte [ARGC],1		; one arg,
 13095 00002A70 750D                    		jnz	short CDCONT
 13096 00002A72 803E[A044]02            		cmp	byte [OBJCNT],2		; two objects..
 13097 00002A77 7506                    		jnz	short CDCONT
 13098 00002A79 BA[C437]                		mov	dx,OVERWRPTR
 13099 00002A7C E9A905                  		jmp	COPYERR			; is file overwrite
 13100                                  
 13101                                  CDCONT:
 13102 00002A7F A0[9F44]                		mov	al,[PLUS]		; AL = '"+" occurred'
 13103 00002A82 A2[9641]                		mov	[CONCAT],al		; if "+" occurred, we're concatenating
 13104 00002A85 D0E0                    		shl	al,1
 13105 00002A87 D0E0                    		shl	al,1
 13106 00002A89 A2[9744]                		mov	[INEXACT],al		; therefore making an inexact copy
 13107 00002A8C BA[9D3C]                		mov	dx,BADARGSPTR
 13108 00002A8F A0[9741]                		mov	al,[ARGC]		; AL = # independent arguments
 13109 00002A92 08C0                    		or	al,al
 13110 00002A94 7404                    		jz	short CERROR4J
 13111                                  
 13112                                  		; MSDOS 6.0
 13113                                  		;or	al,al
 13114                                  		;jnz	Try_Too_Many		; more than 0 args; check if too many
 13115                                  		
 13116                                  		;mov	dx,offset TRANGROUP:Extend_Buf_Ptr ; DX = ptr to msg block
 13117                                  		;mov	Extend_Buf_Ptr,LessArgs_Ptr	; set msg # "param missing"
 13118                                  		;jmp	short CError_ParseJ		; take parse error exit		
 13119                                  
 13120                                  	; more than 0 args; check if too many
 13121                                  
 13122                                  TRY_TOO_MANY:
 13123 00002A96 3C02                    		cmp	al,2
 13124 00002A98 7603                    		jbe	short ACOUNTOK		; <= 2 arguments - ok
 13125                                  
 13126                                  		; MSDOS 6.0
 13127                                  		;mov	dx,offset TRANGROUP:Extend_Buf_Ptr ; DX = ptr to msg block
 13128                                  		;mov	Extend_Buf_Ptr,MoreArgs_Ptr	; set msg # "too many params"
 13129                                  ;CError_ParseJ:
 13130                                  		;mov	Msg_Disp_Class,PARSE_MSG_CLASS	; parse error message	
 13131                                  
 13132                                  CERROR4J:
 13133 00002A9A E94DF1                  		jmp	CERROR
 13134                                  
 13135                                  ACOUNTOK:
 13136 00002A9D BD[7C43]                		mov	bp,DESTVARS		; BP = base of dest variables
 13137                                  
 13138 00002AA0 3C01                    		cmp	al,1
 13139 00002AA2 7520                    		jnz	short GOT2ARGS
 13140                                  
 13141                                  	;	Only one independent pathname argument on command line.
 13142                                  	;	Set destination to d:*.*, where d: is current drive.
 13143                                  
 13144                                  	;	Bugbug: but is this appropriate for "copy x:file1+x:file2"?
 13145                                  	;	The two files would be appended as d:file1, rather than x:file1.
 13146                                  
 13147 00002AA4 A0[9541]                		mov	al,[CURDRV]		; AL = current drive (0 = A)
 13148                                  		;add	al,[CAPITAL_A]		; AL = current drive letter
 13149                                  		; 01/03/2023
 13150 00002AA7 0441                    		add	al,capital_A  ; add al,'A'
 13151 00002AA9 B43A                    		mov	ah,':'			; AX = "d:"
 13152                                  		;mov	byte [bp+1],2
 13153 00002AAB C6460102                		mov	byte [bp+VARSTRUC.SIZ],2 ; pathname length = 2
 13154                                  
 13155 00002AAF BF[8143]                		mov	di,DESTBUF		; ES:DI = ptr to dest path buf
 13156 00002AB2 AB                      		stosw				; store "d:"
 13157                                  		
 13158 00002AB3 C706[9C41]0000          		mov	word [DESTSWITCH],0	; clear destination switches
 13159                                  		;mov	byte [bp+4],2		
 13160 00002AB9 C6460402                		mov	byte [bp+VARSTRUC.INFO],2 ; mark destination 'wildcard present'
 13161                                  		;mov	byte [bp+VARSTRUC.ISDIR],0 ; mark destination 'not a directory'
 13162                                  		;mov	byte [bp+0],0		
 13163 00002ABD C6460000                		mov	byte [bp],0
 13164 00002AC1 E88107                  		call	SETSTARS		; add wildcards
 13165                                  GOT2ARGS:
 13166                                  	;	If destination pathname is "d:", add full wildcard filename
 13167                                  
 13168                                  		;cmp	byte [bp+1],2
 13169 00002AC4 807E0102                		cmp	byte [bp+VARSTRUC.SIZ],2
 13170 00002AC8 7516                    		jnz	short NOTSHORTDEST	; not two chars, can't be "d:"
 13171 00002ACA B03A                    		mov	al,':'
 13172 00002ACC 3806[8243]              		cmp	[DESTBUF+1],al
 13173 00002AD0 750E                    		jnz	short NOTSHORTDEST	; it's just a 2-character filename
 13174                                  		;or	byte [bp+4],2
 13175 00002AD2 804E0402                		or	byte [bp+VARSTRUC.INFO],2 ; mark destination 'wildcard present'
 13176 00002AD6 BF[8343]                		mov	di,DESTBUF+2		; ES:DI = ptr after "d:"
 13177                                  		;mov	byte [bp+VARSTRUC.ISDIR],0 ; mark destination 'not a directory'
 13178                                  		;mov	byte [bp+0],0		
 13179 00002AD9 C6460000                		mov	byte [bp],0
 13180 00002ADD E86507                  		call	SETSTARS		; add wildcards
 13181                                  
 13182                                  NOTSHORTDEST:
 13183                                  	;	If destination pathname ends with "\", try to make
 13184                                  	;	sure it's "d:\".
 13185                                  
 13186                                  		;mov	di,[bp+2]
 13187 00002AE0 8B7E02                  		mov	di,[bp+VARSTRUC.TTAIL]	; DI = ptr to last path element
 13188 00002AE3 803D00                  		cmp	byte [di],0
 13189 00002AE6 7515                    		jnz	short CHKSWTCHES	; not a null, so last char not "\"
 13190                                  
 13191 00002AE8 BA[A63A]                		mov	dx,BADCDPTR
 13192 00002AEB B03A                    		mov	al,':'
 13193 00002AED 3845FE                  		cmp	[di-2],al
 13194 00002AF0 75A8                    		jne	short CERROR4J		; it's not "d:\", exit with error msg
 13195                                  		;mov	byte [bp+0],2
 13196                                  		;mov	byte [bp+VARSTRUC.ISDIR],2 ; destination 'is a directory'
 13197 00002AF2 C6460002                		mov	byte [bp],2
 13198                                  		;or	byte [bp+4],6
 13199 00002AF6 804E0406                		or	byte [bp+VARSTRUC.INFO],6 ; destination wildcarded and contains
 13200                                  						  ;  path character
 13201 00002AFA E84807                  		call	SETSTARS		; add wildcards
 13202                                  CHKSWTCHES:
 13203                                  	;	We have enough information about the destination for now.
 13204                                  
 13205                                  	;	Turn on verify if requested. Save the current verify flag.
 13206                                  
 13207 00002AFD BA[5239]                		mov	dx,BADPARMPTR
 13208 00002B00 A1[9E41]                		mov	ax,[ALLSWITCH]		; AX = all switch flags
 13209                                  
 13210                                  		; MSDOS 3.3
 13211                                  		;test	ax,~SWITCHCOPY ; 7FE3h
 13212 00002B03 A9E37F                  		test	ax,NOT_SWITCHCOPY ; 7FE3h ; 13/10/2018
 13213 00002B06 7592                    		jnz	short CERROR4J
 13214                                  		; MSDOS 3.3 (& MSDOS 6.0)
 13215 00002B08 A91000                  		test	ax,SWITCHV ; 10h
 13216 00002B0B 7414                    		jz	short NOVERIF		; no /v, no verify
 13217                                  
 13218 00002B0D B454                    		mov	ah,GET_VERIFY_ON_WRITE ; 54h
 13219 00002B0F CD21                    		int	21h		; DOS -	2+ - GET VERIFY	FLAG
 13220                                  					; Return: AL = 00h if flag OFF
 13221                                  					; AL = 01h if flag ON
 13222 00002B11 1E                      		push	ds
 13223 00002B12 8E1E[8141]              		mov	ds,[RESSEG]
 13224 00002B16 30E4                    		xor	ah,ah
 13225 00002B18 A3F10B                  		mov	[VERVAL],ax	; save current verify flag
 13226 00002B1B 1F                      		pop	ds
 13227 00002B1C B8012E                  		mov	ax,(SET_VERIFY_ON_WRITE<<8)|1 ; 2E01h
 13228 00002B1F CD21                    		int	21h		; DOS -	SET VERIFY FLAG
 13229                                  					; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
 13230                                  NOVERIF:
 13231                                  		;*	Scan for first source.
 13232                                  
 13233 00002B21 31ED                    		xor	bp,bp			; BP = switch flags accumulator
 13234 00002B23 BE8100                  		mov	si,81h			; SI = ptr into command line
 13235                                  		;mov	bl,[PLUS_CHR]		; BL = special CParse delimiter = "+"
 13236                                  		; 01/03/2023
 13237 00002B26 B32B                    		mov	bl,plus_chr  ; mov bl,'+'
 13238                                  SCANFSRC:
 13239 00002B28 BF[3E44]                		mov	di,SCANBUF		; DI = ptr to pathname buf
 13240 00002B2B E84607                  		call	CPARSE			; parse first source pathname
 13241 00002B2E F6C701                  		test	bh,1			; switch?
 13242 00002B31 75F5                    		jnz	short SCANFSRC		; yes, try again
 13243 00002B33 092E[9C41]              		or	[DESTSWITCH],bp		; include copy-wide switches on dest
 13244                                  
 13245                                  ;	Set ascii copying mode if concatenating, unless /b is specified.
 13246                                  
 13247                                  		;test	bp,8
 13248 00002B37 F7C50800                		test	bp,SWITCHB
 13249 00002B3B 750C                    		jnz	short NOSETCASC		; /b - explicit binary copy
 13250 00002B3D 803E[9641]00            		cmp	byte [CONCAT],0
 13251 00002B42 7405                    		je	short NOSETCASC		; we're not concatenating
 13252                                  		;mov	byte [ASCII],4
 13253 00002B44 C606[9E44]04            		mov	byte [ASCII],SWITCHA	; set ascii copy
 13254                                  NOSETCASC:
 13255 00002B49 E88F03                  		call	SOURCE_SET		; set source variables
 13256 00002B4C E83B00                  		call	FRSTSRC			; set up first source copy
 13257 00002B4F E98C00                  		jmp	FIRSTENT		; jump into the copy loop
 13258                                  
 13259                                  ; ---------------------------------------------------------------------------
 13260                                  
 13261                                  ENDCOPY:
 13262                                  
 13263                                  	;*	End of the road. Close destination, display # files
 13264                                  	;	copied (meaning # destinations), and go back to main
 13265                                  	;	transient COMMAND code.
 13266                                  
 13267 00002B52 E8A002                  		call	CLOSEDEST
 13268                                  ENDCOPY2:
 13269 00002B55 BA[2E38]                		mov	dx,COPIEDPTR
 13270 00002B58 8B36[A941]              		mov	si,[FILECNT]
 13271 00002B5C 8936[6043]              		mov	[COPY_NUM],si
 13272 00002B60 E8C508                  		call	STD_PRINTF
 13273 00002B63 E99ED5                  		jmp	TCOMMAND		; stack could be messed up
 13274                                  
 13275                                  ; ---------------------------------------------------------------------------
 13276                                  
 13277                                  SRCNONEXIST:
 13278                                  
 13279                                  	;*	Source doesn't exist.  If concatenating, ignore and continue.
 13280                                  	;	Otherwise, say 'file not found' and quit.
 13281                                  
 13282 00002B66 803E[9641]00            		cmp	byte [CONCAT],0
 13283 00002B6B 753A                    		jne	short NEXTSRC	; concatenating - go on to next source
 13284                                  
 13285                                  		; MSDOS 3.3
 13286 00002B6D BA[E443]                		mov	dx,SRCBUF
 13287 00002B70 8916[5843]              		mov	[STRING_PTR_1],dx
 13288 00002B74 BA[5D36]                		mov	dx,STRINGBUF1PTR
 13289 00002B77 E8AE08                  		call	STD_PRINTF
 13290 00002B7A BA[2837]                		mov	dx,FNOTFOUNDPTR
 13291 00002B7D E9A804                  		jmp	COPYERR
 13292                                  
 13293                                  		; MSDOS 6.0
 13294                                  	;	Set up error message.
 13295                                  		;mov	Msg_Disp_Class,EXT_MSG_CLASS	     ; extended error msg
 13296                                  		;mov	dx,offset TRANGROUP:Extend_Buf_Ptr   ; DX = ptr to msg block
 13297                                  		;mov	Extend_Buf_Ptr,ERROR_FILE_NOT_FOUND  ; 'file not found' msg#
 13298                                  		;mov	String_Ptr_2,offset TRANGROUP:SrcBuf ; point at bad pathname
 13299                                  		;mov	Extend_Buf_Sub,ONE_SUBST	     ; 1 substitution
 13300                                  		;
 13301                                  		;jmp	CopErr			; print msg and clean up
 13302                                  
 13303                                  ; ---------------------------------------------------------------------------
 13304                                  
 13305                                  SOURCEPROC:
 13306                                  
 13307                                  	;*	Preparatory processing for each source file.
 13308                                  	;	Called at FrstSrc for first source file.
 13309                                  
 13310 00002B80 E85803                  		call	SOURCE_SET		; set source variables & ascii/binary
 13311 00002B83 803E[9641]00            		cmp	byte [CONCAT],0
 13312 00002B88 750B                    		jne	short LEAVECFLAG	; concatenating - leave CFlag alone
 13313                                  
 13314                                  ; ---------------------------------------------------------------------------
 13315                                  
 13316                                  FRSTSRC:
 13317 00002B8A 31C0                    		xor	ax,ax
 13318 00002B8C A2[A041]                		mov	[CFLAG],al		; 'destination not created'
 13319 00002B8F A3[A441]                		mov	[NXTADD],ax		; copy buffer ptr = 0
 13320 00002B92 A2[A141]                		mov	[DESTCLOSED],al		; 'destination not closed'
 13321                                  
 13322                                  LEAVECFLAG:
 13323 00002B95 8936[9544]              		mov	[SRCPT],si		; save cmd-line ptr
 13324 00002B99 BF[6340]                		mov	di,USERDIR1		; DI = ptr to buf for user's 
 13325                                  						;   current dir
 13326 00002B9C BD[DF43]                		mov	bp,SRCVARS		; BP = base of source variables
 13327 00002B9F E8CD05                  		call	BUILDPATH		; cd to source dir, figure
 13328                                  						;   out stuff about source
 13329 00002BA2 8B36[E143]              		mov	si,[SRCTAIL]		; SI = ptr to source filename
 13330 00002BA6 C3                      		retn
 13331                                  
 13332                                  ; ---------------------------------------------------------------------------
 13333                                  
 13334                                  NEXTSRC:
 13335                                  
 13336                                  	;*	Next source. Come here after handling each pathname.
 13337                                  	;	We're done unless there are additional source pathnames
 13338                                  	;	to be appended.
 13339                                  	;
 13340                                  	;	Note that all files matching an ambiguous pathname
 13341                                  	;	are processed before coming here.
 13342                                  
 13343 00002BA7 803E[9F44]00            		cmp	byte [PLUS],0
 13344                                  		;jne	short MORECP		; copying "+" sources - keep going
 13345                                  		; 01/03/2023
 13346 00002BAC 74A4                    		je	short ENDCOPY
 13347                                  ;ENDCOPYJ2:
 13348                                  		;jmp	short ENDCOPY
 13349                                  MORECP:
 13350 00002BAE 31ED                    		xor	bp,bp			; BP = switch flags accumulator
 13351 00002BB0 8B36[9544]              		mov	si,[SRCPT]		; SI = ptr to current pos'n in cmd line
 13352                                  		;mov	bl,[PLUS_CHR]		; BL = special delimiter = "+"
 13353                                  		; 01/03/2023
 13354 00002BB4 B32B                    		mov	bl,plus_chr ; mov bl,'+'
 13355                                  SCANSRC:
 13356 00002BB6 BF[3E44]                		mov	di,SCANBUF		; DI = ptr to pathname buf
 13357 00002BB9 E8B806                  		call	CPARSE			; parse first source name
 13358                                  		;jb	short ENDCOPYJ2		; CR found - we're done
 13359                                  		; 01/03/2023
 13360 00002BBC 7294                    		jb	short ENDCOPY
 13361                                  
 13362 00002BBE F6C780                  		test	bh,80h
 13363                                  		;jz	short ENDCOPYJ2		; no "+" delimiter - we're done
 13364                                  		; 01/03/2023
 13365 00002BC1 748F                    		jz	short ENDCOPY
 13366                                  
 13367 00002BC3 F6C701                  		test	bh,1
 13368 00002BC6 75EE                    		jnz	short SCANSRC		; switch found - keep looking
 13369                                  
 13370                                  	;	ScanBuf contains the next source pathname.
 13371                                  
 13372 00002BC8 E8B5FF                  		call	SOURCEPROC		; prepare this source
 13373 00002BCB 803E[D642]01            		cmp	byte [COMMA],1		; was +,, found last time?
 13374 00002BD0 7507                    		jnz	short NOSTAMP		;  no - try for a file
 13375 00002BD2 C606[D742]01            		mov	byte [PLUS_COMMA],1	; yes - set flag
 13376 00002BD7 EB8D                    		jmp	short SRCNONEXIST	; we know we won't find it
 13377                                  NOSTAMP:
 13378 00002BD9 C606[D742]00            		mov	byte [PLUS_COMMA],0	; reset +,, flag
 13379                                  
 13380                                  ; ---------------------------------------------------------------------------
 13381                                  
 13382                                  FIRSTENT:
 13383                                  
 13384                                  ;M047
 13385                                  ; The only case we need to worry about is when the source is wildcarded and
 13386                                  ;the destination is not. For this case, ConCat is not yet set to indicate
 13387                                  ;concatenation. We check for this case.
 13388                                  ;
 13389                                  ;NB: This change has been backed out and replaced by M048. This is not the
 13390                                  ;right place to do this check.
 13391                                  
 13392                                  	;	This is where we enter the loop with the first source.
 13393                                  
 13394 00002BDE BF5C00                  		mov	di,FCB ; 5Ch		; DI = ptr to FCB
 13395 00002BE1 B80029                  		mov	ax,PARSE_FILE_DESCRIPTOR*256 ; 2900h
 13396 00002BE4 CD21                    		int	21h		; DOS -	PARSE FILENAME
 13397                                  					; DS:SI	-> string to parse
 13398                                  					; ES:DI	-> buffer to fill with unopened	FCB
 13399                                  					; AL = bit mask	to control parsing
 13400 00002BE6 803C00                  		cmp	byte [si],0		; did we parse the whole thing?
 13401 00002BE9 7516                    		jne	short SRCHDONE		; no, error, simulate 'not found'
 13402 00002BEB A1[E443]                		mov	ax,[SRCBUF]		; AX = possible "d:"
 13403 00002BEE 80FC3A                  		cmp	ah,':'
 13404 00002BF1 7402                    		je	short DRVSPEC1		; AX = definite "d:"
 13405 00002BF3 B040                    		mov	al,'@'			; AL = drive 'letter' for current drive
 13406                                  DRVSPEC1:
 13407 00002BF5 0C20                    		or	al,20h			; AL = lowercase drive letter
 13408 00002BF7 2C60                    		sub	al,60h			; AL = drive id (0=current,1=A,..)
 13409                                  		;mov	[5Ch],al
 13410 00002BF9 A25C00                  		mov	[FCB],al		; put drive id in FCB
 13411                                  
 13412                                  	;	FCB contains drive and filename to search.
 13413                                  		
 13414 00002BFC B411                    		mov	ah,DIR_SEARCH_FIRST ; 11h  ; AH = 'Find First File'	
 13415 00002BFE E80301                  		call	SEARCH
 13416                                  SRCHDONE:
 13417 00002C01 9C                      		pushf				; save flags from Search
 13418 00002C02 E85BEC                  		call	RESTUDIR1		; restore users current directory
 13419 00002C05 9D                      		popf				; restore flags from search
 13420 00002C06 7403                    		jz	short NEXTAMBIG0	; found the source - continue
 13421 00002C08 E95BFF                  		jmp	SRCNONEXIST		; didn't find the source
 13422                                  
 13423                                  NEXTAMBIG0:
 13424 00002C0B 30C0                    		xor	al,al
 13425 00002C0D 8606[A641]              		xchg	al,[FRSTSRCH]
 13426 00002C11 08C0                    		or	al,al
 13427 00002C13 740B                    		jz	short NEXTAMBIG
 13428                                  SETNMEL:
 13429 00002C15 B90C00                  		mov	cx,12
 13430 00002C18 BF[C042]                		mov	di,SDIRBUF
 13431 00002C1B BE[7A42]                		mov	si,DIRBUF
 13432 00002C1E F3A4                    		rep movsb			; save very first source name
 13433                                  NEXTAMBIG:
 13434 00002C20 30C0                    		xor	al,al
 13435 00002C22 A2[9944]                		mov	[NOWRITE],al		; turn off nowrite
 13436 00002C25 8B3E[E143]              		mov	di,[SRCTAIL]
 13437 00002C29 BE[7B42]                		mov	si,DIRBUF+1
 13438 00002C2C E836ED                  		call	FCB_TO_ASCZ		; SrcBuf has complete name
 13439                                  MELDO:
 13440 00002C2F 803E[9641]00            		cmp	byte [CONCAT],0
 13441 00002C34 7507                    		jnz	short SHOWCPNAM		; concatenating - show name
 13442 00002C36 F606[E343]02            		test	byte [SRCINFO],2	; wildcard - show name
 13443 00002C3B 7410                    		jz	short DOREAD
 13444                                  SHOWCPNAM:
 13445 00002C3D BA[E443]                		mov	dx,SRCBUF
 13446 00002C40 8916[5E43]              		mov	[STRING_PTR_2],dx
 13447 00002C44 BA[6F36]                		mov	dx,STRINGBUF2PTR
 13448 00002C47 E8DE07                  		call	STD_PRINTF
 13449 00002C4A E8ECEC                  		call	CRLF2
 13450                                  DOREAD:
 13451 00002C4D E8C500                  		call	DOCOPY
 13452 00002C50 803E[9641]00            		cmp	byte [CONCAT],0
 13453 00002C55 750A                    		jnz	short NODCLOSE		; concatenating - don't close dest
 13454                                  
 13455 00002C57 E89B01                  		call	CLOSEDEST		; close current destination
 13456 00002C5A 7205                    		jc	short NODCLOSE		; concatenating - dest not closed
 13457                                  
 13458 00002C5C C606[A041]00            		mov	byte [CFLAG],0		; 'destination not created'
 13459                                  NODCLOSE:
 13460 00002C61 803E[9641]00            		cmp	byte [CONCAT],0		
 13461 00002C66 740A                    		jz	short NOFLUSH
 13462                                  
 13463                                  ;	Concatenating - flush output between source files so LostErr
 13464                                  ;	stuff works correctly.
 13465                                  
 13466                                  		;invoke	FlshFil  ; MSDOS 6.0
 13467                                  
 13468 00002C68 E8A502                  		call	FLUSHFIL ; MSDOS 3.3
 13469 00002C6B F606[DC43]FF            		test	byte [MELCOPY],0FFh
 13470                                  		;jz	short NOFLUSH
 13471                                  		;jmp	short DOMELCOPY
 13472                                  		; 01/03/2023
 13473 00002C70 750C                    		jnz	short DOMELCOPY
 13474                                  NOFLUSH:
 13475 00002C72 E88300                  		call	SEARCHNEXT		; try next match
 13476 00002C75 755D                    		jnz	short NEXTSRCJ		; not found - finished with 
 13477                                  						;   this source spec
 13478 00002C77 C606[A141]00            		mov	byte [DESTCLOSED],0	; 'destination not closed'
 13479                                  
 13480 00002C7C EBA2                    		jmp	short NEXTAMBIG		; do next ambig match
 13481                                  DOMELCOPY:
 13482 00002C7E 803E[DC43]FF            		cmp	byte [MELCOPY],0FFh
 13483 00002C83 740D                    		je	short CONTMEL
 13484 00002C85 8B36[9544]              		mov	si,[SRCPT]
 13485 00002C89 8936[DD43]              		mov	[MELSTART],si
 13486 00002C8D C606[DC43]FF            		mov	byte [MELCOPY],0FFh
 13487                                  CONTMEL:
 13488 00002C92 31ED                    		xor	bp,bp
 13489 00002C94 8B36[9544]              		mov	si,[SRCPT]
 13490                                  		;mov	bl,[PLUS_CHR]
 13491                                  		; 01/03/2023
 13492 00002C98 B32B                    		mov	bl,plus_chr ; mov bl,'+'
 13493                                  SCANSRC2:
 13494 00002C9A BF[3E44]                		mov	di,SCANBUF
 13495 00002C9D E8D405                  		call	CPARSE
 13496 00002CA0 F6C780                  		test	bh,80h
 13497 00002CA3 7432                    		jz	short NEXTMEL		; no "+" - go back to start
 13498 00002CA5 F6C701                  		test	bh,1
 13499 00002CA8 75F0                    		jnz	short SCANSRC2		; switch - keep scanning
 13500 00002CAA E8D3FE                  		call	SOURCEPROC
 13501 00002CAD E8B0EB                  		call	RESTUDIR1
 13502 00002CB0 BF[FB41]                		mov	di,DESTFCB2
 13503 00002CB3 B80029                  		mov	ax,PARSE_FILE_DESCRIPTOR*256 ; 2900h
 13504 00002CB6 CD21                    		int	21h		; DOS -	PARSE FILENAME
 13505                                  					; DS:SI	-> string to parse
 13506                                  					; ES:DI	-> buffer to fill with unopened	FCB
 13507                                  					; AL = bit mask	to control parsing
 13508 00002CB8 BB[C142]                		mov	bx,SDIRBUF+1
 13509 00002CBB BE[FC41]                		mov	si,DESTFCB2+1
 13510 00002CBE 8B3E[E143]              		mov	di,[SRCTAIL]
 13511                                  
 13512 00002CC2 E87A04                  		call	BUILDNAME
 13513                                  
 13514 00002CC5 803E[9641]00            		cmp	byte [CONCAT],0
 13515 00002CCA 7405                    		je	short MELDOJ		; not concatenating - continue
 13516                                  
 13517                                  	;	Yes, turn off nowrite because this part of the code 
 13518                                  	;	is only reached after the first file has been dealt with.
 13519                                  
 13520 00002CCC C606[9944]00            		mov	byte [NOWRITE],0
 13521                                  MELDOJ:
 13522 00002CD1 E95BFF                  		jmp	MELDO
 13523                                  
 13524                                  NEXTSRCJ:
 13525 00002CD4 E9D0FE                  		jmp	NEXTSRC
 13526                                  
 13527                                  NEXTMEL:
 13528 00002CD7 E81B01                  		call	CLOSEDEST
 13529 00002CDA 31C0                    		xor	ax,ax
 13530 00002CDC A2[A041]                		mov	[CFLAG],al
 13531 00002CDF A3[A441]                		mov	[NXTADD],ax
 13532 00002CE2 A2[A141]                		mov	[SPECDRV],al
 13533 00002CE5 8B36[DD43]              		mov	si,[MELSTART]
 13534 00002CE9 8936[9544]              		mov	[SRCPT],si
 13535 00002CED E80800                  		call	SEARCHNEXT
 13536 00002CF0 7403                    		jz	short SETNMELJ
 13537 00002CF2 E960FE                  		jmp	ENDCOPY2
 13538                                  
 13539                                  SETNMELJ:
 13540 00002CF5 E91DFF                  		jmp	SETNMEL
 13541                                  
 13542                                  ; ---------------------------------------------------------------------------
 13543                                  
 13544                                  SEARCHNEXT:
 13545 00002CF8 B412                    		mov	ah,DIR_SEARCH_NEXT ; 12h
 13546 00002CFA F606[E343]02            		test	byte [SRCINFO],2
 13547 00002CFF 7503                    		jnz	short SEARCH		; do search-next if ambig
 13548 00002D01 08E4                    		or	ah,ah			; reset zero flag
 13549 00002D03 C3                      		retn
 13550                                  
 13551                                  ; ---------------------------------------------------------------------------
 13552                                  
 13553                                  SEARCH:
 13554 00002D04 50                      		push	ax
 13555 00002D05 B41A                    		mov	ah,SET_DMA ; 1Ah
 13556 00002D07 BA[7A42]                		mov	dx,DIRBUF	; put result of search in dirbuf
 13557 00002D0A CD21                    		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 13558                                  				; DS:DX	-> disk	transfer buffer
 13559 00002D0C 58                      		pop	ax		; restore search first/next command
 13560 00002D0D BA5C00                  		mov	dx,FCB ; 5Ch
 13561 00002D10 CD21                    		int	21h		; Do the search
 13562 00002D12 08C0                    		or	al,al
 13563 00002D14 C3                      		retn
 13564                                  
 13565                                  ; ---------------------------------------------------------------------------
 13566                                  
 13567                                  DOCOPY:
 13568 00002D15 BE[E443]                		mov	si,SRCBUF	; do name translate of source
 13569 00002D18 BF[AF3E]                		mov	di,SRCXNAME	; save for name comparison
 13570 00002D1B B460                    		mov	ah,XNAMETRANS ; 60h
 13571 00002D1D CD21                    		int	21h	; DOS -	RESOLVE	PATH STRING TO CANONICAL PATH STRING
 13572                                  				; DS:SI	-> ASCIZ relative path string or directory name
 13573                                  				; ES:DI	-> 128-byte buffer for ASCIZ canonical fully qualified name
 13574 00002D1F C606[9441]00            		mov	byte [RDEOF],0	; no EOF yet
 13575                                  
 13576                                  		; MSDOS 6.0
 13577                                  		;mov	ax,EXTOPEN shl 8	; open the file
 13578                                  ;M046
 13579                                  ; For reads, the sharing mode should be deny none so that any process can
 13580                                  ;open this file again in any other sharing mode. This is mainly to allow
 13581                                  ;multiple command.com's to access the same file without getting sharing
 13582                                  ;violations
 13583                                  ;
 13584                                  		;mov	bx,DENY_NONE or READ_OPEN_MODE
 13585                                  						; open mode for COPY ;M046
 13586                                  		;xor	cx,cx			; no special files
 13587                                  		;mov	dx,READ_OPEN_FLAG	; set up open flags
 13588                                  		;int	21h
 13589                                  		;
 13590                                  		;jnc	OpenOk
 13591                                  
 13592                                  	;	Bogosity: IBM wants us to issue Access Denied in this case.
 13593                                  	;	They asked for it...
 13594                                  
 13595                                  		;jmp	short Error_On_Source 	;AC022; clean up and exit
 13596                                  
 13597                                  		; MSDOS 3.3
 13598 00002D24 BA[E443]                		mov	dx,SRCBUF
 13599 00002D27 B8003D                  		mov	ax,OPEN*256 ; 3D00h
 13600 00002D2A CD21                    		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 13601                                  					; DS:DX	-> ASCIZ filename
 13602                                  					; AL = access mode
 13603                                  					; 0 - read
 13604 00002D2C 7311                    		jnc	short OPENOK
 13605 00002D2E E848F1                  		call	GET_EXT_ERR_NUMBER
 13606 00002D31 9C                      		pushf
 13607 00002D32 83F841                  		cmp	ax,65
 13608 00002D35 7506                    		jnz	short DOCOPY_ERR
 13609 00002D37 BA[4D37]                		mov	dx,ACCDENPTR
 13610 00002D3A E8EB06                  		call	STD_PRINTF
 13611                                  DOCOPY_ERR:
 13612 00002D3D 9D                      		popf
 13613 00002D3E C3                      		retn
 13614                                  
 13615                                  		; MSDOS 3.3 (& MSDOS 6.0)
 13616                                  OPENOK:
 13617 00002D3F 89C3                    		mov	bx,ax
 13618 00002D41 891E[3B44]              		mov	[SRCHAND],bx		; save handle
 13619 00002D45 B80057                  		mov	ax,FILE_TIMES*256 ; 5700h
 13620 00002D48 CD21                    		int	21h		; DOS -	2+ - GET FILE'S DATE/TIME
 13621                                  					; BX = file handle
 13622                                  
 13623                                  		;jc	Error_On_Source  ; MSDOS 6.0
 13624                                  
 13625 00002D4A 8916[A144]              		mov	[CPDATE],dx		; save date
 13626 00002D4E 890E[A344]              		mov	[CPTIME],cx		; save time
 13627                                  
 13628                                  		; MSDOS 6.0
 13629                                  		;jmp	short No_Copy_Xa  ; (xa copy code removed)
 13630                                  
 13631                                  ;Error_On_Source:				;AN022; we have a BAD error
 13632                                  		;invoke	Set_Ext_Error_Msg	;AN022; set up the error message
 13633                                  		;mov	String_Ptr_2,offset TRANGROUP:SrcBuf ;AN022; get address of failed string
 13634                                  		;mov	Extend_Buf_Sub,ONE_SUBST ;AN022; put number of subst in control block
 13635                                  		;invoke	Std_EprintF		;AN022; print it
 13636                                  		;cmp	SrcHand,0		;AN022; did we open the file?
 13637                                  		;je	No_Close_Src		;AN022; no - don't close
 13638                                  		;call	CloseSrc		;AN022; clean up
 13639                                  ;No_Close_Src:					;AN022;
 13640                                  		;cmp	CFlag,0			;AN022; was destination created?
 13641                                  		;je	EndCopyJ3		;AN022; no - just cleanup and exit
 13642                                  		;jmp	EndCopy			;AN022; clean up concatenation and exit
 13643                                  ;EndCopyJ3:					;AN022;
 13644                                  		;jmp	EndCopy2		;AN022;
 13645                                  ;No_Copy_Xa:
 13646                                  		;mov	bx,SrcHand		;AN022; get handle back
 13647                                  
 13648                                  		; MSDOS 3.3 (& MSDOS 6.0)
 13649 00002D52 B80044                  		mov	ax,(IOCTL<<8) ; 4400h
 13650 00002D55 CD21                    		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 13651                                  					; BX = file or device handle
 13652 00002D57 80E280                  		and	dl,devid_ISDEV ; 80h
 13653 00002D5A 8816[3D44]              		mov	[SRCISDEV],dl		; set source info
 13654 00002D5E 740D                    		jz	short COPYLP		; source not a device
 13655 00002D60 803E[9A44]00            		cmp	byte [BINARY],0
 13656 00002D65 7406                    		je	short COPYLP		; ascii device ok
 13657 00002D67 BA[2B3C]                		mov	dx,INBDEVPTR		; cannot do binary input
 13658 00002D6A E9BB02                  		jmp	COPYERR
 13659                                  
 13660                                  COPYLP:
 13661 00002D6D 8B1E[3B44]              		mov	bx,[SRCHAND]
 13662 00002D71 8B0E[A241]              		mov	cx,[BYTCNT]
 13663 00002D75 8B16[A441]              		mov	dx,[NXTADD]
 13664 00002D79 29D1                    		sub	cx,dx			; compute available space
 13665 00002D7B 750E                    		jnz	short GOTROOM
 13666                                  		;invoke	FlshFil   ; MSDOS 6.0
 13667 00002D7D E89001                  		call	FLUSHFIL  ; MSDOS 3.3
 13668 00002D80 803E[9D44]00            		cmp	byte [TERMREAD],0
 13669 00002D85 7565                    		jne	short CLOSESRC		; give up
 13670 00002D87 8B0E[A241]              		mov	cx,[BYTCNT]
 13671                                  GOTROOM:
 13672 00002D8B 1E                      		push	ds
 13673 00002D8C 8E1E[8341]              		mov	ds,[TPA]
 13674 00002D90 B43F                    		mov	ah,READ ; 3Fh
 13675 00002D92 CD21                    		int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
 13676                                  					; BX = file handle,CX = number	of bytes to read
 13677                                  					; DS:DX	-> buffer
 13678 00002D94 1F                      		pop	ds
 13679 00002D95 7255                    		jc	short CLOSESRC	; MSDOS 3.3
 13680                                  		;jc	Error_On_Source ; MSDOS 6.0
 13681 00002D97 89C1                    		mov	cx,ax			; get count
 13682 00002D99 E351                    		jcxz	CLOSESRC		; no more to read
 13683 00002D9B 803E[3D44]00            		cmp	byte [SRCISDEV],0
 13684 00002DA0 7507                    		jne	short NOTESTA		; is a device, ascii mode
 13685 00002DA2 803E[9E44]00            		cmp	byte [ASCII],0
 13686 00002DA7 741B                    		je	short BINREAD
 13687                                  NOTESTA:
 13688 00002DA9 89CA                    		mov	dx,cx
 13689 00002DAB 8B3E[A441]              		mov	di,[NXTADD]
 13690 00002DAF B01A                    		mov	al,1Ah
 13691 00002DB1 06                      		push	es
 13692 00002DB2 8E06[8341]              		mov	es,[TPA]		; scan for EOF
 13693 00002DB6 F2AE                    		repne scasb
 13694 00002DB8 07                      		pop	es
 13695 00002DB9 7505                    		jnz	short USEALL
 13696 00002DBB FE06[9441]              		inc	byte [RDEOF]
 13697 00002DBF 41                      		inc	cx
 13698                                  USEALL:
 13699 00002DC0 29CA                    		sub	dx,cx
 13700 00002DC2 89D1                    		mov	cx,dx
 13701                                  BINREAD:
 13702 00002DC4 030E[A441]              		add	cx,[NXTADD]
 13703 00002DC8 890E[A441]              		mov	[NXTADD],cx
 13704 00002DCC 3B0E[A241]              		cmp	cx,[BYTCNT]		; is buffer full?
 13705 00002DD0 720C                    		jb	short TESTDEV		; if not, we may have found eof
 13706                                  		;invoke	FlshFil
 13707 00002DD2 E83B01                  		call	FLUSHFIL
 13708 00002DD5 803E[9D44]00            		cmp	byte [TERMREAD],0
 13709 00002DDA 7510                    		jne	short CLOSESRC		; give up
 13710 00002DDC EB8F                    		jmp	short COPYLP
 13711                                  TESTDEV:
 13712 00002DDE 803E[3D44]00            		cmp	byte [SRCISDEV],0	; if file then EOF
 13713 00002DE3 7407                    		je	short CLOSESRC
 13714 00002DE5 803E[9441]00            		cmp	byte [RDEOF],0
 13715 00002DEA 7481                    		je	short COPYLP		; on device, go till ^Z
 13716                                  CLOSESRC:
 13717 00002DEC 8B1E[3B44]              		mov	bx,[SRCHAND]
 13718 00002DF0 B43E                    		mov	ah,CLOSE ; 3Eh
 13719 00002DF2 CD21                    		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 13720                                  					; BX = file handle
 13721                                  CLOSESRCDEST_RETN:
 13722 00002DF4 C3                      		retn
 13723                                  
 13724                                  ; ---------------------------------------------------------------------------
 13725                                  
 13726                                  CLOSEDEST:
 13727                                  
 13728                                  	;	We are called to close the destination.
 13729                                  	;	We need to note whether or not there is any internal data left
 13730                                  	;	to be flushed out.
 13731                                  
 13732 00002DF5 803E[A141]00            		cmp	byte [DESTCLOSED],0
 13733 00002DFA 75F8                    		jne	short CLOSESRCDEST_RETN	; don't double close
 13734 00002DFC A0[9C41]                		mov	al,[DESTSWITCH]
 13735 00002DFF E86502                  		call	SETASC			; check for b or a switch
 13736 00002E02 7434                    		jz	short BINCLOS		;   on destination
 13737 00002E04 8B1E[A441]              		mov	bx,[NXTADD]
 13738                                  ;
 13739                                  ;M048 -- TryFlush changes the state of ConCat flag. So, before we append a
 13740                                  ;^Z, let's always flush out. This way if the ConCat flag changes, we will
 13741                                  ;just return without appending a ^Z incorrectly for the first file (since we
 13742                                  ;are concatenating now). Also, in case it is a single file copy, we will
 13743                                  ;anyway write the ^Z out separately. The only drawback is that there is a
 13744                                  ;performance overhead on single ASCII file copies which now always involve
 13745                                  ;2 writes instead of 1 before. Is this really that important?
 13746                                  ;
 13747                                  ;M048;	cmp	bx,BytCnt		; is memory full?
 13748                                  ;M048;	jne	PutZ
 13749                                  
 13750                                  		; MSDOS 3.3
 13751 00002E08 3B1E[A241]              		cmp	bx,[BYTCNT]	; is memory full?
 13752 00002E0C 7509                    		jne	short PUTZ
 13753                                  
 13754 00002E0E E8F200                  		call	TRYFLUSH	; flush (and double-check for concat)	
 13755 00002E11 7402                    		jz	short NOCONC
 13756                                  CONCHNG:
 13757 00002E13 F9                      		stc
 13758 00002E14 C3                      		retn
 13759                                  
 13760                                  NOCONC:	
 13761 00002E15 31DB                    		xor	bx,bx
 13762                                  PUTZ:
 13763 00002E17 1E                      		push	ds
 13764 00002E18 8E1E[8341]              		mov	ds,[TPA]
 13765 00002E1C C7071A00                		mov	word [bx],1Ah	; add EOF mark (ctrl-Z)
 13766 00002E20 1F                      		pop	ds
 13767 00002E21 FF06[A441]              		inc	word [NXTADD]	; make sure our ^z gets written	
 13768 00002E25 C606[9944]00            		mov	byte [NOWRITE],0
 13769 00002E2A A1[9B44]                		mov	ax,[WRITTEN]
 13770 00002E2D 0306[A441]              		add	ax,[NXTADD]
 13771 00002E31 7205                    		jc	short BINCLOS	; > 1
 13772 00002E33 83F801                  		cmp	ax,1
 13773 00002E36 740A                    		je	short FORGETITJ	; Written = 0 NxtAdd = 1 (the ^Z)
 13774                                  BINCLOS:
 13775 00002E38 E8C800                  		call	TRYFLUSH
 13776 00002E3B 75D6                    		jnz	short CONCHNG
 13777                                  
 13778 00002E3D 803E[9B44]00            		cmp	byte [WRITTEN],0
 13779                                  FORGETITJ:
 13780 00002E42 747D                    		jz	short FORGETIT	; never wrote nothing
 13781                                  NO_FORGET:				; wrote something
 13782 00002E44 8B1E[D843]              		mov	bx,[DESTHAND]
 13783 00002E48 8B0E[A344]              		mov	cx,[CPTIME]
 13784 00002E4C 8B16[A144]              		mov	dx,[CPDATE]
 13785 00002E50 803E[9744]00            		cmp	byte [INEXACT],0 ; copy not exact?
 13786 00002E55 7431                    		je	short DODCLOSE	; if no, copy date & time
 13787 00002E57 B42C                    		mov	ah,GET_TIME ; 2Ch
 13788 00002E59 CD21                    		int	21h		; DOS -	GET CURRENT TIME
 13789                                  					; Return: CH = hours,CL = minutes,DH = seconds
 13790                                  					; DL = hundredths of seconds
 13791 00002E5B D0E1                    		shl	cl,1
 13792 00002E5D D0E1                    		shl	cl,1		; left justify min in cl
 13793 00002E5F D1E1                    		shl	cx,1
 13794 00002E61 D1E1                    		shl	cx,1
 13795 00002E63 D1E1                    		shl	cx,1		; hours to high 5 bits, min to 5-10
 13796 00002E65 D0EE                    		shr	dh,1		; divide seconds by 2 (now 5 bits)
 13797 00002E67 08F1                    		or	cl,dh		; and stick into low 5 bits of cx
 13798 00002E69 51                      		push	cx		; save packed time
 13799 00002E6A B42A                    		mov	ah,GET_DATE ; 2Ah
 13800 00002E6C CD21                    		int	21h		; DOS -	GET CURRENT DATE
 13801                                  					; Return: DL = day,DH = month,	CX = year
 13802                                  					; AL = day of the week (0=Sunday,1=Monday,etc.)
 13803 00002E6E 81E9BC07                		sub	cx,1980
 13804 00002E72 86E9                    		xchg	ch,cl
 13805 00002E74 D1E1                    		shl	cx,1		; year to high 7 bits
 13806 00002E76 D0E6                    		shl	dh,1		; month to high 3 bits
 13807 00002E78 D0E6                    		shl	dh,1
 13808 00002E7A D0E6                    		shl	dh,1
 13809 00002E7C D0E6                    		shl	dh,1
 13810 00002E7E D0E6                    		shl	dh,1		; most sig bit of month in carry
 13811 00002E80 80D500                  		adc	ch,0		; put that bit next to year
 13812 00002E83 08F2                    		or	dl,dh		; or low three of month into day
 13813 00002E85 88EE                    		mov	dh,ch		; get year and high bit of month
 13814 00002E87 59                      		pop	cx
 13815                                  DODCLOSE:
 13816 00002E88 83FB00                  		cmp	bx,0
 13817 00002E8B 7E2A                    		jle	short CLOSEDONE
 13818 00002E8D B80157                  		mov	ax,(FILE_TIMES<<8)|1 ; 5701h
 13819 00002E90 CD21                    		int	21h		; DOS -	2+ - SET FILE'S DATE/TIME
 13820                                  					; BX = file handle,CX = time to be set
 13821                                  					; DX = date to be set
 13822                                  		; MSDOS 6.0
 13823                                  		;jc	Cleanup_Err	;AN022; handle error
 13824                                  
 13825                                  	;	See if the destination has *anything* in it.
 13826                                  	;	If not, just close and delete it.
 13827                                  
 13828 00002E92 B80242                  		mov	ax,(LSEEK<<8)+2 ; 4202h	; seek to EOF
 13829 00002E95 31D2                    		xor	dx,dx
 13830 00002E97 89D1                    		mov	cx,dx
 13831 00002E99 CD21                    		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 13832                                  					; AL = method: offset from end of file
 13833                                  	;	DX:AX is file size
 13834                                  
 13835 00002E9B 09C2                    		or	dx,ax
 13836 00002E9D 9C                      		pushf
 13837 00002E9E B80044                  		mov	ax,(IOCTL<<8)+0 ; 4400h	; get the destination attributes
 13838 00002EA1 CD21                    		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 13839                                  					; BX = file or device handle
 13840 00002EA3 52                      		push	dx			; save them away
 13841 00002EA4 B43E                    		mov	ah,CLOSE ; 3Eh
 13842 00002EA6 CD21                    		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 13843                                  					; BX = file handle
 13844 00002EA8 5A                      		pop	dx
 13845                                  
 13846                                  		; MSDOS 6.0
 13847                                  		;jnc	Close_Cont	;AN022; handle error on close
 13848                                  		;popf			;AN022; get the flags back
 13849                                  ;Cleanup_Err: 				;AN022;
 13850                                  		;call	CleanUpErr	;AN022; attempt to delete the target
 13851                                  		;call	DestDelete	;AN022; attempt to delete the target
 13852                                  		;jmp	short FileClosed ;AN022; close the file
 13853                                  ;Close_Cont:				;AN022; no error - co
 13854                                  		; MSDOS 3.3 (& MSDOS 6.0)
 13855 00002EA9 9D                      		popf
 13856 00002EAA 750B                    		jnz	short CLOSEDONE
 13857 00002EAC F7C28000                		test	dx,80h		; is the destination a device?
 13858 00002EB0 7505                    		jnz	short CLOSEDONE	; yes, copy succeeded
 13859 00002EB2 E81E00                  		call	DESTDELETE
 13860 00002EB5 EB04                    		jmp	short FILECLOSED
 13861                                  CLOSEDONE:
 13862 00002EB7 FF06[A941]              		inc	word [FILECNT]
 13863                                  FILECLOSED:
 13864 00002EBB FE06[A141]              		inc	byte [DESTCLOSED]
 13865                                  RET50:
 13866 00002EBF F8                      		clc
 13867 00002EC0 C3                      		retn
 13868                                  FORGETIT:
 13869 00002EC1 8B1E[D843]              		mov	bx,[DESTHAND]
 13870 00002EC5 E8C0FF                  		call	DODCLOSE	 ; close the dest	
 13871 00002EC8 E80800                  		call	DESTDELETE
 13872 00002ECB C706[A941]0000          		mov	word [FILECNT],0 ; no files transferred
 13873 00002ED1 EBEC                    		jmp	short RET50
 13874                                  
 13875                                  ; ---------------------------------------------------------------------------
 13876                                  
 13877                                  DESTDELETE:
 13878 00002ED3 BA[8143]                		mov	dx,DESTBUF
 13879 00002ED6 B441                    		mov	ah,UNLINK ; 41h
 13880 00002ED8 CD21                    		int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
 13881                                  				; DS:DX	-> ASCIZ pathname of file to delete 
 13882                                  				;		(no wildcards allowed)
 13883 00002EDA C3                      		retn
 13884                                  
 13885                                  ; ---------------------------------------------------------------------------
 13886                                  
 13887                                  SOURCE_SET:
 13888 00002EDB 56                      		push	si
 13889 00002EDC A1[A744]                		mov	ax,[STARTEL]
 13890 00002EDF BE[3E44]                		mov	si,SCANBUF	; adjust to copy
 13891 00002EE2 29F0                    		sub	ax,si
 13892 00002EE4 BF[E443]                		mov	di,SRCBUF
 13893 00002EE7 01F8                    		add	ax,di
 13894 00002EE9 A3[E143]                		mov	[SRCTAIL],ax
 13895 00002EEC 880E[E043]              		mov	[SRCSIZ],cl	; save its size
 13896 00002EF0 41                      		inc	cx		; include the nul
 13897 00002EF1 F3A4                    		rep movsb		; save this source
 13898 00002EF3 883E[E343]              		mov	[SRCINFO],bh	; save info about it
 13899 00002EF7 5E                      		pop	si
 13900 00002EF8 89E8                    		mov	ax,bp		; switches so far
 13901 00002EFA E86A01                  		call	SETASC		; set a,b switches accordingly
 13902 00002EFD E875EB                  		call	SWITCH		; get any more switches on this arg
 13903                                  		;call	SETASC		; set
 13904                                  		;retn
 13905                                  		; 02/03/2023
 13906 00002F00 E96401                  		jmp	SETASC
 13907                                  
 13908                                  ; =============== S U B	R O U T	I N E =======================================
 13909                                  
 13910                                  ; MSDOS 6.0
 13911                                  
 13912                                  ;****************************************************************
 13913                                  ;*
 13914                                  ;* ROUTINE:	CleanupErr
 13915                                  ;*
 13916                                  ;* FUNCTION:	Issues extended error message for destination
 13917                                  ;*		if not alreay issued
 13918                                  ;*
 13919                                  ;* INPUT:	return from INT 21
 13920                                  ;*
 13921                                  ;* OUTPUT:	none
 13922                                  ;*
 13923                                  ;****************************************************************
 13924                                  
 13925                                  ;CleanupErr	proc	near		;AN022;
 13926                                  ;
 13927                                  ;	cmp	Msg_Flag,0		;AN022; have we already issued a message?
 13928                                  ;	jnz	CleanupErr_Cont 	;AN022; yes - don't issue duplicate error
 13929                                  ;	invoke	Set_Ext_Error_Msg	;AN022; set up error message
 13930                                  ;	mov	String_Ptr_2,offset TRANGROUP:DestBuf 
 13931                                  ;					;AN022; get address of failed string
 13932                                  ;	mov	Extend_Buf_Sub,ONE_SUBST ;AN022; put number of subst in control block
 13933                                  ;	invoke	Std_EPrintF		;AN022; issue the error message
 13934                                  ;
 13935                                  ;CleanupErr_Cont:			;AN022;
 13936                                  ;	ret				;AN022; return to caller
 13937                                  ;
 13938                                  ;CleanupErr	endp			;AN022;
 13939                                  
 13940                                  ;============================================================================
 13941                                  ; COPYPR1.ASM, MSDOS 6.0, 1991
 13942                                  ;============================================================================
 13943                                  ; 01/10/2018 - Retro DOS v3.0
 13944                                  
 13945                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2FBBh
 13946                                  
 13947                                  ; =============== S U B	R O U T	I N E =======================================
 13948                                  
 13949                                  ;***	TryFlush - flush copy buffer, double-check for concatenation
 13950                                  ;
 13951                                  ;	EXIT	ZR set if concatenate flag unchanged
 13952                                  
 13953                                  TRYFLUSH:
 13954 00002F03 A0[9641]                		mov	al,[CONCAT]
 13955 00002F06 50                      		push	ax
 13956 00002F07 E80600                  		call	FLUSHFIL
 13957 00002F0A 58                      		pop	ax
 13958 00002F0B 3A06[9641]              		cmp	al,[CONCAT]
 13959 00002F0F C3                      		retn
 13960                                  
 13961                                  ; =============== S U B	R O U T	I N E =======================================
 13962                                  
 13963                                  FLUSHFIL:
 13964 00002F10 A0[9A44]                		mov	al,[BINARY]
 13965 00002F13 8A26[9E44]              		mov	ah,[ASCII]
 13966 00002F17 50                      		push	ax
 13967 00002F18 E80900                  		call	FLSHFIL
 13968 00002F1B 58                      		pop	ax
 13969 00002F1C 8826[9E44]              		mov	[ASCII],ah
 13970 00002F20 A2[9A44]                		mov	[BINARY],al
 13971 00002F23 C3                      		retn
 13972                                  
 13973                                  ; =============== S U B	R O U T	I N E =======================================
 13974                                  
 13975                                  ;***	Flshfil - write out any data remaining in copy buffer.
 13976                                  ;
 13977                                  ;	Inputs:
 13978                                  ;	  [NXTADD] = No. of bytes to write
 13979                                  ;	  [CFLAG] <> 0 if file has been created
 13980                                  ;	Outputs:
 13981                                  ;	  [NXTADD] = 0
 13982                                  
 13983                                  FLSHFIL:
 13984 00002F24 C606[9D44]00            		mov	byte [TERMREAD],0
 13985 00002F29 803E[A041]00            		cmp	byte [CFLAG],0
 13986 00002F2E 7403                    		jz	short NOTEXISTS
 13987 00002F30 E98300                  		jmp	EXISTS
 13988                                  
 13989                                  NOTEXISTS:
 13990 00002F33 E84B01                  		call	BUILDDEST	; find out all about the destination
 13991 00002F36 E82803                  		call	COMPNAME	; source and dest. the same?
 13992 00002F39 7516                    		jnz	short PROCDEST	; if not, go ahead
 13993 00002F3B 803E[3D44]00            		cmp	byte [SRCISDEV],0
 13994 00002F40 750F                    		jnz	short PROCDEST	; same name on device ok
 13995 00002F42 803E[9641]00            		cmp	byte [CONCAT],0	; concatenation?
 13996 00002F47 BA[C437]                		mov	dx,OVERWRPTR
 13997 00002F4A 745E                    		je	short COPERR	; not concatenating - overwrite error
 13998                                  		
 13999                                  ;No_Concat_Err:	; concatenating
 14000 00002F4C C606[9944]01            		mov	byte [NOWRITE],1 ; flag not writing (just seeking)
 14001                                  PROCDEST:
 14002                                  		; MSDOS 6.0
 14003                                  		;mov	ax,EXTOPEN shl 8		; open the file
 14004                                  		;mov	si,offset TRANGROUP:DestBuf	; get file name
 14005                                  ;M046
 14006                                  ; For writes, we want to deny writes by anyone else at the same time that we
 14007                                  ;are writing to it. For instance, on a network, 2 workstations could try
 14008                                  ;writing to the same file. Also, because we opened the source file with
 14009                                  ;DENY NONE, it is fine if the source and destination files are the same as
 14010                                  ;would happen when we append to an existing file.
 14011                                  ;
 14012                                  		;mov	bx,DENY_WRITE or WRITE_OPEN_MODE;get open mode for copy; M046
 14013                                  		;xor	cx,cx				; no special files
 14014                                  		;mov	dx,WRITE_OPEN_FLAG		; set up open flags
 14015                                  		;
 14016                                  		;cmp	NoWrite,0
 14017                                  		;jne	DoDestOpen		; don't actually create if nowrite set
 14018                                  		;mov	dx,CREAT_OPEN_FLAG	; set up create flags
 14019                                  
 14020 00002F51 B8013D                  		mov	ax,(OPEN*256)+1 ; 3D01h ; open file, write access
 14021 00002F54 803E[9944]00            		cmp	byte [NOWRITE],0
 14022 00002F59 7504                    		jne	short DODESTOPEN
 14023 00002F5B B43C                    		mov	ah,CREAT ; 3Ch
 14024 00002F5D 31C9                    		xor	cx,cx
 14025                                  DODESTOPEN:
 14026 00002F5F BA[8143]                		mov	dx,DESTBUF
 14027 00002F62 CD21                    		int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
 14028                                  				; CX = attributes for file
 14029                                  				; DS:DX	-> ASCIZ filename (may include drive and path)
 14030                                  		
 14031                                  		; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 301Ch
 14032                                  		;mov	dx,FULDIRPTR
 14033                                  		;call	GET_EXT_ERR_NUMBER
 14034                                  		;jc	short COPERR
 14035                                  
 14036                                  		; 01/10/2018
 14037                                  		;jnc	short DEST_OPEN_OKAY
 14038                                  		
 14039                                  		;mov	dx,FULDIRPTR
 14040                                  		;call	GET_EXT_ERR_NUMBER
 14041                                  		;jmp	short COPERR
 14042                                  
 14043 00002F64 723E                    		jc	short DEST_OPEN_ERROR
 14044                                  ;DEST_OPEN_OKAY:
 14045 00002F66 A3[D843]                		mov	[DESTHAND],ax	; save handle
 14046 00002F69 C606[A041]01            		mov	byte [CFLAG],1	; destination now exists
 14047 00002F6E 89C3                    		mov	bx,ax
 14048 00002F70 B80044                  		mov	ax,IOCTL*256 ; 4400h ; get device stuff
 14049 00002F73 CD21                    		int	21h	   	; DOS - 2+ - IOCTL - GET DEVICE INFORMATION
 14050                                  				   	; BX = file or device handle
 14051                                  
 14052 00002F75 8816[DA43]              		mov	[DESTISDEV],dl	; set dest info
 14053                                  		;test	dl,80h
 14054 00002F79 F6C280                  		test	dl,devid_ISDEV
 14055 00002F7C 7438                    		jz	short EXISTS	; Dest not a device
 14056                                  
 14057                                  ;	Destination is device.
 14058                                  
 14059 00002F7E A0[9C41]                		mov	al,[DESTSWITCH]
 14060                                  		;and	al,0Ch
 14061 00002F81 240C                    		and	al,SWITCHA+SWITCHB
 14062 00002F83 7509                    		jnz	short TESTBOTH
 14063 00002F85 A0[9E44]                		mov	al,[ASCII]	; neither set, use current setting
 14064 00002F88 0A06[9A44]              		or	al,[BINARY]
 14065 00002F8C 741E                    		jz	short EXSETA	; neither set, default to ascii
 14066                                  TESTBOTH:
 14067 00002F8E 7A26                    		jpe	short EXISTS	; both are set, ignore
 14068                                  		;test	al,8
 14069 00002F90 A808                    		test	al,SWITCHB
 14070 00002F92 7422                    		jz	short EXISTS
 14071                                  		;mov	ax,(IOCTL shl 8) or 1
 14072 00002F94 B80144                  		mov	ax,(IOCTL<<8)|1 ; 4401h
 14073 00002F97 30F6                    		xor	dh,dh
 14074                                  		;or	dl,20h
 14075 00002F99 80CA20                  		or	dl,devid_RAW
 14076 00002F9C 8816[DA43]              		mov	[DESTISDEV],dl
 14077 00002FA0 CD21                    		int	21h	; DOS -	2+ - IOCTL - SET DEVICE	INFORMATION
 14078                                  				; BX = device handle,DH = 0
 14079                                  				; DL = device information to set (bits 0-7 from	function 0)
 14080 00002FA2 EB12                    		jmp	short EXISTS
 14081                                  
 14082                                  		; 01/10/2018 - Retro DOS v3.0 modification
 14083                                  DEST_OPEN_ERROR:
 14084 00002FA4 BA[9E37]                		mov	dx,FULDIRPTR
 14085 00002FA7 E8CFEE                  		call	GET_EXT_ERR_NUMBER
 14086                                  COPERR:
 14087 00002FAA EB7C                    		jmp	short COPYERR
 14088                                  
 14089                                  EXSETA:
 14090                                  ;	What we read in may have been in binary mode, flag zapped write OK
 14091                                  
 14092                                  		;mov	byte [ASCII],4
 14093 00002FAC C606[9E44]04            		mov	byte [ASCII],SWITCHA	; set ascii mode
 14094                                  		;or	byte [INEXACT],4
 14095 00002FB1 800E[9744]04            		or	byte [INEXACT],SWITCHA	; ascii -> inexact
 14096                                  EXISTS:
 14097 00002FB6 803E[9944]00            		cmp	byte [NOWRITE],0
 14098 00002FBB 7524                    		jnz	short NOCHECKING	; if nowrite don't bother with name check
 14099 00002FBD 803E[D742]01            		cmp	byte [PLUS_COMMA],1	; don't check if just doing +,,
 14100 00002FC2 741D                    		jz	short NOCHECKING
 14101 00002FC4 E89A02                  		call	COMPNAME		; source and dest. the same?
 14102 00002FC7 7518                    		jnz	short NOCHECKING	; if not, go ahead
 14103 00002FC9 803E[3D44]00            		cmp	byte [SRCISDEV],0
 14104 00002FCE 7511                    		jne	short NOCHECKING	; same name on device ok
 14105                                  
 14106                                  ;	At this point we know in append (would have gotten overwrite error
 14107                                  ;	on first destination create otherwise), and user trying to specify
 14108                                  ;	destination which has been scribbled already (if dest had been named
 14109                                  ;	first, NoWrite would be set).
 14110                                  
 14111 00002FD0 BA[F037]                		mov	dx,LOSTERRPTR		; tell him he's not going to get it
 14112                                  		;invoke	Std_EprintF		;ac022;
 14113 00002FD3 E85204                  		call	STD_PRINTF
 14114 00002FD6 C706[A441]0000          		mov	word [NXTADD],0		; set return
 14115 00002FDC FE06[9D44]              		inc	byte [TERMREAD]		; tell read to give up
 14116                                  RET60:
 14117 00002FE0 C3                      		retn
 14118                                  
 14119                                  NOCHECKING:
 14120 00002FE1 8B1E[D843]              		mov	bx,[DESTHAND]		; get handle
 14121 00002FE5 31C9                    		xor	cx,cx
 14122 00002FE7 870E[A441]              		xchg	cx,[NXTADD]
 14123 00002FEB E3F3                    		jcxz	RET60			; if nothing to write, forget it
 14124 00002FED FF06[9B44]              		inc	word [WRITTEN]		; flag that we wrote something
 14125 00002FF1 803E[9944]00            		cmp	byte [NOWRITE],0	; if nowrite set, just seek cx bytes
 14126 00002FF6 755A                    		jnz	short SEEKEND
 14127 00002FF8 31D2                    		xor	dx,dx
 14128 00002FFA 1E                      		push	ds
 14129 00002FFB 8E1E[8341]              		mov	ds,[TPA]
 14130 00002FFF B440                    		mov	ah,WRITE ; 40h
 14131 00003001 CD21                    		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 14132                                  					; BX = file handle,CX = number	of bytes to write,DS:DX -> buffer
 14133 00003003 1F                      		pop	ds
 14134 00003004 BA[6937]                		mov	dx,NOSPACEPTR
 14135 00003007 7222                    		jc	short COPERRP		; failure
 14136 00003009 29C1                    		sub	cx,ax
 14137 0000300B 74D3                    		jz	short RET60		; wrote all supposed to
 14138 0000300D F606[DA43]80            		test	byte [DESTISDEV],devid_ISDEV ;80h
 14139 00003012 7414                    		jz	short COPYERR		; is a file, error
 14140 00003014 F606[DA43]20            		test	byte [DESTISDEV],devid_RAW ; 20h
 14141 00003019 750A                    		jnz	short DEVWRTERR		; is a raw device, error
 14142 0000301B 803E[9744]00            		cmp	byte [INEXACT],0
 14143 00003020 75BE                    		jnz	short RET60		; inexact so ok
 14144 00003022 49                      		dec	cx
 14145                                  RETZ60:
 14146 00003023 74BB                    		jz	short RET60		; wrote one byte less (the ^z)		
 14147                                  
 14148                                  DEVWRTERR:
 14149 00003025 BA[B93C]                		mov	dx,DEVWMESPTR
 14150                                  
 14151                                  COPYERR:
 14152                                  		;invoke	Std_EPrintF		;AC022;
 14153 00003028 E8FD03                  		call	STD_PRINTF
 14154                                  COPERRP:
 14155 0000302B FE06[A141]              		inc	byte [DESTCLOSED]
 14156 0000302F 803E[A041]00            		cmp	byte [CFLAG],0
 14157 00003034 7419                    		jz	short ENDCOPYJ		; never actually got it open
 14158 00003036 8B1E[D843]              		mov	bx,[DESTHAND]
 14159 0000303A 83FB00                  		cmp	bx,0
 14160 0000303D 7E04                    		jle	short NOCLOSE
 14161                                  
 14162                                  ;	Check to see if we should save part of the destination file.
 14163                                  
 14164                                  		; MSDOS 6.0
 14165                                  		;mov	cx,OFilePtr_Hi		; CX = hi word of original file ptr
 14166                                  		;mov	dx,OFilePtr_Lo		; DX = lo word of original file ptr
 14167                                  			
 14168                                  		;mov	ax,cx
 14169                                  		;or	ax,dx
 14170                                  		;jz	ceClose			; null file ptr means nothing to save
 14171                                  
 14172                                  ;	Destination was also the first source.  Do the best we can to
 14173                                  ;	restore it.  Truncate it back to the size we took from it (which
 14174                                  ;	may have been due to a Ctrl-Z, so may not have included the whole
 14175                                  ;	file).  If a Ctrl-Z was originally read, put it back.
 14176                                  
 14177                                  		;mov	ax,LSEEK shl 8
 14178                                  		;int	21h
 14179                                  
 14180                                  		;xor	cx,cx			; CX = # bytes to write = 0
 14181                                  		;mov	ah,WRITE
 14182                                  		;int	21h			; truncate file
 14183                                  
 14184                                  		;cmp	OCtrlZ,0
 14185                                  		;je	@f			; no ctrl-z removed from original
 14186                                  		;inc	cx			; CX = # bytes to write = 1
 14187                                  		;mov	dx,offset TRANGROUP:OCtrlZ  ; DS:DX = ptr to original ctrl-z
 14188                                  		;mov	ah,WRITE
 14189                                  		;int	21h			; write ctrl-z
 14190                                  ;@@:
 14191                                  		;mov	ah,CLOSE
 14192                                  		;int	21h			; close it
 14193                                  ;;		;mov	CFlag,0
 14194                                  		;jmp	EndCopy			; and go home
 14195                                  
 14196                                  		; MSDOS 3.3 (& MSDOS 6.0)
 14197                                  CECLOSE:
 14198 0000303F B43E                    		mov	ah,CLOSE ; 3Eh		; close the file
 14199 00003041 CD21                    		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 14200                                  					; BX = file handle
 14201                                  NOCLOSE:
 14202 00003043 BA[8143]                		mov	dx,DESTBUF
 14203 00003046 B441                    		mov	ah,UNLINK ; 41h 	; and delete it
 14204 00003048 CD21                    		int	21h		; DOS -	2+ - DELETE A FILE (UNLINK)
 14205                                  					; DS:DX	-> ASCIZ pathname of file to delete (no	wildcards allowed)
 14206 0000304A C606[A041]00            		mov	byte [CFLAG],0
 14207                                  ENDCOPYJ:
 14208 0000304F E900FB                  		jmp	ENDCOPY
 14209                                  
 14210                                  SEEKEND:
 14211 00003052 31D2                    		xor	dx,dx
 14212 00003054 87D1                    		xchg	dx,cx
 14213                                  		;mov	ax,(LSEEK shl 8) or 1
 14214 00003056 B80142                  		mov	ax,(LSEEK<<8)|1 ; 4201h
 14215 00003059 CD21                    		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 14216                                  					; AL = method: offset from present location
 14217 0000305B 803E[9441]00            		cmp	byte [RDEOF],0
 14218 00003060 74C1                    		jz	short RETZ60
 14219                                  
 14220                                  ;	^Z has been read - we must set the file size to the current
 14221                                  ;	file pointer location
 14222                                  
 14223 00003062 B440                    		mov	ah,WRITE ; 40h
 14224 00003064 CD21                    		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 14225                                  					; BX = file handle,CX = number	of bytes to write,DS:DX -> buffer
 14226                                  
 14227                                  		; MSDOS 6.0
 14228                                  		;jc	Xa_Set_Error_Jmp	;AC022; failure
 14229                                  
 14230                                  ;	Make note that ^Z was removed, in case the
 14231                                  ;	copy should fail and we need to restore the file.
 14232                                  
 14233                                  		;mov	OCtrlZ,1Ah
 14234                                  
 14235 00003066 C3                      		retn
 14236                                  
 14237                                  ;============================================================================
 14238                                  ; COPYPR2.ASM, MSDOS 6.0, 1991
 14239                                  ;============================================================================
 14240                                  ; 01/10/2018 - Retro DOS v3.0
 14241                                  
 14242                                  ; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 311Fh
 14243                                  
 14244                                  ; =============== S U B	R O U T	I N E =======================================
 14245                                  
 14246                                  ;***	SetAsc - set Ascii, Binary, Inexact flags based on switches
 14247                                  ;
 14248                                  ;	Given switch vector in AX,
 14249                                  ;	  Set Ascii flag if /a is set
 14250                                  ;	  Clear Ascii flag if /b is set
 14251                                  ;	  Binary set if /b specified
 14252                                  ;	  Leave Ascii unchanged if neither or both are set
 14253                                  ; 	Also sets Inexact if Ascii is ever set. 
 14254                                  ;	AL = Ascii on exit, flags set
 14255                                  
 14256                                  SETASC:
 14257 00003067 240C                    		and	al,SWITCHA+SWITCHB ; 0Ch ; AL = /a, /b flags
 14258 00003069 7A10                    		jpe	short LOADSW	; even parity - both or neither
 14259 0000306B 50                      		push	ax
 14260 0000306C 2408                    		and	al,SWITCHB  ; 8
 14261 0000306E A2[9A44]                		mov	[BINARY],al
 14262 00003071 58                      		pop	ax
 14263 00003072 2404                    		and	al,4
 14264 00003074 A2[9E44]                		mov	[ASCII],al
 14265 00003077 0806[9744]              		or	[INEXACT],al
 14266                                  LOADSW:
 14267 0000307B A0[9E44]                		mov	al,[ASCII]
 14268 0000307E 08C0                    		or	al,al
 14269 00003080 C3                      		retn
 14270                                  
 14271                                  ; =============== S U B	R O U T	I N E =======================================
 14272                                  
 14273                                  BUILDDEST:
 14274 00003081 803E[7C43]FF            		cmp	byte [DESTISDIR],-1 ; 0FFh
 14275 00003086 750C                    		jnz	short KNOWABOUTDEST	; figuring already done
 14276 00003088 BF[6340]                		mov	di,USERDIR1
 14277 0000308B BD[7C43]                		mov	bp,DESTVARS
 14278 0000308E E8DE00                  		call	BUILDPATH
 14279 00003091 E8CCE7                  		call	RESTUDIR1
 14280                                  
 14281                                  ;	We now know all about the destination
 14282                                  
 14283                                  KNOWABOUTDEST:
 14284 00003094 30C0                    		xor	al,al
 14285 00003096 8606[DB43]              		xchg	al,[FIRSTDEST]
 14286 0000309A 08C0                    		or	al,al
 14287 0000309C 7503                    		jnz	short FIRSTDST
 14288 0000309E E98A00                  		jmp	NOFIRSTDEST
 14289                                  FIRSTDST:
 14290                                  
 14291                                  ;	Create an fcb of the original dest.
 14292                                  
 14293 000030A1 8B36[7E43]              		mov	si,[DESTTAIL]
 14294 000030A5 BF[3742]                		mov	di,DESTFCB
 14295 000030A8 B80029                  		mov	ax,PARSE_FILE_DESCRIPTOR*256 ; 2900h
 14296 000030AB CD21                    		int	21h		; DOS -	PARSE FILENAME
 14297                                  					; DS:SI	-> string to parse
 14298                                  					; ES:DI	-> buffer to fill with unopened	FCB
 14299                                  					; AL = bit mask	to control parsing
 14300 000030AD 803C00                  		cmp	byte [si],0
 14301 000030B0 7404                    		jz	short GOODPARSE
 14302 000030B2 C645017C                		mov	byte [di+1],'|'
 14303                                  		; MSDOS 6.0
 14304                                  	;;AD052; mov	byte ptr [di+1],"|"	; must be illegal file name character
 14305                                  		;mov	dx,offset TRANGROUP:FulDir_Ptr	;AN052; issue "file creation error"
 14306                                  		;jmp	CopErr				;AN052;
 14307                                  GOODPARSE:
 14308 000030B6 A1[8143]                		mov	ax,[DESTBUF]		; AX = possible "d:"
 14309 000030B9 80FC3A                  		cmp	ah,':'
 14310 000030BC 7402                    		jz	short DRVSPEC4
 14311 000030BE B040                    		mov	al,'@'
 14312                                  DRVSPEC4:
 14313                                  
 14314                                  ;	AX = "d:" for following FCB drive computation
 14315                                  
 14316 000030C0 8A0E[9E44]              		mov	cl,[ASCII]		; CL = saved Ascii flag
 14317 000030C4 0C20                    		or	al,20h
 14318 000030C6 2C60                    		sub	al,60h
 14319 000030C8 A2[3742]                		mov	[DESTFCB],al		; store drive # in FCB
 14320                                  
 14321                                  ;*	Figure out what copy mode we're in.
 14322                                  ;	Letters stand for unambiguous, * for ambiguous pathnames.
 14323                                  ;	+n stands for additional sources delimited by +'s.
 14324                                  ;
 14325                                  ;	copy a b	not concatenating
 14326                                  ;	copy a *	not concatenating
 14327                                  ;	copy * a	concatenating
 14328                                  ;	copy * *	not concatenating
 14329                                  ;	copy a+n b	concatenating
 14330                                  ;	copy *+n a	concatenating
 14331                                  ;	copy *+n *	concatenating, Mel Hallerman style
 14332                                  
 14333                                  ;	Bugbug:  copy *.a+a.b *.t  picks up only 1st *.a file.. Why?
 14334                                  ;		 copy a.b+*.a *.t  picks up all *.a files.
 14335                                  
 14336 000030CB A0[8043]                		mov	al,[DESTINFO]	; AL = destination CParse flags
 14337 000030CE 8A26[E343]              		mov	ah,[SRCINFO]	; AH = source CParse flags
 14338 000030D2 250202                  		and	ax,202h		; AH,AL = source,dest wildcard flags
 14339 000030D5 08C0                    		or	al,al
 14340 000030D7 7413                    		jz	short NOTMELCOPY ; no destination wildcard
 14341                                  
 14342                                  ;	Destination is wildcarded.
 14343                                  	
 14344 000030D9 38E0                    		cmp	al,ah
 14345 000030DB 750F                    		jnz	short NOTMELCOPY ; no source wildcard
 14346                                  
 14347                                  ;	Source and destination are both wildcarded.
 14348                                  
 14349 000030DD 803E[9F44]00            		cmp	byte [PLUS],0
 14350 000030E2 7408                    		jz	short NOTMELCOPY ; no +'s in source
 14351                                  
 14352                                  ;	Source and destination are wildcarded, and source includes +'s.
 14353                                  ;	It's Mel Hallorman copy time.
 14354                                  
 14355 000030E4 FE06[DC43]              		inc	byte [MELCOPY]	; 'Mel copy' = true
 14356 000030E8 30C0                    		xor	al,al
 14357 000030EA EB06                    		jmp	short SETCONC
 14358                                  
 14359                                  NOTMELCOPY:
 14360 000030EC 3402                    		xor	al,2	; AL=0 -> ambiguous destination, 2 otherwise
 14361 000030EE 20E0                    		and	al,ah
 14362 000030F0 D0E8                    		shr	al,1	; AL=1 -> ambiguous source, unambiguous dest
 14363                                  				;   (implies concatenation)
 14364                                  SETCONC:
 14365 000030F2 0A06[9F44]              		or	al,[PLUS]	; "+" always infers concatenation
 14366                                  
 14367                                  ;	Whew. AL = 1 if concatenating, 0 if not.
 14368                                  
 14369 000030F6 A2[9641]                		mov	[CONCAT],al
 14370 000030F9 D0E0                    		shl	al,1
 14371 000030FB D0E0                    		shl	al,1
 14372 000030FD A2[9744]                		mov	[INEXACT],al	; concatenation -> inexact copy
 14373 00003100 803E[9A44]00            		cmp	byte [BINARY],0
 14374 00003105 7524                    		jne	short NOFIRSTDEST ; explicit binary copy	
 14375                                  
 14376 00003107 A2[9E44]                		mov	[ASCII],al	; otherwise, concatenate in ascii mode	
 14377 0000310A 08C9                    		or	cl,cl
 14378 0000310C 751D                    		jnz	short NOFIRSTDEST ; Ascii flag set before, data read correctly	
 14379 0000310E 08C0                    		or	al,al
 14380 00003110 7419                    		jz	short NOFIRSTDEST ; Ascii flag did not change state
 14381                                  
 14382                                  ;	At this point there may already be binary read data in the read
 14383                                  ;	buffer. We need to find the first ^Z (if there is one) and trim the
 14384                                  ;	amount of data in the buffer correctly.
 14385                                  
 14386 00003112 8B0E[A441]              		mov	cx,[NXTADD]
 14387 00003116 E313                    		jcxz	NOFIRSTDEST	; no data, everything ok
 14388 00003118 B01A                    		mov	al,1Ah
 14389 0000311A 06                      		push	es
 14390 0000311B 31FF                    		xor	di,di
 14391 0000311D 8E06[8341]              		mov	es,[TPA]
 14392 00003121 F2AE                    		repne scasb		; scan for EOF
 14393 00003123 07                      		pop	es
 14394 00003124 7505                    		jnz	short NOFIRSTDEST ; no ^z in buffer, everything ok
 14395 00003126 4F                      		dec	di		; point at ^z
 14396 00003127 893E[A441]              		mov	[NXTADD],di	; new buffer length
 14397                                  
 14398                                  NOFIRSTDEST:
 14399 0000312B BB[7B42]                		mov	bx,DIRBUF+1	; Source of replacement chars
 14400 0000312E 803E[9641]00            		cmp	byte [CONCAT],0
 14401 00003133 7403                    		jz	short GOTCHRSRC	; Not a concat
 14402 00003135 BB[C142]                		mov	bx,SDIRBUF+1	; Source of replacement chars
 14403                                  GOTCHRSRC:
 14404 00003138 BE[3842]                		mov	si,DESTFCB+1	; Original dest name
 14405 0000313B 8B3E[7E43]              		mov	di,[DESTTAIL]	; Where to put result
 14406                                  
 14407                                  ; --------------- S U B	R O U T	I N E --------------------------------------- 
 14408                                  
 14409                                  BUILDNAME:
 14410 0000313F B90800                  		mov	cx,8
 14411                                  BUILDMAIN:
 14412 00003142 AC                      		lodsb
 14413 00003143 3C3F                    		cmp	al,'?'
 14414 00003145 7502                    		jnz	short NOTAMBIG
 14415 00003147 8A07                    		mov	al,[bx]
 14416                                  NOTAMBIG:
 14417 00003149 3C20                    		cmp	al,' '
 14418 0000314B 7401                    		jz	short NOSTORE
 14419 0000314D AA                      		stosb
 14420                                  NOSTORE:
 14421 0000314E 43                      		inc	bx
 14422 0000314F E2F1                    		loop	BUILDMAIN
 14423 00003151 B103                    		mov	cl,3
 14424 00003153 B020                    		mov	al,' '
 14425 00003155 3804                    		cmp	[si],al
 14426 00003157 7412                    		jz	short ENDDEST	; No extension
 14427                                  		;mov	al,[DOT_CHR]
 14428                                  		; 01/03/2023
 14429 00003159 B02E                    		mov	al,dot_chr ; mov al,'.'
 14430 0000315B AA                      		stosb
 14431                                  BUILDEXT:
 14432 0000315C AC                      		lodsb
 14433 0000315D 3C3F                    		cmp	al,'?'
 14434 0000315F 7502                    		jnz	short NOTAMBIGE
 14435 00003161 8A07                    		mov	al,[bx]
 14436                                  NOTAMBIGE:
 14437 00003163 3C20                    		cmp	al,' '
 14438 00003165 7401                    		jz	short NOSTOREE
 14439 00003167 AA                      		stosb
 14440                                  NOSTOREE:
 14441 00003168 43                      		inc	bx
 14442 00003169 E2F1                    		loop	BUILDEXT
 14443                                  ENDDEST:
 14444 0000316B 30C0                    		xor	al,al
 14445 0000316D AA                      		stosb			; NUL terminate
 14446 0000316E C3                      		retn
 14447                                  
 14448                                  ; =============== S U B	R O U T	I N E =======================================
 14449                                  
 14450                                  BUILDPATH:
 14451 0000316F F6460402                		test	byte [bp+VARSTRUC.INFO],2  ; test byte [bp+4],2
 14452 00003173 7522                    		jnz	short NOTPFILE	; If ambig don't bother with open
 14453 00003175 89EA                    		mov	dx,bp		; Set DX to spec
 14454 00003177 83C205                  		add	dx,VARSTRUC.BUF ; add dx,5
 14455                                  
 14456                                  		; MSDOS 6.0
 14457                                  		;push	di				;AN000;
 14458                                  		;mov	ax,EXTOPEN SHL 8		;AC000; open the file
 14459                                  		;mov	bx,DENY_NONE or READ_OPEN_MODE	; open mode for COPY ;M046
 14460                                  		;xor	cx,cx				;AN000; no special files
 14461                                  		;mov	si,dx				;AN030; get file name offset
 14462                                  		;mov	dx,read_open_flag		;AN000; set up open flags
 14463                                  		;INT	21h
 14464                                  		;pop	di				;AN000;
 14465                                  		;jnc	pure_file			;AN022; is pure file
 14466                                  		;invoke	get_ext_error_number		;AN022; get the extended error
 14467                                  		;cmp	ax,error_file_not_found 	;AN022; if file not found - okay
 14468                                  		;jz	notpfile			;AN022;
 14469                                  		;cmp	ax,error_path_not_found 	;AN022; if path not found - okay
 14470                                  		;jz	notpfile			;AN022;
 14471                                  		;cmp	ax,error_access_denied		;AN022; if access denied - okay
 14472                                  		;jz	notpfile			;AN022;
 14473                                  		;jmp	extend_setup			;AN022; exit with error
 14474                                  ;pure_file:
 14475                                  		; MSDOS 3.3
 14476 0000317A B8003D                  		mov	ax,OPEN*256 ; 3D00h
 14477 0000317D CD21                    		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 14478                                  					; DS:DX	-> ASCIZ filename
 14479                                  					; AL = access mode
 14480                                  					; 0 - read
 14481 0000317F 7216                    		jc	short NOTPFILE
 14482                                  ;PURE_FILE:
 14483 00003181 89C3                    		mov	bx,ax
 14484 00003183 B80044                  		mov	ax,IOCTL*256 ; 4400h
 14485 00003186 CD21                    		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 14486                                  					; BX = file or device handle
 14487 00003188 B43E                    		mov	ah,CLOSE ;3Eh
 14488 0000318A CD21                    		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 14489                                  					; BX = file handle
 14490 0000318C F6C280                  		test	dl,devid_ISDEV ; test dl, 80h
 14491 0000318F 7545                    		jnz	short ISADEV
 14492 00003191 F6460404                		test	byte [bp+VARSTRUC.INFO],4 ; test byte [bp+4],4
 14493 00003195 743F                    		jz	short ISADEV
 14494                                  
 14495                                  NOTPFILE:
 14496 00003197 8B5605                  		mov	dx,[bp+VARSTRUC.BUF] ; mov dx,[bp+5]
 14497                                  		
 14498                                  		;MSDOS 6.0
 14499                                  		;cmp	dl,0		     	;AN034; If no drive specified, get
 14500                                  		;je	short SET_DRIVE_SPEC	;AN034;    default drive dir
 14501                                  
 14502 0000319A 80FE3A                  		cmp	dh,':'
 14503 0000319D 7402                    		je	short DRVSPEC5
 14504                                  SET_DRIVE_SPEC:
 14505 0000319F B240                    		mov	dl,'@'
 14506                                  
 14507                                  DRVSPEC5:
 14508 000031A1 80CA20                  		or	dl,20h
 14509 000031A4 80EA60                  		sub	dl,60h		; A = 1
 14510 000031A7 E86CE7                  		call	SAVUDIR1
 14511                                  	
 14512                                  		; MSDOS 6.0
 14513                                  		;jnc	short curdir_ok		;AN022; if error - exit
 14514                                  		;invoke	get_ext_error_number	;AN022; get the extended error
 14515                                  		;jmp	extend_setup		;AN022; exit with error
 14516                                  CURDIR_OK:
 14517 000031AA 89EA                    		mov	dx,bp
 14518                                  		;add	dx,5
 14519 000031AC 83C205                  		add	dx,VARSTRUC.BUF		; Set DX for upcomming CHDIRs
 14520                                  		;mov	bh,[bp+4]
 14521 000031AF 8A7E04                  		mov	bh,[bp+VARSTRUC.INFO]
 14522 000031B2 80E706                  		and	bh,6
 14523 000031B5 80FF06                  		cmp	bh,6			; Ambig and path ?
 14524 000031B8 7517                    		jne	short CHECKAMB		; jmp if no
 14525                                  		;mov	si,[bp+2]
 14526 000031BA 8B7602                  		mov	si,[bp+VARSTRUC.TTAIL]
 14527 000031BD B33A                    		mov	bl,':'
 14528 000031BF 385CFE                  		cmp	[si-2],bl
 14529 000031C2 7506                    		jne	short KNOWNOTSPEC
 14530                                  		;mov	byte [bp+VARSTRUC.ISDIR],2 ; Know is d:/file
 14531                                  		;mov	byte [bp+0],2
 14532 000031C4 C6460002                		mov	byte [bp],2
 14533 000031C8 EB05                    		jmp	short DOPCDJ
 14534                                  KNOWNOTSPEC:
 14535                                  		;mov	byte [bp+VARSTRUC.ISDIR],1 ; Know is path/file
 14536                                  		;mov	byte [bp+0],1		
 14537 000031CA C6460001                		mov	byte [bp],1
 14538 000031CE 4E                      		dec	si
 14539                                  DOPCDJ:
 14540 000031CF EB5C                    		jmp	short DOPCD
 14541                                  CHECKAMB:
 14542 000031D1 80FF02                  		cmp	bh,2
 14543 000031D4 7505                    		jnz	short CHECKCD
 14544                                  ISSIMPFILE:
 14545                                  ISADEV:
 14546                                  		;mov	byte [bp+VARSTRUC.ISDIR],0
 14547                                  		;mov	byte [bp+0],0		
 14548 000031D6 C6460000                		mov	byte [bp],0
 14549                                  NOTPDIR_RETN:	; 02/03/2023
 14550 000031DA C3                      		retn
 14551                                  
 14552                                  CHECKCD:
 14553 000031DB E8DBEC                  		call	SETREST1
 14554 000031DE B43B                    		mov	ah,CHDIR ; 3Bh
 14555 000031E0 CD21                    		int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 14556                                  					; DS:DX	-> ASCIZ directory name	(may include drive)
 14557 000031E2 7221                    		jb	short NOTPDIR
 14558 000031E4 89D7                    		mov	di,dx
 14559 000031E6 31C0                    		xor	ax,ax
 14560 000031E8 89C1                    		mov	cx,ax
 14561 000031EA 49                      		dec	cx
 14562 000031EB F2AE                    		repne scasb
 14563                                  DONE:
 14564 000031ED 4F                      		dec	di
 14565 000031EE A0[8641]                		mov	al,[DIRCHAR]
 14566                                  		;mov	byte [bp+VARSTRUC.ISDIR],2 ; assume d:/file
 14567                                  		;mov	byte [bp+0],2
 14568 000031F1 C6460002                		mov	byte [bp],2
 14569 000031F5 3A45FF                  		cmp	al,[di-1]
 14570 000031F8 7405                    		jz	short GOTSRCSLSH
 14571                                  _STORE_PCHAR:
 14572 000031FA AA                      		stosb
 14573                                  		;mov	byte [bp+VARSTRUC.ISDIR],1 ; know path/file
 14574                                  		;mov	byte [bp+0],1
 14575 000031FB C6460001                		mov	byte [bp],1
 14576                                  GOTSRCSLSH:
 14577                                  		;or	byte [bp+4],6
 14578 000031FF 804E0406                		or 	byte [bp+VARSTRUC.INFO],6 
 14579                                  		;call	SETSTARS
 14580                                  		; 02/03/2023
 14581 00003203 EB40                    		jmp	SETSTARS
 14582                                  ;NOTPDIR_RETN:
 14583                                  		;retn
 14584                                  
 14585                                  NOTPDIR:
 14586                                  		; MSDOS 6.0
 14587                                  		;invoke	get_ext_error_number	;AN022; get the extended error
 14588                                  		;cmp	ax,error_path_not_found ;AN022; if path not found - okay
 14589                                  		;jz	notpdir_try		;AN022;
 14590                                  		;cmp	ax,error_access_denied	;AN022; if access denied - okay
 14591                                  		;jnz	extend_setupj		;AN022; otherwise - exit error
 14592                                  ;notpdir_try:
 14593                                  		; MSDOS 3.3 (& MSDOS 6.0)
 14594                                  		;mov	byte [bp+VARSTRUC.ISDIR],0
 14595                                  		;mov	byte [bp+0],0
 14596 00003205 C6460000                		mov	byte [bp],0
 14597                                  		;mov	bh,[bp+4]
 14598 00003209 8A7E04                  		mov	bh,[bp+VARSTRUC.INFO]
 14599 0000320C F6C704                  		test	bh,4
 14600 0000320F 74C9                    		jz	short NOTPDIR_RETN	; Know pure file, no path seps
 14601                                  		;mov	byte [bp+VARSTRUC.ISDIR],2 ; assume d:/file
 14602                                  		;mov	byte [bp+0],2		
 14603 00003211 C6460002                		mov	byte [bp],2
 14604                                  		;mov	si,[bp+2]
 14605 00003215 8B7602                  		mov	si,[bp+VARSTRUC.TTAIL]
 14606 00003218 803C00                  		cmp	byte [si],0
 14607 0000321B 7424                    		je	short BADCDERRJ2	; Trailing '/'	
 14608                                  		;;mov	bl,[DOT_CHR]
 14609                                  		; 01/03/2023
 14610                                  		;mov	bl,dot_chr  ; mov bl,'.'
 14611                                  		;cmp	[si],bl
 14612 0000321D 803C2E                  		cmp	byte [si],dot_chr ; '.'
 14613 00003220 741F                    		je	short BADCDERRJ2	; If . or .. pure cd should have worked
 14614                                  		;mov	bl,':'
 14615                                  		;cmp	[si-2],bl
 14616                                  		; 01/03/2023
 14617 00003222 807CFE3A                		cmp	byte [si-2],':'
 14618 00003226 7405                    		je	short DOPCD		   ; Know d:/file
 14619                                  		;mov	byte [bp+VARSTRUC.ISDIR],1 ; Know path/file
 14620                                  		;mov	byte [bp+0],1
 14621 00003228 C6460001                		mov	byte [bp],1
 14622 0000322C 4E                      		dec	si			; Point at last '/'
 14623                                  DOPCD:
 14624 0000322D 30DB                    		xor	bl,bl
 14625 0000322F 861C                    		xchg	bl,[si]			; Stick in a NUL
 14626 00003231 E885EC                  		call	SETREST1
 14627 00003234 3A5CFF                  		cmp	bl,[si-1]		; if double slash, then complain.
 14628 00003237 7408                    		je	short BADCDERRJ2
 14629 00003239 B43B                    		mov	ah,CHDIR ; 3Bh
 14630 0000323B CD21                    		int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 14631                                  					; DS:DX	-> ASCIZ directory name	(may include drive)
 14632 0000323D 861C                    		xchg	bl,[si]
 14633 0000323F 7399                    		jnc	short NOTPDIR_RETN
 14634                                  		
 14635                                  		; MSDOS 3.3
 14636                                  BADCDERRJ2:
 14637 00003241 F9                      		stc
 14638 00003242 E97FDF                  		jmp	BADCDERR
 14639                                  
 14640                                  		; MSDOS 6.0
 14641                                  		;invoke	get_ext_error_number	;AN022; get the extended error
 14642                                  ;EXTEND_SETUPJ:					;AN022;
 14643                                  		;JMP	EXTEND_SETUP		;AN022; go issue the error message
 14644                                  ;BADCDERRJ2:
 14645                                  		;jmp	badpath_err		;AC022; go issue path not found message
 14646                                  
 14647                                  ; =============== S U B	R O U T	I N E =======================================
 14648                                  
 14649                                  SETSTARS:
 14650                                  		;mov	[bp+2],di
 14651 00003245 897E02                  		mov	[bp+VARSTRUC.TTAIL],di
 14652                                  		;add	byte [bp+1],12
 14653 00003248 8046010C                		add	byte [bp+VARSTRUC.SIZ],12
 14654                                  		;mov	ax,[DOT_QMARK] ; '?.' (2E3Fh)
 14655                                  		; 01/03/2023
 14656 0000324C B83F2E                  		mov	ax,dot_qmark ; '?.' (mov ax,2E3Fh)
 14657 0000324F B90800                  		mov	cx,8
 14658 00003252 F3AA                    		rep stosb
 14659 00003254 86C4                    		xchg	al,ah
 14660 00003256 AA                      		stosb
 14661 00003257 86C4                    		xchg	al,ah
 14662 00003259 B103                    		mov	cl,3
 14663 0000325B F3AA                    		rep stosb
 14664 0000325D 30C0                    		xor	al,al
 14665 0000325F AA                      		stosb
 14666 00003260 C3                      		retn
 14667                                  
 14668                                  ; =============== S U B	R O U T	I N E =======================================
 14669                                  
 14670                                  COMPNAME:
 14671 00003261 BE[8143]                		mov	si,DESTBUF	; do name translate of target
 14672 00003264 BF[063F]                		mov	di,TRGXNAME	; save for name comparison
 14673 00003267 B460                    		mov	ah,XNAMETRANS ; 60h
 14674 00003269 CD21                    		int	21h	; DOS -	RESOLVE	PATH STRING TO CANONICAL PATH STRING
 14675                                  				; DS:SI	-> ASCIZ relative path string or directory name
 14676                                  				; ES:DI	-> 128-byte buffer for ASCIZ canonical fully qualified name
 14677 0000326B BE[AF3E]                		mov	si,SRCXNAME	; get name translate of source
 14678 0000326E BF[063F]                		mov	di,TRGXNAME	; get name translate of target
 14679                                  		;call	STRCOMP
 14680                                  		;retn
 14681                                  		; 02/03/2023
 14682 00003271 E917E7                  		jmp	STRCOMP
 14683                                  
 14684                                  ;============================================================================
 14685                                  ; CPARSE.ASM, MSDOS 6.0, 1991
 14686                                  ;============================================================================
 14687                                  ; 30/09/2018 - Retro DOS v3.0
 14688                                  
 14689                                  ;-----------------------------------------------------------------------;
 14690                                  ; ENTRY:								;
 14691                                  ;	DS:SI	Points input buffer					;
 14692                                  ;	ES:DI	Points to the token buffer				;
 14693                                  ;	BL	Special delimiter for this call 			;
 14694                                  ;		    Always checked last 				;
 14695                                  ;		    set it to space if there is no special delimiter	;
 14696                                  ; EXIT: 								;
 14697                                  ;	DS:SI	Points to next char in the input buffer 		;
 14698                                  ;	ES:DI	Points to the token buffer				;
 14699                                  ;	[STARTEL] Points to start of last element of path in token	;
 14700                                  ;		points to a NUL for no element strings 'd:' 'd:/'       ;
 14701                                  ;	CX	Character count 					;
 14702                                  ;	BH	Condition Code						;
 14703                                  ;			Bit 1H of BH set if switch character		;
 14704                                  ;				Token buffer contains char after	;
 14705                                  ;				switch character			;
 14706                                  ;				BP has switch bits set (ORing only)	;
 14707                                  ;			Bit 2H of BH set if ? or * in token		;
 14708                                  ;				if * found element ? filled		;
 14709                                  ;			Bit 4H of BH set if path sep in token		;
 14710                                  ;			Bit 80H of BH set if the special delimiter	;
 14711                                  ;			   was skipped at the start of this token	;
 14712                                  ;		Token buffer always starts d: for non switch tokens	;
 14713                                  ;	CARRY SET							;
 14714                                  ;	    if CR on input						;
 14715                                  ;		token buffer not altered				;
 14716                                  ;									;
 14717                                  ;	DOES NOT RETURN ON BAD PATH, OR TRAILING SWITCH CHAR ERROR	;
 14718                                  ; MODIFIES:								;
 14719                                  ;	CX, SI, AX, BH, DX and the Carry Flag				;
 14720                                  ;									;
 14721                                  ;-----------------------------------------------------------------------;
 14722                                  
 14723                                  ; Modifications to cparse: recognition of right and left parentheses
 14724                                  ; as integral tokens, and removal of automatic upper-case conversion code.
 14725                                  ;
 14726                                  ; Both modifications were installed in the course of adding a coherent
 14727                                  ; command-line parser to COMMAND.COM which builds a UNIX-style argv[]/argc
 14728                                  ; structure for command-line arguments. This parser relies on cparse to
 14729                                  ; recognize individual tokens.
 14730                                  ;
 14731                                  ; To process for-loops correctly, parentheses must therefore be
 14732                                  ; recognized as tokens. The upper-case conversion code was removed so
 14733                                  ; that commands (such as for and echo) would be able to use the "original"
 14734                                  ; text of the command line.
 14735                                  ;
 14736                                  ; Note also the modification to prevent the automatic conversion of colons
 14737                                  ; into spaces WITHIN THE SOURCE TEXT!
 14738                                  ;
 14739                                  ; Also note that BP is also clobbered if cparse recognizes any switches
 14740                                  ; on the command line.
 14741                                  ;
 14742                                  ; Alan L, OS/MSDOS				    14 August 1983
 14743                                  
 14744                                  ; ---------------------------------------------------------------------------
 14745                                  
 14746                                  ; COMEQU.ASM (MSDOS 6.0, 1991)
 14747                                  
 14748                                  ;FSWITCH	EQU	8000h
 14749                                  ;FBADSWITCH	EQU	4000h
 14750                                  
 14751                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3334h
 14752                                  
 14753                                  ; =============== S U B	R O U T	I N E =======================================
 14754                                  
 14755                                  CPARSE:
 14756 00003274 31C0                    		xor	ax,ax
 14757 00003276 893E[A744]              		mov	[STARTEL],di		; No path element (Is DI correct?)
 14758 0000327A A2[AA44]                		mov	[ELPOS],al		; Start in 8 char prefix
 14759 0000327D A2[AB44]                		mov	[SOURCE],al		; No skip delimiter yet
 14760 00003280 88C7                    		mov	bh,al			; Init nothing
 14761 00003282 9C                      		pushf				; save flags
 14762 00003283 57                      		push	di			; save the token buffer addrss
 14763 00003284 31C9                    		xor	cx,cx			; no chars in token buffer
 14764 00003286 880E[D642]              		mov	[COMMA],cl		; reset comma flag
 14765                                  MOREDELIM:
 14766 0000328A AC                      		lodsb
 14767 0000328B E8C0E6                  		call	DELIM
 14768 0000328E 751D                    		jnz	short SCANCDONE
 14769 00003290 3C20                    		cmp	al,' '
 14770 00003292 74F6                    		jz	short MOREDELIM
 14771 00003294 3C09                    		cmp	al,9
 14772 00003296 74F2                    		jz	short MOREDELIM
 14773 00003298 8606[AB44]              		xchg	al,[SOURCE]
 14774 0000329C 08C0                    		or	al,al
 14775 0000329E 74EA                    		jz	short MOREDELIM		; One non space/tab delimiter allowed
 14776 000032A0 F6C780                  		test	bh,80h			; has a special char been found?
 14777 000032A3 7405                    		jz	short NO_COMMA		; no - just exit
 14778 000032A5 C606[D642]01            		mov	byte [COMMA],1		; set comma flag
 14779                                  NO_COMMA:
 14780 000032AA E91801                  		jmp	X_DONE			; Nul argument
 14781                                  SCANCDONE:
 14782 000032AD 803E[6643]01            		cmp	byte [CPYFLAG],1
 14783 000032B2 7503                    		jnz	short CPCONT1
 14784 000032B4 E83DE5                  		call	UPCONV_MAPCALL
 14785                                  CPCONT1:
 14786 000032B7 38D8                    		cmp	al,bl			; Special delimiter?
 14787 000032B9 7505                    		jnz	short NOSPEC
 14788 000032BB 80CF80                  		or	bh,80h
 14789 000032BE EBCA                    		jmp	short MOREDELIM
 14790                                  NOSPEC:
 14791 000032C0 3C0D                    		cmp	al,0Dh			; a CR?
 14792 000032C2 7503                    		jnz	short NCPERROR
 14793 000032C4 E9F900                  		jmp	CPERROR
 14794                                  NCPERROR:
 14795 000032C7 3A06[8541]              		cmp	al,[SWITCHAR]		; is the char the switch char?
 14796 000032CB 7503                    		jnz	short NA_SWITCH		; yes, process...
 14797 000032CD E9F800                  		jmp	A_SWITCH
 14798                                  NA_SWITCH:
 14799 000032D0 B23A                    		mov	dl,':'
 14800 000032D2 3814                    		cmp	[si],dl
 14801 000032D4 7513                    		jnz	short ANUM_CHARD	; Drive not specified
 14802 000032D6 E83501                  		call	MOVE_CHAR
 14803 000032D9 AC                      		lodsb				; Get the ':'
 14804 000032DA E83101                  		call	MOVE_CHAR
 14805 000032DD 893E[A744]              		mov	[STARTEL],di
 14806 000032E1 C606[A944]00            		mov	byte [ELCNT],0
 14807 000032E6 E99A00                  		jmp	ANUM_TEST
 14808                                  ANUM_CHARD:
 14809 000032E9 893E[A744]              		mov	[STARTEL],di
 14810 000032ED C606[A944]00            		mov	byte [ELCNT],0		; Store of this char sets it to one
 14811 000032F2 803E[6643]01            		cmp	byte [CPYFLAG],1	; Was CPARSE called from COPY?
 14812 000032F7 751D                    		jnz	short ANUM_CHAR		; No, don't add drive spec.
 14813 000032F9 E8DCE6                  		call	PATHCHRCMP		; Starts with a pathchar?
 14814 000032FC 7518                    		jnz	short ANUM_CHAR		; no
 14815 000032FE 50                      		push	ax
 14816 000032FF A0[9541]                		mov	al,[CURDRV]		; Insert drive spec
 14817                                  		;add	al,[CAPITAL_A]
 14818                                  		; 01/03/2023
 14819 00003302 0441                    		add	al,capital_A  ; add al,'A'
 14820 00003304 E80701                  		call	MOVE_CHAR
 14821 00003307 B03A                    		mov	al,':'
 14822 00003309 E80201                  		call	MOVE_CHAR
 14823 0000330C 58                      		pop	ax
 14824 0000330D 893E[A744]              		mov	[STARTEL],di
 14825 00003311 C606[A944]00            		mov	byte [ELCNT],0
 14826                                  ANUM_CHAR:
 14827                                  		;cmp	al,[DOT_CHR]
 14828                                  		; 01/03/2023
 14829 00003316 3C2E                    		cmp	al,dot_chr  ; cmp al,'.'
 14830 00003318 7509                    		jnz	short TESTQUEST
 14831 0000331A FE06[AA44]              		inc	byte [ELPOS]		; flag in extension
 14832 0000331E C606[A944]FF            		mov	byte [ELCNT],0FFh	; Store of the '.' resets it to 0
 14833                                  TESTQUEST:
 14834 00003323 3C3F                    		cmp	al,'?'
 14835 00003325 7503                    		jnz	short TESTSPLAT
 14836 00003327 80CF02                  		or	bh,2
 14837                                  TESTSPLAT:
 14838                                  		;cmp	al,[STAR]
 14839                                  		; 01/03/2023
 14840 0000332A 3C2A                    		cmp	al,star ; cmp al,'*'
 14841 0000332C 752C                    		jnz	short TESTPATH
 14842 0000332E 80CF02                  		or	bh,2
 14843 00003331 803E[B744]00            		cmp	byte [EXPAND_STAR],0
 14844                                  		;jnz	short EXPAND_FILENAME
 14845                                  		;jmp	short TESTPATH
 14846                                  		; 01/03/2023
 14847 00003336 7422                    		jz	short TESTPATH
 14848                                  ;BADPERR2J:
 14849                                  		;jmp	BADPERR2
 14850                                  
 14851                                  		;db	0E9h
 14852                                  		;db	7Eh	
 14853                                  		;db	0
 14854                                  
 14855                                  EXPAND_FILENAME:
 14856 00003338 B407                    		mov	ah,7
 14857 0000333A 803E[AA44]00            		cmp	byte [ELPOS],0
 14858 0000333F 7402                    		jz	short GOTELCNT
 14859 00003341 B402                    		mov	ah,2
 14860                                  GOTELCNT:
 14861 00003343 B03F                    		mov	al,'?'
 14862 00003345 2A26[A944]              		sub	ah,[ELCNT]
 14863                                  		;jb	short BADPERR2J
 14864                                  		; 01/03/2023
 14865 00003349 726C                    		jb	short BADPERR2
 14866 0000334B 86E1                    		xchg	ah,cl
 14867 0000334D E309                    		jcxz	TESTPATHX
 14868                                  QMOVE:
 14869 0000334F 86E1                    		xchg	ah,cl
 14870 00003351 E8BA00                  		call	MOVE_CHAR
 14871 00003354 86E1                    		xchg	ah,cl
 14872 00003356 E2F7                    		loop	QMOVE
 14873                                  TESTPATHX:
 14874 00003358 86E1                    		xchg	ah,cl
 14875                                  TESTPATH:
 14876 0000335A E87BE6                  		call	PATHCHRCMP
 14877 0000335D 7521                    		jnz	short NOTSPECIAL
 14878 0000335F 80CF04                  		or	bh,4
 14879 00003362 803E[B744]00            		cmp	byte [EXPAND_STAR],0
 14880 00003367 7405                    		jz	short NO_ERR_CHECK
 14881 00003369 F6C702                  		test	bh,2		; If just hit a '/', cannot have ? or * yet
 14882 0000336C 754F                    		jnz	short BADPERR
 14883                                  NO_ERR_CHECK:
 14884 0000336E 893E[A744]              		mov	[STARTEL],di	  ; New element
 14885 00003372 FF06[A744]              		inc	word [STARTEL]	  ; Point to char after /
 14886 00003376 C606[A944]FF            		mov	byte [ELCNT],0FFh ; Store of '/' sets it to 0
 14887 0000337B C606[AA44]00            		mov	byte [ELPOS],0
 14888                                  NOTSPECIAL:
 14889 00003380 E88B00                  		call	MOVE_CHAR	; just an alphanum string
 14890                                  ANUM_TEST:
 14891 00003383 AC                      		lodsb
 14892 00003384 803E[6643]01            		cmp	byte [CPYFLAG],1
 14893 00003389 7503                    		jnz	short CPCONT3
 14894 0000338B E866E4                  		call	UPCONV_MAPCALL
 14895                                  CPCONT3:
 14896 0000338E E8BDE5                  		call	DELIM
 14897 00003391 7432                    		jz	short X_DONE
 14898 00003393 3C0D                    		cmp	al,0Dh
 14899 00003395 742E                    		jz	short X_DONE
 14900 00003397 3A06[8541]              		cmp	al,[SWITCHAR]
 14901 0000339B 7428                    		jz	short X_DONE
 14902 0000339D 38D8                    		cmp	al,bl
 14903 0000339F 7424                    		jz	short X_DONE
 14904 000033A1 3C3A                    		cmp	al,':'		; ':' allowed as trailer because of devices
 14905 000033A3 750F                    		jnz	short ANUM_CHARJ
 14906                                  
 14907                                  ; Modification made for parseline.
 14908                                  ; Why would it be necessary to change colons to spaces? In this
 14909                                  ; case, EVERY colon is changed to a space; e.g., 'f:' yields 'f ',
 14910                                  ; but so does 'echo foo:bar' yield 'echo foo bar'.
 14911                                  
 14912 000033A5 803E[6643]02            		cmp	byte [CPYFLAG],2
 14913 000033AA 7505                    		jnz	short CPCONT4
 14914 000033AC E85F00                  		call	MOVE_CHAR
 14915 000033AF EBD2                    		jmp	short ANUM_TEST
 14916                                  CPCONT4:
 14917 000033B1 46                      		inc	si		;Skip the ':'
 14918 000033B2 EB11                    		jmp	short X_DONE
 14919                                  ANUM_CHARJ:
 14920 000033B4 E95FFF                  		jmp	ANUM_CHAR
 14921                                  BADPERR2:
 14922 000033B7 BA[7C3C]                		mov	dx,BADCPMESPTR
 14923 000033BA E92DE8                  		jmp	CERROR
 14924                                  BADPERR:
 14925 000033BD E904DE                  		jmp	BADCDERR  ; MSDOS 3.3	
 14926                                  CPERROR:
 14927 000033C0 4E                      		dec	si		; adjust the pointer
 14928 000033C1 5F                      		pop	di		; retrive token buffer address
 14929 000033C2 9D                      		popf			; restore flags
 14930 000033C3 F9                      		stc			; set the carry bit
 14931 000033C4 C3                      		retn
 14932                                  X_DONE:
 14933 000033C5 4E                      		dec	si		; adjust for next round
 14934                                  
 14935                                  ; Mod to recognize right and left parens as integral tokens.
 14936                                  ;X_DONE2:
 14937 000033C6 EB3F                    		jmp	short OUT_TOKEN
 14938                                  A_SWITCH:
 14939 000033C8 80CF01                  		or	bh,1		; Indicate switch
 14940 000033CB 81CD0080                		or	bp,FSWITCH ; 8000h
 14941 000033CF E874E5                  		call	SCANOFF
 14942 000033D2 46                      		inc	si
 14943 000033D3 3C0D                    		cmp	al,0Dh
 14944 000033D5 7509                    		jnz	short STORE_SWT
 14945 000033D7 B000                    		mov	al,0
 14946 000033D9 AA                      		stosb
 14947 000033DA 81CD0040                		or	bp,FBADSWITCH ; 4000h
 14948 000033DE EBE0                    		jmp	short CPERROR	; Trailing switch character error
 14949                                  					;   BP = fSwitch but no switch
 14950                                  					;   bit is set (unknown switch)
 14951                                  STORE_SWT:
 14952 000033E0 E82B00                  		call	MOVE_CHAR	; store the character
 14953                                  
 14954                                  ; This upconv call must stay.  It is used to identify copy-switches
 14955                                  ; on the command line, and won't store anything into the output buffer.
 14956                                  
 14957 000033E3 E80EE4                  		call	UPCONV_MAPCALL
 14958 000033E6 06                      		push	es
 14959 000033E7 57                      		push	di
 14960 000033E8 51                      		push	cx
 14961 000033E9 0E                      		push	cs
 14962 000033EA 07                      		pop	es
 14963 000033EB BF[2E3E]                		mov	di,SWITCH_LIST ; "VBAPW"
 14964 000033EE B90500                  		mov	cx,SWCOUNT ; 5
 14965 000033F1 81CD0040                		or	bp,FBADSWITCH  ; 4000h
 14966 000033F5 F2AE                    		repne scasb
 14967 000033F7 750B                    		jnz	short OUT_TOKENP
 14968 000033F9 81E5FFBF                		and	bp,~FBADSWITCH ; 0BFFFh
 14969 000033FD B80100                  		mov	ax,1
 14970 00003400 D3E0                    		shl	ax,cl
 14971 00003402 09C5                    		or	bp,ax
 14972                                  OUT_TOKENP:
 14973 00003404 59                      		pop	cx
 14974 00003405 5F                      		pop	di
 14975 00003406 07                      		pop	es
 14976                                  OUT_TOKEN:
 14977 00003407 B000                    		mov	al,0		; null at the end
 14978 00003409 AA                      		stosb
 14979 0000340A 5F                      		pop	di		; restore token buffer pointer	
 14980 0000340B 9D                      		popf
 14981 0000340C F8                      		clc			; clear carry flag
 14982 0000340D C3                      		retn
 14983                                  
 14984                                  ; =============== S U B	R O U T	I N E =======================================
 14985                                  
 14986                                  MOVE_CHAR:
 14987 0000340E AA                      		stosb			; store char in token buffer
 14988 0000340F 41                      		inc	cx		; increment char count
 14989 00003410 FE06[A944]              		inc	byte [ELCNT]	; increment element count for * substi
 14990 00003414 C3                      		retn
 14991                                  
 14992                                  ;============================================================================
 14993                                  ; NPRINTF.ASM, PRINTF.ASM, MSDOS 3.3, 1987
 14994                                  ;============================================================================
 14995                                  ; 30/09/2018 - Retro DOS v3.0
 14996                                  
 14997                                  ; BREAK	<Message Printing Routine>
 14998                                  
 14999                                  ;
 15000                                  ;	MSDOS V3.00 PRINT
 15001                                  ;
 15002                                  ;	Message Printing Routine
 15003                                  ;
 15004                                  
 15005                                  ;PRINTF.ASM (MSDOS 3.3, LIBC)
 15006                                  ;
 15007                                  ;TITLE   PRINTF ROUTINE FOR MS-DOS
 15008                                  ;
 15009                                  ; PRINTF(Control String, arg1, arg2,...,argn-1,argn)
 15010                                  ;
 15011                                  ; Characters are output to PFHandle according to the
 15012                                  ; specifications contained in the Control String.
 15013                                  ;
 15014                                  ; The conversion characters are as follow:
 15015                                  ;
 15016                                  ;               %c - output the next argument as a character
 15017                                  ;               %s - output the next argument as a string
 15018                                  ;               %x - output the next argument as a hexidecimal number
 15019                                  ;                    using abcedf
 15020                                  ;               %X - output the next argument as a hexidecimal number
 15021                                  ;                    using ABCDEF
 15022                                  ;               %d - output the next argument as a decimal number
 15023                                  ;
 15024                                  ;
 15025                                  ; Other format specifiers that may precede the conversion character are:
 15026                                  ;
 15027                                  ;               - (minus sign) - causes the field to be left-adjusted
 15028                                  ;               + (plus sign)  - causes the field to be right-adjusted (default)
 15029                                  ;               n - digit specifing the minimum field width (default to 1)
 15030                                  ;               L - specifing a long integer
 15031                                  ;
 15032                                  ;   On entry to PRINTF the stack contains the return address and a pointer
 15033                                  ;   to an argument list.
 15034                                  ;
 15035                                  ;   ____________________
 15036                                  ;   |   Ret Addr       |      <= SP
 15037                                  ;   --------------------
 15038                                  ;   |  Ptr to Arg List |
 15039                                  ;   --------------------
 15040                                  ;
 15041                                  ;   And the argument list contains the following:
 15042                                  ;
 15043                                  ;       String_ptr                  (a pointer to the control string)
 15044                                  ;       Arg 1
 15045                                  ;       Arg 2
 15046                                  ;         .
 15047                                  ;         .
 15048                                  ;         .
 15049                                  ;       Arg n-1
 15050                                  ;       Arg n
 15051                                  ;
 15052                                  ;   If the argument is a %s or %c the arg contains a pointer to the string
 15053                                  ;   or character.
 15054                                  ;
 15055                                  ;   The arguments are used in one-to-one correspondence to % specifiers.
 15056                                  
 15057                                  
 15058                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 34E0h
 15059                                  
 15060                                  ; =============== S U B	R O U T	I N E =======================================
 15061                                  
 15062                                  PRINTF_INIT:
 15063 00003415 E81000                  		call	STD_PRINTF
 15064 00003418 CB                      		retf
 15065                                  
 15066                                  ; =============== S U B	R O U T	I N E =======================================
 15067                                  
 15068                                  PRINTF_CRLF:
 15069 00003419 E80C00                  		call	STD_PRINTF
 15070                                  		;call	CRLF2
 15071                                  		;retn
 15072                                  		; 02/03/2023
 15073 0000341C E91AE5                  		jmp	CRLF2
 15074                                  
 15075                                  ; =============== S U B	R O U T	I N E =======================================
 15076                                  
 15077                                  STD_EPRINTF:
 15078 0000341F 2EC706[493E]0200        		mov	word [cs:PRINTF_HANDLE],2
 15079 00003426 EB07                    		jmp	short NEW_PRINTF
 15080                                  
 15081                                  ; =============== S U B	R O U T	I N E =======================================
 15082                                  
 15083                                  STD_PRINTF:
 15084                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 34F4h
 15085                                  
 15086 00003428 2EC706[493E]0100        		mov	word [cs:PRINTF_HANDLE],1
 15087                                  
 15088                                  NEW_PRINTF:				;Save the callers' registers
 15089 0000342F FC                      		cld
 15090 00003430 52                      		push	dx
 15091 00003431 55                      		push	bp
 15092 00003432 89E5                    		mov	bp,sp
 15093 00003434 51                      		push	cx
 15094 00003435 53                      		push	bx
 15095 00003436 50                      		push	ax
 15096 00003437 57                      		push	di
 15097 00003438 56                      		push	si
 15098 00003439 06                      		push	es
 15099 0000343A 1E                      		push	ds
 15100 0000343B 0E                      		push	cs
 15101 0000343C 07                      		pop	es		;ES points to Printf segment
 15102 0000343D BF[4B3E]                		mov	di,PRINTF_BUF	;DI points to the output buffer
 15103 00003440 8B6E02                  		mov	bp,[bp+2]  ; dx ;BP points to the argument list
 15104                                  		;mov	si,[ds:bp+0]	;SI points to the control string
 15105 00003443 3E8B7600                		mov	si,[ds:bp] ; bp
 15106 00003447 83C502                  		add	bp,2
 15107 0000344A 31DB                    		xor	bx,bx
 15108 0000344C E8D001                  		call	CLEAR_FLAGS	; initialize the world
 15109                                  GET_CHAR:
 15110 0000344F AC                      		lodsb			;Get a character
 15111 00003450 3C25                    		cmp	al,'%'		;Is it a conversion specifier?
 15112 00003452 7416                    		jz	short CONV_CHAR	;Yes - find out which one
 15113 00003454 08C0                    		or	al,al		;Is it the end of the control string?
 15114 00003456 7405                    		jz	short PRINTF_DONE ;Yes - then we're done
 15115                                  PRINTF_PERCENT:				
 15116 00003458 E86101                  		call	OUTCHR		;Otherwise store the character
 15117 0000345B EBF2                    		jmp	short GET_CHAR	;And go get another
 15118                                  PRINTF_DONE:
 15119 0000345D E86401                  		call	FLUSH
 15120 00003460 1F                      		pop	ds
 15121 00003461 07                      		pop	es
 15122 00003462 5E                      		pop	si
 15123 00003463 5F                      		pop	di
 15124 00003464 58                      		pop	ax
 15125 00003465 5B                      		pop	bx
 15126 00003466 59                      		pop	cx
 15127 00003467 5D                      		pop	bp
 15128 00003468 5A                      		pop	dx
 15129 00003469 C3                      		retn
 15130                                  
 15131                                  CONV_CHAR:
 15132 0000346A 2EC606[403E]00          		mov	byte [cs:PRINTF_LEFT],0
 15133                                  NXT_CONV_CHAR:	
 15134                                  		;Look for any format specifiers preceeding the conversion character
 15135 00003470 AC                      		lodsb
 15136 00003471 3C25                    		cmp	al,'%'			;Just print the %
 15137 00003473 74E3                    		jz	short PRINTF_PERCENT
 15138                                  		;cmp	al,[cs:CHAR_SUB] ; "-"	;Right justify the field	
 15139                                  		; 01/03/2023
 15140 00003475 3C2D                    		cmp	al,'-'
 15141 00003477 743C                    		jz	short LEFT_ADJ
 15142                                  		;cmp	al,[cs:PLUS_CHR] ; "+"	;Left justify the field
 15143 00003479 3C2B                    		cmp	al,plus_chr ; cmp al,'+'
 15144 0000347B 74ED                    		jz	short CONV_CHAR
 15145                                  		;cmp	al,[cs:CHAR_L]	 ; "L"	;Is it a long integer
 15146 0000347D 3C4C                    		cmp	al,'L'
 15147 0000347F 743C                    		jz	short LONG_INT
 15148                                  		;cmp	al,[cs:char_l]	 ; "l"		
 15149 00003481 3C6C                    		cmp	al,'l'
 15150 00003483 7438                    		jz	short LONG_INT
 15151 00003485 3C30                    		cmp	al,'0'			;Is it a precision specification
 15152 00003487 723C                    		jb	short LOOK_CONV_CHAR
 15153 00003489 3C39                    		cmp	al,'9'
 15154 0000348B 7738                    		ja	short LOOK_CONV_CHAR
 15155 0000348D 3C30                    		cmp	al,'0'
 15156 0000348F 750C                    		jnz	short NOT_PAD
 15157 00003491 2E833E[443E]00          		cmp	word [cs:PRINTF_WIDTH],0
 15158 00003497 7504                    		jnz	short NOT_PAD
 15159                                  		;mov	ah,'0'
 15160                                  		;mov	[cs:PAD_CHAR],ah
 15161                                  		; 01/03/2023
 15162 00003499 2EA2[483E]              		mov	[cs:PAD_CHAR],al ; '0'
 15163                                  NOT_PAD:					;Adjust decimal place on precision
 15164 0000349D 50                      		push	ax
 15165 0000349E 2EA1[443E]              		mov	ax,[cs:PRINTF_WIDTH]
 15166 000034A2 B90A00                  		mov	cx,10
 15167 000034A5 F7E1                    		mul	cx
 15168 000034A7 5A                      		pop	dx
 15169 000034A8 30F6                    		xor	dh,dh
 15170 000034AA 80EA30                  		sub	dl,'0'
 15171 000034AD 01D0                    		add	ax,dx
 15172 000034AF 2EA3[443E]              		mov	[cs:PRINTF_WIDTH],ax	;And save the total
 15173 000034B3 EBBB                    		jmp	short NXT_CONV_CHAR
 15174                                  LEFT_ADJ:
 15175 000034B5 2EC606[403E]01          		mov	byte [cs:PRINTF_LEFT],1
 15176 000034BB EBB3                    		jmp	short NXT_CONV_CHAR
 15177                                  LONG_INT:
 15178 000034BD 2E800E[413E]01          		or	byte [cs:PRINTF_LONG],1
 15179 000034C3 EBAB                    		jmp	short NXT_CONV_CHAR
 15180                                  LOOK_CONV_CHAR:
 15181 000034C5 24DF                    		and	al,0DFh
 15182                                  		; 01/03/2023
 15183                                  		;cmp	al,[cs:CHAR_X]	 ; "X"
 15184 000034C7 3C58                    		cmp	al,'X'
 15185 000034C9 7431                    		jz	short HEX_UP
 15186                                  		;cmp	al,[cs:CHAR_D]	 ; "D"
 15187 000034CB 3C44                    		cmp	al,'D'
 15188 000034CD 7436                    		jz	short DECIMAL
 15189                                  		;cmp	al,[cs:CHAR_C]	 ; "C"
 15190 000034CF 3C43                    		cmp	al,'C'
 15191 000034D1 743B                    		jz	short C_PUT_CHAR
 15192                                  		;cmp	al,[cs:CHAR_S]	 ; "S"
 15193 000034D3 3C53                    		cmp	al,'S'
 15194                                  		;jz	short S_PUT_STRG
 15195                                  		;call	CLEAR_FLAGS
 15196                                  		;jmp	GET_CHAR
 15197                                  		; 01/03/2023
 15198 000034D5 753F                    		jnz	short S_PUT_5
 15199                                  		;jmp	short S_PUT_STRG ; -->
 15200                                  
 15201                                  		; 01/03/2023
 15202                                  ;HEX_UP:
 15203                                  ;		mov	word [cs:PRINTF_BASE],16 ;Hex conversion
 15204                                  ;		jmp	short CONV_TO_NUM
 15205                                  ;DECIMAL:
 15206                                  ;		mov	word [cs:PRINTF_BASE],10 ;Decimal conversion
 15207                                  ;		jmp	short CONV_TO_NUM
 15208                                  ;
 15209                                  ;C_PUT_CHAR:
 15210                                  ;		call	NEXT_CHRS
 15211                                  ;		mov	al,dl
 15212                                  ;		call	OUTCHR
 15213                                  ;		call	CLEAR_FLAGS
 15214                                  ;		jmp	GET_CHAR
 15215                                  
 15216                                  ; -->
 15217                                  S_PUT_STRG:
 15218 000034D7 56                      		push	si			;Save pointer to control string
 15219 000034D8 E83701                  		call	NEXT_CHRS
 15220 000034DB 89D6                    		mov	si,dx
 15221                                  S_PUT_1:
 15222 000034DD 2E8B0E[443E]            		mov	cx,[cs:PRINTF_WIDTH]
 15223 000034E2 09C9                    		or	cx,cx
 15224 000034E4 740B                    		jz	short S_PUT_2
 15225 000034E6 2E803E[403E]00          		cmp	byte [cs:PRINTF_LEFT],0
 15226 000034EC 7503                    		jnz	short S_PUT_2
 15227 000034EE E84300                  		call	PAD_STRING
 15228                                  S_PUT_2:
 15229 000034F1 56                      		push	si
 15230                                  S_PUT_3:
 15231 000034F2 AC                      		lodsb
 15232 000034F3 08C0                    		or	al,al
 15233 000034F5 7425                    		jz	short S_PUT_4
 15234 000034F7 E8C200                  		call	OUTCHR			;Put it into our buffer
 15235 000034FA EBF6                    		jmp	short S_PUT_3
 15236                                  
 15237                                  		; 01/03/2023
 15238                                  HEX_UP:
 15239 000034FC 2EC706[463E]1000        		mov	word [cs:PRINTF_BASE],16 ;Hex conversion
 15240 00003503 EB41                    		jmp	short CONV_TO_NUM
 15241                                  DECIMAL:
 15242 00003505 2EC706[463E]0A00        		mov	word [cs:PRINTF_BASE],10 ;Decimal conversion
 15243 0000350C EB38                    		jmp	short CONV_TO_NUM
 15244                                  C_PUT_CHAR:
 15245 0000350E E80101                  		call	NEXT_CHRS
 15246 00003511 88D0                    		mov	al,dl
 15247 00003513 E8A600                  		call	OUTCHR
 15248                                  S_PUT_5: ; 01/03/2023
 15249 00003516 E80601                  		call	CLEAR_FLAGS
 15250 00003519 E933FF                  		jmp	GET_CHAR
 15251                                  S_PUT_4:
 15252 0000351C 5E                      		pop	si
 15253 0000351D 2E803E[403E]00          		cmp	byte [cs:PRINTF_LEFT],0
 15254 00003523 740C                    		jz	short C_S_END
 15255 00003525 2E8B0E[443E]            		mov	cx,[cs:PRINTF_WIDTH]
 15256 0000352A 09C9                    		or	cx,cx
 15257 0000352C 7403                    		jz	short C_S_END
 15258 0000352E E80300                  		call	PAD_STRING
 15259                                  C_S_END:
 15260 00003531 5E                      		pop	si			;Restore control string pointer
 15261                                  		;call	CLEAR_FLAGS
 15262                                  		;jmp	GET_CHAR		;Go get another character	
 15263                                  		; 01/03/2023
 15264 00003532 EBE2                    		jmp	short S_PUT_5
 15265                                  
 15266                                  ; =============== S U B	R O U T	I N E =======================================
 15267                                  
 15268                                  PAD_STRING:
 15269 00003534 31D2                    		xor	dx,dx
 15270 00003536 56                      		push	si
 15271                                  COUNT_LOOP:
 15272 00003537 AC                      		lodsb
 15273 00003538 08C0                    		or	al,al
 15274 0000353A 7403                    		jz	short COUNT_DONE
 15275 0000353C 42                      		inc	dx
 15276 0000353D EBF8                    		jmp	short COUNT_LOOP
 15277                                  COUNT_DONE:
 15278 0000353F 5E                      		pop	si
 15279 00003540 29D1                    		sub	cx,dx
 15280 00003542 7667                    		jbe	short COUNT_RET
 15281                                  		;call	PAD
 15282                                  		; 02/03/2023
 15283 00003544 EB66                    		jmp	PAD
 15284                                  ;COUNT_RET:
 15285                                  		;retn
 15286                                  
 15287                                  ; ---------------------------------------------------------------------------
 15288                                  
 15289                                  CONV_TO_NUM:
 15290 00003546 E8C900                  		call	NEXT_CHRS
 15291 00003549 89D0                    		mov	ax,dx
 15292 0000354B 31D2                    		xor	dx,dx
 15293 0000354D 2E803E[413E]00          		cmp	byte [cs:PRINTF_LONG],0 
 15294                                  				;Is this is a short or long integer?
 15295 00003553 7403                    		jz	short NOT_LONG_INT
 15296 00003555 E8BA00                  		call	NEXT_CHRS
 15297                                  NOT_LONG_INT:
 15298 00003558 53                      		push	bx
 15299 00003559 56                      		push	si
 15300 0000355A 2E8B36[463E]            		mov	si,[cs:PRINTF_BASE]
 15301 0000355F 2E8B0E[443E]            		mov	cx,[cs:PRINTF_WIDTH]
 15302 00003564 E80B00                  		call	PNUM
 15303 00003567 5E                      		pop	si
 15304 00003568 5B                      		pop	bx
 15305 00003569 E84000                  		call	PAD
 15306 0000356C E8B000                  		call	CLEAR_FLAGS
 15307 0000356F E9DDFE                  		jmp	GET_CHAR
 15308                                  
 15309                                  ; =============== S U B	R O U T	I N E =======================================
 15310                                  
 15311                                  PNUM:
 15312 00003572 49                      		dec	cx
 15313 00003573 50                      		push	ax
 15314 00003574 89D0                    		mov	ax,dx
 15315 00003576 31D2                    		xor	dx,dx
 15316 00003578 F7F6                    		div	si
 15317 0000357A 89C3                    		mov	bx,ax
 15318 0000357C 58                      		pop	ax
 15319 0000357D F7F6                    		div	si
 15320 0000357F 87DA                    		xchg	bx,dx
 15321 00003581 50                      		push	ax
 15322 00003582 09D0                    		or	ax,dx
 15323 00003584 58                      		pop	ax
 15324 00003585 7407                    		jz	short DO_PAD
 15325 00003587 53                      		push	bx
 15326 00003588 E8E7FF                  		call	PNUM
 15327 0000358B 5B                      		pop	bx
 15328 0000358C EB0B                    		jmp	short REM
 15329                                  DO_PAD:
 15330 0000358E 2E803E[403E]00          		cmp	byte [cs:PRINTF_LEFT],0
 15331 00003594 7503                    		jnz	short REM
 15332 00003596 E81300                  		call	PAD
 15333                                  REM:
 15334 00003599 80FB0A                  		cmp	bl,10
 15335 0000359C 7203                    		jb	short NOT_HEX
 15336 0000359E 83C306                  		add	bx,6
 15337                                  NOT_HEX:
 15338 000035A1 2E8A87[4036]            		mov	al,[cs:PRINTF_TABLE+bx]	; "0123456789ABCDEF"
 15339 000035A6 51                      		push	cx
 15340 000035A7 E81200                  		call	OUTCHR
 15341 000035AA 59                      		pop	cx
 15342                                  COUNT_RET:	; 02/03/2023
 15343 000035AB C3                      		retn
 15344                                  
 15345                                  ; =============== S U B	R O U T	I N E =======================================
 15346                                  
 15347                                  PAD:
 15348 000035AC 09C9                    		or	cx,cx
 15349 000035AE 7E0B                    		jle	short PAD_DONE
 15350 000035B0 2EA0[483E]              		mov	al,[cs:PAD_CHAR]
 15351                                  PAD_LOOP:
 15352 000035B4 51                      		push	cx
 15353 000035B5 E80400                  		call	OUTCHR
 15354 000035B8 59                      		pop	cx
 15355 000035B9 E2F9                    		loop	PAD_LOOP
 15356                                  PAD_DONE:
 15357 000035BB C3                      		retn
 15358                                  
 15359                                  ; =============== S U B	R O U T	I N E =======================================
 15360                                  
 15361                                  OUTCHR:
 15362 000035BC AA                      		stosb
 15363 000035BD 81FF[AF3E]              		cmp	di,PRINTF_BUF_END ; SRCXNAME
 15364 000035C1 7401                    		je	short FLUSH
 15365                                  OUTCHR_RETN:
 15366 000035C3 C3                      		retn
 15367                                  
 15368                                  ; =============== S U B	R O U T	I N E =======================================
 15369                                  
 15370                                  FLUSH:
 15371 000035C4 B9[4B3E]                		mov	cx,PRINTF_BUF
 15372 000035C7 87CF                    		xchg	cx,di
 15373 000035C9 29F9                    		sub	cx,di
 15374 000035CB 74F6                    		jz	short OUTCHR_RETN
 15375                                  WRITE_CHARS:
 15376 000035CD 53                      		push	bx
 15377 000035CE 2E8B1E[493E]            		mov	bx,[cs:PRINTF_HANDLE]
 15378 000035D3 1E                      		push	ds
 15379 000035D4 0E                      		push	cs
 15380 000035D5 1F                      		pop	ds
 15381 000035D6 BA[4B3E]                		mov	dx,PRINTF_BUF
 15382 000035D9 B440                    		mov	ah,WRITE ; 40h
 15383 000035DB CD21                    		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 15384                                  					; BX = file handle, CX = number	of bytes to write,
 15385                                  					; DS:DX -> buffer
 15386 000035DD 730B                    		jnb	short FOOB2_1
 15387 000035DF E897E8                  		call	GET_EXT_ERR_NUMBER
 15388 000035E2 83F806                  		cmp	ax,6
 15389                                  		;jz	short FOOB2_4
 15390                                  		;jmp	short FOOB2_2
 15391                                  		; 02/03/2023
 15392 000035E5 7507                    		jnz	short FOOB2_2
 15393                                  FOOB2_4:
 15394 000035E7 1F                      		pop	ds
 15395 000035E8 5B                      		pop	bx
 15396 000035E9 C3                      		retn
 15397                                  FOOB2_1:
 15398 000035EA 39C1                    		cmp	cx,ax
 15399 000035EC 74F9                    		jz	short FOOB2_4
 15400                                  FOOB2_2:
 15401 000035EE 89D3                    		mov	bx,dx
 15402 000035F0 01C3                    		add	bx,ax
 15403 000035F2 803F1A                  		cmp	byte [bx],1Ah
 15404 000035F5 74F0                    		jz	short FOOB2_4
 15405 000035F7 1F                      		pop	ds
 15406 000035F8 5B                      		pop	bx
 15407 000035F9 2E8E06[8141]            		mov	es,[cs:RESSEG]
 15408 000035FE BA[6937]                		mov	dx,NOSPACEPTR
 15409 00003601 26F606560CFF            		test	byte [es:PIPEFLAG],0FFh
 15410 00003607 7406                    		jz	short PRINT_ERR_EXIT
 15411 00003609 E804ED                  		call	PIPEOFF
 15412 0000360C BA[023C]                		mov	dx,PIPEEMESPTR
 15413                                  PRINT_ERR_EXIT:	
 15414 0000360F E9D8E5                  		jmp	CERROR
 15415                                  
 15416                                  		; 02/03/2023
 15417                                  ;FOOB2_4:
 15418                                  		;pop	ds
 15419                                  		;pop	bx
 15420                                  		;retn
 15421                                  
 15422                                  ; =============== S U B	R O U T	I N E =======================================
 15423                                  
 15424                                  NEXT_CHRS:
 15425 00003612 56                      		push	si		;Save pointer to control string
 15426 00003613 89DE                    		mov	si,bx		;Get index into argument list
 15427 00003615 83C302                  		add	bx,2		;Increment the index
 15428 00003618 3E8B32                  		mov	si,[ds:bp+si]	; Get pointer to next argument
 15429 0000361B 8B14                    		mov	dx,[si]		; Get (address of the) next argument			
 15430 0000361D 5E                      		pop	si
 15431 0000361E C3                      		retn
 15432                                  
 15433                                  ; =============== S U B	R O U T	I N E =======================================
 15434                                  
 15435                                  CLEAR_FLAGS:
 15436 0000361F 31C0                    		xor	ax,ax
 15437 00003621 2EA2[403E]              		mov	[cs:PRINTF_LEFT],al	;Reset justifing flag
 15438 00003625 2EA2[413E]              		mov	[cs:PRINTF_LONG],al	;Reset long flag
 15439 00003629 2EA3[443E]              		mov	[cs:PRINTF_WIDTH],ax	;Reinitialize width to 0
 15440 0000362D B020                    		mov	al,' '			
 15441 0000362F 2EA2[483E]              		mov	[cs:PAD_CHAR],al 	;Reset padding character
 15442 00003633 C3                      		retn
 15443                                  
 15444                                  ; ---------------------------------------------------------------------------
 15445                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3729h
 15446                                  
 15447                                  		; times 7 db 0
 15448                                  
 15449                                  ;============================================================================
 15450                                  ; TDATA.ASM, MSDOS 6.0, 1991
 15451                                  ;============================================================================
 15452                                  ; 30/09/2018 - Retro DOS v3.0
 15453                                  
 15454                                  ; TITLE	COMMAND Transient Initialized DATA
 15455                                  
 15456                                  ;The TRANDATA segment contains data that is assumed to have predefined
 15457                                  ;initial values at the beginning of each command cycle. It is
 15458                                  ;included in the transient checksum area. If values in TRANDATA
 15459                                  ;change, the transient will be reloaded for the next command cycle.
 15460                                  
 15461 00003634 90<rep Ch>              align 16
 15462                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3730h
 15463                                  
 15464 00003640 303132333435363738-     PRINTF_TABLE:	db '0123456789ABCDEF'
 15464 00003649 39414243444546     
 15465 00003650 255300                  _3740h:		db '%S',0
 15466 00003653 [5036]                  ARG_BUF_PTR:	dw _3740h
 15467 00003655 [5736]                  		dw _3747h
 15468 00003657 [D842]                  _3747h:		dw ARG_BUF ; _43E8h
 15469 00003659 25532000                _3749h:		db '%S ',0
 15470 0000365D [5936]                  STRINGBUF1PTR:	dw _3749h
 15471 0000365F [5843]                  		dw STRING_PTR_1 ; _4468h
 15472 00003661 25396C6400              _3751h:		db '%9ld',0
 15473 00003666 [6136]                  FSIZEMESPTR:	dw _3751h
 15474 00003668 [5A43]                  		dw FILESIZE_L ; _446Ah
 15475 0000366A [5C43]                  		dw FILESIZE_H ; _446Ch
 15476 0000366C 255300                  _375Ch:		db '%S',0
 15477 0000366F [6C36]                  STRINGBUF2PTR:	dw _375Ch
 15478 00003671 [5E43]                  		dw STRING_PTR_2 ; _446Eh
 15479 00003673 0900                    _3763h:		db 9,0
 15480 00003675 [7336]                  TABPTR:		dw _3763h
 15481 00003677 0D0A                    _3767h:		db 0Dh,0Ah
 15482 00003679 42617463682066696C-     		db 'Batch file missing',0Dh,0Ah,0
 15482 00003682 65206D697373696E67-
 15482 0000368B 0D0A00             
 15483 0000368E [7736]                  BADPATHPTR:	dw _3767h
 15484 00003690 0D0A                    _3780h:		db 0Dh,0Ah
 15485 00003692 496E73657274206469-     		db 'Insert disk with batch file',0Dh,0Ah
 15485 0000369B 736B20776974682062-
 15485 000036A4 617463682066696C65-
 15485 000036AD 0D0A               
 15486 000036AF 616E64207072657373-     		db 'and press any key when ready',0Dh,0Ah,0
 15486 000036B8 20616E79206B657920-
 15486 000036C1 7768656E2072656164-
 15486 000036CA 790D0A00           
 15487 000036CE [9036]                  INSERTDSKPTR:	dw _3780h
 15488 000036D0 42616420636F6D6D61-     _37C0h:		db 'Bad command or file name',0Dh,0Ah,0
 15488 000036D9 6E64206F722066696C-
 15488 000036E2 65206E616D650D0A00 
 15489 000036EB [D036]                  BADNAMPTR:	dw _37C0h
 15490 000036ED 4475706C6963617465-     _37DDh:		db 'Duplicate file name or File not found',0Dh,0Ah,0
 15490 000036F6 2066696C65206E616D-
 15490 000036FF 65206F722046696C65-
 15490 00003708 206E6F7420666F756E-
 15490 00003711 640D0A00           
 15491 00003715 [ED36]                  RENERRPTR:	dw _37DDh
 15492 00003717 46696C65206E6F7420-     _3807h:		db 'File not found',0Dh,0Ah,0
 15492 00003720 666F756E640D0A00   
 15493 00003728 [1737]                  FNOTFOUNDPTR:	dw _3807h
 15494 0000372A 50617468206E6F7420-     _381Ah:		db 'Path not found',0Dh,0Ah,0
 15494 00003733 666F756E640D0A00   
 15495 0000373B [2A37]                  PNOTFOUNDPTR:	dw _381Ah
 15496 0000373D 416363657373206465-     _382Dh:		db 'Access denied',0Dh,0Ah,0
 15496 00003746 6E6965640D0A00     
 15497 0000374D [3D37]                  ACCDENPTR:	dw _382Dh
 15498 0000374F 496E73756666696369-     _383Fh:		db 'Insufficient disk space',0Dh,0Ah,0
 15498 00003758 656E74206469736B20-
 15498 00003761 73706163650D0A00   
 15499 00003769 [4F37]                  NOSPACEPTR:	dw _383Fh
 15500 0000376B 4F7574206F6620656E-     _385Bh:		db 'Out of environment space',0Dh,0Ah,0
 15500 00003774 7669726F6E6D656E74-
 15500 0000377D 2073706163650D0A00 
 15501 00003786 [6B37]                  ENVERRPTR:	dw _385Bh
 15502 00003788 46696C652063726561-     _3878h:		db 'File creation error',0Dh,0Ah,0
 15502 00003791 74696F6E206572726F-
 15502 0000379A 720D0A00           
 15503 0000379E 7838                    FULDIRPTR:	dw 3878h
 15504 000037A0 46696C652063616E6E-     _3890h:		db 'File cannot be copied onto itself',0Dh,0Ah,0
 15504 000037A9 6F7420626520636F70-
 15504 000037B2 696564206F6E746F20-
 15504 000037BB 697473656C660D0A00 
 15505 000037C4 [A037]                  OVERWRPTR:	dw _3890h
 15506 000037C6 436F6E74656E74206F-     _38B6h:		db 'Content of destination lost before copy',0Dh,0Ah,0
 15506 000037CF 662064657374696E61-
 15506 000037D8 74696F6E206C6F7374-
 15506 000037E1 206265666F72652063-
 15506 000037EA 6F70790D0A00       
 15507 000037F0 [C637]                  LOSTERRPTR:	dw _38B6h
 15508 000037F2 496E76616C69642066-     _38E2h:		db 'Invalid filename or file not found',0Dh,0Ah,0
 15508 000037FB 696C656E616D65206F-
 15508 00003804 722066696C65206E6F-
 15508 0000380D 7420666F756E640D0A-
 15508 00003816 00                 
 15509 00003817 [F237]                  INORNOTPTR:	dw _38E2h
 15510 00003819 2539642046696C6528-     _3909h:		db '%9d File(s) copied',0Dh,0Ah,0
 15510 00003822 732920636F70696564-
 15510 0000382B 0D0A00             
 15511 0000382E [1938]                  COPIEDPTR:	dw _3909h
 15512 00003830 [6043]                  		dw COPY_NUM ; _4470h
 15513 00003832 2539642046696C6528-     _3922h:		db '%9d File(s) ',0
 15513 0000383B 73292000           
 15514 0000383F [3238]                  DIRMESPTR:	dw _3922h
 15515 00003841 [6743]                  		dw DIR_NUM  ; _4477h
 15516 00003843 25396C642062797465-     _3933h:		db '%9ld bytes free',0Dh,0Ah,0
 15516 0000384C 7320667265650D0A00 
 15517 00003855 [4338]                  BYTEMESPTR:	dw _3933h
 15518 00003857 [6943]                  		dw BYTES_FREE   ; _4479h
 15519 00003859 [6B43]                  		dw BYTES_FREE+2 ; _447Bh
 15520 0000385B 496E76616C69642064-     _394Bh:		db 'Invalid drive specification',0Dh,0Ah,0
 15520 00003864 726976652073706563-
 15520 0000386D 696669636174696F6E-
 15520 00003876 0D0A00             
 15521 00003879 [5B38]                  BADDRVPTR:	dw _394Bh
 15522 0000387B 0D0A                    _396Bh:		db 0Dh,0Ah
 15523 0000387D 436F64652070616765-     		db 'Code page %5d not prepared for system',0Dh,0Ah,0
 15523 00003886 20253564206E6F7420-
 15523 0000388F 707265706172656420-
 15523 00003898 666F72207379737465-
 15523 000038A1 6D0D0A00           
 15524 000038A5 [7B38]                  CPNOTSETPTR:	dw _396Bh
 15525 000038A7 [203E]                  		dw SYSTEM_CPAGE ; _3F2Fh
 15526 000038A9 0D0A                    _3999h:		db 0Dh,0Ah
 15527 000038AB 436F64652070616765-     		db 'Code page %5d not prepared for all devices',0Dh,0Ah,0
 15527 000038B4 20253564206E6F7420-
 15527 000038BD 707265706172656420-
 15527 000038C6 666F7220616C6C2064-
 15527 000038CF 6576696365730D0A00 
 15528 000038D8 [A938]                  CPNOTALLPTR:	dw _3999h
 15529 000038DA [203E]                  		dw SYSTEM_CPAGE ; _3F2Fh
 15530 000038DC 0D0A                    _39CCh:		db 0Dh,0Ah
 15531 000038DE 41637469766520636F-     		db 'Active code page: %5d',0Dh,0Ah,0
 15531 000038E7 646520706167653A20-
 15531 000038F0 2535640D0A00       
 15532 000038F6 [DC38]                  CPACTIVEPTR:	dw _39CCh
 15533 000038F8 [203E]                  		dw SYSTEM_CPAGE ; _3F2Fh
 15534 000038FA 43757272656E742064-     _39EAh:		db 'Current drive is no longer valid',0
 15534 00003903 72697665206973206E-
 15534 0000390C 6F206C6F6E67657220-
 15534 00003915 76616C696400       
 15535 0000391B [FA38]                  BADCURDRVPTR:	dw _39EAh
 15536 0000391D 537472696B65206120-     _3A0Dh:		db 'Strike a key when ready . . . ',0
 15536 00003926 6B6579207768656E20-
 15536 0000392F 7265616479202E202E-
 15536 00003938 202E2000           
 15537 0000393C [1D39]                  PAUSEMESPTR:	dw _3A0Dh
 15538 0000393E 496E76616C69642070-     _3A2Eh:		db 'Invalid parameter',0Dh,0Ah,0
 15538 00003947 6172616D657465720D-
 15538 00003950 0A00               
 15539 00003952 [3E39]                  BADPARMPTR:	dw _3A2Eh
 15540 00003954 53756E4D6F6E547565-     WEEKTAB:	db 'SunMonTueWedThuFriSat'
 15540 0000395D 576564546875467269-
 15540 00003966 536174             
 15541 00003969 0D0A                    _3A59h:		db 0Dh,0Ah
 15542 0000396B 496E76616C69642064-     		db 'Invalid date',0
 15542 00003974 61746500           
 15543 00003978 [6939]                  BADDATPTR:	dw _3A59h
 15544 0000397A 43757272656E742064-     _3A6Ah:		db 'Current date is ',0
 15544 00003983 6174652069732000   
 15545 0000398B [7A39]                  CURDATPTR:	dw _3A6Ah
 15546 0000398D 0D0A                    _3A7Dh:		db 0Dh,0Ah
 15547 0000398F 456E746572206E6577-     		db 'Enter new date ',0
 15547 00003998 20646174652000     
 15548 0000399F [8D39]                  NEWDATPTR:	dw _3A7Dh
 15549 000039A1 286D6D2D64642D7979-     _3A91h:		db '(mm-dd-yy): ',0
 15549 000039AA 293A2000           
 15550 000039AE [A139]                  USADATPTR:	dw _3A91h
 15551 000039B0 2864642D6D6D2D7979-     _3AA0h:		db '(dd-mm-yy): ',0
 15551 000039B9 293A2000           
 15552 000039BD [B039]                  EURDATPTR:	dw _3AA0h
 15553 000039BF 2879792D6D6D2D6464-     _3AAFh:		db '(yy-mm-dd): ',0
 15553 000039C8 293A2000           
 15554 000039CC [BF39]                  JAPDATPTR:	dw _3AAFh
 15555 000039CE 0D0A                    _3ABEh:		db 0Dh,0Ah
 15556 000039D0 496E76616C69642074-     		db 'Invalid time ',0
 15556 000039D9 696D652000         
 15557 000039DE [CE39]                  BADTIMPTR:	dw _3ABEh
 15558 000039E0 43757272656E742074-     _3AD0h:		db 'Current time is ',0
 15558 000039E9 696D652069732000   
 15559 000039F1 [E039]                  CURTIMPTR:	dw _3AD0h
 15560 000039F3 0D0A                    _3AE3h:		db 0Dh,0Ah
 15561 000039F5 456E746572206E6577-     		db 'Enter new time: ',0
 15561 000039FE 2074696D653A2000   
 15562 00003A06 [F339]                  NEWTIMPTR:	dw _3AE3h
 15563 00003A08 41726520796F752073-     _3AF8h:		db 'Are you sure (Y/N)?',0
 15563 00003A11 7572652028592F4E29-
 15563 00003A1A 3F00               
 15564 00003A1C [083A]                  SUREMESPTR:	dw _3AF8h
 15565 00003A1E 203C4449523E202020-     _3B0Eh:		db ' <DIR>   ',0
 15565 00003A27 00                 
 15566 00003A28 [1E3A]                  DMESPTR:	dw _3B0Eh
 15567 00003A2A 4D532D444F53205665-     _3B1Ah:		db 'MS-DOS Version %1d.%02d                     ',0
 15567 00003A33 7273696F6E20253164-
 15567 00003A3C 2E2530326420202020-
 15567 00003A45 202020202020202020-
 15567 00003A4E 202020202020202000 
 15568 00003A57 [2A3A]                  VERMESPTR:	dw _3B1Ah
 15569 00003A59 [6D43]                  		dw MAJOR_VER_NUM ; _447Dh
 15570 00003A5B [6F43]                  		dw MINOR_VER_NUM ; _447Fh
 15571 00003A5D 254300                  _3B4Dh:		db '%C',0
 15572 00003A60 [5D3A]                  ONECHRVALPTR:	dw _3B4Dh
 15573 00003A62 [7143]                  		dw ONE_CHAR_VAL	; _4481h
 15574 00003A64 20566F6C756D652069-     _3B54h:		db ' Volume in drive %c %s',0
 15574 00003A6D 6E2064726976652025-
 15574 00003A76 6320257300         
 15575 00003A7B [643A]                  VOLMESPTR:	dw _3B54h
 15576 00003A7D [7443]                  		dw VOL_DRV ; _4484h
 15577 00003A7F [7243]                  		dw VOLNAME_ADDR ; _4482h
 15578 00003A81 69732000                IS:		db 'is ',0
 15579 00003A85 686173206E6F206C61-     NOVOL:		db 'has no label',0
 15579 00003A8E 62656C00           
 15580 00003A92 496E76616C69642064-     _3B82h:		db 'Invalid directory',0Dh,0Ah,0
 15580 00003A9B 69726563746F72790D-
 15580 00003AA4 0A00               
 15581 00003AA6 [923A]                  BADCDPTR:	dw _3B82h
 15582 00003AA8 556E61626C6520746F-     _3B98h:		db 'Unable to create directory',0Dh,0Ah,0
 15582 00003AB1 206372656174652064-
 15582 00003ABA 69726563746F72790D-
 15582 00003AC3 0A00               
 15583 00003AC5 [A83A]                  BADMKDPTR:	dw _3B98h
 15584 00003AC7 496E76616C69642070-     _3BB7h:		db 'Invalid path, not directory,',0Dh,0Ah
 15584 00003AD0 6174682C206E6F7420-
 15584 00003AD9 6469726563746F7279-
 15584 00003AE2 2C0D0A             
 15585 00003AE5 6F7220646972656374-     		db 'or directory not empty',0Dh,0Ah,0
 15585 00003AEE 6F7279206E6F742065-
 15585 00003AF7 6D7074790D0A00     
 15586 00003AFE [C73A]                  BADRMDPTR:	dw _3BB7h
 15587 00003B00 4D7573742073706563-     _3BF0h:		db 'Must specify ON or OFF',0Dh,0Ah,0
 15587 00003B09 696679204F4E206F72-
 15587 00003B12 204F46460D0A00     
 15588 00003B19 [003B]                  BADONOFFPTR:	dw _3BF0h
 15589 00003B1B 204469726563746F72-     _3C0Bh:		db ' Directory of  %S',0Dh,0Ah,0
 15589 00003B24 79206F66202025530D-
 15589 00003B2D 0A00               
 15590 00003B2F [1B3B]                  DIRHEADPTR:	dw _3C0Bh
 15591 00003B31 [7543]                  		dw VOL_DIR ; _4485h
 15592 00003B33 4E6F205061746800        _3C23h:		db 'No Path',0
 15593 00003B3B [333B]                  NULLPATHPTR:	dw _3C23h
 15594 00003B3D 504154483D              PATH_TEXT:	db 'PATH='
 15595 00003B42 50524F4D50543D          PROMPT_TEXT:	db 'PROMPT='
 15596 00003B49 434F4D535045433D        COMSPEC_TEXT:	db 'COMSPEC='
 15597 00003B51 496E76616C69642064-     _3C41h:		db 'Invalid drive in search path',0Dh,0Ah,0
 15597 00003B5A 7269766520696E2073-
 15597 00003B63 656172636820706174-
 15597 00003B6C 680D0A00           
 15598 00003B70 [513B]                  BADPMESPTR:	dw _3C41h
 15599 00003B72 496E76616C69642064-     _3C62h:		db 'Invalid device',0Dh,0Ah,0
 15599 00003B7B 65766963650D0A00   
 15600 00003B83 [723B]                  BADDEVPTR:	dw _3C62h
 15601 00003B85 4C6162656C206E6F74-     _3C75h:		db 'Label not found',0Dh,0Ah,0
 15601 00003B8E 20666F756E640D0A00 
 15602 00003B97 [853B]                  BADLABPTR:	dw _3C75h
 15603 00003B99 53796E746178206572-     _3C89h:		db 'Syntax error',0Dh,0Ah,0
 15603 00003BA2 726F720D0A00       
 15604 00003BA8 [993B]                  SYNTMESPTR:	dw _3C89h
 15605 00003BAA 0D464F522063616E6E-     _3C9Ah:		db 0Dh,'FOR cannot be nested',0Dh,0Ah,0
 15605 00003BB3 6F74206265206E6573-
 15605 00003BBC 7465640D0A00       
 15606 00003BC2 [AA3B]                  FORNESTMESTR:	dw _3C9Ah
 15607 00003BC4 496E73756666696369-     _3CB4h:		db 'Insufficient memory',0Dh,0Ah,0
 15607 00003BCD 656E74206D656D6F72-
 15607 00003BD6 790D0A00           
 15608 00003BDA [C43B]                  INSFMEMMESPTR:	dw _3CB4h
 15609 00003BDC 496E7465726D656469-     _3CCCh:		db 'Intermediate file error during pipe',0Dh,0Ah,0
 15609 00003BE5 6174652066696C6520-
 15609 00003BEE 6572726F7220647572-
 15609 00003BF7 696E6720706970650D-
 15609 00003C00 0A00               
 15610 00003C02 [DC3B]                  PIPEEMESPTR:	dw _3CCCh
 15611 00003C04 43616E6E6F7420646F-     _3CF4h:		db 'Cannot do binary reads from a device',0Dh,0Ah,0
 15611 00003C0D 2062696E6172792072-
 15611 00003C16 656164732066726F6D-
 15611 00003C1F 206120646576696365-
 15611 00003C28 0D0A00             
 15612 00003C2B [043C]                  INBDEVPTR:	dw _3CF4h
 15613 00003C2D 425245414B20697320-     _3D1Dh:		db 'BREAK is ',0
 15613 00003C36 00                 
 15614 00003C37 [2D3C]                  CTRLMESPTR:	dw _3D1Dh
 15615 00003C39 564552494659206973-     _3D29h:		db 'VERIFY is ',0
 15615 00003C42 2000               
 15616 00003C44 [393C]                  VERIMESPTR:	dw _3D29h
 15617 00003C46 4543484F2069732000      _3D36h:		db 'ECHO is ',0
 15618 00003C4F [463C]                  ECHOMESPTR:	dw _3D36h
 15619 00003C51 6F66660D0A00            _3D41h:		db 'off',0Dh,0Ah,0
 15620 00003C57 [513C]                  OFFMESPTR:	dw _3D41h
 15621 00003C59 6F6E0D0A00              _3D49h:		db 'on',0Dh,0Ah,0
 15622 00003C5E [593C]                  ONMESPTR:	dw _3D49h
 15623 00003C60 496E76616C69642070-     _3D50h:		db 'Invalid path or file name',0Dh,0Ah,0
 15623 00003C69 617468206F72206669-
 15623 00003C72 6C65206E616D650D0A-
 15623 00003C7B 00                 
 15624 00003C7C [603C]                  BADCPMESPTR:	dw _3D50h
 15625 00003C7E 496E76616C6964206E-     _3D6Eh:		db 'Invalid number of parameters',0Dh,0Ah,0
 15625 00003C87 756D626572206F6620-
 15625 00003C90 706172616D65746572-
 15625 00003C99 730D0A00           
 15626 00003C9D [7E3C]                  BADARGSPTR:	dw _3D6Eh
 15627 00003C9F 4572726F7220777269-     _3D8Fh:		db 'Error writing to device',0Dh,0Ah,0
 15627 00003CA8 74696E6720746F2064-
 15627 00003CB1 65766963650D0A00   
 15628 00003CB9 [9F3C]                  DEVWMESPTR:	dw _3D8Fh
 15629 00003CBB 0D0A00                  _3DABh:		db 0Dh,0Ah,0
 15630 00003CBE [BB3C]                  ACRLFPTR:	dw _3DABh
 15631 00003CC0 08                      _3DB0h:		db 8
 15632 00003CC1 20                      		db 20h
 15633 00003CC2 08                      		db 8
 15634 00003CC3 00                      		db 0
 15635 00003CC4 [C03C]                  DBACKPTR:	dw _3DB0h
 15636 00003CC6 79                      small_y:	db 'y'
 15637 00003CC7 6E                      small_n:	db 'n'
 15638 00003CC8 59                      CAPITAL_Y:	db 'Y'
 15639 00003CC9 4E                      CAPITAL_N:	db 'N'
 15640 00003CCA 041B5B324A              CLSSTRING:	db 4,1Bh,'[2J'	; ANSI Clear screen
 15641                                  PROMPT_TABLE:
 15642 00003CCF 42                      		db 'B' ; 42h
 15643 00003CD0 [D813]                  		dw PRINT_B
 15644 00003CD2 44                      		db 'D' ; 44h
 15645 00003CD3 [1629]                  		dw PRINT_DATE
 15646 00003CD5 45                      		db 'E' ; 45h
 15647 00003CD6 [CC13]                  		dw PRINT_ESC
 15648 00003CD8 47                      		db 'G' ; 47h
 15649 00003CD9 [D013]                  		dw PRINT_G
 15650 00003CDB 48                      		db 'H' ; 48h
 15651 00003CDC [C213]                  		dw PRINT_BACK
 15652 00003CDE 4C                      		db 'L' ; 4Ch
 15653 00003CDF [D413]                  		dw PRINT_L
 15654 00003CE1 4E                      		db 'N' ; 4Eh
 15655 00003CE2 [ED13]                  		dw PRINT_DRIVE
 15656 00003CE4 50                      		db 'P' ; 50h
 15657 00003CE5 [F513]                  		dw BUILD_DIR_FOR_PROMPT
 15658 00003CE7 51                      		db 'Q' ; 51h
 15659 00003CE8 [C813]                  		dw PRINT_EQ
 15660 00003CEA 54                      		db 'T' ; 54h
 15661 00003CEB [B221]                  		dw PRINT_TIME
 15662 00003CED 56                      		db 'V' ; 56h
 15663 00003CEE [5613]                  		dw PRINT_VERSION
 15664 00003CF0 5F                      		db '_' ; 5Fh
 15665 00003CF1 [3919]                  		dw CRLF2
 15666 00003CF3 24                      		db '$' ; 24h
 15667 00003CF4 [DA13]                  		dw PRINT_CHAR
 15668 00003CF6 00                      		db 0
 15669                                  
 15670                                  		; Table of IF conditionals
 15671                                  IFTAB:
 15672 00003CF7 03                      		db 3	; First byte is count
 15673 00003CF8 4E4F54                  		db 'NOT'
 15674 00003CFB [7A09]                  		dw IFNOT
 15675 00003CFD 0A                      		db 10
 15676 00003CFE 4552524F524C455645-     		db 'ERRORLEVEL'
 15676 00003D07 4C                 
 15677 00003D08 [3D0A]                  		dw IFERLEV
 15678 00003D0A 05                      		db 5
 15679 00003D0B 4558495354              		db 'EXIST'
 15680 00003D10 [D109]                  		dw IFEXISTS
 15681 00003D12 00                      		db 0
 15682                                  
 15683                                  		; Table for internal command names
 15684                                  
 15685 00003D13 03                      COMTAB:		db 3
 15686 00003D14 444952                  		db 'DIR'
 15687 00003D17 03                      		db 3
 15688 00003D18 [AC0E]                  		dw CATALOG
 15689 00003D1A 04                      		db 4
 15690 00003D1B 43414C4C                		db 'CALL'
 15691 00003D1F 02                      		db 2
 15692 00003D20 [B20A]                  		dw _$CALL
 15693 00003D22 04                      		db 4
 15694 00003D23 43484350                		db 'CHCP'
 15695 00003D27 02                      		db 2
 15696 00003D28 [9915]                  		dw CHCP
 15697 00003D2A 06                      		db 6
 15698 00003D2B 52454E414D45            		db 'RENAME'
 15699 00003D31 01                      		db 1
 15700 00003D32 [E811]                  		dw CRENAME
 15701 00003D34 03                      		db 3
 15702 00003D35 52454E                  		db 'REN'
 15703 00003D38 01                      		db 1
 15704 00003D39 [E811]                  		dw CRENAME
 15705 00003D3B 05                      		db 5
 15706 00003D3C 4552415345              		db 'ERASE'
 15707 00003D41 01                      		db 1
 15708 00003D42 [7F11]                  		dw ERASE
 15709 00003D44 03                      		db 3
 15710 00003D45 44454C                  		db 'DEL'
 15711 00003D48 01                      		db 1
 15712 00003D49 [7F11]                  		dw ERASE
 15713 00003D4B 04                      		db 4
 15714 00003D4C 54595045                		db 'TYPE'
 15715 00003D50 01                      		db 1
 15716 00003D51 [5A12]                  		dw TYPEFIL
 15717 00003D53 03                      		db 3
 15718 00003D54 52454D                  		db 'REM'
 15719 00003D57 02                      		db 2
 15720 00003D58 [0401]                  		dw TCOMMAND
 15721 00003D5A 04                      		db 4
 15722 00003D5B 434F5059                		db 'COPY'
 15723 00003D5F 03                      		db 3
 15724 00003D60 [6C29]                  		dw COPY
 15725 00003D62 05                      		db 5
 15726 00003D63 5041555345              		db 'PAUSE'
 15727 00003D68 02                      		db 2
 15728 00003D69 [7311]                  		dw PAUSE
 15729 00003D6B 04                      		db 4
 15730 00003D6C 44415445                		db 'DATE'
 15731 00003D70 02                      		db 2
 15732 00003D71 [8E20]                  		dw DATE
 15733 00003D73 04                      		db 4
 15734 00003D74 54494D45                		db 'TIME'
 15735 00003D78 00                      		db 0
 15736 00003D79 [9F21]                  		dw CTIME
 15737 00003D7B 03                      		db 3
 15738 00003D7C 564552                  		db 'VER'
 15739 00003D7F 00                      		db 0
 15740 00003D80 [4D13]                  		dw VERSION
 15741 00003D82 03                      		db 3
 15742 00003D83 564F4C                  		db 'VOL'
 15743 00003D86 01                      		db 1
 15744 00003D87 [F712]                  		dw VOLUME
 15745 00003D89 02                      		db 2
 15746 00003D8A 4344                    		db 'CD'
 15747 00003D8C 01                      		db 1
 15748 00003D8D [7918]                  		dw _$CHDIR
 15749 00003D8F 05                      		db 5
 15750 00003D90 4348444952              		db 'CHDIR'
 15751 00003D95 01                      		db 1
 15752 00003D96 [7918]                  		dw _$CHDIR
 15753 00003D98 02                      		db 2
 15754 00003D99 4D44                    		db 'MD'
 15755 00003D9B 01                      		db 1
 15756 00003D9C [BB18]                  		dw _$MKDIR
 15757 00003D9E 05                      		db 5
 15758 00003D9F 4D4B444952              		db 'MKDIR'
 15759 00003DA4 01                      		db 1
 15760 00003DA5 [BB18]                  		dw _$MKDIR
 15761 00003DA7 02                      		db 2
 15762 00003DA8 5244                    		db 'RD'
 15763 00003DAA 01                      		db 1
 15764 00003DAB [FD18]                  		dw _$RMDIR
 15765 00003DAD 05                      		db 5
 15766 00003DAE 524D444952              		db 'RMDIR'
 15767 00003DB3 01                      		db 1
 15768 00003DB4 [FD18]                  		dw _$RMDIR
 15769 00003DB6 05                      		db 5
 15770 00003DB7 425245414B              		db 'BREAK'
 15771 00003DBC 00                      		db 0
 15772 00003DBD [4E28]                  		dw CNTRLC
 15773 00003DBF 06                      		db 6
 15774 00003DC0 564552494659            		db 'VERIFY'
 15775 00003DC6 00                      		db 0
 15776 00003DC7 [8028]                  		dw VERIFY
 15777 00003DC9 03                      		db 3
 15778 00003DCA 534554                  		db 'SET'
 15779 00003DCD 02                      		db 2
 15780 00003DCE [6E16]                  		dw ADD_NAME_TO_ENVIRONMENT
 15781 00003DD0 06                      		db 6
 15782 00003DD1 50524F4D5054            		db 'PROMPT'
 15783 00003DD7 02                      		db 2
 15784 00003DD8 [5416]                  		dw ADD_PROMPT
 15785 00003DDA 04                      		db 4
 15786 00003DDB 50415448                		db 'PATH'
 15787 00003DDF 02                      		db 2
 15788 00003DE0 [5C14]                  		dw PATH
 15789 00003DE2 04                      		db 4
 15790 00003DE3 45584954                		db 'EXIT'
 15791 00003DE7 00                      		db 0
 15792 00003DE8 [2616]                  		dw _$EXIT
 15793 00003DEA 04                      		db 4
 15794 00003DEB 43545459                		db 'CTTY'
 15795 00003DEF 03                      		db 3
 15796 00003DF0 [3515]                  		dw CTTY
 15797 00003DF2 04                      		db 4
 15798 00003DF3 4543484F                		db 'ECHO'
 15799 00003DF7 02                      		db 2
 15800 00003DF8 [0B28]                  		dw ECHO
 15801 00003DFA 04                      		db 4
 15802 00003DFB 474F544F                		db 'GOTO'
 15803 00003DFF 02                      		db 2
 15804 00003E00 [E60A]                  		dw GOTO
 15805 00003E02 05                      		db 5
 15806 00003E03 5348494654              		db 'SHIFT'
 15807 00003E08 02                      		db 2
 15808 00003E09 [6B0A]                  		dw SHIFT
 15809 00003E0B 02                      		db 2
 15810 00003E0C 4946                    		db 'IF'
 15811 00003E0E 02                      		db 2
 15812 00003E0F [2A09]                  		dw _$IF
 15813 00003E11 03                      		db 3
 15814 00003E12 464F52                  		db 'FOR'
 15815 00003E15 02                      		db 2
 15816 00003E16 [3F0D]                  		dw _$FOR
 15817 00003E18 03                      		db 3
 15818 00003E19 434C53                  		db 'CLS'
 15819 00003E1C 00                      		db 0
 15820 00003E1D [CA14]                  		dw CLS
 15821 00003E1F 00                      		db 0
 15822                                  
 15823                                  ; 01/03/2023
 15824                                  ;CAPITAL_A:	db 'A'
 15825                                  ;VBAR:		db '|'
 15826                                  ;LABRACKET:	db '<' ; 3Ch
 15827                                  ;RABRACKET:	db '>' ; 3Eh
 15828                                  ;DOLLAR:	db '$'
 15829                                  ;LPAREN:	db '('
 15830                                  ;RPAREN:	db ')'
 15831                                  ;NULLRPAREN:	db ')' ; 29h
 15832                                  ;		db 0
 15833                                  ;IN_WORD:	db 'I','N'
 15834                                  ;DO_WORD:	db 'D','O'
 15835                                  ;STAR:		db '*'
 15836                                  ;CHAR_SUB:	db '-' 
 15837                                  ;PLUS_CHR:	db '+'
 15838                                  ;CHAR_L:	db 'L'
 15839                                  ;char_l:	db 'l'
 15840                                  ;small_a:	db 'a'
 15841                                  ;small_z:	db 'z'
 15842                                  ;CHAR_D:	db 'D'
 15843                                  ;CHAR_C:	db 'C'
 15844                                  ;CHAR_S:	db 'S'
 15845                                  ;CHAR_X:	db 'X'
 15846                                  ;DOT_CHR:	db '.' 
 15847                                  ;DOT_QMARK:	dw '?.'  ; dw 2E3Fh
 15848                                  ;		db ','
 15849                                  ;TIMECHARS:	dw ':.'  ; dw 2E3Ah 	 
 15850                                  ;MNCHR:		db 'p'
 15851                                  
 15852 00003E20 0000                    SYSTEM_CPAGE:	dw 0
 15853                                  
 15854 00003E22 2E434F4D                COMEXT:		db '.COM'
 15855 00003E26 2E455845                EXEEXT:		db '.EXE'
 15856 00003E2A 2E424154                BATEXT:		db '.BAT'
 15857 00003E2E 5642415057              SWITCH_LIST:	db 'VBAPW'
 15858 00003E33 2000                    BATBUFLEN:	dw BATLEN ; 32
 15859                                  
 15860                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3F44h
 15861                                  
 15862                                  TRANDATAEND:
 15863                                  
 15864                                  ;============================================================================
 15865                                  ; TSPC.ASM, MSDOS 6.0, 1991
 15866                                  ;============================================================================
 15867                                  ; 29/09/2018 - Retro DOS v3.0
 15868                                  
 15869                                  ;TITLE	COMMAND Transient Uninitialized DATA
 15870                                  
 15871                                  ;The TRANSPACE segment contains variable data that is considered
 15872                                  ;volatile between command cycles, and therefore is not included in the
 15873                                  ;transient checksum area. Contents of these variables MUST be
 15874                                  ;initialized before use, and must not be relied upon from command
 15875                                  ;cycle to command cycle.
 15876                                  ;
 15877                                  ;No constant data values should be stored here.
 15878                                  
 15879                                  ; ---------------------------------------------------------------------------
 15880                                  ; START OF UNITIALIZED DATA
 15881                                  ; ---------------------------------------------------------------------------	
 15882                                  
 15883                                  ;	times 12 db 0
 15884                                  
 15885 00003E35 90<rep Bh>              align 16
 15886                                  
 15887                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3F50h
 15888                                  
 15889 00003E40 00                      PRINTF_LEFT:	db 0
 15890 00003E41 00                      PRINTF_LONG:	db 0
 15891 00003E42 00                      PRINTF_HEX:	db 0
 15892 00003E43 00                      TABLE_INDEX:	db 0
 15893 00003E44 0000                    PRINTF_WIDTH:	dw 0
 15894 00003E46 0000                    PRINTF_BASE:	dw 0
 15895 00003E48 00                      PAD_CHAR:	db 0
 15896 00003E49 0000                    PRINTF_HANDLE:	dw 0
 15897 00003E4B 00<rep 64h>             PRINTF_BUF: times 100 db 0
 15898                                  PRINTF_BUF_END: ; 30/09/2018
 15899                                  
 15900                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3FBFh
 15901                                  
 15902 00003EAF 00<rep 57h>             SRCXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
 15903 00003F06 00<rep 57h>             TRGXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
 15904 00003F5D 00<rep 83h>             UCOMBUF:  times COMBUFLEN+3  db 0 ; 131	; Raw console buffer
 15905 00003FE0 00<rep 83h>             COMBUF:	  times COMBUFLEN+3  db 0 ; 131	; Cooked console buffer
 15906 00004063 00<rep 46h>             USERDIR1: times	DIRSTRLEN+3  db 0 ; 70  ; Storage for users current directory
 15907 000040A9 00<rep 83h>             EXECPATH: times COMBUFLEN+3  db 0 ; 131 ; Path for external command
 15908 0000412C 00<rep 53h>             RE_INSTR: times DIRSTRLEN+16 db 0 ; 83  ; path for input to redirection
 15909                                  
 15910                                  ; Variables passed up from resident	; in the Resident portion: (initial values)	
 15911 0000417F 0000                    HEADCALL:	dw 0			; TRANVARS  (dw THEADFIX)
 15912 00004181 0000                    RESSEG:		dw 0			; MYSEG     (dw 0) 	 	
 15913 00004183 0000                    TPA:		dw 0			; LTPA	    (dw 0)	
 15914 00004185 00                      SWITCHAR:	db 0			; RSWITCHAR (db '-')
 15915 00004186 00                      DIRCHAR:	db 0			; RDIRCHAR  (db '/')
 15916 00004187 00000000                EXEC_ADDR:	dd 0			; 	    (dw EXT_EXEC)	 
 15917                                  					; MYSEG1    (dw 0)	
 15918 0000418B 00000000                RCH_ADDR:	dd 0			;	    (dw TREMCHECK) 	
 15919                                  					; MYSEG2    (dw 0)	
 15920 0000418F 0000                    		dw 0			; RESTEST   (dw 0)	
 15921 00004191 0000                    TRAN_TPA:	dw 0			; RES_TPA   (dw 0)	
 15922                                  
 15923 00004193 00                      CHKDRV:		db 0
 15924                                  IFNOTFLAG:
 15925                                  FILTYP:
 15926 00004194 00                      RDEOF:		db 0			; Misc flags
 15927 00004195 00                      CURDRV:		db 0
 15928                                  PARM1:
 15929 00004196 00                      CONCAT:		db 0
 15930                                  PARM2:
 15931 00004197 00                      ARGC:		db 0
 15932 00004198 0000                    COMSW:		dw 0			; Switches between command and 1st arg
 15933 0000419A 0000                    ARG1S:		dw 0			; Switches between 1st and 2nd arg
 15934                                  ARG2S:					; Switches after 2nd arg		
 15935 0000419C 0000                    DESTSWITCH:	dw 0
 15936                                  ARGTS:
 15937 0000419E 0000                    ALLSWITCH:	dw 0			; ALL switches except for COMSW
 15938 000041A0 00                      CFLAG:		db 0
 15939                                  DESTCLOSED:
 15940 000041A1 00                      SPECDRV:	db 0
 15941 000041A2 0000                    BYTCNT:		dw 0			; Size of buffer between RES and TRANS
 15942 000041A4 0000                    NXTADD:		dw 0
 15943 000041A6 00                      FRSTSRCH:	db 0
 15944                                  ;LeftOnLine:	db 0			; entries left on line u.b. DIR
 15945                                  ;PerLine:	db 0			; entries/line u.b. DIR
 15946 000041A7 00                      LINCNT:		db 0
 15947 000041A8 00                      LINLEN:		db 0
 15948                                  ;LeftOnPage:	dw 0			; lines left on page u.b. DIR
 15949 000041A9 0000                    FILECNT:	dw 0			; file count u.b. DIR
 15950                                  ;FileSiz:	dd 0			; file size u.b. DIR
 15951                                  
 15952                                  ;		Note:  keep FileCntTotal through csecUsedTotal together!
 15953                                  ;
 15954                                  ;FileCntTotal:	dd 0			; total file count u.b. DIR
 15955                                  ;FileSizTotal:	dd 0			; total file size u.b. DIR
 15956                                  
 15957                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 42BBh
 15958                                  
 15959 000041AB 00<rep 50h>             CHARBUF:  times	80 db 0			;line byte character buffer for xenix write
 15960                                  DESTFCB2:
 15961 000041FB 00                      IDLEN:		db 0
 15962 000041FC 00<rep 8h>              ID:	  times	8  db 0
 15963 00004204 00<rep 3h>              COM:	  times	3  db 0 
 15964 00004207 00<rep 25h>             DEST:	  times 37 db 0
 15965 0000422C 00<rep Bh>              DESTNAME: times 11 db 0
 15966                                  DESTDIR:
 15967 00004237 00<rep 43h>             DESTFCB:  times DIRSTRLEN db 0 ; 67	; Directory for PATH searches
 15968                                  GOTOLEN:	; word
 15969                                  BWDBUF: 	; byte
 15970                                  EXEFCB: 	; word
 15971 0000427A 00<rep 46h>             DIRBUF:	times DIRSTRLEN+3 db 0 ; 70
 15972                                  
 15973                                  DIRBUF_ATTRIB1 equ DIRBUF+19  ; byte	; INT 21h AH=11h (8+DIR_ENTRY struc)
 15974                                  DIRBUF_ATTRIB2 equ DIRBUF+21  ; byte	; INT 21h AH=4Eh (FIND_BUF struc)
 15975                                  DIRBUF_FTIME   equ DIRBUF+30  ; word
 15976                                  DIRBUF_FDATE   equ DIRBUF+32  ; word	
 15977                                  DIRBUF_FSIZ_L  equ DIRBUF+36  ; word
 15978                                  DIRBUF_FSIZ_H  equ DIRBUF+38  ; word
 15979                                  
 15980 000042C0 00<rep Ch>              SDIRBUF:  times 12 db 0	
 15981 000042CC 0000                    _BITS:		dw 0
 15982 000042CE 0000                    PATHCNT:	dw 0
 15983 000042D0 0000                    PATHPOS:	dw 0
 15984 000042D2 0000                    PATHSW:		dw 0
 15985                                  ;AttrSpecified:	db 0			; attribute bits u.b. DIR
 15986                                  ;AttrSelect:	db 0			; attribute bits u.b. DIR
 15987 000042D4 00                      LINPERPAG:	db 0
 15988 000042D5 00                      		db 0
 15989 000042D6 00                      COMMA:		db 0			; flag set if +,, occurs
 15990 000042D7 00                      PLUS_COMMA:	db 0			; flag set if +,, occurs
 15991                                  
 15992                                  ;dirflag: 	db 0			;AN015; set when pathcrunch called from DIR
 15993                                  ;parse_last:	dw 0			;AN018; used to hold parsing position
 15994                                  ;system_cpage:	dw 0			;AC001; used for CHCP variable
 15995                                  
 15996 000042D8 00<rep 80h>             ARG_BUF:  times 128 db 0   ; _43E8h	
 15997 00004358 0000                    STRING_PTR_1:	dw 0	   ; _4468h	
 15998 0000435A 0000                    FILESIZE_L:	dw 0	   ; _446Ah		
 15999 0000435C 0000                    FILESIZE_H:	dw 0	   ; _446Ch	
 16000 0000435E 0000                    STRING_PTR_2:	dw 0	   ; _446Eh	
 16001                                  
 16002 00004360 0000                    COPY_NUM:	dw 0
 16003 00004362 00<rep 4h>              	  times 4 db 0 ; MSDOS 3.3 (unused bytes)
 16004 00004366 00                      CPYFLAG:	db 0
 16005 00004367 0000                    DIR_NUM:	dw 0
 16006 00004369 0000                    BYTES_FREE:	dw 0
 16007 0000436B 0000                    		dw 0
 16008 0000436D 0000                    MAJOR_VER_NUM:	dw 0
 16009 0000436F 0000                    MINOR_VER_NUM:	dw 0
 16010 00004371 00                      ONE_CHAR_VAL:	db 0
 16011                                  		;db 0
 16012 00004372 0000                    VOLNAME_ADDR:	dw 0 ; MSDOS 3.3
 16013 00004374 00                      VOL_DRV:	db 0
 16014 00004375 0000                    VOL_DIR:	dw 0 ; MSDOS 3.3
 16015                                  
 16016 00004377 00                      ROM_CALL:	db 0			; flag for rom function
 16017 00004378 0000                    ROM_IP:		dw 0
 16018 0000437A 0000                    ROM_CS:		dw 0
 16019                                  
 16020                                  DESTVARS:
 16021 0000437C 00                      DESTISDIR:	db 0
 16022 0000437D 00                      DESTSIZ:	db 0
 16023 0000437E 0000                    DESTTAIL:	dw 0
 16024 00004380 00                      DESTINFO:	db 0
 16025 00004381 00<rep 57h>             DESTBUF:  times	DIRSTRLEN+20 db 0 ; 87
 16026                                  ENDDESTBUF:
 16027                                  
 16028 000043D8 0000                    DESTHAND:	dw 0
 16029 000043DA 00                      DESTISDEV:	db 0
 16030 000043DB 00                      FIRSTDEST:	db 0
 16031 000043DC 00                      MELCOPY:	db 0
 16032 000043DD 0000                    MELSTART:	dw 0
 16033                                  
 16034                                  SRCVARS:
 16035 000043DF 00                      SRCISDIR:	db 0
 16036 000043E0 00                      SRCSIZ:		db 0
 16037 000043E1 0000                    SRCTAIL:	dw 0
 16038 000043E3 00                      SRCINFO:	db 0
 16039 000043E4 00<rep 57h>             SRCBUF:   times	DIRSTRLEN+20 db 0 ; 87
 16040                                  
 16041 0000443B 0000                    SRCHAND:	dw 0
 16042 0000443D 00                      SRCISDEV:	db 0
 16043                                  
 16044 0000443E 00<rep 57h>             SCANBUF:  times DIRSTRLEN+20 db 0 ; 87
 16045                                  
 16046 00004495 0000                    SRCPT:		dw 0
 16047 00004497 00                      INEXACT:	db 0
 16048 00004498 00                      		db 0 ; MSDOS 3.3 
 16049 00004499 00                      NOWRITE:	db 0
 16050 0000449A 00                      BINARY:		db 0
 16051 0000449B 0000                    WRITTEN:	dw 0
 16052 0000449D 00                      TERMREAD:	db 0
 16053 0000449E 00                      ASCII:		db 0
 16054 0000449F 00                      PLUS:		db 0
 16055 000044A0 00                      OBJCNT:		db 0			; Used in copy
 16056 000044A1 0000                    CPDATE:		dw 0
 16057 000044A3 0000                    CPTIME:		dw 0
 16058                                  
 16059                                  ;OFilePtr_Lo:	dw 0			; original file ptr for COPY when
 16060                                  ;OFilePtr_Hi:	dw 0			; 1st source is also destination
 16061                                  ;OCtrlZ:	db 0			; original ctrl+Z for COPY when ditto
 16062                                  
 16063 000044A5 0000                    BATHAND:	dw 0			; Batch handle
 16064 000044A7 0000                    STARTEL:	dw 0
 16065 000044A9 00                      ELCNT:		db 0
 16066 000044AA 00                      ELPOS:		db 0
 16067 000044AB 00<rep Bh>              SOURCE:   times	11 db 0
 16068                                  
 16069 000044B6 00                      ext_entered:	db 0			;AN005;
 16070                                  
 16071                                  ;display_ioctl	db 0			;AN000; info level
 16072                                  ;		db 0			;AN000; reserved
 16073                                  ;		dw crt_ioctl_ln		;AN000; length of data
 16074                                  ;		dw 0			;AN000; control flags
 16075                                  ;display_mode:	db 0			;AN000; display mode, colors
 16076                                  ;		db 0			;AN000; reserved
 16077                                  ;		dw 0			;AN023; colors
 16078                                  ;		dw 0			;AN000; display width (PELS)
 16079                                  ;		dw 0			;AN000; display length (PELS)
 16080                                  ;display_width:	dw 0			;AN000; display width
 16081                                  ;linperpag:	dw linesperpage		;AN000; display length (default to linesperpage)
 16082                                  ;
 16083                                  ;vol_ioctl_buf:				;AN000; buffer for ioctl volume label/serial call
 16084                                  ;		dw 0			;AN000; info level
 16085                                  ;vol_serial:	dd 0			;AN000; volume serial number
 16086                                  ;vol_label: times 11 db 20h ; " "	;AN000; volume label - init to blanks
 16087                                  ;	    times 8  db 20h ; " "       ;AN000; file system type
 16088                                  
 16089 000044B7 00                      EXPAND_STAR:	db 0
 16090                                  
 16091                                  ;msg_flag:	db 0			;AN022; flag set if non-utility message issued
 16092                                  ;msg_numb:	dw 0			;AN022; set with extended error message issued
 16093                                  ;append_exec:	db 0			;AN041; set if internal append executed
 16094                                  ;print_err_flag: dw 0			;AN000; flag set if error during sysdispmsg
 16095                                  ;subst_buffer: times parm_block_size*2 db 0 ;AN061;
 16096                                  
 16097 000044B8 00                      COMSPEC_FLAG:	db 0 ; MSDOS 3.3
 16098                                  
 16099                                  ; Data declarations taken out of parse.asm
 16100                                  
 16101                                  ; MSDOS 6.0
 16102                                  ;arg	arg_unit	<>		; pointers, arg count, string buffer
 16103                                  ;argbufptr	dw	?		; index for argv[].argpointer
 16104                                  ;tpbuf		db	128   DUP (?)	; temporary buffer
 16105                                  ;LAST_ARG	dw	?		; point at which to accumulate switch info
 16106                                  ;comptr		dw	?		; ptr into combuf
 16107                                  
 16108                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 45C9h
 16109                                  ARG:
 16110                                  ARG_ARGV:
 16111 000044B9 0000                    ARGV0_ARGPOINTER: dw 0	; ARGV[0]
 16112 000044BB 00                      ARGV0_ARG_FLAGS:  db 0
 16113 000044BC 0000                    ARGV0_ARGSTARTEL: dw 0
 16114 000044BE 0000                    ARGV0_ARGLEN:	  dw 0
 16115 000044C0 0000                    ARGV0_ARGSW_WORD: dw 0
 16116 000044C2 0000                    ARGV0_OCOMPTR:	  dw 0
 16117                                  
 16118 000044C4 0000                    ARGV1_ARGPOINTER: dw 0	; ARGV[1]	
 16119 000044C6 00<rep 5h>              	  times 5 db 0
 16120 000044CB 0000                    ARGV1_ARGSW_WORD: dw 0
 16121 000044CD 0000                    		  dw 0
 16122                                  
 16123 000044CF 0000                    ARGV2_ARGPOINTER: dw 0	; ARGV[2]
 16124 000044D1 00<rep 5h>              	  times 5 db 0
 16125 000044D6 0000                    ARGV2_ARGSW_WORD: dw 0
 16126 000044D8 0000                    		  dw 0
 16127                                  
 16128 000044DA 00<rep 29Fh>            	times 671 db 0  ; ARGV[3] to ARGV[63]
 16129                                  	
 16130 00004779 0000                    ARG_ARGVCNT:	dw 0
 16131 0000477B 0000                    ARG_ARGSWINFO:	dw 0
 16132                                  
 16133 0000477D 0000<rep 100h>          ARG_ARGBUF:    	times 256 dw 0	; times ARGBLEN dw 0 
 16134 0000497D 00<rep 80h>             ARG_ARGFORCOMBUF: times 128 db 0  ; times COMBUFLEN db 0 
 16135                                  
 16136                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4B0Dh
 16137                                  
 16138 000049FD 0000                    ARGBUFPTR:	dw 0			; index for argv[].argpointer
 16139 000049FF 00<rep 80h>             TPBUF:    times 128 db 0		; temporary buffer
 16140 00004A7F 0000                    LASTARG:	dw 0			; point at which to accumulate switch info
 16141 00004A81 0000                    COMPTR:		dw 0			; ptr into combuf
 16142                                  
 16143                                  ; Data declarations taken out of path.asm
 16144                                  ;fbuf	find_buf	<>			; dma buffer for findfirst/findnext
 16145                                  ;pathinfo	DW	3 DUP (?)		; ES, SI(old), and SI(new) of user path
 16146                                  ;psep_char	DB	?			; '/' or '\'
 16147                                  ;search_best	DB	(?)			; best code, best filename so far
 16148                                  ;fname_max_len	equ	13
 16149                                  ;search_best_buf DB	fname_max_len DUP (?)
 16150                                  ;search_curdir_buf DB	64 DUP (?)		; a place for CurDir info, if successful
 16151                                  ;search_error	DW	(?)			; address of error message to be printed
 16152                                  
 16153                                  FINDBUFLEN equ FIND_BUF.size ; 43
 16154                                  
 16155                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4B93h
 16156                                  
 16157 00004A83 00<rep 2Bh>             FBUF:	  times	FINDBUFLEN db 0 ; times 43 db 0
 16158                                  FBUF_PNAME equ FBUF+30			; packed name, 13 bytes
 16159                                  PATHINFO:
 16160 00004AAE 0000                    PATHINFO_0:	dw 0
 16161 00004AB0 0000                    PATHINFO_2:	dw 0
 16162 00004AB2 0000                    PATHINFO_4:	dw 0
 16163 00004AB4 00                      PSEP_CHAR:	db 0
 16164 00004AB5 00                      SEARCH_BEST:	db 0
 16165                                  ;FNAME_MAX_LEN equ 13
 16166 00004AB6 00<rep Dh>              SEARCH_BEST_BUF: times FNAME_MAX_LEN db 0 ; times 13 db 0
 16167 00004AC3 00<rep 40h>             SEARCH_CURDIR_BUF: times 64 db 0
 16168 00004B03 0000                    SEARCH_ERROR:	dw 0
 16169                                  
 16170                                  ; Data declarations taken out of tbatch.asm
 16171                                  
 16172                                  ;if_not_count	DW	?
 16173                                  ;
 16174                                  ;zflag		db	?		; Used by typefil to indicate ^Z's
 16175                                  ;
 16176                                  ;		DW	80H DUP(0)	; Init to 0 to make sure the linker is not fooled
 16177                                  ;STACK		LABEL	WORD
 16178                                  
 16179                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4C15h
 16180                                  
 16181 00004B05 0000                    IF_NOT_COUNT:	dw 0
 16182 00004B07 00                      ZFLAG:		db 0
 16183 00004B08 00<rep 100h>            	  times 256 db 0 	
 16184                                  STACK:
 16185                                  
 16186                                  ;INTERNATVARS	internat_block <>
 16187                                  ;		DB	(internat_block_max - ($ - INTERNATVARS)) DUP (?)
 16188                                  ;
 16189                                  ;;		Buffer for DOS function 64h (Get extended country information)
 16190                                  ;;		subfunctions 2, 4, 6, or 7:
 16191                                  ;
 16192                                  ;CountryPtrInfo	label	byte
 16193                                  ;CountryPtrId	db	?
 16194                                  ;CountryPtr	dd	?
 16195                                  ;		.erre	(($ - CountryPtrInfo) GE 5)
 16196                                  
 16197                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4D18h
 16198                                  
 16199                                  INTERNATVARS:	
 16200 00004C08 0000                    DATE_TIME_FORMAT: dw 0			; 0-USA, 1-EUR, 2-JAP
 16201 00004C0A 0000000000              CURRENCY_SYM: 	db 0,0,0,0,0 		; times 5 db 0	; Currency Symbol 5 bytes
 16202 00004C0F 0000                    THOUS_SEP:	db 0,0			; Thousands separator 2 bytes
 16203 00004C11 0000                    DECIMAL_SEP:	db 0,0			; Decimal separator 2 bytes
 16204 00004C13 0000                    DATE_SEP:	db 0,0			; Date separator 2 bytes
 16205 00004C15 0000                    TIME_SEP:	db 0,0			; Time separator 2 bytes	
 16206 00004C17 00                      BIT_FIELD:	db 0			; Bit values
 16207                                  					;   Bit 0 = 0 if currency symbol first
 16208                                  					;	  = 1 if currency symbol last
 16209                                  					;   Bit 1 = 0 if No space after currency symbol
 16210                                  					;	  = 1 if space after currency symbol
 16211 00004C18 00                      CURRENCY_CENTS:	db 0			; Number of places after currency dec point
 16212 00004C19 00                      TIME_24:	db 0			; 1 if 24 hour time, 0 if 12 hour time
 16213 00004C1A 00000000                MAP_CALL:	dw 0,0  ; dd 0 		; Address of case mapping call (DWORD)
 16214                                  					; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
 16215                                  					;  in pieces.
 16216 00004C1E 0000                    DATA_SEP:	db 0,0			; Data list separator character		
 16217                                  
 16218 00004C20 00<rep 8h>              		times 8 db 0
 16219                                  ;
 16220                                  ; Max size of the block returned by the INTERNATIONAL call
 16221                                  ;
 16222                                  INTERNAT_BLOCK_SIZE EQU	32
 16223                                  
 16224                                  BATLEN equ 32
 16225                                  	
 16226                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4D38h		
 16227                                  
 16228 00004C28 0000                    BATBUFPOS:	dw 0			; integer position in buffer of next byte
 16229                                  
 16230 00004C2A 00<rep 20h>             BATBUF:	  times	BATLEN db 0 ; times 32 db 0
 16231                                  
 16232 00004C4A 0000                    BATBUFEND:	dw 0
 16233                                  
 16234                                  ;TypeFilSiz:	dd 0			; stores size of file to be typed
 16235                                  
 16236                                  TRANSPACEEND:	; 4D4Ch ; End of MSDOS 3.3 COMMAND.COM (1987) Transient portion
